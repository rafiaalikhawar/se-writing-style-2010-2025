guiding dynamic symbolic execution toward unverified program executions maria christakis peter m ller valentin w stholz department of computer science eth zurich switzerland maria.christakis peter.mueller valentin.wuestholz inf.ethz.ch abstract most techniques to detect program errors such as testing codereviews andstaticprogramanalysis donotfullyverify all possible executions of a program.
they leave executions unverified when they do not check certain properties fail to verify properties or check properties under certain unsound assumptions such as the absence of arithmetic overflow.
in this paper we present a technique to complement partial verification results by automatic test case generation.
in contrast to existing work our technique supports the common case that the verification results are based on unsound assumptions.
we annotate programs to reflect which executions have been verified and under which assumptions.
these annotations are then used to guide dynamic symbolic execution toward unverified program executions.
our main technical contribution is a code instrumentation that causes dynamic symbolic execution to abort tests that lead to verified executions to prune parts of the search space and to prioritize tests that cover more properties that are not fully verified.
we have implemented our technique for the .net static analyzer clousot and the dynamic symbolic execution tool pex.
it produces smaller test suites by up to .
covers more unverified executions by up to .
and reduces testing time by up to .
compared to combining clousot and pex without our technique.
.
introduction modern software projects use a variety of techniques to detect program errors such as testing code reviews and static program analysis .
in practice none of these techniques check all possible executions of a program.
they often leave entire paths unverified for instance when a test suite does not achieve full path coverage fail to verify certain properties such as complex assertions or verify some paths under assumptions such as the absence of arithmetic overflow that might not hold on all executions of the path.
making such assumptions is necessary in code reviews to reducethecomplexityofthetask itisalsocustomaryinstatic permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa copyright held by the owner author s .
publication rights licensed to acm.
isbn .
.
.
.
deposit int amount if amount amount reviewdeposit amount else balance balance amount if balance suggestinvestment assert balance old balance figure c example illustrating partial verification results.
techniques that assume that the additiononline5doesnotoverflowmightmissviolations of the assertion on line .
we use the assertion to make the intended behavior explicit the oldkeyword indicates that an expression is evaluated in the pre state of the method.
balanceis an integer field declared in the enclosing class.
we assume methods reviewdeposit and suggestinvestment to be correct.
programanalysistoimprovetheprecision performance and modularity of the analysis and because some program features elude static checking .
that is most static analysessacrificesoundnessinfavorofotherimportantqualities.
automatic test case generation via dynamic symbolic execution dse also called concolic testing systematically explores a large number of program executions and thus effectively detects errors missed by other techniques.
however simply applying dse in addition to other techniques leads to redundancy when executions covered by dse have already been verified.
in this case the available testing time is wasted on executions that are known to be correct rather than on exploring previously unverified executions.
this redundancy is especially problematic when dse is used to complement static analyzers because static techniques can check a large fraction of all possible program executions and thus many or even most of the executions covered by dse are already verified.
method depositin fig.
illustrates this problem.
a reviewer or static analyzer that checks the implementation under the assumption that the addition on line does not overflow might miss violations of the assertion on line .
applying dse to the method tries to explore six different paths through the method there are three paths through the conditionals each combined with two possible outcomes for the assertion in addition to all the paths through the called methods reviewdeposit and suggestinvestment.
assuming that these two methods are correct only one of all these paths reveals an error namely the path that is taken when amountis between and and balanceis large ieee acm 38th ieee international conference on software engineering enough for the addition on line to overflow.
all other generated test cases are redundant because they lead to executions that have already been verified.
in particular if the called methods have complex control flow dse might not detect the error because it reaches a timeout before generating the only relevant test case.
to reduce this redundancy existing work integrates static analyses and dse it uses the verification results of a static analysis to prune verified executions from testing.
however existing combinations of static analysis and test case generation do not support analyses that make unsound assumptions.
they either require the static analysis to be sound and are thus of limited use for most practical analyses or they ignore the unsoundness of the static analysis and may therefore prune executions during dse that contain errors.
in particular they would miss the error in fig.
if the static analysis ignores overflow.
in this paper we present a novel technique to complement partial verification by automatic test case generation.
in contrast to existing work our technique supports the important case that the verification results are obtained by an unsound manual or automatic static analysis.
building on our earlier work we use program annotations to make explicit which assertions in a program have already been verified and under which assumptions.
these annotations can be generated automatically by a static analysis or inserted manually for instance during a code review.
we consider a code reviewer as a human static analyzer since like tools reviewers typically make simplifying assumptions.
the main technical contribution of this paper is a code instrumentation of the unit under test that detects redundanttestcasesearlyduringtheirexecutionandabortsthem reduces the search space for dse by pruning paths that have been previously verified and prioritizes test cases that cover more assertions that are not fully verified.
this instrumentation is based on an efficient static inference that propagates information about unverified executions up in the control flow where it may prune the search space more effectively.
it does not require a specific dse algorithm and thus can be used with a wide range of existing tools.
this paper goes beyond our previous work in three important ways it leverages partialverification results whereas our previous work reduced the test effort mainly for fully verified methods.
practical analyses typically do not achieve full verification for non trivial methods.
it demonstrates the effectiveness of our approach using an industrial analyzer and the sources of unsoundness it contains our previous work used an artificially unsound variation of dafny .
it provides a more substantial evaluation.
our technique works for modular and whole program verification and can be used to generate unit or system tests.
we present it for modular verification and unit testing here.
in particular we have implemented our approach for microsoft s .net static checker clousot a modular static analysis and the dse tool pex a test case generator for unit tests.
our experiments demonstrate that compared to classical dse our approach produces smaller test suites explores more unverified executions and reduces testing time.
outline.
we give an overview of our approach in sect.
.
sect.
explains how we infer the code instrumentation from partialverificationresults.
ourexperimentalresultsarepresented in sect.
.
we discuss related work in sect.
and conclude in sect.
.1void deposit int amount var a true if amount amount assume !a reviewdeposit amount else assumed nooverflowadd balance amount asa a a nooverflowadd balance amount assume !a balance balance amount if balance suggestinvestment assume !a balance old balance assert balance old balance verified a figure the instrumented version of the method from fig.
.
the dark boxes show the annotations generated by the static analyzer.
the assumedstatement makes explicit that the analyzer assumed that the addition on line does not overflow.
the verifiedannotation on the assertion on line expresses that the assertion was verified under this unsound assumption.
the two annotations are connected via the assumption identifier a which uniquely identifies the assumedstatement.
the light boxes show the instrumentation that we infer from the annotations and that prunes redundant tests.
.
approach inthissection wesummarizeanannotationlanguagethat we have developed in earlier work to express partial verification results and then illustrate how the instrumentation proposed here uses these annotations to guide dse toward unverified executions.
the details of the approach are explained in the next section.
.
verification annotations inordertoencodepartialverificationresults weintroduce two kinds of annotations an assumedstatement of the form assumed pasaexpresses that an analysis assumed property pto hold at this point in the code without checking it.
the assumption identifier auniquely identifies this statement.
in order to record verification results we use assertions of the form assert pverified a which express that property phas been verified under condition a. thepremise ais a boolean condition over assumption identifiers each of which is introduced in an assumedstatement.
specifically it is the conjunction of the identifiers for the assumptions used to verify p or false if pwas not verified.
when several verification results are combined for instance from a static analysis and a code review ais the disjunction of the assumptions made during each individual verification.
we record verification results for all assertions in the code including implicit assertions such as a receiver being non null or an index being within the bounds of an array.
we assume here that a static analyzer records the assumptions it made during the analysis which assertions it verified and under which assumptions.
we equipped microsoft s .net static analyzer clousot with this functionality .
among other unsound assumptions clousot ignores arithmetic overflow and thus misses the potential 145violation of the assertion on line of fig.
.
this partial verification result is expressed by the annotations in the dark boxes of fig.
the light boxes are discussed below .
the assumedstatement makes explicit that the addition on line was assumed not to overflow the predicate nooverflowadd can be encoded as equality of an integer and a long integer addition the verified annotation on the assertion on line expresses that the assertion was verified under this unsound assumption.
themeaningofverificationannotationsisdefinedinterms ofassignmentsandstandard assumestatements whichmakes the annotations easy to support by a wide range of static and dynamic tools.
for each assumption identifier we declare a boolean variable which is initialized to true.
for modular analyses assumption identifiers are local variables initialized at the beginning of the enclosing method line in fig.
for whole program analyses assumption identifiers are global variables initialized for instance during class initialization.
a statement assumed pasais encoded as a a p as illustrated on line .
that is variable aaccumulates the assumed properties for each execution of the assumedstatement.
since assumptions typically depend on the current execution state this encoding ensures that an assumption is evaluated in the state in which it is made rather than the state in which it is used.
an assertion assert pverified ais encoded as assume a p assert p as illustrated on line .
the assumestatement expresses that if condition aholds then the asserted property p holds as well which reflects that pwas verified under the premise a. consequently an assertion is unverified if ais false theassertionisfullyverifiedif aistrue andotherwise the assertion is partially verified.
.
guiding dynamic symbolic execution to reduce redundancies with prior analyses of the unit under test dse should generate test cases that check each assertion assert pverified afor the case that the premise adoes not hold because phas been verified to hold otherwise.
we guide dse toward such test cases by pruning test cases that cover verified executions.
moreover we prioritize testcases thatviolatemore assertionpremisesand thus are more likely to reveal an assertion violation.
test prioritization is important when dse is applied until certain limits for instance on the overall testing time are reached.
pruning redundant tests.
a test is redundant if the premise of each assertion in its execution holds in this case all assertions have been statically verified.
to prune redundant tests we compute statically for each program point a sufficient condition for every execution from this program point onward to be verified.
if this condition holds during the execution of a test case all subsequent assertions are definitely verified and thus the test can be aborted.
more importantly all other test cases that share the prefix of the execution path up to the abort and also satisfy the condition 1clousot is modular that is reasons about a method call using the method s pre and postcondition we assume here that the postconditions of reviewdeposit and suggestinvestment state that balanceis not decreased.can be pruned from the search space for dse.
if all assertions in the shared prefix are fully verified then these test cases are redundant.
otherwise they are not redundant according to the definition above but nevertheless guaranteed not to reveal an assertion violation.
assertions after the shared prefix are definitely verified violations of assertions in the shared prefix would be detected before aborting the former test case since dse tools treat assertions as branches and thus two executions of the same path satisfy or violate the same assertions.
both aborting and pruning of tests are achieved by instrumenting the unit under test with assumestatements.
they affect dse in two ways.
first when the execution of a test case encounters an assumestatement whose condition is false the execution is aborted.
second when an execution encounters an assumestatement its condition is added to the symbolic path condition ensuring that subsequent test cases that share the prefix of the execution path up to the assumestatement will satisfy the condition.
we instrument the unit under test by assuming at various program points a condition under which there maybe an execution from this program point onward that is unverified.
we call this condition a may unverified condition it is the negation of the condition that all executions from the point onward are verified.
note that this may unverified instrumentation is conservative.
it retains any execution in which the premise of at least one of the assertions might not hold.
therefore it does not abort or prune any tests that may reveal an assertion violation.
the example in fig.
has an assertion with premise a at the very end.
consider the program points on lines and .
at both points ais a sufficient condition for the rest of the execution of depositto be verified.
since we are interested in test cases that lead to unverified executions we instrument both program points by assuming the negation !a.
with this instrumentation any test case that enters the outer then branch is aborted since ais always true at this point which in particular prunes the entire exploration of method reviewdeposit.
similarly any test case that does not lead to an overflow on line is aborted on line which prunes the entire exploration of method suggestinvestment.
so out of all the test cases generated by dse for the uninstrumented depositmethod only the one that reveals the error remains all others are either aborted early or pruned.
note that the instrumentation aborts and prunes redundant tests more effectively if may unverified conditions are assumed earlier in the control flow because early assumptions may abort test cases earlier and share the prefix with more executions.
for instance if instead of the assumptions on lines and we assumed !aonly right before the assertion on line tests would be aborted late and no redundant tests would be pruned.
dse would generate the same test cases as if there were no prior verification results.
our previous work produces exactly this result which demonstrates that it provides only weak supportforpartially verifiedmethods.
toaddressthisproblem we propagate constraints that characterize unverified executions higher up in the control flow where they can be used to effectively prune redundant test cases.
prioritizing premise violations.
intuitively test cases that violate the premise of more than one assertion have a higher chance to detect an assertion violation.
to prioritize such test cases we devise a second instrumentation called 146verified unverified may unverified must unverifiedfigure may unverified and must unverified conditions.
the set of all executions is depicted by the largeellipse thegrayandwhiteareasdepicttheverified and unverified executions respectively.
executions that satisfy the may unverified conditions are ruled horizontally while those satisfying the mustunverified conditions are ruled vertically.
must unverified instrumentation we compute for each program point a sufficient condition for every execution from this program point onward to be definitely unverified.
if the conditionholdstheneveryexecutionfromtheprogrampoint onward contains at least one assertion and the premises of allassertions in the execution are false.
when the must unverified condition is violated it does not necessarily mean that the subsequent execution is verified and thus we cannot abort the test case.
therefore we instrumenttheprogramnotbyassumingthemust unverified condition but instead with a dedicated tryfirst statement.
this statement interrupts the execution of the test case and instructs dse to generate new inputs that satisfy the must unverified condition that is inputs that have a higher chance to detect an assertion violation.
the interrupted test case is re generated later after the executions that satisfy the must unverified condition have been explored.
this exploration strategy prioritizes test cases that violate all premises over those that violate only some.
suppose that the depositmethod in fig.
contained another assertion at the very end that has not been verified that is whose premise is false.
in this case the mayunverified instrumentation yields true for all prior program points since every execution is unverified.
in this case this instrumentation neither aborts nor prunes any test cases.
in contrast the must unverified instrumentation infers !aon line .
the corresponding tryfirst statement not shown in fig.
gives priority to executions that lead to an overflow on line .
however it does not prune the others since they might detect a violation of the unverified second assertion at the end of the method.
summary.
fig.
illustrates the may unverified and mustunverified conditions.
the set of executions that satisfy the may unverified conditions is a superset of the unverified executions whereas the set of executions that satisfy the mustunverified conditions is a subset.
the may unverified and must unverified instrumentations have complementary strengths.
while the former effectively aborts or prunes redundant tests the latter prioritizes those tests among the non redundant ones that are more likely to detect an assertion violation.
therefore our experiments show the best results for the combination of both.
.
condition inference our may unverified and must unverified conditions reflect whether the premises of assertions further down in the control flow hold.
in that sense they resemble weakest preconditions a may unverified condition is the negation of the weakest condition that implies that all premises furtherdown hold a must unverified condition is the weakest condition that implies that all premises do not hold.
precisely computing such conditions for instance via weakest precondition calculi abstract interpretation or predicate abstraction is too expensive for our purpose the overhead of computing the conditions precisely would efface the benefits of pruning tests.
therefore we use a rather coarseover approximation of may and must unverified conditions that can be computed efficiently and is sufficiently precise to prune and prioritize tests effectively.
wefirstabstracttheunitundertesttoanon deterministic booleanprogram whereallvariablesareassumptionidentifiers.
this step is an efficient syntactic program transformation.
the abstraction is sound that is each execution of the concrete program is included in the set of executions of the abstract program.
therefore a condition that guarantees that all premises hold or are violated in the abstract program provides the same guarantee for the concrete program.
the may unverified and must unverified conditions can then be computed efficiently using abstract interpretation of the abstract program over a simple abstract domain.
.
abstraction we abstract a concrete program to a boolean program where all boolean variables are assumption identifiers.
in the abstract program all expressions that do not include assumption identifiers are replaced by non deterministically chosen values which in particular replaces conditional control flow by non determinism.
moreover the abstraction removes assertions that have been fully verified that is where the premise is the literal trueor includes trueas a disjunct.
we present the abstraction for a simple concrete programming language with the following statements assumedstatements assertions method calls conditionals loops and assignments.
besides conditional statements and loops with non deterministicguards the abstractlanguageprovidesthe following statements initialization of assumption identifiers var a true updates to assumption identifiers a a where denotes a non deterministic boolean value assertions assert verified a where a negationslash true and method calls call mf where mfis a fully qualified method name and the receiver and arguments have been abstracted away.
note that we desugar assumedstatements into initializations and updates of assumption identifiers which allows us to treat modular and whole program analyses uniformly even though they require a different encoding of assumedstatements sect.
.
.
to abstract a program we recursively apply the following transformations to its statements an assumption assumed pas ais rewritten to an assumption identifier initialization var a true at the appropriate program point as discussed above and an update a a an assertion assert pverified ais transformed into assert verified a if ais not trivially true and omitted otherwise a conditional statement if b s0elses1is rewritten to if s prime 0else s prime where s prime 0ands prime 1are the results of recursively rewriting the statements s0ands1 a loop while b sis rewritten to while s prime where s prime is the result of recursively rewriting statement s 1471method deposit true var a true true if !a call account.reviewdeposit !a else true a a !a if !a call account.suggestinvestment !a !a !a assert verified a false figure the abstraction of method depositfrom fig.
.
the gray boxes light and dark show the inferred may unverified conditions.
the conditions that are used for the may unverified instrumentation are shown in dark gray boxes.
a method call r.m .
.
.
is rewritten to callmf where mfis the fully qualified name of m and assignments are omitted.
fig.4showstheabstractionofmethod depositfromfig.
.
the gray boxes light and dark show the inferred mayunverified conditions as we explain in the next subsection.
soundness.
the abstraction described above is sound that is each execution of the concrete program is included in the set of executions of the corresponding abstract program.
the abstraction preserves the control structure of each method but makes the control flow non deterministic which enlarges the set of possible executions.
all other occurrences of expressions in assumedstatements assertions andcalls arereplacedbynon deterministicvaluesoftheappropriate type which also enlarges the set of possible executions.
once all occurrences of variables have been replaced by non deterministic values assignments do not affect program execution and can thus be omitted.
.
may unverified conditions a may unverified condition expresses that some execution from the current program point onward may be unverified.
we compute this condition for each program point in two steps.
first we compute the weakest condition at the corresponding program point in the abstract program that implies that allexecutions are verified.
since the set of executions of the abstract program subsumes the set of concrete executions this condition also implies that all concrete executions are verified although for the concrete execution the computed condition is not necessarily the weakest such condition .
second we negate the computed condition to obtain a may unverified condition.inference.
to compute the weakest condition that implies that all executions from a program point onward are verified we define a predicate transformer wpon abstract programs.
if wp s r holds in a state then the premise of each assertion in each execution of statement sfrom that state holds and if the execution terminates rholds in the final state.
for a modular analysis such as clousot calls are encoded by asserting their precondition reflecting their side effects and assuming their postcondition since our abstract programs omit all information about program variables the latter two do not occur in the abstract program.
defining an inter procedural wpis of course also possible.
thus we define wpas follows wp assert verified a r a r wp a true r r denoting the substitution of abytrueinr and wp a a r r r .
the semantics of sequential composition conditionals and loops is standard .
the may unverified condition for a statement sis the negation of the weakest precondition may s wp s true in our implementation we compute for each program point the may unverified condition for the program fragment from this point onward.
the computation is done using backward abstract interpretation over a set of cubes that is conjunctions of assumption identifiers or their negations .
in the presence of loops we use a fixed point computation.
the light and dark gray boxes in fig.
show the mayunverifiedconditionsateachprogrampoint assumingmethods reviewdeposit and suggestinvestment have no preconditions .
the may unverified inference propagates meaningful information only up until the non deterministic update is reached which corresponds to the assumedstatement.
specifically on line we infer true because the abstraction loses the information that would be needed to compute a stronger may unverified condition.
so in return for an efficient condition inference we miss some opportunities for aborting and pruning redundant tests.
instrumentation.
since each execution of the concrete program corresponds to an execution of the abstract program we can instrument the concrete program by adding anassume cstatement at each program point where cis the may unverified condition at the corresponding program point in the abstract program.
as we explained in sect.
.
these statements abort redundant test cases and contribute constraints that guide dse toward unverified executions.
to avoid redundant constraints that would slow down dse we omit assumestatements when the may unverified condition is trivially true or not different from the condition at the previous program point as well as the assume false statement at the end of the unit under test.
therefore out of all the conditions inferred for the example in fig.
we use only the ones on lines and to instrument the program which leads to the assumptions on lines and of fig.
and guides dse as described in sect.
.
.
.
must unverified conditions a must unverified condition expresses that each execution from the program point onward contains at least one assertion and on each execution the premise of each assertion evaluates to false.
1481method deposit false var a true !a if !a call account.reviewdeposit !a else !a a a !a if !a call account.suggestinvestment !a !a !a assert verified a true assert verified false false figure the abstraction of a variant of method depositfrom fig.
that contains an additional unverified assertion at the end of the method see sect.
.
.
the gray boxes show the inferred mustunverified conditions.
the conditions that are used for the must unverified instrumentation are shown in dark gray boxes.
inference.
we infer the two properties that are entailed by a must unverified condition separately via two predicate transformers must assertandmust all.
ifmust assert s r holds in a state then each execution of statement sfrom that state encounters at least one assertion orterminates in a state in which rholds.
if must all s r holds in a state then the premise of each assertion in each execution of statement sfrom that state does not hold and if sterminates r holds.
both transformers yield the weakest condition that has these properties.
consequently we obtain the weakest must unverified condition for an abstract statement sas follows must s must assert s false must all s true must assertandmust allare defined analogously to wp see sect.
.
except for the treatment of assertions must assert assert verified a r true must all assert verified a r a r the definition for must assertexpresses that at a program point before an assertion property holds that is the remaining execution from that point on contains at least one assertion.
the definition for must allexpresses that the premise amust evaluate to false and that rmust hold to ensure that the premises of subsequent assertions do not hold either.
fig.
shows the abstraction of a variant of depositfrom fig.
that contains an additional unverified assertion at theend of the method see sect.
.
.
the light and dark gray boxes show the inferred must unverified conditions.
compared to the may unverified conditions the must unverified conditions are stronger that is information is usually propagated further up in the control flow.
whereas the unverified assertion at the end of this example causes the mayunverifiedconditionstobetriviallytrue themust unverified inference obtains conditions that can be used to prioritize test cases.
instrumentation.
to prioritize tests that satisfy their must unverified conditions we instrument the concrete program with tryfirst cstatements where cis the mustunverified condition at the corresponding program point in the abstract program.
this statement causes dse to prefer test inputs that satisfy condition c. more specifically when a tryfirst cstatement is executed for the first time it adds cto the path condition to force dse to generate inputs that satisfy condition c. note however that unlike the constraints added by assumestatements this constraint may be dropped by the dse to also explore executions where the condition is violated.
if during this first execution of the statement condition cis violated then the test case is interrupted and will be re generated later when condition c can no longer be satisfied.
so the tryfirst statement influences the orderin which test cases are generated but never aborts or prunes tests.
nevertheless the order is important because dse is typically applied until certain limits for instance on the overall testing time or the number of test cases are reached.
therefore exploring non redundant test cases early increases effectiveness.
pex supports primitives for expressing tryfirst cstatements easily as instrumentation.
alternatively other tools may encode them by placing additional branches into the codeandcustomizingthesearchstrategytopreferthebranch where cholds.
to avoid wasting time on interrupting tests that will be re generated later our implementation enforces an upper bound on the number of interrupts that are allowed per unit under test.
when this upper bound is exceeded all remaining tryfirst statements have no effect.
as illustrated by lines and in fig.
the mustunverified condition at some program points evaluates to false for all executions.
instrumenting these program points would lead to useless interruption and re generation of test cases.
to detect such cases we apply constant propagation and do not instrument program points for which the mustunverified conditions are trivially true or false.
moreover we omit the instrumentation for conditions that are not different from the condition at the previous program point.
therefore out of all the conditions inferred for the example in fig.
we use only the ones on lines and to instrument the program which prioritize test cases that lead to an arithmetic overflow on line as discussed in sect.
.
.
.
combined instrumentation as we explained in sect.
.
the may unverified instrumentation aborts and prunes redundant tests while the must unverified instrumentation prioritizes test cases that are more likely to detect an assertion violation.
one can therefore combine both instrumentations such that dse attempts to first explore program executions that must be unverified and falls back on executions that may be unverified when the former is no longer feasible.
149the combined instrumentation includes both the assume statementsfromthemay unverifiedinstrumentationandthe tryfirst statements from the must unverified instrumentation.
the tryfirst statement comes first.
whenever we can determine that the must unverified and may unverified conditions at a particular program point are equivalent we omit the tryfirst statement because any interrupted and re generated test case would be aborted by the subsequent assumestatement anyway.
.
experiments in this section we give an overview of our implementation and present our experimental results.
they show that compared to dynamic symbolic execution alone our technique produces smaller test suites covers more unverified executions and reduces testing time.
they also show that the combined instrumentation is more effective than the mayunverified or the must unverified instrumentation alone.
.
implementation we have implemented our technique for the .net static analyzer clousot and the dse tool pex .
our tool chain consists of four subsequent stages static analysis and verification annotation instrumentation mayunverified and must unverified instrumentation runtime checking and dynamic symbolic execution.
the first stage runs clousot on a given .net program which contains code and optionally specifications expressed in code contracts and instruments the sources of unsoundness and partial verification results of the analyzer using our verification annotations.
for this purpose we have implemented a wrapper around clousot that uses the debug output emitted during the static analysis to instrument the program at the binary level .
note that clousot performs a modular analysis and thus the verification annotations are local to the containing methods.
we have elicited a complete list of clousot s unsound assumptions by studying publications extensively testing the tool and having numerous discussions with its designers.
we encoded most of these assumptions with our verification annotations .
thesecondstageofthetoolchainaddsthemay unverified must unverifiedinstrumentation ortheircombinationtothe annotated program.
in the third stage we run the existing code contracts binary rewriter to transform any code contracts specifications into runtime checks.
we then run a second rewriter that transforms all the assumedstatements and assertions of the annotated program into assignments and assumptions as described in sect.
.
.
in the final stage we run pex on the instrumented code.
.
experimental evaluation in the rest of this section we describe the setup for the evaluation of our technique and present experiments that evaluate its benefits.
setup.for our experiments we used methods written in c from nine open source projects and from solutions to programming tasks on the rosetta code repository.
a complete list of the methods used in our evaluation can be found in christakis ph.d. thesis .
we selected only methods for which pex can automatically that is withoutuser provided factories produce at least one test case that passes the method s parameter validation between and methods per project or task .
in clousot we enabled all checks set the warning level to themaximum anddisabledall inferenceoptions.
inpex we set the maximum number of branches conditions and execution tree nodes to and the maximum number of concrete runs to .
without any instrumentation methods reach this maximum number of runs and are tested exhaustively which gives an indication of the complexity of the selected methods.
in our experiments we allowed up to test interrupts per method under test when these are caused by tryfirst statements see sect.
.
.
we experimented with different such bounds and on methods from the suite of methods.
for an upper bound of for the number of allowed interrupts per method dse strikes a good balance between testing time and the number of detected bugs.
we used a machine with a quad core cpu intel core i74770 .
ghz and gb of ram for these experiments.
performance of static analysis and instrumentation.
on average clousot analyzes each method from our suite in .
seconds.
the may unverified and must unverified instrumentations are very efficient.
on average they need milliseconds per method when combined.
configurations.
to evaluate our technique we use the following configurations uv unverified code.
stages and of the tool chain are not run.
pv partially verified code.
stage of the tool chain is not run.
may partially verified code instrumented with mayunverified conditions.
all stages of the tool chain are run.
stage adds only the may unverified instrumentation.
must partially verified code instrumented with mustunverified conditions.
all stages of the tool chain are run.
stage adds only the must unverified instrumentation.
may must partially verifiedcode instrumentedwith may unverified and must unverified conditions.
all stages of the tool chain are run.
stage adds the combined may and must unverified instrumentation.
fig.
shows the number of tests that each configuration generated for the methods categorized as nonredundant and failing as non redundant and successful or as redundant tests.
a failing test is a test that terminates abnormally whereas a successful one terminates normally.
teststhatterminateonexceptionsthatareexplicitlythrown by the method under test for instance for parameter validation are considered successful.
to determine the redundant tests we counted the tests in which the premises of all encountered assertions hold.
note that the figure does not include tests that are interrupted when a condition in atryfirst statement is violated since these tests are regenerated and counted later .
the results of dse alone that is of uv do not significantly differ from those of pvin terms of the total number of tests and the number of non redundant tests generated.
this confirms that the instrumentation from stage alone without the may unverified and must unverified instrumentation does not reduce the test effort significantly uv pv may must may mustnumber of tests configurationgenerated tests non redundant failing tests non redundant successful tests redundant testsfigure the tests generated by each configuration categorized as non redundant and failing as non redundantandsuccessful orasredundanttests.
may mustgenerates .
fewer tests but .
more non redundant tests than pv including additional failing tests.
for partially verified methods as we explained in sect.
.
.
note that this result does not contradict the results of our previous work .
first that work used a different static analyzer whose artificial sources of unsoundness affected fewer methods than clousot s leading to a much larger portion of fully verified methods.
second the improvements observed in our earlier work were mostly caused by exemptingfully verified methods completely from the test stage whereas here we apply stage to all methods and rely on our may instrumentation to prune the entire search space.
forthefollowingexperiments weuseconfiguration pvas the baseline to highlight the benefits of the may unverified and must unverified inference over our earlier work .
smaller test suites.
the may unverified instrumentation causes dse to abort tests leading to verified executions and to prune verified parts of the search space.
as a result dse generates smaller test suites.
fig.
shows that in total maygenerates .
fewer tests and may must generates .
fewer tests than pv.
the differences in the total number of tests for configurations without the mayunverified instrumentation are minor.
fig.
compares the total number of generated tests including aborted tests by pvandmayper method.
for many methods mayproduces fewer tests as shown by the negative values.
however for some methods maygenerates more tests than pv.
this happens when pruning verified parts of the search space guides dse toward executions that are easier to cover within the exploration bounds of pex for instance maximum number of branches .
more unverified executions.
although configurations mayandmay mustgeneratesmallertestsuitesincomparison to pv they do not generate fewer non redundant tests as shown in fig.
.
in other words they generate at least as many non redundant tests as pv thus covering at least as many unverified executions.
the must unverified instrumentation prioritizes test inputs that lead to more premise violations.
in comparison to the may unverified conditions the must unverified conditionsarestrongerandtheirinstrumentationisusuallyadded further up in the control flow.
as a result mustand may mustguidedsetocoverunverifiedexecutionsear 97change in percentage method idfigure change in total number of tests generated foreachofthe101methodsbyconfiguration mayin comparison to pv in percentage .
negative values indicate that mayproduces fewer tests.
lier and may allow it to generate more non redundant tests within the exploration bounds.
as shown in fig.
configuration mustgenerates .
more non redundant tests thanpvand .
more than may may mustproduces7.
resp.
.
morenon redundanttests .
bygenerating more such tests we increase the chances of producing more failing tests.
in fact mustgenerates .
more failingteststhan pvand4.
morethan may may must produces .
resp.
.
more failing tests .
musttypically generates more non redundant tests for methods in which clousot detects errors that is for methods with unverified assertions.
in such methods the mayunverified instrumentation is added only after the unverified assertions in the control flow if the conditions are nontrivial thus failing to guide dse toward unverified executions early on as discussed in sect.
.
.
shorter testing time.
to compare the testing time of the different configurations we considered only methods for which all configurations generated the same number of nonredundant tests.
this is to ensure a fair comparison for these methods all configurations achieved the same coverage of unverified executions.
this experiment involved out of the methods and the time it took for each configuration to test these methods is shown in fig.
.
as expected pruning verified parts of the search space with the may unverified instrumentation is very effective.
in particular configuration mayis .
faster and configuration may mustis .
faster than pv.
the difference between pvandmustis caused by a few outliers for which pvruns more than twice as long.
the mustinstrumentation affects the order in which execution paths are explored.
even though the same number of non redundant tests is generated the generated tests could exercise different paths leading to different constraint solving times.
note that fig.
does not include the time of the static analysis for two reasons.
first clousot is just one way of obtaining verification results.
second the goal of our work is to efficiently complement existingverification results with test case generation we assume that the static analysis is run anyway to achieve a more thorough scrutiny of the code.
recallthattheoverheadoftheinstrumentationisnegligible.
even though mayis overall much faster than pv there .
.
.
.
.
uv pv may must may musttime seconds configurationperformancefigure testing time for each configuration.
we onlyconsideredmethodsforwhichallconfigurations generated the same number of non redundant tests.
may mustis .
faster than pv.
uv pv may must may mustnumber of bounds configurationreached bounds max branches max stack max runs max solver time figure the exploration bounds reached by each configuration.
mayandmay mustoverall reach fewer bounds than pv.
weremethodsforwhichthetestingtimefor maywaslonger in comparison to pv.
this is the case when constraint solving becomes more difficult due to the inferred conditions.
in particular it might take longer for the constraint solver to prove that an inferred condition at a certain program point is infeasible.
fewer exploration bounds reached.
during its exploration dse may reach bounds that prevent it from covering certain possibly failing execution paths.
there are four kinds of bounds that were reached during our experiments max branches maximum number of branches that may be taken along a single execution path max stack maximum number of active call frames on the stack at any time during a single execution path max runs maximum number of runs that will be tried during an exploration each run uses different inputs but some runs are not added to the test suite if they do not increase coverage max solver time maximumtimethattheconstraintsolver has to find inputs that will cause an execution path to be taken.
fig.
shows the exploration bounds in pex that were reached by each configuration when testing all methods.may must and may mustreach the maxsolver time bound more often than pv.
this is because our instrumentation introduces additional conjuncts in the path conditions occasionally making constraint solving harder.
nevertheless configurations mayandmay mustoverall reach significantly fewer bounds than pv for instance the max stack bound is never reached by pruning verified parts of the search space.
this helps in alleviating an inherent limitation of symbolic execution by building on results from tools that do not suffer from the same limitation.winnerconfiguration.
configuration may mustgenerates the second smallest test suite containing the largest number of non redundant tests and the smallest number of redundant tests .
this is achieved in the shortest amount of time for methods with the same coverage of unverified executions across all configurations and by reachingthesmallestnumberofexplorationbounds .
therefore may musteffectively combines the benefits of both the may unverified and must unverified instrumentation to prune parts of the search space that lead only to verified executions as well as to identify and prefer test inputs that lead to unverified executions as soon as possible.
note that in practice these benefits should be independent of the exploration strategy in the underlying dse.
for methods whose exploration does not reach any bounds the order in which the tests are generated is obviously not relevant.
for the remaining methods we do not expect an exploration strategy to significantly affect how often our instrumentation is hit because clousot makes unsound assumptions for various expressions and statements and thus assumedstatements are spread across the method body.
we have confirmed this expectation by running the may mustconfiguration with different exploration strategies on methods for which exploration bounds were reached.
the differences between all strategies breadth first random search and pex s default search strategy were negligible.
threats to validity.
we identified the following threats to the validity of our experiments sample size weused101methodsfromninec projects and from solutions to programming tasks.
static analyzer for our experiments we used a modular as opposed to whole program static analyzer namely clousot.
moreover our experimental results depend on the deliberate sources of unsoundness and verification results of this particular analyzer.
note that there are a few sources of unsoundness in clousot that our tool chain does not capture for instance about reflection or unmanaged code.
soundly analyzed methods out of the methods contain no assumedstatements.
clousot reports no warning for of them and thus these methods are fully verified and our may unverified instrumentation prunes the entire search space.
however our results are not significantlyaffectedbyincludingthesemethods thedifference in running times with and without fully verified methods is minor e.g.
may mustis still .
faster than pv .
failing tests the failing tests generated by each configuration do not necessarily reveal bugs in the containing methods.
this is inherent to unit testing since methods are tested in isolation rather than in the context of the entire program.
however out of the methods validate their parameters and for methods no parameter validation was necessary which suggests that programmers did intend to prevent failures in these methods.
.
related work many static analyzers for mainstream languages such as havoc spec andesc java deliberatelymake unsound assumptions to increase automation improve performance and reduce the number of false positives and the annotation overhead for the programmer .
our tech152nique can effectively complement these analyzers by dse.
integration of static analysis and testing.
various approaches combine static analysis and automatic test case generation to determine whether an error reported by the static analysis is spurious and to reduce the search space for the test case generator.
for example check n crash is an automated defect detection tool that integrates the unsound esc java static checker with the jcrasher test case generator.
check n crash was later integrated with daikon in the dsd crasher tool .
similarly dyta integrates clousot with pex.
like our work all of these approaches use results from the static analysis to guide test case generation toward the errors reported by the static analysis and to prune parts of the search space during testing.
however in contrast to our work they ignore the unsoundness of the static analysis each assertion for which the static analysis does not report an error is consideredsoundly verified even if the analysis makes unsound assumptions.
consequently these approaches may prune unverified executions whereas our technique retains all executions that are not fully verified and therefore may reveal errors missed by the unsound static analysis.
sante uses a sound value analysis in combination with program slicing to prune those execution paths that do not lead to unverified assertions.
in contrast our work supports the common case that a static analysis is unsound.
several analyses combine over and under approximations of the set of program executions.
counterexample guided abstraction refinement cegar exploits the abstract counterexample trace of a failing proof attempt to suggest a concretetracethatmightrevealarealerror.
if however the abstract trace refers to a spurious error the abstraction is refined in such a way that subsequent verification attempts will not reproduce the infeasible abstract trace.
yogi switches between static analysis and dse both to prove properties and find bugs without reporting false positives.
specifically yogi uses two different abstract domains one not may abstraction for proving a property and one must abstraction for disproving a property.
the two abstractions are used simultaneously communicate with each other and refine each other for either finding a proof or a bug.
to obtainanover approximationofthesetofprogramexecutions these approaches rely on a sound analysis.
in contrast our work supports the common case that a static analysis is unsound that is neither over nor under approximates the set ofprogramexecutions theanalysismayhavebothfalsepositives and false negatives .
soundly verified executions and executions for which the analysis reports an error are handled similarly to work based on over approximations we prune soundly verified executions during test case generation and use an under approximation testing to find bugs and identify spurious errors among the executions for which theanalysisreportsanerror.
thenoveltyofourworkisthat we also handle executions that are verified unsoundly that is underunsoundassumptions.
ourannotationsmakethese assumptions explicit in other words they express which executions one would have to add to the set of analyzed executions for it to become a sound over approximation .
these executions are then targeted by an under approximation.
a recent approach starts by running a conditional model checker on a program and then tests those parts ofthestatespacethatwerenotcoveredbythemodelchecker for instance due to timeouts .
more specifically the modelchecker produces an output condition which captures the safe states and is used to produce a residual program that can be subsequently tested.
unlike an instrumented program in our technique the residual program can be structurally very different from the original program.
as a result its construction can take a significant amount of time as the authors point out.
furthermore this approach can characterize assertions only as either fully verified or unverified on a given execution path.
it is not clear how to apply this approach in a setting with static analysis tools that are not fully sound without reducing its effectiveness.
dynamic symbolic execution.
testing and symbolically executing all feasible program paths is not possible in practice.
the number of feasible paths can be exponential in the program size or even infinite in the presence of inputdependent loops.
existing dse tools alleviate path explosion using search strategies and heuristics that guide the search toward interesting paths while pruning the search space.
these strategies typically optimize properties such as deeper paths in depth first search less traveled paths number of new instructions covered in breadth first search or paths specified by the programmer .
for instance sage uses a generational search strategy in combination with simple heuristics such as flip count limits and constraint subsumption.
other industrial strength tools like pex alsousesimilartechniques.
asweexplainedinsect.
.
the benefits of our approach are independent of the exploration strategy in the underlying dse.
our technique resembles a search strategy in that it optimizes unverified executions prunes verified executions and is guided by verification annotations instead of properties like the above.
compositional symbolic execution has been shown to alleviate path explosion.
dynamic state merging and veritesting achievethisbymergingsub programsearches while rwset prunes searches by dynamically computing variable liveness.
by guiding dse toward unverified program executions our technique also alleviates path explosion.
in particular the may unverified instrumentation causes dse to abort tests that lead to verified executions and to prune parts of the search space.
moreover since our technique does not require a particular dse algorithm it can be combined with any of the above approaches by running them on a program that contains our instrumentation.
.
conclusion we have presented a technique for complementing partial verification results by automatic test case generation.
our technique causes dynamic symbolic execution to abort tests that lead to verified executions consequently pruning parts of the search space and to prioritize tests that are more likely to detect an assertion violation.
it is applicable to any program with verification annotations either inserted automatically by a possibly unsound static analysis or manually for instance during a code review.
our work suggests a novel way to combine static analysis and testing in order to maximize software quality and investigates to what extent unsound static analysis reduces the test effort.