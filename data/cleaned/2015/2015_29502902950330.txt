smt based verification of parameterized systems arie gurfinkel sei cmu usa university of waterloo canada arie.gur nkel uwaterloo.casharon shoham tel aviv university israel sharon.shoham gmail.comyuri meshman technion israel syurim gmail.com abstract it is well known that veri cation of safety properties of sequential programs is reducible to satis ability modulo theory of a rst order logic formula called a veri cation condition vc .
the reduction is used both in deductive and automated veri cation the di erence is only in whether the user or the solver provides candidates for inductive invariants.
in this paper we extend the reduction to parameterized systems consisting of arbitrary many copies of a user speci ed process and whose transition relation is de nable in rstorder logic modulo theory of linear arithmetic and arrays.
we show that deciding whether a parameterized system has a universally quanti ed inductive invariant is reducible to satis ability of non linear constraint horn clauses chc .
as a consequence of our reduction we obtain a new automated procedure for verifying parameterized systems using existing pdr and chc engines.
while the new procedure is applicable to a wide variety of systems we show that it is a decision procedure for several decidable fragments.
ccs concepts theory of computation !automated reasoning logic and veri cation veri cation by model checking keywords model checking parameterized systems safety veri cation invariant inference this material is based upon work funded and supported by the department of defense under contract no.
fa8721 05c with cmu for the operation of the sei a ffrdc and by eu seventh framework programme fp7 under erc grant agreements no.
vssc and no.
erc cog prime.
any opinions ndings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily re ect the views of the us dod.
this material has been approved for public release and unlimited distribution.
please see copyright notice for non us government use and distribution.
dm .
introduction many mutual exclusion algorithms bus protocols distributed algorithms telecommunication protocols and cache coherence protocols are designed to be run by an arbitrary number of threads or processes.
such protocols give rise to parameterized systems where the number of processes is a parameter of the system.
any value of the parameter de nes an instance of the parameterized system.
in this work we are interested in verifying safety properties of parameterized systems.
namely we would like to verify that the system is safe for any value of the parameter.
we consider parameterized systems where each instance consists ofnidentical processes executing asynchronously.
safety holds if every con guration that is reachable from an initial state via an execution of the system with any number of processes satis es the safety property.
due to the unbounded number of processes the set of possible con gurations of the system is in nite.
therefore parameterized systems are a special case of in nite state transition systems.
one of the most useful techniques for proving safety of such systems already advocated by floyd is using inductive invariants .
given a set of initial con gurations init a transition relation trand a safety property p we say that an invariant invisinductive forhinit tr piif invsatis es the following three conditions i init inv initiation .
ii inv p safety .
iii invis closed under tr i.e.
for every step of trwhich starts in a conguration satisfying inv invalso holds after executing tr consecution .
it is well known that pholds in all the congurations that are reachable from initvia steps of trif and only if there exists an inductive invariant for hinit tr pi in a su ciently powerful language .
our goal in this work is to nd inductive invariants that prove safety of a parameterized system for all values of the parameter .
to do so we model the initial con gurations init the transition relation tr and the safety property p of a parameterized system in rst order logic modulo theory and look for inductive invariants of the same form.
since we consider instances of the system with an arbitrary number of processes we cannot x the set of processes in the formulas describing init trandp.
likewise a typical inductive invariant will not refer to a xed set of processes.
we therefore model process identi ers as logical variables and allow for quanti cation over process identi ers both in init tr p and in the invariants.
we observe that the veri cation condition of such a system can be written as a set of constrained horn clauses chcs where the invariant is given by an uninterpreted permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november seattle wa usa c acm.
... .
predicate inv .
the chcs encode the initiation safety and consecution requirements and contain quanti ed constraints .
searching for an inductive invariant then amounts to solving the set of chcs i.e.
nding an interpretation ofinv that satis es all clauses.
to tackle this problem we focus our attention on universally quanti ed invariants oruniversal invariants in short where process identi ers are universally quanti ed.
despite their simplicity universal invariants are powerful enough to prove safety of many parameterized systems.
we show that under certain natural restrictions searching for a universal invariant with a xed number of universal quanti ers is reducible to the problem of solving quanti erfree chcs.
this reduction allows us to use existing chc solvers to nd universal inductive invariants.
as a consequence of our reduction we obtain a new automated procedure for verifying parameterized systems using existing pdr and chc engines.
our procedure is applicable to a wide variety of systems and is a decision procedure for several decidable fragments including petri nets.
interestingly in the case of one quanti er invariants our reduction produces owicki gries proof rule .
for a larger number of quanti ers our reduction generalizes owicki gries.
our main contributions are a a safety veri cation condition vc for parameterized systems in the form of chcs with quanti ed constraints.
a solution to the chcs is an inductive invariant that certi es safety of all instances of the system.
b inference of universally quanti ed solutions for the vc with a xed number of quanti ers.
we reduce nding a solution with kuniversal quanti ers to solving quanti er free chcs.
c a su cient condition for a system with in nitely many processes to soundly approximate a system with unbounded but nite number of processes.
d a procedure by combining our technique with an iterative search for a nite counterexample for verifying safety of parameterized systems which is complete for interesting decidable fragments.
e an implementation and initial experience verifying interesting parameterized protocols.
.
overview in this section we provide a short overview of our approach for safety veri cation of parameterized systems.
.
motivating example figure presents an example of a parameterized system which describes an arbitrary number of agents moving around asynchronously.
all agents run the code depicted in figure .
each agent has a unique identi er i and its own copy of the local variables denoted v .
agentionly changes its own copies of the local variables but its functionality also depends on the local variables of other agents via universal global guards.
in this example an agent starts in state choose.
it then computes some local desired location and changes its state to try.
from try it changes its state to wait and sets desired to itsnext location.
however this change only happens under a global universal guard which makes sure that the desired location is di erent than both thecurr andnext locations of all the agents with higher ids.
next the agent changes to move.
this transition is only enabled when next is di erent than both the curr and next locations of all the agents with smaller ids.
finally in move the agent changes its curr location to next.
note that the last two steps are not performed atomically rstlocal pc fchoose try wait moveg curr next desired location def proc i do pc choose desired pc try pc try 8j i j curr desired next desired next desired pc wait pc wait 8j j i next curr next next pc move pc move curr next pc choose def init i j pc choose curr next i6 j curr curr def bad i j i6 j curr curr figure collision avoidance .
the agent changes its state to move and only in the next step it actually moves.
the safety property requires that no collisions occur.
this example has two sources of in nity which make the veri cation task challenging.
first the locations are taken from an in nite domain.
second and more importantly the number of agents is unbounded.
fortunately the theory of linear integer arithmetic allows smt based veri ers to deal with the rst source of in nity.
however to tackle the second obstacle and verify the system for anynumber of agents we need to consider quanti ed invariants that prove correctness of all instances of the system simultaneously while also taking into account in nite domains of variables.
.
our approach we view the problem of nding an invariant for the parameterized system as the problem of nding a solution to a set of constrained horn clauses chcs which capture the initiation consecution and safety requirements of an inductive invariant.
in order to formulate the problem in this way we model the initial states the transitions and the bad states using rst order logic formulas.
this modeling reveals several subtle points that we discuss at length in section .
having formulated the set of chcs all that remains is to solve it.
however since the solution we seek is quanti ed we cannot use o the shelf solvers.
we therefore develop a specialized approach targeted at nding simple universal invariant .
by universal we mean that the invariant is denable by a formula with a pre x of universal quanti ers and by simple we mean that quanti er free body of the invariant does not use functions over the quanti ed variables.
for example if iis a quanti ed variable then i is not allowed in the body.
our solution strategy is to a x the number of quanti ers expected in the invariant b instantiate the quanti ers eagerly and c use existing solvers for inference of quanti er free safe inductive invariants to discover solutions of the reduced chc system.
in the rest of this section we demonstrate this strategy on two special cases of one and two quanti ers.
the general case is presented in section .
one quanti er.
when applying our search strategy for in339init i i v i1 i v i1 i v tr i v v0 i1 i v0 i1 i v i1 j v tr j v v0 j6 i i1 i v0 i1 i v i1 j v bad i j v figure vc t for one quanti er invariants.
init i j v init j i v init i i v init j j v i2 i j v i2 i j v tr i v v0 i2 i j v0 i2 i j v tr j v v0 i2 i j v0 i2 i j v i2 i k v i2 j k v tr k v v0 k6 i k6 j i2 i j v0 i2 i j v bad i j v figure vc t for two quanti er invariants.
variants with one quanti er i.e.
of the form 8i i1 i v on a systemt we obtain the set of constraints vc t depicted in figure .
vc t is based on a logical formulation of tthat uses quanti ed id variables in order to refer to arbitrary agents.
technically the initial states are constraint via a formula8i j init i j v which allows the initial constraint to refer to pairs of agents.
the transition relation formula has the form9i tr i v v0 which re ects the property that some agent imoves in each step and the bad states are constraint by9i j bad i j v .
in systems with universally guarded commands tr i v v0 is itself a quanti ed formula.
to complete the reduction to a set of chcs we additionally instantiate the quanti ers intr.
the details are presented in section which also addresses existentially guarded transitions.
vc t reduces the problem of nding a quanti er solution of a set of linear chc to the problem of nding a quanti er free solution of a set of non linear chc.
iftrdoes not update any shared variable as is the case in the collision avoidance example then is unnecessary and the set of chcs is linear.
relation to owicki gries proof rule.
vc t is a parametric extension of the owicki gries proof rule for partial correctness of concurrent programs .
in particular corresponds to invariant preservation under a step of a process and to preservation under an interference.
two quanti ers.
in practice a one quanti er invariant is useful only when tritself does not contain any global transitions i.e.
transitions guarded by quanti ed guards .
this is not the case for the example in figure and vc t does not have a solution.
we therefore extend our approach to two quanti er invariants of the form 8i j i i j v .
figure depicts the set of constraints vc t obtained by our reduction.
to simplify the presentation we again do not present additional instantiations that result from universal or existential guards intr.
these are explained in section .
similarly to vc the clause corresponds to local preservation of the invariant and the clauses and corre spond to preservation under interference.
as in vc t if trdoes not update any shared variables as is the case in the example in figure then is removed and the system vc t becomes linear.
vc t captures the common self vs other proof pattern in veri cation of parameterized systems.
that is it can express reasoning about arbitrary many processes that reduces to reasoning about the current process self and its environment as abstracted by some other process.
more re ned capturing of the environment is possible with additional quanti ers.
intuitively each additional quanti er corresponds to exposing an additional process in the environment.
by solving vc t an inductive invariant with universal quanti ers is found for the example in figure .
completeness.
while our approach is in general incomplete it is complete in interesting special cases.
speci cally we show that for parameterized systems that form monotonic transition systems such as petri nets iterating our approach with increasing number of quanti ers is guaranteed to terminate and nd an inductive invariant.
this matches known decidability results for such systems.
.
background in this section we give a brief overview of notation and other key concepts used in the paper.
we writexfor a vector of elements hx1 x mi xifor theith element of xandjxjfor the length of x. for a formula and a variable x we write x to denote that x is free in .
note that might have other free variables in addition to x. for a term aofarray sort we write a for theith element of a select a i in smt lib syntax anda for an array obtained from aby replacing the ith element by v store a i v in smt lib syntax .
for a vectora ha1 a miofarray terms we write a as a shorthand for the vector ha1 a m i. constrained horn clauses.
lettbe a rst order theory over some signature including equality and vandpbe sets of variables and predicates respectively.
a constrained horn clause chc is a formula 8v p1 x1 pk xk h x fork where is a possibly quanti ed constraint in t xi x v are possibly empty vectors of variables pi xi is an applicationp t1 t n of ann ary predicate symbol p2p for rst order terms ti andh x is either de ned analogously topior isp free i.e.
nopsymbols occur in h .
his called the head of the clause and p1 x1 pk xk is called the body.
a clause is linear if its body contains at most one predicate symbol and non linear otherwise.
for simplicity of presentation we usually omit the outermost universal quanti er.
unless otherwise speci ed we assume that the theorytis the standard smt combination of the theories of linear integer arithmetic and arrays.
a setcof chcs is satis able modulo a theory t with a canonical model mt if there exists an extension jof mtthat interprets all of the predicate symbols in psuch that each clause c2cis true underj.
in this case we say thatjis asolution ofc.
in practice we are interested int de nable solutions.
for simplicity of presentation we identify the solution with the fo formulas that de ne the interpretation of the predicate symbols in p when exist .
for example we say that the solution is p x y x y 340hproci def proc i dohgcmdsi hgcmdsi hguardi hcmdi guraded command j hgcmdsijhgcmdsi nondeterministic choice hguardi i v local guard j 9j .
i g i j v existential global guard j 8j .
i g i j v universal global guard hcmdi expr assignmnet to local variable jb expr assignment to shared variable j hcmdi hcmdi sequential composition figure syntax of a process i v denotes a formula over local v andshared v g i j v denotes a formula over local v shared v andlocal v denotes a local variable while bdenotes a shared variable expr denotes an expression over shared v andlocal v .
meaning that the solution is a fo model jsuch thatj p f x y jx yg.
universal horn clauses uhc extend chc by allowing universal quanti cation over predicates from pthat appear in the body.
satis ability and solution of uhc are de ned analogously to chc.
.
safety of parameterized systems in this section we present our syntax semantics and the safety veri cation problem of parameterized systems.
.
syntax we consider parameterized systems that consist of an arbitrary number of copies of a given process pwith a global initial condition initand a global error condition bad.
processes.
a processpis de ned by a set of variables vand a set of guarded commands with the meaning that these guarded commands reside in a loop where in each iteration one of the commands whose guard evaluates to true is chosen non deterministically and is executed atomically.
the process is parameterized by an identi er denoted i. figure presents the syntax of a process explained next .
variables.
as a generalization of several interaction modes between copies of the process we consider two classes of variables in p i local variables denotedlocal v and ii shared variables denotedshared v .
technically all copies ofpshare the same copy of the shared variables while each copy of phas its own copy of each local variable.
local variables are accessed via a process id e.g.
v orv .
we allow processes to read but not write local variables of other processes.
thus the local variables can be further sub divided into process private not read by others and distributed shared written by one read by others .
however this distinction is irrelevant for our purpose.
each copy of pinteracts with the other copies via shared variables or global guards that examine the local variables of other processes in a restricted manner as explained below.
universal and existential guards.
global guards are either existential or universal and do not explicitly refer to speci c process indices.
we assume a static topology and a linear order on the process indices where a process can only distinguish between the processes with greater or smaller indices.
formally a global guard has the form qj .
i i j v where q2f9 8g .
2f g and i j v is a formulaoverlocal v shared v andlocal v .
ifq the guard is called universal and if q the guard is called existential .
the relation .
refers to the order between the copies of the process induced by the linear topology.
an existential guard 9j .
i is satis ed by the ith copy of pi there exists a copy jofpthat satis es j .
i and whose local state together with the local state of isatis es .
similarly a universal guard 8j .
i is satis ed by the ith copy ofpi the local state of each of the copies jofp that satisfy j .
i satis es .
other guards are called local.
in particular if then else commands are written using local guards.
note that local guards can refer to shared variables.
we classify guarded commands as local orglobal based on their guards.
initial and bad states.
the description of a parameterized system includes a description of the initial states as well as a description of the bad states def init i j init i j v def bad i j bad i j v where i j v is a formula over shared v local v and local v .
informally the initial condition inithas to hold for all pairs of processes in the initial state while a bad condition is satis ed if some pair of processes satisfy bad.
.
asynchronous operational semantics each value n2nde nes an instance of the parameterized system which consists of ncopies ofp which are linearly ordered.
we refer to each process via an index i n .
the semantics of the instance is given by a transition system denoted tn p or simply tnwhenpis clear from the context de ned as follows.
letldenote the set of local states i.e.
lconsists of all possible valuations of the local variables local v and letg denote the set of global states which consists of all possible valuations of shared variables shared v .
the states of tnare given by con gurations.
a con guration oftnis a tuplec2ln gofnlocal states from l and a global state in g. indexnin the tuple denoted c represents the global state shared by all the processes and for i n theith index in the tuple c denotedc represents the local state of the ith copy of p. we denote the set of all con gurations of tnbycn i.e.cn ln g. the transitions of tn denoted trn correspond to the execution of guarded commands by the individual processes.
therefore trn sn i 0tri n where tri n cn cnis the set of transitions of process i. each transition of process i corresponds to the execution of a guarded command.
technically a guarded command induces the transition c c0 tri nifcsatis es the guard at i as de ned below c0 and c0 are updated based on the command and c0 c for everyj6 i. satisfaction of local guards by process iis de ned as usual csatis es a local guard atiif c c satisfy wherec is an interpretation for local v and c is an interpretation for shared v .csatis es a global guard qj .
i atiif q 8and for every j n s.t.j .
i c c c satisfy or q 9and there exists j n s.t.j .
i and c c c satisfy wherec c andc are interpretations of local v local v andshared v respectively.
341we de ne the set of initial con gurations of tn denoted ci n as the set of all con gurations c2cnsuch that c c c satisfy initfor every i j n and similarly we de ne the set of badcon gurations denoted cb n as the set of all con gurations c2cnsuch that c c c satisfy badfor some i j n .
parameterized systems as in nite state transition systems.
the semantics of a parameterized system de ned by pis the in nite state transition system t p c tr where c s n 1cnis the set of con gurations of all instances and tr s n 1trnis the set of transitions of all instances.
we lift the de nition of initial and bad states to t p similarly ci s n 1ci nandcb s n 1cb n. whenpis clear from the context we simply write tinstead oft p .
safety.
traces in a transition system are de ned in the usual way as sequences of states con gurations where each two consecutive states are connected by the transition relation.
a transition system e.g.
tnort issafeif there is no trace from an initial state to a bad state.
tis safe if and only if tnis safe for every n .
.
verification conditions for parameterized systems in this section we provide veri cation conditions for verifying the safety of a parameterized system in the form of sets of constrained horn clauses chc such that the veri cation condition is satis able i the system is safe.
further a solution of the chcs provides a witness of safety in the form of an inductive invariant.
we present two variants of the veri cation condition.
one calledn aware explicitly encodes the number of processes via a logical variable.
another called n oblivious ignores this number and can be thought of as encoding a system with in nitely many processes.
in the following we denote formulas used in the n aware formulation by f and formulas used in the n oblivious formulation by f!.
we write f to denote either of them.
logical variables.
given a process p to model the parameterized system using logical formulas we introduce a logical variable for every variable v2vand adopt the same notation for it.
the variables that correspond to v2local v are of sort array and the shared variables v2shared v inherit their sorts from the program.
for the n aware veri cation condition we add to the set of variables a variable n of sort integer that captures the arbitrary number of processes.
we denote by uthe set of variables which consists of bothvandnin then aware formulation and consists of v only in the n oblivious formulation.
we introduce variables e.g.
i j of sort integer to refer to process identi ers.
arrays conveniently represent con gurations of instances of the parameterized system with any number of processes.
transition relation formula.
as usual formulas representing transitions are de ned over two copies of the variables where the rst unprimed copy refers to the state before the transition and the second copy primed refers to the next state obtained after the transition.
we denote by v0 the copy of vused to describe the next state variables.
a next state copy of nis not needed since we consider static topologies.
therefore in the n aware formulation u0stands for v0 n .role formula local transition 9i lgrd i u trcmd i v v0 universal transition 9i 8j ugrd i j u trcmd i v v0 existential transition 9i 9j egrd i j u trcmd i v v0 initial condition 8i 8j init i j u error condition 9i 9j bad i j u figure quanti ed formulas representing transitions initial states and bad states of parameterized systems.
f stands for either f representing then aware formulation in which case ustands for n v or forf!
representing the n oblivious formulation in which case ustands for v. notation de nition lgrd i u range i i v ugrd i j u range i range j j .
i g i j v egrd i j u range i range j j .
i g i j v init i j u range i range j init i j v bad i j u range i range j bad i j v figure quanti er free formulas used in the logical formulation of parameterized systems.
in the n aware formulation range i i2 n while in then oblivious formulation range i .
we associate every command cmd with a quanti er free transition relation formula denoted trcmd i v v0 .
the formula trcmd de ned over i v v0 captures the semantics of the command when executed by process iwhile all other processes are idle.
that is trcmd i v v0 encodes the values of local v0 andshared v0 based on the update performed bycmd and implies that for every v2local v and for everyj6 i v0 v .
for example for the command next desired pc wait from figure trcmdis next0 next pc0 pc curr0 curr desired0 desired note thatndoes not appear in these formulas since commands do not explicitly refer to n. thus these formulas are the same both in the n aware and in the n oblivious case.
from the command formulas a transition relation formula is constructed for each guarded command of p describing the e ect of some process executing the guarded command.
the formulas for both the n aware case and the n oblivious case are listed in figure and figure .
formulas corresponding to local guarded commands have the form 9i i u u0 formulas corresponding to universal guarded commands have the form 9i 8j i j u u0 and formulas corresponding to existential guarded commands have the form9i 9j i j u u0 where is quanti er free.
the naware respectively n oblivious transition relation formula of the parameterized system denoted tr u u0 is the disjunction of these formulas over all guarded commands of p. initial and bad states formulas.
the initial and bad states formulas are shown in figures to .
they have the form 8i 8j init i j u and9i 9j bad i j u respectively where init i j u and bad i j u are quanti er free.
abusing notation we also refer to the quanti ed formulas above as init u and bad u respectively.
342note that the n oblivious formulation corresponds to removing the range constraints on id variables in tr initand bad.
for example it does not require that i2 n in the de nition of trand that that j2 n in the formulas for global guards.
intuitively the n oblivious formulas encode a transition system whose con gurations consist of in nite sequences of local states.
this can be thought of as letting in nitely many processes interact.
.
verification conditions for safety lettbe a parameterized transition system and let u init u tr u v0 bad u be de ned as above where f !ganduis de ned accordingly.
definition .
.
for 2f !g the veri cation conditionvc t fortis de ned via the following set of chcs over variables u u0and over the predicate inv u .
init u inv u inv u tr u u0 inv u0 inv u bad u then aware veri cation condition denoted vc t is obtained when anduis v n .
then oblivious veri cation condition denoted vc!
t is obtained when !
andu v. we omit twhen it is clear from the context.
note thatvc is de ned over a set of variables which includesn while the set of variables of vc!excludesn.
by splitting the disjunction in tr u u0 into multiple clauses and pulling out quanti ers when possible the veri cation condition vc t can be equivalently rewritten into the set of uhcs depicted in figure note that init and ugrd might contain universal quanti ers .
the following lemma shows that vc captures the safety of the parameterized transition system.
lemma .
.vc t is satis able i tis safe.
it is tempting to claim and is often implicitly assumed in other works that vc!
t issati tis safe.
unfortunately this is incorrect as demonstrated by the following examples.
example unsoundness .
consider the process p from figure .
initially all copies of the process are in locationi initial .
from location ithe process makes an unconditional move to location t trying .
if all other processes are in t the process moves to e error .
the bad states are a process in an error location.
clearly the system is unsafe for any number of processes.
however vc!is sat.
a satisfying interpretation for inv includes all in nite con gurations where a nite pre x consists of iandtlocations while the in nite su x which is of course nonempty consists ofilocations thus blocking the universal transition that leads to error.
as a side note we point out that in this example no interpretation for inv that satis es vc!is expressible by a universally quanti ed formula.
example unsoundness .
consider the process from figure .
the process has a boolean variable b. initially each copy of the process nondeterministically selects a boolean value forb.
if all processes have completed their selection and in addition8i j i6 j b b then process i can move to an error location.
if two processes reach an error location a bad state is encountered.
clearly tis unsafe since t2is unsafe whereas tnfor everyn 2is safe .
however vc!issat.
speci cally the solution is inv 8i j i6 j pc e pc e 8i pc i b 8i j pc e i6 j pc i b b these examples show that in the general case the naware andn oblivious variants of the veri cation conditions do not coincide.
speci cally the n oblivious formulation might be satis able even though the system is not safe.
one way to x the unsoundness is to restrict the system.
definition .
weak monotonicity .
we say that tisweakly monotonic if there exists a quanti er free formula i local v such that 8i init i j v j j local v and for every formula g i j v that appears in a global universal guard j local v j g i j v .
intuitively tis weakly monotonic if no universal guard can be blocked by a process in an initial state as witnessed by the formula j local v .
for example if processes have an initial location then i local v can state that process iis in its initial location.
weak monotonicity ensures that adding additional processes which remain in their initial state does not disable any global universal transition.
in particular if there are no universal guards then tis weakly monotonic.
note that the classical notion of monotonicity is stronger as it would require that adding additional processes in any local state would not disable any global universal transition which essentially forbids universal guards altogether.
lemma .
.
iftis weakly monotonic then vc!
t is satis able i tis safe.
proof.
consider a solution model jforvc!
t .
we need to show that tis safe.
assume to the contrary that it is unsafe.
then there exists n2nsuch that there exists an error trace in tn.
we construct a corresponding trace over in nite con gurations where each in nite con guration in the trace agrees with the corresponding nite one on the pre x of the con guration of length n and the su x of the in nite con guration corresponds to processes that have not moved since their initialization.
the existence of such a trace contradicts the fact that jsatis esvc!
t .
we construct the corresponding trace inductively.
the rst con guration consists of an arbitrary extension of the initial con guration that satis es the initial condition.
to extend the trace we consider the guarded command that is being executed.
if it is a local or an existential command then the same command is enabled also in the in nite con guration.
if it is a universal command then weak monotonicity ensures that it is also enabled in the in nite con guration where the additional processes remained in their initial state.
suppose tis safe.
to show that vc!issatit su ces to show that the system de ned over in nite congurations is safe.
assume to the contrary that it is not.
then there is a nite error trace which consists of in nite con gurations.
we use it to construct an error trace for tn for somen2n in contradiction.
to de ne the value nfor whichtnis unsafe we consider all the indices of processes that move along the trace as well as the indices of all the witnesses to existential guarded commands.
we de ne nto 343init u inv u inv u lgrd i u trcmd i v v0 inv v0 for every local guraded command inv u 8j ugrd i j u trcmd i v v0 inv v0 for every universal guarded command inv u egrd i j u trcmd i v v0 inv v0 for every existential guarded command inv u bad u figure veri cation condition for safety of a parameterized system.
def proc i do pc i pc t 8j6 i pc t pc e def init i j pc i def bad i j pc e figure parameterized system demonstrating unsoundness of vc!.
def proc i do pc i pc d b pc i pc d b 8j6 i pc d pc i b b pc e def init i j pc i def bad i j i6 j pc e pc e figure parameterized system demonstrating unsoundness of vc!.
be the maximum over all these indices.
with this choice of n we can now consider the trace which consists of the in nite con gurations truncated to con gurations of length n. this is a legal trace of tn as every local and universal guard that was enabled in the in nite con guration is clearly enabled in its sub con guration and every existential guard that was enabled is still enabled since the witness process is also present in the con guration.
corollary .
.
under the weak monotonicity condition vc t is satis able if and only if vc!
t is satis able.
note that the systems described in example example and figure are notweakly monotonic.
.
inferring universal inv ariants in this section we present an approach for determining whether the veri cation condition vc t has a model denable by a universally quanti ed fo formula or equivalently whether there is a safe inductive universally quanti ed invariant for t .
more precisely we consider models de nable by simple universally quanti ed formulas definition .
.
a formula u is asimplek universal formula if u 8i1 i k qf i1 i k u where qf is a quanti er free formula such that the variables i1 i k are not used as arguments of functions in qf.
our strategy for determining the existence of a simple universal invariant is to a x the number of quanti ersexpected in the invariant b instantiate the quanti ers eagerly and c use existing solvers for inference of quanti erfree safe inductive invariants to discover models of the reduced system.
the two special cases of one and two quanti ers were already discussed in section .
we now present the general case prove its soundness and investigate its completeness.
letk be the number of universal quanti ers in the simple universal invariant we seek.
that is we consider solutions where inv u is of the form inv u 8i1 i k invk i1 i k u to reduce the search for a quanti ed solution to a search for a quanti er free one we de ne an operator uk parameterized by a number k that takes a uhc system vc e.g.
vc vc orvc vc!
and returns a chc system uk vc such that uk vc has a quanti er free solution i vchas a simple k universal solution.
ukperforms three transformations restriction case splitting and instantiation which are described next.
we describe each transformation on each individual clause ofvc separately.
we show the case of the consecution clauses only.
the initiation and safety clauses are handled similarly when applicable .
let gcmd be a guarded command with the corresponding consecution clause inv u gcmd i inv u where gcmd is de ned as lgrd i u trcmd i v v0 8j ugrd i j u trcmd i v v0 egrd i j u trcmd i v v0 whenevergmcd is local universal or existential respectively see figure .
restriction.
the rst transformation replaces the predicate invby a predicate invkthat is universally quanti ed with kquanti ers.
formally the result of the restriction transformation of is 8i1 i k invk i1 i k u gcmd i invk i1 i k u clearly has a quanti er free de nable model i has a model de nable using kuniversal quanti ers.
case splitting.
recall that in the formula gcmd i the next state variables v0are indexed only by i whereas in a global guard the current state vvariables might also be indexed by another variable .
intuitively this captures that local variables of a process are changed only by its own moves.
the case splitting transformation splits the consecution premise for gcmd intok premises.
intuitively each new premise represents a di erent process making a transition and changing its state.
the rst kpremises consider the steps of the processes that the invariant refers to hence they can change local and shared variables while thek premise considers an interference from another different interfering process.
note that the interfering process can only a ect the shared variables.
formally case splitting transforms the clause into k clauses for j k 8i1 i k invk i1 i k u gcmd ij invk i1 i k u0 additionally if gcmd might update a shared variable casesplitting adds the k st interference clause 8i1 i k invk i1 i k u gcmd ik j kij6 ik invk i1 i k u0 the case split vchas a quanti er free solution i the restrictedvchas a quanti er free solution.
this follows from the logical equivalence between the two sets of chcs.
in particular whenever gcmd does not update any shared variables the interference clause is unnecessary.
intuitively this means that gcmd can cause no interference when executed by some other process.
case splitting is motivated by obtaining clauses with fewer free variables.
this is bene cial for the instantiation step performed next since the set of possible instantiations depends on the free variables.
instantiation.
the restriction and case splitting transformations result in a vcthat contains universal quanti ers in the body.
the instantiation transformation applies a nite eager instantiation to the remaining universal quanti ers.
the result is a quanti er free chc vcthat can be solved by existing chc solvers.
we begin with the following de nitions definition .
instantiation elements .
given a clausec the set of instantiation elements forc denoted c c is the smallest set xthat contains i the variables i1 i kwhenver inv k i1 i k u is the head of c ii every termxthat appears as index to some array logical variable corresponding to a local program variable in c and iii every termysuch thaty.
x orx.
y is incforx2x.
intuitively c c includes all variables that are used to index an array or compared with a variable already in c c .
note that in the n aware formulation and nare inc c .
definition .
full instantiations .
letk2nand letcbe a nite set of instantiation elements.
we de ne nite instantiations fi k c ckto be the set of all k tuples constructed from c. note thatfi k c also contains tuples in which the same term appears multiple times.
definition .
reduced instantiations .
letk2 n cbe a nite set of instantiation elements and be an arbitrary total order on terms.
we de ne reduced instantiationsri k c fhy1 y ki2ckj8i j i j yi yjg to be the set of all strictly increasing k tuples constructed fromc.note that the de nition of ri k c is parameterized by the choice of the term order .
for example if c fx ygand x y thenri c f x y g. the instantiations transformation is applied on each clause cof the vc that contains universal quanti ers.
all occurrences of 8i1 i k invk i1 i k u are replaced by v i2ri k c c invk i u and all other universally quantied formulas8i i u are replaced by their complete instantiations v i2fi jij c c i u .
the latter include a the transition relation formulas for universal guarded commands where only one variable is instantiated and therefore the full instantiations are the same as the reduced ones and b the initial states formula where pairs of variables are instantiated.
example .consider the consecution clause obtained fromvc!after case splitting.
if the clause corresponds to a universal guarded command we obtain from it the following clause inuk vc!
invk i1 i k v h ktrugcmd ij ih v v0 invk i1 i k v0 where tr ugcmd ij ih v v0 ih.
ij g ij ih v trcmd ij v v0 .
here reduced instantiations are used for invk resulting in one instantiation and full instantiations are used for the transition relation formula in fact the instantiation where ih ijcan be removed since it simpli es totrue due to the structure of tr ugcmd ih ij v v0 .
note that the obtained clause is linear .
from a consecution clause that corresponds to an existential command we obtain the following clause in uk vc!
i2ri k c c invk i v tregcmd ij x v v0 invk i1 i k v0 wherec c fi1 i k xg hence there are k instantiations inri k c c and tr egcmd ij x v v0 x. i j g ij x v trcmd ij v v0 .
in this case the obtained clause isnon linear .
lemma .
.
the fully and reduced instantiated vcs are equi satis able.
proof.
since the reduced instantiations are a subset of the full instantiations one direction follows trivially.
for the other direction consider a quanti er free solutionm x u for invkof the fully instantiated vc with x hx1 x ki.
to transform minto a solution hof the reduced instantiated vc we de ne y fy hy1 y kij81 i k j k yi xjg andh x u v y2ym y u .
that is yis the set of all k tuples constructed from x1 x k including tuples that have repetitions i.e.
yi yj andhis the re exive symmetric closure of m. we have that v x2ri k c h x u v x2fi k c m x u .
each conjunct of h x u corresponds to m y u fory2 y whose permutations are all part ofv x2fi k c m x u .
therefore each premise with the head m y u and body v x2ri k c h x u gcmd i follows by a proper renaming of the variables in y. hence his a solution of the reduced instantiated vc.
345if the instantiated vchas a quanti er free solution then the original vchas ak universal solution.
however the opposite direction is not true in general.
the reduced instantiations of invkreduce an exponential number of instantiations jc c jk jfi k c c j to jc c j k jri k c c j. in the typical case jc c j k o which makes the number of reduced instantiations jc c jo .
for example if c c fi1 i kg then the number of instantiations is just resulting in linear constraints.
this is the case for all the clauses that correspond to local guarded commands and for all the clauses that correspond to universal guarded commands in vc!
except for the interference clauses.
the interference clauses have an additional instantiation element resulting in k instantiations.
clauses corresponding to existential guarded commands also have additional instantiation elements.
example .having presented the general reduction for k universal invariants we now revisit the special cases of one quanti er and two quanti er invariants that were presented in section .
the sets of constraints displayed in figure and figure correspond to u1 vc!
andu2 vc!
respectively for the case where all transitions in thave local guards but may update shared variables .
universal and existential guards would be handled by u vc!
as demonstrated in example .
for example for a universal guarded command the constraint in figure would become inv i j v tr i j v v0 inv i j v0 for an existential command constraint would become inv i j v inv j k v inv i k v tr i k v v0 inv i j v0 in the rest of the section we establish the soundness and relative completeness of the transformation uk vc .
soundness.
the soundness of the transformation uk vc follows directly from the soundness of each of the steps.
this claim is robust it applies both to the n awarevc as well as to the n obliviousvc!.
lemma .
.
letvc be one ofvc orvc!.
ifuk vc has a quanti er free solution then vc has a solution with kuniversal quanti ers.
the proof of lemma .
is straightforward if h i u is a solution of uk vc then8i h i u is a solution for vc.
in the rest of this section we show one of our main results under the transformation uk n obliviousvc!soundly approximates n awarevc .
thus in many cases a simpler formulation vc!
i.e.
fewer instantiations is su cient.
lemma .
.
ifuk vc!
has a quanti er free solution thenuk vc has a quanti er free solution.
proof.
the proof is constructive.
given a quanti er free solutionh i1 i k v for invk i1 i k v inuk vc!
we construct a quanti er free solution s i1 i k n v for invk i1 i k n v inuk vc .sis de ned as follows s k j 1ij2 n h that is each identi er variable ij j k is restricted to the legal range of process identi ers.to show that sis a solution to uk vc we need to show that it satis es all clauses.
we prove the claim for the consecution premises the proof of the other clauses is similar .
consider a consecution premise cinuk vc with head invk i1 i k n v and let be an assignment that satis es the body.
if the value of at least one of i1 i k in is not in the range n then satis escvacuously.
assume all index variables are in range and let c0be the corresponding premise from uk vc!
.
we consider two cases a ccorresponds to a local or existential guarded command.
then any additional range constraints in its body are conjoined with the body.
since the body is satis ed by they all hold.
therefore under csimpli es to c0and the claim follows b ccorresponds to a universal guarded command this is the interesting case that was the source of unsoundness before .
here the body of calso contains conjuncts of the form j2 n j .
i g i j v where the range conditions are antecedents in implications.
however since in each such implication jis an instantiation element see de nition .
its range condition also appears as a conjunct in the body and by our assumption that the body is satis ed by so does the range condition.
further the instantiations where jis orndo not exist in c0 .
therefore under again csimpli es to c0and the claim follows.
lemma .
implies the following corollary that establishes thatvc!approximates vc under theuktransformation.
corollary .
.
ifuk vc!
has a quanti er free solution thenvc has ak universally quanti ed solution.
this allows us to verify the example in figure with vc!
even though it is not weakly monotonic.
relative completeness.
while the soundness of our approach does not rely on the restriction to simple universal invariants completeness does.
lemma .
.
ifvc has ak universal simple solution thenuk vc has a quanti er free solution.
the proof of this lemma follows from the fact that the syntax of processes ensures that init trand bad do not use identi er variables as arguments to functions.
this and the restriction to simple invariants is su cient to guarantee that our set of instantiations is complete.
.
safety verification safety veri cation of parameterized systems is in general undecidable.
in this section we extend the technique of section to a semi algorithm for the problem i.e.
our procedure might not terminate .
we show that for certain classes of systems e.g.
petri nets our procedure is in fact a decision procedure.
our procedure is shown in algorithm .
it combines a search for a simple k universal safe inductive invariant with a search for a counterexample in a k process instance of the system.
initially kis and it is increased in each iteration.
the search for a simple k universal invariant is done as described in section based on vc!.
the search for a counterexample is done by an o the shelf model checker.
in practice we use chc solver for both steps.
termination.
algorithm might not terminate due to several reasons.
first solving the chcs generated by ukmight 346k while truedo invk i1 i k v solve uk vc!
t ifinvk i1 i k v nullthen return inductive invariant found 8i1 i k inv i1 i k v res modelcheck tk ifres cexthen return counterexample found for kprocesses k k algorithm procedure for safety veri cation of parameterized systems.
be undecidable.
second even safety veri cation of a single instance of the system might be undecidable.
these issues are alleviated if we restrict ourselves to nite state processes.
however even if both inner steps of algorithm are decidable the procedure might not terminate.
the reason is that it is possible that a parameterized system is safe i.e.
no counterexample exists in any instance but it has no simple universal invariant.
in this case both searches performed by algorithm diverge.
fortunately there are classes of systems for which this phenomenon is impossible.
in such cases we obtain a decision procedure for safety veri cation.
an example of such a class of systems is when the parameterized system forms a monotonic transition system with respect to the subsequence ordering over con gurations .
in particular parameterized systems with local and existential transitions but no universal transitions meet the monotonicity condition .
an important subclass of such systems is petri nets.
.
implementation and ev aluation we have implemented a prototype of our technique in python.
the input is a description of a parametric system as a collection of guarded commands.
the output is an inductive invariant or a counterexample.
our input language is similar to the input language of cubicle and is more liberal than the syntax of figure used for the formal presentation in the paper.
given a parametric system our implementation computes a veri cation condition as a set of uhcs reduces it to chcs using the transformations described in section and solves them using spacer .
we have experimented with several small but challenging protocols including the collision avoidance protocol from figure dining philosophers and several variants of lamport s bakery mutual exclusion algorithm.
in all these cases we were able to successfully compute a universal inductive invariant in a few seconds.
further work is necessary to tune our implementation for more challenging benchmarks.
.
related work there is a large body of work on veri cation of concurrent distributed and parameterized systems.
we refer the reader to for a recent survey.
below we compare our approach only with the most closely related work.
our technique can be seen as an adaptation of the view abstraction of abdulla et al.
and in this similar to dynamic cut o of kroening et al.
invisible invariants of zuck et al.
and environment abstraction of clarke et al.
.
when our procedure converges the constructed invariant is a view abstraction of the original system wherethe size of the view is determined by the number of quantiers.
however the details of the technique are very different.
in particular our approach naturally extends to in nite state processes such as processes with integer local and shared variables without the need for a separate nitestate abstraction.
while such variables might not appear directly in the protocol they are convenient for veri cation purposes.
for example it is common to abstract the number of processes in a particular state by an integer counter which introduces a shared integer variable in the model.
our reduction from universal horn clauses to chc is inspired by the eager quanti er instantiation of bj rner et al.
.
our key insight is in the use of problem speci c restrictions to dramatically reduce the number of the necessary instantiations while maintaining completeness.
in particular we require exponentially fewer instantiations than .
in that our formulation is similar to that of hojjat et al.
.
in the paper we reduce veri cation of parameterized systems to chc satis ability and leave the choice of the chc solver open.
in the evaluation the resulting chcs are solved by a chc solver spacer .
this combination is similar to the mcmt approach and in particular to the barb algorithm of cubicle .
the key similarities and di erences are highlighted below.
spacer is a chc solver based on the generalization of the ic3 model checking algorithm .
similar to barb it combines abstract backward and concrete forward reachability computations.
unlikebarb the backward reachability is under approximated using model based projection and is generalized using interpolation and over approximation of forward reachable states .
this makes our algorithm less susceptible to the syntactic description of the model under analysis.
for example generalizations are not restricted to the predicates that are obtained by quanti er elimination in the computation of backward reachability.
as an added bonus when the problem is safe spacer always produces an easy tovalidate certi cate.
on the other hand cubicle requires a non trivial certi cate generation procedure .
so far we have used spacer as a black box.
we leave exploring the many possible optimizations of the spacer algorithm for this domain for future work.
.
conclusion in this paper we present an smt based approach for verifying parameterized systems systems consisting of asynchronous composition of nidentical processes.
we show that a veri cation condition of a parameterized system is captured by a rst order formula as a conjunction of constrained horn clauses with constraints in the combined theory of linear integer arithmetic and quanti ed theory of arrays.
since satis ability of such chcs is undecidable we develop a technique for inferring universally quanti ed solutions.
our approach yields a novel procedure for automated veri cation of parameterized system using existing smt based chc solvers such as spacer .
interestingly the constraints that we derive systematically match and extend the well known owicki gries proof rules to the parameterized setting.
while the paper is focused on asynchronous composition of identical process the main ideas extend to process groups and to synchronous composition.
.