study and refactoring of android asynchronous programming yu lin semih okur computer science department university of illinois at urbana champaign usa fyulin2 okur2g illinois.edudanny dig school of electrical engineering and computer science oregon state university digd eecs.oregonstate.edu abstract to avoid unresponsiveness a core part of mobile development is asynchronous programming.
android provides several async constructs that developers can use.
however developers can still use the inappropriate async constructs which result in memory leaks lost results and wasted energy.
fortunately refactoring tools can eliminate these problems by transforming async code to use the appropriate constructs.
in this paper we conducted a formative study on a corpus of widely used android apps to map the asynchronous landscape of android apps understand how developers retrofit asynchrony and learn about barriers encountered by developers.
based on this study we designed implemented and evaluated async droid a refactoring tool which enables android developers to transform existing improperly used async constructs into correct constructs.
our empirical evaluation shows that async droid is applicable accurate and saves developers effort.
we submitted refactoring patches and developers consider that the refactorings are useful.
i. i ntroduction according to a gartner report by more than billion apps for smartphones and tablets will be downloaded annually.
android is the dominant platform by 4x over the next largest platform and .7x over all the others combined .
previous studies have shown that unresponsiveness is the number one bug that plagues android apps.
to avoid unresponsiveness app developers use asynchronous programming to execute cpu bound or blocking i o operations e.g.
accessing the cloud database filesystem in background and inform the app when the result becomes available.
in order to make asynchronous programming easier android provides three major async constructs asynctask intentservice andasynctaskloader .asynctask is designed for encapsulating short running tasks while the other two are good choices for long running tasks.
however as our formative study on a corpus of shows asynctask is the most widely used construct dominating by a factor of 3x over the other two choices combined.
however if improperly used asynctask can lead to memory leaks lost results and wasted energy.
our previous study found that developers usually hold a reference to a gui component in an asynctask so that they can easily update gui based on task results.
however there are several instances in which the android system can destroy and recreate a gui component while an asynctask is running when a user changes the screen orientation or navigates to another screen on the same app switches to another app clicks the home button and navigates back etc.
if the asynctask is still running and it holds gui reference the destroyed gui cannot be garbage collected which leads to memory leaks.
on the other hand if an asynctask that finished its job updates a gui component that has already been destroyed and recreated the update is sent to the destroyed gui rather than the recreated new one and cannot be seen by the user.
thus the task result is lost frustrating the user.
moreover the device wasted its energy to execute a task whose result is never used.
as pointed out by many forums this problem is widespread and is critical for long running tasks.
intentservice andasynctaskloader do not have the above limitations because they do not hold a reference to gui and instead use a radically different mechanism to communicate with the gui.
to avoid the above problems of asynctask developers must refactor asynctask code into enhanced async constructs such as intentservice .
however manually applying this refactoring is non trivial due to drastic changes in communication with gui.
this is a challenging problem because a developer needs to transform a shared memory based communication through access to the same variables into a distributed style through marshaling objects on special channels .
first the developer needs to determine which objects should flow into or escape from intentservice .
unlike asynctask the objects that flow into or escape from intentservice should be serializable.
determining this requires tracing the call graph and type hierarchy.
second the developer needs to rewire the channels of communication.
whereas asynctask provides handy event handlers for callback communication intentservice does not.
intentservice and gui can only communicate through sending and receiving broadcast messages.
this requires developer to replace event handlers with semanticequivalent broadcast receivers which is tedious.
third the developer needs to infer where to register the broadcast receivers.
registering at inappropriate places can still lead to losing task results.
in this paper we first present a formative study to understand how developers use different android async constructs.
we analyzed a corpus of most popular open source android apps comprising .47m sloc.
to further put the study results in a broader context we then surveyed expert android developers.
the formative study answers the following questions rq1 how do android developers use asynchronous pro1gramming?
mapping the landscape of usage of async constructs in android is useful for researchers library designers and is educational for developers.
we found that of the studied apps use at least one asynchronous programming resulting in instances.
out of these asynctask is the most widely used.
rq2 how do android developers retrofit asynchrony into existing apps?
must asynchrony be designed into a program or can it be retrofitted later?
what are the most common transformations to retrofit asynchrony?
answering this question is important for software evolution researchers as well as tool builders.
we found widespread use of refactorings both from sequential code to async and from basic async to enhanced async.
we found the following code evolution scenario developers first convert sequential code to asynctask and those that continue to evolve the code for better use of asynchrony refactor it further into enhanced constructs.
rq3 how do expert developers interpret the disparity in usage of async constructs?
answering this question can provide educational value for developers.
we found that experts think asynctask is being overused at the expense of other enhanced async constructs and many inexperienced android developers do not know its problem.
they also suggest asynctask should only be considered for short running tasks i.e.
less than a second .
they suggest that the current guides and examples of intentservice are not enough and point out the need for refactoring tools to help unexperienced developers use and learn about the enhanced async constructs and the different style of communicating with the gui.
inspired by the results of our formative study we designed developed and evaluated async droid an automated refactoring tool that transforms shared memory into distributed style communication in the context of android async programming.
async droid refactors asynctask intointentservice .
we developed async droid as an eclipse plugin thus it offers all the convenience of a modern refactoring tool it enables the user to preview and undo changes and it preserves formatting and comments.
to use it the programmer only needs to select an asynctask instance then async droid verifies that the transformation is safe and rewrites the code if the preconditions are met.
however if a precondition fails it warns the programmer and provides useful information that helps the programmer fix the problem.
this paper makes the following contributions problem description to the best of our knowledge we are the first to propose solving the generic problem of converting shared memory into distributed style communication through refactoring.
we do this in the context of android async programming.
formative study to the best of our knowledge this paper presents the first quantitative and qualitative study to i map the asynchronous landscape of android ii understand how developers retrofit asynchrony and iii learn about barriers encountered by developers.
algorithms we designed the analysis and transformation algorithms to address the challenges of refactoring from shared memory communication as used in asynctask to distributed style communication as used inintentservice .
the algorithm determines the incoming and outgoing objects in from intentservice replaces event handlers with broadcast messages and receivers and infers where to register broadcast receivers.
tool we implemented the algorithms in async droid a refactoring tool built on top of eclipse refactoring engine.
evaluation we evaluated async droid empirically by refactoring asynctasks in popular open source android projects.
we evaluate async droid from three aspects.
first of the asynctasks pass the refactoring preconditions and with minor manual changes another asynctasks can pass preconditions.
this means the refactoring is highly applicable.
second async droid changed sloc in files in total determined that variables flow into or escape from intentservice moved methods into intentservice and marked types as serializable.
this task is very large and challenging to be performed manually butasync droid performs each refactoring in a few seconds.
this shows that async droid can save developer effort.
third we submitted refactoring patches in projects.
projects replied and considered our changes to be correct and they accepted refactorings.
this shows async droid is valuable.
the tool and subjects for our study and evaluation are available at yulin2 asyncdroid ii.
b ackground on android an android app consists of four types of components activity service broadcast receiver andcontent provider .
in this paper we focus on the first three components.
activities contain gui widgets and represent the gui screens that are shown to users.
services do not provide gui but perform invisible operations e.g.
playing music .
broadcast receivers provide a channel for activities andservices to communicate.
similar to many other gui frameworks such as swing and swt android uses an event driven model.
events in android include lifecycle events e.g.
activity creation user actions e.g.
button click menu selection sensor inputs e.g.
gps orientation change etc.
developers define event handlers to respond to these events.
for example oncreate handler is a lifecycle event handler and is invoked automatically by the os when an activity creation event occurs while onclick handler of a button is invoked when user clicks the button.
android framework uses a single thread model to process events .
when an application is launched the system creates aui thread in which it will run the application.
this thread is in charge of dispatching ui events to appropriate widgets or lifecycle events to activities.
it puts events into a single event queue dequeues events and executes event handlers.
by default all the event handlers defined in the above three components are processed by the ui thread one by one.
thus if any handler executes cpu or io bound operations such as network access the ui thread will be blocked and no further events can be processed.
this will lead to unresponsiveness.
to avoid unresponsiveness developers should exploit asynchrony and schedule long running tasks on background threads.
android provides three major async constructs asynctask intentservice andasynctaskloader .
2gui update background task gui onpreexecute background thread os library cpu io operations publishprogress onprogressupdate onpostexecute gui update gui update asynctask.execute asynctask a where is asynctask code executing?
background task onhandleintent gui background thread os library cpu io operations onreceive startservice registerbroadcast receiver sendbroadcast intent service broadcast receiver gui update b where is intentservice code executing?
fig.
flow of android async constructs a.asynctask asynctask provides a method for encapsulating asynchronous work.
it also provides four event handlers which are run in the ui thread.
the and these event handlers share variables through which the background task can communicate with ui.
figure a shows the flow of asynctask .
anasynctask is started by invoking execute method.
ui thread first executes onpreexecute handler.
then method is executed in a background thread .
while the task is executing it can report its progress to the ui thread by invoking publishprogress and implementing onprogressupdate handler.
finally ui thread executes the onpostexecute handler after finishes.
onpostexecute takes the task result as its parameter.
notice that user can also cancel an asynctask .
if a task is canceled oncancel handler will be executed instead of onpostexecute .
figure a shows a real world example from owncloudandroid app which is an android client for a cloud server.
logactivity starts a loadinglogtask at line .
the task reads some files in lines and returns a string line .
onpostexecute takes this string and uses it to update a text view line .
notice that loadinglogtask is declared as a non static inner class so it holds a reference to logactivity .
though asynctask is an easy to use construct it is ideally used for short tasks.
otherwise the three problems introduced in sec.
i memory leaks lost results wasted energy can occur.b.intentservice intentservice belongs to the service component but its encapsulated operations are executed in a background thread instead of ui thread.
figure b shows the flow of intentservice .
service is started when startservice is invoked.
then onhandleintent method is executed in a background thread.
unlike asynctask intentservice uses a distributed style programming to communicate with ui thread.
to get the task result the gui that starts the service should register a broadcast receiver.
after the task is finished intentservice sends its task result via sendbroadcast method.
once the registered receiver receives i.e.
the gui this broadcast its onreceive method will be executed on ui thread so it can get the task result and update gui.
figure b shows an equivalent implementation of logactivity using intentservice .
the background task from fig.
a is now put into onhandleintent method line .
the result is wrapped by an intent object which is marshalled and sent via broadcast lines .
intent is analogous to a hash map whose key is a string and value is a serializable object i.e.
implements java.io.serializable orandroid.os.parcelable .
it is the only medium through which different components e.g.
service andbroadcast receiver can exchange data.
finally onreceive unwraps the result and updates the text view line .
notice that to register a receiver the developer should provide a filter represented by a string to specify which broadcast the receiver can receive.
for example line defines a filter filter .
lines and use it to register receiver and send broadcast.
since intentservice is not affected by the destruction of the gui objects that started it it does not suffer from the problems introduced in sec.
i. thus it can be safely used for both short or long tasks.
c. asynctaskloader asynctaskloader is built on top of asynctask and it provides similar handlers as asynctask .
unlike asynctask asynctaskloader is lifecycle aware android system binds unbinds the background task with gui according to gui s lifecycle.
thus it can also solve the problems we mentioned in sec.
i. however asynctaskloader is introduced after android .
and it only supports two gui components activity andfragment .
iii.
f ormative study of android asynchrony we want to assess the state of practice async programming in open source android apps.
to obtain a deep understanding of asynchronous programming practices in android we answer three research questions.
we now answer each of these questions by first presenting the methodology and corpus and then the results.
rq1 how do android developers use asynchronous programming?
to answer this question we studied allasync constructs provided by the standard android libraries asynctask intentservice asynctaskloader and also the legacystyle java thread .
31public class logactivity extends activity private string mlogpath filestorageutils.getlogpath protected void oncreate ... loadinglogtask task new loadinglogtask view task.execute private class loadinglogtask extends asynctask private textview textview private exception exception public loadinglogtask textview view textview view public void onpostexecute string result if exception null textview.settext result else log.i exception.getmessage public string args try file file new file mlogpath ... return text catch exception e exception e return null a using asynctask1public class logactivity extends activity public static final filter logactivity receiver private loadinglogreceiver receiver private string mlogpath filestorageutils.getlogpath protected void oncreate ... receiver new loadinglogreceiver view this .registerreceiver receiver new intentfilter filter intent intent new intent this loadinglogservice.
class intent.putextra mlogpath mlogpath this .startservice intent private class loadinglogreceiver extends broadcastreceiver private textview textview private exception exception public loadinglogreceiver textview view textview view public void onreceive context context intent intent string text intent.getstringextra rv exception exception exception intent.getserializableextra exception if exception null textview.settext text else log.i exception.getmessage public class loadinglogservice extends intentservice private string mlogpath private exception exception public void onhandleintent intent intent this .mlogpath intent.getstringextra mlogpath intent result new intent logactivity.filter try file file new file mlogpath ... result.putextra exception exception result.putextra rv text sendbroadcast result catch exception e exception e result.putextra exception exception result.putextra rv null sendbroadcast result b using intentservice fig.
asynchronous code from owncloud android app.oncreate method starts a background task to read a log file and the result is shown in a textview .
a and b shows two semantic equivalent implementations using asynctask and intentservice respectively.
corpus .
to collect representative android apps we chose github .
to distinguish android apps in github we first searched all apps whose readme file contains the android keyword.
because we want to analyze recently updated apps we filtered for apps which have been modified at least once since july .
then we sorted all these apps based on their star count and gathered the top apps.
to make sure that these apps have android projects we check whether every app has at least one androidmanifest.xml file which every android project must contain in its root directory.
after all filters our code corpus has android apps comprising .69m nonblank non comment sloc as reported by sloccount .
methodology.
we built a tool async analyzer to automatically analyze the usage of async constructs in our corpus.
async analyzer uses eclipse api for syntactic analysis.
it builds an abstract syntax tree ast for each source file and traverses asts to gather the usage statistics for the four async constructs.
the analysis at the level of asts and not at table i usage of async constructs in the corpus instances app app asynctask thread intentservice asynctaskloader the textual level improves the accuracy in several ways.
first it is immune to noise generated by text that matches names of the async constructs e.g.
import statements comments variable names etc.
but does not represent an instance of an async construct.
second it correctly accounts for the ways in which developers instantiate async constructs via anonymous inner classes e.g.
myasynctask new asynctask ... and via class subtyping e.g.
class myservice extends intentservice .
results.
table i tabulates the usage statistics of async constructs.
the three columns show the total number of construct instances the total number of apps with instances of the construct and the percentage of apps with instances of the construct.
as we see from the table asynctask is the most popular async construct in our corpus based on the total number of instances.
however if we count the total number of apps that use at least one of these constructs then the legacy style thread is the most popular despite the fact that android already provides three special async constructs.
asynctaskloader andintentservice are not as popular as the other two.
rq2 how do android developers retrofit asynchrony into existing apps?
next we analyze how developers introduce async constructs into their apps.
we want to determine whether developers introduced async constructs when i implementing new features 4table ii how developers introduce asynctask and intentservice in the corpus type instances newly added asynctask refactor sequential code to asynctask refactor thread toasynctask newly added intentservice refactor sequential code to intentservice refactor thread tointentservice refactor asynctask tointentservice refactor asynctaskloader tointentservice i.e.
asynchrony was added to a new program element when writing code from scratch ii refactoring from existing sequential code iii refactoring from another existing async construct.
in order to be able to detect transitions between basic and enhanced async constructs we need to find projects where developers are aware that the enhanced constructs exist.
thus we use different corpora to study intentservice and asynctaskloader respectively corpus .
we collected random open source android apps from github comprising .54m sloc which use both asynctask andintentservice constructs in their latest snapshot.
corpus .
we collected random open source android apps comprising .24m sloc which use both asynctask and asynctaskloader constructs in their latest snapshot.
methodology.
in order to identify transitions we study not only the latest version of the code but also the first version where developers introduce async constructs.
to do this we automatically searched the commit history of our corpora through gitective api identified the commits that add import statements to asynctask asynctaskloader or intentservice .
after automatically finding commits that introduce these async constructs we manually inspected the versions before and after such commits in order to understand how these async constructs are introduced.
results.
tables ii and iii show how asynctask intentservice and asynctaskloader are introduced.
the results show that in many cases developers refactor sequential code to asynctask .
this observation confirms our previous findings .
however the refactorings for intentservice andasynctaskloader mostly come from other async constructs.
this shows the following code evolution scenario developers first convert sequential code to asynctask and those that continue to evolve the code for better use of asynchrony refactor it further into intentservice orasynctaskloader .
rq3 how do expert developers interpret the disparity in usage of async constructs?
to shed light into this question we conducted a survey with expert android developers.
methodology.
to find expert developers we used stackoverflow which is the pioneering q a website fortable iii how developers introduce asynctask and asynctaskloader in the corpus type instances newly added asynctask refactor sequential code to asynctask refactor thread toasynctask newly added asynctaskloader refactor sequential code to asynctaskloader refactor asynctask toasynctaskloader refactor thread toasynctaskloader programming.
in stackoverflow users are sorted by their points that they received from their answers for questions which are associated with some tags.
we contacted the top users for the android async tag and these people are the ones who answered the questions related to android async programming most.
on average each of them answered questions on stackoverflow.
we got replies from of them including the author of a popular android programming book .
results.
we asked three questions and summarized the experts answers below q1 why are there still lots of legacy style thread uses even though android provides three dedicated async constructs?
first thread construct has been around since the beginning and many android developers formerly developed java apps.
developers are very familiar with thread and they do not have time to learn something new thus they continue using it.
second thread is suitable for other scenarios such as parallelism and scheduled tasks.
q2 why are there many more asynctask uses than the other two enhanced constructs even though asynctask may lead to memory leaks lost task results and wasted energy?
they all agree that asynctask is being overused at the expense of the other two enhanced constructs.
as a main reason they invoke a historical account asynctask was advertised to the developers a lot in android documentation and it got a lot of good press early on .
on the other hand they thought many developers coming from desktop do not realize the async nature of the android memory management .
they also mention that asynctaskloader has been around only for a short time and is harder to implement and google has not provided production level examples of code that use intentservice andasynctaskloader .
as a guidance on android async programming they suggest thatasynctask orthread should only be considered for short tasks i.e.
less than one second .
for the work that will take more than a second developers should use intentservice .
q3 do you think that developers can benefit from a refactoring tool from asynctask tointentservice ?
they concluded that the technical challenges make the automation really hard it would be a very difficult task so the end solution may appear very complicated that would be quite a challenge to do automatically .
one also said that it may help beginner but senior developers still like using their 5preferred way of writing async and another said it would have to be very compelling for users to take their existing code and change it especially to something they do not already understand .
iv.
r efactoring async task to intent service based on our findings from sec.
iii developers tend to choose asynctask for android async programming.
however asynctask is not fit for long running tasks where developers should use intentservice orasynctaskloader .
inspired by these findings we propose async droid an automated refactoring tool that transforms shared memory into distributed style communication in the context of android async programming.
async droid refactors existing asynctask intointentservice .
it helps developers migrate the inappropriately used asynctasks tointentservices .
additionally by looking at transformations performed e.g.
using eclipse s preview refactoring feature developers can educate themselves on how to transform between asynctasks to intentservices .
a. refactoring challenges there are three main challenges that make it hard to execute the refactoring quick and flawlessly by hand.
first the developer needs to determine which objects should be transferred into intentservice andbroadcastreceiver and how to transfer them.
second the developer should establish channels to enable communication between intentservice and gui.
third the developer must register the receiver properly in order to receive the computation result from the established channel.
transfer objects from to intentservice .as shown in sec.
ii the non local objects required by asynctask are passed as method arguments or can be directly accessed as fields from the outer class.
however the objects that flow into and escape from intentservice have to be wrapped and sent via an intent object.
similar to distributed style programming objects transferred in this way are required to be serializable .
for example at line in fig.
a field mlogpath flows into method.
thus it should be transferred to intentservice during refactoring line in fig.
b .
determining objects transfer requires a nontrivial inter procedural analysis of the code the developer must trace i the call graph to figure out which objects flow into intentservice andbroadcastreceiver and ii type hierarchy to check if the objects can be serialized.
establish channels for communication.
asynctask provides four handlers that enable developers to interact with gui.
background task and handlers exchange data by accessing the shared memory.
however intentservice sends broadcast tobroadcastreceiver to communicate with gui.
thus the developer needs to rewire the channels of communication.
to achieve this one must split asynctask into intentservice andbroadcastreceiver .
splitting an asynctask includes moving the related fields and methods intointentservice andbroadcastreceiver which requires to trace the call graph.
additionally the developer has to write extra code for sending broadcast which makes the refactoring more tedious.where to register the receiver.
in order to receive the computation result from the channels the gui needs to register abroadcastreceiver .
a naive approach is to register at the original call site where the asynctask is created.
for example in fig.
a the task is created in oncreate at line .
while using intentservice in fig.
b the receiver is registered at the same place in oncreate line .
this approach only works when the original call site is already in a lifecycle event handler such as oncreate method.
lifecycle events are guaranteed to be triggered by os during gui recreation so the receiver can be registered automatically.
however if the call site is not in a lifecycle event handler the receiver cannot be registered unless the event is triggered again after gui recreation.
for example the call site can be in theonclick listener of a button so the receiver can only be registered when the user clicks the button.
if the gui containing the button is recreated while the background task is running the recreated gui cannot receive the broadcast unless the button is clicked again.
thus the developer also needs to infer where to register broadcastreceiver during the refactoring.
this is a non trivial insight for developers because online documents only show basic android asynchronous programming scenarios where this is not a concern.
b.the canonical form of asynctask code and refactoring preconditions a key insight in designing refactorings is that there is a canonical form for input code .
this canonical form adheres to the preconditions of the refactoring so that the result of the transformation is indeed correct.
this means that if the input code is not in canonical form it is necessary to transform into canonical form before performing the refactoring.
async droid has several preconditions which together dictate the canonical form which the source code must adhere to for a successful transformation p1 all variables that flow into or escape from are or can be marked as serializable.
this is required because such variables need to be transferred tointentservice and broadcastreceiver via marshalling unmarshalling.
p2 all the methods invoked in should also be accessible by intentservice .because most asynctasks are declared as non static inner classes they can call methods from the outer class.
since intentservice is not an inner class it needs to be able to call the same set of methods from the outer class so their visibility needs to be appropriate.
p3 the refactored task is directly extended from asynctask and is not subclassed.
this precondition prevents the refactoring from breaking the inheritance relation and affecting other asynctasks that are not refactored in the type hierarchy.
p4 anasynctask instance is only used when invoking asynctask.execute .for example if a task instance is used as a method argument or return value async droid halts the refactoring to avoid changing the design contract of the method.
on the other hand asynctask defines some methods that are not supported by intentservice e.g.
asynctask.cancel .
if these methods are invoked on the task instance a sync droid halts the refactoring.
6figure a is a valid example of a target program that meets all these preconditions thus it can be refactored by async droid .
we will see in sec.
v how many real world programs readily meet these preconditions.
c. the refactoring algorithm async droid takes the following steps to refactor an asycntask tointentservice .
analyzing transferred objects.
since andonhandleintent are semantic equivalent methods that enclose background task async droid needs to analyze to determine which objects should be transferred.
we define the target class incoming variables andoutgoing variables forintentservice as following definition target class tc the top level or static inner class that creates and starts the asynctask .
definition incoming variables iv the set of nonlocal variables flow into which have to be transferred to intentservice is ftc ftask args task lvtcm where ftcis the set oftc s fields when the asynctask is a non static inner class of tc ftask is the set of asynctask s fields that are initialized in its constructors or onpreexecute handler args task are the arguments of asynctask.execute method lvtcm is the set of final local variables declared in thetc s method where the task is created when the asynctask is an anonymous inner class of tc notice that collecting ivrequires inter procedural analysis since may invoke other methods defined intcor the asynctask .
definition outgoing variables ov the set of variables that escape from and need to be transferred from intentservice to broadcastreceiver is fm tc fm task rv where fm tcis the set oftc s fields that are modified in method fm task is the set of asynctask s fields that are modified in method and used in onpostexecute rv is the return value of method an example ofovis the return value text and a field exception in fig.
a lines .
fm tcandfm task are ovbecause intentservice and gui holds and operates on different copies of objects due to de serialization.
they should be written back in broadcastreceiver otherwise the modifications are lost.
note that there is no way to write back modified incoming lvtcm orargs task due to the communication mechanism of intentservice .
however we never find a case in practice where these two types of iv are modified.
a reasonable explanation is that modifying them in a background thread can introduce data races.
as mentioned in sec.
iv a the objects in the ivandov set are required to be serializable.
async droid traverses the type hierarchy and checks the serializability of an variable type based on its definition a type is serializable if it implements java.io.serializable and all of its fields types are serializable unless the field is transient .async droid also refactors a type to implement java.io.serializable if its fields conform to the definition but it has not implemented yet.
note that when refactoring a type to be serializable async droid also checks the serializability of all its subtypes to guarantee the transformation is safe and it only refactors the type defined in source code not libraries.
if any of the ivandovare not serializable or cannot be refactored the refactoring fails precondition p1.
generating and starting intentservice .first for the target asynctask async droid creates a corresponding intentservice class.
the method body of onhandleintent is moved from .
unlikeasynctask intentservice class cannot be a nonstatic inner class.
thus async droid creates it as an independent class.
async droid creates a field for each variables in ivandov.async droid adds statements to unwrap objects inivfromintent at the beginning of onhandleintent line in fig.
b .
at every exit of async droid creates an intent to carryov and sends it via broadcast lines to and to in fig.
b .
second since can invoke methods defined in asynctask ortc s methods async droid copies such methods into intentservice class.
note that async droid moves such methods instead of copying if is the only caller.
however if any of such methods are in library code and cannot be copied the refactoring fails p2.
finally async droid rewrites the call sites of asynctask.execute into startservice .
this includes creating the intent object to wrap the iv lines in fig.
b .
notice that in android starting a service or sending a broadcast requests a context object.
async droid checks if i tcitself is a subclass of context and ii tccontains a visible context field or local variable or a visible method that returns a context object.
async droid uses such context if there is any otherwise the refactoring stops.
creating and registering receiver.
asynctask communicates with gui through handlers.
however to receive task result from intentservice the developer needs to establish a channel by registering a broadcastreceiver on gui.
async droid rewrites the target asynctask intobroadcastreceiver class.
it keeps all the fields constructors and handlers defined in asynctask and rewrites onpostexecute handler into broadcastreceiver.onreceive lines in fig.
b .
async droid also inserts statements at the beginning of onreceive to unwrapov and writes them back to corresponding variables lines in fig.
b .
7as discussed in sec.
iv a to avoid losing task result during gui destroying and recreation the receiver should be registered in lifecycle event handlers.
async droid declares the receiver as a field oftc line in fig.
b .
it tries to move the receiver creation and registration into tc s lifecycle event handlers unless they are already there.
the following example shows an asynctask that executes in a button s onclick listener.
async droid register the receiver in oncreate lifecycle handler during refactoring instead of in the onclick listener void oncreate f button.setonclicklistener f fnew myasynctask ... .execute gg g broadcastreceiver receiver void oncreate f receiver new mybroadcastreceiver ... registerreceiver receiver ... button.setonclicklistener f fstartservice ... gg g note that atccan have multiple lifecycle event handlers.
async droid registers the receiver in the handler that is invoked first by the system e.g.
oncreate .
a receiver can be moved if and only if i the tccontains lifecycle event handlers ii all variables transferred to the receiver are still visible to it after moving and iii the variables used by receiver s constructor are not redefined in other lifecycle event handlers.
rule ii guarantees syntax correction while rule iii preserves the semantics of the refactoring.
async droid raises a warning when a receiver cannot be moved.
a filter is required when registering receiver.
the filter specifies which broadcast a receiver can receive.
async droid concatenatestcclass name and receiver name as filter name and uses it to register receiver and send broadcast lines and in fig.
b .
dealing with other asynctask handlers.
in addition to onpostexecute asynctask provides three other handlers.
note that the generated broadcastreceiver keeps all these three handlers.
for onpreexecute async droid inserts an invocation to this handler before starting the service.
foronprogressupdate async droid first rewrites the call site of publishprogress intosendbroadcast with the filter set to progressupdate void g void onhandleintent ... fintent.setaction progressupdate intent.putextra taskprogress arg sendbroadcast intent g then in onreceive async droid adds a branch to intercept the progressupdate broadcast and invokes onprogressupdate void onprogressupdate ... f...g void onreceive context context intent intent f... code from onpostexecute g void onprogressupdate ... f...g void onreceive context context intent intent f if intent.getaction .equals progressupdate f... onprogressupdate ... g else ... code from onpostexecute g async droid ignores oncancelled handler since android does not support canceling intentservice .
tasks that invoke asynctask.cancel fails p4.table iv nine popular android projects from github.
project name sloc asynctask intentservice owncloud android open311 android prey android client smssync opentripplanner ultimateandroid antennapod whatandroid textsecure total d. the refactoring implementation we have implemented the refactoring as a plugin in the eclipse ide on top of eclipse jdt and refactoring engine .
to use async droid the developer selects the method in the asynctask she wants to transform and then chooses convert tointent service option from the refactoring menu.
v. e valuation to empirically evaluate whether async droid is useful we answer the following evaluation questions.
eq1.
applicability how applicable is the refactoring?
eq2.
effort how much programmer effort is saved by async droid when refactoring?
eq3.
accuracy and value how accurate is async droid when performing a refactoring?
do developers think that the refactorings performed by a sync droid are useful?
a. experimental setup to answer the above questions we apply async droid on nine popular github open source android projects.
we selected projects that use asynctask predominantly.
table iv provides statistics about these projects.
we report the size in sloc the number of asynctask and intentservice instances that are used in each project.
for each project we applied the async droid to every asynctask except for the ones that have already been used inservice or retained fragment .
the lifecycle of such asynctasks is independent of gui s lifecycle so the they do not suffer from the problems described in sec.
i. we recorded several metrics for each refactoring.
to measure the applicability we counted how many instances met the refactoring preconditions and thus can be refactored.
we also analyzed the reasons why the remaining instances cannot be refactored by async droid .
to measure refactoring effort we recorded the number of input and output variables iv ov serialized types moved copied methods and moved receivers.
we also counted the number of files and sloc that are changed.
to verify the accuracy and value we manually examine the correctness of all the refactored code.
we also sent refactorings in projects to developers and let them judge the correctness and usefulness.
8table v results of applying a sync droid toasynctask in nine android projects.
project name applicability effort task objects passed conditionalpassed failed p1 p2 p4 iv ov movedmethodsserializedtypesmoved unmovedreceiversfilesmod.slocmod.
owncloud android open311 android prey android client smssync opentripplanner ultimateandroid antennapod whatandroid textsecure total iv incoming vars ov outgoing vars p1 allivandov can be serializable p2 all methods invoked by are accessible in intentservice p4 asynctask is only used when invoking asynctask.execute .
b. results table v shows the result of applying async droid on the asynctask s in our corpus of android projects.
applicability.
we totally refactored asynctask s in the nine projects.
columns and show the number of instances that pass and fail the refactoring preconditions.
there are 44asynctasks that pass the preconditions while fail the preconditions.
this is not a limitation of async droid but such cases can not be converted from shared memory to distributed style.
column shows another asynctasks that fail the preconditions.
however these instances can be refactored into canonical form with other well known refactorings such as demoting fields to local variables so thatasync droid can refactor them.
we show these instances in the conditional pass column.
we discovered two common transformations that convert code into canonical form.
first an unserializable object contained inivbut not inov can be converted into a local variable in as long as it is only used by unserializableobject object new unserializableobject ... void void unserializableobject object new unserializableobject ... object.method g second an ascyntask that is executed on a threadpool can be changed to execute on a plain thread since intentservice does not support threadpool s asynctask task new asynctask f...g task.executeonexecutor ... asynctask task new asynctask f...g task.execute ... for refactorings that conditional pass or fail the preconditions we analyzed which preconditions they violate.
columns to shows the number of instances that fail p1 p2andp4.
note that one refactoring can violate multiple preconditions.
the result shows most failed refactorings violate p1.
the main reason is that the unserializable types in ivorovare declared in third party libraries such as network or database .
asource to source transformation tool like async droid cannot transform third party binary code.
preconditions p2and p4are violated mainly due to methods cancel orexecuteonexecutor that are invoked either in thus failing p2 or on the task instance thus failing p4 .
since these methods are specific to asynctask andintentservice does not support them async droid cannot transform those cases.
for p3 we only find one violation in whatandroid so we do not show them in table v due to lack of space.
in terms of applicability async droid successfully refactored .
ascyntasks directly in nine projects.
there are .
ascyntasks that can also be refactored after converting them to canonical form.
this shows that async droid has a high level of applicability.
effort.
we estimate the effort based on the asynctasks that pass or conditional pass the preconditions.
in the last column we show the number of task instances that are created for the asynctasks .
task instances are created in total which means most asynctasks are used only at one place.
this observation confirms our previous study developers tend to tightly bind an asynctask to only one gui component.
columns and show the number of ivandovfor each project.
for the asynctasks there are 81ivand ov.
detecting them needs inter procedural analysis.
moreover wrapping them into intent object is also tedious.
column shows the methods that need to be moved or copied into intentservice .
we find methods that should be put into intentservice .
note that searching these methods also needs inter procedural analysis.
column shows the number of types that are refactored to be serializable.
on average each refactoring marks .
types as serializable.
however checking serializability is tedious since it requires traversing the type hierarchy for each field.
column shows the number of broadcastreceivers that are moved into lifecycle event handlers by async droid left side of slash and that have to be moved but async droid 9cannot move right side of slash .
notice that for each task instance async droid creates a corresponding receiver.
therefore it creates receivers in total are moved cannot be moved and the remaining are already in lifecycle event handlers.
for the unmoved receivers gui component can lose task result if gui destroying and recreation occurs during task running thus a sync droid raises a warning.
columns and show the number of files and sloc that are changed during the refactorings.
on average each refactoring changes .
files and sloc.
async droid helps developers change several sloc and such changes are non trivial.
thus we conclude that async droid can save developers effort.
accuracy and value.
by manually examining the refactored instances applied by async droid we determined that no compilation errors were introduced and the original semantics ofasynctask are preserved.
we also submitted refactorings in projects to developers through github pull request.
given the large size of changes in the patches that we submitted on average a patch touching files with additions and deletions we expected that developers might not reply as previous studies show that open source developers are more likely to respond to small patches.
despite this by may we received replies from projects.
whatandroid developers accepted the refactorings we submitted by saying this is an interesting set of changes asynctask can definitely be a pain to deal with and these tasks are a good fit for migration to intentservices and i will migrate over to intentservices .antennapod developers said their asynctasks are short most of our tasks read or write data from the database and should finish well under 100ms .
they think asynctasks work fine for their shortrunning tasks while intentservice makes the code more verbose.
this shows that async droid can produce accurate and valuable results.
vi.
r elated work performance analysis and testing for mobile apps.
liu et al.
empirically study performance bug patterns in android apps and conclude that executing long running operations in main thread is the main culprit.
berardinelli et al.
introduce a framework for modeling and analyzing the performance of context aware mobile software systems.
arijo et al.
propose a model based approach to analyze the performance of mobile apps in which they represent state changes by graph transformation.
muccini et al.
analyze the challenges in testing mobile apps including performance and memory testing.
lillack et al.
propose an approach to track load time configuration for android apps which can help with tuning performance of android apps.
yan et al.
propose a test generation approach to detect memory leaks for android apps.
however our work is complementary to previous approaches we assume that developers have already used the above techniques to detect responsiveness problems in their apps and now we enable developers to fix these problems via refactoring for async programming.
empirical study on concurrency refactoring and api usage.
li et al.
study and categorize bug characteristicsin modern software.
their result shows concurrency and performance related bugs can have a severe impact on software.
bavota et al.
investigate to what extent refactoring activities induce faults.
there are also several empirical studies on the usage of libraries or programing language constructs.
dyer et al.
analyzes 31k open source java projects to find uses of new java language features over time.
buse et al.
propose an automatic technique for synthesizing api usage examples and conduct a study on the generated examples.
our previous work studies the misuses of concurrent constructs in java and c .
our formative study on usage of async constructs is similar with other studies in the literature but on different topics.
in this work we study how developers use android async constructs.
refactoring for concurrency parallelism and asynchrony.
the refactoring community has been recently pushing refactoring technology beyond its classic realm i.e.
in improving software design into improving non functional qualities such as performance through parallelism and concurrency.
schafer et al.
propose a refactoring for replacing java built in locks with more flexible locks.
wloka et al.
present a refactoring for replacing global state with thread local state.
schafer et al.
examine whether classic refactorings can be safely applied to concurrent programs.
our group implemented several implemented several concurrency related refactorings to improve throughput .
our previous work presents a refactoring for android developers to extract synchronous code from ui thread into async code that inverts the flow of control.
in this work we go one step further and investigate a new scientific challenge converting between shared memory communication with the ui into a distributedstyle as encompassed in two android async constructs.
compiling shared memory to distributed memory.
several compiler techniques have attempted to translate shared memory program to distributed memory program.
however these techniques target high performance distributed computing.
in our work we presented a refactoring from a shared memory construct to a distributed style construct in the context of android asynchrony.
vii.
c onclusions asynchronous execution of long running tasks is crucial for the now ubiquitous mobile and wearable apps.
despite significant efforts to educate android app developers on how to use async programming developers can improperly use the primary construct asynctask which can lead to memory leaks lost results and wasted energy.
in this paper we take stake of the usage of async constructs in a corpus of widely used android apps.
we discovered that developers refactor their sync code into asynctask and some go further into using safer but more complex async constructs.
to aid developers when converting to these constructs we designed implemented and evaluated async droid .
it is a refactoring that converts from asynctask which uses a shared memory style of communication to intentservice which uses a distributed style of communication.
our empirical evaluation shows that async droid is applicable and accurate and it saves effort.
developers already accepted several refactorings generated by async droid which shows that it is valuable.
10viii.
a cknowledgments we would like to thank michael hilton mihai codoban kendall bailey shane mckee and sruti srinivasa for their feedback on earlier versions of this paper.
this research is partly funded through nsf ccf and ccf grants a seif award from microsoft and a gift grant from intel.