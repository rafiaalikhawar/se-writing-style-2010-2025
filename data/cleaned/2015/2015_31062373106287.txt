on the scalability of linux kernel maintainers work minghui zhou peking university key laboratory of high confidence software technologies ministry of education beijing china zhmh pku.edu.cnqingying chen peking university key laboratory of high confidence software technologies ministry of education beijing china qychen pku.edu.cn audris mockus university of tennesee knoxville tn usa audris utk.edufengguang wu intel opensource technology center shanghai china fengguang.wu intel.com abstract open source software ecosystems evolve ways to balance the workload among groups of participants ranging from core groups to peripheral groups.
as ecosystems grow it is not clear whether the mechanisms that previously made them work will continue to be relevant or whether new mechanisms will need to evolve.
the impact of failure for critical ecosystems such as linux is enormous yet the understanding of why they function and are effective is limited.
we therefore aim to understand how the linux kernel sustains its growth how to characterize the workload of maintainers and whether or not the existing mechanisms are scalable.
we quantify maintainers work through the files that are maintained and the change activity and the numbers of contributors in those files.
we find systematic differences among modules these differences are stable over time which suggests that certain architectural features commercial interests or module specific practices lead to distinct sustainable equilibria.
we find that most of the modules have not grown appreciably over the last decade most growth has been absorbed by a few modules.
we also find that the effort per maintainer does not increase even though the community has hypothesized that required effort might increase.
however the distribution of work among maintainers is highly unbalanced suggesting that a few maintainers may experience increasing workload.
we find that the practice of assigning multiple maintainers to a file yields only a power of 2increase in productivity.
we expect that our proposed framework to quantify maintainer practices will help clarify the factors that allow rapidly growing ecosystems to be sustainable.
ccs concepts software and its engineering software evolution maintaining software open source model programming teams permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
maintainer s workload maintainer scalability work distribution software evolution linux kernel open source ecosystem acm reference format minghui zhou qingying chen audris mockus and fengguang wu.
.
on the scalability of linux kernel maintainers work.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction free libre open source floss ecosystems in particular large ecosystems such as the linux kernel openstack docker or android represent critical computing infrastructure for our society.
such ecosystems involve contributions from various participants who are distributed over the world and are diverse in skills interests and needs.
typically a small core group does most of the work and coordinates a much larger group of peripheral participants .
the authority of this core group arises naturally as a result of their contributions to the project such as writing code themselves or reviewing patches contributed by others.
the linux kernel has a fairly sophisticated hierarchical organization within this core group of contributors referred to as maintainers.
subsystem maintainers are responsible for collecting the accepted patches do a final review and submit them to linus torvalds and main maintainer.
12understanding how such core groups function can shed light on linux and other large ecosystems.
in particular we would like to develop ways to measure the work maintainers do.
even though a substantial body of literature has characterized developers work what maintainers do has not been addressed.
maintainers are not regular developers unlike core groups in smaller projects some maintainers do not write code.
consequently it is not clear how to quantify the work of linux kernel maintainers rq1 .
maintainers are like editors in the publishing industry 1with burdensome responsibilities such as patches in a two week period and hundreds of emails a day .
the situation may deteriorate because a popular project often accumulates a rapidly expanding code base and contributor community.
as project grows 1events.linuxfoundation.org sites events files slides collab linux kernel v2.pdf esec fse september paderborn germany minghui zhou qingying chen audris mockus and fengguang wu its ability to sustain itself may come into question.
alarms over the number of major features that will need to be integrated in the future and the concern about the potential of the current maintainer population s ability to scale with the linux kernel have been raised.3this risk is exacerbated by the fact that almost everyone and every organization in the world relies on the linux kernel.
these concerns lead to more research questions.
how fast does the linux ecosystem grow rq2 ?
has the maintainers workload increased as the ecosystem has expanded rq3 ?
how is the work distributed among maintainers rq4 ?
in particular does the rule of work is done by of participants apply within the core groups of linux?
if so the linux ecosystem exhibits self similarity and the same phenomenon is repeated at different scales .
finally we inquire how well does the linux ecosystem scale rq5 ?
more specifically to what degree does adding development resources to a large project decrease productivity and cause diminishing returns to overall output .
according to its creator the key to the success of the linux is its modularity .
inside the system the modules are arranged in a structured hierarchy of dependence relations but modules at the same level can be developed independently from each other .
we therefore assume that the coping mechanisms that make ecosystem effective allow for adaptations that both are caused by and affect software architecture represented by module structure change over time and react to commercial involvement strategies.
observing differences among linux kernel modules and the changes that occur over time may lead to insights regarding what mechanisms may be at play.
to investigate our research questions we obtained the maintainer history for each file of the linux kernel and quantified each maintainer s workload by the number of files under maintenance the numbers of commits in the maintained files and the number of authors the maintainer was obligated to deal with.
we find that the amount of work had stabilized for the core modules but continued to grow in the periphery.
the number of maintainers grows faster than the amount of work thus the providing evidence against the hypothesized risk that maintainers would be overwhelmed by work.
the distribution of work among maintainers showed that a few maintainers accomplish most of the work for most modules confirming this aspect of self similarity.
finally the investigation of scalability showed that the practice of assigning multiple maintainers to a file yields only a power of 2increase in productivity e.g.
four parallel maintainers are needed to double the overall output .
in the remainder of the paper section presents the methodology we used section summarizes our findings section outlines limitations section discusses related work.
the conclusions are presented in section .
methodology we applied a mixed method approach to understand and quantify how the maintainers of the linux kernel the core of the linux operating system work.
we used qualitative methods to understand maintainer behavior and to design suitable measures for maintainers work rq1 .
maintainer activity data were then used to quantify growth of the system rq2 the growth of maintainers workloads rq3 the work distribution among maintainers rq4 and the scalability of maintainers work rq5 .
.
qualitative investigation the linux kernel has been extensively studied in the past we compiled further evidence from recorded artifacts in the version control system git project web pages and relevant websites.
we interviewed maintainers to address questions with no coverage in existing sources.
more specifically we searched for and read digital records and communicated with linux maintainers to understand project context and practices.
we designed metrics and validated results by combining and triangulating information from disparate sources.
in particular we went through the following procedure read the existing literature particularly on the linux kernel e.g.
to understand the project context and the studied practices.
inspect linux web sites looking for project related information such as the standard development process and the role of maintainers.
examine various blogs forums webzines like lwn.net and news websites like linux.slashdot.org .
search for relevant information such as the practices of maintainers in different subsystems and the trajectories of known maintainers.
target four maintainers and conduct interviews to understand how they do their work and the details of maintainer mechanisms that are difficult to obtain from artifacts such as whether the tasks and contributors in different modules vary from each other and how they vary.
also interview maintainers to validate the findings.
based on the information we gathered from various sources the following quote pithily summarized the maintainers work being a maintainer means you read patches from submitters handle questions from both developers and users about things related to the subsystem usually bug reports .
if a patch looks acceptable you test it if possible and apply it to the relevant git tree and push it publicly and notify the author that it was accepted.
every weekday these git trees get merged together in the linux next release and inevitably problems are reported and it is up to the maintainer to fix them when they affect their portion of the kernel.
4it suggests three measurable quantities that should affect maintainer effort.
.
the more files a maintainer oversees the more time and effort she will need to devote.
each file under maintenance may need to be considered when fixing a bug even if it is ultimately not changed.
.
more commits in the maintained files imply more effort for a maintainer all other things being equal .
in particular a maintainer is likely to review and approve changes made to the files she maintains.
she might also make the changes herself.
.
a maintainer s effort is likely to increase with the number of authors contributing to the maintained files.
a need for increased maintainer effort may be caused by too many cooks spoil the broth effect or the need to learn the different personalities of contributors and their contribution styles.
we therefore use the number of files maintained the number of commits committed to the maintained files and the number of authors in these commits during a time period month to characterize the amount of work for a maintainer.
this answers rq1.
28on the scalability of linux kernel maintainers work esec fse september paderborn germany .
quantitative analysis for our quantitative analysis we obtained and prepared data from the mainline git repository as described in section .
.
.
we selected seven modules of the linux kernel that play distinct roles in the architecture.
section .
.
discusses the differences among these modules.
we define the primary module for a maintainer used in several analyses in section .
.
.
the number of commits authors files maintainers and new joiners are used to quantify the growth of the linux kernel rq2 .
new joiners are identified in section .
.
.
the growth of each maintainer s workload rq3 is calculated in section .
.
based on the aforementioned metrics.
to understand the scalability of the maintainers work rq5 we fit regression models as introduced in section .
.
.
.
.
data preparation.
we cloned the mainline repository of linux kernel maintained by linus torvalds5in dec and jan respectively.
we used the data set for exploration and present our results based on the clone.
the linux kernel moved to git in the present study omitted the pre history of linux.
we took steps to clean and standardize the raw data for further analysis .
each observation is a change a commit may contain a group of related changes submitted to the mainline repository.
the repository records who authored the code when the code was committed and the name of the file involved such as drivers pci iova.c.
we also obtained the maintainer of the file as well as the module for that file.
from april the linux kernel has included a file named maintainers that contains information needed to discover the maintainer for each file.
the file records the name of the subsystem e.g.
ufs filesystem people who maintain it and the files associated with this subsystem and the status of this subsystem such as maintained meaning that someone actually looks after the file or supported meaning someone is actually paid to look after the file .
in addition a perl program get maintainer.pl uses the maintainers file to compute a file to maintainer mapping.
using these tools we obtained maintainers for every file in the linux kernel for every month since april .
.
.
modules used for this study.
modularity suits the characteristics of the open source production process .
linux kernel has a folder structure that partially reflects the architecture of its modules.
in particular folders exist at the first level some of these folders such as include documentation do not represent a module other folders such as tools scripts do not contain code that is a part of a running system.
we therefore focus on seven folders that implement the main features have the most changes and may be considered as modules as described in following passages.
arch each supported processor architecture is in the corresponding folder.
for example the source code for alpha processors is maintained in the alpha folder.
drivers this directory contains the code for the drivers.
each folder is named after each piece or type of hardware.
for example the bluetooth folder holds the code for bluetooth drivers.
fs inside this folder each file system s code is in its own folder.
for instance the ext4 file system s code is in the ext4 folder.
5git git.kernel.org pub scm linux kernel git torvalds linux.git the code in this folder controls the kernel itself.
for instance if a debugger needed to trace an issue the kernel would use code that originated from source files in this folder to inform the debugger of all of the actions that the kernel performs.
mm the memory management folder contains the code for managing the memory.
net the network folder contains the code for network protocols.
this includes code for ipv6 and appletalk as well as protocols for ethernet wifi bluetooth and other related functions.
sound this directory has sound driver code for audio cards.
.
.
defining maintainer s primary module.
to investigate phenomena across modules we must define which module a maintainer works on.
as explained in section .
.
we obtained maintainers for every file and every month since april .
two complications arose some files such as all files in the documentation or include folders do not belong to any module maintainers often work on multiple modules for example drivers and arch.
we used two approaches to address this problem.
first we report the statistics of the maintained or changed files based on the actual folders they were located in.
we thus referred to the module as the original module mod .
in the second approach we defined a primary module for a maintainer in order to calculate the average maintainer s workload for different modules.
we assume that the files may be modularized better not by actual folder structure but by the sets of files a maintainer is maintaining .
this definition is distinct from the architectural definitions derived from call flows or data flow graphs.
it is also distinct from the co change definition used to define modules in which multiple files are said to have the co change relationship if all of those files are changed together in the same commit.
we therefore first obtained the module for each maintainer month which had the most files maintained by that maintainer.
the module mod m m argmaxmod 0 f mod 0i f m m is the primary module for maintainer mat month m where fis a file i f m m is the indicator function for mbeing a maintainer of fduring month m. for each file we therefore can uniquely obtain mod 0based on its folder and for each maintainer mof the file we define mod mas the primary module of m. notably both modules may vary over time mod 0may change if the file is moved to another folder and mod m may change if the maintainer mchanges her set of maintained files.
.
.
identifying joiners and one time contributors.
for every author we define the first time she authored code in the commit history as her joining time.
we define any author who stayed with the project for less than one month from her joining day as a one time contributor otc .
our latest data was retrieved in jan .
we exclude joiners in the most recent year for the purpose of calculating otcs.
we thus avoid classifying developers who might commit within one year again as otcs see figure .
.
.
calculating workload.
the workloads or productivity of individual maintainers is complicated because over of the files in the linux kernel have more than one maintainer.
to adjust individual maintainer output we subdivided effort equally among all maintainers of a file.
to accomplish that we produce a weight for each file maintainer pair.
for example suppose maintainer m maintains f1with one other maintainer and f2with two other maintainers during month m. suppose that f1is modified twice 29esec fse september paderborn germany minghui zhou qingying chen audris mockus and fengguang wu table average and median monthly workload of a maintainer drivers arch fs net sound kernel mm files .
.
.
.
.
.
.
.
authors .
.
.
.
.
.
.
.
.
.
.
.
commits .
.
.
.
.
.
.
.
.
.
.
by one author and f2is modified six times by six different authors.
then maintainer m sadjusted effort during month mis1 6files 3commits and .
authors.
this measure preserves overall effort if we add all the observations for a month we obtain the total number of maintained files commits and authors for that month.
it also allows us to distribute effort among multiple modules by adding the relevant quantity for files in that module.
more formally the adjustment weight for a file fis obtained as wm f m m is a maintainer f or f durin month m table presents the monthly workload of a maintainer in different modules mod m .
each cell includes two values one is the average adjusted workload and the other is median adjusted workload.
unadjusted workload ignores the fact that multiple maintainers are working on the same file and is much higher.
for example for drivers the average adjusted number of files that a maintainer maintains is .
and unadjusted is .
.
we therefore only consider adjusted workload in the remainder of the paper.
table shows substantial differences statistically significant between average and median effort and among modules.
these differences which are explored in more detail in section may reflect how the ecosystem adapts to the variations in architecture commercial involvement and growing workloads.
.
.
regression for productivity scaling.
to understand the scalability of linux ecosystem we investigate how maintainer productivity scales when more maintainers are added to a set of maintained files.
to model maintainer productivity we used multiple regression on logarithm transformed data.
the predictor and the response have much less skewed distribution after the transformation.
furthermore the model lnoutput lnn maintainers .
.
.has a very simple interpretation with output n maintainers namely represents power by which the productivity scales as maintainers are added to a file.
we also included other major predictors that are likely to affect productivity identity of the maintainer and identity of the module.
whereas the individuals and modules greatly affect productivity we are not concerned with the estimates for these predictors they are nuisance parameters from our perspective and we adjust for that variation by including them as independent variables in our model.
results this section presents the results for rq2 .
we use mod mwhen it is necessary to associate a maintainer with a single module otherwise we use mod mod mandmod 0are defined in section .
.
.rq2 how fast does the linux ecosystem grow?
the linux kernel has grown from .
thousand lines of code in version .
to .
million lines of code in version .
.
in recent years the rise in popularity of the android operating system which includes the linux kernel has made the kernel the most popular choice for mobile devices rivaling the installed base of all other operating systems.
we explore how the linux ecosystem particularly the central parts represented by the seven modules defined in section .
.
grows over time in terms of commits authors files maintainers and new joiners.
figure presents the number of commits over time for different modules mod .
modules drivers arch net and sound have increasing numbers of commits.
the other three modules appear to have a decreasing trend in the last few years.
modules mm and kernel have the fewest commits for the entire period.
please note that different scales are used to emphasize similarities in trends among modules.
for example numbers for the drivers module are divided by but the numbers for the arch module are divided by three.
in figure the number of authors shows almost linear growth for drivers arch and net whereas the growth for the arch module slows in the final years.
modules kernel and mm do not seem to have an increase similar to their numbers of commits.
the number of maintained files shown in figure increases almost constantly for almost all modules.
the number of maintainers shown in figure also demonstrates a rapid increase for almost all modules.
the drivers module has particularly high increase in the number of files which may be explained by the popularity of linux with hardware vendors.
however the inflow of joiners appears to drop as shown in figure .
in particular it shows a constant stream of joiners of approximately year for drivers and an obvious decrease for almost all the other modules.
furthermore the rate of joiners even though it is declining appears to exceed that of leavers as modules drivers arch and sound show linear growth in the number of authors see figure .
in some modules however leavers appear to be balanced by joiners resulting in a constant or even slightly declining in net number of authors contributing per year.
figure depicts the overall growth of the linux kernel.
the numbers of commits authors files and maintainers appear to grow over time.
however the number of joiners does not appear to grow.
in summary the amount of work measured by commits and authors appears to have stabilized for the core modules e.g.
kernel and mm but continues to grow for the periphery e.g.
drivers .
some modules particularly drivers appear to contain most of the changes of the system.
for example in the most recent linux kernel .
released in december two thirds of the bulk of changes are drivers7 .
the number of maintainers and the number of maintained files grow faster than the number of commits or the number of authors.
because the number of files is the easiest to measure it may be the cause of concern expressed in public discussions.
the remaining two measures do not appear to be exploding and appear to expand much less than the number of maintainers.
it may be 30on the scalability of linux kernel maintainers work esec fse september paderborn germany commits over time calendar yearnumber2222222 7drivers arch fs net sound kernel mm .
figure numbers of commits in different modules authors over time calendar yearnumber22222222 7drivers arch fs net sound kernel mm .
figure numbers of authors in different modules files over time calendar yearnumber2222 7drivers arch fs net sound kernel .
mm .
figure numbers of maintained files in different modules maintainers over time calendar yearnumber 7drivers arch fs net sound kernel .
mm .
figure numbers of maintainers in different modules joiners over time calendar yearnumber2 7drivers arch fs net sound kernel mm 1figure numbers of joiners in different modules 4000growth of linux kernel calendar yearnumber commits authors files maintainers .
joiners .
figure overall growth of the linux kernel troubling to observe that the number of new joiners has been decreasing in recent years but the total number of authors has been stable or is still expanding at least for drivers.
rq3 has the maintainers workload increased as the ecosystem has expanded?
whereas the expansion as measured by commits and authors is contained within a few modules the linux kernel has continued to expand since both in terms of files and maintainers.
because both amount of work and number of workers have increased it is not clear whether the workload per maintainer has increased.
we calculated both average and median workload per maintainer on their primary module mod m for each year we also obtained monthly data which has similar trends but is more noisy to determine whether the maintainers work is evenly distributed among maintainers.
files.
as shown in figure the number of files does not appear to be increasing for a median maintainer with one to two files in kernel less than one in mm and up to for fs and arch.
the drivers module appears to be the only module with a slightly increasing number of files per maintainer.
modules arch and sound appear to be decreasing all the time.
the average number is more sensitive to extreme maintainers arch and sound are at the top with or more files per maintainer and decreasing and the rest of the modules have less than files per maintainer.
in particular kernel and mm are at the bottom with less than and that number seems to hold constant .
by comparing average and median workload 31esec fse september paderborn germany minghui zhou qingying chen audris mockus and fengguang wu per maintainer among the seven modules we can see that sound is at the bottom for a median maintainer but at the top for an average maintainer.
a further investigation shows that the sound module had maintainers in and maintainers in .
a few maintainers are much more productive than others the most productive jaroslav kysela and takashi iwai are the maintainers of the whole sound subsystem.
this implies that the work is not balanced among maintainers.
commits.
as shown in figure the average number of commits per maintainer per month appears to be stable over time for most modules mm kernel drivers net and fs .
however arch and sound have a clear decreasing trend ranging from to similar to the situation for the number of files.
again the mm module is at the bottom with two commits.
the median number of commits per maintainer per month is less than .
for all modules not shown .
this suggests what appears to be a rather moderate workload for a typical maintainer.
authors.
the yearly counts shown in figure show a rapid growth in the number of authors for drivers arch and net with the remaining modules stabilizing.
for example yearly numbers for drivers increased from in to in .
increase in maintainer numbers for drivers appears to be rapid also resulting in a flat curve of authors per maintainer in this module as shown in figure .
however the numbers for sound and arch seem to be decreasing in a manner similar to the inflow of commits.
author churn.
whereas the number of authors a maintainer must handle over a one year period stays relatively constant over time the effort may increase if each month brings new authors or the effort may decrease if the same authors contribute over long periods of time.
the number of authors per maintainer encountered over the last year appears to be much more stable five for drivers to seven for mm and fs for arch and kernel approximately for net and sound as shown in figure to reduce noise the monthly numbers were smoothed using a moving average with a window length of four .
the monthly numbers of authors per maintainer were several times lower 4 for drivers and arch 5 for fs net and sound and 7 lower for kernel and mm.
the high ratios suggest that author churn from month to month in mm and kernel may make the work of mm and kernel maintainers more difficult than the work in the modules with more stable groups of authors like drivers.
figure depicts the average workload of a maintainer in the linux kernel.
the average numbers of commits authors and files per maintainer appear to decline.
in summary the maintainers in different modules differ in their workloads.
most importantly a maintainer s workload does not seem to grow over time on the contrary it tends to decrease particularly in modules arch and sound.
the average values tend to be much higher than median values suggesting highly uneven distribution of the work investigated in rq4.
rq4 how is the work distributed among linux maintainers?
an average maintainer in the linux kernel does not appear to have an increasing workload despite rapid expansion of the ecosystem.
however the difference between the median and average workload suggests that a small team of maintainers does most of the work.
asimilar relationship was observed between the core and the periphery of project contributors measured by lines added issues fixed and commits .
it is not clear whether the same relationships would apply to the maintainers at the center of the project if their work were measured by number of files maintained and numbers of authors and commits for the maintained files.
if that relationship does apply it may suggest that the linux kernel ecosystem has self similarity i.e.
the system has invariants that are preserved under a scale transformation.
figure shows the fraction of maintainers who are responsible for of work files commits and authors plotted for each primary mod m. module drivers has the smallest core team of approximately of maintainers handling files for up to of the authors.
at the other extreme module mm deploys of the maintainers to do of the work.
the other modules have their own core teams containing between and of all maintainers.
this appears to support the conjecture of self similarity but the variations among modules especially the outlier represented by mm suggests that the self similarity may not be completely uniform and warrants a closer investigation.
in summary the distribution of work among maintainers appears to depend on the module.
in particular modules like drivers with well modularized maintainers follow the rule i.e.
of the people accomplish of the work but modules where maintainers are often also involved in other modules like mm have a much more even distribution of work.
such self similarity as in biological ecosystems would suggest that similar mechanisms must be at play in the context of linux kernel maintainers as at the larger scale of core peripheral contributors.
perhaps to be effective the community requires this rather extreme distribution of participants so as to be both predictable at delivering major features on time and to be able to incorporate a rich variety of small inputs from a much wider community.
rq5 how well does the linux ecosystem scale?
the growth of the features and the participants may challenge the core team of the linux kernel.
discussions swirl around in the forums and conferences about how to expand the maintainer model because as one critic complained as the workload has increased it has come to feel like things are getting much worse.
at the kernel summit linus torvalds said that he has come to like the group maintainer model where more than one person takes responsibility for a given subsystem.
however numerous developers were skeptical of the idea.
to understand whether or not maintainers work could scale by assigning more maintainers to the same files we fit models of maintainer productivity.
each observation represents a month denoted asm for a maintainer denoted as m and module denoted as mod .
the response variable was operationalized in three ways according to our three primary measures files authors and commits.
table presents the attributes of an observation used for the model.
to model number of files or authors or commits per maintainer we used the average number of maintainers over all maintained files as an independent variable as equation shows.
note that the adjusted numbers reflect the adjusted contribution of a maintainer.
32on the scalability of linux kernel maintainers work esec fse september paderborn germany mean files a maintainer maintained per month calendar year mean files2 7drivers .
arch fs .
net .
sound kernel .
mm .
median files a maitainer maintained per month calendar year median files2 7drivers arch fs net sound kernel .
mm .
figure average and median numbers of files maintained per maintainer mean commits a maintainer responsible for per month calendar year mean commits2 7drivers arch fs net sound kernel mm figure average number of commits per maintainer .
.
.
.
.
.
.
mean authors a maintainer responsible for per month calendar year mean authors2 7drivers arch fs net sound kernel mm figure average number of authors per maintainer 40evolution of maintainer s average workload calendar yearnumber files authors commits figure average workload per maintainertable an observation in the model nf files maintained by min module mod during month m nfadj files adjusted for the number of maintainers adjustment is done using weights defined in equation nauth authors for the maintained files of min module mod during month madjusted for the number of maintainers ncmt commits on the maintained files of min modulemod during month madjusted for the number of maintainers nmtr maintainers added over the files maintained bymin module mod during month m if it does not depend on the number of co maintainers that implies the effort scales linearly each added maintainer contributes as much as if she were the sole maintainer.
if adding additional maintainers to the same file diminishes productivity we would expect a negative exponent see section .
.
.
log nf adj nauth ncmt lognmtr nf mod m the results are presented in table .
in all cases adjusted r2is fairly high including .
.
and .
.
the coefficient of interest is close to .5and is statistically significant with an extremely small p value.
notably the arch module in contrast to the other modules has the most files and the mm has the fewest see table .
this means that maintainers for arch were more productive in terms of maintained files.
maintainers for drivers supervised the most commits and authors and maintainers for mm supervised the fewest.
a dual interpretation would be that the drivers module is the easiest to maintain and the mm module is the hardest.
the coefficients for lognmtr nfmean the power at which maintainer productivity increases as more maintainers are added to a file.
in particular for the number of files is .
for the number of commits is .
and for the number of authors is .
.
individual productivity decreases approximately byq nmtr nfbut the number of maintainers goes up so two maintainers can handle 2more files or commits or authors than one maintainer.
four maintainers can handle twice as much as one maintainer.
in summary adding more maintainers to a file yields only a power of increase in productivity thus four parallel maintainers 33esec fse september paderborn germany minghui zhou qingying chen audris mockus and fengguang wu 4ratio of monthly authors monthly maintainers calendar month from april 2009number2222222222222222222222222222222222222222222222222222222222222222222222222222222222222 7drivers arch fs net sound kernel mm 25ratio of yearly authors monthly maintainers calendar month from april 2009number22 7drivers arch fs net sound kernel mm figure ratio of number of authors to number of maintainers .
.
.
.6fraction of maintainers who are responsible for of files calendar yearfraction 7drivers arch fs net sound kernel mm .
.
.
.
.8fraction of maintainers who are responsible for of commits calendar yearfraction 7drivers arch fs net sound kernel mm .
.
.
.
.8fraction of maintainers who are responsible for of authors calendar yearfraction 7drivers arch fs net sound kernel mm figure fraction of maintainers who are responsible for of filestable results of modeling nfadj nauth ncmt adjusted r2 .
.
.
indicates p value .
nfadj std.
errornauth std.
errorncmt std.
error intercept .
.
.
.
.
.
lognmtr nf .
.
.
.
.
.
drivers .
.
.
.
.
.
fs .
.
.
.
.
.
kernel .
.
.
.
.
.
mm .
.
.
.
.
.
net .
.
.
.
.
.
sound .
.
.
.
.
.
are needed to double the overall output.
this suggests limits to the scalability that can be achieved by adding multiple maintainers to the same files.
mechanisms differentiating modules different maintainers contributions on the seven central modules of the linux kernel appear to differ in a consistent way.
a review of various artifacts and interviews with the maintainers of linux kernel suggests three mechanisms at play architectural features commercial support and maintainer s skill sets.
architectural features.
the seven modules under study were chosen for distinct roles they play in the architecture of the linux kernel.
we also use the core peripheral classification for example mm and kernel are core drivers and arch are peripheral.
as we have observed after more than two decades of evolution the core modules appear to have become mature and have less development activity and therefore fewer people looking after them.
however maintainers work on these modules tends to be widely distributed for example of the work is accomplished by of the maintainers in mm.
at the other extreme the peripheral modules like drivers keep growing to satisfy various needs of hardware manufacturers and therefore involve large numbers of commits authors and maintainers.
in drivers of the work is accomplished by only of the maintainers.
this highly uneven distribution of work suggests that some drivers maintainers may experience increasing workloads.
commercial support.
most linux code is currently developed by well paid engineers.9approximately of kernel developers whowriteslinux2015.pdf 34on the scalability of linux kernel maintainers work esec fse september paderborn germany table commercial support measures drivers arch fs net sound kernel mm nf nf all f. .
.
.
.
.
are paid according to a senior linux maintainer .
the most obvious and compelling reason is commercial interest of large and rich companies in the continued robust health of linux.
twenty years ago linux was the plaything of hobbyists and supercomputer makers today it powers everything from smartphones android to wireless routers to set top boxes.
this commercial interest may not be uniform for different parts of the linux kernel.
the drivers module for example has strong support from hardware manufacturers interested in increasing the market for their products.
however modules like mm do not appear to have features that would represent a business opportunity for numerous companies.
table lists the two measures that are likely to reflect commercial interests in the actual modules of the linux kernel mod the number of supported files nf and the fraction among all files nf all f .
the drivers module has the largest number of supported files followed by arch.
the mm module has none.
the biggest fraction of supported files is in arch followed by drivers.
this may partially explain the differences of growth in different modules.
in particular modules like mm do not have commercial backing and may have to seek contributions from the community.
breadth of maintainers reach.
at the functional level different modules do vastly different things and require vastly different skill sets to be able to contribute in a meaningful manner as one interviewee noted.
presumably most maintainers specialize in a single area.
this could be illustrated with two measures the fraction of maintainers who exclusively maintain their primary module mod m and the fraction of all maintainers of mod 0for whom mod mod m as shown in table .
let i m mod m f mod i f m m 1and otherwise where i f m m is defined in section .
.
.
the first fraction is then m modm mod m maintains onl ymodm i m mod m modm mod 0i m mod .
the second fraction is m modm mod 0i m mod mi m mod .
for modules sound kernel and mm no more than half of the maintainers primarily work on these modules whereas more than of the drivers maintainers work either primarily or exclusively on drivers.
a driver implementation is relatively self contained.6a single developer can add a new device driver and that addition requires minimal interaction with other kernel developers.
however the skill level required to work on kernel mm versus fixing up spelling or whitespace changes in drivers staging is vastly different according to another respondent.
the fraction of maintainers for whom kernel and mm are primary modules and who work exclusively on kernel and mm the first row of table may be relatively high because so few maintainers are capable of maintaining these modules and the ones that do may not have time for other parts of the kernel.
for example mm is a very tiny subsystem yet a very core one so the people working on it are much more specialized and experienced than normal driver developers.
meanwhile the tasks of driver development are often considered to representtable multi module maintainers drivers arch fs net sound kernel mm exclusive .
.
.
.
.
.
.
primary .
.
.
.
.
.
.
one time contributors over time calendar yearnumber 7drivers arch fs net sound kernel mm figure number of otcs in different modules lower entry barrier for newcomers.10our models of productivity in rq5 support the view that the drivers module is the easiest from the maintainers perspective as well it is the easiest in terms of commits and authors and the second easiest after arch in terms of files maintained.
figure shows that the mm module has the fewest otcs each year it has fewer than ten with kernel having fewer than twenty whereas the drivers module has otcs each year mod .
in summary each module implements different technical features and may attract different groups of contributors with distinct profiles unique skill sets and particular commercial interests.
the ecosystem uses community support for central tasks and central code but the modules of the architectural periphery are most effectively supported by commercial entities except for the kernel module .
the ecosystem grows primarily because commercial entities add code to the drivers module the community resolves conflicts in core modules such as mm.
other systems may learn from these strategies to adapt and scale their efforts e.g.
to distribute their resources based on architectural features and to utilize commercial support and community strength on different parts of the system.
limitations we used the git repository of the linux kernel to reconstruct past versions of the maintainers file and associated scripts we obtained a list of maintainers for each file.
only individuals explicitly labeled as maintainer were considered.
people who do not want their names to appear in the maintainers file are excluded.
further we unified multiple identities for many of the maintainers and authors based on email login and full name some of these identifications may have been erroneous.
our approach may not capture all ways in which maintainers may spend their effort.
for example the participation in discussion groups was not considered.
because we considered only the mainline repository of the linux kernel a large number of patches that did not gain acceptance into the mainline repository were excluded .
reviewing and rejecting 35esec fse september paderborn germany minghui zhou qingying chen audris mockus and fengguang wu these patches consume maintainers effort even though they are not accepted into the mainline repository.
however according to one interviewee it s easier for the maintainer to not accept your code at all.
to accept it it takes time to review it apply it send it on up the development chain handle any problems that might happen with the patch accept responsibility for the patch possibly fix any problems that happen later on when you disappear and maintain it for the next years.
therefore it is not unreasonable to assume that the accepted commits can represent the bulk of the maintainers efforts.
to increase internal validity we interviewed linux kernel maintainers and inspected various online resources to validate our findings.
we checked the assumptions for the regression model and log transformed the predictors to make the model coefficients more interpretable and to reduce the influence of the potential outliers.
the uniqueness of the linux kernel limits external validity.
as one of the largest cooperative software projects ever attempted the linux kernel may have unique practices.
despite that other projects might benefit from the practices of linux kernel as one interviewee said i ve been spending lots of time helping other projects scale that are having problems.
... we work together to see if they can adapt things that we do or i help them identify the pain points they have they try a change iterate and see if it s better or not.
yin wrote that the question of how to generalize from a single case is challenging for case studies.
the short answer is that case studies are generalizable to theoretical propositions and not to populations or universes.
the theoretical propositions in this study are the quantification of effort spent by the maintainers in the project and the quantification of work across maintainers.
related work the division of labor and distribution of tasks is a common theme in the floss literature because floss projects rely on volunteers who are dispersed across organizational and geographical boundaries.
lee and cole reported that the linux community has a project leader several hundred maintainers and thousands of developers the patterns of linux resemble the patterns of community organization revealed in other studies.
for example ducheneaut presented a pattern with core developers in the center surrounded by the maintainers patchers who fix bugs bug reporters documenters and finally the users of the software.
they characterized a community as a series of concentric circles each circle is occupied by people playing a particular role in the development process.
in this study we focus on the central circle of the linux kernel ecosystem maintainers.
how developer communities evolve and sustain has been subject to numerous investigations.
two constructs are considered crucial to an floss team s input effectiveness the number of developers that have been attracted and retained to work on the team team size and the amount of effort those developers have devoted.
two factors shape the lifecycle of a successful floss project a widely accepted leadership setting the project guidelines and driving the decision process and an effective coordination mechanism among the developers based on shared communication protocols.
studies of the progressive integration of new members and the evolution of sustainable groups are common.
forexample zhou and mockus found that individuals initial willingness and environment affect their chances of staying long term with the floss project.
the laws of software evolution were stated by lehman and have been widely observed by others .
evolutionary studies of long lived large scale floss ecosystems have attracted some attention .
wermelinger et al.
found that the eclipse architecture is always growing but components on a layered plugin architecture dependency graph exhibit different evolution patterns.
fortuna et al.
found that the modularization of the debian network over time in various operating system installations often parallels ecological relationships between interacting species.
building on prior work we investigated linux maintainers to quantify the types of tasks they do and the relationships between their work patterns and architectural and governance aspects of the contributors they work with.
whereas developers work has been extensively studied we adopted existing metrics and also added new metrics for maintainers.
conclusions we investigated maintainer activities in the linux ecosystem and quantified maintainers work based on the files they maintain the change activity in the maintained files and the number and churn of external contributors they must deal with.
we found that most of the modules did not grow appreciably over the last decade the majority of code was added to three modules drivers architecture and net.
however the number of files has grown for all modules which may be the cause of concern expressed in public discussions.
we found systematic yet stable differences among modules suggesting that the architectural features commercial interests or modulespecific practices led to distinct sustainable maintenance equilibria.
we also found that the workloads of the average maintainer and the median maintainer do not appear to increase thus some risks hypothesized in the community are not evident.
however the distribution of work among maintainers showed that rule applies for most modules suggesting that a few maintainers may bear the brunt of the increased workload.the practice of assigning multiple maintainers to a file yielded only a power of 2increase in productivity.
our proposed framework to quantify maintainer practices and productivity scaling may lead to a better understanding of the factors that allow rapidly growing projects to be sustainable and to practices that reduce risk of project failures.
the mechanisms underlying such large scale complicated production remain to be explored because the ecosystem never stops evolving.
in the words of one maintainer years from now it will look different depending on the people involved the external forces happening and what the needs of the project is.