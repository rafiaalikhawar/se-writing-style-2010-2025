jitprof pinpointing jit unfriendly javascript code liang gong michael pradel koushik sen electrical engineering and computer sciences university of california at berkeley technical report no.
ucb eecs august 2014copyright by the author s .
all rights reserved.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission.jitp rof pinpointing jit unfriendly javascript code liang gong michael pradel koushik sen gongliang13 pradel ksen cs.berkeley.edu eecs department uc berkeley abstract most modern javascript engines use just in time jit compilation to translate parts of javascript code into efficient machine code at runtime.
despite the overall success of jit compilers programmers may still write code that uses the dynamic features of javascript in a way that prohibits profitable optimizations.
unfortunately there currently is no technique that helps developers to identify such jit unfriendly code.
this paper presents jitp rof a profiling framework to dynamically identify code locations that prohibit profitable jit optimizations.
the basic idea is to associate execution counters with potentially jit unfriendly code locations and to use these counters to report code locations that match code patterns known to prohibit optimizations.
we instantiate the idea for six jit unfriendly code patterns that cause performance problems in the firefox and chrome browsers and we apply the approach to popular benchmark programs.
our results show that refactoring these programs to avoid performance problems identified by jitp rof leads to performance improvements of up to .
in benchmarks.
.
introduction javascript is the most widely used client side language for writing web applications.
it powers various popular websites including gmail facebook twitter and google docs.
more recently javascript has found its way into mobile platforms such as firefox os tizen os ios and android as well as desktop platforms such as windows and chrome os.
a key reason behind the popularity of javascript is that it can run on any platform that has a modern web browser.
another key reason behind the popularity of javascript among programmers is that it is a flexible dynamically typed language.
for example programmers can add and delete object properties and truncate and expand arrays at any point during an execution.
access to nonexistent object properties and out of bounds array elements returns the undefined value instead of raising an exception.
these dynamic features make programming in javascript convenient but they also make it difficult to compile javascript into efficient machine code.
for example the fact that object properties can be added and deleted forces javascript engines to implement objects as hash tables making property lookup an expensive operation.
to avoid these performance penalties modern javascript engines implement just in time jit compilation which translates and optimizes javascript code into efficientmachine code while the program executes.
an important premise for effective jit optimization is that programmers use the dynamic features of javascript in a systematic way.
for example jit compilers exploit the fact that object properties are often added to an object of a given type in a specific order or that out of bounds array accesses occur rarely.
jit compilers exploit these regularity assumptions to generate efficient machine code at runtime.
if a code block satisfies the assumptions the javascript engine executes efficient generated machine code.
otherwise the engine must fall back to slower code or to interpreting the program.
despite the overall success of jit compilers programmers may still write code that uses the dynamic features of javascript in a way that prohibits profitable jit optimizations.
we call such code jit unfriendly code.
previous research shows that programmers extensively use the dynamic features of javascript including dynamic addition and deletion of object properties that often result in jit unfriendly code.
unfortunately there currently is no technique that helps developers to identify jit unfriendly code.
in this paper we propose a profiling framework called jitp rof that dynamically identifies code locations that prohibit profitable jit optimizations.
the basic idea is to associate execution counters to potentially jit unfriendly operations and to use these counters to report code locations that match code patterns known to be jit unfriendly.
jitp rof associates meta information with javascript objects updates this information at runtime and uses the meta information to identify jit unfriendly operations.
for example jitp rof tracks hidden classes and inline cache misses which are two important concepts in jit optimization by associating a hidden class with every javascript object and a cache miss counter with every code location that accesses an object property.
we implement jitp rof1in a prototype framework written purely in javascript.
jitp rof instruments javascript code through source to source transformation and the instrumented code checks and reports at runtime various jit unfriendly code locations.
we instantiate the jitp rof framework for six jitunfriendly code patterns that cause performance problems in the firefox and chrome browsers.
we apply our approach to the programs in the sunspider and octane benchmark suites.
even though the javascript engines of firefox and chrome 1the tool is available as open source at berkeley correctness group jalangi berkeley tree master src js analyses jitawareare tuned towards these benchmarks jitp rof identifies various jit unfriendly code locations.
based on these reports we manually refactor programs by replacing jit unfriendly code with jit friendly code.
these simple changes give statistically significant improvements of execution time of up to .
and .
in firefox and chrome respectively.
in the ranked list of code locations that jitp rof reports all of these optimization opportunities are at the first or second position.
in contrast traditional cpu time profiling often reports the methods that contain these code locations at a lower rank.
a key advantage of jitp rof compared to traditional cputime profilers is that it not only identifies performance problems but it also explains the cause of these problems.
this is particularly important for scripting languages whose performance behaviors are often unpredictable and heavily depend on the runtime characteristics of the program.
another key advantage of jitp rof is that the framework can easily be extended to incorporate other programming patterns that prevent jit optimizations.
such an extension does not require detailed knowledge of the internals of a jit compiler.
instead an extension writer needs to understand the jit unfriendly code pattern at a high level and to write a few lines of javascript code that use jitp rof s api.
our existing analyses require between and lines of javascript code.
this user level extensibility is important because jit compilers evolve rapidly and because different jit compilers may not employ the same set of optimizations.
a third advantage of jitp rof is that it is not tied to any javascript engine.
our prototype tool is written purely in javascript.
as an alternative a jitp rof like approach could be implemented within a javascript engine.
however such an implementation would be hard to maintain and extend by anyone who is not familiar with the specific engine and it would not be useful for other jit engines that implement potentially different set of optimizations.
in summary this paper makes the following contributions we study popular javascript engines and extract common code patterns that reduce performance because they prohibit effective jit optimization section .
we present a profiling framework that automatically detects these jit unfriendly code patterns at runtime section and describe its implementation as a jit engine independent source to source transformation section .
we evaluate the approach with well known javascript benchmark programs and demonstrate that our approach pinpoints valuable optimization opportunities in of them.
.
jit unfriendly code patterns this section presents and discusses some of the important code patterns that are difficult to handle for javascript jit compilers and that often lead to performance bottlenecks.
jitp rof detects instances of all these jit unfriendly code patterns in widely used benchmark programs.
in this section we illustrate1function c i 2if i this.a math.random this.b math.random else this.b math.random this.a math.random 10function sum base p1 p2 return base base 13for var i i i sum new c i a b function c i if i this.a math.random this.b math.random else this.a math.random this.b math.random function sum base p1 p2 return base base for var i i i sum new c i a b figure example for inconsistent object layouts left and improved code right .
the highlighted code on the left pinpoints the jit unfriendly code location.
the highlighted code on the right shows the difference to the code on the left.
each pattern with a simple example.
the full source code of these micro benchmarks is available for download.
the code patterns described in this section are jitunfriendly for two reasons.
first several patterns prevent the jit compiler from executing specialized code.
for example jit compilers often speculate that runtime types at a code location match the types observed in prior executions of this location.
second several patterns prevent the jit compiler from using a specialized data representation or force the jit compiler to transform data from one representation to another.
.
.
inconsistent object layouts a common pattern of jit unfriendly code is to construct objects of the same type in a way that forces the compiler to use multiple representations for the sets of object properties.
such inconsistent object layouts prevent an optimization that specializes property accesses based on recurring object layouts.
example.
the program in figure has two functions cis a constructor that creates an object with two properties aandb.
the properties are initialized in two possible orders depending on the value of the constructor s parameter i. the function sum has three parameters base is an object and p1and p2are property names.
the expression base returns the value of the property whose name is stored as a string in the variable p1.
the main loop of the program repeatedly constructs objects of type cand passes them to sum.
the performance of the example can be significantly improved by swapping lines and .
the modified code given on the right of figure runs .
and .
faster than the original example in firefox and chrome respectively.
explanation.
the reason for this speedup is that the original code creates numerous cobjects with two possible layouts of the properties.
in one layout aappears at offset and b jalangi berkeley tree master tests jitaware experiments benchmarks microbench 3all performance improvements reported in this paper are statistically significant section .
explains our methodology in detail.
2property offset hidden classes objects offset .
offset .
hidden class property offset b property offset b a property offset a hidden class offset .
offset .
property offset a b hidden classes figure structure of objects and hidden classes.
appears at offset whereas in the other layout the order is reversed.
as a result the jit compiler fails to specialize the code for the property lookups in sum.
instead of optimizing this code so that it accesses the properties at a fixed offset the executed code accesses the properties via an expensive hash table lookup.
we next explain this problem in more detail.
background hidden classes and inline caching.
in javascript an object is a map from property names to property values.
looking up a property of an object can be expensive if the object is represented as a hash map.
to avoid expensive property lookups most javascript engines store a representation of each object s memory layout and use this representation by caching the offset of properties accessed at particular code locations.
for this purpose the object is represented in two parts an array with the values of the object s properties and a map from property names to offsets called hidden class .
a property lookup has two steps.
first the javascript engine retrieves the offset of the property from the hidden class.
second the engine uses the offset to retrieve the value of the property from the array representing the object.
whenever a new property is added to an object the engine appends the value to the array that represents the object and updates the object s hidden classes so that it reflects the new object layout.
figure shows how objects of type cfrom the original example in figure are represented in memory.
when an object of type cis instantiated at line an empty array representing the object is created and the hidden class of the object points to an empty map .
when the execution reaches line the array of the object is updated by adding a value at offset and the hidden class of the object now points to a map that assigns bto .
when executing line another value is added to the array at offset and the hidden class of the object now points to a map that assigns bto and ato .
similarly if the execution takes the then branch at line an object is created whose array contains values at offsets and respectively.
however the hidden class of this object maps ato and bto i.e.
the hidden class differs from the hidden class created when taking the other branch.
the javascript engine reuses existing hidden classes if the order of properties matches.
for example the engine uses the same hidden classes whenever it executes the then branch in line .
given the above representation of an object in javascript the value of a property of an object at a code location can be retrieved quickly by a mechanism called inline caching .the basic idea is to cache the offset of the property that was previously used at a code location and to reuse this offset if the program repeatedly accesses the same property name in the same hidden class.
in other words the jit compiler specializes the code for property accesses based on the assumption that object layouts recur at code locations.
to this end the javascript engine maintains for every code location that performs a property access base.prop two variables cached hidden class which points to the hidden class that was used last at this location and cached offset which contains the offset accessed last at this location.
to access the property the engine checks whether the hidden class of base is the same as cached hidden class .
in this case called inline cache hit the engine returns the property value stored at cached hidden class .
otherwise called inline cache miss the engine looks up the property s offset in the current hidden class and caches both for the next time the code location is reached.
inline cache misses are significantly more expensive than inline cache hits.
for code that accesses a property where the property name is stored in a variable such as at line of figure inline caching stores the property name in addition to the hidden class and the offset.
real world javascript engines may use more sophisticated variants of inline caching than what we describe here such as polymorphic inline caches that store multiple previously seen hidden classes and offsets.
hidden classes and inline caching explain why changing the order of initializing properties in figure leads to a significant performance improvement.
if we swap lines and all objects of type ccreated at line have the same hidden class.
therefore all but the first accesses to the properties aandb result in an inline cache hit.
in contrast the unmodified code results in an inline cache miss at each property access in line because the cached hidden class alternates between the two hidden classes described above.
.
.
polymorphic operations another common source of jit unfriendly behavior are code locations that apply an operation to different sets of types when reaching the location multiple times.
we call such operations polymorphic operations .
example.
the plus operation in figure at line operates on numbers when fis called after executing line and on strings when fis called after executing line .
the performance of the example can be significantly improved by splitting finto a function that operates on numbers and a function that operates on strings as shown on the right of figure .
the modified code runs .
and .
faster than the original example in firefox and chrome respectively.
explanation.
this change significantly improves the performance because it enables the javascript engine to execute specialized code for the plus operation.
the change turns a polymorphic operation into two monomorphic operations i.e.
into operations that always execute on the same types of 31function f a b 2return a b 7for var i i i 8var arg1 arg2 9if i a b else a a b b f a b function f a b return a b function g a b return a b for var i i i var arg1 arg2 if i a b f a b else b a b b g a b figure example of polymorphic operation left and improved code right .
1var x y 2var rep 3for var i i rep i 4y x var x y var rep for var i i rep i y x figure example for a binary operation on undefined left and improved code right .
operands.
in the modified code the operation at line always executes on numbers and the operation at line always executes on strings.
for example the jit compiler can optimize the monomorphic plus into a few quick integer instructions and inline these instructions at the call site of f. in contrast the jit compiler cannot optimize the original code because the types of operands change every time line executes.
.
.
binary operation on undefined binary operations such as and that are executed on undefined values which has well defined semantics in javascript can cause a loss of performance compared to applying the same operations on non undefined values.
example.
the code on the left of figure reads the undefined value from xand implicitly converts it into zero.
modifying this code so that xis initialized to zero preserves the semantics and significantly improves the performance.
the modified code on the right is .
and .
faster than the original code in firefox and chrome respectively.
explanation.
the reason for this performance difference is that the original code prevents the javascript engine from executing code specialized for numbers.
instead the engine falls back on code that performs additional runtime checks and that coerces the undefined value into a number.
.
.
non contiguous arrays in javascript arrays can have holes i.e.
the elements at some indexes between zero and the end of the array may be uninitialized.
such non contiguous arrays cause slowdown.
example.
the code on the left of figure initializes an array in reverse order so that every write at line is accessing a noncontiguous array.
modifying this code so that the array grows1for var j j j 2var array 3for var i i i array i for var j j j var array for var i i i array i figure example of non contiguous arrays left and improved code right .
1var array sum 2for var i i i 3array 4for var j j j 5var ij 6var len array.length 7while array sum array ij var array sum for var i i i array for var j j j var ij var len array.length while ij len sum array ij figure example of accessing undefined array elements.
contiguously leads to a significant performance improvement.
the modified code on the right is .
and .
faster than the original code in firefox and chrome respectively.
explanation.
non contiguous arrays are jit unfriendly for three reasons.
first javascript engines use a slower implementation for non contiguous arrays than for contiguous arrays.
dense arrays where all or most keys are contiguous starting from zero are represented using linear storage.
sparse arrays where keys are non contiguous are implemented as hash tables and looking up elements is relatively slow.
second using non contiguous arrays may degrade performance because the javascript engine may change the representation of an array if its density changes during the execution.
third non contiguous arrays are jit unfriendly because jit compilers speculatively specialize code under the assumption that arrays do not have holes.
for example hackett et al.
describe a type inference based jit optimization implemented in firefox which marks arrays as contiguous or potentially non contiguous called packed and unpacked in and which generates optimized code for contiguous arrays.
.
.
accessing undefined array elements another array related source of inefficiency is accessing an uninitialized deleted or out of bounds array element.
example.
the code in figure creates an array and repeatedly iterates through it.
the original code on the left checks whether it has reached the end of the array by checking whether the current element is defined i.e.
the code accesses an uninitialized array element each time it reaches the end of the while loop.
the modified code on the right avoids accessing an undefined element and instead continues the while loop as long as the current index ijis smaller than the length of the array.
this change results in a significant performance improvement of .
and .
in firefox and chrome respectively.
explanation.
accessing undefined array elements causes slowdown for reasons similar to ones discussed in section .
.
41var array 2for var i i i 3array i 4array abc 5array .
var array for var i i i array i array array .
figure example of storing non numeric values into numeric arrays.
jit unfriendly code pattern firefox chrome inconsistent object layouts .
.
polymorphic operations .
.
binary operations on undefined .
.
non contiguous arrays .
.
accessing undefined array elements .
.
storing non numeric values in numeric arrays .
.
table performance improvements on micro benchmarks of jit unfriendly code patterns.
.
.
storing non numeric values in numeric arrays javascript arrays may contain elements of different types.
however for good performance programmers should avoid to store non numeric values into an otherwise numeric array.
example.
the code on the left of figure creates a large array that contains only numeric values.
then the code assigns a non numeric value to one of the array s elements.
the modified code on the right avoids storing a non numeric value which leads to a significant performance improvement of .
and .
in firefox and chrome respectively.
explanation.
if a dense array contains only numeric values such as bit signed integers4or doubles then the javascript engine can represent the array as a fixed sized c like array of integers or doubles respectively.
operations on such arrays are faster than on arrays containing values of arbitrary types.
if a numeric array in a program is updated with a non numeric value the javascript engine must change the representation of the array from a fixed sized integer double array to an array of non numeric values which is an expensive operation.
table summarizes the jit unfriendly code patterns and the performance improvement we measure for micro benchmarks when avoiding these patterns.
.
dynamic analyses to detect jit unfriendly code patterns the previous section describes several code patterns that prohibit profitable jit optimizations.
in this section we describe jitp rof a profiling approach that detects these code patterns at runtime and reports them to the developer.
our experience with jitp rof shows that jit unfriendly code reported byjitp rof often causes noticeable performance bottlenecks and that developers can optimize javascript code by refactoring jit unfriendly code into jit friendly code.
4both the firefox and the chrome javascript engine use tagged integers where bit represent a signed integer and the remaining bit distinguishes an integer value from a pointer.to detect instances of the code patterns described in the previous section jitp rof keeps track of particular operations that happen at runtime.
for example the analysis keeps track of operations that read and write properties of an object called put and get property operations respectively and of binary operations such as arithmetic and logical operations.
for each code pattern jitp rof associates a zero initialized counter with source code locations that may execute a jit unfriendly operation.
we call this counter the unfriendliness counter .
whenever the analysis observes a jit unfriendly operation it increments the unfriendliness counter of the respective operation.
in addition to keeping track of runtime operations jitp rof associates meta information called shadow objects with runtime objects.
at the end of the program s execution jitp rof reports code locations with a non zero unfriendliness counter to the developer.
we rank reports by their unfriendliness counter i.e.
by how frequently a jit unfriendly operation occurs at a particular code location and for some patterns by an estimate of how profitable it is to fix the problem.
similar to other profiling approaches we expect developers to inspect only the top ranked reports.
in the following we describe a dynamic analysis for each of the jit unfriendly code patterns.
.
.
tracking inconsistent object layouts to find performance problems caused by inconsistent object layouts section .
jitp rof tracks the hidden class associated with each object and the number of inline cache misses that occur at code locations that perform a property get or put operation.
the unfriendliness counter for this code pattern represents how often a location suffers from an inline cache miss and an estimate of how profitable it is to fix the problem.
the analysis represents the hidden class of an object as a list of the object s property names.
the list is stored in the shadow value associated with the object and it represents the order in which the object s properties are initialized.
this representation of hidden classes is independent of the underlying javascript engine and abstracts from the implementation of hidden classes in javascript engines.
the analysis updates the hidden class associated with each object as follows whenever an object gets created using an object literal or using a constructor the analysis iterates over the property names of the object and checks if there exists a hidden class that matches the list of property names.
if there is a matching list the analysis sets the list as the shadow value of the newly created object.
if there is no matching list the analysis creates a new list of property names and associates it with the object.
the list is also added to a global database of hidden classes so that the analysis can later reuse it when searching for a particular hidden class.
whenever a put property operation is performed on an object the analysis checks if the property name involved in the operation is already present in the hidden class of the object.
if the property name exists the analysis does noth5ing.
otherwise the analysis extends the hidden class by adding the new property name to the list of property names.
then the analysis checks if the new list of names matches any existing hidden class.
if a match is found the analysis associates the matching hidden class with the object.
otherwise the analysis creates a new hidden class with the list of property names associates the list with the object and adds the list to the database of hidden classes.
based on the information about the hidden class of each object jitp rof tracks whether property get and put operations result in inline cache misses by maintaining for each such location the following information the value cached hidden class which points to the hidden class of the base object of the get or put property operation that was executed most recently at the code location.
the value cached prop name which stores the name of the most recently accessed property at the code location.
the unfriendliness counter cicm which represents the number of inline cache misses observed at this get or put property operation.
whenever the program performs a get or put property operation the analysis updates the information associated with the operation s code location.
if the hidden class of the operation s base object matches the cached hidden class and if the accessed property matches the cached prop name then the analysis does nothing.
this case corresponds to an inline cache hit i.e.
the code specialized by the jit compiler for this location can be executed.
if the cached hidden class or the cached prop name does not match then the analysis increments cicmand updates cached hidden class and cached prop name .
this case corresponds to an inline cache miss i.e.
the jit compiler cannot execute the code specialized for this location and must fall back on the slower generic code.
the analysis also keeps track of the number of occurrence of each hidden class.
at the end of the execution jitp rofreports a ranked list of all code locations with a non zero number cicmof inline cache misses.
the results are ranked by the sum of cicmand a number csecond that estimates how profitable it is to fix a problem at a particular location.
the value csecond is the number of occurrences of the second most frequently observed hidden class at the location.
this approach is a heuristic to break ties when multiple locations have similar numbers of inline cache misses.
the rationale is that the location with a larger csecond is likely to be more profitable to fix because making the two most frequent hidden classes consistent can potentially avoid more inline cache misses.
for the example in figure the analysis tracks the hidden classes illustrated in figure identifies various inline cache misses at line and reports this line to the developer as illustrated by the highlighted code on the left of the figure.
.
.
tracking polymorphic operations to detect performance problems caused by polymorphic operations section .
jitp rof tracks the types of operands involved in unary and binary operations.
the unfriendliness counter for this code pattern represents how often an operation at a particular code location is polymorphic.
the analysis maintains the following information for each code location that performs a unary or binary operation the most recently observed type op1 type of the left operand.
the most recently observed type op2 type of the right operand for binary operations only .
the unfriendliness counter cpoly which represents the number of times that the types of the operands have changed during the program s execution.
whenever the program performs a binary operation the analysis checks whether the types of the operands match the stored op1 type andop2 type.
if the types match then the analysis does nothing.
this case corresponds to an operation that the jit compiler can effectively optimize through pre computed type specific code.
if at least one of the two observed types differs from the respective stored type then the analysis increments cpoly and it updates op1 type and op2 type with the current operand types.
in this case the javascript engine cannot execute type specific code but must fall back on the slower generic implementation.
the analysis performs similar checks and updates for unary operations.
at the end of the execution jitp rof reports code locations with a non zero number cpolyof polymorphic operations and ranks them in the same way as described in section .
.
for the example in figure the analysis warns about the polymorphic operation at line because the types of its operands always differ from the previously observed types.
.
.
tracking binary operations on undefined to detect performance problems caused by binary operations with undefined operands section .
jitp rof tracks all binary operations and maintains an unfriendliness counter cunde f for each code location with a binary operation.
the counter represents how often the operation operates on an undefined operand.
whenever the program executes a binary operation the analysis checks whether one of the operands is undefined .
in this case the analysis increments cunde f .
at the end of the execution jitp rof reports the code locations with a non zero value of cunde f and ranks them by the unfriendliness counter.
for the example in figure the analysis warns about line because the first operand of the operation is frequently observed to be undefined .
.
.
tracking non contiguous arrays to detect performance problems caused by non contiguous arrays section .
jitp rof tracks writes of array elements 6that make the array non contiguous.
the analysis maintains an unfriendliness counter cnon contfor each code location that writes into an array.
the counter represents how often a code location makes an array non contiguous.
for each put property operation where the base is an array and where the property is the index the analysis checks whether the index of the element to be updated is less than or greater than the length of the array.
in this case the operation inserts an element that makes the array non contiguous by leaving a hole between the existing array and the inserted element.
therefore the analysis increments the counter cnon contfor the code location.
at the end of the execution jitp rof reports all code locations with a non zero cnon cont ranked by the unfriendliness counter.
for the example in figure the analysis warns about line because it transforms the array into a non contiguous array every time the line is executed.
.
.
tracking access to undefined array elements to find performance problems caused by accessing undefined array elements section .
jitp rof tracks all operations that read array elements.
the unfriendliness counter cuninit for this code pattern represents how often a code location reads an undefined array element.
similar to writes into arrays reading an array element in javascript is a get property operation where the base object is an array and where the property name is the index.
the analysis checks for each get property operation that reads an array element from base whether the index is defined in the array by calling base.hasownproperty index .
if this check fails the program accesses an undefined array element and the analysis increments the cuninit counter of the code location.
at the end of the execution jitp rof reports all code locations with a non zero number cuninit of reads of undefined array elements and ranks them by the unfriendliness counter.
for the example in figure the analysis warns about line because it reads an undefined array element every time the while loop terminates.
.
.
tracking non numeric stores into numeric arrays to detect performance problems caused by transforming numeric arrays into non numeric arrays section .
jitp rof tracks the state of each array and operations that may change the state of arrays.
the unfriendliness counter for this code pattern represents how often a particular code location transforms a numeric array into a non numeric array.
the analysis maintains a simple state machine for each array figure .
the state machine has three states unknown numeric non numeric .
when an array gets created the analysis initialized the state machine for this array and stores its initial state in the shadow value of the array.
the state is initialized to unknown if the array is empty or if all elements are uninitialized.
if all the elements of the array are numeric then the state is initialized to numeric .
otherwise the state is initialized to non numeric .
the analysis updates the state ofunkna noanumeric element non numeric elementnon numeric elementnumeric element numeric non numeric element nameans numeric array.
noa means non numeric array.
unk means uninitialized array of unknown type.
figure state machine of an array.
an array whenever the program writes into the array through a put property operation.
if the operation stores a non numeric value in a numeric array the state machine transitions from numeric tonon numeric .
if a numeric value is stored in a numeric array the state of the array remains unchanged.
if a numeric value is stored in an unknown array the state of the array transitions to numeric .
in all other scenarios the state of the array is changed to non numeric .
the analysis maintains an unfriendliness counter cnon num for each code location that writes an array element.
if executing an operation leads to a transition from numeric to non numeric then the analysis increments cnon numfor the corresponding code location.
at the end of the execution jitp rof reports all code locations that transform numeric into non numeric arrays i.e.
all code locations with a nonzero value of cnon num ranked by cnon num.
for the example in figure the analysis warns about line because it writes a non numeric value into a numeric array.
.
.
discussion the dynamic analyses described in this section approximate the behavior of popular jit engines to identify jit unfriendly code locations.
these approximations are based on simplifying assumptions about how jit compilation for javascript works which may not always hold for every javascript engine.
for example we model inline caching in a monomorphic way and ignore the fact that a javascript engine may use polymorphic inline caching.
approximating the behavior of the javascript engine is a deliberate design decision that allows for implementing analyses that check for jit unfriendly code patterns with a few lines of code and without requiring knowledge about the engine s implementation details.
evaluating our approach with state of the art javascript engines section shows that it effectively identifies valuable optimization opportunities suggesting that our dynamic analyses model the engine s behavior in a reasonable way.
.
implementation we implement jitp rof via a source to source transformation that adds analysis code to a given program.
this approach avoids limiting jitp rof to a particular javascript engines.
the implementation is built on top of the instrumentation and dynamic analysis framework jalangi .
7the framework instruments a javascript programs through source to source transformation and then the instrumented code is executed in place of the original code.
a jalangi instrumented javascript program provides two capabilities to a dynamic analysis.
first it allows the analysis to associate an arbitrary value called shadow value with any object in the program to store meta information about the object.
second jalangi supports shadow execution on shadow values a technique in which an analysis can update the shadow values and analysis state on each operation performed by the program.
the operations considered by jalangi are at a lower level than javascript statements e.g.
complex expressions are split into multiple unary and binary operations.
for each jit unfriendly code pattern jitp rof contains a dynamic analysis that uses shadow values and shadow execution to identify occurrences of the pattern.
for example the analysis to detect inconsistent object layouts section .
stores a representation of the hidden class of each object as the object s shadow value.
the analysis uses shadow execution to update the hidden class whenever an object property is added or deleted.
furthermore the analysis uses shadow execution to check at each operation that accesses a property whether to increment the unfriendliness counter.
the implementation tracks unfriendliness counters for code locations via a global map that assigns unique identifiers of code locations to the current unfriendliness counter at the location.
the map is filled lazily i.e.
jitp rof tracks counters only for source locations that are involved in a jit unfriendly code pattern.
given the jalangi framework the implementations of the analyses are relatively simple making it straightforward to extend jitp rof with additional jit unfriendly code patterns.
our implementations of the analyses in section require between and lines of javascript code.
.
evaluation to evaluate the effectiveness of jitp rof we apply it to the sunspider and octane benchmark suites.
we inspect the code locations that jitp rof identifies refactor them by replacing jit unfriendly code with jit friendly code and measure whether these simple changes lead to a performance improvement in the firefox and chrome web browsers section .
.
furthermore we compare the effectiveness of jitp rof with traditional cpu time profiling section .
.
we want to note that finding jit compilation related performance problems in the sunspider and octane benchmarks is non trivial because these benchmarks have been used extensively to tune the performance of popular javascript engines.
.
.
experimental methodology table lists the programs used for the evaluation along with their number of lines of code.
the table also shows the running time of the benchmark when we profile it with jitp rof and the slowdown imposed by jitp rof compared to running the benchmark without any instrumentation.
our implementationbenchmark loctime of profiling run sec profiling slowdown sunspider controlflow recursive .
sunspider bitops bits in byte .
sunspider bitops bitwise and .
sunspider math partial sums .
sunspider bitops nsieve bits .
sunspider bitops 3bit bits in byte .
sunspider access nsieve .
sunspider math spectral norm .
sunspider access binary trees .
sunspider 3d morph .
sunspider string unpack code .
sunspider access fannkuch .
sunspider string fasta .
sunspider string validate input .
sunspider math cordic .
sunspider string base64 .
sunspider access nbody .
sunspider crypto sha1 .
sunspider string tagcloud .
sunspider crypto md5 .
sunspider date format tofte .
sunspider 3d cube .
sunspider date format xparb .
sunspider crypto aes .
sunspider 3d raytrace .
sunspider regexp dna .
octane splay .
octane navier stokes .
octane richards octane deltablue .
octane raytrace .
octane code load .
octane crypto .
octane regexp .
octane earley boyer .
octane box2d .
octane gbemu .
octane typescript octane pdfjs .
octane mandreel .
table programs used for the evaluation.
is not optimized for reducing slowdown but instead focuses on providing a javascript engine independent framework that is easily extensible.
for each jit unfriendly code pattern jitp rof reports a ranked list of code locations.
we inspect at most the top three code locations per program and pattern and we try to refactor the program to avoid the jit unfriendly code.
we apply only semantics preserving changes that affect at most a few lines of code.
each change fixes only the problem reported by jitp rof and does not apply any other optimization.
to assess whether a change improves the performance we compare the execution time of the original and the modified program in two popular browsers firefox .
and chrome .
.
to obtain reliable performance data we repeat the following steps times open a fresh browser instance and run the original benchmark.
open a fresh browser instance and run the modified benchmark.
each run yields a benchmark score explained below giving a total of scores per browser.
given these scores we use the independent t test confidence interval to check whether there is a statistically significant performance difference be8benchmarkcprjitp rof ch.
avg.
improvement rank loc stat.
significant firefox chrome sunspider crypto sha1 in uae po bou6 .
.
sunspider string tagcloud in iol .
sunspider crypto md5 in uae po bou6 .
sunspider format tofte in uae .
sunspider 3d cube in nca .
sunspider format xparb in po .
.
sunspider 3d raytrace in nna .
octane splay in iol .
.
octane splaylatency in iol .
octane deltablue in iol .
octane raytrace in iol .
octane box2d in iol .
cpr means cpu profiler rank.
ch.
loc is the number of changed loc.
iol means inconsistent object layouts.
po means polymorphic operations.
bou means binary operation on undefined .
nca means non contiguous arrays.
uae means accessing undefined array elements.
nna means storing non numeric values in numeric arrays.
table performance improvement achieved by avoiding jitunfriendly code patterns.
tween the original and the modified program.
all performance differences we report are statistically significant.
the experiments are performed on mac os x .
.
using a .40ghz intel core i7 3635qm cpu machine with 8gb memory.
to assess the performance of a single benchmark execution we rely on the measurement infrastructure that is part of the sunspider and octane benchmarks.
sunspider benchmarks report a performance score that is the total amount of time used to complete a fixed amount of computation i.e.
a lower score means better performance.
therefore we compute performance improvement as soriginal smodi f ied soriginal for sunspider where soriginal andsmodi f ied mean the average score for the original and modified benchmark respectively.
since some sunspider benchmarks run too short to reliably measure their performance we modify their test harness code by increasing the number of repetitions of the computation.
octane benchmarks report a performance score that is proportional to the number of repetitions performed in a fixed amount of time i.e.
a higher score means better performance.
therefore we compute performance improvement as smodi f ied soriginal soriginal for octane.
.
.
jit unfriendly code found by jitp rof jitp rof detects jit unfriendly code that causes easy to avoid performance problems in of the benchmarks.
table summarizes the performance improvements achieved by avoiding these problems.
the jitp rof rank column indicates which analysis detects a problem and the position of the problem in the ranked list of reported code locations.
the table also shows how many lines of code we change to avoid the problem.
the last two columns of the table show the performance improvement achieved with these changes.
avoiding jit unfriendly code patterns leads to improvements of up to19.
and .
in firefox and chrome respectively.
in the following we discuss representative examples of performance problems and how to avoid them.
the appendix list all examples from table that we are not discussed in this section.
inconsistent object layouts in octane splay.
jitp rof reports a code location where inconsistent object layouts occur a total of times.
specifically the layout of the objects frequently alternate between two layouts key value left right and key value right left .
the problem boils down to the following code which initializes the properties left andright in two possible orders depending on the outcome of the conditional check at line 1var node new splaytree.node key value 2if key this.root .key 3node.left this.root 4node.right this.root .right ... else 7node.right this.root 8node.left this.root .left ... to fix the problem we swap the first two statements in the else branch so that the code always creates an object with layout key value left right .
this simple change results in a .
and .
improvement in firefox and chrome respectively.
polymorphic operations in sunspider format xparb.
jitp rof reports a code location that frequently performs a polymorphic plus operation.
specifically the analysis observes operand types string string times and operand types object string times.
the behavior is caused by the following function which returns either a primitive string value or a string object depending on the value of val 1string.leftpad function val size ch 2var result new string val 3if ch null ch 6while result.length size result ch result 9return result to avoid this problem we refactor string.leftpad by replacing line with 1var result val 2var tmp new string val the modified code initializes result with a primitive string value.
for a fair performance comparison we add the statement at line to retain a string object construction operation and a monomorphic object string concatenation operation.
this simple change leads to .
and .
performance improvement in firefox and chrome respectively.
fixing the problem without the statement that calls thestring constructor which is the solution a developer may choose in practice leads to an even larger improvement.
9multiple undefined related problems in sunspider md5.
jitp rof reports occurrences of three jitunfriendly code patterns for the following code snippet 1function str2binl str 3var bin array 4var mask chrsz 5for var i i str.length chrsz i chrsz bin str.charcodeat i chrsz mask i 7return bin the function creates an empty array and then reads uninitialized elements of the array in a loop before assigning values to those elements.
jitp rof reports that the code accesses undefined elements of an array times at line .
furthermore the approach reports that this line repeatedly performs bitwise or operations on the undefined value.
finally the approach also reports that this operation is polymorphic because it operates both on numbers and on undefined .
to avoid this conglomerate of jit unfriendly operations we refactor the code as follows 1function str2binl str 3var len str.length chrsz 4var bin new array len 5for var i i len i bin 6var mask chrsz 7for var i i str.length chrsz i chrsz bin str.charcodeat i chrsz mask i 9return bin the modified code avoids all three jit unfriendly code patterns.
it initializes the array bin with a predefined size stored in the variable len and then initializes all of its elements with zero.
although we introduce additional code this change leads to a .
performance improvement in chrome.
non contiguous arrays in sunspider cube.
jitp rof detects code that creates a non contiguous array times.
the example is similar to figure an array is initialized in reverse order and we modify the code by initializing the array from lower to higher index.
as a result the array increases contiguously which results in a small but statistically significant performance improvement of .
in chrome.
non numeric values in numeric arrays in sunspider raytrace.
jitp rof reports that the sunspider raytrace benchmark transforms a numeric array into a non numeric array times.
the reason is that the program initializes an array that is supposed to represent pixels with zeros 1var size 2var pixels new array 3for var y y size y 4pixels new array 5for var x x size x pixels the code initializes pixels as a numeric array but the program later stores non numeric values into the array that each represent a pixel each pixel is a numeric array of length three .
since the initial zero values are never used in the program we refactor the initialization code as follows 1var size 2var tmp 3var pixels new array 4for var y y size y 5for var x x size x pixels tmp the new code informs the jit engine that the array should contain only array values which avoids adapting the data representation at runtime.
the change improves performance by .
in chrome.
.
.
comparison with cpu time profiling the most prevalent existing approach for finding performance bottlenecks is cpu time profiling .
to compare jitp rof with cpu time profiling we analyze the benchmark programs in table with the firebug profiler.5cpu time profiling reports a list of functions in which time is spent during the execution sorted by the time spent in the function itself i.e.
without the time spent in callees.
the cpu profiler rank column in table shows for each jit unfriendly location identified by jitp rof the cpu profiling rank of the function that contains the code location.
most code locations appear on a higher rank injitp rof s output than with cpu profiling.
the function of one code location sunspider string tagcloud does not even appear in the cpu profiler s output presumably because the program does not spend a significant amount of time in the function that contains the jit unfriendly code.
in addition to the higher rank of jit unfriendly code locations jitp rof improves upon traditional cpu time profiling by pinpointing a single code location and by explaining why this location causes performance problems.
in contrast cputime profiling suggests entire functions as optimization candidates.
for example the performance problem in sunspiderformat tofte is in a function with lines of code.
instead of letting developers find an optimization opportunity in this function jitp rof precisely points to the problem.
overall our results suggest that jitp rof enables developers to find jit unfriendly code locations quicker than cputime profiling.
in practice we expect both jitp rof and traditional cpu time profiling to be used in combination.
developers can identify jit compilation related problems quickly with jitp rof and if necessary use other profilers afterwards.
.
.
non optimizable jit unfriendly code for some of the jit unfriendly code locations reported by jitp rof we fail to improve performance with a simple refactoring.
a common pattern of such non optimizable code is an object that is used as a dictionary or map.
for such objects the program initializes properties outside of the constructor making the object structure unpredictable and leading to multiple hidden classes for a single object.
dictionary objects often cause inline cache misses because the object s structure varies 10in an unpredictable way at runtime but we cannot easily refactor such problems.
another common pattern is jit unfriendly code that is not executed frequently and where eliminating the jit unfriendly code requires adding statements.
for example sometimes creating consistent object layouts requires adding some property initialization statements in a constructor and executing these additional statements takes more time than the time saved from avoiding the jit unfriendly code.
developers can avoid inspecting and optimizing such code by inspecting only the top ranked jit unfriendly code locations which occur relatively often.
.
related work .
.
just in time compilation jit compilation is widely used to improve the performance of a program while it executes .
recent work includes tracebased dynamic type specialization optimizing the representation of arrays based on object access profiles memoizing side effect free methods identifying and removing short lived objects just in time value specialization and studying how the effectiveness of jit compilation depends on the order in which compilation units are re compiled .
hackett et al.
improve the performance of the firefox javascript engine through combined static dynamic type inference that enables the engine to omit unnecessary runtime checks given that the program matches particular regularity assumptions.
ahn et al.
improve chrome s javascript engine by modifying the structure of hidden classes to increase the inline caching hit rate .
these approaches improve the performance of existing programs whereas jitp rof pinpoints code locations that developers may refactor to improve performance on existing javascript engines.
even though we expect further improvements of jit compilation in the future we also expect that there will always remain code that cannot be compiled into efficient machine code by a given jit compiler.
our work addresses the problem of identifying such code.
.
.
performance analysis and profiling a recent study shows that performance bugs are a common problem.
in the following we discuss existing approaches to detect and diagnose such problems.
st amour et al.
propose to instrument a compiler so that it creates a log of all optimization decisions and to use this log to suggest to the developer code changes that enable currently missed optimizations.
in contrast to this compile time analysis implemented inside a compiler jitp rof is a runtime analysis that is implemented without modifying the javascript engine.
javascript developers often rely on web sites that compare the execution time of particular code snippets across javascript engines6or on advice on how to write efficient javascript code .
in contrast to these generic and program agnostic 6for example .guidelines our approach points to optimization opportunities in a given program.
hauswirth et al.
propose multi layer profiling to understand the whole system performance of programs executed in a virtual machine.
powerscope is a profiler for measuring energy consumptions at procedure and process level.
cprof and statcache are cache profiling systems that identify memory cache misses in frequently executed parts of a program.
these approaches and our work share the idea of analyzing the interaction between a program and its execution environment.
perfdiff is a dynamic analysis to understand and localize performance differences between execution environments .
instead our work pinpoints performance problems that may exist in multiple execution environments.
there are various profilers and dynamic analyses to detect inefficient memory usage and other performance bottlenecks.
xu et al.
propose approaches to find underutilized or overutilized containers unnecessarily copied data and objects where the cost to create the object exceeds the benefit from using it .
yan et al.
detect common patterns of excessive memory usage through reference propagation profiling .
taeds is a framework to record and analyze data structure evolution during the execution .
marinov and o callahan propose an analysis to find optimization opportunities due to equal objects and xu refines this idea to detect allocation sites where similar objects are created repeatedly .
toddler detects loops where all iterations have similar memory access patterns and proposes to move the corresponding code out of the loop.
profiling is also used to understand the performance of interactive user interface applications and large scale parallel hpc programs .
pin is a runtime instrumentation framework for binaries that includes profilers and cache simulators .
other approaches combine execution traces from multiple users to localize performance problems .
all these approaches detect performance problems that are independent of the program s execution environment.
instead jitp rof focuses on jit unfriendly code locations.
llvm is a framework to support program analysis at compiler level.
this framework is capable of gather profiling information for later analysis and optimization.
mytkowicz et al.
compare four java profilers and show that non uniform sampling may skew the profiling results.
our implementation of jitp rof avoids this problem by not sampling the execution.
.
conclusion this paper presents jitp rof a profiling framework to pinpoint code locations that prohibit profitable jit optimizations.
we realize our idea for six code patterns that lead to performance bottlenecks on popular javascript engines and show thatjitp rof finds instances of these patterns in widely used benchmark programs.
simple changes of the programs to avoid the jit unfriendly code patterns lead to significant performance improvements of up to .
.
our work is the 11foundation for an easy to use tool that pinpoints jit related optimization opportunities without the need to fully understand the javascript engine.
given the increasing popularity of javascript we consider our work to be an important step toward improving the efficiency of an increasingly large fraction of all executed software.
acknowledgment this research is supported in part by nsf grants ccf0747390 ccf ccf and ccf and gifts from mozilla and samsung.
the authors would like to thank luca della toffola for his valuable feedback.