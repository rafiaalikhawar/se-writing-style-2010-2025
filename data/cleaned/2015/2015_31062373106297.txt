regression test selection across jvm boundaries ahmet celik marko vasic university of texas at austin usa ahmetcelik vasic utexas.edualeksandar milicevic microsoft usa almili microsoft.commilos gligoric university of texas at austin usa gligoric utexas.edu abstract modern software development processes recommend that changes be integrated into the main development line of a project multiple times a day.
before a new revision may be integrated developers practice regression testing to ensure that the latest changes do not break any previously established functionality.
the cost of regression testing is high due to an increase in the number of revisions that are introduced per day as well as the number of tests developers write per revision.
regression test selection rts optimizes regression testing by skipping tests that are not affected by recent project changes.
existing dynamic rts techniques support only projects written in a single programming language which is unfortunate knowing that an open source project is on average written in several programming languages.
we present the first dynamic rts technique that does not stop at predefined language boundaries.
our technique dynamically detects at the operating system level all file artifacts a test depends on.
our technique is hence oblivious to the specific means the test uses to actually access the files be it through spawning a new process invoking a system call invoking a library written in a different language invoking a library that spawns a process which makes a system call etc.
we also provide a set of extension points which allow for a smooth integration with testing frameworks and build systems.
we implemented our technique in a tool called rtslinux as a loadable linux kernel module and evaluated it on java projects that escape the jvm by spawning new processes or invoking native code totaling lines of code.
our results show that rtslinux on average skips .
of tests and saves .
of test execution time compared to executing all tests.
ccs concepts software and its engineering software testing and debugging software evolution keywords regression test selection language agnostic acm reference format ahmet celik marko vasic aleksandar milicevic and milos gligoric.
.
regression test selection across jvm boundaries.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
introduction to check that recent project changes do not break any established functionality developers practice regression testing running available tests against the new changes.
although immensely important regression testing often comes at a high cost .
google recently reported that the company runs more than million tests daily and the testing cost increases quadratically both the number of revisions per day and the number of tests per revision increase linearly .
background regression test selection rts optimizes regression testing by skipping tests that are not affected by recent project changes i.e.
changes between two given revisions .
to determine which tests are affected dependencies on various source artifacts must be established and maintained for each test throughout the life cycle of a program.
before tests are executed only those tests whose dependencies are invalidated by the recent changes are selected.
an rts technique typically has to make two big choices regarding tracking dependencies what kind of dependencies to track e.g.
at what granularity level and how to track them e.g.
statically ordynamically .
this leads to a whole spectrum of techniques which all greatly vary in safety and precision a safe technique always selects all affected tests while a precise technique does not select any unaffected test .
in this paper we consider java projects that are either multilingual i.e.
make native calls via jni or span across multiple jvms by spawning multiple java processes .
we argue that the existing rts techniques are not well suited for this class of projects.
to address their shortcomings we propose a novel rts technique based on dynamic system level file and process monitoring .
problem existing dynamic rts techniques are all language specific i.e.
unable to observe dependencies that span across languages making them unsafe for multilingual projects.
recent studies found that an open source project is written in five programming languages on average .
existing static rts techniques on the other hand are imprecise .
due to common limitations of static analyses such techniques must typically overapproximate the set of dependencies .
examples include google s continuous integration system tap and microsoft s cloudbuild which only track dependencies between projects.
assume for example a new method is added to a commonly used collections library in such a setting all tests of all dependent projects must be rerun even though none of them are effectively affected by that change.
technique we present the first dynamic language agnostic rts technique dubbed rtslinux .rtslinux collects dependencies at thefile level granularity.
to do so rtslinux integrates with the os kernel via a loadable kernel module where it intercepts all relevant process and file related system calls.
the benefits of such tight esec fse september paderborn germany ahmet celik marko vasic aleksandar milicevic and milos gligoric integration with the operating system are twofold it enables rtslinux to precisely observe all dynamic dependencies no matter which part of the test s process tree creates them and keeps the overhead to a minimum.
finally rtslinux provides primitives and extension points for easy integration with testing frameworks and build systems as well as for further domain specific improvements of the technique s precision.
evaluation we evaluated rtslinux on revisions of popular open source projects.
our evaluation has the following main objectives evaluate rtslinux s effectiveness in its own right in terms of the reduction in testing time evaluate the added benefits of the key novelty behind rtslinux dependency detection across jvm boundaries comparing to an rts tool for java only projects and provide initial assessment of the significance of kernel level integration.
we measured the effectiveness in terms of the reduction in the end to end testing time and in terms of the number of skipped tests .
our results show that rtslinux on average reduces testing time by .
and skips .
of tests compared to retestall i.e.
executing all tests at each project revision .
to measure the added benefit we compared rtslinux to ekstazi a recent rts technique that collects dynamic file dependencies for java projects but fails to collect dependencies created from child processes or from jni calls to code that does not compile to java bytecode.
we compared the two techniques in terms of safety i.e.
the percent of dependencies that are missed by ekstazi and in terms of reduction in number of tests and testing time.
our findings show ekstazi is less safe as it collects only on average .
of accessed files collected by rtslinux .
despite being safer than ekstazi rtslinux achieves comparable savings both in the number of tests skipped and the overall testing time.
motivating examples we motivate our work with two sample unit tests taken from popular open source projects hadoop and ant .
the first sample test illustrates the case when code written in multiple languages is executed in the same process.
the second sample test illustrates the case when code written in a single language is executed in multiple processes.
in neither of these two cases or combinations thereof the existing rts techniques provide safety.
we discuss the issues faced by the existing techniques and briefly describe our proposed technique to overcome the challenges.
.
multiple languages and a single process figure shows a test that invokes c code from java code the test is from the apache hadoop project git sha fe6c1bd7 a popular map reduce framework.
the testsnappynullpointerexception test method which is declared in testsnappycompressordecompressor.java invokes line compress method declared in snappycompressor.java which in turn invokes line compressbytesdirect anative method also declared in snappycompressor.java .
the implementation of the native method is in java compressbytesdirect function written in c and implemented in snappycompressor.c .
java uses the java native interface jni to invoke the native code .
note that jni does not spawn a new process but executes the native code in the same process as the java virtual machine jvm .
testsnappycompressordecompressor.java 2void testsnappynullpointerexception snappycompressor compressor new snappycompressor byte bytes bytesgenerator.get compressor.setinput bytes bytes.length compressor.compress null ... snappycompressor.java 11int compress byte b int off int len ... compress data n compressbytesdirect compresseddirectbuf.limit n uncompresseddirectbuf.clear ... 17native int compressbytesdirect snappycompressor.c 20jniexport jint jnicall java compressbytesdirect jnienv env jobject thisj ... figure an example test from the hadoop project that invokes c code from java without spawning a new process the existing dynamic rts techniques are unsafe in this scenario.
for example ekstazi would collect dependencies only on classes that are loaded in the jvm i.e.
testsnappycompressordecompressor .class and snappycompressor.class but it would not collect the dependency on libhadoop.so that contains the compiled code for snappycompressor.c .
similarly techniques that collect dependencies on executed methods e.g.
testtube would detect methods written in java i.e.
testsnappynullpointerexception compress and compressbytesdirect and would miss functions written in c i.e.
function java compressbytesdirect .
our proposed technique rtslinux is by design oblivious to the specificities of jni.
as such it collects all dependencies introduced by the jvm loading whatever files it needs to execute jni calls.
rtslinux only needs to be informed by a build system or a testing framework when each test starts and finishes no changes to the project under test are needed.
.
a single language and multiple processes figure shows a test that spawns a new java process the test is taken from the ant project git sha c50b683c a popular build system for java.
the testforkedcapture test method declared in junittasktest class checks the correctness of the junit task with fork set to true meaning that ant should execute the test in a newly spawned jvm rather than the same one that ant is already running in .
in the setup of the test a build script to be executed by ant is specified line the build script contains a target with a junit task in it.
the test first sets the fork option to true line and then executes said target line .
the execution continues through the implementation of the build system line until it eventually spawns a new jvm where the requested junit task executes the tests found in the printer class line .
the existing rts techniques would only collect dependencies within the jvm of junittasktest and would miss dependencies introduced from the spawned processes.
for example ekstazi would 810regression test selection across jvm boundaries esec fse september paderborn germany junittasktest.java 2public void setup buildrule.configureproject src etc testcases taskdefs optional junit.xml ... 5public void testforkedcapture throws ioexception buildrule.getproject .setproperty fork true buildrule.executetarget capture ... buildfilerule.java project.java target.java task.java dispatchutils.java !
src etc testcases taskdefs optional junit.xml target name capture depends setup ... junit fork fork test name org.apache.tools.ant...optional.junit.printer ... ... junit target figure an example test from the ant project that spawns a new jvm to execute tests in the printer class collect dependencies on junittasktest buildfilerule project task target and dispatchutils .class files but not printer.class ultimately failing to select testforkedcapture if the printer class is modified impacting the regression testing safety .
rts techniques which collect fine grained dependencies e.g.
testtube or faulttracer face the same issue.
rtslinux automatically tracks the entire process tree of the test rather than a single process at a time and collects dependencies on all files accessed by either the root process or any of its children processes.
given the example in figure therefore rtslinux collects the same dependencies as ekstazi as well as the dependencies introduced by the spawned process i.e.
the printer.class file.
technique this section describes the details of rtslinux .
we describe the common phases performed by traditional rts techniques present the way rtslinux performs those phases discuss a mechanism that a user can utilize to alter the behavior of the technique and present the integration of rtslinux with the existing testing frameworks and build systems.
rts techniques typically include three phases analysis execution and collection .
the analysis phase checks for each test if any of the previously collected dependencies have been affected by the recent changes.
if a test is not invalidated by the changes the test is not executed.
tests for which dependencies have not previously been collected are always selected.
the execution phase runs selected tests.
the collection phase collects dependencies for each test these dependencies are used in the analysis phase of the subsequent project revision.
the execution and collection phases are frequently interleaved i.e.
collection is done during test execution rather than in a separate run.
figure shows the three phases as performed by rtslinux .
function run line takes as input a command to execute and functions defined by the user that can alter rtslinux s behavior as discussed later in this section .
the given command can be an arbitrary unix command in the context of this paper that commandrequire cmd user command to execute require userfuns functions defined by the user function run cmd userfuns ifistestaffected cmd userfuns then processmap empty map pid executetest cmd processmap storedeps cmd pid userfuns processmap end if end function function istestaffected cmd userfuns ifhasdependencies cmd then for all proc setofprocesses cmd do for all dep setofdeps proc do nsum userfuns.cksum proc.type dep.path ifnsum none then nsum syscksum dep.path end if ifnsum dep.cksum then return true end if end for end for return false end if return true end function function systemexecute syscall processmap ifspawnsnewprocess syscall then processmap syscall.currentproc syscall.newpid else if accessesfiles syscall then for all dep syscall.getaccessedfiles do setofdeps syscall.currentproc dep end for end if end function function storedeps cmd pid userfuns processmap processes for all proc p pid s.t.pid p.pid pid transitiveclosure pid processmap do processes proc for all dep setofdeps proc do ifuserfuns.includein dep then dep.cksum userfuns.cksum proc.type dep.path ifdep.cksum none then dep.cksum syscksum dep.path end if end if end for end for setofprocesses cmd processes end function figure analysis execution and collection phases as performed by rtslinux will always execute a test.
if any dependency of the given command is affected line then rtslinux executes the command and stores in the current working directory new dependencies for the given process id line .
we next describe the details of the three phases.
811esec fse september paderborn germany ahmet celik marko vasic aleksandar milicevic and milos gligoric user applications gnu c library glibc rtslinux system call interface kernel architecture dependent kernel code hardware platformgnu linuxu ser space kernel space figure integration of rtslinux in the linux software stack.
rtslinux wraps system calls that manage processes and files .
analysis phase analysis phase figure lines checks if the given command test is affected or not the utility function hasdependencies checks if there are dependencies associated with the given command and the current working directory.
as stated earlier if there are no dependencies associated with the command e.g.
command has not been executed before or its meta data was removed the command is always affected line .
if dependencies are present then rtslinux checks if any dependency of the given command is affected since the latest run lines .
the set of dependencies for a given command includes all dependencies collected in the previous run by any process that was spawned by the command.
to check if a dependency file is modified or not line rtslinux compares the checksum of the current version of the file and the checksum that was computed at the end of the prior execution of the same command.
by default rtslinux computes the checksum of the entire file or file names in a directory.
rtslinux provides an extension mechanism which allows the user to specify a customized function for computing the checksums line .
the custom function accepts two arguments the type of the process that accesses the dependency and the path to the dependency.
based on the type of the process and the type of the file the user can adjust the computation of the checksum.
for example if a process parses an xml file the user may exclude comments from all xml files.
in such cases the command would not be selected if the changes are only in the comments of xml files.
note that computing the checksum is application dependent rtslinux provides a function that ignores debug info in .class files if these files are accesses from a jvm.
the extension mechanism for the checksum can also be used to implement hierarchical checksum i.e.
a user can first check the size of the file and then check the content only if the size is the same.
.
execution phase inrtslinux collection happens for every executed process.
unlike most existing dynamic rts techniques rtslinux does not requirechanges to either sources or binaries of the project under test to enable collection of dependencies.
figure shows the integration of rtslinux in the linux os.
specifically rtslinux implements wrappers for each system call available in linux that manages the set of running processes e.g.
fork or accesses the file system e.g.
open .
after starting the execution of the command line in figure system calls go through rtslinux wrappers.
specifically our systemexecute function line in figure is invoked from the wrappers.
the function checks if the system call is spawning a new process or if it accesses any file or directory on the file system.
if the call spawns a new process rtslinux updates the mapping of processes to include that the current process is spawning a new process the map is used later to reconstruct the process tree which is used to find all transitively spawned processes from the given process id.
on the other hand if the system call accesses a file or a directory rtslinux updates the set of dependencies of the current process.
note that this phase only creates the mapping among processes and collects dependencies but does not compute the checksum of dependencies or associate dependencies with the command being executed.
we separated the two phases to enable the user to collect dependencies for any part of the process tree and to entirely ignore dependencies for some commands if necessary.
.
collection phase collection phase figure lines computes the set of processes transitively spawned from the given command and computes the checksum of each dependency accessed by at least one process.
initially rtslinux finds transitive closure of processes from the process that started the given command line .
to compute the transitive closure rtslinux uses process map which was created during the execution.
note that it is necessary to find only processes that are spawned transitively from the given command because there can be many other processes running in parallel which are not related to the user command.
even more there could be other processes running other tests in parallel.
we discuss several aspects of parallel test execution in section .
computing the checksum of each dependency of each process is similar to the checksum computation that was described in section .
.
as before rtslinux uses the user defined function if provided for computing the checksum.
additionally in collection phase rtslinux provides an extension point where the user can provide a filter to exclude some dependencies e.g.
temp files and directories.
.
system integration we implemented rtslinux as a loadable kernel module and made only a few modifications to the linux kernel .
we have tested our changes with several versions of the linux kernel from version .
.
ckt39 apr to version .
.
jan .
we had to change only five lines of code in our module to enable it to work across all linux versions in the tested range.
specifically an argument to do execve function was moved to a struct so we had to adjust one of our wrapper functions.
we note however that other changes e.g.
addition of a new system call could lead to a much higher maintenance cost.
rtslinux implementation includes all the functions shown in figure and a number of wrapper functions for the existing system 812regression test selection across jvm boundaries esec fse september paderborn germany calls.
the user can invoke either the top level function run or invoke independently istestaffected and storedeps functions.
the runfunction provides a mechanism to collect dependencies for any command e.g.
an arbitrary bash script and skip the execution of the same command in the future if no dependency has changed .
the runis similar to fabricate and memoize build systems except that rtslinux runs as part of the os we discuss other differences in section .
as an example to enable rtslinux when executing tests with maven instead of running mvn test the user should run rtslinux mvn test .
the rtslinux command implements the runfunction thus it executes the command and collects dependencies only if the set of dependencies collected in the previous run has been affected.
however collecting dependencies for a test command that executes all tests is likely to be imprecise because any change to any dependency of any test would trigger the execution of all tests in the future.
to improve precision the user can run one test per process most popular build systems e.g.
provide options to spawn a new process for each test.
istestaffected andstoredeps can be used by developers of build systems to check if a test should be executed before starting a test and saving dependencies for the test after it was executed.
we integrated rtslinux with maven.
an alternative implementation in addition to rtslinux we implemented our technique in another tool called rtsfab which works in user space i.e.
runs outside the operating system s kernel .
our motivation was to explore and compare the overheads of various approaches for collecting test dependencies.
rtsfab is implemented on top of fabricate a build system with dynamic dependencies that uses strace to collect accessed files .
evaluation we assess the usability of rtslinux by answering the following research questions rq1 how effective is rtslinux i.e.
what is the reduction in testing time and the number of executed tests?
rq2 what are the benefits drawbacks of dependency detection across jvm boundaries as implemented in rtslinux compared to a single jvm rts as implemented in ekstazi a recently developed rts tool for java .
specifically rq2.
efficiency does rtslinux achieve as much reduction in total testing time and number of executed tests?
rq2.
safety how many more dependencies are discovered byrtslinux ?
rq3 what is the overhead of rtsfab a naive implementation of our technique running in user space compared to rtslinux ?
the main objective of our evaluation is to show that rtslinux is as effective as the state of the art and detecting filebased dependencies at the system level is beneficial.
additionally by comparing rtslinux tortsfab we provide an initial assessment of the importance of implementing our technique in kernel space instead of in user space.
although rtsfab may not be the most efficient possible implementation running in user space we believe it provides a good starting point for seeking an implementationrequire project a project under study require tool an rts tool under study function experimentprocedure project tool clone project.url checkout project.sha for all last20revisions project do project.sha checkout project.sha ifbuild project failed then continue end if test results test project storeavailable project test results integrate project tool selected select project test results deps test project selected storeselected project tool test results deps end for end function figure experiment procedure running in user space that is as efficient and as easy to integrate with the existing build systems as rtslinux is.
we first describe the setup of our study section .
and then answer the research questions section .
.
section .
includes additional case studies including an experiment in using rtslinux with a python project.
.
study setup .
.
projects.
table lists the projects used in this evaluation sorted by test execution time.
this list includes projects from recent studies on regression testing as well as a number of new projects containing tests that escape the jvm by spawning processes and or making native calls.
although not all of the projects used in previous studies require rtslinux s cross jvm capabilities they still serve as fair benchmarks for evaluating rtslinux on its own merit rq1 and comparing it to ekstazi in terms of efficiency rq2.
.
we required that each project is available on github and builds with maven which simplified our experiment infrastructure.
columns in table designate project name github repository url latest revision sha used in the study number of lines of code loc as measured with sloccount number of maven modules total number of files total number of test classes test execution time for all test classes for a single project revision and the way in which at least some tests escape the jvm they run in processes spawns subprocesses native calls has native calls files accesses external files e.g.
txt files for projects that escape the jvm via both subprocesses and jni we mark them only as processes in the table because that is the more interesting case from rtslinux s perspective.
for each project we evaluated our selection technique over revisions such that the latest of these revisions is the one reported in the sha column we report the averages in the second and third to last columns in table .
the last two rows show the total p and average avg.
values for each column if appropriate .
in summary our evaluation spans across revisions of projects totaling lines of code.
.
.
experiment procedure.
figure provides the procedure that we used to collect data for the analysis for a single project.
813esec fse september paderborn germany ahmet celik marko vasic aleksandar milicevic and milos gligoric table projects used in the evaluation project url sha loc maven modules files test classestest time escape method la4j vkostyukov la4j.git 358be77e .
.
n a scribejava fernandezpablo85 scribe java.git 5175a416 .
.
n a bukkit bukkit bukkit.git f210234e .
.
n a zt exec zeroturnaround zt exec .
.
processes crypto apache commons crypto.git dc1769ed .
.
native calls retrofit square retrofit ec0635c6 .
.
files codec apache commons codec.git 535bd812 .
.
files vectorz mikera vectorz.git 425109e2 .
.
n a lang apache commons lang.git 17a6d163 .
.
files net apache commons net.git 4450add7 .
.
files config apache commons configuration.git 8dddebf1 .
.
files io apache commons io.git e8c1f057 .
.
files okhttp square okhttp d854e6d5 .
.
files closurec google closure compiler.git 283d8161 .
.
native calls dropwizard dropwizard dropwizard.git 1e40fef4 .
.
processes cloudstack apache cloudstack.git 56a35265 .
.
processes tika apache tika 9cf82589 .
.
processes math apache commons math.git 471e6b07 .
.
files guava google guava.git 061da3b3 .
.
files metron apache incubator metron .
.
processes activiti activiti activiti.git b2eba94b .
.
processes pn a n a .
.
n a avg.
n a n a .
.
.
.
.
n a in the first step line we clone the project and then line checkout the latest revision used in the study sha column in table .
next we iterate over the last project revisions lines starting from the oldest revision and moving towards newer revisions.
we consider only project revisions that are on the master branch because many projects run regression tests only against those revisions.
in each iteration of the loop we build the project and skip the revision if the build fails.
if the build is successful we execute the available tests and save the results.
to force each test to run in a separate jvm which is a common practice we run mvn test dforkcount dreuseforks false .
note that mvn test runs several build phases including the compilation phase prior to running the tests.
we will use eavailableto denote this end toendtest execution time and navailableto denote the number of available tests.
in the next step the procedure line integrates rtslinux by enabling our module in the linux kernel and including the rtslinux maven plugin into the project under study.
the tests are then selected based on the dependencies collected in the previous run and those tests are executed line .
finally the procedure stores the results and newly collected dependencies for the executed tests line .
we will use eselto denote end to end time to select tests execute those tests and collect dependencies we will use nselto denote the number of selected tests.
using the collected data we compute test selection ratio ass nsel navailable and savings in terms of end to end time as t esel eavailable .
savings in terms of end to end time compared to retestall is the key metric for measuring the benefits of an rts technique .
to be consistent with prior studies wealso report test selection ratio the saving in terms of the number of tests is a metric independent of the machine used for running the experiments.
.
.
execution platform.
we run all experiments on a core intel r core tm i7 cpu .40ghz with 16gb of ram running our version of ubuntu .
lts.
similar to several recent studies we used multiple versions of java oracle jdk 7u72 and 8u60 which was necessary because several projects e.g.
lang do not work with newer java versions.
.
answers to research questions .
.
rq1 how effective is rtslinux .table shows the main results for rtslinux .
columns are explained in section .
.
column denotes the total number of dependencies used by tests we counted dependencies that are in the project under study the local maven cache or executable files used by tests .
the last two rows show the summary values where appropriate and average values computed over all projects.
we discuss the right hand part ekstazi of the table in the next section.
our results show that rtslinux reduces test execution time for all projects .
in the best case for the netproject time to execute tests is decreased to only .
of retestall time .
in the worst case for the closurec project time to execute tests is decreased to .
.
on average across all projects test execution time is decreased to .
.
similarly rtslinux leads to substantial reduction in terms of the number of executed tests.
in the best case for the config project rtslinux selects only .
of available tests.
in the worst case for the vectorz project rtslinux selects .
of available tests.
we can observe that there are significant 814regression test selection across jvm boundaries esec fse september paderborn germany table test execution time and test selection ratio for rtslinux and ekstazi project rtslinux ekstazi time tests deps time tests deps esel t nsels esel t nsels la4j .
.
.
.
.
.
.
.
.
scribejava .
.
.
.
.
.
.
.
.
bukkit .
.
.
.
.
.
.
.
.
zt exec .
.
.
.
.
.
.
.
.
crypto .
.
.
.
.
.
.
.
.
retrofit .
.
.
.
.
.
.
.
.
codec .
.
.
.
.
.
.
.
.
vectorz .
.
.
.
.
.
.
.
.
lang .
.
.
.
.
.
.
.
.
net .
.
.
.
.
.
.
.
.
config .
.
.
.
.
.
.
.
.
io .
.
.
.
.
.
.
.
.
okhttp .
.
.
.
.
.
.
.
.
closurec .
.
.
.
.
.
.
.
.
dropwizard .
.
.
.
.
.
.
.
.
cloudstack .
.
.
.
.
.
.
.
.
tika .
.
.
.
.
.
.
.
.
math .
.
.
.
.
.
.
.
.
guava .
.
.
.
.
.
.
.
.
metron .
.
.
.
.
.
.
.
.
activiti .
.
.
.
.
.
.
.
.
p1847.
n a .
n a .
n a .
n a n a avg.
.
.
.
.
.
.
.
.
.
.
.
differences in reduction in terms of the number of tests and time.
recall section .
that we measure end to end time for the entire build as developers would do when running their tests rather than measuring only test execution time therefore we tend to observe smaller savings for projects where build phases e.g.
compilation take longer than test execution.
.
.
rq2.
how does rtslinux compare to ekstazi in terms of efficiency.
table right shows the results for ekstazi including time taken to execute selected tests column time to run selected tests normalized by retestall column the average number of selected tests column test selection ratio column number of dependencies column and number of dependencies normalized by rtslinux dependencies column .
the last two rows show the total and average values.
in summary test selection ratio is .
and .
and execution time is decreased to .
and .
for rtslinux and ekstazi respectively.
it is expected that rtslinux takes longer to execute tests because it captures more dependencies than ekstazi as discussed in the next section which may lead to more tests being affected per run and higher cost for computing checksums.
although test selection ratio is the same for most of the projects we can observe differences in several cases e.g.
io .
vs. .
.
such a difference can happen for two reasons tests create directories and or files that are not removed when test execution finishes and ekstazi misses to collect some files that are modified between revisions.
we illustrate these two cases using the ioproject.
many tests in the ioproject create the test directory in the root of the project but they do not remove the directory upon completion.consider a test tthat creates the test directory.
when the test finishes rtslinux computes the checksum of the test directory which is non empty at this point .
at the next project revision under the assumption that we are running tests on a continuous integration service cis e.g.
travis ci which always does a clean build rtslinux will compute the checksum for the test directory and find that the checksum is different from before thus rtslinux will select tevery time for the execution.
note that the same problem can happen even if developers do not use cis but multiple tests use the same test directory that is not cleaned .
this problem happens for several other projects including config and closurec observe that the test selection ratio in the table is the same for these two projects because we automatically insert code to cleanup project repository prior to computing the checksum.
as mentioned before another reason for the difference in test selection ratio is the difference in the set of dependencies.
we observed that several tests in io e.g.
directoryfilecomparatortest traverse all files from the root of the project whenever any of these files change rtslinux selects tests for the execution while ekstazi misses to select these tests.
.
.
rq2.
how does rtslinux compare to ekstazi in terms of safety.
we find that ekstazi collects only .
of dependencies collected by rtslinux see the last row in the last column in table .
therefore ekstazi is less safe than rtslinux .
despite these differences in the set of dependencies the reduction in test execution time by rtslinux and ekstazi is similar which demonstrates thatrtslinux is efficient.
we observed for rtslinux that projects with many maven modules have high number of dependencies the 815esec fse september paderborn germany ahmet celik marko vasic aleksandar milicevic and milos gligoric table overhead introduced by rtslinux ekstazi and rtsfab for the first revision compared to retestall project retestall rtslinux ekstazi rtsfab la4j .
.
.
.
bukkit .
.
.
.
codec .
.
.
.
vectorz .
.
.
.
lang .
.
.
.
net .
.
.
.
config .
.
.
.
io .
.
.
.
math .
.
.
.
zt exec .
.
.
.
crypto .
.
.
.
avg.
.
.
.
.
number of modules is reported in table .
this high number of dependencies happens because java searches for a class file in all modules on the classpath prior to searching in third party libraries.
note that rtslinux collects even files that are non existent and assigns a special flag to them because adding such files can affect test execution.
.
.
rq3 what is the overhead of rtsfab our technique implemented in user space compared to rtslinux .table shows for each project time to run all tests repeated values from table and overhead of rtslinux ekstazi and rtsfab when all tests are run which happens for the first revision .
table includes only single module projects because rtsfab currently supports only those projects.
on average rtslinux ekstazi and rtsfab introduce .
.
and .
overhead respectively.
we can conclude thatrtsfab is significantly less efficient than rtslinux .
a more efficient way to implement our technique in user space could still exist e.g.
using fuse this question is left for future work.
additionally we can conclude that the collection phase of rtslinux introduces lower overhead than that of ekstazi but it takes more time to compute checksums due to larger number of collected dependencies .
the latter conclusion is supported by tables and .
we can see that for the first project revision when computation of checksums is done only once after tests were executed rtslinux introduces lower overhead.
however on average across revisions when checksums are computed both during the analysis phase and collection phase rtslinux introduces slightly higher overhead.
.
case studies we performed several case studies to further evaluate rtslinux and test its correctness.
specifically we checked if rtslinux gives the expected results for our motivating examples section tried several interesting tests from various projects and evaluated the benefits of rtslinux when applied to a python project.
.
.
multiple languages and a single process.
section .
introduced a test from the hadoop project which is written in multiple languages.
recall that the test is executed in a single process.
our goal is to confirm that rtslinux collects necessary dependencies.
we did not use hadoop in our experiments in section .
due to long retestall time and limited resources.
in ourstudy we executed only the testsnappynullpointerexception test described in section .
and we collected dependencies with rtslinux and ekstazi.
rtslinux collected dependencies includinglibhadoop.so which contains the compiled c code while ekstazi collected only dependencies not including libhadoop.so .
.
.
a single language and multiple processes.
section .
introduced a test from the ant project that spawns subprocesses.
we did not include ant in our benchmark projects in section .
because it does not build with maven.
as for hadoop we executed only the test method of interest testforkedcapture as expected rtslinux collected printer.class among dependencies while ekstazi didn t among dependencies .
.
.
additional cases.
we have also checked correctness of rtslinux on a few hand picked interesting tests that either use jni or spawn subprocesses.
table shows these tests and compares number of dependencies collected by rtslinux deps and percent of those dependencies collected by ekstazi deps .
we manually confirmed that expected dependencies are collected by rtslinux .
for example javacpp spawns a subprocess that runs a g compiler and depends on .h files and pysonar2 spawns a process that runs python code and depends on .py files .
.
.
a python project.
being implemented at the system level and not tied to java at all rtslinux can be applied to a project written entirely in a non jvm language.
although this paper primarily focuses on predominantly java projects here we discuss our experience of applying rtslinux topendulum the most popular python project on github based on the number of stars .
the pendulum project comes with test methods and includes a custom py.test command used to run them.
because tests for this project take negligible time we measured only test selection ratio.
we modified py.test to integrate rtslinux next we followed the same procedure as for other projects figure .
on average rtslinux reduced the number of executed tests to .
.
in terms of the number of selected tests however rtslinux selected most of them in out of revisions.
the main reason for such high selection rate is the small size of the project so many tests end up importing most of the source .pyfiles unlike in java the import statement in python evaluates the target .pyfile and thus creates a dependency even if nothing from it gets used by the test .
our motivation for including a python project was to show that our technique readily generalizes to other languages we do not mean however to imply that the empirical evaluation results from section .
do too.
to make such a claim a much larger collection of non java projects would have to be included.
further research is also necessary to explore ways of improving precision of rtslinux for python and other languages .
threats to validity external the projects used in our study may not be representative.
to mitigate this threat we used popular open source projects that vary in size number of authors number of revisions number of tests application domain and ways their tests escape from jvm.
furthermore several projects used in our study were used in recent work on regression testing .
816regression test selection across jvm boundaries esec fse september paderborn germany table case studies with native calls and sub processes project url sha test name escape methodrtslinux depsekstazi deps zeppelin apache zeppelin org.apache.zeppelin.integration.authenticationit processes .
ratis apache incubator ratis 7e71a2e0 org.apache.ratis.server.storage.testraftstorage native calls .
javacpp bytedeco javacpp b41028b9 org.bytedeco.javacpp.adaptertest processes .
pysonar2 yinwang0 pysonar2.git dc6d8f10 org.yinwang.pysonar.testrefs processes .
we performed experiments with projects mostly written in java although rtslinux is in theory more broadly applicable .
our main motivation for this work were projects that escape from jvm.
in the future we plan to evaluate rtslinux and develop necessary extensions for projects written in other languages.
we performed our experiments on revisions per project.
the results could differ if we chose different number of revisions or another time frame.
for projects used in a previous evaluation of ekstazi we used the same revisions as reported in that study.
for other projects added in this study we used the latest revisions available at the time of our experiments.
the overhead introduced by the collection phase may differ for other linux kernel versions.
although we tested rtslinux with several linux versions we have not measured the time for each version.
considering that the version was introduced only to avoid high version numbers we do not expect that our results would differ on a few latest releases of the kernel.
internal implementation of rtslinux may contain bugs that may impact our conclusions.
to mitigate this threat we wrote a number of tests manually inspected the output of several examples and compared the outputs of ekstazi and rtslinux .
we also compared rtslinux andrtsfab which should always have the same test selection ratio.
construct we compared rtslinux only with ekstazi although many other rts techniques have been proposed in the past section .
we justify our decision with two reasons.
first other existing rts techniques collect fine grained dependencies e.g.
methods statements basic blocks elements of the extended controlflow graphs etc.
and they are less safe than ekstazi.
ekstazi also compares favorably with the existing rts techniques in terms of end to end regression testing time .
second to the best of our knowledge ekstazi is the only publicly available rts tool for java at the moment.
discussion dependent tests some test suites may have order dependencies among tests e.g.
if test t1executes before test t2 then t2passes otherwise it fails.
therefore if rtslinux selects only test t2for the execution the test would fail if the test t1is not selected.
rtslinux as other rts tools does not reason about order dependencies among tests.
however because rtslinux requires that each test or group of tests specified by a developer executes in a separate process there cannot be a problem due to order dependencies on values in the main memory.
still there could be a problem if tests share state on the disk.
we believe that rtslinux can be a base for a framework for detecting such dependencies.
using rtslinux we were ableto detect bugs when a test does not clean the state on disk in io config and closurec our patches were recently accepted by ioand config developers .
flaky tests flaky tests are tests that non deterministically pass and fail for the same project revision .
there are a number of sources of non determinism including gui events networking concurrency etc.
similar to the existing rts techniques rtslinux collects dependencies only for one possible execution if a test is not selected then the previous execution trace is still feasible.
note that this is consistent with existing static rts techniques that are used in practice .
parallel execution rtslinux supports parallel test execution by tracking dependencies for each user s command separate and monitoring the accessed files directories by transitively spawned processes.
note however that rtslinux does not support distributed tests i.e.
tests that communicate over network but only tests that are executed on a single machine.
one test per jvm although running one test or groups of dependent tests per jvm can introduce overhead it is still a common approach practiced in industry .
as a result rtslinux fits well in the common development practices and reduces the testing cost by skipping many tests after code changes.
detecting files loaded by jvm in ekstazi ekstazi has a hidden option to collect files loaded by jvm which is untested and disabled by default.
in our experiments hence we used the default stable ekstazi configuration.
in principle even when collecting all files loaded by jvm ekstazi still cannot detect file accesses made from spawned processes and from native code making it strictly less safe than rtslinux .
related work regression test selection there has been a lot of work in the last three decades on regression testing and on regression test selection .
prior work on dynamic rts techniques mostly explored fine grained dependencies including dependencies on functions methods e.g.
statements e.g.
basic blocks e.g.
and elements of extended control flow graphs .
recent work introduced ekstazi that collects dynamic file dependencies which we discussed throughout this paper.
unlike the existing techniques rtslinux supports tests that are written in multiple languages and spawn multiple processes.
kung et al.
introduced the class firewall a technique that statically identifies modified set of classes for two project revisions.
skoglund and runeson proposed an rts technique based on the class firewall and later improved the precision of their technique .
orso et al.
combined the class firewall static 817esec fse september paderborn germany ahmet celik marko vasic aleksandar milicevic and milos gligoric technique and dangerous edge dynamic technique to increase safety and improve precision.
recent work compared static and dynamic rts and showed that static techniques tend to be unsafe and imprecise.
several researchers proposed rts techniques that collect dependencies on external resources .
haraty et al.
and daou introduced regression testing techniques for database applications.
willmor and embury presented a new definition of safety that takes into account the interaction of the program with a database state.
nanda et al.
recently proposed an rts technique that collects dependencies on non code elements such as configuration files and databases.
rtslinux collects not only dependencies on configuration files and databases but on any file accessed by any process transitively spawned by the test.
tracing tools there are several tools for tracing system calls in the linux kernel.
the most popular tool for tracing system calls is thestrace tool .
internally strace uses ptrace system call that stops the traced process es for each call and introduces observable overhead when many system calls are made by the traced process es .
for example the execution of du sh is hundreds of times faster than the execution of strace du sh .
another popular tool available in linux is perf trace .
although this tool has much lower overhead than the strace tool perf trace does not provide a way to extract the file names in human readable format .
other third party tools are available including systemtap lttng and ktap.
these tools are more generic than rtslinux and require the use of domain specific languages to specify calls to be traced.
additionally our attempt to use systemtap was unsuccessful due to incompatibility with recent versions of the linux kernel.
build systems and memoization many build systems including ant make maven and gradle support incremental execution of a build target but the incremental computation is commonly based on statically computed dependencies which makes them unsafe.
modern cloud based build systems improve safety of incremental builds by keeping the explicit list of fine grained dependencies but require substantial effort by the users and are rather imprecise .
memoize and fabricate collect dynamic dependencies on executed files by using the strace command these systems do not collect dependencies on accessed files that do not exist.
scons and vesta capture accesses to files even if the files do not exist however scons does not support an arbitrary language by default and vesta requires that used files are under revision control.
tup collects dynamic file dependencies via fuse therefore tup currently cannot collect separate set of dependencies for tests that are running in parallel processes.
pluto is a build system for java that dynamically collects file dependencies and uses semantic hashing.
regarding memoization guo and engler proposed incpy that memoizes calls to functions even if functions access files.
similar to existing rts techniques incpy is language specific.
rtslinux was inspired by both the existing build systems and memoization.
however rtslinux is complementary to build systems and can be integrated with any build system to enable rts as long as the build system notifies rtslinux when each test starts and finishes these notification can be easily added via plugins that are supported by many existing build systems.
rtslinux alsomay reduce the need for build system migration that can be nontrivial .
provenance aware systems provenance aware systems provide meta data that describe the history of various objects in a system.
initial work on provenance aware systems was language specific e.g.
.
recent work explored support for multilingual projects via libraries that require manual annotations and os logging .
muniswamy reddy et al.
proposed a technique that collects meta data on various abstraction levels.
bates et al.
presented a whole system provenance aware technique that collects meta data for the entire system with negligible overhead and gehani and tariq introduced support for provenance auditing in distributed environments .
lee et al.
presented an approach that avoids dependency explosion.
rtslinux and any other rts technique and the provenance aware systems have different goals which is reflected in the type of collected meta data and the way the meta data is used.
for example an rts technique needs to know when each test starts and finishes.
continuous integration services recent work by vasilescu et al.
and hilton et al.
showed that continuous integration services ciss such as travis ci are widely used and improve the productivity of project teams.
currently more than 300k projects use travis ci which is only one out of more than publicly available ciss.
ciss are used by projects written in different combination of programming languages and build languages.
rtslinux could easily be integrated with a number of ciss that run linux based vms which would lead to reduction in regression testing cost for a number of projects.
conclusion we presented a novel regression test selection technique dubbed rtslinux .
the key novelty is that rtslinux supports tests that escape jvm e.g.
spawn multiple subprocesses .
for each test rtslinux collects all accessed files by the process running the test and all spawned subprocesses the overhead of collection is reduced by implementing rtslinux at the system level as a loadable kernel module .
rtslinux provides extension mechanism for smooth integration with build systems and testing frameworks.
our results show that rtslinux substantially reduces testing time compared to retestall.
additionally our experiments showed that rtslinux achieves similar savings for java projects as ekstazi a regression test selection tool for jvm languages while improving the safety.
although more research is needed to evaluate rtslinux for various languages and improve its precision by combining it with languagespecific techniques we believe that current savings achieved by rtslinux can make a significant difference for a large number of multilingual projects and any continuous integration service.