build system with lazy retrieval for java projects ahmet celik1 alex knaust1 aleksandar milicevic2 and milos gligoric1 the university of texas at austin1 usa microsoft2 usa ahmetcelik awknaust utexas.edu almili microsoft.c om gligoric utexas.edu abstract in the modern day development projects use continuous integration services ciss to execute the build for every change in the source code.
to ensure that the project remains correct and deployable a cis performs a clean build each time.
in a clean environment a build system needs to retrieve the project s dependencies e.g.
guava.jar .
the retrieval however can be costly due to dependency bloat despite a project using only a few files from each library the existing build systems still eagerly retrieve all the libra ries at the beginning of the build.
this paper presents a novel build system molly which lazily retrieves parts of libraries i.e.
files that are ne eded during the execution of a build target.
for example the compilation target needs only public interfaces of classes within thelibraries and thetest target needs only implemen tation of the classes that are being invoked by the tests.
additionally mollygenerates a transfer script that retrieves parts of libraries based on prior builds.
molly s design requires that we ignore the boundaries set by the library developers and look at the files within the libraries.
we implemented mollyfor java and evaluated it on popular open source projects.
we show that test targets on average depend on only .
of files in libraries.
a variant ofmollyspeeds up retrieval by .
.
furthermore the scripts generated by mollyretrieve dependencies on average .
faster than the maven build system.
ccs concepts software and its engineering software notations and tools keywords build system continuous integration service .
introduction continuous integration ci i.e.
integrating all developer working copies into a shared mainline of source code as often as multiple times a day has been widely adopted as part of agile software development in general and in ex treme programming in particular.
in theenvironmentof01234 codec io math net pool lang closurec jxpath config jgit retrofit guava okhttp orientdb empiredb dpatterns cxf projectretrieval ratio molly maven thread count figure comparison of a baseline dependency retrieval the transitive closure is computed and libraries are retrieved in parallel as implemented by maven vs. the ideal case all necessary files are known upfront and these files are retrieved in parallel .
values on the retrieval ratio axis are proportional to the baseline value which is .
rapid code changes ci was designed to prevent scenarios in which a developer working copy significantly diverges from the mainline to the point where integration becomes difficult and time consuming.
in the modern day development ci is typically performed by a dedicated service continuous integration service cis after every push to the source repository.
onesuchpublicservice travisci for exa mple is used by more than 300k projects today and performs approximately 130k builds daily .
to ensure that the project being developed remains deployable after every push a cis has to perform a clean build every time starting from a clean state on disk the latest copy of the source code is fetched from the repository dependencies to other projects or libraries are retrieved th e project is compiled and finally all tests are run.
in this paper we focus on improving the dependency retrievalstep.
the common inefficiency of this particular step has been widely recognized .
as an example it can take up to an hour to retrieve all libraries on which the apache camel project depends.
to motivate the problem further consider figure where we take popular open source java projects all using the maven build system and show how much faster at least in the ideal scenario the dependency retrieval step can be.
this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version was published in the following publication fse november seattle wa usa c acm.
... 643the baseline denoted as value on the yaxis is the default dependency retrieval implemented by maven the transitive closure of libraries is computed first then the resolved li braries are retrieved in their entirety.
we tried configuring the size of the thread pool used by maven for retrievingdependencies byusingthe dmaven.artifact.threads option butthischangehadnoimpactontheretrievaltime.
in contrast imagine if the full list of used libraries e.g.
.jarfiles was known upfront there would be no need for any additional computation and the files could be retrieved massively in parallel.
further imagine if not only the nece ssary libraries are known buttheexact individualfiles with in those libraries e.g.
.classfiles only those files could be retrieved still massively in parallel saving both disk s pace and total retrieval time.
for the projects listed in figure we statically computed the minimal set of necessary files and measured the time it took to retrieve them in parallel later in the paper we show how this can be achieved fully automatically by a general purpose build system when using threads on a core machine the total retrieval time is reduced by .
on average.
problem thekeycontributortoslow dependencyretrieval is what we call dependency bloat .
thedependency footprint of a project includes all libraries the project may possibly use.
build systems e.g.
typically retrieve the entire footprint eagerly prior to executing concrete build targets.
in practice however often times not every librar y or part thereof gets used during a concrete build.
reasons are various a project may not use some of the transitive libraries e.g.
very few projects that depend on junit use junit s dependency hamcrest the compilation phase needs only the apis of classes rather than their implementation thecompilation phasemayfail sothereisnonee d to retrieve libraries used by any later phases e.g.
testin g and even if all tests are successfully executed they may use only a small fraction of files from the libraries.
solution to mitigate the dependency bloat problem in a generic and application agnostic way we propose lazy dependency retrieval .
provided that the host language compiler runtime allows for dynamic library loading the buil d system ought to retrieve physical dependency artifacts e. g. by retrieving them from a central repository only when requested by the compiler runtime that is only when triggered by execution of concrete build targets.
we also propose a variant of lazy dependency retrieval where boundaries set by library providers are ignored by the build system and instead library content is retrieved on individual file basis.
we dub this technique elastic dependencies .
in our experiments we observed that elastic dependencies reduce the total size of retrieved content by .
on average.
finally to further reduce the cost of dependency retrieval forsubsequent builds we use our infrastructure to maintain a flattened list of resolved dependencies called transfer script which helps us get closer to the ideal retrieval time figure .
note that our infrastructure for lazy retrieval is still needed during the subsequent builds to retrieve new dependencies and update the flattened list for future builds .
implementation we implemented a prototype of the proposed technique in a novel build system for java projects calledmolly.
we implemented lazy dependency retrieval and elastic dependencies by modifying both the java compiler and the java runtime.theoryrunbeforerunnerexternalresourceurlconvertermethodutilsarrayconverter objenesishelper androidinstantiator objectinstantiator 137commons beanutils .
.
314junit .
indexclasshsql .
.
.
35objenesis .
testautosavelistener testiniconfiguration unused used by both tests figure dependencies for two tests in config .
evaluation we evaluated mollyon popular opensource java projects.
we report both empirical findings and concrete improvements observed when using molly empirical averagetimespentondependencyretrieval .
of the total clean build time improvement average reduction in dependency retrievaltime .
duetolazydependencyretrieval improvement average reduction in size of retrieved dependencies .
due to both lazy dependency retrieval and elastic dependencies .
mollyachieves significant savings in both build time and disk space which we believe can have a profound impact on reducing the cost of running and maintaining any cis.
.
overview this section illustrates mollythroughan example.
first we introduce a project to build.
next we walk through the build process as carried out by both maven a widely used buildsystem from apache and molly.
we compare and contrast compilation and execution models of the two and discuss the benefits brought by molly.
finally we describe the way mollyobtains a transfer script.
example project config is an apache project for parsing configurations from a variety of file formats.
the configproject includes a maven build script pom.xml listing all its dependencies.
each such dependency is a maven project too containing its own build script specifying its own dependencies.
the most recent version of configtransitively depends on libraries.
figure depicts some of them as boxes containing a few representative classfiles de noted as circles and illustrates which of those classfiles a re used by two randomly chosen unit tests.
assume that a developer of configpushes a change to the repository and a build is triggered by a cis.
we consider the following three scenarios compilation of test sour ces fails only one test is run and build succeeds.
we nextdescribe mavenand mollyandshowhowtheymanage dependencies for these three scenarios.
644maven central x.jar x1.class x2.classmolly repository x.jar xt .class xt .class x x1.jar x1.class x x2.jar x2.classbuild system runtime environmentx1.classmaven local x.jar x1.class x2.class molly localx.jar x1.class xt .classcompile test trim split testmergecompile mergesave save figure molly s architecture solid lines and a conventi onal build system maven dashed lines .
maven eagerly retrieves x.jarprior to the compilation and test execution whereas molly l azily retrieves trimmed x.jarat compile time and lazily retrieves necessary executable c ode at runtime merging when convenient.
maven maven automatically manages a project s dependencies based on the user s specification in the build script .
specifically maven maintains the maven central repository of publicly available libraries .
we mined the maven central repository and discovered that it currently includes libraries totaling 043gb.
maven ce ntral repository allows library developers to autonomously deploy their libraries to the repository.
consequently th e library developers determine the size and content of the library and consumers of the library have no way of specifying which parts of the library they need they must use the entire library or none of it.
when a build is executed maven automatically retrieves the necessary libraries for the executed target based on pom.xml .
the retrieved libraries are saved in the local repository on disk for later reuse.
note that if a project uses cis the libraries are removed from the local repository when the build finishes1.
figure dashed lines illustrates the maven build model.
when a user invokes a target maven retrieves the dependencies eagerly before the execution of the target begins.
for our example scenarios importantly maven retrieves the same set of libraries regardless of which test is executed.
the retrieved libraries include boththeuser specified depe ndencies and transitive dependencies with their entire contents.
however the failing compilation does not need the executable code of the compiled files but only their public interfaces.
the executed test testiniconfiguration does notneeddependencies e.g.
objenesishelper usedbynonexecutedtests andevenasuccessful builddoes notneedfile s that are never used e.g.
indexclass .
other popular build systems including ant ivy bazel limited gradle and sbt follow a simi lar approach with respect to dependency retrieval from the maven central repository.
molly mollyintroduces a novel execution model shown in figure solid lines which tightly couples the build sy stem the compiler and the runtime environment.
unlike the existing build systems mollyretrieves parts of libraries lazily during the execution of the targets.
like other build 1recently several ciss including travis ci introduced simple caching support that packages dependencies into an archive and uploads it to a remote storage service.
however retrieving a large cache can be costlier than retrieving the original dependencies .
note that our work is complementary to caching and can reduce the cache size.systems mollymaintains its own central repository the two boxes that shown in figure .
the library developers deploy the same libraries as they would to maven central repository.
when a library is uploaded mollyruns its preexecution phase which splitsthe library into files and trimsthe library to reduce it to its public api.
specifically mollycreates one library for each classfile in the original library bottom second box from the left in figure and then trims classfiles from the original library so that the trimmed library consists only of the public interfaces of th e original classfiles top second box from the left in figure .
for our running example config molly s splitting step will create new libraries and the trimming step will reduce the size of the libraries by .
.
when a user invokes a target molly in itsexecution phase lazily retrieves only the classfiles that are needed for the execution and loads them into the main memory third bottom box from the left in figure .
then either in parallel with the execution or offline between two build runs mollymergesretrieved classfiles into libraries in the local repository.
note that merging is unnecessary for the execu tion of the build but it is used to keep mollytransparent to the user .
an additional advantage of mollyis that it makes the molly central repository transparent to both the library developers as theydonothave tothinkhowthe best to split their libraries and users of the libraries as they do not have to worry about unnecessarily files being retrieved .
in our three scenarios for config mollyretrieves only the interfaces of classfiles needed to compile tests.
if the user executes only testiniconfiguration mollyretrieves of files the numbers are shown below the boxes in figure from commons beanutils and no files from either objenesis orhsql.
if the user instead executes testautosavelistener mollyretrieves of classfiles from objenesis but none from commons beanutils and also none from hsql.
even when the build succeeds and all tests are executed configonly uses .
of classfiles.
we present other results in section .
during the build mollyobtains a transfer script for the subsequent build we discuss the details of the generated scripts in section .
.
as described earlier transfer scri pt contains the flattened list of files retrieved during the buil d. if the script exists it is executed at the beginning of the build and newly needed files are retrieved by mollylazily during the build execution.
.
molly phases this section describes molly spreexecution phase performed when a library is deployed to molly central repository section .
execution phase performed when a build target is executed section .
and generation of the transfer script section .
.
we assume the standard semantics for the java classfiles and the java runtime .
throughout this section we provide the intuition for why mollypreserves the behavior of the original build.
.
preexecution trimming and splitting in the preexecution phase a library l is decomposed into a compile time component lt and the runtime components l r .
for each java classfile in the library z l the compile time component of the classfile zt s.t.
zt lt andzt trim z should contain only the class s public interfaces whichwedefinelater inmoredetail .
each runtime component lrcontains exactly one of the classfiles from the original library i.e.
z l. lrsuch that z lrand negationslash lr such that z lr .
.
.
trimming step the objective of the trimming step is to decompose an existing library l a container of compiled java classfiles into a new trimmed library lt that can be substituted for l during the compilation phase of any dependent.
additionally the trimfunction should extract a dependent agnostic interface of lthat is smaller delaying decisions about which classes are really needed until runtime.
the requirements o f ltare stated below .
for any project pthat depends on l ltmay be substituted for lat compile time.
.
the product of the compilation with lt will be identical to the product of the compilation with l. .ltshould be the smallest possible library in terms of code fragment that satisfies the above two requirements and each classfile passes the java verification.
requirement ensures that ltis independent of a project p so that trim l lt which may be expensive is performed only once per library.
this requirement also guarantees that from the compiler s perspective ltis identical tol so that the developers of pcan substitute ltforlin compilation.
the second requirement guarantees that will be possible to build pusingltand later replace ltwith lat runtime.
the third requirement sets the optimization goal for the trimming step it should remove as much compiled code as possible while still satisfying the first two r equirements.
if ltsatisfies these requirements it will be a physically smaller version of l that can be transparently substituted for lat compile time.
the trimming algorithm works by removing sections of the compiled classfiles that are not visible to its dependent s. these can be broken up into two categories executable code andnon visible members .
rewrite rules we define the trimfunction with a set of rewrite rules.
each rule has the following form c condition wherecis the context before afterare java statements orclass members e.g.
fieldsormethods ortheemptystring denoted by andcondition defines the applicability ofstatic mod type f ifprivate mod mod type f exprtype mod type f zero type ifprivate e atio slash modand type e atio slash pror type prand const expr or static final e atio slash mod mod type m ifprivate mod mod type m mod type m return zero type ifprivate e atio slash mod mod c ifprivate mod mod c mod c ifprivate e atio slash mod mod class m ifprivate mod figure rewrite rules for the trimming phase.
mod type m mod native type m ifprivate e atio slash mod figure alternative rewrite rule for in figure .
the rule.
interestingly our rules apply in any context so we always omit c. additionally we omit the condition if a rule always applies.
moddenotes a set of java modifies exprtypedenotes any expression of the specified type typedenotes any type and prdenotes primitive and string types.
we use fto refer to a field mto refer to a method andcto refer to a constructor.
are positional parameters and their use on the right side follow the order on the left side.
function zero type returns default value for the given type e.g.
nullfor a reference type for int etc.
.
we define a predicate const expr that holds iff the given expression is a constant expression e.g.
string f or string type .
the rewrite rules are shown in figure .
the class members and statements that are never explicitly used on the left side of the rules remain unchanged.
although our implementation of mollytrims java classfiles we define the rewrite rules on java source level for the simplicity of exposition.
note that some rules cannot apply to java source code directly and are mentioned below.
most of the rules are straightforward so we explain the intuition behi nd the rules on a high level and emphasize the rules that are potentially less obvious.
privateaccessmembers fields methods constructors and inner and nested classes of lcannot be referenced by pat compile time duetoaccess modifiers.
followingthestandard java specification the trimfunction may safely remove all privatefields methods constructors and classes of l since these may only be referenced in the classes in which they are defined.
this is described by rules and .
note that private members can be accessed through the java reflection mechanism but that belongs to the execution phase and we describe it in section .
.
646package privateaccessmembers fields methods construc tors andclasses areonlyaccessible withinthesamepacka ge in which they are defined.
unfortunately it is not possible to remove signatures of such members from las a class c1 of project pcan be in the same package as c2ofl in which case at compile time methods in c2should be able to reference package private members of c1.
sinceprotected visibility implies package private visibility the trimmer also keeps the signatures of protected and obviously publicmembers .
bytecode instructions for anymethod andconstructor can be replaced by a return statement with the appropriate default value and no statement for the constructors and void methods .
this is specified with rules and .
note that performing the change on source code level would not be compilable in cases when a super class defines a constructor with non empty list of arguments.
this is not an issue on the bytecode level as exception would not be thrown until the class is instantiated.
figure shows an alternative approach for trimming non private methods each method can be made native indicating that its implementation is provided via a non java binary using the java native interface jni which can save several extra bytes per method.
there is a special treatment for non private static final fields rule .
if a field has both static not bound to object instances and final cannot be altered after initialization modifiers and const expr holds for the expression assigned to the field we do not rewrite the value of that field.
for these fields java bytecode compilers may inline the values of constant fields duringcompilation.
the prob lem could happen either in compilation phase e.g.
if those fields are used in a switch statement or at runtime.
trimming static blocks rule is straightforward on bytecode level as the constant expressions have been assigned to the final static fields during the compilation.
nested classes definedinside the scope of another class are no exception to the visibility rules described above.
anony mous classes defined within the body of a method are only accessible within the scope they are defined and can be treated as private classes and safely removed from l. .
.
splitting step function split l creates one lrper classfile in l. currently we do not consider the cases when a class c1depends on another class c2for every possible execution and c2is used exclusively by c1 e.g.
a private inner class can always be in the same lras the enclosing class .
it is possible to perform static analysis to conservatively find furthe r cases when one class always depends on another.
optimizing for these cases would complicate the lookup of retrievable classes at runtime and require additional considerati on in the merge step this optimization is left for future work.
it must be possible to determine the corresponding lr fromztat runtime so that it can be lazily resolved and correctly retrieved.
our solution to this is to concatenate the fully qualified class name with the unique identifier of the library creating a name unique in both maven central repository and in the molly central repository.
additionally libraries frequently contain other artifacts e.g.
images we make these artifacts available in lt. .
execution retrieving and merging although pmay be compiled with the trimmed library lt in order to execute pit is necessary to obtain the orig input zthe class attempting to be loaded input repolocalset of local dependencies input reporemoteset of remote split dependencies input mergeset class dep.
pairs to merge initially 1function dynamicload z repolocal reporemote mergeset 2l initandgetlibrary repolocal z.name 3ifz.name e atio slash l.replaced then z retrieve reporemote l.id z.name mergeset mergeset l z return z .src 7end if 8return z.src 9end function 10procedure asyncmerge mergeset repolocal 11for all z l mergeset do 12l l zt z 13l .replaced l .replaced z.name repolocal repolocal l l mergeset mergeset z l 16end for 17end procedure figure dynamicload algorithm retrieves implementation of classes at runtime.
asyncmerge integrates the retrieved classes into the libraries on local disk concurrently or at program end.
inal executable code of l. requirement of the trimming ensures that the compiled output of pusingltis identical to the output of compilation with l so one option would be to fully replace ltwithlat run time when any of the classes is needed.
it may be the case that lis specified as a dependency but never used dangling or only necessary for certain build targets .
in this case this simple techniq ue replacement of ltwithl would still be beneficial.
however as shown in the motivating example pwill likely not require all classes of lto execute.
each execution on an input of prequires some subset of the classes of l. letli lbe the classes required during execution of pon input i. then we can represent the complete partial dependency ofpondaslp uniontext ili.
ideally pcould be made to depend on lpinstead of l. but due to dynamic dispatch reflection and other features of java and other languages it is challenging to compute lpstatically .
instead we build lpdynamically and incrementally retrievingli s lazily during execution.
this is the point where the build system the compiler and the runtime environment cross cut.
in the first execution the program is started with the trimmed libraries retrieved during the compilatio n. on subsequent executions each library may be a mix of trimmed and executable classes loaded in prior executions.
.
.
retrieving step in order to dynamically load the executable classes all class loads must be intercepted.
in java this is possible by providing a system classloader a jvm agent which transforms all classes as they are loaded or modifying the runtime environment.
the dynamicload algorithm depicted in figure is called when the jvm attempts to load a class z. the algorithm first line obtains a local library that should contain z. the library may already be in the local repository if it was needed during the compilation or a prior run .
if the library is not available locally a new library is created based on the build script we assume that 647input repolocalset of local dependencies after build output sexecutable script that retrieves dependencies 1procedure genscript repolocal 2for alll repolocaldo 3s fetch lt.id 4s fetch l.id z.name z.name l.replaced 5end for 6end procedure figure genscript algorithm generates the transfer script.
the algorithm should be run after a clean build but it can be extended to incrementally update the script.
the build script includes a mapping from a classfile to its library.
note that the algorithm ensures that the class is re trieved even if it was not used in compilation e.g.
accesse d through reflection .
second line the algorithm checks ifzhas already been replaced with the executable class in a previous execution and therefore does not need to be retrieved.
otherwise if only the trimmed version of the class is present in the library or the class was not accessed previously the underlying dependency resolution system is call ed to retrieve the lrdependency for z line .
this retrieved classfile is then marked to be merged into its library and returned to the jvm lines and .
.
.
merging step after the executable version of a classfile is resolved and retrieved by dynamicload it is desirable to cache the classfile for future executions.
we perform the merge step to keep molly transparent to the user.
if cis performs clean builds the merge step provides no value and it can be skipped.
asyncmerge described in figure performs this merging.
for each class library pair marked to be merged asyncmerge removes the trimmed classfile if one exists and includes the new classfile.
additionally in order to distinguish between trimmed and original classes a file inside of the library is updated to persist that the class has been replaced.
these new libraries will then be loaded as repolocaland used as input to dynamicload for the next execution of the program.
performing asyncmerge is expensive to execute as the library file must be completely rewritten to add a new classfile.
however since the merged library is only relevant to the subsequent executions the merging may be done in the background or postponed until jvm shutdown which we implement .
in maven and other build systems the retrieved libraries may be shared between different programs however synchronization is required to make this work with asyncmerge .
finally considering that class loading is invoked before any use of the class under the assumption that the network connection is always available mollyhas no impact of the project s behavior.
.
obtaining the transfer script prior sections described the core mollyfeatures that are sufficienttobuildanyjavaproject.
retrievingasingle clas sfile at a time during the build execution however can slow down the build figure .
the full power of mollycan be unleashed by generating a script that prefetches dependencies used in prior builds.
figure shows the algorithm to generate the script.
note that the algorithm assumes that a clean build has finished previously.
for each library thatis in the local repository after build execution we inser t fetchstatement for the trimmed version of the library and onefetchstatement for each non trimmed classfile.
we use standard notation from code generation community to represent code fragments and holes .
on local machines or on ciss which do not use dependency information to trigger builds and tests the generate d scriptscansimplybeusedpriortoeachexecutionanditcan be updated as frequently as developers specify.
note that a stale script does not affect the correctness of the build becausemollywill retrieve newly added dependencies lazily and unused dependencies have no impact on the build.
more generally scan be used as the complete list of dependencies of the project which can be used to trigger build tests .
in this case the script needs t o be updated after each build to ensure consistency.
.
implementation this section briefly describes the implementation of our mollyprototype.
we only describe the implementation of the steps that are relevant for our evaluation.
trimming step trimming is performed on the bytecode of classes within jar files using the asm bytecode manipulation framework .
the trimmer walks the class file tree applying the rewrite rules in figure to generate the class s trimmed bytecode which is then added to a new trimmed jar.
non classfiles in the jar are passed through untouched and an additional file jarsplitter.molly meta is added containing the unique identifier of the artifact.
the existence of this file is used during the retrieving step to determine whether the jar has been altered by molly.
splitting step mollyprovides the splitter tool to split an existing jar into individual class dependencies.
the too l creates a separate jar for each class adding the jarsplitter.molly meta file as before.
packaging each class into a separate jar allows for simpler integration with maven but these could simply be stored as separate classfiles or in a database.
this step is transparently run when a library developer deploys their libraries to the mollyrepository.
retrieving step wemodifiedopenjdk scompiler and runtime jdk8u74 b02 to implement this step.
we currently implement two variants of molly mollyj which retrieves trimmed jars lazily during compilation and retriev es the original jars duringexecution amodification of the ori ginal technique described in section .
and mollyf which retrieves trimmed files lazily during compilation and retrievestheindividualfilesduringexecution amodificat ion of the original technique that uses the algorithm similar to figure both in the compilation and runtime .
weimplementedourcodeintheexceptionhandlingblocks of the compiler i.e.
if a compiler cannot find a class we intercepttheexceptionandretrievetheappropriatelibrary file if the library file is available .
for the runtime environment we do a simple lookup to check if the local class is trimmed and if so the original class is retrieved.
mollyj andmollyfcurrently retrieve jars and files sequentially.
.
ev aluation to assess the usability of mollyin the real world we answer the following research questions rq1 what is the average size difference between a java library jar file and its public api trimmed jar ?
648table details of evaluated open source projects.
project url sha kloc jar file jar size classfile size total mean max mean max codec apache commons codec e9da3d16 .
.
.
.
.
.
io apache commons io e8c1f057 .
.
.
.
.
.
math apache commons math 471e6b07 .
.
.
.
.
.
net apache commons net 4450add7 .
.
.
.
.
.
pool apache commons pool 14eb6188 .
.
.
.
.
.
lang apache commons lang 4777c3a5 .
.
.
.
.
.
closurec google closure compiler 831be0a9 .
.
.
.
.
.
jxpath apache commons jxpath f1dde173 .
.
.
.
.
.
config apache commons configuration 8dddebf1 .
.
.
.
.
.
jgit eclipse jgit 070bf8d1 .
.
.
.
.
.
retrofit square retrofit d26484c7 .
.
.
.
.
.
guava google guava 76e7d7a8 .
.
.
.
.
.
okhttp square okhttp 0cd6b186 .
.
.
.
.
.
orientdb orientechnologies orientdb 27e798b4 .
.
.
.
.
.
empiredb apache empire db 83c8fb2f .
.
.
.
.
.
dpatterns iluwatar java design patterns 4f56f7b0 .
.
.
.
.
.
cxf apache cxf f3185100 .
.
.
.
.
.
average n a n a .
.
.
.
.
.
.
.
n a n a rq2 what portion of the dependency retrieval time can be saved by lazy retrieval?
rq3 what portion of the dependency retrieval time can be saved by using transfer script?
rq4 what is the space reduction that can be achieved by lazy retrieval and elastic dependencies?
we use two machines for our experiments a core .8ghz i7 4500u cpu with 8gb of ram running ubuntu linux .04lts which we will refer to as boxc1 and a core .7ghz i7 cpu with 4gb of ram running ubuntu linux .04lts which we will refer to as boxc2 .
.
projects under study table shows the list of the projects used in our study all open source widely used written in java and built with maven.
we selected these projects based on their popularity on github build system and build outcome.
note that our experiments require projects that build successfully in o rder to obtain all their dependencies.
due to some test failures which were mostly caused by flaky tests we exclude test execution for guava okhttp orientdb and cxf.
for each project we show a short identifier2 the project url the git commit sha used in the experiment and the number of lines of code obtained using the cloctool .
note that the different versions of the same library are treated as unique dependencies by maven and are counted accordingly in the table.
additionally we include statistics about the project s unique dependencies the number of libraries on which the project depends including transitive libraries the number of files in these libraries and the total mean and maximum size of each library.
the set of dependencies also include all libraries that are used by maven process during the build e.g.
plugins and their dependencies .
th e final two columns examine the java bytecode files within the libraries their mean and maximum size.
analysis of the libraries shows that the mean size of the libraries and 2projects are sorted based on the number of test dependencies which is not included in the table.the sizes of classfiles within the libraries is independent o f the project size.
to confirm that sizes of libraries used by the selected projects are not unusual we mined the maven central repository which includes libraries onl y the latest versions of libraries totaling 110gb.
althoug h the selected projects use libraries whose size is somewhat higher than the median of libraries in the maven central repository the selected projects include no outliers.
.
trimming step table average size of trimmed jars.
project size codec .
io .
math .
net .
pool .
lang .
closurec .
jxpath .
config .
jgit .
retrofit .
guava .
okhttp .
orientdb .
empiredb .
dpatterns .
cxf .
average .60table shows the average size of trimmed libraries by applyingthetrimmingalgorithm section .
.
to each project.
we first compute the size of each original library size l and its corresponding trimmed library size lt .
next we compute theportionof ltthatisin l i.e.
size size lt size l .
we then average size values across all libraries for each project and show these values in the table.
the final row computes the average across projects.
we can observe that the size of trimmed libraries differs by only few percentage points among the projects.
interestingly we can see that the reduction in size is the smallest fordpatterns which depends on classfiles with smallest size table next to last column .
in larger classfiles bytecod e instructions take more space than the constant pool so the larger the classfile the more reduction may be obtained by trimming.
we observed by manually inspecting trimmed libraries that a significant portion of the compiled byteco de is dedicated to the constant pool which we do not alter.
a1 trimmed libraries are on average .
smaller than the original libraries.
649table comparison of maven and mollyjretrieval times.
i2 build time including compilation and test execution w o dependency retrieval i dependency retrieval time i percent of time spent on dependency retrieval.
projectboxc1boxc2 maven mollyjmaven mollyj i2 i i i i i2 i i i i codec .
.
.
.
.
.
.
.
.
.
io .
.
.
.
.
.
.
.
.
.
math .
.
.
.
.
.
.
.
.
.
net .
.
.
.
.
.
.
.
.
.
pool .
.
.
.
.
.
.
.
.
.
lang .
.
.
.
.
.
.
.
.
.
closurec .
.
.
.
.
.
.
.
.
.
jxpath .
.
.
.
.
.
.
.
.
.
config .
.
.
.
.
.
.
.
.
.
jgit .
.
.
.
.
.
.
.
.
.
retrofit .
.
.
.
.
.
.
.
.
.
guava .
.
.
.
.
.
.
.
.
.
okhttp .
.
.
.
.
.
.
.
.
.
orientdb .
.
.
.
.
.
.
.
.
.
empiredb .
.
.
.
.
.
.
.
.
.
dpatterns .
.
.
.
.
.
.
.
.
.
cxf .
.
.
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
n a n a n a n a .
retrieval time setup instead of using the existing maven central repository we installed empty maven and mollyrepositories on a dedicated server exclusively available to us denoted as boxs to provide for fairness and stable measurements.
we used the two machines described earlier as clients which resulted in two configurations boxc1 boxsandboxc2 boxs.
in both configurations the bandwidth between the client and the server was .
mbits sec averaged over repeated measurements using iperf .
to initialize the repositories on boxs for each project we executed mvn install once without any changes to the project s build script.
this command retrieved all librari es from the original maven repositories which we copied over to our private maven repository.
additionally we executed trim and split on each original library and added the resulting artifacts to our mollyrepository.
first we measure the time it takes to retrieve dependencies from boxs.
all retrievals from this point on are from boxs.
to do so we measure maven execution times of two separate runs i1 where we delete the local maven repository and execute mvn install and i2 where we execute mvn install offline without cleaning the local repository.i2 thus is the time spentbuildingand executingtests while i i1 i2 is thetimespentretrievingdependencies.
second wemeasurethetimeittakestoretrievedependencies using mollyj.
recall section that mollyjlazily retrieves trimmed libraries during compilation and lazily retrieves the original libraries during the execution.
in th eory runningbuildwithlazyretrievalcouldincreasethebu ild time ifmost of thelibraries are retrieved because mollyretrieves boththe trimmed and original libraries.
however w e did not observed a slowdown for any project because many libraries are usually unused.
exactly as we do for maven we runmollytwice without and with a local repository present to measure i1andi2 and then compute ias the differenceofthetwo.
notethat i2is expectedtobethesamefor both maven and molly because they both perform exactly the same build which our experiment confirmed.
results table shows the i2and ivalues for maven andmollyjwhen running on both of our client machines.
the final two rows show the average and sum.
we see that on both machines mollyjspends less time retrieving dependencies .
vs. .
on boxc1 and .
vs. .
on boxc2.
based on these values we compute the average saving of retrieval time .
.
.
.
.
a2 mollyjsaves on average .
of retrieval time compared to maven.
.
transfer script savings in the introduction we already described the ideal dependency retrieval time figure .
of retrieval time ca n be reducedon average by usingtransfer script on boxc2 the results on boxc1are almost identical which can be obtained frommollyf.
note that the same figure shows that the initial retrieval time for mollyfcan be several times that of maven due to the large number of http requests but that disadvantage would be gone by the end of the second build.
a3 transfer script can save .
of retrieval time.
.
lazy retrieval disk savings table shows the savings in terms of the size of retrieved dependencies and therefore disk space .
the results are split into two main columns mollyjandmollyf.
for mollyj we show the total number of libraries retrieved bymollyj jar and compare it with the total number of libraries retrieved by maven jar .
the numbers for maven were reported in table .
for mollyf we show the total number of retrieved files file compare it with the total number of files in libraries retrieved by maven file and compute the reduction of the total size of retrieved artifacts when compared with maven size .
both mollyjandmollyfachieve consistent savings across all the projects.
this particular metric is e s650table stats for jars and files retrieved by mollyj and mollyf respectively.
projectmollyjmollyf jar jar file file size codec .
.
.
io .
.
.
math .
.
.
net .
.
.
pool .
.
.
lang .
.
.
closurec .
.
.
jxpath .
.
.
config .
.
.
jgit .
.
.
retrofit .
.
.
guava .
.
.
okhttp .
.
.
orientdb .
.
.
empiredb .
.
.
dpatterns .
.
.
cxf .
.
.
average .
.
.
.
.
n a n a n a pecially important for distributed build systems a s it improves dependency caching we discuss this in more detail in the next section.
a4 mollyfuses only .
of files used by maven and mollyjuses .
of jars used by maven the reduction in space with mollyfis .
on average.
.
discussion and future work amortization although mollyprovides the most benefits in cis environments with clean builds without caching mollycan bring benefits even when dependencies are remotely cached .
not only is mollyorthogonal to caching butmollymay improve the performance of caches particularly in a distributed environment due to disk us age reduction.
additionally if dependencies are cached there is no need to cache them eagerly but they can be cached when classfiles are lazily retrieved.
this amortizes theretrieval time across several builds ofmultiple proje cts .
it is important to mention that local caching i.e.
storing the cache on the machine that executed the latest build of the project is non existent in ciss.
the reason may be obvious ciss use the same machines to runbuilds of hundreds of thousandsofprojects e.g.
travis ci is usedbymore than 300k projects and caching all dependencies for al l projects on all machines is simply infeasible.
transparency mollyis transparent to both library developers and library users.
specifically as only the necessary classes are retrieved mollyincentivizes library users to make decisions about libraries based on the quality of each library instead of its packaged size.
at the same time library developers need not think about the sizes of their libraries.
additionally library developers need not manu ally separate public apis and its implementation which is a non trivial task.
tracking maven central repository provides some statistics about libraries that it hosts.
mollycould provide additional valuable information to the library developers e .g.
the list of classfiles that are most frequently used.
the abil ity to track dependencies could be further used to optimizetesting and verification by tracki ng for each test property what classes are being used.
compression we combined the pack200 jar compression tool included with most jre distributions with the molly s trimming algorithm.
combining both techniques reduces most projects dependencies to of their origi nalsize.
althoughcombining mollyandpack200mayseem attractive we did not proceed with this combination due to unpacking cost when the dependencies are retrieved which would be done in the execution phase.
unlike unpacking the packing could be done in the trimming step of the preexecution phase.
this step is performed either offline for each dependency as it is built or as it is uploaded to the repository and hence is not a runtime overhead.
future work we see several different ways to extend molly as well as a few opportunities for applying molly s core lazy retrieval techniques in other domains.
as for extendingmolly to save more space mollycould track dependencies at a granularity finer than classfiles e.g.
meth ods to improve the running time mollycould speculatively prefetch classes and retrieve them in parallel e.g.
if classais heavily used in methods of class b mollycould start retrieving aas soon as bis requested .
beyond build systems os package managers could implement a similar approach to ours to retrieve parts of packages only upon request the standard latex distribution on linux systems is a good example since it contains a large number of packages that most people never use.
.
threats to v alidity external the reported results may not generalize beyond the projects used in our evaluation.
to mitigate this threat we chose active projects that differ in the application domain the number of developers the number of lines of code the number of dependencies and the number of authors.
additionally several projects used in our experiments hav e been used in recent studies on regression testing and build systems .
the results for parallel retrieval time section .
may differ based on the machine e.g.
hd instead of ssd and networkconfigurations.
tomitigate thisthreat we obtaine d results on two machine which consistently showed improvement of the transfer script for retrieving dependencies ove r maven s mechanism for retrieving dependencies.
internal implementation of mollyand our scripts may contain bugs that may impact our conclusions.
molly s code base includes a number of tests that check the correctness of all phases of the proposed technique.
we also manually inspected the outputs of mollyfor several small and large examples.
construct for parallel retrievals we used several values to initialize the thread pool such that each value is a power of two.
our goal was to show the substantial speedup that can be obtained with our approach rather than to find the optimal value of threads in the thread pool.
in our evaluation we used the default maven configuration.
as reported in section we also evaluated maven retrieval time for different sizes of the thread pool but we observed no savings we used the same set of values for the thread pool size as for the evaluation of the transfer script s. although a number of different build systems are available we compared mollyonly with maven.
maven is still one ofthemost popularbuildsystems for javausedbymany 651open source projects.
in the future we plan to further comparemollywith other build systems.
note however that every build system can benefit from lazy dependency retrieval and elastic dependencies.
.
related work this section describes prior work related to molly.
software remodularization and target decomposition software remodularization is a closely related area of research attempting to cluster existing programs or dependencies into more meaningful modules.
the bunch tool introduces using subsystem decomposition by graph partitioning of static inter project file dependencies.
bunch pr ovides different search metrics to allow for different tradeoff s between remodularization quality and performance.
the decomposer and refiner tools build upon this approach by forming the strongly connected components of an enormous file dependency graph using expected dependent test triggers as a metric to partition the graph.
decomposer splits dependencies into only two subdependencies and the chosen decomposition is tied to which dependents are available when the tool is run.
closely related work uses the strongly connected components of the file dependencygraph to statically remove unused file dependencies from the build file within a project .
podoja seeks to minimize the download cost of code using dynamic information to statically repackage the downloadable jars.
podoja monitors theclasses usedinseveral executionscenarios andoptimi zes the average download size across scenarios using a geneticalgorithm searchfor apartitioningoftheclasses withinaj ar.
in comparison mollyperforms lazy dependency retrieval and elastic dependencies which automatically reduce the dependencies between the projects project depends only on the files from libraries that are used in one phase of the build execution.
our approach does not require any changes to libraries and thus could help decoupling projects and re ducing regression testing cost without requiring substan tial effort from developers.
dependency compression java packages code into jar files which use the zip format for easy distribution.
in addition to standard compression algorithm such as gzip or bz2 specialized tools exist to shrink the size of jars.
pack200 performs a lossy compression on a jar file by joining the classes s constant pools removing debug information and applying the gzip algorithm.
as discussed earlier we experimented with combining pack200 and molly finding that while pack200 achieves on average a reduction to combining both approaches reduces to .
another tool proguard strips unused code from jars and obfuscates the rest achieving between and reduction in jar size.
mollyoperates orthogonally to these compression tools and combining the approaches achieves greater trimmed library compression at the cost of uncompressing overhead which can be high for runtime deployment.
build systems there are at least as many build systems as programming languages .
furthermore studies show build system maintenance accounts for significant overhead of project development .
over time build systems have evolved to be integrated with a package manager that can resolve retrieve and install library dependencies automatically similar to tradition al package management software .
although resolution of dependencies with fixed versions is used by maven thereis interest in taking advantage of a complex version resolution model .
the spack build system leverages a constraint solver to determine the appropriate dependency version for large hpc software projects.
mollyenhances these efforts by allowing the project to determine if changes in the dependencyversion are relevant.
otherwork has sped up maven builds by delaying execution of the tests until all modules are built .
our work is orthogonal as we look how to optimize retrieval of dependencies regardless of the target being executed.
bazel can create a library that includes only class apis however the obtained classfiles cannot be loaded by the java runtime environment as they do not pass the java verification.
this could be a limitation ifmollyis implemented via the java agent mechanism to avoid modifying the java runtime environment.
dynamic patching mollybuilds on work on dynamic patching to insert executable code at runtime .
java is designed to provide extensible dynamic loading .
research in dynamic patching has shown that executable binarycode maybepatchedatruntimewithlowoverhead .
in a corba system dls implements a system and repository for loading code dynamically from the web at runtime .
dls supports loading the appropriate implementation for the system with fallback implementations.
other related work java web start is a tool for deploying code from the web that is included in oracle s jre.
the newest versions of webstartallow for lazy downloading of code at runtime but only at the packaged jar level these jars are downloaded when the application is started.
molly goes a step further by allowing lazy retrieval of individual files within the dependency and integrating automatically into the project s build system.
static analysis of a partia l program requires inference of missing types to enable build of the partial program.
unlike work on analysis of a partial program mollylazily retrieves the full implementation of types used during the build.
.
conclusions we presented molly a new build system which tackles the dependency bloat problem.
mollyretrieves dependencies partially and lazily i.e.
only the necessary files ex actly before they are needed while remaining fully automatic and completely transparent to the users .
this is the key advancement over the existing build systems which enablesmollyto reduce the retrieval time by .
reduce disk space requirements by .
and reduce retrieval time in typical cases by up to .
.
molly excels in scenarios typical for builds on continuous integr ation services the fast builds due to transfer script incr ease the overall throughput and the small dependency footprint due to lazy dependency retrieval and elastic dependencies enables more efficient caching.
we believe the cumulativeeffect ofthe savings achievedby mollycan make a significant difference for any continuous integration service especia lly in the long run.
.