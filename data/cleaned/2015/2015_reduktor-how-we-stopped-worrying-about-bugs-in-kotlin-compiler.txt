reduktor how we stopped worrying about bugs in kotlin compiler daniil stepanov marat akhin mikhail belyaev saint petersburg polytechnic university jetbrains research saint petersburg russia stepanov akhin belyaev kspt.icc.spbstu.ru abstract bug localization is well known to be a difficult problem in software engineering and specifically in compiler development where it is beneficial to reduce the input program to a minimal reproducing example this technique is more commonly known as delta debugging.
what additionally contributes to the problem is that every new programming language has its own unique quirks and foibles making it near impossible to reuse existing tools and approaches with full efficiency.
in this experience paper we tackle the delta debugging problem w.r .t.
kotlin a relatively new programming language from jetbrains.
our approach is based on a novel combination of program slicing hierarchical delta debugging and kotlin specific transformations which are synergistic to each other .
we implemented it in a prototype called reduktor and did extensive evaluation on both synthetic and real kotlin programs we also compared its performance with classic delta debugging techniques.
the evaluation results support the practical usability of our approach to kotlin delta debugging and also shows the importance of using both language agnostic and language specific techniques to achieve best reduction efficiency and performance.
index t erms program fuzzing delta debugging program slicing input reduction compiler testing i. i ntroduction in the recent years software has been becoming more and more complex with the subsequent rise in difficulty of debugging.
despite all the latest advances in the field of software quality assurance such as testing static analysis and verification finding the root cause of a bug still takes a lot of time and effort from a developer.
one of the main reasons for that is the inherent difficulty of bug localization figuring out which part of the program or program inputs causes the bug to manifest itself.
in compilers for example reducing the input file to a minimal reproducing example is a very important step in bug investigation which is often done manually.
automatic reduction of input files which cause a compiler error greatly simplifies the debugging process as it removes irrelevant details allowing the developer to better understand and focus on what triggers the bug.
several techniques such as delta debugging program slicing and their various improvements attempt to deal with this problem.
these methods are language agnostic which is their clear cut advantage however in practice they often are hard to employ efficiently for real world cases with complex language specific interdependencies and features.
using stand alone language oriented transformations or incorporating them into other reduction techniques has been shown to perform best.
this work aims at creating an automatic input reduction tool for the kotlin1compiler.
our approach is based on a novel combination of program slicing hierarchical delta debugging and kotlin specific transformations which help each other in finding and pruning irrelevant parts of input kotlin files.
as real world kotlin projects often consist of multiple files we also support simultaneous reduction of several input files.
we have implemented our approach in a prototype tool called reduktor and tested it extensively on several types of input.
for the first part of the evaluation we applied reduktor to a number of input files generated by kotlin compiler fuzzer .
for the second part of the evaluation a number of realworld projects were injected with various bugs which trigger kotlin compiler errors and processed with reduktor.
we also compared reduktor with classic input reduction techniques such as slicing and hierarchical delta debugging hdd .
our results show reduktor to outperform other approaches on the size and complexity of the resulting inputs and also support the need for hybrid reduction approaches.
the rest of the paper is organized as follows.
we introduce the basics of various input reduction techniques and approaches in section ii.
in section iii we explain our approach in more detail how it relates to kotlin features and what challenges we had to tackle.
we talk about the implementation in section iv evaluation setup and results are discussed in section v. we overview related works in section vi make conclusion and identify possible future work in section vii.
ii.
i nput reduction as we established earlier input data triggering a program error often contains a lot of irrelevant information for example listing shows an example kotlin program which crashes the compiler.
despite the program being more than lines the actual error is triggered by the single expression when .
of course in this case the reduction could be done manually however such an approach does not scale well for bigger and more intricate inputs.
that is why a lot of effort has been put into automating the process of input reduction.
let us briefly review the different techniques applicable to compiler input reduction i.e.
reduction of program source code.
34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fun box string return when if ok ok ... more lines fig.
compiler crashing when example slicing was historically among the first techniques to attempt simplification of a given program w.r.t.
number of criteria which describe interesting program properties it was coined by weiser in .
a slicing criterion is often given as a pair program statement set of variables and is used to create a program slice a reduced program containing only elements related to the criterion e.g.
elements which influence the criterion variables at the given statement.
by definition for slicing to be applicable to an input reduction problem we must have a sound slicing criterion a setup we do not always have.
delta debugging is an approach free from such limitation proposed by zeller and hildebrandt in .
it views an input sample tof a program pas a combination of individual components which can be minimized to tmin such that tmin causes the same failure as t if you remove any component of tmin the error does not reproduce on p the minimization is done via a variation of binary search let program pand input tbe given such that p t crashes the program.
we find tmin dd t using the following procedure the initial input sample tis divided into nparts t 2 ... n which are examined in order to understand if they could be removed from the input.
if needed we increase nand repeat the procedure.
this delta debugging algorithm from is shown in figure .
the principal input agnosticism of delta debugging is its main pro and con on one hand it can be applied to any kind of input data on the other hand it does not take into account the inherent structure of the input and usually performs poorly on complex data.
in mishergi and su introduced hierarchical delta debugging an extension of classic delta debugging which focuses on applying delta debugging to hierarchical inputs e.g.
abstract syntax trees xml documents html dd t dd t dd t n dd i ifp i fails dd i m a x n ifp i fails dd t min t 2n ifn t t otherwise i t i t 2 ... n i negationslash j i j fig.
delta debugging algorithmpages representable as trees.
their algorithm works as shown in figure it independently analyzes every level of the input tree in a top down fashion.
first it collects all tree nodes at the current level second these nodes are reduced using the classic delta debugging creating a minimal node configuration.
this configuration is then applied to the tree following which we proceed to the next tree level.
while hdd does work better than classic delta debugging on structured data and can achieve good reduction on any input for many practical examples its performance is subpar as it has no knowledge about the finer structure of the input.
for programming languages for example it does not take into account control or data dependencies and has to deduce them implicitly via its level by level tree reduction.
to speed up this process and improve on its quality many practical delta debugging tools include custom language specific transformations .
for example c reduce attempts to replace arbitrary function arguments with compatible constants and performs inlining of small functions.
for kotlin we decided to combine these approaches in such a way that individual techniques support each other.
let us describe our approach in more detail.
iii.
r eduction for kotlin compiler our approach to input reduction for kotlin compiler see figure similarly to many other approaches consists of a number of independent steps each taking a set of kotlin files as an input and reducing them via some kind of transformation.
even before we discuss these steps in more detail we need to explore two things transformation soundness and their order.
a. transformation soundness a transformation is sound w.r.t.
input reduction problem if it preserves the original error if a program pfails on input t it should fail with the same error on the transformed input t prime.
however for compiler errors it is often very hard to define what same means.
for example an error message may contain parts of generated bytecode which may be different for files before and after transformation but relate to the same cause.
there are ways to solve this problem.
the first one assumes error messages have a specific format which can be automatically parsed and compared.
a number of errors from kotlin compiler satisfy this condition an example of such input hierarchical input data tree result tree is reduced level nodes getnodes tree level whilenodes negationslash do minconfig dd nodes removenodes tree level minconfig level level nodes getnodes tree level fig.
hierarchical delta debugging authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
overview of our approach error is shown in listing .
as one can see from the example the type and location of error are easily identifiable.
for such errors we have developed a number of parsers which extract relevant information used for error comparison.
if error messages do not have a structure we need to compare them directly i.e.
find their differences.
a classic approach is to view this problem as a string difference one solvable via longest common subsequence lcs algorithm such as myers .
to avoid reinventing the wheel we use diff match patch a highly optimized library from google for text synchronization.
the diff component compares two strings and outputs a list of their differences which we can use to estimate the similarity of original strings as summationtext diff summationtext total .
the closer this coefficient is to zero the more similar the strings are.
to be considered the same error messages should have similarity lower than a set threshold which is configurable.
our approach first attempts to compare two error messages using one of the template parsers if they fail it falls back to a direct difference comparison.
this allows our approach to more aggressively reduce input for a large class of errors which have comprehensive error messages.
b. transformation order all input reduction steps are independent of each other however even for a fixed set of transformations the final result may be affected by the order in which these transformations are applied.
more so the overall performance also depends on the transformation order as the individual performance of many transformations is greatly related to the input size.
for this work we decided to apply transformations in the order of their reductiveness based on the preliminary evaluation from coarse grained steps which can remove whole input files to more fine grained ones which may work on a subexpression level.
it would be interesting to see if it is possible to reliably learn a quazi optimal transformation order for a specific class of inputs via machine learning or genetic engineering.
we hope to explore this opportunity in our future work.
the resulting pipeline is as follows.
project level simplifications slicingerror kotlin org.jetbrains.
kotlin.codegen.compilationexception backend jvm internal error wrong code generated org.jetbrains.kotlin.codegen.
compilationexception back end jvm internal error couldn t transform method node test v l0 linenumber l0 l1 pop l2 ... cause after mandatory stack transformations incorrect bytecode element is unknown the root cause was thrown at methodverifier.kt file being compiled at position in main .kt ... fig.
an example of a kotlin compiler error message with well defined format text based transformations syntax tree based transformations hierarchical delta debugging every transformation is applied in order until convergence i.e.
until its input stops decreasing in size.
we also check if the transformation preserves the error by comparing before and after error messages.
if the error stops reproducing we rollback the input and continue with the subsequent transformations.
c. reduction criterion as mentioned before our approach takes as an input a set of kotlin files with its respective error which allows to support reduction of not only individual files but also whole projects.
however some transformations need a starting point e.g.
slicing needs a criterion from which to do its work.
when the error message contains information about the error location we extract it as described in iii a and use from here on.
if the information is missing we ask the developer to provide a file presumably containing the error.
from here on out we will call this starting point a reduction criterion rc .
note despite our fallback strategy appearing as unsound relying on manual developer input may seem quite unsound the approach established in section iii a helps us to ensure soundness.
if the developer specifies an incorrect file for the rc they will get a suboptimal reduction but the original error will still be preserved.
in case you are interested in how often the fallback rc have been actually used we kindly forward you to the evaluation specifically section v a. d. project level simplifications the first transformation we use performs different projectlevel simplifications.
their main purpose is to prune away parts authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
of the project which are irrelevant to the error.
modern programs have complex internal dependencies greatly complicating reducing individual files.
to solve this problem we need to remove these dependencies.
in kotlin dependencies of a file are usually defined via import lists statements specifying which other parts of the project are needed in the current file.
another way of specifying dependencies is fully qualified names fqn when a program component is referenced by its complete name.
these elements form the dependency tree which may be used to guide the simplification process.
figure 6a shows an example with import dependencies.
in order to reduce class a and leave only the relevant function with the bug we must reduce classes b c and d in the correct order.
to do this we use the dependency tree as in figure 6b.
to build this tree we recursively collect the imports and fqns starting from the reduction criterion.
all files not in the dependency tree are removed from the project.
after that we traverse the dependency tree in the bottom up order applying to each file a subset of transformations aimed specifically at simplifying the project dependencies.
as all files except one do not contain the rc all transformations must not depend on a given starting point.
the transformations used are listed below we describe them in more detail in their respective sections.
all text based transformations syntax tree based transformations related to pruning unused program parts removing of unused components simplifying interdependent components e. slicing as mentioned in section ii slicing is one of the most basic input reduction techniques.
it creates a program slice free of unneeded parts w.r.t.
slicing criterion in our case we use the rc as the slicing criterion.
there are several different types of slicing varying in their performance and complexity.
for our purposes we decided to implement a static backward slicing over the syntax trees which is applied on the following levels in their respective order.
intraprocedural level function level class level the algorithm for intraprocedural slicing is presented in figure .
the algorithm analyzes the function in the reverse order.
all lines after the slicing criterion are removed using the deletelineifsound function which checks for transformation soundness as described in sections iii a and iii b .
after that we collect the interesting variables aka dependencies from the slicing criterion and continue processing the function if a line depends on these variables we keep it and extend the dependencies otherwise it can be removed.
the dependson and getdeps functions can handle different kotlin language statements and expressions such as if statements loops etc.
.
in case the rc does not contain an exact line we perform redundant slicing w.r.t.
every line as the possible slicing criterion and pick the best shortest resulting file.
a example of import dependencies file a.kt class a fun funwithbug ... fun f ... file b.kt class b val a a fun f a.f file c.kt class c val a a file d.kt class d val b b fun f b.f b built dependency tree fig.
example of project dependencies problem slicing at the function level works similarly to the dependency tree pruning.
starting from the slicing criterion we collect the function call graph tree marking all functions called as used.
afterwards all unused functions are removed from the file if their deletion is sound w.r.t.
rc see figure .
class level slicing is performed in a parallel fashion.
an example of how our slicing algorithm works is shown in figure in the example we attempt slicing w.r.t.
line .
f .
text based transformations direct transformations over the program text representation despite their simplicity are often the most efficient way of reducing the program.
examples of such transformations include removing some or all text in a string literal changing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
input slicing criterion targetline input functionfun output reduced function fun curline getlastline fun whilecurline negationslash targetline do deletelineifsound fun curline curline getprevline fun curline deps getdeps curline whilecurline getfirstline fun do ifdependson curline deps then deps deps getdeps curline else deletelineifsound fun curline curline getprevline fun curline returnfun fig.
intraprocedural slicing algorithm input slicing criterion targetfun input filefile output reduced file file calltree buildcalltree file callees collectcalleesfor targetfun calltree funstoremove getallfuns file callees topologicalsort funstoremove forfun funstoremove do removefunifsound file fun returnfile function collect callees for fun calltree directcallees getdirectcallees fun calltree res directcallees fordirect directcallees do res res collectcalleesfor direct calltree returnres end function fig.
function level slicing algorithm code based on a pattern etc.
we selected about of various text transformations to be used based on the following.
our kotlin programming experience transformations used in other reduction tools transformations used in the kotlin intellij idea plugin for code simplification2 as most of them are pretty straightforward to invent and implement we skip on describing them for brevity.
below is an incomplete list of text based transformations included in our approach.
removal of text inside a balanced pair of parentheses pattern based removal or substitution of text original example class square private val a double fun getperimeter double a fun getsquare double a a class triangle private val a double private val b double private val c double fun getperimeter double a b c fun getsquare double var square .
if a a b b c c square a b else val p getperimeter square math.sqrt p p a p b p c return square b example after slicing class triangle private val a double private val b double private val c double fun getsquare double var square .
if a a b b c c square a b else return square fig.
slicing algorithm before and after example replacement of string literals with empty strings replacement of integer constants with an example of these transformations is shown in figure .
g. syntax tree based transformations another group of ad hoc transformations which perform well for source code reduction are syntax tree based transformations.
there are two main approaches to them language agnostic and language specific.
language agnostic transformations assume only the basic tree structure and are defined in terms of generic node transformations this allows them to successfully reduce any input representable as a tree.
on the other hand language specific transformations usually depend on particular tree properties for a given programming language this limits their generality but improves the reduction efficiency.
similarly to text based transformations section iii f we decided to use a number of kotlin specific transformations derived from our kotlin programming experience and from authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a original example fun f var a val b a val c .
var d double while a.todouble !
c d a b c a println a a b example after text based transformations fun f var a val b a val c .
var d double if a.todouble !
c d a c a println fig.
text based transformations before and after example which transformations are used in other tools.
they can be divided into the following groups.
expression simplification if statements loops elvis operator etc.
removal of unneeded components function and constructor parameters imports etc.
simplification of interdependencies removal of inherited properties and functions replacement of function bodies with todo etc.
miscellaneous comment deletion replacement of function return value etc.
such transformations are implemented as syntax tree based ones instead of text based because they either cannot be expressed or would create too many syntactically incorrect programs if done over text.
the latter may greatly influence the overall reduction performance as every incorrect transformation causes a rollback to the previous reduction state.
our approach currently includes kotlin specific syntax tree based transformations as describing each and every of these transformation would have taken up most of the paper we decided to describe in detail only the most interesting ones.
simplifying elvis operator kotlin has an elvis operator a succinct way of checking value for null and providing a sensible default option val a b?
c means if bis not null assign the non null value btoa else assign the default value ctoa .
this operator can be reduced as val a c i.e.
we can drop its left hand side.
as the type of cis guaranteed to be a subtype of b?
c this substitution is safe.
deleting function parameters function parameters often become unused as a result of other reduction steps.
to delete them efficiently you have to perform a bona fide refactoring modify the function itself find all calls to the function and delete the corresponding argument.
at the same time you have to consider function overloading and inheritance making this transformation quite sophisticated to implement.
todo simplification kotlin has a special todo function which throws a notimplementederror exception when called and has a special nothing return type.
nothing is a uninhabited subtype of all kotlin types i.e.
can be used in place of any other kotlin expression.
the corresponding transformation attempts to replace arbitrary expressions such as function bodies or variable initializers with the call to todo .
inlining in case of small functions it makes sense to inline their bodies in place of their calls to improve readability and give other transformations additional opportunities for reduction.
the inlining threshold is configurable by the user by default we attempt inlining for functions less than lines.
simplifying if statements this transformation attempts to replace the if statement with its true or false branch.
if the condition contains a type check kotlin performs a smart cast3 a variation of flow based typing aimed at reducing the code boilerplate by automatically changing the compile time type of a variable after type checks and type check like constructions.
for our transformation we create a corresponding type cast v as t for every type check from the condition vi st taking into account their negation for the false branch.
h. hierarchical delta debugging the last step in input reduction is hierarchical delta debugging .
hdd is used as a finishing tool to remove redundant constructions not considered by the previous steps.
after other transformations have done their job the input file is already significantly reduced compared to the starting point this means hdd can be performed much faster if we were to compare it to an hdd only approach.
iv .
i mplement a tion we implemented a prototype tool for kotlin file reduction based on our approach called reduktor.
in this section we would like to discuss some of the more interesting reduktor implementation details.
a. working with kotlin many of our reduction steps require quite an advanced understanding of the kotlin source code e.g.
building and manipulating its abstract syntax trees ast .
we also need to be able to efficiently recompile the source code after each change so that we can check if the target error is preserved as described in section iii a. to achieve these goals we made a well considered decision to build reduktor on top of the kotlin compiler using it as a library.
this allows us to use its robust source code parser authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
which produces program structure interface psi trees4 jetbrains traditional concrete syntax tree cst implementation supporting both text and tree based transformations.
by using the compiler as a library we significantly reduced the time needed to check the error reproducibility as kotlin compiler has quite a long startup time if used externally.
unfortunately this decision has a serious drawback by being dependent on the very thing we are trying to debug we may be reducing the space of supported kotlin inputs if the parser itself fails reduktor also cannot work.
that said in our experience we have never encountered such a situation.
the kotlin compiler is used in a two stage process.
first we use only the parser to create the psi which is much quicker than invoking the full compilation if the psi contains error nodes the input file is syntactically incorrect and should be rejected.
second we perform the full compilation and analyze the error message.
this scheme also helps to save time checking for transformation soundness.
b. parallel processing the first step of the transformations project level simplifications is performed in parallel on every project file to better utilize the modern hardware.
as described in section iii d w e process the project dependency tree in the bottom up order and do so in parallel for independent files i.e.
viewing the dependency tree as a parallel task graph.
additionally we also considered running the separate reduction steps in parallel but decided against it in the prototype due to the complexity of how to merge the possibly interdependent results together.
c. caching another optimization employed in reduktor is the caching of intermediate results.
during transformations we may encounter source code configurations which have been already explored this is most often encountered during hdd.
to avoid rechecking we cache previously checked ast configurations as their hashes together with the result.
if the current hash has already been seen we reuse the cached result to guide the subsequent transformations.
in our experience this significantly improves the hdd performance.
v. e v alua tion for the evaluation we run reduktor for kotlin compiler version .
.
on two types of input.
for the first part we used the results of kotlin compiler fuzzer single files which cause compiler crashes together with the code samples from various compiler bugs collected from the kotlin compiler bug tracker5.
for the second part a number of real world projects were injected with invalid code to test the relevance and performance of project level simplifications.
we did attempt to find project level inputs with compiler crashing bugs to no avail which is why we opted to create such inputs artificially.
the brief description of selected projects is shown in table i. psi.html collected the following statistics reduction efficiency i.e.
the decrease in file size and performance i.e.
the wall clock time for reduction .
for every test project we ran input reduction in the following configurations.
slicing only s kotlin specific transformations kst only t hdd only d pardis only p reduktor without transformations s d reduktor without slicing t d reduktor without hdd s t reduktor s t d reduktor with pardis instead of hdd s t p pardis is the latest addition to the family of languageagnostic input reduction algorithms considered to be state ofthe art and outperform c reduce by a factor of in reduction performance.
for the purposes of evaluation we implemented pardis as an optional step in reduktor to see how it performs within a complex input reduction tool.
for the test bench we used a machine with intel core i74790 .
ghz processor gb of memory and intel ssd storage.
the evaluation results are shown in tables ii and iii.
an example of how different modes of reduktor perform on an example from kotlin fuzzer tests is shown in figure .
a. reduction soundness in section iii a we discussed two ways of ensuring reduction soundness one based on parsing error messages in a specific format and another based on generic string comparison.
in our evaluation we did not encounter a single crash for which our error parsers failed to extract the error type and location this fact speaks highly of kotlin compiler team and their error handling discipline.
this also means our evaluation compares and talks about sound reduction results.
in a scenario when reduktor has to fallback to generic string comparison one has a possible problem with reduction soundness only in a large scale evaluation when it is not feasible to manually manage the similarity threshold.
if we are to talk about using reduktor in practice there should be a human developer in the reduction feedback loop who can check and tweak the similarity threshold as needed.
b. lessons learned there are several interesting insights we can extract from the evaluation results.
first slicing impact on the input reduction is negligible if we remove slicing from the pipeline the reduction efficiency is almost unchanged and the performance is decreased by percent at most.
in our opinion this means slicing is better used for subsequent bug localization a step performed after the input reduction has been done.
second custom language specific transformations outperform even the state of the art language agnostic technique pardis in both performance and efficiency.
they are better in reduction efficiency by up to .64x for out of project fuzztests bugstests mapdb koin and faster by up to .0x for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
name lines 103tokens 103description fuzztests .
kotlin fuzzer tests files bugstests .
code samples from the bug tracker files kotlinpoet .
library for kotlin source code generation kfg .
cfg builder for jvm bytecode mapdb .
embeddable database koin .
library for dependency injection t able i description of the test projects project o r s t d p s d t d s t s t d s t p fuzztests bugstests kotlinpoet kfg mapdb koin column o shows the number of original tokens column r number of tokens after reduction t able ii reduction efficiency projectt s s t d p s d t d s t s t d s t p fuzztests bugstests kotlinpoet kfg mapdb koin column t shows the reduction wall clock time in seconds t able iii reduction performance out of projects bugstests kotlinpoet kfg mapdb .
this proves their importance for reduction in real world applications.
third despite their standalone efficiency the results of language specific transformations can be significantly improved by applying language agnostic techniques such as hdd or pardis to their results.
adding either hdd or pardis together with slicing improves the results by .1x to .9x times.
of course adding additional reduction steps causes a subsequent reduction in performance by up to .5x times.
besides that from a practical standpoint aggressive caching of intermediate results together with using compiler in a two stage process see section iv a for further details greatly improves performance.
for example disabling these features slows down the reduction process for bugstests by .0x times.
we believe the second and third insights to strongly support the need for hybrid input reduction approaches to utilize the synergy between language agnostic and language specific techniques.
they also show we need a better strategy for comparing different input reduction tools for example pardis is said to be times faster than c reduce however it is a consequence of c reduce using hdd as its final step.
we also performed a manual overview of the reduction results and identified some inefficiencies.
in several cases reduktor failed to remove all information irrelevant to the error from the target file in a multi file project.
this happened because the project level simplifications failed to remove all unneeded dependencies inside the project.
in our future work we plan to explore how one may better perform project levelreduction by either extending the number of transformations used or selecting better project level transformations.
as mentioned in section iii b the reduction process consists of many stages the order of which can affect both the reduction time and its result.
we conducted additional experiments not presented here for the sake of brevity which have shown the selected order to outperform alternative orders.
for example if you implement the same transformations in reverse order the reduction slows down by as much as on fuzztests and by on average.
c. real world adoption unfortunately reduktor is only a research prototype and we do not have any solid practical adoption yet besides the evaluation we only used it internally in our research group for several quirky bugs triggered by our code in the kotlin compiler.
one of the main reasons for that is as discussed in section iv a to speed up reduction we use the compiler as a library via a non stable internal api.
as this api changes between versions one cannot currently use reduktor as an offthe shelf solution for their particular compiler version and or development environment.
we recently contacted the kotlin compiler team and proposed them to incorporate reduktor in their workflow.
their feedback was positive with their cooperation we should be able to migrate reduktor to a new stable api to better support different compiler versions.
we also further confirmed the need for project level simplification in real use cases as currently authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a original test case class a fun string .test ok string fun box string val clazz a ?
class .java val method clazz.getdeclaredmethod test string class .java string class .java val parameters method.getparameters if !method .isimplicit parameters .issynthetic return wrong modifier return parameters .name b test case after slicing class a fun box string val clazz a ?
class .java val method clazz.getdeclaredmethod test string class .java string class .java val parameters method.getparameters return parameters .name c test case after hdd fun box string val clazz a ?
class .java val method clazz.getdeclaredmethod val parameters method.getparameters return parameters.name d test case after full reduktor mode fun box val clazz a ?
class .java fig.
example of different reduction modes developers spend a lot of their time manually reducing complex project setups to create minimal reproducing examples.
we hope to explore how we can improve on reduction for multi file projects in our future work.
vi.
r ela ted work as mentioned before input reduction is a popular research area with a lot of practically applicable tools.
at the moment the most developed tool for delta debugging is c reduce initially created for reduction of c c compiler tests generated by csmith .
these tests being randomly generated usually contain a lot of irrelevant information.
over the years creduce has evolved into a sophisticated hybrid input reduction tool utilizing the following transformations.
delta debugging using topformflat v arious text and tree based transformations over the source code for example function inlining removal of unused functions and variables etc.
source code pretty printing c reduce has a proven track record of being able to handle even complex c c programs .
reduktor may be considered an adaptation of the c reduce approach to the kotlin programming language however it also supports simultaneous reduction of several kotlin files i.e.
project level input reduction and uses slicing to improve performance.
other tools for input reduction of java or c programming languages include jslice indus javabst and codesurfer .
they implement a variety of techniques in a way more or less similar to c reduce.
an example of an approach similar to ours combining delta debugging and static slicing would be the one by leitner et al.
targeted at minimizing randomly generated tests for eiffel.
some approaches use dynamic slicing instead of static which helps with the related activity of program understanding e.g.
gupta et al.
.
this approach takes a forward dynamic slice from the delta debugged input and intersects it with a backward dynamic slice of the erroneous output creating what is called a failure inducing chop.
it is used to better guide the bug finding activities we did not have the opportunity to focus on this problem in our work and hope to explore it in the future.
a number of tools attempt to perform language agnostic input reduction.
the classic example of this is picireny an implementation of hdd.
it performs hdd over the parse trees produced from an input antlr grammar if your input can be described with antlr picireny can try to reduce it.
the advantages and disadvantages of this tool mirror the ones of hdd it is universal but often takes very long to reduce complex inputs.
other tools based on hdd include .
herfert in presents a language independent algorithm named generalized tree reduction gtr .
it extends hdd in an attempt to improve its performance combining hdd with a greedy backtracking based search over a set of generic tree transformations.
these transformations improve the hdd performance and efficiency by limiting the number of tree configurations considered on every level and also allowing to reduce the tree on several levels simultaneously.
sun et al.
tackle the same problem hdd performance from another angle in their perses framework.
perses is also language agnostic and accepts input grammar in backus naur form which is then transformed into an internal grammar representation.
tree nodes are classified into four classes regular kleene plus kleene star and optional regular node is replaced with its minimal compatible descendant other types of nodes are reduced using a variation of delta debugging.
evaluation shows perses produces much smaller results compared to most other input reduction tools smaller except for c reduce.
at the same time it performs on average two times faster than c reduce.
gharachorlu et al.
present a new technique called pardis which improves perses by prioritizing reduction of larger subtrees first.
it is shown authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to work .3x to .8x faster than perses with less reduction soundness checks and same overall reduction quality.
vii.
c onclusion despite all the latest advances in software engineering input reduction is still a very hard problem in a lot of cases solved by tedious manual efforts.
the more complex an input structure is the more time it takes to reduce the input manually this is especially true for compilers as reducing code requires deep understanding of the said code.
in this experience paper we present an approach to automatic input reduction for the kotlin programming language.
the approach is based on a combination of kotlin specific transformations program slicing and hierarchical delta debugging which are highly synergistic.
it also accounts for multi file projects by supporting simultaneous reduction of several files.
we have implemented a prototype tool called reduktor based on our approach and performed its thorough evaluation.
the results show that to achieve high reduction quality one must still employ language specific transformations together with general approaches such as hdd language agnostic techniques despite their recent advances still fail to achieve the efficiency of custom transformations when used standalone.
as for our future work we hope to explore both theoretical and practical improvements.
the input reduction pipeline consists of multiple steps and the order of these steps may influence the performance it would be interesting to see if machine learning could be used to find a quazi optimal ordering depending on the input properties.
from the practical side we plan to better parallelize the pipeline allowing to perform transformations simultaneously and improve the integration with kotlin compiler to speed up the soundness checks.
we also hope to collaborate with the kotlin compiler team on incorporating reduktor into their workflow to further the understanding of how input reduction performs in practice.
acknowledgement we would like to express our gratitude to the kotlin compiler team for their support and feedback to all the reviewers for their questions and comments and to our shepherd for their help in improving the final version of the paper.