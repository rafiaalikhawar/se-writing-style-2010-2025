macke compositional analysis of low level vulnerabilities with symbolic execution saahil ognawala1 mart n ochoa2 alexander pretschner1 tobias limmer3 1technical university of munich germany ognawala pretschn in.tum.de 2singapore university of technology and design singapore martin ochoa sutd.edu.sg 3siemens ag germany tobias.limmer siemens.com abstract concolic conc rete symb olic execution has recently gained popularity as an e ective means to uncover non trivial vulnerabilities in software such as subtle bu er over ows.
however symbolic execution tools that are designed to optimize statement coverage often fail to cover potentially vulnerable code because of complex system interactions and scalability issues of constraint solvers.
in this paper we present a tool macke that is based on the modular interactions inferred by static code analysis which is combined with symbolic execution and directed inter procedural path exploration.
this provides an advantage in terms of statement coverage and ability to uncover more vulnerabilities.
our tool includes a novel feature in the form of interactive vulnerability report generation that helps developers prioritize bug xing based on severity scores.
a demo of our tool is available at ccs concepts security and privacy !vulnerability management software and its engineering !software testing and debugging general and reference !veri cation keywords symbolic execution compositional analysis .
introduction symbolic execution has been used for analyzing programs and to look for vulnerabilities of the kind that are typically hard to nd for blackbox methods that ignore speci c program structure.
symbolic execution performs much better in terms of coverage nding bugs in parts of the code that are seldom exposed via random testing.
this can be attributed to the fact that symbolic execution exploits the semantics of the program by assuming symbolic values for the input parameters and simulating possible execution paths.
but symbolic execution su ers from bottlenecks of underlying model checkers and constraint solvers .
since most of the real world programs are highly intricate and containmany environmental interactions the size of the constraints path conditions generated during symbolic execution may grow too large for constraint systems to solve in a reasonable amount of time.
this leads to low coverage of the program potentially leaving many vulnerabilities undetected.
in this paper we present a tool that enables testers to detect low level vulnerabilities de ned for this study as unhandled memory operations resulting in memory out ofbounds bu er over ow in a program using symbolic execution in a reasonable amount of time.
reasonable amount may be de ned in terms of time taken for program analysis or required computing resource.
however for this study we will perform our performance comparison in terms of time taken for the full analysis only.
we achieve our goal by performing a fully compositional1analysis of the program under test.
our tool named modular and compositional analysis with klee engine macke2 makes use of symbolic execution techniques at the level of c functions and then combines the results using static code information and inter procedural path feasibility.
moreover our tool allows security experts to reach informed decisions on xing vulnerabilities based on their respective severity scores and potential risk.
problem most symbolic execution tools generate test cases by starting at the entry point of the program forward symbolic execution resulting in insu cient code coverage.
this leaves many potential bugs undetected.
on the other hand symbolically executing only individual functions f yields many false positive vulnerabilities which may never materialize if the corresponding inputs are sanitized by the functions that transitively call f. compositional approaches to symbolic execution such as have either not been evaluated on multiple real world programs or are not accompanied by automated tools.
solution our solution is a three step approach firstly macke performs symbolic execution on the individual components of a program in isolation.
this has the advantage of higher code coverage and ability to uncover many lowlevel vulnerabilities in all program components.
secondly macke uses results of the rst step to reason about and therefore reduce the number of reported vulnerabilities from a compositional perspective i.e.
by nding feasible inter procedural paths for those vulnerabilities to be exploited.
thirdly macke assigns severity scores to reported vulnerabilities by considering several characteristic features and provides the result in an interactive visual format.
contribution in terms of compositional analysis of vulnerabilities the contribution of our work is three fold i evaluation on multiple real world examples which is missing in 1we will use components and functions interchangeably since macke works on c code only.
2tool available at permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the owner author s .
publication rights licensed to acm.
ase september singapore singapore acm.
... .
3int mask b int b int n f b p o t e n t i a l buf .
overflow return n 6g 7int main int argc char argv f int i n b f0 0g for i i argc i f i f argv b n mask b b n else foo expensive function 14g while f i f getchar symbolic input .
.
.
do something .
.
.
18g return 20g listing program to show e ectiveness of targetedsearch.
ii automation of all stages of instrumentation and concolic execution which is missing in and iii an open source implementation for reproduction of results which is missing in .
we also provide a compositional approach to ranking vulnerabilities on perceived severity scores which is absent from all the previously cited works.
this paper is structured as follows.
in section we describe our approach starting with klee the underlying symbolic execution engine and the architecture of macke.
we provide preliminary evaluation results in section .
section enumerates some related work to our tool.
in section we conclude our paper.
.
approach as discussed in the previous sections termination of forward search strategies in symbolic execution depends on the ability of the underlying constraint solver to return quickly and e ectively .
in our solution we prefer to reduce the size of constraints that we input to the constraint solvers.
then we use compositional methods to combine the results.
before explaining macke we describe klee the symbolic execution engine used by our tool.
.
klee a symbolic execution tool klee is the most popular symbolic execution tool and it is well documented and maintained by its developers.
this is the reason we chose it as the symbolic execution engine for macke framework.
klee is a coverage rst symbolic execution tool which means that it focuses on covering as many paths in a program as possible.
this is done by symbolically executing a program till a branching statement is encountered.
at this point the branching condition p is analyzed to determine its feasibility depending on the path condition pc obtained from all the preceding branching conditions in the path and assignments to variables in the branching conditions.
a pc is de ned as a conjunction of predicates that represent which branch true or false was taken at any branching statement.
if both branches p and p are feasible then the program is cloned with both possibilities added to the pc respectively for each clone .
a path is said to endat a node when i the next branching condition to be added is inconsistent with the pc ii an exception is with the current pc and a possibly unsafe memory handling operation or iii the path has reached a leaf node with a return statement.
at the end of the path an attempt is made by the underlying decision procedure to nd an assignment for the symbolic variables in the pc.
by default this is done by a satis ability solver such as stp or any other constraint solver .
.
macke macke is a framework written on top of the klee symbolic execution engine for compositional analysis of c programs.
the complete procedure of compositional analysis is divided into three stages each of which we describe next.
.
.
looking for low level vulnerabilities the rst step of such a compositional analysis is the isolation of low level components .
low level components may be de ned di erently for di erent programming languages or runtime frameworks.
for all experiments in our study these low level components are c functions.
to look for bu er over ows in low level components macke s static analyzer isolates them and creates a unit test le for each of them.
these isolated components are then symbolically executed by klee to obtain test cases and bu er over ow violation reports for each c function.
a bene t of symbolically executing isolated components is that this process may be parallelized e ciently.
as our intent is to focus on inter procedural interactions only in the second step section .
.
this approach makes sense in the rst step.
when functions are isolated the function calls are notstubbed with symbolic return values but are executed normally.
this in our experience results in many false positives to a degree that does not provide a good costbene t w.r.t.
higher path coverage in the isolated component.
also this obviates application of static compositional analysis step as described in section .
.
.
referring to the code in listing which we will use as a running example3 this means that we rst isolate functions main5andmask b and then execute them both with symbolic arguments argc andargv formain andbandnformask b .
symbolic arguments are the variables which determine the execution paths in symbolic execution.
as the output of this stage we get unit test cases for both functions individually.
it is highly likely that we achieve full path coverage in mask b due to only two non expensive instructions.
some covered paths lead to memory out of bounds error bu er over ow based on some assignment to the symbolic arguments.
these test cases are reported in unre ned bug reports as low level vulnerabilities or simply bugs.
in listing such a vulnerability exists on line .
function mask b might try to write outside the bounds of array b. the same vulnerability would be reported in main function if more than elements of argv are b and line is executed.
.
.
exploring paths to vulnerabilities after we have a report of bugs found by symbolic execution on the isolated functions the next step is to rule out the ones that are unfeasible i.e.
they cannot be reached due to input sanitization conditions in higher level functions.
below are the activities that macke perform for exploring paths to low level vulnerabilities firstly static analyzer 3program directly adapted from shortest distance symbolic execution sdse description in .
4include statements are not shown so lines start from .
5main is treated the same as all other functions.
macke does this by changing main s function name to main aux .
a b figure klee bug reports a describes a bug inmask b and b describes a matching bug in main.
creates a call graph and controlow graph of the program.
secondly macke analyzes the call graph in combination with the unre ned bug reports generated in the previous stage.
the bug reports that klee produces contain relevant details viz.
the problematic symbolic variable s the problematic value s those variables take function exploit the source line containing a ected instruction and the call stack up to function containing the a ected instruction.
with these artifacts the second stage of compositional analysis may be further divided into following sub steps static compositional analysis and partial pc matching.
static compositional analysis the rst step in exploring vulnerability paths aims to con rm whether some of the bugs reported at the isolated function level can be reproduced via higher compositional level.
macke does this by comparing the location of a bug reported in a function f to that reported in the parent function of f. consider the callsequence of the program in listing .
for every function such as mask b that contains bug s at the isolated level we look at bug reports of all functions that call mask b such asmain.
a bug infis said to be matching to a bug in parent offif the call stack of the parent function s bug report shows that the a ected instruction is located in the same source le and line as that reported for the bug in f. as shown in fig.
b the bug reported by klee in main is at the same program location as the bug reported in mask b as shown in fig.
a .
thus these two bugs as reported by klee in isolated components are called matching bugs.
if a matching bug is found to be reported in calling function we recursively do a similar static bottom up reasoning all the way up to the entry point of the program in this case main is the entry point of the program .
we de ne lowest level function as the one which does not call any other function or calls functions external to the tested system.
the above described initial compositional analysis step con rms reachability of some or all of the vulnerabilities reported in the isolated functions.
however due to timeouts in constraint solver this does not help us in ruling out reproducibility of the bugs for which matching bugs are not found.
this gives rise to the need for partial pc matching.
partial pc matching to understand the need for partial pcs let us reiterate the cases when a matching bug may not be found in a higher compositional level a if input to the lower level component is sanitized in a higher level component orb if the higher level component is incompletely covered time out .
in case a there is nothing to report as the malicious input is already taken care of.
in case b the set of partially covered paths in main are called partial pcs .
consider again listing .
assume that a matching bug7int main int argc char argv f int i n b f0 0g for i i argc i f i f argv b k l e e a s s e r t !
!nn memcmp argv bbbbb sizeof argv nn argc else foo expensive function 16g while f i f getchar symbolic input .
.
.
do something .
.
.
20g return 22g listing modi ed main function.
call to mask b replaced by assertion statement to line mask b has not been reported in main.
note that mask b has been su ciently covered to nd a vulnerability.
one way of reducing the number of paths for symbolic execution to explore in main is to replace the call to mask b with the summary of those symbolic execution runs of mask b performed previously which resulted in bugs.
programmatically summarizing is done by the pc matcher component of macke as follows i prepare a klee assertion statement that compares actual parameter with solution assignments to formal parameters found by klee ii replace function call by the klee assertion statement.
for the code in listing macke modi es the code as shown in listing .
the values bbbbb and are assignments found for b c that lead to the bu er over ow.
furthermore the time taken to reach the target compositional interactions can be decreased by executing those branches rst that take the execution closest to the target statements.
as a part of the full macke framework we implemented an additional search strategy in klee known astargeted search .
for our targeted search mechanism we draw inspiration from the best rst strategy described in and variants of sdse described in .
the pc matching phase of our approach is essentially another run of klee on isolated components but with targeted search strategy enabled instead of the default cover new paths rst strategy.
targeted search is implemented by rst picking the shortest path to the function containing the assertion statement from program call graph and then employing a source code based distance metric within the container function.
this way we avoid spending time in expanding those execution paths that do not reach the assertion statements.
for the code in listing symbolic execution will cover line only when the pc is i argc argv 0b0 .
considering that this is true for only a few possible inputs to the program targeted search performs better than klee s path search by directing exploration explicitly to line .
.
.
ranking the vulnerabilities a thorough compositional analysis for nding low level vulnerabilities is more useful when there is a process to prioritize those vulnerabilities.
after consulting with our industry partners we decided to implement in our framework an interactive procedure to assign severity scores to vulnerable functions that are found in the analysis stages of macke.
this severity score is based on the functions described below with their intuition and a weight impact factor between and associated with each function 782table results of compositional analysis with macke program loc coverage vuln.
instr.
level up main exploit forward compositional splint forward compositional compositional forward compositional bzip2 grep flex coreutils i the function lenchain f returns a natural number representing the depth of function hierarchy through which a vulnerability in fmight be exploited.
it has the impact factorl.
if a function can be exploited through a long hierarchy it s more likely somebody forgot to sanitize the exploit input.
ii the function isint f returns a boolean according to whether the function fis an exposed interface or not.
it has the impact factor i. vulnerability in an exposed interface such as the main function is easily exploitable and must be xed with higher priority.
iii the function vuln inst f returns the number of distinct instructions that were found to contain a vulnerability and has the impact factor n. more vulnerabilities strongly indicates a missing input sanitization check somewhere in the function.
iv the function dinterface f returns the proximity length of nested function chains of the function to an exposed interface and has the impact factor d. a vulnerable function closer to an exposed interface may be easier to exploit.
v the function isoutlier f returns a boolean depending on whether the number of vulnerable instructions found section .
.
is much greater than the average number of vulnerable instructions per function in the program6.
the intuition behind this is the same as that for vulnerable inst f .
it has the impact factor o. we formulated the above functions with our industry partners and based on our combined intuitions on the programs that we analyzed we used the following function s to calculate the total severity value s f l lenchain f i isint f n vuln inst f d dinterface o isoutlier f functions with higher severity scores are in our view more vulnerable to attacks.
the speci c values for the impact factors are also as the function sitself dependent on the context of development and vulnerability analysis as we clarify once more in section .
as a nal presentation step macke color codes the ranges of severity scores for all functions in the program and displays the call graph with function and instruction level details of the test cases that cause a vulnerability to be exposed with compositional analysis.
.
results we conducted experiments to show that our compositional analysis technique with symbolic execution performs better than a plain forward symbolic execution technique and na ve static analysis7 by evaluating the outcomes on a number of parameters.
we applied macke on 6speci cally the number of vulnerable instructions where is the average number of vulnerable instructions in all functions and is the standard deviation in number of vulnerable instructions.
7using splint for memory management vulnerabilities4 open source applications and evaluated the results w.r.t.
forward symbolic execution over a comparable amount of total time.
the programs considered were flex grep8bzip2 and a set of coreutils programs unix utilities .
for each candidate program we put a limit of minutes per function for the stage one of compositional analysis with macke i.e.
looking for low level vulnerabilities.
after this stage all the static analysis processes and instrumentation for targeted path search were performed by macke automatically and took less than minutes per program .
for comparison with forward symbolic execution we ran klee with nurs covnew as the search method on the main functions for2 hours per program .
the source code coverage in all four programs was found to be higher with macke compositional analysis column than forward symbolic execution at main functions column .
in case of coreutils and grep however the relatively smaller increase in coverage may be attributed to the fact that most of the functionality in these programs are implemented in single monolithic functions instead of the more modular implementations found in bzip2 or flex.
overall the increase in coverage can be trivially attributed to the rst stage of compositional analysis that looks for low level vulnerabilities by separately analyzing functions in isolation.
it can be seen from table that vulnerable instructions reported by macke column are more comprehensive than forward symbolic execution column .
however this number is still far lower than a static code analysis tool column .
we infer from these gures that due to higher coverage compositional analysis nds more pote ntial vulnerabilities with exploit parameters in individual components than forward symbolic execution.
however developers do not have to go through thousands of reported vulnerable instructions many of which have no corresponding exploit parameters as is the case with static analysis.
in order to further demonstrate the e ectiveness of macke column lists the number of vulnerabilities reported in isolated functions that were also reproducible via at least one higher level of composition .
this shows that macke s compositional approach helped to con rm the reachability of some low level vulnerabilities through higher compositional interfaces thereby re ning the set of reported vulnerabilities even more.
last two columns list the number of vulnerabilities that were reported from themain functions.
for compositional case last column this set is a subset of the vulnerabilities reported in level up .
in the case of coreutils version .
we found one real vulnerability exploitable though main intouch.c that could not be found with forward symbolic execution.
finally in fig.
we present part of an interactive report generated by macke for grep program.
all the vulnerable functions are represented in compositional chains for depicting their 8sources for flex and grep were obtained from the softwareartifact infrastructure repository sir .
783figure interactive tool s sample result on grep l i n d o .
reproducibility a novel feature in symbolic analysis tools.
we claim that macke s approach leads to higher source coverage than forward symbolic execution more compositional information about reported vulnerabilities than static analysis a low number of possible false positives and highlighted function chains in a graphical report.
.
related work the earliest conceptualization of symbolic execution dates back to .
over the years many improvements to the basic symbolic execution techniques and domain speci c implementations have been developed .
tools for symbolic execution have also been developed for several programming languages .
the problem of directing path exploration in symbolic execution to speci c source locations is addressed in .
unfortunately most such works do not adequately describe ways to e ectively nd vulnerabilities.
the same shortcoming also applies to papers that deal with the problem of path explosion in symbolic execution.
in we nd methods of merging modifying or summarizing program states or individual components.
the technique proposed in for instance partitions the input space such that dynamic execution may execute separate paths of the program that depend exclusively on one input partition.
in the concolic execution tool is modi ed to deal with applications based on a speci c grammar for the input and the constraint solver is changed from a normal bu er based one to a grammar based constraint solver.
above ways are useful in mitigating the path explosion problem so as to increase coverage in a reasonable amount of time with symbolic execution.
however none of these works are accompanied by a tool for discovering and analyzing vulnerabilities which we postulate should follow increased path coverage in the program.
with respect to compositional analysis to the best of our knowledge none of the past works describe a freely available tool that nds vulnerable instructions compositionally analysis them and assigns severity to vulnerable components all in a single work.
additionally previous works like do not report reproducible improvementson existing evaluations such as on coreutils.
our work shows a clear improvement in terms of program coverage and vulnerability discovery.
our results also indicate a reduction in probable false positives w.r.t.
static analysis tools or compositional analysis methods that use static analysis for low level vulnerability detection such as .
compared to our approach pure static code analysis typically reports many more vulnerabilities using only code patterns most of which in our experience can be discarded as false positives without analyzing path feasibility.
some works such as do not limit the directed search strategy to nding vulnerabilities in the code but to a more generalized goal of generating summaries for parts of program to be re used for compositionally analyzing higher level components.
in the authors describe veri cation of a proprietary windows library.
the proposed technique uses the same rst step of executing functions in isolation without stubbing return values .
however the second step of path exploration is highly tailored to the image parsing library being veri ed.
speci cally only functions analyzed by the authors were notfully covered compared to more than functions in our analysis.
for the impartially covered functions authors of either manually inlined the functions to the calling contexts or manually examined the calling pre conditions to decide absence of memory related faults.
for a larger scale evaluation like ours this would of course be infeasible.
moreover our automation approach for summarizing paths to potential vulnerabilities and automatically replacing calling contexts with assertion statements works for more general scenarios.
in a related work by author?
only those low level functions are automatically summarized in the program whose input parameters are free of constraints up to the point that they are called .
for the real world examples that we evaluated macke on this would be unproductive because most of the low level functions in the call graphs were dependent on variables that were part of path constraints up to the calling statements.
with the above research gaps in mind our work aims to provide an open source tool to nd vulnerabilities analyze their reachability compositionally and report vulnerabilities in the context of their usage environment.
even though other works in the past have addressed the problem of vulnerability discovery with a similar compositional approach they have either not been shown to be e ective in terms of coverage and discovered vulnerabilities on multiple real world programs or not fully automated or are closed source implementations.
moreover none of the above works integrate vulnerability discovery with priority based reporting.
.
conclusion in this paper we have presented a tool for compositional analysis that uses symbolic execution on the isolated functional level and combines the results using static code analysis and targeted path search.
we evaluated macke on four open source projects.
in addition to being better than forward symbolic execution in terms of program coverage and vulnerability discovery macke also includes a severity scale that is based on the context around a reported vulnerability such as the distance of the function from a known interface and the number of possibly vulnerable instructions.
values of impact factors l i n d and o are chosen based on the context of development which is naturally speci c to the responsible stakeholders.
an empirical study of these 784impact factor values is left to future work.
all these impact factors together form a severity score .
this we believe is novel and crucial because in the absence of this severity metric it would be very di cult for developers to prioritize the bug xing procedure.
when combined with severity scores our compositional analysis tool empowers developers to not only analyze the reported vulnerabilities with more contextual information but also reason about which bugs are more critical to be resolved than others.
we wish to point here that the results of our study may have been a ected due to particularities of the open source programs we chose that may not be generalizable to a larger class of programs under test.
an empirical investigation on how macke can e ectively impact the productivity of developers and security of the resulting applications is left to future work.
.