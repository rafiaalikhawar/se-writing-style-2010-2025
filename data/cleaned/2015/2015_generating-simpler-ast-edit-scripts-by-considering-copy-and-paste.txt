generating simpler ast edit scripts by considering copy and paste yoshiki higo akio ohtani and shinji kusumoto graduate school of information science and technology osaka university yamadaoka suita osaka japan abstract in software development there are many situations in which developers need to understand given source code changes in detail.
until now a variety of techniques have been proposed to support understanding source code changes.
tree based differencing techniques are expected to have better understandability than text based ones which are widely used nowadays e.g.
diff in unix .
in this paper we propose toconsider copy and paste as a kind of editing action forming treebased edit script which is an editing sequence that transforms a tree to another one.
software developers often perform copy and paste when they are writing source code.
introducing copyand paste action into edit script contributes to not only making simpler more easily understandable edit scripts but also makingedit scripts closer to developers actual editing sequences.
we conducted experiments on an open dataset.
as a result we confirmed that our technique made edit scripts shorter for of the code changes with a little more computational time.
for the other code changes our technique generated the sameedit scripts as an existing technique.
we also confirmed that our technique provided more helpful visualizations.
i. i ntroduction in various situations in software development such as source code review and merge conflict resolution developers have to understand given source code changes in detail.
to support un derstanding source code changes previous work has proposed various techniques that visualize given changes.
the most widely used differencing techniques are textbased ones .
for example in unix diff added lines and deleted lines are visualized with special prefixes.
an issueof the text based differencing techniques is that the structureof source code is not considered.
because of this visualizedchanges are not necessarily easy to understand in detail.
techniques overcoming the issue of the text based differencing techniques are ast based ones .
in astbased differencing techniques given changes are visualizedaccording to the structure of source code.
in the techniques anedit script is generated from two asts which have been built from pre change and post change source code.
an edit script is a sequence of editing actions to convert the pre change astto the post change ast .
longer edit scripts are generated from bigger changes.
falleri et al.
showed that length of editscripts could be an indicator of the need to understand givenchanges .
changes with shorter edit scripts are easier tounderstand.
generating an edit script takes a long time if target source code is large or code move is considered.
falleri et al.
1abstract syntax treesucceeded to shorten generation time by adopting some heuristics .
they also showed that their edit scripts were morehelpful to understand the changes.
currently we are trying to generate more easilyunderstandable edit scripts.
in this paper we propose a new technique for edit script generation.
our technique is based onfalleri s one which visualizes code changes with four kindsof actions inserting deleting updating and moving.
we aregiving an eye to copy and paste which is a commonly performed operation when developers are writing source code .
in existing differencing techniques a change made bydeveloper s copy and paste is visualized as a sequence of newcode insertions.
as a result long edit scripts are generatedfor changes on which developer performed copy and pasteoperations.
in this research we propose to consider copy and paste as a kind of editing actions in edit scripts.
introducing copy and paste to edit scripts contributes to not only making themshorter but also making them closer to developers actualediting sequences.
in other words our technique generatesedit scripts for more easily understanding code changes.
our technique is a lower level representation of changes but theauthors consider that it can be used to generate higher level abstracted changes.
higher level changes are useful in variouscontexts of software development such as version controlmerging .
we conduct an experiment on opensource software with an implemented tool of our technique.
the followings are main findings of the experiment.
our technique generated shorter edit scripts for changes than falleri s technique .
for the remaining changes our technique generated the same editscripts as falleri s one.
our technique took longer time to generate edit scriptsthan falleri s technique.
however for changes gen eration time was less than one and a half times than falleri s technique.
for changes our technique gen erated edit scripts in two seconds.
the visualization of our technique was more helpful than falleri s technique for research participants on all theten change understanding tasks.
the reminder of this paper is organized as follows section ii shows an actual example for which our techniquegenerates a better edit script and then lists rqs to revealin this research section iii introduces some terminologies .
c circlecopyrt2017 ieeease urbana champaign il usa t echnical research532 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
!
!
!
!
!
!
a gumtree s visualization !
!
!
!
!
!
!
!
!
!
b ours visualization fig.
.
an actual change where our technique generated a shorter edit script than falleri s technique for this research section iv explains edit script and our research motivation in section v we propose a new astedit script generation technique by considering copy and paste section vi shows our experimental results and then answersthe rqs section vii dicsusses the results section viiidescribes some threats in the experiment lastly we concludethis paper in section ix.
ii.
a c hange example and research questions figure shows an actual change for which our technique generates a different edit script from falleri s one .
inthis change a method named setreception has been newly added.
setreception has a similar structure to another method named setrecurrence while the used variables and the invoked methods in the two methods are different.
figure a shows a visualized change with falleri s technique.
we can easily understand that green colored setreception has been added by the change.
figure b shows a visualized change with our technique.
the purple area in the pre change code means a copied code fragment and the samecolor in the post change code means its pasted code fragment.
the yellow tokens in the purple areas are different tokens between the copied and pasted code fragments.
by using falleri s technique we can easily understand that setreception has been added.
however there is no information about the followings in the visualization.
setreception is similar to setrecurrence .
the developer might have copied and pasted setrecurrence and then he she might have updated some tokens inside the pasted code.
by using our technique we can easily obtain the above information.
the knowledge that setreception is similar to setrecurrence should be useful for program understanding.
for example if a developer is trying to understand setreception and he she knows that setreception is similar to setrecurrence with which he she is familiar he she should be able to easily understand setreception.falleri s edit script for this change includes editing actions while our edit script includes only five.
our techniqueshortens the edit script for this change by .
in this research we try to answer the following research questions.
rq1 how often and how much does our technique gener ate shorter edit scripts than falleri s one?
rq2 can our technique generate edit scripts at short times?
rq3 are edit scripts of our technique more helpful tounderstand source code differences than falleri sone?
iii.
p reliminaries a. abstract syntax tree abstract syntax tree in short ast is a tree structured representation of source code.
figure shows toy source codeand an ast generated from it.
this ast has nodes each of which corresponds to a program element in the source code.
each node has a label for type and some nodes have valuestoo.
for example in figure b numberliteral meansthat numberliteral is its node type and is its value.
if a node has child nodes the child nodes represent more detailedinformation of the node.
for example the ifstatement node whose id is nhas two child nodes an infixexpresson node and a returnstatement node.
they represent the conditional expression and the inner statement of the if statement.
b. copy and paste when developers are writing source code they often copy and paste code .
there is a study that copy and paste is performed within a single source file .
copied and pastedcode become code clones.
kim et al.
proposed clone genealogy which approximates how programmers create propagate and evolve code clones by copying pasting and modifyingcode .
li et al.
pointed out that copy and pasted codecan include bugs because developers occasionally forget to change identifier names after copy and pasted operations .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a source code !
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
!
!
!
b ast fig.
.
an ast example they developed a tool cp miner to find such copy andpasted related bugs and found several dozen of new bugs in open source operating systems.
jablonski et al.
developedan eclipse plug in to track code generated by copy and pasteoperations .
the plug in monitors developer s behavior oneclipse to catch copy and paste operations.
c. code clone a code clone in short clone is a code fragment that is similar or identical to another code fragment in source code.
clones occur in source code for various reasons .
clones are classified as follows based on the degree of similarity to their correspondences.
type clone is completely identical code except white spaces tabs new line characters and comments.
type clone is similar code that includes token level differences.
for example similar code having different variable names or literals are classified into type .
type clone is similar code that includes larger differences than token level.
for example if a programstatement is inserted or deleted after a copy and pasteoperation the pasted code becomes a type clone ofits original code.
various clone detection techniques have been proposed until now .
each detection technique has a different clonedefinition.
thus different detection techniques find differentclones from the same source code.
in this research clones are similar subtrees in asts.
our type clones mean identical subtrees which have the same structures and the same values in their nodes.
our type 2clones mean they have the same structures but include different values.
our type clones mean their structures are similar but not identical including some extra nodes compared withtheir correspondences.
currently our technique utilizes only type and type clones for copy and paste operations.
iv .
ast e dit script an ast edit script is a sequence of editing actions to transform a given ast to another ast.
in existing research the following edit actions are considered .
insert t tp i l v means inserting a new node to the ast.
tis the inserted node.
its label is l. its value is v. its parent node is tp.imeans that tis the i th child of tp.
delete t means deleting an existing node from the ast.
tis the deletion target.
update t v means updating value of an existing node in the ast.
tis the updating target node.
vis a new value.
move t tp i means moving a subtree to another place in the ast.
tis the root node of the moving target subtree.
tpis the new parent node after twas moved.
imeans that tis the i th child of tp.
the length of an edit script is the number of editing actions included in it.
previous research reported that longer editscripts require more effort to understand .
consequently shorter edit scripts are better from the viewpoint of understanding code changes.
an edit script shows how to transform an ast to another one.
however edit scripts do not necessarily reproduce the process of code changes that developers made.
if we want toreproduce such an actual change process we need to recorddevelopers changes themselves .
a. previous research on edit script generation there are many research studies that proposed techniques of edit script generations.
myers proposed an efficient algorithm to compare two strings aand b and then generate a shortest edit script that transforms ainto b .
the algorithm requires o nd time.
nis the sum of the lengths of aand b.dis the size of the shortest edit script for aand b. miller et al.
proposed another algorithm for string comparison .
their algorithm is faster than unix diffin the case where two very similar strings are compared.
however if two completely different strings are compared the performance of the algorithmis much worse than diff.
both myers s and miller s algorithms do not consider moving code.
asaduzzaman et al.
proposed a technqiue named lhdiff for better tracking of source code lines .
firstly lhdiff utilizes unix diffto identify unchanged code lines in given two source files.
then for the remaining code lines thetechnique computes their context and content similarity.
if itidentifies similar code lines they are regarded as moved code.in asaduzzaman s experiment the time of lhdiff execution was times longer than unix diff.
recently tree edit script generations have been researched well.
pawlik et al.
proposed rted algorithm to compute a shortest tree edit script .
in the worst case their algorithmrequires o n time where nis the number of tree nodes.
however rted does not consider moving code.
their experiment showed that rted algorithm worked more efficiently for any authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
an overview of gumtree shapes of trees than other algorithms that generate a shortest edit script and do not consider moving code.
chawathe et al.
proposed an algorithm to generate an edit script from given two trees .
the remarkable feature ofthe algorithm is that the algorithm considers moving code.generating a shortest edit script in consideration with movingcode is an np hard problem.
to finish edit script generationquickly the algorithm often generates longer edit scripts.
inthe case where two similar trees are given to the algorithm italways generates a shortest edit script.
the algorithm requireso ne e time where nis the number of tree leaves and eis the weighted edit distance typically e lessmuchn .
fluri et al.
proposed an algorithm to compute tree differencing for source code change extraction .
this algorithmis a specialized version of chawathe s algorithm becausechawathe s algorithm is not for ast but for the general treestructure.
fluri et al.
introduced four kinds of modifications onchawathe s algorithm to extract more significant source codechanges.
because of the modifications fluri s algorithm getso log n slower than chawathe s algorithm.
however in the experiment fluri s algorithm approximated the minimum editscripts better than the chawathe s algorithm.
hashimoto et al.
proposed a technique to generate edit scripts including code move .
their technique utilizeszhang s algorithm which occasionally generates unfitting ast edit scripts because it is for general tree structures not specialized for ast structures.
thus hashimoto et al.introduced some preprocessing and postprocessing to generatemore appropriate ast edit scripts.
in hashimoto s technqiue move operations are derived from pairs of deleted subtrees andadded subtrees satisfying some conditions.
even in the worstcase the time complexity of hashimoto s technique cannotbe higher than o n where nis the number of nodes in the compared trees.
there are some algorithms that generate edit scripts for xml documents .
their algorithms give shortening the computational time the utmost importance.
thus editscripts generated with them are not suited to be understoodby the human.
!
a source code after change !
!
b generated edit script fig.
.
an example of gumtree s edit script b. gumtree falleri et al.
proposed a technique gumtree which can generate edit scripts from larget asts in consideration with moving code at short times .
figure shows an overview of gumt ree .i fgumt ree takes the source code of figure a and a as its inputs it outputs the edit script shown in figure b .
gumt ree executes the following steps for given two source files and then it outputs an edit script.
step1 syntax analysis performs syntax analysis for given source files to generate an ast for each of them.
step2 mapping generation generates mappings of subtrees between the two asts by executing step2 and step2 .
step2 top down mapping searches identical subtrees between the two asts.
the search starts atthe root nodes of the asts.
step2 bottom up mapping searches similar subtrees from other than the identical subtrees foundin step2 .
this search begins with each leaf nodeof the asts.
step3 edit script generation generates an edit script based on the mappings generated in step2 and step2535 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
chawathe s algorithm is used to generate edit scripts.
c. research motivation developers occasionally copy existing code fragments and paste them in other places of the source code when they are writing code .
however gumt ree does not consider copyand paste operations.
in edit scripts of gumt ree and other differencing techniques a copy and paste is represented witha sequence of insert actions.
figure shows a code change example where a new method is added to the source code shown in figure a .
the added method newf oo is quite similar to the existing method foo.
figure b shows an ast of the post change source code.
forthis change gumt ree outputs an edit script shown in figure c .
this edit script means that new nodes were added to the ast by the change.
however the subtree of the added method has the same structure as the subtree of the existing method.
in this case by considering copy and paste a simpler edit script can begenerated.
figure d shows an edit script generated by ourtechnique.
in this edit script firstly the subtree of the existingmethod is copied and pasted then two nodes in the pastedsubtree are updated.
v. p roposed technique herein we explain our technique.
an implemented tool of our technique for java is publicly available2 a. outline as described in subsection iv c by representing an added subtree with a copy and paste action rather than a sequenceof insert actions simpler edit scripts can be generated.
in ourtechnique a new editing action representing copy and pasteis introduced in addition to the conventional editing actions insert delete update and move .
in the case of figure the length of the edit script reduces by one fifth.
our edit script is not only shorter but also easier to understand becausea combination of copy and paste and update actions implies that similar code has been added by a given change.
our technique is designed by extending gumt ree .
figure shows an overview of our technique.
our technique takestwo source files and it outputs an edit script.
our techniqueincludes three steps as well as gumt ree .
our technique considers five editing actions insert delete update move and c p. the former four actions are the same as gumt ree s ones which are described in section iv.
the following is thedefinition of the new action.
c p t tp i means copying an existing subtree and pasting it to another place in the ast.
tis the root of the subtree of the copying target.
tpis the parent node of the pasted place.
imeans that tis pasted as the i th child of tp.
a post change code !
!
!
!
!
b post change ast !
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
!
!
!
c edit script by gumt ree d edit script by our technique fig.
.
a change example where a new method was added authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
an overview of our technique b. procedure our technique is an extended version of gumt ree .i n figure the steps that have been added or changed in our technique are emphasized.
the followings are short descrip tions for each of the steps.
step2 top down mapping searches identical subtrees between the two asts.
this step also finds candidates for copy and pasted subtrees.
step2 c p cognition checks whether each of the copy and pasted candidates has been mapped in step2 or not.
if not the candidate is regarded as generated bycopy and paste.
step3 edit script generation generates an edit script with the two asts generated in step1 and the mapping information including the copy and paste information .
the remainder of this section explains each of the above steps in detail.
c. step2 top down mapping in step2 our technique finds candidates of subtrees added by copy and paste operations in addition to the processings of original gumt ree .
step2 of our technique consists of the following processings.
the processings and arethe same as original gumt ree .
the processing has been newly added in our technique.
finding similar subtrees between the two asts.
in this explanation we assume that nsubtrees in the pre change ast are similar to msubtrees of the post change ast.
those subtrees can be represented by a bipartite graph where a set of nnodes and another set of mnodes exist.
an edge exists between each pair of two nodes whose similarity is higher than a given threshold.
making mappings between the nnodes and the mnodes with the following procedure.
firstly finding a pair of nodes that has the highest similarity between the nnodes and the mnodes.
the found pair is recorded and the two nodes forming the pair are removed from the bipartitegraph.
secondly finding a pair of nodes that has thehighest similarity between the n nodes and the m nodes.
this processing is repeated until all edges in thebipartite graph disappear.
when the processing has finished the remaining nodes in the bipartite graph mean that their subtrees havenot been mapped to any other subtrees.
in other words their subtrees are similar to other subtrees but the other subtrees have more similar subtrees.
in our technique non mapped subtrees in the post change ast are treated as candidates for copy and paste from the most similarsubtrees in the pre change ast.
d. step2 c p cognition in this step our technique determines which candidates are copy and paste operations.
our technique traverses the post change ast to find nodes satisfying both the followingconditions found as candidates for copy and paste operation instep2 and not mapped to any nodes in the pre change ast when step2 has finished.
if our technique finds a node that satisfies both the conditions it regards a pair of the candidate and its most similar subtrees as a copy and paste mapping.
in this step we use a heuristic.
in our technique subtrees similarities are calculated based on their structure and node labels.
node values are ignored.
thus many false positivesare found.
for example all variable declaration statements areregarded as identical subtrees even if their variable types and variable names are different.
to reduce such false positives if all node values in a subtree are different from ones of another subtree the two subtrees are not regarded as a copy and pasteoperation.
e. step3 edit script generation chawathe s algorithm is used in step3 to identify insert delete update and move as well as original gumt ree .
our technique extends chawathe s algorithm to identify c p too.
in step3 the two asts are traversed once and an edit script is generated.
identifying insert update move and c p actions by traversing the post change ast.
identifying delete actions by traversing the pre change ast.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
fig.
.
an example of mappings mappings between figure b and figure b in the processing if our technique finds a node in the copy and paste mappings a c p action is added to the edit script.
f .
an example of edit script generation figure shows an example of mappings between prechange and post change asts.
in this figure the pre change ast is the same as figure b and the post change ast is the same as figure b .
in step2 top down mapping subtree ein the prechange ast gets mapped with subtree ein the post change ast.
besides subtree ein the pre change ast is very similar toe primein the post change ast so that they become a candidate for copy and paste operation.
in step2 bottom up mapping firstly container mappings are generated.
a container mapping means if most nodes under a subtree have been mapped the root node of thesubtree also gets mapped.
in the process of container mappinggeneration node bin the pre change ast gets mapped with node bin the post change ast.
then recovery mappings are generated.
recovery mappings mean mapping nodes bytraversing from the nodes of the container mappings to their leaves.
in this example nodes cand dget mapped in the process of recovery mapping generation.
in step2 c p cognition each copy and paste candidate found in step2 is checked whether it has been mappedin step2 or not.
if not the candidate is regarded as copy and paste operation.
in this example subtree ein the prechange ast and e primeof the post change ast found as a copyand paste candidate in step2 and e primeis not mapped instep2 .
consequently they are regarded as a copy and pasteoperation in step2 .
in step3 an edit script is generated with the mapping and copy and paste information as follows.
for each pair of moved subtrees a move action is added to the edit script.
in this example there are no movedsubtrees.
for each pair of nodes that includes different values an update action is added to the edit script.
node pairs under a pair of copy and paste are not targets of this processing.
thus no update action is added to the edit script in the example.
if the pre change ast includes nodes that are not mapped to any nodes in the post change ast delete actions for them are added to the edit script.
in this example there is no node for delete actions.
if the post change ast includes nodes that are neither mapped nor copy and paste insert actions for them are added to the edit script.
in this example there is no nodefor insert actions.
for each subtree of copy and paste in the post change ast a c p action is added to the edit script.
if there are nodes under the subtree that have different values fromtheir counterparts update actions for them are added to the edit script.
in this example action c p e b is added and then two more actions update h newfoo andupdate s newfoo!
are also added.
as a result the edit script shown in figure d is generated by our technique.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
vi.
e v aluation as described in section iv a there are many techniques to generate edit scripts.
falleri s experiment showed that gumt ree s edit scripts were easier to understand for the human than other techniques .
hence we compare our technique with gumt ree and then answer the rqs listed in section ii.
a. preparation we use the following values as the thresholds of gumt ree and our technique.
those values are the same as ones that were used in falleri s experiment .
the minimum subtree height for top down mappings is .
the minimum similarity for bottom up mappings is .
.
only subtrees having or fewer nodes are targets ofbottom up mappings.
our experimental targets are software systems that are included in cvs vintage dataset .
this dataset includes source files and revisions in total.
this dataset was used in falleri s experiment too.
b. procedure for rq1 and rq2 we run gumt ree and our technique for the same changes and then compared generated edit scripts3.
in the remainder of this section we call a pair of two consecutive revisionsof a source file a change .
thus the number of changed source files is the same as the number of changes in thisexperiment.
changes for the two tools were extracted from the projects.
for each project changes were extracted.
if a project included less than changes all the changes were extracted.
the target changes were extracted in the following way which is the same as fellari s experiment.
we identified revisions in which at least a source file is committed and then we obtained a list of the committed source files for each of the identified revisions.
we retrieved the pre change revision for each of the files in the lists.
3gumt ree and our technique were executed on a personal workstation equipped with a .40ghz core cpu and 32gb ddr4 memory.
table i edit script length of our technique and gumtree for the changes for which our technique generated different edit scripts from gumtree projectmaximum value median minimum value gt ours gt ours gt ours argouml carol columba dnsjava jboss jedit jhotdraw junit log4j jdtcore workbench scarab struts tomcat argouml carol columba dnsjava jboss jedit jhotdraw junit log4j jdtcore workbench scarab struts tomcat0.
.
.
.
.
.
fig.
.
edit script length ratio of our technique to gumt ree argouml carol columba dnsjava jboss jedit jhotdraw junit log4j jdtcore workbench scarab struts tomcat05101520 fig.
.
execution time ratio of our technique to gumt ree we stored each pair of the pre change and post change texts of the files as a change.
we removed changes where only comments and or formatting are modified because empty edit scripts are generated from such changes.
we selected changes randomly from the remaining ones.
we obtained changes in total.
all the obtained changes were given to gumt ree and our technique to generate edit scripts.
the execution time of the tools was measured.
c. results for rq1 and rq2 for changes our technique generated shorter edit scripts than gumt ree .
for the remaining changes our technique generated the same edit scripts as gumt ree .
there was no change for which our technique generated a longer edit script than gumt ree .
table i shows the length of the edit scripts for the changes.
figure shows the length ratio of our technique to gumt ree for the changes.
for most of the projects the median values are between .
and .
.
more concretely for .
of the changes in the graph our technique shortenededit scripts by or more.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
figure shows the execution time ratio of our technique to gumt ree .
the execution time of our technique tends to longer than gumt ree .
for all the changes we confirmed that there was a significant difference in execution time between our technique and gumt ree by using wilcoxon signed rank test with .
.
however the difference of execution time is not so large.
for changes our technique took one and a half times or less than gumt ree .
for and changes our technique took less than second and seconds respectively.
our answer to rq1 is that our technique generated shorter edit scripts for changes and for .
of those changes our technique shortened or more.
our answer to rq2 is that our technique can generate edit scripts at short times.
our technique took less than seconds for of all target changes.
d. procedure for rq3 twelve research participants took part in the experiment for rq3.
the participants include one professor nine graduate students and two undergraduate students.
the professor andall the graduate students had experiences in the research ofsoftware engineering.
they had at least year experiencesof java programming in their research.
the undergraduatestudents had finished a half year java exercise in their course.
all the participants are not the authors of this paper.
in this experiment the authors prepared ten changes hereafter we call them tasks all of which were selected from the changes.
all the ten tasks satisfy both the following conditions.
gumt ree and our technique generate different edit scripts for the tasks.
the tasks do not include huge code changes such as changing all over the source files.
this experiment included two phases.
in the first phase the research participants were divided into two groups.
the participants in the first group used our technique to understand thechanges for the odd numbered tasks and they used gumt ree for the even numbered tasks.
the participants in the secondgroup used gumt ree and our technique in an opposite way.
each of the participants wrote down what he she understoodon the tasks after they had finished understanding the tasks.
to keep participants concentration we set one hour as the time limit for understanding the tasks.
thus there were someparticipants who were not able to finish some tasks.
in the second phase for each of the tasks each participant compared visualization of our technique with gumt ree and then chose from the following five options.
the visualization of gumt ree is definitely more helpful to understand the tasks.
the visualization of gumt ree seems a little more helpful to understand the tasks.
no differences in the visualization of gumt ree and our technique from the viewpoint of understanding the tasks.
the visualization of our technique seems a little more helpful to understand the tasks.
fig.
.
understanding time for the tasks fig.
.
description length for the tasks the visualization of our technique is definitely more helpful to understand the tasks.
e. evaluation measure for rq3 in this experiment we used the following evaluation indicators to compare our technique with gumt ree the time required to understand the tasks the degree of understanding the tasks and participants qualitative comparison.
the participants timed themselves for the time required to understand the tasks.
before this experiment we told the participants not to count the time required to write down whatthey understood on the tasks in the time required to understandthe tasks.
we considered that if a participant understood a task well he she would write down what she he understood in detail.
thus we used the length of participants descriptions as the degree of understanding the tasks.
we used the questionnaire described in the last paragraph of subsection vi d for the qualitative comparison.
f .
results for rq3 figure shows the average understanding time of the research participants for each of the tasks.
to reduce influences of the outliers we eliminated the minimum and maximum values in calculating average time.
the total time of our technique was seconds and gumt ree is seconds respectively.
to investigate whether there was a significantdifference in understanding time between our technique and gumt ree we firstly checked the presence of normality in the time data with shapiro wilk test.
after we confirmedthe presence of normality we applied paired t test to the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii answers of the research participants for qualitative comparisons research participants abcdefgh i j kl ave. med.
tasks01 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ave. .
.
.
.
.
.
.
.
.
.
.
.
med.
.
.
.
.
.
.
.
.
.
.
.
.
data.
as a result there was no significant difference in the understanding time between our technique and gumt ree .
figure shows the average length of participants descriptions for each of the tasks.
we eliminated the minimum and maximum values in calculating average length too.
the totallength of our technique was .
bytes and gumt ree was .
bytes respectively.
to investigate the presence of asignificant difference in the description length of our techniqueand gumt ree we firstly checked the presence of the normality in the description length data with shapiro wilk test.
after weconfirmed that there was no normality in the data we applied wilcoxon signed rank test to the data.
as a result there was no significant difference in the description length between ourtechnique and gumt ree .
table ii shows the participants answers for the questionnaire.
for all the tasks the average and median values weremore than .
in other words the research participants felt that our technique was more helpful than gumt ree for all the tasks.
on the other hand there were two participants whose averageand median values were less than .
research participants aand d considered that gumt ree was better than our technique for the tasks.
consequently we conclude that our techniqueprovides better visualization than gumt ree .
however there were some developers who preferred gumt ree s visualization than our technique.
our answer to rq3 is that the research participants tended to prefer change visualization based on our technique thanfalleri s one for all their tasks.
vii.
d iscussion in the current implementation identical subtrees same structure and same values and structurally identical subtrees same structure but different values are regarded as copy andpaste.
the former is a type clone and the latter is a type clone respectively.
in the experiment for changes our technique generated the same edit scripts as gumt ree .
those edit scripts did not include c p actions at all.
if we use an ast based type clone detection techniques such as clonedr or deckard our technique can be extended 4in the questionnaire .
.
are ordinal scale not ratio scale.
thus the average values in this experiment should be used only as a guide.to regard type clones as copy and paste.
if we do such an extension more edit scripts will include c p actions.
we used value as the minimum height of subtrees for copy and paste.
if we use a greater value less edit scripts include c p actions.
viii.
t hreats tovalidity in the experiment the target programming language was only java.
our technique s and gumt ree s algorithms are not specialized for java.
however currently we do not know whether our technique works well for other programming languages.
in the experiment we used the same experimental targets and the same threshold values as falleri s experiment.however if we use different projects or different threshold values we may obtain different experimental results.
more experiments are required with more projects and more differentthreshold values to evaluate our technique more solidly.
ix.
c onclusion in this paper we proposed to introduce copy and paste operation to ast edit script to promote change understand ability.
in the process of designing our technique we weregreatly affected by an existing technique gumt ree and our technique is its extended version.
we conducted an experimentto compare our technique with gumt ree .
as a result our technique generated shorter edit scripts than gumt ree for changes.
for the remaining changes our technique generated the same edit scripts as gumt ree .
we also confirmed that the execution time of our technique tends to be longerthan gumt ree .
however for changes the execution time of our technique was less than seconds.
we conducted an other experiment with research participants and confirmedthat our technique provided more helpful visualization than gumt ree for all the ten change understanding tasks.
in the future we are going to apply our technique for more projects.
extending our technique to regard type clones ascopy and paste is another future work.
a cknowledgment this work was supported by mext jsps kakenhi .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.