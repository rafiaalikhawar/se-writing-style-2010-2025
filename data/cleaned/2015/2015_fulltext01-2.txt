postprint this is the accepted version of a paper presented at 30th int.
conf.
on automated software engineering ase .
citation for the original published paper artho c. seidl m. gros q. choi e h. kitamura t. et al.
model based testing of stateful apis with modbat.
in proc.
30th int.
conf.
on automated software engineering ase pp.
.
n.b.
when citing this work cite the original published paper.
permanent link to this version modbat.dsl.
class simplelistmodel extends model val sut new java.util.arraylist var n def add val ret sut.add new integer choose assert ret n def remove require n sut.remove choose n n def bounds choose sut.remove sut.remove n main main add weight main main remove main main assert sut.size n main main sut.clear n main main bounds throws indexoutofboundsexception figure .
simple list model.
include a reference to the sut and model variables to track the model s view of the sut to verify its results.
in this case the model only keeps track of the expected size of the list.
the model code can also define a number of functions in the middle that can be referenced from the declared transitions at the bottom .
this example uses only one model state main because most actions are available in any state.1to use random data the model calls modbat s choose functions which return a random number and a random element in a list of functions respectively.
the example shows that test code can be kept in a separate function or be directly written as an anonymous function.
we can also modify the weight of a transition function by default its value is .
in this example we emphasize adding elements by giving more weight to add so calls to clear do not repeatedly empty the list before several elements can be added.
finally we can easily declare that an exception must occur in a given transition.
in this case calls to remove with index 1ornaccess an entry outside the valid range so the sut is expected to throw a corresponding exception.
b. key features of modbat modbat s light weight dsl has been inspired by a preprocessor to modeljunit .
compared to similar tools it is more concise and expressive for models that are based on transition systems especially for non deterministic actions like nonblocking network input output where the result of an operation depends not only on inputs but also on the physical state of the network .
as models are scala classes they inherit all variables functions and transitions in a natural way which makes modbat ideal for testing libraries implementing several related data structures or protocols.
furthermore the current version of modbat introduces observer state machines similar to abstract state machines in spec explorer .
1it is also possible to use multiple states in the model such as empty and non empty and to define transitions with pre and postconditions.table i. i terator methods .
method description hasnext true if forward iterator has more elements next returns the next element and advances the cursor remove removes the element that was returned optional method table ii.
a dditional list iterator methods .
method description add e inserts the specified element optional method hasprevious true if reverse iterator has more elements nextindex returns the index of the next element previous return the previous element moves the cursor backwards previousindex returns the index of the previous element set e replaces the element that was returned optional method in this demonstration we take advantage of being able to use multiple models in parallel.
unlike in other tools the number of parallel models does not have to be fixed a priori.
instead models are instantiated dynamically with functionlaunch which initializes a new possibly parametrized model.
newly launched models become active at the end of the current transition.
iii.
s cenario j ava iterators the java library contains collections data structures for data types such as lists sets and maps .
iterators provide a way to access elements of a collection one by one.
a. semantics of the iterator api iterators can be instantiated on an underlying collection through the methods iterator andlistiterator .
the former provides a simple forward iterator see table i while the latter provides a bidirectional iterator see table ii .
java iterators do not allow a concurrent modification of the underlying collection while iterating on it.
any modification of the underlying collection invalidates all previously created iterators on it.
invalid iterators produce an undefined result for calls to hasnext and similar methods 2and throw a concurrentmodificationexception if attempts are made to access or modify data through them.
through experiments we confirmed that this exception is usually only thrown upon a successful modification of the underlying collection.
while directly modifying the collection invalidates all of its iterators it is possible to modify data if the iterator itself provides a set of optional methods add set and remove .
such modifications are intricately linked with iteration remove andset both require a preceding call to either next orprevious .
furthermore calls to remove or add require another iterator step before remove orset can be called again.
we discuss this property in more depth below.
b. model of the iterator api our list model closely mirrors java s collections but uses simpler data structures to ensure correctness.
we use random data as items to be added and also add a function to validate internal model invariants.
modbat s support for inheritance is very useful here because arraylist implements a strict 2this was confirmed by oracle as a response to a bug report filed by us under test iterator modelmodellistiteratoriterator model modelcollection systemfigure .
orchestrating collection and iterator models.
main add set remove illegalstateexception modifiable next previous remove add next previous set figure .
model of the bidirectional iterator showing the applicability of set andremove before and after calls to other methods.
subset of all operations in linkedlist .3our generic list model uses the following data structures testdata the sut data a fixed size array that models the list contents n which counts the number of elements and version which counts the number of changes to the collection.
we use preconditions to distinguish between cases where a method can be used successfully and cases where we expect an exception to be thrown.
modbat s direct support for exceptions in transitions allows us to express these features succinctly .
iterators and list iterator models are instantiated by transitions in the list model that launch a new child model instance and link it to the resulting iterator that is obtained from the sut.
each model may affect the collection and or an iterator see figure .
the iterator models remember the version of the list so the occurrence or absence of a concurrentmodificationexception can be modeled based on whether the version counts of the collection and of the iterator match.
furthermore we use a state modifiable to model whether calls to set andremove are permitted these calls require a previous call to next orprevious without any other modification in between see figure .
other requirements are captured using preconditions and postconditions.
we choose to model valid and invalid usage contexts using mutually exclusive preconditions and verify the correct result using exception declarations and postconditions see figure details can be found online .
c. defect found in java .
when running the test model against java s list implementation some tests fail on arraylist after a failed remove the java library marks the list as modified subsequent calls to next throw a concurrentmodificationexception see figure .
other types of failed modifications such as remove with n do notmark the list as modified.
all other data structures behave consistently in all cases.
modbat finds the problem quickly oracle has confirmed the issue as a defect.
3some operations are not provided by arraylist because they cannot be implemented efficiently on arrays.
def valid version datamodel.version def next simplified for brevity require valid require pos datamodel.n val res sutit.next pos assert datamodel.data pos res figure .
transition modeling valid uses of next .
arraylist integer list new arraylist integer iterator integer it list.iterator try list.remove attempt removal catch indexoutofboundsexception fails it.next expected nosuchelementexception but throws concurrentmodificationexception figure .
error trace for java s arraylist .
we obtain an iterator on an empty list and then try to remove a non existent element at index .
this operation does not modify the list but the next operation throws aconcurrentmodificationexception which is wrong.
the trace shown here is minimal but the issue is more serious for non empty lists because the spurious exception prevents further access to data.
iv.
s cenario sat s olver a. sat solvers in verification sat solvers are tools for deciding the satisfiability problem of propositional logic.
formulas of propositional logic consist of atomic variables x y defined over the boolean domain logical connectives like negation conjunction and disjunction with standard semantics as well as parentheses necessary to structure a formula.
for example x y x y is true if both variables have the same value.
a sat solver tries to find an assignment for the variables of a formula such that the formula is true under this assignment.
by being the prototypical problem for the complexity class np sat offers a powerful framework for encoding and solving many problems stemming from verification artificial intelligence etc.
.
often sat solvers are not used only once in a verification problem but in an incremental manner.
here a satisfiable formula is enriched with additional constraints until it becomes either unsat or the considered problem is found to be satisfiable.
usually formulas are represented in conjunctive normal form cnf i. e. as conjunction of clauses.
a clause is a disjunction of literals and a literal is either a variable or its negation.
constraints are given in form of additional clauses.
for developing a competitive sat solver that is able to handle real world formula instances pruning techniques are essential.
these techniques have to be carefully integrated into the incremental solving process in order to preserve the correctness of the solver.
therefore modern sat solvers are very complex pieces of software and as it has been shown they are not resistant to errors.
especially when sat solvers are part of the verification process however it is not acceptable that a sat solver is faulty because otherwise the whole effort put into the verification process is useless.
because of their complex structure competitive sat solvers are not amenable to full verification.
therefore other techniques have to be applied to ensure correctness and trust in sat solvers.cnf unit create clause solve testsolver binary choose lit clause done sat solve unsat solve inc solve done ternary choose lit add clause done rest choose lit done choose lit checkassignment checkassumption add clauses end exit figure .
ipasir model for incremental sat solvers coverage after 5tests.
b. model based testing of sat solvers in previous work we have presented model based testing for sat solvers .
to this end we considered a data model describing expressive random formulas as input as well as a model describing the usage of the api.
we presented specific solutions for the sat solver lingeling which has always ranked highly in the sat solver competition because of its sophisticated pruning techniques.
in various experiments we showed the power of model based testing for the sat solver lingeling .
those models are very specific to lingeling which provides an extensive api and many options and hence cannot be used for other sat solvers directly.
at that time no standards for incremental sat solver apis existed.
this year the sat competition offers a special track for incremental solving acknowledging its practical relevance.
in this track submissions include incremental solvers as well as applications which use incremental sat solvers.
to this end a standardized interface called ipasir has been specified which the participating sat solvers have to implement and which can be used by the applications .
we contribute to the incremental track of the sat solver competition by providing a model based tester for incremental sat solvers.
we implemented this model based tester with modbat by specifying the model shown in figure .
the transitions between the states trigger the call of various solver api functions specified by the ipasir interface.
first the solver is initialized and then the input formula is generated left hand side .
the input formula consists of unit clauses clauses of size one binary clauses ternary clauses and clauses of arbi trary size.
it is important to ensure that the formula contains clauses of size smaller than four because these clauses are often handled in a different manner.
the literals and their polarity negated not negated are randomly selected and given to the solver under test.
after enough clauses have been generated the solving function is called.
as formulas are generated at random the outcome of the sat solver cannot be predicted by the model.
the dashed transitions from state solve indicate alternative outcomes unsatisfiable formulas or a time out overriding the default successor state sat with unsat and inc respectively using nextif statements that specify pairs of predicates and successor states.
if we use option dotify coverage modbat indicates that the first five tests generate only unsatisfiable formulas see figure .
the new model can be used for any solver implementing the ipasir interface.
therefore it can be easily integrated in the solver development process.
for the competition we suggest to measure the time a solver takes to finish a given number of tests generated from a fixed random seed.
in the provided demo we test sat solver picosat .
we demonstrate the tests on the original version and a modified version where we introduced a small bug in a pruning technique called failed literal probing in the faulty version a literal is not negated .
the bug causes the program to crash sporadically.
with modbat this bug can be found quickly.
note that picosat can be easily exchanged against any incremental sat solver implementing the ipasir interface.
v. r elated work a variety of model based testing tools with different features and characteristics have been proposed up to now.
in a systematic review shafique and labiche identified a total of tools and apis providing support for model based testing.
micskei maintains an online overview of model based testing tools currently according to the information last modified in july the list contains academic commercial and open source tools plus tools that are not developed anymore.
several tools have features and characteristics that are similar to those of modbat.
to highlight and explain the differences between modbat and related tools we selected three widely known tools for comparison modeljunit scalacheck and spec explorer .
we consider these tools to be representative examples as we have practical experience from applying them in previous projects and since some of their features were a source of inspiration when implementing modbat.