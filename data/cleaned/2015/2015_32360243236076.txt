stochastic energy optimization for mobile gps applications anthony canino suny binghamton binghamton new york acanino1 binghamton.eduyu david liu suny binghamton binghamton new york davidl binghamton.eduhidehiko masuhara tokyo institue of technology tokyo japan masuhara is.titech.ac.jp abstract mobile applications regularly interact with their noisy and everchanging physical environment.
the fundamentally uncertain nature of such interactions leads to significant challenges in energy optimization a crucial goal of software engineering on mobile devices.
this paper presents aeneas a novel energy optimization framework for android in the presence of uncertainty.
aeneas provides a minimalistic programming model where acceptable program behavioral settings are abstracted as knobs and application specific optimization goals such as meeting an energy budget are crystallized as rewards both of which are directly programmable.
at its heart aeneas is endowed with a stochastic optimizer to adaptively and intelligently select the reward optimal knob setting through a form of reinforcement learning.
we evaluate aeneas on mobile gps applications built over google locationservice api.
through an in field case study that covers approximately miles and hours of driving as well as hours of biking and hiking we find that aeneas can effectively and resiliently meet programmerspecified energy budgets in uncertain physical environments where individual gps readings undergo significant fluctuation.
compared with non stochastic approaches such as profile guided optimization aeneas produces significantly more stable results across runs.
ccs concepts software and its engineering power management humancentered computing mobile computing keywords energy management stochastic optimization uncertainty acm reference format anthony canino yu david liu and hidehiko masuhara.
.
stochastic energy optimization for mobile gps applications.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa pages.
introduction energy efficiency is a critical goal of mobile software ecosystem design.
effective energy optimization requires a precise understanding permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
elapsed time seconds as unit energy j trace with gps update interval 1s 500msfigure the energy fluctuation of a gps application.
the two traces are collected when a mapping app maps.me navigates in a moving vehicle.
each data point represents the energy consumption in the preceding time unit.
of the in situ energy behavior of the application and its underlying systems.
the very nature of mobile systems however poses a fundamental challenge against meeting this requirement a mobile application may frequently interact with the noisy and ever changing physical environment leading to significant uncertainty in energy behavior.
take the energy behavior of a gps based mapping application for example.
figure illustrates two traces of its energy consumption with gps update intervals set at second and milliseconds respectively through google locationservices .
some observations may surprise an energy optimization designer who expects more predictable results.
first within each trace there is significant variation in energy consumption e.g.
ranging from joules to joules in the 1s trace despite that the gps update interval does not change within each trace.
second the variation is often time dependent e.g.
for the 1s trace energy consumption ranges joules during elapsed time units while later it remains within joules during elapsed time units possibly due to physical environment change.
third when we consider multiple traces the seemingly obvious task of deciding between 1s and 500ms as the desirable gps interval to minimize energy consumption a common decision in application level energy optimization may not be obvious at all.
aeneas design.
in this paper we describe aeneas1 a novel energy optimization framework for android applications where uncertainty is treated as the rule not the exception in mobile application energy optimization .
aeneas provides a simple programming interface where knobs i.e.
application specific semantic elements that may have different 1aeneas is the hero in virgil s epic aeneid .
despite many uncertainties on land and at sea he finally reached latium.
esec fse november lake buena vista fl usa anthony canino yu david liu and hidehiko masuhara energy impacts can be defined by programmers.
in addition programmers may provide their application specific goal for optimization such as quality of service qos or energy budget through programmable rewards .
the maintenance tasks of the knobs and rewards are left to the stochastic run time optimizer such as deciding which knob setting should be selected when it should be selected and how to meet the reward.
unlike traditional approaches based on testing or profiling our optimization is fundamentally in vivo the process of observing the uncertain vicissitudes of energy behavior and that of performing stochastic optimization are unified as one.
within the landscape of energy optimizations where uncertainty is either smoothed out through heuristics or mitigated through fault tolerance or worse treated as an experimental afterthought aeneas represents a distinct point in the design space where uncertainty is captured by design .
philosophically aeneas can be viewed as an interesting instance of human machine co optimization.
the two components of aeneas a simple programming interface and a sophisticated runtime design bring the programmer and the automated algorithm together for cooperative energy optimization.
this two pronged design leads to three noteworthy features representing different work distributions between the programmer and the automated algorithm.
first we allow programmers to fully provide alternative settings of a knob such as a gps update interval can be either 1s or 500ms a feature we call the declared discrete knob .
the goal of the stochastic optimizer for this feature is to adaptively select the reward optimal one among the alternatives.
second when the programmer does not fully specify what the alternatives for a numeric knob should be we allow programmers to simply provide a range a feature we call the inferred knob .
to support this feature the stochastic optimizer is endowed with an iterative refinement algorithm.
third our stochastic algorithm itself comes with inherent parameters.
instead of asking programmers or deployers to provide hard code values aeneas can function as a self optimizer where the optimal parameter setting is stochastically selected.
our concrete stochastic algorithm design is based on multiarmed bandits mab a family of reinforcement learning algorithms with solid theoretical underpinnings on optimality .
our framework bridges program level elements of knobs and rewards to two fundamental concepts in mab slots and rewards.
in this view aeneas is a unique systematic study in streamlining the programming interface between the application and the runtime for reinforcement learning.
in aeneas stochastic optimization is no longer a pure system level feature invisible to programmers but a service that applications may choose to resort to for cooperative energy optimization.
aeneas for gps applications.
our experience with aeneas represents a significant effort of evaluating the idea of stochastic energy optimization in the real world.
aeneas is built on top of android and we use it to guide an open source gps mapping app maps.me .
the evaluation was conducted through driving for hours covering approximately miles as well as hours of biking and hiking.
to the best of our knowledge our in field evaluation is the most extensive study of applying mab algorithms to mobile transportation systems.
these use scenarios are impactful in the real world for a number of reasons.
first gps apps are prevalently used.second they continuously interact with the surrounding environment regardless of being in the foreground or background the need for turn by turn directions implies they may be used for a long duration.
third for use scenarios where driving is involved plugging mobile devices to car chargers is known to be environmentally unfriendly it may cost times more energy than charging from wall sockets .
fourth for more environmentally friendly use scenarios such as biking hiking and riding in public transportation the energy optimization of gps applications critically links to mobile device usability.
our evaluation shows that aeneas is highly effective in energy optimization in the presence of uncertainty inherent in gps data.
through a comprehensive design space exploration with declared discrete knobs vs.inferred knobs varying energy budgets as rewards varying numbers and settings of knobs and varying modes of transportation we find aeneas consistently converges toward the knob settings to maximize the programmer specified reward such as a particular battery drain rate.
when compared with nonstochastic approaches we also find aeneas remarkably resilient occasional noise or physical environment change has little impact on the effectiveness of optimization.
in contrast profiling based approaches are significantly more sensitive to how representative the profile data are.
contributions.
this paper makes the following contributions a simple and intuitive programming model and api to streamline application level energy management with run time level stochastic optimization a novel stochastic optimizer based on mab with variants an optimizer for declared discrete knobs an iterative refinement optimizer for inferred knobs and a self optimizer a significant in field evaluation with a comprehensive design space exploration and extensive driving biking hiking experiments aeneas is an open source project.
details can be found at our website with url .
background mab is a classic problem in stochastic optimization.
the real world inspiration comes from slot machines.
a gambler wishes to optimize the accumulated reward by pulling a set of slot machines each with a distinct but unknown distribution of rewards.
the gambler may choose to interact with the slot machine by either pulling a lever to try it out a step known as exploration in mab or pulling one known to produce a good reward a step known as exploitation in mab.
most mab solutions focus on balancing the trade off between exploration and exploitation a common theme within reinforcement learning.
mathematically the mab problem can be viewed as follows.
given a set of configurations c let us assume each configuration c cwhen interacted at its tthtime has reward t c .
the mab algorithm attempts to construct an interaction sequence i where ij cfor any j with the goal of maximizing qx k 1 l ik ik wherel i c is alocal counting function defined as the number of times cappears in i. the algorithm is 704stochastic energy optimization for mobile gps applications esec fse november lake buena vista fl usa online in nature in that the selection of ijmay be influenced by the rewards associated with configuration choices i1.
.
.ij .
many solutions exist for solving the mab problem .
for example the one algorithm that will be extensively used by aeneas is value difference based exploration vdbe .
in the interaction sequence the average reward for each configuration cis maintained separately through the simple qfunction below.
qt c t 1 c 2 c t c as the algorithm is online in nature the same definition can be written a more friendly recurrence form qt c qt c t t c qt c the essence of vdbe is to choose between exploration and exploitation at each interaction.
for an interaction sequence so far asi the next interaction should chose itas exploration random c c. exploitation ciwhere ql i ci ci is the maximum among ql i c1 c1 .
.
.ql i cp cp wherec c1 c2 .
.
.
cp .
the choice is decided by a simple comparison between a random number at interaction tand a computed value t edt edt t wheredis defined as dt ql i c c ql i c c with c it and and are constants inherent to vdbe design.
despite the sophisticated formula here the dfunction reveals the simple philosophy behind vdbe.
it utilizes the difference of qof the last two rounds of results to guide the mab to make decisions.
classic mab solutions are known to enjoy strong guarantees on optimality known as asymptotic effectiveness .
vdbe is a widely used practical variant of mab for balancing exploration and exploitation.
3aeneas design aeneas is an application runtime co design which consists of a programming model section .
and runtime stochastic support sections .
.
.
.
.
aeneas programming model aeneas provides a simple and flexible programming model to help programmers customize their applications and the underlying stochastic energy optimizer.
to streamline our support for android the aeneas programming model is crystallized as a form of java apis.
as seen in listing a simple example using the apis shows a locationprovider dynamically adjusts its accuracy priority gpsprio and update interval gpsupdate in the presence of uncertainty of gps to meet a service level agreement sla of per hour battery drain rate.
three programming abstractions central to aeneas areknobs rewards and machines .
the three concepts are supported by library classes knob reward and aeneasmachine respectively.
knobs represent program elements where alternative values are allowed a recurring theme in application level energy aware and1 class locationprovider implements interactor aeneasmachine aeneas knob gpsprio new discreteknob new integer android.priority low power android.priority high accuracy knob gpsupdate new inferredknob new integer locationprovider aeneas new aeneasmachine new vbde new knob gpsupdate gpsprio new bratereward this void oninteract locationrequest req new locationrequest req.setupdate gpsupdate.read req.setpriority gpsprio.read requestlocationupdates req void start aeneas.start void stop aeneas.stop void resume aeneas.resume class bratereward extends reward float brate energyreward this .brate brate float valuate float e this .perinteractionenergy return this .batteryrate e float sla return brate listing an aeneas programming example approximate computing e.g.
.
in aeneas knobs may either be a declared discrete knob or an inferred knob .
the former indicates a small set of choices given by the programmer.
for example at line two android built in values for gps accuracy priority low power andpriority high accuracy are considered by the programmer as acceptable during the online optimization.
the discreteknob class a subclass of knob captures this notion.
the latter an inferred knob is used in scenarios when the programmer does not have a clear notion on the optimal setting leaving it to be decided by the runtime optimizer a case of inference.
inferred knobs are supported by another subclass of knob inferredknob .
for example at line the programmer indicates thegpsupdate field may be set at any value between ms and ms and be optionally provided with seed values such as ms and ms for the underlying stochastic optimizer to start the search.
an inferredknob object consists of values of numerical type.
knob objects have a read method which returns a value determined by the stochastic optimizer as seen in lines .
rewards can be viewed as programmer definable quality of service qos specifications which is in turn used by the underlying runtime to determine the desirable knob setting in stochastic optimization.
among its methods a subclass of reward class can override a method valuate to define how reward should be computed and a slamethod on what the goal of the optimal reward should be.
when both methods are provided the underlying optimizer attempts to operate the application so that the reward is as close to the defined sla as possible.
when the slais not overridden aeneas simply maximizes the reward.
the reward base class provides a default implementation that is equivalent as minimizing energy consumption.
as energy is a commonly used metric to define qos the reward also includes a utility method called perinteractionenergy to compute the energy consumption between two latest valuate method invocations and a utility method 705esec fse november lake buena vista fl usa anthony canino yu david liu and hidehiko masuhara algorithm aeneas discrete 1struct config 2 float reward 3 int local counter 5r float reward function 6t float sla target 7min int min interactions 8max int max interactions 9ct float converge threshold 10rate float interaction rate 11function maindiscrete k t 12c init k 13n c 14whilen maxdo i mab c interact c i k 17n n if n min convg c n break 19returnc 20function init k t 21foriin0.. k 1do 22c config interact c i k 24returnc 25function interact c config i int k t set k i oninteract timeelapsed rate update c 29function update c config 30c.
t r 31c.
c. 32function convg c config n int 33for all cincdo return true ifc.
n ct 35return falsealgorithm vdbe 1 float .
ks recommended by vdbe 2 float inverse sensitivity 3 float .
latest epsilon 4function mab c config 5ifrandomfloat then 6i randomint c 7else 8i q best c 9d q ql c .
10 ed ed 11return i 12function best c config 13i argminj .
.
c q c .
14return i q c .
15function q r float 16returnr ...r r 17function ql r float 18returnr ...r r 1algorithm aeneas inferred 1struct frame 2 t knobs 3 float best q value 4 t best knob setting 6it int interpolation density 7k0 t initial inferred knob 8s stack stack 9function maininferred 10k k 11while truedo 12c maindiscrete k i q best c ifq t0then 15k next frame k q k 16function next f frame 17f top s 18casef.
f .
boundary cross push s f 20k interp f. f .
21case f .
f. t0 tighten push s f i last f. first f. 24k interp f. i f. i 25otherwise widen f pop s 27k f. 28returnk 29function interp i j t 30i max min i j first k0 31j min max i j last k0 32k j i it 33return figure aeneas algorithm specification batteryrate to convert energy to battery life in the unit of percentage hour.
these base implementations rely on querying low level android battery management apis more details in section .
the reward design reflects the flexible extensibility and portability of aeneas api not only an end programmer may define customized qos energy metrics but also a framework level programmer may customize how battery should be accounted for when low level battery management solutions evolve from one smartphone to another by overriding methods such as perinteractionenergy .
either way the underlying stochastic optimizer remains unchanged.
finally an aeneasmachine may be created the programming abstraction for the stochastic optimizer itself.
each aeneasmachine may be customized by the mab strategy the available knobs and the reward.
one such machine can be seen at line .
the last argument of the aeneasmachine constructor is an object with interactor interface.
this interface consists of one method called oninteract the callback method for specifying application specific behavior each time an mab interaction is initiated as seen in line .
in addition our framework allows flexible lifecycle management of the aeneasmachine such as starting stopping restarting and resetting the optimizer start stop resume reset .
.
declared discrete knob runtime support the algorithm used by aeneas for runtime optimization is specified by algorithm .
the key data structure maintained at run time is config aconfiguration .
intuitively each configuration indicates a particular knob combination such as setting gpspriotoandroid.priority high accuracy and setting gpsupdate to .
this combination is indicated by the field of the configuration struct.
at run time each configuration is used for a number of interactions kept by counter .
for each interaction on the configuration a reward is stored in the array .
for simplicity the algorithm shows only one knob kwith ksnumber of settings.
in the presence of multiple knobs the number of the configurations is the cartesian product of all knob settings.
finally the ris the abstract representation of the valuate method defined by the user andtis the sla provided by the programmer.
the optimizer operates in its own thread and its algorithm is conceptually simple.
after a warm up procedure to make sure each configuration is at least attempted once init the algorithm henceforth alternates between inquiring the mab to select a configuration mab and performing an interaction based on the selected configuration interact .
within each interaction the runtime first sets the knob settings according to the selected configuration set calls the programmer defined callback method oninteract and updates the reward for the chosen configuration update .
the reward is computed as the difference between the latest reward returned byrand the specified by sla t. when sla is not provided tis defaulted at so the reward used for the update is the value computed by the r. we delay the discussion of timeelapsed until section .
.
since mab algorithms are diverse algorithm is abstract in its mab policy choice.
we provide a concrete vdbe based implementation of the mab function in algorithm .
for clarity we choose the same metavariables for this algorithm specification as 706stochastic energy optimization for mobile gps applications esec fse november lake buena vista fl usa those in section when applicable so the algorithm should be selfexplanatory.
note that q values can be computed incrementally the choice of aeneas but we do not define it here for simplicity.
we will delay the explanation of min max ct and the function ofconvg until next section.
as a standalone algorithm for declared discrete knobs minis set to be maxis set to be a largest constant ctis set to be .
.
inferred knob runtime support the algorithm used by aeneas for inferred knob optimization is specified by algorithm .
conceptually an inferred knob represents arange of possible knob combinations such as seconds to second for gpsupdate .
concretely an inferred knob exists as a set of iteratively updating discrete values within the user supplied range.
we represent an inferred knob s current set of discrete values with a frame that keeps a collection of values a reward sla associated with the frame and the best knob setting within the values .
we maintain a stack sof inferred knob values.
when working with real values we define a closeness relation twhere tis a user defined threshold for an acceptable precision analogous toequate in the programmer api.
the process of stochastic optimization for inferred knobs consists of a sequence of iterations .
each iteration is indeed a stochastic optimization for declared discrete knobs as indicated as the use ofmaindiscrete function in the algorithm.
unlike a bona fide declared discrete knob optimization where the optimizer may continuously and potentially infinitely perform interactions each iteration in an inferred knob optimization must terminate so that the next iteration may start.
this explains why the maindiscrete function definition consists of the minandmaxconstants to bound the minimum and maximum number of interactions to try in each iteration.
in addition the convg function computes a convergence ratio i.e.
the percentage of interactions of a particular configuration being used within the current iteration.
if it exceeds a threshold ct the iteration can also terminate intuitively indicating the stochastic optimizer has converged toward a particular configuration.
on the high level the algorithm connects iterations through iterative refinement .
after an iteration the inference algorithm selects the configuration closest to the sla best .
if it is not close enough algorithmically represented as the qvalue approximates defined by the trelation the optimizer starts a new iteration next .
it decides upon a new set of values by comparing the current frame fwith the previous frame f .
conceptually there are three cases boundary crossing fandf carry opposite rewards one above the sla and the other below the sla indicating the optimal values exist somewhere between the best values of the two frames.
we perform interpolation interp between the best knob settings represented by fandf .
tightening the reward produced by fis closer to the sla than that of f indicating fis the more desired choice.
we half the range of the inferred knob around the current setting represented by f interpolate a new set of settings within the range and lead to a new iteration exploring a tighter range.
widening the reward produced by fis further away to sla than f .
in this case we need to reverse the decision made by the previous iteration leading to a pop on the stack.
.
parameter selection and self optimization an important design issue in aeneas stochastic optimization is theinteraction rate i.e.
how frequent a new interaction should be triggered.
this is shown in algorithm as rate which determines the delay associated with firing update with timeelapsed as seen in the same algorithm.
intuitively a higher interaction rate may improve the adaptiveness of the optimization whereas the lower interaction rate may reduce overhead.
in the case of gps applications on mobile devices two additional thorny issues exist.
first there is a delay effect in updating the gps interval i.e.
setting a new gps interval on the google api level does not imply gps hardware will immediately take a new sample based on the new interval.
second fuel gauge on android devices we will discuss in section has its own rate for updates.
setting an interaction rate higher than the fuel gauge update rate implies reading the same value as the previous interaction.
with these hardware system level limitations an excessively high interaction rate would lead to erroneous results that the reward may not reflect the effect of the interaction it is intended to.
manually setting the interaction rate is a challenge.
a key insight of aeneas is that the interaction rate for our gps application can be determined by stochastic optimization itself .
the self optimizer performs inferred stochastic optimization with the interaction rate as the knob.
the algorithm is identical to the inferred knob algorithm we described in section .
with three exceptions.
i for each interaction the self optimizer adjusts rate based on the inferred knob.
ii the knob for the gps update interval is alternately set between the fastest interval and the slowest interval.
iii the reward is set as the power difference of the last two interactions in watts .
the intuition here is that if the delay effect we described earlier does not occur the design of ii above should lead to significant power difference of the last two interactions.
throughout our experiments we found the interaction rate is the most sensitive parameter of algorithm design which justifies the automated approach of self optimization.
for other parameters such as the vdbe s and as in algorithm we rely on settings recommended in existing literature.
note that our framework itself is fully extensible a programmer with a different parameter setting of vdbe can provide an alternative vdbe sub class.
4aeneas evaluation in this section we report our findings while experimenting aeneas in field i.e.
while being used in the real world use scenarios of driving biking and hiking.
this is a significant effort.
for driving alone we have covered roughly miles for early stage testing and exploratory data collection and miles to collect data reported in this section.
in total we have collected approximately hours of driving data over the duration of the project as well as hours of biking and hiking.
.
system setup experiments were performed on google nexus 5x android phones with qualcomm snapdragon processor at .
ghz 2gb ram 707esec fse november lake buena vista fl usa anthony canino yu david liu and hidehiko masuhara and android runtime art .
.
with android .
marshmellow os.maps.me release build .
.
utilizes android s gps through the locationservices google api.
accelerometer sensors and bluetooth are switched off and the phones are set at the do not disturb mode.
since display system is known to be a signifiant contributor to energy consumption in smartphones we choose to leave them onwith bright set to and auto adaptive brightness set to off.
this is a challenging base setting to start with.
in the following sections we will show that even when the display system is set to be fully in operation gps energy optimization remains relevant.
energy samples were collected using the phones internal fuelgauge chips whose battery voltage and current can be queried programmably through batterymanager api.
some experiments uses drain rate such as per hour as a form of reward specified by programmers.
to correlate drain rate with energy consumption we first start the phone at battery and run maps.me until android sends out a critical power warning this is done via the android.intent.action.battery low intent triggered at battery life.
we observed that between this range battery discharge is linear.
hence the energy consumption of a user provided drain rate such as can be computed proportionally.
.
experiment design we structure the evaluation of aeneas with types of experiments.
first and second we evaluate declared discrete knobs and inferred interval knobs an in field validation of algorithm and algorithm respectively detailed in the immediately following subsections.
third we compare our stochastic optimizer with non stochastic profile based optimization with experiments detailed in section .
.
fourth we report our results on self optimization in section .
.
finally we present overhead analysis in section .
.
we use a combination of three gps parameters as knobs.
gps update interval represents the frequency that updates are provided to the application from the gps hardware.
gps priority represents the power mode of the gps hardware.
gps maximum wait time represents the maximum additional wait time the application can tolerate once an update has been received.
this parameter allows for a form of batching where location updates are delayed beyond the specified update interval and delivered in a batch resulting in slower updates.
value difference based exploration is the default stochastic policy chosen for aeneas .
all experiments use .
seconds as the interaction rate.
we justify this choice in section .
.
we set vdbe s inverse sensitivity to .
for experiments with discrete knobs.
this causes less exploration and quicker convergence ideal properties when primarily using discrete knobs.
when running experiments with inferred knobs we set to .
which causes more exploration throughout the run.
for the inferred knob optimization we set min max and ctin the algorithm specification as and .
for driving experiments routes were selected that followed a 60mph speed limit as much as possible in a combination of urban and rural environment.2in all experiments of driving biking and hiking the maps.me application actively displays updated location information at all time.
2the details of the route information is available at our project site.
.
energy optimization with declared discrete knobs we first evaluate how aeneas targets a specified sla in the presence of alternative settings for multiple knobs based on the algorithm specified in algorithm .
we define reward to be the instantaneous battery drain rate in percentage drain per hour.
this was done by overriding aeneas default reward class as shown in section .
we perform the experiment targeting two slas and percent drain rate per hour hr .
we have knobs gps update interval with 10s .5s .5s .5s and 1s gps priority with low power and high accuracy and gps wait time with 5xand1x each with settings respectively.
in total there are 20configurations for the stochastic optimizer to choose from.
this creates a challenging and realistic case in that it may not be obvious to a programmer which of the configurations is the best.
indeed there may be multiple reasonable configurations that exhibit similar energy behavior.
results from representative runs are presented in figure .
in all experiments with different drain rate slas and with different modes of transportation aeneas demonstrates remarkable effectiveness and stability in converging on configurations that make best efforts to meet the specified sla.
in all figures the blue line accumulated average drain rate approaches the target drain rate sla as time proceeds.
observe that the rolling average i.e.
the most recent drain rate of the last interactions indicated by the green line may often lie far from the target sla in the beginning stage of each run however as more and more interactions are attempted aeneas intelligently selects configurations that get better and better resulting in the rolling average tending toward the target sla.
furthermore despite the stable trend indicated by the blue line and the green line the red line continues to fluctuate.
this line indicates the per sample drain rate.
the fluctuation results from two reasons.
first different configurations may be attempted at different interactions resulting in different instantaneous drain rate.
this is consistent with the stochastic design itself even after the initial warm up stage interactions the system continues to explore potentially sub optimal configurations but with less likelihood .
second uncertainty in instantaneous energy behavior is inherent so the drain rate may still fluctuate even in the presence of the same configuration.
this can be seen toward the end of each trace such as interactions where sub optimal explorations are significantly reduced yet the red line continues to fluctuate significantly.
as the blue green lines indicate aeneas operates successfully in this uncertain environment.
comparatively figure 3a and figure 3b show that hr experiments converge faster than the hr experiments.
this trend is similar across the different transportation modes.
this highlights the limitation of stochastic optimization based on declared discrete knobs fully provided by programmers.
after inspecting the traces we found that few among the configurations generated from the supplied knobs have energy profiles near hr sla but the optimizer must explore these configurations enough to find an ideal configuration.
this can be seen from observing the relatively low battery drain rate during the initial warm up phase of the hr run interactions and also time for additional exploration interactions .
approaching the end of each trace there remains a gap between the accumulated average and the target 708stochastic energy optimization for mobile gps applications esec fse november lake buena vista fl usa interactionsdrain rate hr run rate avg roll a drive hr sla interactionsdrain rate hr run rate avg roll b drive hr sla interactionsdrain rate hr run rate avg roll c bike hr sla interactionsdrain rate hr run rate avg roll d bike hr sla interactionsdrain rate hr run rate avg roll e hike hr sla interactionsdrain rate hr run rate avg roll f hike hr sla figure traces with declared discrete knobs.
each graph is a representative trace of a run lasting approximately hour.
the x axis represents the elapsed interactions.
the red line shows the instantaneous battery drain rate at each interaction the blue line shows the accumulated average battery drain rate of the run the green line shows the interaction rolling average battery drain rate.
the dotted horizontal line represents the target battery drain rate sla.
sla as a consequence of early sub optimal interactions.
here the rolling average line indicates in all hr experiments the rolling average of the drain rate is indeed converging toward the sla from around interaction onward.
taking these figures as a whole aeneas demonstrates consistent effectiveness in different transportation modes and different target slas.
in addition to these representative runs the left half of the columns of figure details statistics on all runs.
observe that the percentage of occurrences that the rolling average drain rate falls within hr of the target sla generally increases from the first quarter of the experiment to the final quarter reflecting the intuition that the aeneas learning algorithm incrementally finds more optimal configurations as time goes on.
we report traces from other runs at the project website.
one challenging case is perhaps biking with sla target of hr.
in our experience we found it difficult to construct a one hour bike ride without frequent stops and interruptions as opposed to driving.
in addition biking does cover a relatively large area with significant gps signal variations as opposed to hiking.
in essence biking compounds the uncertainty from both driving and hiking.
this is evidenced by the relatively large variance between energyreadings as seen in figure 3d.
in addition the relatively low number ofdiscrete configurations that have energy profiles friendly for the target hr sla poses a challenge for our experiment.
as we shall see in section .
this last challenge is overcome when aeneas works with inferred knobs leading to improved results for hr biking.
.
energy optimization with inferred interval next we evaluate how aeneas infers unknown knob settings that target a programmer defined sla in the presence of uncertainty following the algorithm specified by algorithm .
we define an inferred knob for gps update interval with initial range of 10s to 1s with interpolation points resulting in 10s .5s 5s .5s and 1s for the initial set of intervals and fix gps priority and gps maximum wait time to high accuracy and1xrespectively.
reward and sla are as defined in section .
.
results from representative runs are presented in figure .
for all experiments the accumulated average drain rate the blue line tends toward the target sla as aeneas performs iterations of inference.
each iteration ends with a set of more refined intervals .
tightening and boundary crossing which refine an inferred knob 709esec fse november lake buena vista fl usa anthony canino yu david liu and hidehiko masuhara declared discrete inferred accumulated roll q1 q2 q3 q4 accumulated roll q1 q2 q3 q4 drive .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bike .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
hike .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
drive .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bike .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
hike .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure declared discrete and inferred interval experiment statistics we show the mean and deviation of accumulated and roll for all runs.
in addition we show the percentage of times that roll was within hr of the target sla for four quarters of the experiment runtime q1 q4 .
a drive hr sla b drive hr sla c bike hr sla d bike hr sla e hike hr sla f hike hr sla figure traces with inferred knobs.
the blue green red and yellow labeled boxes indicate iterations where tightening widening boundary crossing and warmup were performed respectively.
all other legends are identical to those in figure .
towards an often smaller and more specific range of settings occur more frequently than widening.
we can see the rolling average the green line stabilizes throughout the iterations of inference.
this is good news for programmers who are unsure about the behavior of their application they can simply provide suggestions in the form of inferred knobs and let the aeneas inference algorithm discover ideal settings.
of particular interest is how the aeneas inference algorithm adapts to uncertainty.
for example when driving with hr sla figure 5a instantaneous drain rate experiences significant fluctuation leading to sub optimal results after the initial iteration oftightening.
consequently the optimizer widened in the next iteration to reach a more stable state.
the final iteration of tightening leads to a more refined set of intervals finishing with a running average of .
hr.
additionally we can see a similar pattern when biking targeting hr sla figure 5d .
observe the initial shift in rolling average after a boundary cross was performed.
as the new set of intervals stabilize a final iteration of tightening brings the average rate to .
hr.
in both cases aeneas adaptively adjusts to the environment and stabilizes around the desirable sla.
the right half of the columns of figure details statistics on all runs.
we report traces from other runs at the project website.
710stochastic energy optimization for mobile gps applications esec fse november lake buena vista fl usa vdbe .
profile profile profile policydrain rate hr figure stochastic vs non stochastic approaches each bar represents a single drive that lasts for approximately hour interactions .
the y axis shows the percent battery drain rate per hour of the run.
the dotted horizontal bar represents the targeted hr sla.
interactionsdrain rate hr run rate avg roll a profile run interactionsdrain rate hr run rate avg roll b profile run figure profile guided optimization traces.
figure a is trace from the 4th run of profile in figure .
figure b is trace from the 1st run of profile in figure .
all other legends are identical to figure .
.
stochastic vs. non stochastic approaches in this section we compare aeneas stochastic optimizer with a non stochastic approach profile guided optimization.
in this latter approach each configuration is chosen for a fixed number of times after which the execution commits to the configuration with the best average reward.
we use profile x to indicate a profile guided run where each configuration is chosen for x number of times.
we use the same knob and reward settings as done in section .
.
figure shows the results of targeting an sla of hr drain rate.
our results show the main drawback of profile guided optimization is its instability .
its effectiveness is dependent on how representative the profiled runs are.
when the level of uncertainty is high profile guided optimization can make a poor choice that make a large impact for the rest of the run.
in general profileguided optimization becomes more stable as the number of samples .
.
.
.
interactionspower difference w run r1 .
r2 .
r3 .
r4 35figure self optimization.
we show the last interactions after the convergence has been reached by the inferred knob algorithm.
each point represents the observed power difference reward between 10s and 1s gps update interval configurations.
run are labeled with the interaction rate converged on by the algorithm.
drawn increase.
profile runs have a narrower range of difference .
hr .
hr than profile .
hr .
hr .
due to its shorter sampling period when profile makes a poor choice as is the case for the 4th run for profile the penalty is severe.
while profile is more stable there is an inherent cost of increasing the sampling for profile guided optimization it samples times requiring minutes before making a choice.
in contrast aeneas only needs to sample each configuration once in the warm up stage behaving like profile in the first interactions but then subsequently relies on stochastic exploration to mitigate potentially unreliable samples in the warm up stage.
as a result vdbe .
has the narrowest range .
hr .
hr compared with all profile guided runs demonstrating stability.
to zero in on the detailed behavior of profile guided optimization figure shows the traces of two representative runs the fourth run of profile and the first run of profile .
in the first case the run unfortunately picked a sub optimal configuration after the sample per configuration profiling and can no longer recover for the rest of the run.
in the second case the run did choose a relatively reward optimal configuration but that only happened after interactions.
the rest of the run does indeed have favorable rolling average drain rate but it may take a long time for the rest of the run to compensate for the significant sub optimal battery drain during the profiling stage.
.
aeneas self optimization in section .
we mentioned that we set the aeneas interaction rate to .
seconds per interaction.
this value is neither hard coded nor heuristics based instead we computed it through our self optimizer described in section .
.
in that experiment we alternate between 10s and 1s as the slowest and fastest update interval respectively.
results from representative runs are presented in figure .
the self optimizer converges on .
seconds per interaction as the interaction rate for r1 r2 and r3 and seconds for r4.
among all runs nearly all converged on a value between .
seconds and seconds.
we hence set the .
seconds as the default setting for interaction rate for the experiments.
711esec fse november lake buena vista fl usa anthony canino yu david liu and hidehiko masuhara .
aeneas overhead overhead introduced from aeneas comes from knob configuration and mab bookkeeping i.e the maintenance of metadata for each configuration accumulated reward and knob profiles as well as running the selected mab algorithms and aeneas thread management.
we measure the cost of running aeneas in terms of additional energy overhead by comparing against a baseline native maps.me with the knobs relevant to our experiments gps update interval gps priority and gps wait time set to 500ms high power and 1x.
the aeneas run performs all bookkeeping and stochastic optimization but is forced to select the same configuration as the native maps.me one after each interaction.
we repeated the experiment times.
the mean energy consumption of the native runs is j with a relative standard deviation of .
and the mean energy consumption of the aeneas runs is j with a relative standard deviation of .
.
aeneas incurs an average additional .
j representing .
energy overhead.
related work powerdial is a dynamic adaptation framework for power optimization.
built with a control theoretic core powerdial allows a number of system knobs dynamic voltage and frequency scaling dvfs and server consolidation in particular to be dynamically adjusted to balance the trade off between performance and quality of service qos .
jouleguard employs a two tier optimization approach where system level energy optimization such as through dvfs can be maintained by mab with which the application level approximations can be coordinated through a powerdial like algorithm.
jouleguard is interesting for its formal control theoretic guarantees well suited for co optimization problems where the boundary between the application and the system is well carved.
in our interested problem domain gps applications it is a challenge to differentiate the two.
for example gps update intervals are set by programmers and may be adjusted within the google locationservices apis.
it is unclear whether this is an application knob or system knob.
from this perspective aeneas explores a different perhaps complementary non hierarchical path where application knobs and system knobs if any are unified through mab.
desirable properties of energy optimization such as adaptiveness convergence and stability thus go hands in hands with the mab algorithm core.
from a practical perspective this unified approach avoids the need for reconciling and tuning two adaptive approaches both mab and control come with algorithm level parameters significantly simplifies deployment.
a few application level frameworks especially in the form of programming models exist to support uncertainty.
in uncertain t programming abstractions are provided so that program values may carry types that indicate data results may be uncertain and the programming language provides a bayesian network semantics to ensure values of such types are correctly flown in the program.
aeneas may complement uncertain t by providing online adaptive support for modeling the level e.g.
distribution of uncertainty without prior knowledge before program execution and the reasoning framework of uncertain t may provide feedback to aeneas to correlate the knobs used by mab.
this complementary relationship may also apply to rely and chisel two programming languages where program types may include areliability specification capturing how the values may be located on underlying unreliable hardware.
there are a number of other programming and annotation frameworks to support energy aware programming such as eon green enerj energy types lab eco ent and ape .
most of these frameworks facilitate adaptive energy management.
for example ent allows programmers to specify mode alternative behavior through a programming abstraction called mode cases an ape programmer may annotate programs with policies managed by timed automata.
a large body of work establishes the complex and dynamic nature of energy behavior in modern applications .
none of these approaches directly address uncertainty and aeneas may serve as an underlying framework for them to model uncertainty and guide the semantics driven program runtimes to make judicious choices among programmer defined alternatives.
mab algorithms can be broadly viewed as a form of reinforcement learning rl .
the dilemma between exploration and exploitation is a classic problem in rl and one of the most classic rl algorithms q learning involves iterative value update of a value function a similar process as mab algorithms.
indeed we presented the mab model in section in a recurrent q update form to show this connection.
rl has been used on the cpu level energy optimization for optimal dvfs voltage frequency selection .
a temporal difference learning method coupled with bayesian classification is designed for balancing power and latency in storage network systems.
rl has also recently been used to guide resource consolidation in cloud computing and data center optimization .
none of these efforts is focused on higher layers of the computing stack such as how application level energy management should be supported and how the interface between the application and the runtime should be streamlined in the presence of uncertainty.
aeneas is also distinctive in its domain a systematic study on energy optimization in the presence of uncertainty in mobile transportation systems.
gps energy consumption has long been recognized as significantly impacting battery life of mobile devices with a large body of solutions.
for example a loc presents a bayesian estimation framework to model user location and sensing errors.
location sensing requests may also be optimized such as substituted or suppressed .
gps optimization may also take into account of context information such as space and temporal data .
conclusion aeneas is an application level energy optimization framework with a simple programming model and a sophisticated stochastic runtime optimizer.
aeneas has been extensively evaluated in the context of gps applications through significant in field validation involving driving biking and hiking.
aeneas is an open source project.
the source code of our framework all raw data collected for our experiments and additional trace graphs omitted from the paper can be found at the project website.