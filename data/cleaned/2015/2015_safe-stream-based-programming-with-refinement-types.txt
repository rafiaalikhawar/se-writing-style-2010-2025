safe stream based programming with refinement types benno stein university of colorado boulder boulder colorado usa benno.stein colorado.edulazaro clapp uber technologies inc. san francisco california usa lazaro uber.com manu sridharan uber technologies inc. san francisco california usa msridhar uber.combor yuh evan chang university of colorado boulder boulder colorado usa evan.chang colorado.edu abstract in stream based programming data sources are abstracted as a stream of values that can be manipulated via callback functions.stream based programming is exploding in popularity as it providesapowerfulandexpressiveparadigmforhandlingasynchronous data sources in interactive software.
however high levelstream abstractions can also make it difficult for developers to reasonaboutcontrol anddata flowrelationshipsintheirprograms.
this is particularly impactful when asynchronous stream based code interacts with thread limited features such as ui frameworks that restrict ui access to a single thread since the threading behav ior of streaming constructs is often non intuitive and insufficiently documented.
inthispaper wepresentatype basedapproachthatcanstatically prove the thread safety of ui accesses in stream based software.
our key insight is that the fluent apis of stream processing frameworksenablethetrackingofthreadsviatype refinement making it possible to reason automatically about what thread a piece of code runs on a difficult problem in general.
we implement the system as an annotation based java typechecker for android programs built upon the popular reactivex framework and evaluate its efficacy by annotating and analyzing open source apps where wefind instancesof unsafeui access whileincurringanannotationburdenofonlyoneannotationper 186sourcelinesofcode.wealsoreportonourexperienceapplying the typechecker to two much larger apps from the uber technologies inc.codebase whereitcurrentlyrunsoneverycodechange and blocks changes that introduce potential threading bugs.
ccs concepts software and its engineering software notations and tools formal software verification keywords stream based programming refinement types mobile applications permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
reference format bennostein lazaroclapp manusridharan andbor yuhevanchang.
.
safe stream based programming with refinement types.
in proceedings of the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm new york ny usa 12pages.
introduction manypopularuserinterfaceframeworks e.g.
swing cocoa eclipse ios android distinguishasinglemainthreadfromwhichallui accesses must be performed .
this design is preferred by library developers since it eliminates the need for libraryinternal synchronization there is no need to worry about data racesordeadlockwhenonlyonethreadisallowedtoperformui operations.
however the single ui thread model requires application developers to carefully avoid interacting with the ui from other threads since so results in a runtime crash or undefined behavior.
suchinvalidthreadaccess bugsareverycommoninpractice a google search for android s calledfromwrongthreadexception one of several exceptions that android can throw when the ui is accessed improperly yields over47 results including numerous githubbugreports stackoverflowquestions anddeveloperguides and tutorials.
furthermore invalidthreadaccessesaredifficulttodetectand debuginpractice.existinguitestingtechniquesareoftenunable to achieve adequate coverage of possible ui interaction traces and struggle with bugs that only manifest on certain devices in the diverse android hardware and software ecosystem .
program analysis approaches to finding improperly threaded ui accessesaresimilarlyinadequate thecallgraph reachabilitytechnique proposed by zhang et al.
and the effect type system ofgordonetal.
bothidentifymethodsthatinteractwiththe uieffectivelybutusea veryconservativeandrestrictivemodelto determine when those methods run on the ui thread on the other hand generalapproachestoconcurrencyanalysistypicallyfocus onsharedmemoryaccessratherthandeterminingthethreadon which a given piece of code will run .
in recent years there has been an explosion in popularity of stream basedprogramming frameworkslikereactiveextensions especiallyforinteractivesoftwarelikeandroidapplications thatneedtorespondtouserinputinrealtime.suchframeworks provide expressiveand convenientthreading abstractionsfor manipulatingstreamsofdataandcomputation butofferlittleinthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france benno stein lazaro clapp manu sridharan and bor yuh evan chang wayoftoolsupporttohelpdevelopersavoidinvaliduiaccessby reasoning about what thread a stream is running on.
weproposeinthispaperarefinementtype basedstaticanalysis thatidentifiespossibleinvalidthreaduiaccessesinstream based android applications combining an effect type system that tracks thepossibleuiinteractionsperformedbymethodswithathread type system that encodes the possible threading behaviors of asynchronous data streams.
our approach not only detects or proves the absence of improper ui access but also helps developers understand and reason aboutuiinteractionsintheircode.furthermore ourannotationbasedapproachmakesthatreasoningexplicitandself documenting allowing future contributors to more easily understand modify or extend previously annotated code.
ourtypecheckercurrentlyrunsoneverycommitmadetotwo majorandroidapplicationsatubertechnologies inc. uber blocking any changes that may introduce invalid thread access bugs.
in practice we have found that the typechecker catches potential bugs earlierin the development processand more efficiently than existing testing and manual code review are able to.
we build on the insights of gordon et al.
who first showed theapplicability ofeffect typing tomodern uiframeworks witha distinguisheduithread byextendingtheirworkintwokeydimensions.
first we introduce a thread type system for determining the threadonwhichstreamoperatorsexecute.combiningthethread typesystemwiththeeffecttypingofgordonetal.enablesverifyinguieffectsafetyforawiderclassofthreadingconstructs with almost no additional annotation burden for developers.
second we develop an effect inference technique for callbacks and lambda abstractions that further lowers the annotation burden of ui effect typing and improves code readability.
contributions the primary contributions of our work are as follows we introduce anovel refinement type systemthat soundly verifies that stream processing code only accesses the ui fromstreamsrunningontheandroidmainthread.wedemonstrate its efficacy by implementing a static annotation based type checker for android applications built upon the re activex java stream based programming framework.
our systemstaticallyrefinesthetypesofcallbacksandlambda abstractions by the effectsthey may incur and data event streams by the threadson which they may run then verifies thatnon uithreadstreamsnevercallmethodswithuieffect.
we analyze a corpus of open source android applications as well as two large closed source applications developedatuber.in a improperuiaccessis detectablebyourtoolandprevalentinbothopen sourceand closed sourcecodebasesand b annotationburdenonthe programmerislowenoughforthetooltobeincorporated intoaproductiondeveloperworkflow.intotal wefind33in stancesofui effectfulcallbacksrunningonnon ui threaded streamsintheopen sourcecorpus.atuberourtoolrunson everycode changeas partofcontinuous integration blocking any change that may introduce stream based threading bugs.
overview inthissection weprovidebackgroundinformationaboutstreambasedprogrammingframeworks theandroiduimodel andrefinement typechecking by applying our tool to a simple example from a user s perspective.
.
reactive extensions reactive extensions reactivex is a multi language framework for asynchronous stream based programming which allows developerstoeasilywritecodethatoperatesoverstreamsofevents or data composing and transforming them with various functional operators and subscribing callbacks to perform computations in response to events.
stream processing frameworks have gained popularity in recent years due to their ability to provide a uniform interface to multiple asynchronous inputsources allowing developers tobuild responsive interactive applications and easily interoperate via the stream api with new frameworks and technologies.
stream based programming also encourages a functional programming paradigm preferring composable modular computations to imperative procedures over mutable state.
a typical use case of reactivex is to receive or generate an observable stream performanumberofoperationsthatmodifyits dataorthread andthensubscribean observer orothercallbacklike object to asynchronously consume the resulting event stream.
thisso called fluent interface inwhichmultiplecallsarechained together isahallmarkofthestream basedprogrammingparadigm combining ideas from the observer pattern the iterator pattern and functional programming .
take for example the code snippet in fig.
which updates car locations on a map using the reactivex framework.
the carlocationdata stream represents location data for some set of cars updated periodically by a remote server.
the filteroperator filtersthestreamtoincludeonlycarscurrentlywithoutapassenger.
then observeon moves subsequent operations to themain thread a requirement for performing ui updates on android.
the delay operatorintroducesadelaybeforeeachlocationupdate toallow for other processing to complete.
finally the anonymous function passed to subscribe invokes ui apis to display the cars in the map.
a key feature of the reactivex fluent interface is that each operationinachainofcallsreturnsanew observable instancerather thanperformingsideeffectsonthereceiverofthecall.thissideeffect free nature of reactivex enables a type based analysis since eachintermediate observable instanceinthecallchaincanbegiven asinglestatictypethatisnotsubjecttochangelaterinthechain.
note that reactivex s api is distinct from the builder pattern whichsupportsasimilarcall chainingsyntaxbutdoesperformside effectswitheachcall passingthesamebuilderinstancethrough the chain.
though fig.
s example makes use of only a few simple stream operators reactivexprovidesawiderange fromfunctionalprogrammingstandardslike filter emitonlythosedatathatsatisfy a given predicate to more exotic combinators like switchmap map incoming data to new streams emitting events only from the most recent datum s stream .
streams i.e.
observable s possess such authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
safe stream based programming with refinement types ase september montpellier france observable ... carlocationdata ... carlocationdata .filter car car has no passenger .observeon andro idschedulers.mainthread .delay timeunit.milliseconds .subscribe car display car on map err render error message figure simple example usage of reactivex observable streams.
contains the distillation of a threading bug that was detected by our tool and fixed as explained in section2.
.
operatorsinreactivexjavaversion2.
.
inadditiontoanycustomoperatorsdefinedbythirdpartylibrariesormorespecialized types of streams.
with the expressivity of such a large and complex framework inevitably comes a steep learning curve since it is difficult for developerstobecomefamiliarwiththeapi.thiscontributestothe preponderance of threading bugs in real world applications using reactivex.inourexperiments wefindthatmanyprogramscontain latent threading bugs that require a nuanced understanding of the framework to detect.
the program in fig.
for example looks safe from improper ui access at first glance its author was careful to observeon the android main thread before subscribing a callback that renders ui elements and error messages.
howev er due to the threading behaviorofthe delayoperator theprogramactuallyaccessesthe ui from a background thread.
.
refinement typechecking inspiteof theintractabilityofdeterminingwhatthread apieceof codewillrunoningeneral stream basedframeworkslikereactive extensions are amenable to thread analysis by means of refinement types .
as discussed in the previous section the fluent functional interface of reactivex streams is the key feature which enables the use of a type based approach to track the thread of intermediatecallsinthechain obviatingtheneedformoreexpensive general purpose thread analyses.
informally arefinementtypesystemcanbethoughtofasaugmentingbase types e.g.
integers lists strings by qualifiers that further restrict the values of the base type e.g.
positiveintegers nonempty lists asciistrings .refinementsubtypingholdswhen bothbasesubtypingandqualifiersubtypinghold andstandardintuitionsaboutnominalsubtypingoverbasetypesbehaveanalogously for refined types1.
inthispaper weverifythesafetyofuiaccessinstream based androidprogramsusingtwoseparatebutparalleltyperefinements.
first werefinethetypesofallmethodsandcallback likeobjects withaneffectqualifier fromfig.
whichplacesanupperboundon thesideeffectstheymayincur asingordonetal.
.wesaya methodis ui effectful whenitmayaccesstheuiandisannotated with uieffect .
1namely refinement subtyping is reflexive and transitive and the liskov substitution principle holds for refined types.
uieffect safeeffect figure qualifier hierarchy for effect type refinements.
anythread compthread uithread bottomthread figure qualifier hierarchy for thread type refinements.
next we refine the types of all data streams with a thread qualifierfrom fig.
which places an upper bound on the thread on whichtheymayemitevents.ifsuchathreadcannotbedetermined statically thestreamwillhavethetrivial anythread qualifier which does not restrict the base type at all.
inbothcases wetakecaretominimizeannotationburdenusing sensible default qualifiers shorthands to annotate entire classes or packages and type inference to determine qualifiers where they are implied.
finally wetypechecktheprogram confirmingthatallassignments returnvalues andfunctionargumentsrespecttheirdeclaredtypes ui effectfulmethodsarenevercalledfromsafe effectfulmethods andui effectful callbacksaresubscribedonlytoui threaded streams.
otherwise we report warnings to the developer where these conditions are not met.
a more precise and formal treatment of the refinement type systemweinstantiatecanbefoundinsection .fornow wewillbuild intuition byapplying ourrefinement typecheckerto theprogram in fig.
.
when a developer tries to compile the program in fig.
our compiler issues the following error at the subscribe callsite error subscribing a callback with uieffect to an observable scheduled on compthread uieffect effects are limited to uithread observables thiserrorindicatesapotentialthreadingerrorintheprogram the callbacks being passed to subscribe can touch the ui but they are being subscribed to a observable scheduled on a background computation thread.
the reason for this error is that delayautomatically returns a streamrunningonabackgroundcomputationthread.thus even thoughthe developerused observeon toforce thestream ontothe main thread before subscribing ui effectful callbacks the intermediatecallto delaypromptlymovedittoacomputationthread.in practice wefoundthatevenexpertdeveloperswereoftenunaware ofthis delaybehavior documentationofwhichislimitedtoashort note buried deep in a large generated documentation file.
however our typechecker refines the types of each program value anythread fortheinitial carlocationdata stream anythread for the result of filter uithread for the result of observeon compthread for the result of delay and uieffect for the lambda expressions passed to subscribe .
thus our typechecker is able authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france benno stein lazaro clapp manu sridharan and bor yuh evan chang to identify the bug subscription of a uieffect function onto a compthread stream and issues the error reproduced above.
thefixtothisissue oncethedeveloperhasbeenmadeawareof it by the typechecker is simple and requires no annotations swap the positions of the delayand observeon calls and the code will typecheck and compile without error.
thread effect semantics this section details the thread semantics of the android ui frameworkandthereactivexthreadingmodelandformalizesthethread andeffecttypesystemsweusetoanalyzereactivex basedandroid applications.
recall that the android ui toolkit is not thread safe and adheres toasinglethreadmodel assuch anycodethataccessesuicomponentsmustdo so from the ui thread .
this is a relatively standardmodelforotheruiframeworks includingiosaswellas java s swing swt and awt .
existing work has established effect types as a useful abstraction fordeveloperstoavoidviolatingthissingle threadassumption .
however such work is limited to relatively simple threading models where the library provides an interface to the ui thread for coderunningelsewhere forexample theeclipseswtuiframework defines a function with signature static void asyncexec runnable r whichallowsadevelopertopasssomeui effectfulcode rtoberun on the ui thread.
whileandroiddoesprovideanalogousfunctions e.g.
activity runonuithread view post thatcanbeanalyzedbyexistingeffecttypingtechniques italsoprovidesmoreexpressivefunctionsbe yond their reach e.g.
asynctask handler .
in addition reactive extensions threading constructsintroduceeven morecomplexity and require new techniques to be analyzed properly.
.
effects the applicationof effect type systemsto ui frameworksis a fairly well understood technique functions are annotated with effect qualifiers which canthen be checked to verifythat the annotated function does not perform any effects not permitted by its annotation.oureffectsystembuildsontopofthatofgordonetal.
whereinfunctionshaveoneoftwoeffectannotations uieffect denotingamethodthatmay ormaynot interactwiththeui or safeeffect denotingamethodthatisguaranteednottotouchthe ui2.
thesub effectingrelation precedesequalisgivenby safeeffect precedesequal uieffect andthetworeflexiverelationships safeeffect precedesequal safeeffect and uieffect precedesequal uieffect .
that is a method with safe effect can be used in place of a method with ui effect but not vice versa.
we say that aprogram is effect safe when its effect annotations over approximateallpossibleeffectsperformedatruntime thus in an effect safe program a method annotated safeeffect is guaranteed never to interact with the ui.
checking effect safety of a programwhosemethodsareannotatedbytheireffectreducesto checking the following two conditions transitivity a method with effect annotation emay only call a method with effect annotation e primeife prime precedesequale.
2note that this ignores polymorphic qualifiers which will be detailed in section .
.class a uieffect void foo ... safeeffect void bar ... class b extends a transitivity violation safeeffect void baz foo inheritance violation uieffect void bar ... figure4 exampleviolationsoftheeffecttypesystem.
b baz violatesthetransitivityconditionbecauseitisannotatedas safe but calls a ui effectful method a foo while b barviolates the inheritance condition because it manipulates theui but overrides a method declared to be safe.
inheritance a method with effect annotation emay only override a method with effect annotation e primeife precedesequale prime.
inotherwords the transitivity conditionstatesthatsafemethods cannot call ui methods while the inheritance condition states that methodscannothaveuieffectiftheyoverrideasafemethod.assumingthatui effectfullibrarymethodsareannotatedaccordingly proving these two conditions suffices to show that the ui is only accessedfrommethodsannotatedwith uieffect .figure4provides concrete examples of effect safety violations.
the reader may find it useful to think of these two conditions in terms of reachability in a directed graph whose vertices aremethods with edges from callers to callees and from superclass methods tooverriding subclass methods.in such agraph an edge from a method with effect eto a method with effect e primeviolates one of the above conditions when e e prime.
the task of applying effect types to an android application is thus equivalent to determining the region of nodes from which android ui methods are reachable that region has ui effect while its complement has safe effect.
other than the lambda support and inference mechanism described in section .
this effect type system is identical to that of gordon et al.
.
.
threads thethreadingbehaviorofandroidapplicationsthatmakeuseof stream basedprogramming frameworkslikereactiveextensions isdeterminednotonlybyasmallsetofandroidapimethodswith fixed semantics but also by a wide range of stream operators with dynamic threading behavior.
effect typing alone is therefore insufficient to properly verify the ui thread safety of such applications.
consider forexample the subscribe methodof observable which is called on a stream in order to register some callback to be executed whenever an event is emitted by the receiver stream.
in contrast to android s runonuithread which can safely be passed a ui effectful callback in all contexts subscribe can only be passed a ui effectful callback obswhen the receiver stream is running on the ui thread.
inordertoexpressthatinvariant ananalysismustreasonnot only about the effects of methods but also the threads on whichstreams emit events and by extension execute subscribed callbacks .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
safe stream based programming with refinement types ase september montpellier france tothatend weaugmentourtypesystemwithtypeannotations that refine stream types by their thread.
these type annotations aredrawnfromthequalifierhierarchygiveninfig.
.thetopof the qualifier hierarchy anythread denotes a stream that can emit events on any thread uithread and compthread denote streams thatcanemiteventsonlyontheuithreadorabackgroundcomputation thread respectively bottomthread denotes a stream that cannotemiteventsonanythread.thisbottomtypeisneverwritten byaprogrammerbutisusedwithinthetypecheckerforthe null value dead code and wildcard lower bounds .
annotating stream operators with thread type refinements allowsatypecheckertoreasonaboutthethreadingbehaviorofthose constructs.
for example the thread semantics of the delayfunction used in the motivating example in fig.
1can be specified by annotating its receiver anythread and its return type compthread .
combiningthreadrefinementtypesforstreamswitheffectrefinementtypesformethodsisthekeyideathatallowsourtypechecker to verify ui thread safety of stream based android applications by checking that subscription of ui effectful callbacks only occurs on ui threaded streams.
.
qualifier polymorphism some design patterns particularly those designed for modularity and reusability have effect and thread behavior that cannot be expressed by a single type signature with fixed refinements.
in these cases we make use of qualifier polymorphism.
qualifierpolymorphismisaformof parametricpolymorphism whichalsounderliesgenericsinjavaandc anduniversallyquantifiedtypesinhaskellandocaml.consider forexample thismethod from the java collections library which creates a singleton set set t singleton t obj ... the generic type variable tmay be instantiated as any single java object type constraining the element type of the returned set to be the same as the argument type.
similarly qualifier polymorphism uses a generic refinement variableto relatetyperefinementsratherthanexplicitlyannotating types with a fixed qualifier.
we define a polythread resp.
polyuieffect qualifierthatmaybeinstantiatedasanyconcrete thread resp.
effect qualifier constraining the refinements on multiple types to be the same3.
qualifier polymorphism is well suited to several design patterns instream basedandroidapplications severalexamplesofwhich are selected and reproduced in figure .
the callback interfaceexhibitseffectpolymorphism weusethe polymorphicqualifiers polyuitype and polyuieffect toenforce thata callback instancehasauiannotationwhenits handlemessage method has ui effect.
similar interfaces such as runnable action and observer are annotated analogously relating the refinement type of the callback like object to the effect of its implemented method s .
3implicitly aclassormethodwithpolymorphicqualifierannotationsisparameterized byasinglerefinementtypevariablewhichis usedwhereverthe polymorphicqualifier iswritten.assuch itisimpossibletoparameterizeadefinitionbymultiplerefinement typevariables butwehavenotfoundanyanycodepatternsinpracticewheresuch atypeisrequired.thispolymorphicqualifiersyntaxisdefinedandprovidedbythe checker framework .
polyuitype interface callback polyuieffect boolean handlemessage message m class observable t polythread observable t take polythread observable t this int k ... polythread observable t observeon polythread scheduler thread ... figure5 examplesofthread andeffect polymorphictypes drawn from reactive extensions io.reactivex.observable and android s android.os.handler respectively.
methods that take callback instances with ui effect versions of handlemessage willneedtodeclarethecorrespondingformalparameteras ui callback.methodsthatdonotcareaboutthecallback s effecttake polyui callback instances.ourtooldefaultstointerpretingunannotatedformalsofapolymorphictypeas alwayssafe non uiaffecting instances.analogouslogicappliestothetypes of fields and locals.
the observable class themainstreamdatatypeinreactivex exhibits two distinct forms of thread polymorphism.
first most of itsmethods e.g.
takeinfig.
donotaffectthethreadofthestream they operate on we express this behavior by constraining their receiver4andreturnvaluestohavethesamethreadrefinementwith the polythread qualifier.
second we use thread polymorphism to express the dependently typed behavior of the observeon operator whichtakesa scheduler e.g.
athreadpool andreturnsastream emitting events on that thread pool.
in order to do so we overload the meaning of our thread qualifiers to apply to schedulers as well as streams and annotate the scheduler and the returned stream of observeon with the polythread qualifier.
qualifier polymorphism introduces some additional complexity tothedefinitionofeffect safetygiveninsection .
.theinteraction between polymorphic and concrete effects is fairly straightforward wehave safeeffect precedesequal polyuieffect and polyuieffect precedesequal uieffect since those relations would hold for whatever concreteeffect polyuieffect takeson.thatis thebodyofaneffectpolymorphic method can call any method with safe effect but isforbidden from calling ui effectful methods.
on the other hand the body of an effect polymorphic method may only call othereffect polymorphic methods when they share the same receiver object sincearbitraryothereffect polymorphicmethodsmaybe instantiated with an incompatible concrete effect.
.
lambdas and qualifier inference thecallbacksusedinstreamprocessingframeworkslikereactivex aretypicallywrittenaseitheranonymousinnerclassesorjava8 lambda expressions.
when a callback is passed to a method whose formal parameter is annotated with a particular effect qualifier the anonymousclassorlambdamustitselfhaveacompatibletypequalifier.inthecaseofanonymousinnerclassesthiscanbeachievedby 4the receiver thisis explicitly written and annotated as the first argument to the method asperjava stypeannotationspecification thisdoesnotaffectthesemantics of the function whatsoever .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france benno stein lazaro clapp manu sridharan and bor yuh evan chang library annotation stubs java sourcesrx thread effect checkerjavac type qualifier hierarchies custom typing rules implicit type factoryexecutable list of alarms figure typechecker infrastructure diagram showing its internalcomponents inputsandoutputs.fromauser sper spective uithread safetycheckingisintegratedseamlessly with other javaccompile time checks in this default configuration butitisalsopossible bymeansofacommand lineoption torunthecheckerasastandaloneprocess emittingasuccessmessageinsteadofgeneratinganexecutablewhenthe program is deemed safe.
using a type use annotation e.g.
new ui consumer ... to specify a consumer whose acceptmethod has uieffect .
however the syntax of java lambda expressions does not permit any explicittype annotations refinement or otherwise .
rather their type is resolved through type inference.
consider for example the java type of thelambda expression passed as the first argument to observable subscribe in figure car display car on map the first formal parameter of observable subscribe has type polyui consumer so thecompilerinfers that consumer isthefunctionalinterface5basetypeofthelambda.duringcompilation javac will convert any lambda expression to an anonymous instantiation of a compatible functional interface inferring its base type from the context.
however the base type inference mechanism does not apply to refinement type qualifiers.
instead we apply local type qualifier inferencetocomputethepropereffectannotationwithwhichtoinstantiate the polyuipolymorphic qualifier by inspecting the body ofthelambdaexpression.ifacalltoamethodwith uieffect effect isfoundwithinthebodyofthelambda wemarkthecorresponding anonymousinstanceofthefunctionalinterfaceas ui andotherwiseassafe.
intheexampleabove aslongasthe codeinbrackets includesatleastonecalltoan uieffect method weinferthetype of the lambda to be ui consumer.
typechecker implementation this section details the implementation of a typechecker for the aforementioned thread and effect type systems which is able to soundlyverifytheuithreadsafetyofreactivex basedjavaandroid applications.
the typechecker s design balances competing goals it must not only provide reliable guarantees of safety and correctness but also be easy to use and integrate into developer workflows.
what s more in order to find and fix existing ui threading bugs it must be applicable to legacy codebases without a prohibitive amountof configuration or annotation effort.
to that end we build the 5a functional interface is any java interface with a single abstract method.typecheckeruponthecheckerframework whichprovidesinfrastructureforbuildingcustomtypecheckersthataugment java s base type system.
refinement types are implemented as checker framework type qualifiers annotations on existing java base types which are then processedatcompile timebyourtypechecker.thecheckerframework allows users to check those types by simply invoking a javac compiler with certain command line flags.
this design enables any modernjavabuildsystemoridetoincorporateuithread safety typechecking with minimal configuration overhead.
the typechecker plugin itself consists primarily of three components as shown in fig.
the type qualifiers themselves custom typing rules that specify the ui thread safety invariant and a type factorythatgeneratesannotationsthatarenotexplicitlywritten but rather inherited derived or inferred.
thetypequalifierhierarchies describedindetailindividually insection implementjavatypeannotationsforeachthreadand effecttype.inadditiontothetypehierarchiesshowninfigures and3 this also includes polymorphic qualifiers that range over thoselatticesaswellasclass andpackage levelannotationswhich apply some annotation to each method therein.
thecustom typing rules express the constraints on effect inheritance and transitivity and enforce the core ui thread safety invariant that uieffect fulcallbacksmayonlybesubscribedto uithread streams.thesecustomtypingrulesaugmentthestandard rules implemented by the checker framework which constrain for example actual parameters to declared formal parameter types assignment r values to corresponding l value types and return values to declared method signatures.
finally the implicit type factory is responsible for generating typerefinementsforthosevariablesthatlackanexplicitrefinement annotation.
this process takes one of three forms inheritance in addition to the uieffect and safeeffect methodannotations theeffecttypesystemwebuildupon also provides shorthand annotations to facilitate blanket annotation of all methods in a class or package .
these shorthands are especially useful when all methods of a particular package or class share the same effect saving the effort of annotating each one manually.
inference whenever our typechecker encounters a lambda expression we retrieve the functional interface base type inferred by javacfor the lambda.
if that type has a concrete effectqualifier noinferenceisrequiredandwesimplyapplythatqualifier.otherwise wescanthebodyofthelambdaforanyinvocationsofmethodswith uieffect .ifanyarefound then the anonymous instance associated with the lambda expression is annotated ui see section .
.
defaults whenanun annotatedmethodorvariabledoes notinheritatyperefinementandinferencedoesnotapply asensibledefaultischosenbythetypechecker.thesedefaults minimize annotation burden dramatically by only forcing developersto writeannotations wherethetype refinement varies from the default.
werefineun annotatedmethodswiththe safeeffect qualifiersothatannotationsonlyneedtobeexplicitlywrittenon code that interacts with the ui while un annotated streams authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
safe stream based programming with refinement types ase september montpellier france receive the anythread trivial refinement so that unless otherwise specified we soundly assume a stream could emit events on any thread.
the choice of default annotations is a design choice in practice we find that these defaults largely correspond to developer intuitions and reduce annotation overhead.
thosethreeelements qualifierhierarchies customtypingrules andimplicittypegeneration sufficetotypecheck wholeprograms programs that are complete and self contained in a set of source files.
the stream based android apps we are concerned with however are openprograms which interact with other libraries and frameworks whose source code the typechecker may not have access to reactivex and the android standard library at a bare minimum.
inordertotypecheckcodethatinteractswithun analyzedexternal libraries we refine types as needed at the public interface of libraries using annotation stubs files consisting of annotated typesignaturesforlibrarymethods.theseannotationsallowthe typecheckertospecifyrefinementtypesforthird partylibrarycode withoutcheckingtheinternalsofthoselibrariesorrebuildingthem from source.
annotation stubs are particularly effective for specifying the effectsofandroidlibrarymethodsandthethreadingbehaviorof observable operators.
we present several such annotation stubs in figure7in order to build intuition and demonstrate the technique.
scrollview isanandroiduielement somostofitsmethods have ui effect.
the uitypeclass level shorthand applies uieffect to each of its methods however some methods including post can safely be called from non ui threads and are thus annotated safeeffect .
delayschedulesthereturned observable onthecomputation threadpool so its return value is annotated compthread .
observeon returns an observable that emits events on the given scheduler .
this behavior is expressed by applying the polymorphic polythread qualifier to both the return type and the threadparameter constraining them to both have the same thread refinement.
takesimplytruncatesastreamafter keventsanddoesnot affectthethreadofthestreamitiscalledon asisthecase withmost observable operators.wethereforeconstrainits receiverand return value to run on the same thread using the polymorphic polythread qualifier.
annotation stubs are a possible source of unsoundness in our approach sincethe refinementtypes theyprovide aretrusted and the corresponding source code is unchecked.
however we are able to mitigate this concern through careful review of source code and documentation forboth androidand reactivex.in particular our annotationstubsconformtotheandroiddeveloperguide sadmonition that the android.widget and android.view packages comprise theandroiduitoolkit i.e.haveuieffect andtoallthreadingbehaviors specified in the reactivex observable documentation .
evaluation we answer the following research questions in order to evaluate our approach.
is the typechecker usable and practical?
is the annotation burden sufficiently small for real world android developersto make use of the tool and are the messages and warnings emitted by the tool useful and understandable?
does the typechecker find real bugs and help fix them?
are threading bugs in stream processing code prevalent in practice does our tool identify them successfully and is a programthatsuccessfullytypechecksreliablyfreeofsuchbugs?
.
evaluation suite ourexperimentalevaluationconsistsofcasestudiesover8opensource android applications as well as a report on our experience applying the tool in production to two android applications developed at uber we select open source applications for our experiments from github according to the following criteria.
first we restrict our search to android applications written in java excluding android applicationswritteninotherlanguages since ourtypecheckeroperates over a java ast .
ofthose weconsideronlyapplicationsthatimporta2.xversion of reactivex.
we exclude applications using a .x version because ourannotationstubcoveragethereofismoresparseandapplicationsusingtheolderlibraryversionaremorelikelytobeabandoned or broken.
finally wetookthe8mostrecentlyindexedapplicationswith 10ormoregithub stars.
thesetwocriteriaformanimperfectbut practicalproxyforrepositoryactivity takingrecentlyindexedapps avoids those that are abandoned or unmaintained while requiring atleast10starsensuresthattheappsarenotsmallpersonalprojects or one off experimental applications.
we believe that the subject programs selected thusly form a reasonably representative cross section of open source android projects including forexample awidely forkedtemplateformodelview presenterapps aclientforarussiantechnologynews website andanappthatscans tracks andorganizesreceipts .
in total this open source evaluation suite consists of thousand lines of code written by distinct contributors.
in addition to this corpus of open source applications we have alsoappliedthetypecheckertotheubereatsanduberdriverapps bothofwhicharelargeclosed sourceandroidapplicationswritten and maintained by professional developers at uber.
.
annotation workflow thissectiondetailstheprocessofapplyingthetypecheckertoan existing android application.
first weclonetheapplication andconfirmthatitbuildssuccessfully in our local environment.
in practice we found that all of the open source apps gathered according to our criteria use the gradle build system and were relatively easy to build locally .
next we configure the application s build to invoke our custom typechecker simply by adding package dependencies and setting javac command line options in the build.gradle configuration file.
at thispoint thetypecheckerisfullyconfiguredandwillbeseamlessly integrated with the existing compilation process.
however the task of refining effect and thread types of existing coderemains.wefinditmostefficienttoannotateintwophases authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france benno stein lazaro clapp manu sridharan and bor yuh evan chang uitype class scrollview ... safeeffect boolean post ui runnable action class observable t ... compthread observable t delay long delay timeunit unit polythread observable t observeon polythread scheduler thread polythread observable t take polythread observable t this int k figure selected example stub annotations for reactivex observable methods and an android ui class.
first apply effect annotations throughout the application ignoring anyerrorsrelatedtothreadingandthen onceallmethodshavethe proper effect type apply thread annotations and or fix real bugs until no alarms remain.
recall the two conditions that govern effect typing methods may only call methods with lesser effect transitivity and override methods with greater effect inheritance .
since all unannotated application code has safeeffect by default and all android ui methods have uieffect from annotation stubs everycallfromtheapplicationintotheandroiduitoolkit violates the transitivity condition in the app s initial unannotated state.inordertodealwiththisavalancheofalarms wefirstidentify allpackages withnamesconnotinguieffect e.g.
ui view widget layout etc.
and use the package level uipackage annotation to apply uieffect to all methods therein.
then we triage remaining alarms and write type annotations manuallyuntilnoalarmsremain.weproceedfromfileswiththe most alarms to those with fewest using the class level uitypefor especially alarm ridden classes where most methods have ui effect.
itispossiblethatourpackage andclass levelannotationsassign the uieffect refinement to methods that do notactually interact withtheui.assuch manualtriageisnotassimpleasblindlypropagating uieffect annotations wearecarefultoidentifycaseswhere analarmisduetothepackage andclass levelannotationsanduse safeeffect to exclude a method from the coarse ui annotation rather than further propagating the spurious uieffect .
unliketheeffecttypesystem whichrequiresamoderateamount ofmanualannotation thethreadtypesystemrequiresalmostnone.
rather our library annotation stubs are sufficient for the typecheckertodeterminethethreadtyperefinementofintermediate values of fluent call chains in most cases and it is rare for developers to store observable streams in instance fields or local variables which would require type annotation at their declaration.
therefore once effect annotations are completed the only remaining alarms in most applications are genuine threading violations where a ui effectful callback is subscribed to a non uithreaded stream.
we manually inspect these violations to confirm that they are bugs and then find fixes on a case by case basis.
oncefixeshavebeenfoundandapplied theapplicationisverifiablysafefromnon uithreadaccessofuielementsinstream based code.
crucially thisfairlyinvolvedannotationprocessisaone time cost.
after an application has been configured to use the thread andeffecttypecheckerandfullyannotatedonce futurebugfixes and feature additions require minimal annotations.
nonetheless possible threading errors are automatically reported by the compiler as they are written allowing developers to write and modify complex asynchronous stream based software with confidence.
.
experimental results for our experiments we apply the described workflow to the open sourceapplicationsgatheredaccordingtotheaforementionedcriteria.
figure 8reports a summary of our results which we apply here to the two stated research questions is the typechecker usable and practical?
there are two facets to this question first is the annotation burden reasonable both in terms of developer time and total annotation andsecond isthetypecheckerusableandunderstandable for real android developers?
our results on the open source evaluation suite demonstrate that whiletheinitialoverheadofannotationismeaningful itisfar from prohibitive we spent an average of .
hours per application writing one annotation per source lines of code.
does the typechecker find real bugs and help fix them?.we find a total of threading defects spread across different appsintheopensourceevaluationsuite anaverageof4 .1errors perapplication.theerrorsvaryfromsimpleoversights e.g.
forgetting an observeon to more complex interactions between multiple stream operators and combinators.
the wide range of bugs found acrossamajorityofsubjectprogramsdemonstratestheapplicability and efficacy of our approach.
we reproduce one example defect identified by the typechecker here taken from the forpda application and slightly modified for clarity.
observable.onerrorreturn throwable handleerror throwable onerroraction return fallbackvalue .observeon andro idschedulers.mainthread .subscribe callback the onerrorreturn methodtakesalambdathatrunswhenever thereceiver observable emitsanerror catchingtheerrorandemitting the lambda s return value instead.
in this case the lambda simply calls handleerror on the error throwable and returns a default value fallbackvalue before scheduling the resulting stream on the main thread and subscribinga callback callback.
the handleerror function renders the error message in the ui but it may run on a background thread since onerrorreturn precedesthe observeon thatmovesthestreamtothe mainthread.thefixtothisbugissimple switchthepositionsof onerrorreturn and observeon and the code compiles without error.
.
uber case study aspartofourevaluation wedeployedthetypecheckerinuber s development infrastructure for two major applications the uber eatsandroidappandthenewestversionoftheuberdriverandroid authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
safe stream based programming with refinement types ase september montpellier france app kloc annotations time spent hrs.
errors found compile time sec.
forpda .
chat sdk android .
trust wallet android .
arch components date .
.
mvparms .
rxbus .
smartreceiptslibrary .
openfoodfacts .
averages .
.
.
.
figure open source test corpus experimental results.
reported loc figures are computed with sloccount .
reported compilation times are the mean of five executions of gradlecompiling all application release sources with our typechecker enabled measured on a laptop with an intel i7 6700hq processor and 8gb ram running ubuntu .
.
app thenindevelopment itwasreleasedtopartnersinapril2018 .
thetypecheckerrunsaspartofthecontinuousintegrationpipeline in parallel with a manual code review process.
it inspects every patch blocking code from merging into the trunk of the repository if it fails to typecheck.
android apps at uber are organized as a collection of targets compiled and unit tested separately.
over a period of months we progressivelyenrolledindividualtargetsfromeachofthetwoapps ontothetypechecker.foreachtarget wefirstwroteaninitialsetof annotationsforexistingcode thenenabledtypecheckingforthat target and merged in the new annotations simultaneously.
overall we enrolled over half a million loc corresponding to targets from each of the two apps.
as of this writing we did notenroll targets in other uber apps or shared platform code and first partylibraries althoughwedidadd trustedbutunchecked annotations stubs for shared ui code.
duringtheinitialenrollmentprocess wemade41substantive changestotheapplicationinadditiontotheaddedtypeannotations.
most of those changes are simple additions of observeon calls to reactivex fluent call chains to move streams onto the main thread.
these represent potential preexisting issues regarding improper ui access off the main thread.
although it is possible for manyof them to be safe in practice due to implicit knowledge aboutruntime behavior not captured in our type system we considerthe safety offered by the typechecker to be worth the potentialmarginal performance cost of moving these streams to the main thread or performing redundant observeon calls.
during this enrollment period we observed two critical production bugs involving reactivex streams accessing the ui from a backgroundthread.thefirstwasdistilledintothe delay example showninfigure .thesecondwasanissuewheredevelopersfailed to notice that observable switchmap could create and return a new observable on a different thread rather than propagate the thread ofitsreceiver.thesebugswerepatchedassoonastheymanifested in production and the app updated accordingly but both would have been caught by the current version of the typechecker had it alreadybeenenabledforthecorrespondingtargets.thisgivesus someconfidencethatthetooliscatchingothersimilarissuesbefore theymakeitpastthe developmentstage.bydesign issuesidentifiedbythetypecheckerarefixedbeforetheybecomeproduction bugs.after enrollment any further commits changing files inside the corresponding target are checked against our type system and developers are responsible for maintaining the annotations as part of thedevelopmentcycle.overthe8monthsofourrollout over4 commitsand178developersinteractedwithourtypechecker.we notethatenrolledtargetscontainanaverageofonetypeannotation per loc indicating that the burden placed on developers is relatively low.
furthermore when excluding commits made by the authors during the initial enrollment the annotation burden falls to one typeannotationper179loc implyingthatmuchoftheannotation burden is incurred upfront and not as ongoing maintenance cost.
wemeasuredthatdevelopershaveadded135 observeon ... invocationstocommitsundercodereviewinresponsetotypechecker warnings eachrepresentingapotentialfixtoathreadingdefectthat couldotherwisehavegoneuncaught.notethatwecannotverify that all of these changes are fixing real threading bugs some may have been needed due to a spurious uieffect annotation or other typechecking imprecision.but aswe have notreceived developer feedback indicating excessive false positives we believe that many of these changes were either fixing real issues or improving the codebymakingitmoreobviouslysafe.catchingthesethreading issuesearlyinthedevelopmentprocessreducescostsandimproves productivity asdevelopersdonotneedtocontext switchbackto code they wrote days or weeks earlier to fix bugs.
.
threats to validity theevaluationresultspresentedinthissectionarepredicatedupon thecorrectnessandsoundness ofourtechniqueandexperimentaldesign.
first itisimportanttonotethatourtechniquedoesnotmake any global guarantee about ui access or general thread safety the typechecker only verifies that ui effectful code is annotated ac cordingly and stream based code is safe from invalid ui thread access.
as such our tool does notfind ui threading bugs outside of stream based codeor non uithreading bugs suchas deadlocksor data races.
furthermore thesafetyguaranteesprovidedbythetypechecker aresoundwithrespecttotrustedlibraryannotationstubs which could potentially diverge from the true behavior of the underlying code.
we note however that our uieffect annotations for the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france benno stein lazaro clapp manu sridharan and bor yuh evan chang android standard library include all methods explicitly specified as ui effectful by the official developer guide .
sincetheseexperimentswereperformedbyanauthorofthetool it is possible that the reported time spent underestimates the time thatwouldbespentbyalessexperienceduser.however thatfactor is balanced somewhat by the fact that we were unfamiliar with the open source applications being annotated several of which were even documented in languages not spoken by the annotator.
itisalsopossiblethatoursubjectprogramcorpusisnotrepresentative of stream based android programs in general either due to small sample size or biases in our selection criteria.
related work althoughthereisawealthofresearchonanalysisofconcurrentprograms existingapproachesareill suitedtotheproblemofdetecting improperlythreadeduiinteractionsinasynchronousstream based software.
much of the existing literature focuses on race detection ordering violations and deadlocks leveraging a wide range of dynamic andstatictechniquesincludinginstrumentation locksetalgorithms and model checking .
however thesinglethreadmodelwewishtoverifyprecludes the need for general thread analyses there are no data races or deadlocksinauilibrarythatrunsononlyonethread.furthermore theaforementionedanalysesarecomputationallyexpensive relying onvariouspointerandaliasanalysestoreasonaboutjava sheapallocated threading constructs.
our type based approach builds upon a deep body of work in extensibletypesystemstoaddressbothoftheseissueswithconcurrencyanalysis sincetypecheckingisanintraproceduralanalysis that scales well and our type system is designed specifically to identify improper ui thread access.
theideaofaugmentinganexistingtypesystemwithmoreexpressive domain specific types was introduced by freeman and pfenningintheirseminalworkrefiningalgebraicdatatypesinstan dardml .however theircontributionsareprimarilytheoretical providing only a barebones proof of concept implementation.
extendingalanguage ssyntaxwith annotations toexpressrefinements asoriginallyproposedforstandardmlin hasemerged as a technique enabling practical adoptionof refinement type systems.
annotation based type systems are widespread augmenting an existing static type system in haskell and sml o r adding simple static types to dynamically typed languages such as javascript and python .
injava thecheckerframework providesameanstoextend the java base type system with arbitrary custom type refinements.
this has also been used in the past for example to infer and check locking disciplines for multithreaded programs verify information flow properties and implement ownership and universe types .
the most closely related work to our own of which we are aware is the effect type system of gordon et al.
which is also implemented using the checker framework.
however withoutthe qualifier inference and thread typing techniques detailed in thispaper theirtypecheckerisunabletoverifythestream based applications with which we are concerned.testing is a popular alternative to static analysis type based or otherwise when trying to rule out classes of errors in software.
there isa largebody ofwork on automaticallytesting android applications at the level of the ui.
fully automated testing approaches include random and search directed event generation tools model based exploration concolictesting andeventgeneration using evolutionary algorithms .
industrial state of the art mostly uses scripted ui tests constructed for a particular app using a testing framework .
record and replay systems also see widespread use to isolatebugsencounteredduringmanualtestingorafterdeployment and can be combined with search based approaches into hybrid testing schemes .
however by their very nature testing techniques cannot show the absence of bugs only their presence.
even a theoretical perfect tester which explores all possible ui interaction traces can missthreading bugs.
for example issues flagged by our typechecker maydependoninteractionwiththenetworkcausinganeventto be emitted on a stream that is subscribed by ui affecting code but it is possible to explore every reachable view without this event ever occurring and thus miss the bug.
a survey by choudhary et al.
suggests that existing fully automated ui testing tools do not significantly outperform random exploration in terms of code coverage under a fixed time budget.
this could be due to either a faster rate of event generation for the simplerapproachorthedifferenceinengineeringeffortsgoingintoanindustrystandardtoolversusresearchprototypes.ineithercase these approaches are challenging to scale for large and complex applications.
finally testing basedtoolsusuallyrunlateinthedevelopment process whereas our analysis can run before a code change has even been merged into the trunk of the repository for our apps.
conclusion wepresentinthispaperatechniquethatstaticallyverifiesuiaccess tooccuronlyfromtheuithreadinstream basedandroidprograms.
our approach refines the types of data streams with a static bound on their thread refines the types of methods and callback likeobjects with a static bound on their side effects and collates the twotypesystemsinordertodetectinvalidthreadaccessesorprove the absence thereof.
we demonstrate the efficacy and usefulness of our typechecker by evaluating it on open source applications and finding bugs.
we also report on our experience applying the tool at scale to two large production android applications at uber where it has analyzed over commits by developers at time of writing.
acknowledgment theauthorswouldliketothankwernerdietl colingordon michael ernst and members of the cuplv lab for valuable discussions.
this material is based on research sponsored in part by the nationalsciencefoundationundergrantnumberccf 1055066and by darpa under agreement number fa8750 .
the u.s. goverernmentisauthorizedtoreproduceanddistributereprintsfor governmentalpurposesnotwithstandinganycopyrightnotation thereon.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
safe stream based programming with refinement types ase september montpellier france