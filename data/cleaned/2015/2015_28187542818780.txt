symbolic model checking of product line requirements using sat based methods shoham ben david baruch steriny joanne m. atlee and sandy beidu david cheriton school of computer science university of waterloo waterloo canada email fs3bendav jmatlee sbeidug uwaterloo.ca ydepartment of eecs university of california berkeley ca usa email sterin berkeley.edu abstract product line pl engineering promotes the development of families of related products where individual products are differentiated by which optional features they include.
modelling and analyzing requirements models of pls allows for early detection and correction of requirements errors including unintended feature interactions which are a serious problem in feature rich systems.
a key challenge in analyzing pl requirements is the efficient verification of the product family given that the number of products is too large to be verified one at a time.
recently it has been shown how the high level design of an entire pl that includes all possible products can be compactly represented as a single model in the smv language and model checked using the nusmv tool.
the implementation in nusmv uses bdds a method that has been outperformed by sat based algorithms.
in this paper we develop pl model checking using two leading sat based symbolic model checking algorithms imc and ic3.
we describe the algorithms prove their correctness and report on our implementation.
evaluating our methods on three pl models from the literature we demonstrate an improvement of up to orders of magnitude over the existing bdd based method.
i. i ntroduction product line engineering ple is an increasingly popular approach to product development in which processes and practices are geared towards creating and managing a family of related products e.g.
smart phones automobiles .
variability among products is characterized in terms of features where afeature is a unit of functionality or variation.
the product line maintains a collection of mandatory and optional features and individual products are derived by selecting among and integrating features from this feature set.
companies that successfully employ ple report dramatic improvements in productivity quality cost labour needs support for mass customization and time to market .
we are particularly interested in requirements models of product lines which we call pl requirements.
we focus on requirements models because incorrect system requirements are a major source of software errors.
requirements analysis can reveal requirements errors early in the development process when errors are easier and cheaper to fix .
in particular in ple a common error is feature interactions in which independently developed features behave differently when combined with other features.
determining how featuresought to behave in combination is a requirements engineering problem thus early identification of undesired interactions that need to be fixed is essential.
another reason that we focus on requirements models is that they are smaller to analyze than other software artifacts are and thus are more amenable to automated analyses.
a key challenge in analyzing pl requirements is efficient verification.
many traditional verification techniques are product based meaning that they can be used to assess models of individual products.
in a product line of reasonable size it is impractical to verify each derivable product individually because the number of possible products is exponential in the number of optional features.
as a result developers especially of safety critical products might verify a small fraction of products and limit the choices that are offered to consumers thereby foregoing one of the greatest assets of product line engineering the promise of mass customization.
as such there is significant interest in family based verification techniques that analyze entire product lines.
in these approaches a product line and its family of products are modelled as a single artifact that represents all possible variable behaviour.
family based verifiers operate on the productline artifact and either guarantee that the desired property holds for all derivable products or identify the products that violate a desired property.
many verification techniques have been adapted to support family based reasoning including type checking constraint checking equivalence checking model checking and deductive verification .
for the analysis of requirements models we use symbolic model checking .
we note that when software is concerned explicit state rather than symbolic model checking techniques are typically used.
however when verifying requirements the picture changes.
many software requirements formalisms like statecharts scr process algebras rsml stateflow and our feature oriented requirements modelling language have a simplified execution semantics in which the software system is assumed to respond completely to one set of inputs before the next set of inputs from the environment occurs.
these ieee acm 37th ieee international conference on software engineering .
ieee ieee acm 37th ieee international conference on software engineering .
ieee icse florence italy 5card pin amount cash card receipt card cancel cancel cancel deposit fig.
.
product line model of an automatic banking machine.
semantics map most naturally to the synchronous execution semantics of symbolic model checkers.
classen et al.
showed how a product line can be modelled and verified using symbolic model checking .
the modelling language is an extended version of the smv language that supports feature modules.
each feature is modelled as a distinct module that extends a base system and when composed together they form a single smv model of the entire product line.
if a behaviour in the product line model is feature specific it is guarded by a corresponding feature variable such that the behaviour is enabled or disabled depending on whether the feature is present or absent in a particular product.
consider the model of a simplified product line for an automatic banking machine abm shown in figure .
in the base product shown in black the abm authenticates the user dispenses cash and returns the card to the user.
the product line includes three optional features a deposit transaction d the issuing of a receipt r and a cancel operation c each shown in a different color that can be combined in different ways to produce different products.
the transitions that model feature specific behavior are annotated with an expression over the feature variables.
for example the transition from state to state is executable only if the receipt r feature is present in the product the transition from state to state is executable only if the receipt feature is absent from the product.
in pl model checking the feature variables d r and c in figure are boolean variables that are assigned a value nondeterministically in the initial state and keep this value throughout the computation1.
each assignment to the feature variables represents a particular feature combination whose corresponding enabled behaviours realize a single product.
by analyzing all feature variable assignments2 the model checker analyzes the behaviours of all the possible products in the product line.
the symbolic model checker in classen et al.
s work is an adaptation of the nusmv toolset .
given an smv model of a product line and a property in the ctl property language the outputs of the extended model 1in this work we assume that a product s feature configuration does not change dynamically as the product executes.
2if afeature model is provided which specifies the feature combinations of the valid products in the product line then assignments to feature variables will be restricted to valid combinations.
3in classen et al.
present family based explicit state model checking which uses a feature aware variant of the promela language and a new model checker called snip that is based on spin.
in this paper we concentrate on symbolic model checking only.checker when the property is violated in the model are an expression in terms of the feature variables representing all of the products that violate the property and a counterexample trace from one of the violating products.
thus in a single model checking run the user gets information regarding all products in the product line.
the results of report a significant speedup compared to model checking each of the products separately.
classen et al.
set nicely the basis for symbolic model checking of product line requirements.
their implementation however is far from optimal.
they implemented their method on top of the classical symbolic model checking algorithm using binary decision diagrams bdds .
this method is known to be significantly outperformed by modern techniques that are based on satisfiability solving sat .
for the vast majority of cases sat based symbolic model checking methods outperform bdd based ones by an order of magnitude or more .
in this paper we investigate adding pl reasoning support to sat based algorithms.
we examine the two leading sat based symbolic modelchecking algorithms and show how each of them can be adapted to support pl model checking.
the first is called imc it is bounded model checking combined with interpolation .
in this method the model s transition relation is unfolded ktimes and the model checker looks for a counterexample within this search space.
if no counterexample exists within kexecution steps interpolation is used to try and prove that no counterexample exists in deeper states.
the second method we investigated is the ic3 algorithm which is considered the state of the art symbolic model checking algorithm.
for a safety property p the ic3 algorithm maintains a sequence of frames r0 r n where each frame rjsatisfiespand is an over approximation of the set of states that are reachable from the initial states in jor fewer steps.
if two adjacent frames are found to be equal it means that a fix point has been found indicating that the property holds in all reachable states.
otherwise a set of counterexamples is found during the computation.
we modify both of these algorithms to support pl model checking.
in both methods when a counterexample is detected the model checker does not terminate.
instead we slightly modify the model removing from the search space the violating product s represented in the counterexample and continue the model checking procedure as if no counterexample has been found.
the algorithm progresses in this manner filtering out products that violate the property until the property is found to hold on the modified model i.e.
the property holds in remaining products .
we have implemented our methods in the abc toolset on top of its existing imc and ic3 utilities .
we evaluate our implementations on three product line models.
two are taken from the literature an elevator and a telephone system both introduced by plath and ryan in .
the third is an automotive pl model that we built based on feature requirement examples provided by general motors.
icse florence italyour experimental results demonstrate a dramatic improvement ranging between one and three orders of magnitude faster than the bdd based implementation.
more importantly our methods are capable of easily model checking examples that are too big to be tackled by the bdd method.
the rest of the paper is organized as follows.
in section ii we review the necessary definitions.
section iii is the main section of the paper where we describe our algorithms and prove their correctness.
section iv discusses our implementations in the abc tool and in section v we present our experimental results.
section vi gives an overview of related results and in section vii we conclude and discuss future directions.
ii.
p reliminaries letvbe a finite set of boolean variables.
a literal is a variablev2vor its negation v. aclause is a disjunction of literals and a cube is a conjunction of literals.
note that if cis a clause then cis a cube and vise versa.
a boolean formula is in cnf if it is a conjunction of clauses and in dnf form if it is a disjunction of cubes.
for a cnf formula f we denote bycl f the set of clauses of which fis composed.
we use the notation sat?
for the satisfiability query checking whether the boolean formula fhas a satisfying assignment.
a. kripke structures and model checking amodelmovervis a kripke structure m s t i l wheresis a set of states t s sis a total transition relation i sis the set of initial states and l s!2vis the labeling function that assigns to each state the subset of variables that are true in the state.
a state can also be seen as a cube of literals one literal for every variable in v. for a statesand a variable v2v we denote by s v the value true orfalse of vins.
we identify a boolean formula bover the variables vwith the set of states it represents the set of all states satisfying b. if s t 2t we say that tis a successor of s. a path inmis a sequence of states s0 s1 s nsuch thats02iand for alli i n we have si si 2t.
we say that a state sis reachable in mifsappears on a path in m. the path above is said to be oflengthn andsnon is in depthnfrom the initial state.
we refer to the transition relation tin two different ways as a boolean formula t v v is defined over two copies of the set of variables.
the copies might be called viandvi section iii a or vandv1 section iii b .
as a function t 2s!2smaps a set of states g sto the set of all successors of states from g. that is t g ftj9s2g s t 2tg.
an invariant property pis a set of states represented by a boolean formula .
the model checking problem for a model mand property pis to determine whether all reachable states inmsatisfyp.
we say that a model msatisfiesp denoted mj p .b.
product line modeling we follow to model a product line as a kripke structure.
letm s t i l be a model over a set of variables v. we assume the existence of a special set of variables vf v called feature variables.
literals of feature variables are called feature literals.
the feature variables are assigned values in the initial state and keep their values forever.
that is for s t 2t we have that for all v2vf s v t v .
every assignment to the feature variables defines a product of the product line.
a conjunction of literals of feature variables is called a product cube.
we note that a product line model is usually accompanied by a feature model which can be interpreted as a boolean expression describing the allowed products in the product line.
to accommodate this we restrict the initial assignments to feature variables to include exactly those that satisfy the feature model .
iii.
pl m odel checking using sat based methods in this section we show how pl support can be added to the two leading symbolic model checking algorithms imc and ic3.
we assume the model under verification describes a full pl as described in section ii b above and that the property to be verified is an invariant formulap.
in section iv b we explain how complex ctl formulas are translated into invariant properties.
in both our methods we search for a counterexample if one does not exist it means that the property holds for allproducts.
when a counterexample is found it describes a violating product might be a setof violating products in the ic3 case .
we first try to enlarge the set of violating products as much as possible.
then we modify the model by excluding from it all violating products found so far and continue the modelchecking procedure.
we repeat this process until the property is found to hold in the modified model at which point the rest of the products those that have not been excluded from the model satisfy the property.
at this stage the set of violating products should be presented to the user.
however this set might grow very big as the number of products grows exponentially in the number of feature variables and should not be presented to the user as a list.
we simplify this set to a compact boolean expression that represents exactly the set of violating products.
in the rest of this section we give the pl support algorithms over imc section iii a and over ic3 section iii b .
since theenlarge andsimplify procedures are common to both we describe them together in section iii c. a. pl model checking with imc letm s t i l be a model over a set of variables v and letpbe an invariant formula.
in bounded model checking bmc a counterexample is searched for among all paths of mup to a given depth k. for a given boundk we introduce new copies v1 v kof the setv and for readability purposes we define v0 v .
a subscript i icse florence italyon boolean formulas over vindicates that the formula is expressed using the variables vi.
we denote by k unroll m p k the formula k i0 t v0 v1 t v1 v2 t vk vk p k krepresents an unrolling of the model m it is a boolean formula representing all legal paths through m that end in a buggy state violating p in depth ksteps from the initial state.
if kis satisfiable the satisfying assignment produced by the sat solver demonstrates a counterexample showing that m6j p. if kis unsatisfiable it means that no counterexample exists in depth kfrom the initial state.
in the sequel we use the terms counterexample and satisfying assignment interchangeably.
in order to verify a property pusing bmc we verify k unroll m p k fork until kis satisfiable.
note that ifpholds in the model no counterexample exists the bmc procedure as described above never ends.
this problem is solved by applying interpolation thus the method is called imc when no satisfying assignment is found for depth k interpolation is used to over approximate the reachable state space.
interpolation involves several more calls to the sat solver searching for a fix point for the over approximation of the reachable states.
if such a fix point is found pis proven to hold inm.
if not we need to increase kand try again.
adding pl support in the method described above the procedure terminates when either a counterexample is found or when interpolation proves that the property holds in the model.
when the model describes an entire pl we want to provide an answer for each of the products in the line.
if the property holds for all the products no satisfying assignment exists in the model the output is the same we need only to change the message to the user to say that the property holds for all products.
when a satisfying assignment is found however it provides a value to all the variables in v and in particular to the feature variables invf.
the assignment to the feature variables defines a single violating product.
the conjunction of the feature literals described by the assignment is a cube pc representing the violating product.
our target is to find allviolating products.
to do that we first try to enlarge the set of violating products that exist in the current depth k .
this procedure is described in section iii c. assume that pc is the output of the enlarge procedure thus representing a set of violating products.
we modify the model checking problem by excluding the products pc from the model.
for depth k this is done by checking for the satisfiability of the formula pc k k pc0 recall that pc 0stands for the cube pc expressed in terms of the variables in v0.
the above formula thus disallows any product in pc to exist in the initial state of the bmc instance k. since feature variables keep their values section ii b the conjunction with pc 0excludes all product satisfying pc from the model.
thus if the above formula is satisfiable again the satisfying assignment provided must demonstrate a product out of our pc set.
the full procedure is given in algorithm .
the variable algorithm imcpl pl model checking using bmc and interpolation 1input modelm s t i l propertyp featurevars vf 2output dnf formula vp 3cube pc cex 4intk 5vp f alse 6while true do k unroll m p k while cex sat ?
vp k do pc enlarge vp k cex vf vp vp pc end result k interpolation vp k if result true then return simplify vp end 16end vp violating products is a dnf formula representing the products for which the property is found to fail so far.
it is assigned false in the beginning and as the procedure progresses violating products discovered are added to it.
cex on line is the satisfying assignment produced by the sat procedure if vp kis satisfiable.
we assume that cex if vp k is unsatisfiable causing the while loop to exit.
in the inner loop lines all counterexamples of length kare found.
for each counterexample detected we first try to enlarge it line to cover more products see section iii c1 .
the violating product cube pc is then added to the products already found line which guarantees the exclusion of it from the rest of the computation.
when the inner loop exits we are guaranteed that vp k k vp0has no more satisfying assignments of lengthk.
we apply interpolation line to check whether pcan be proven to hold on vp kin which case result is t rue.
ifp holds on vp k no more violating products exist in the model and we return a simplification of vp line describing exactly all violating products.
otherwise the interpolation makes a few more unrolling iterations and returns a kthat is larger than before.
the model is unrolled again line with the largerk and counterexamples are searched for deeper in the model.
in order to prove termination of our algorithm we first claim that the inner while loop must terminate for every k. this is because in every iteration of the loop all previously found icse florence italyviolating products are removed from the computation.
if a new satisfying assignment is found it involves a product that has not been detected before.
since the number of products is finite the loop must terminate.
note that if all products are violating the dnf formula vp is equivalent to true thus the conjunction k vp0is equivalent to false and does not have a satisfying assignment.
since the inner loop always terminates the termination of imcpl depends on the ability of interpolation to prove correctness of pin the modified model which is guaranteed for large enough k .
theorem when imcpl terminates vp describes exactly all the violating products in the model.
proof products satisfying vp are all violating they were added to vp either because they appeared in an explicit counterexample or as a result of enlarge which we assume to work correctly .
when imcpl terminates it is because interpolation determined that no more counterexamples existed in vp k. this means that no more violating products exist in the model thus vp satisfies exactly all of them.
b. pl model checking using ic3 ic3 is a sat based symbolic model checking algorithm that does not involve unrolling of the model.
thus we use only two copies of the variables vandv1.
ic3 is based on maintaining a sequence of frames r0 r1 r n. each frame is a cnf formula over the variables v representing a set of states in the model r j s .
each frame rjis an over approximation of the set of states that are reachable from the initial states iinjor fewer steps.
the frames rjfulfill the conditions in fig.
adapted from .
the ic3 algorithm proceeds by r0 i. a rj rj .
b cl r j cl r j forj .
t rj rj .
rj p forj n .
fig.
.
the conditions maintained by the frames of the ic3 algorithm refining the frames adding more clauses when possible while maintaining the conditions of fig.
.
one way of refining the frames that we use in the sequel is that of pushing clauses.
a clause cin a frame rjcan be pushed forward to the following frame if the sat query sat?
is not satisfiable.
this means that starting from states in rj and taking one step forward through t we can never reach a state that does not satisfy the clause c. thus we can safely add ctorj 1and this will not violate the conditions of fig.
.
the ic3 algorithm terminates in one of two cases for some j rj rj .
in this case a fix point of reachable states has been found and thus mj p. an error cube si iis found from which a path to pexists.
in this case m6j p. the two termination cases above together with the conditions in fig.
and query are sufficient for understanding our product line support.
for more details about the ic3 algorithm refer to .
adding pl support letm s t i l be a model over a set of variables v with a subset vf vof feature variables.
let pbe the invariant property to be verified.
our goal is to find all of the violating products that is all assignments to variables from vfsuch thatpfails to hold.
as before if pis found to hold in the model it means that it is satisfied for all products.
we change the output to the user reporting that pholds for all products.
in the case where the property fails to hold in the model we get a cube si ifrom which a path exists to a state violating p. like in the imc case we extract the product cube out of si and enlarge it to get a cube pc hopefully describing a set larger than one of violating products.
in order to remove pc from the model we define modified frames4 j n rj rj pc note that rj rjfor eachj.
the product cube pc is put aside to be reported later to the user.
the ic3plcontinues checking p with the new frames r0 rnreplacing the old ones.
note that by so the algorithm actually checks pon a modified model where states satisfying pc are filtered out.
if another counterexample is found on the modified model it identifies a different product cube pc0that also fails to satisfy p. the product cube pc0is set aside and the frames are modified as before.
the ic3pl algorithm continues in this manner until the property is found to hold on the modified model.
the full procedure is given in algorithm .
the input to the ic3 function on line is a sequence of frames initially the sequence of frames contains the initial states iand the full set of statess and the output is an updated sequence of frames.
ic3 returns also a boolean result whose value is true if two frames are found to be equal if the value of result is false then the cube siis a counterexample that identifies initial states that lead to an error state.
the function enlarge in line is the one explained in section iii c which returns a cube of feature literals representing a set of violating products.
we use the notation frames line to denote the replacement of rjbyrj pc in the set frames.
the function simplify in line is the same as in algorithm and its functionality is described in section iii c. we claim that when algorithm terminates the set of products reported to the user is exactly the set of products in the pl that violate the property.
to prove this we first state the following.
4the clause pc is in fact added to rnonly.
in the ic3 algorithm a clause added to rjis automatically added to all risuch that i j .
we explicate this in the description of our algorithm.
icse florence italyalgorithm ic3pl pl model checking using ic3 1input modelm fs t i lg propertyp featurevars vf 2output dnf formula vp 3sequence frames fi sg int result 4cube pc si 5vp false 6while true do result frames si ic3 t frames p ifresult true then return simplify vp end pc enlarge frames si vf vp vp pc forrj2frames do frames frames end 16end proposition .letr0 r nbe frames satisfying the conditions of fig.
.
then r0 rn defined as in equation satisfy the conditions of fig.
as well where iis replaced by i i pc.
proof conditions and of fig.
hold trivially.
for condition note that t rj t rj pc to see why recall that rj rj pc equation thus states satisfying pc do not exist in rj.
since feature variables keep their values no state satisfying pc can exist in t rj .
thus the conjunction of t rj with pc does not change the set.
since rj rjit follows that t rj t rj .
given thatrjsatisfies the conditions of fig.
the premise of the proposition we have t rj rj which allows us to deducet rj rj .
by conjuncting pc to both sides we gett rj pc rj pc.
by equations and we conclude what we need t rj rj note that in every call to ic3 the list of frames might grow.
however new frames that are introduced will include the product clauses because product clauses satisfy the pushing condition query .
like in proposition this is because feature variables keep their values.
by adding the clause pc to the frames we modify the model on which pis verified in a way that the products in pc are disabled.
note also that the products in pc are the only products disabled by adding pc to the frames.
since the new frames satisfy the conditions of fig.
when ic3 returns true we are guaranteed that p holds in the modified model.
a special case that should be noted is when allproducts in the product line violate p. suppose that our product list already holds several product cubes and assume that the pcidentified in the current iteration of the loop represents all the remaining products in the product line.
adding pc to the frames would make each rja contradicting cnf formula.
this would make every clause of each frame pushable to the next frame since query would be unsatisfiable .
thus when opening a new frame two frames will be found equal and the algorithm would terminate correctly.
following the discussion above we can now state the theorem theorem when the algorithm of fig.
terminates vp includes exactly all of the violating products.
c.enlarge andsimplify a set of products the algorithms in sections iii a and iii b both use the functions enlarge andsimplify.
in this section we explain their functionalities and how they are implemented in our tool.
we note that other implementation options exist that achieve the same functionalities.
the enlarge function our methods discussed in the previous subsections detect violating products one at a time.
our target is to get more violating products at each iteration.
in order to do that we take the formula for which a counterexample was found and try to find feature variables whose values are not needed for determining the satisfying assignment.
this is the purpose of enlarge.
the functionality of enlarge is based on a capability possessed by modern sat solvers among them minisat that we use in our implementation.
minisat allows literals to be added to a sat formula as assumptions .
when is found to be unsatisfiable minisat returns the set of assumptions used to prove that no satisfying assignment existed.
while this is not necessarily a minimal set of assumption it is often smaller than the original set.
let k unroll m p k be as in section iii a and cex the satisfying assignment produced for it.
in order to enlarge our set of assignments we use a well known trick based on the assumption capability.
we construct a new formula built of several components.
the first is k unroll m p k that is similar to but requires pto hold at depth k see section iii a .
the second component is a set of unit clauses one for each literal defined by cex except for the feature literals.
the last component is the set of feature literals added as assumptions.
for example let v fv1 v2 v3 v4gwithvf fv3 v4g and let cex be v v v v .
our formula will be defined as follows v v2 assumption v v4 note that is unsatisfiable it requires that pwould be true in cyclek but it forces the values of cex because of the unit clauses which must cause pto be false since it is a satisfying assignment to the original .
when given to the sat solver is immediately found to be conflicting and a conflict clause in terms of the feature literals is produced.
in our example let this conflict clause be v .
icse florence italythis means that the value of v4does not make a difference thus both v v4 and v v4 are failing products.
the simplify function the list of violating products is stored in our algorithms as a dnf formula vp satisfying exactly all the violating products.
as discussed before this formula can easily get too big to be presented to the user.
for example in a model with features if half of the products are violating vpdescribes products.
there exist more than one way for simplifying a dnf formula.
in our implementation we use a method by morreale known as irrelevant sum of products isop .
this algorithm takes as input a truth table representing a boolean formulafand calculates the simplest possible dnf formula that is equivalent to f. in abc where we implemented our algorithms the isop method is implemented supporting formulas of up to boolean variables.
our program constructs a truth table representing the list of products and uses the isop service of abc to simplify it.
the simplification using isop took a fraction of a second to complete.
since this step depends on the number of features in the model and not on the size of the model itself the simplification is expected to have very little influence on the overall runtime models of any size.
when the number of features in the model is larger than other simplification methods should be considered for example using bdds.
we note that our output will always be the simplest dnf formula but not necessarily the simplest formula.
for example the dnf formula v1 v2 v1 v3 is equivalent tov1 v 2 v3 which is simpler.
in contrast the output from the nusmv implementation depends on the last bdd order in the model checking run.
while in many cases it is the simplest formula possible we have seen cases where due to the bdd order the expression includes irrelevant feature variables.
iv.
i mplementation we implemented our methods in the abc toolset on top of its existing ic3 and imc functions.
in the subsections below we describe the abc tool and the conversion of safety ctl properties into invariant properties.
a. the abc tool abc is an open source software system for the synthesis and verification of sequential logic circuits represented as andinverter graphs aigs .
abc uses logic optimization and implements many algorithms from the literature including synthesis equivalence checking and various model checking algorithms among them bmc interpolation and ic3.
the tool uses a dialect of minisat as its sat solving facility and supports the isop method which we use to simplify the resulting set of products.
to be accepted by the abc toolset a model should be given in the aiger language .
for our experiments we translated models written in nusmv to aiger in two steps we invoked nusmv with the option output boolean model obm to translate a complex nusmv model into a simplerone that is flat i.e.
has no modules and boolean i.e.
has no multi valued variables .
we used the utility smvtoaig from the aiger distribution to translate the boolean model from into aiger.
b. translating safety actl properties to invariant properties our current implementations support only invariant properties of type agp with pbeing a boolean formula.
we were able to translate all safety actl properties into ag p type ones accompanied by auxiliary state machines that were added to the smv model .
a property is in actl if when represented in negation normal form where negation is over atomic propositions only it does not contain the e path quantifier.
an actl property is considered a safety property if it does not contain the aforauoperators.
for properties that use the au operator but are otherwise safety actl properties we converted au intoaw weak until .
while this weakened the meaning of the properties it allowed them to be included in our experiments.
for a safety actl formula the translation was done in two phases.
first we converted into a regular expression r .
we note that this conversion is limited to safety properties that are in the common fragment of actl and ltl .
luckily all safety properties in our case belong to this fragment.
we then used the algorithm of to build a state machine s in the smv language together with an ag p type property.
the results of guarantee the correctness of the translation but we also validated our implementation by running nusmv on the two versions of each property and comparing the results.
v. e xperimental results we ran our experiments on three pl requirement models.
two are taken from the literature the elevator and telephone models introduced by plath and ryan .
in order to build a pl model containing all features we used classen et al.
method and tool .
the third model is based on an industrial product line model of automotive software controllers first presented in .
we elaborate more on these models in the subsections below.
the experiments compare the performance of our two new methods with that of the bdd based method of classen et al.
implemented in the nusmv tool .
for the nusmv experiments we performed a preprocessing phase we invoked each model with the dynamic bdd ordering option dynamic and saved the final variable ordering in a file.
consequent runs recorded in the tables were invoked with the saved variable ordering file as an initial order and did not perform dynamic reordering.
the runs were performed on an amd fx machine with six cores at .3ghz and 32gb of ram.
the output results indicating the set of products for which the formula fails to hold were the same for all three methods for all runs except for those where nusmv could not terminate .
icse florence italytable i experimental results for the elevator model .
time is given in seconds .
t he product set is shuttle antiprank empty property res products bdd imc ic3 speedsup quick close!
ag door open!ax door close pnone .
.
.
ag door open!ax door close x quick close .
.
.
shuttle!ag floor direc up !ax direc up pnone .
.
.
ag floor direc up !ax direc up x shuttle .
.
shuttle!ag floor direc down !ax direc down pnone .
.
.
ag floor direc down !ax direc down x shuttle .
.
ag but but3!a x all .
.
overloaded!ag over door closed !ax door closed pnone .
.
.
ag over door closed !ax door closed p overloaded .
.
.
overloaded!
ag floor over !a pnone .
.
.
ag floor over !a x overloaded .
.
.
ag floor but3 direc up !
door closed x all .
.
ag floor but3 direc down !
door closed x all .
.
ag floor but8 direc up !a x see .
.
ag floor but1 direc down !a x see .
.
a. the elevator model the elevator model we use was first introduced by berry in .
plath and ryan in augmented the model with features demonstrating how feature interactions can be detected using model checking.
classen et al.
in generalized the model added features and made it configurable allowing the composition of part or all the features into a single pl model.
we use classen et al.
s model taken from their site in its largest configuration possible containing floors and features.
the feature set in our model includes park which sends the elevator to a designated floor to park too full ignoring calls when elevator is too full to load more people executive floor which gives priority to one of the floors overloaded preventing the doors from closing when the elevator is overloaded open if idle leaving the doors open when parked empty which cancels calls inside the elevator if it is empty antiprank ignoring calls inside the elevator when active shuttle continuously moving even when no calls are made and quick close closing doors one time step after opening.
for a full description of the elevator model and its features refer to .
after composing all features the model had state variables making it a relatively small model.
out of about properties accompanying the elevator model only ten were safety properties supported by our methods.
the rest were mixed universal and existential ctl properties or liveness ones.
five of the properties were conditioned on the existence of a certain feature in the product tested.
for those we introduced also an unconditioned version.
table i presents the results for each of the properties.
column of the table lists the output of the run true p for all products or false x for some or all of them.
column gives the expression describing the violating products hence this value is none when the formula holds for all products .
for example the second property in table i is violated in all products where quick close is not present.
columns present the time in seconds for the bdd imc and ic3 methods respectfully.
thelast column calculates the speedup between the imc method which is the fastest and the bdd method.
we note that while the speedup gets up to times better the run times are relatively short for all cases.
b. the telephone model our second case study is a simple version of a telephone system introduced by plath and ryan in .
the system models a network of phones each with a different set of functionalities.
we manually translated the system and feature modules that were written in a dialect of the smv language cadence smv into the nusmv dialect.
we were able to compose features using classen et al.
s composer to get a pl model with state variables.
most of the features were applied to phone only some were applied also to phone .
this is indicated by an extension 1or 2to the feature name.
the list of features taken from is given below.
call forward unconditional cfu all calls to the subscriber s phone are redirected to another phone.
call forward on busy cfb andcfb all calls to the subscriber s phone are redirected to another phone if the line is busy.
call forward on no reply cfnr andcfnr all calls to the subscriber s phone are redirected to another phone if not answered in a certain amount of time.
ring back when free rbwf if the user gets the busy tone on calling another line the feature can be activated.
a call to the same line will be reissued as soon as it becomes idle.
terminating call screening tcs reject calls to the subscriber s phone from numbers on a given screening list.
full description of the telephone model can be found in .
the telephone model includes properties of which are safety actl properties.
we ran all of them and we report the results for of them in table ii.
the rest of the properties were found to fail on all products and have run times that are comparable to those presented in table ii.
while the telephone model is almost twice as large as the elevator run times were not longer and seemed to vary less than in the elevator icse florence italytable ii experimental results for the telephone model property result products bdd imc ic3 speedup ag ph st talking ph1 dialled !ph2 st talked x all .
.
ag ph tcs msg!
ph dialled ph1 tcs2 x cfu 1 cfb .
.
ph2 dialled ph4 tcs2 ag ph cfu forw !ag ph st infringing talkedg x cfu .
.
ag ph tcs msg!
ph dialled ph1 tcs2 x cfu 1 cfb .
.
ph dialled ph4 tcs2 ag ph tcs2 ph1 st ringing !ph3 st ringingt x all .
.
ag ph tcs msg!
ph dialled ph1 tcs3 x cfu 1 cfb .
.
ph dialled ph4 tcs3 ag ph st trying !ax ph st ringingt ph1 st busyt x cfb .
.
ag ph st talking ph1 dialled !ph3 st talked pnone .
.
ag ph tcs3!ag ph dialled ph3 st infringingt talking g x tcs .
.
ag p tcs2!ag ph dialled ph2 st infringingt talking g x tcs .
.
example.
the significant advantage of our methods over the bdd one however is maintained here with all sat based runs completing the verification in less than half a second.
c. the autosoft model our third and largest pl requirement model is an automotive example called autosoft.
this model is derived from feature requirement examples provided by general motors and was manually modelled in the forml language which supports precise modelling of feature requirements for software product lines.
full details of the forml features which are very abstract versions of the features in the original document can be found in .
the features were automatically composed into a pl model which was then semiautomatically translated using a chain of tools being deployed by the last author into the smv language.
its analysis using a model checker is presented here for the first time.
the model consists of features.
bds is the basic driving service which responds to the drivers s requests.
cruise control cc maintains the vehicle s speed while headway control hc maintains the vehicle s headway distance from road objects.
lane change alert lca is responsible for issuing an alert if the driver tries to change lanes under unsafe conditions and forward collision alert fca issues an alert whenever there is danger of a collision with an object ahead.
headway personalization hp saves the last cruise headway setting of a driver.
speed limit control slc overrides cc s computation of the car s acceleration whenever cruising speed is greater than the speed limit of the road and lane centring control lcc periodically adjusts the car s orientation to centre the vehicle in its current lane.
lane change control lxc automatically changes the vehicle s lane to a driver selected lane provided the conditions are safe.
finally driver monitoring system dms issues an alert whenever the driver is not attentive.
for our experiment we introduced a set of safety properties listed below.
if lxc is activated by the driver then within two cycles either lcc will be automatically activated or a request will be issued for the driver to take control.
if lxc is activated then so is lca.
when lcc is active and the driver turns the steering wheel then lcc should be temporarily deactivated.
whenever a driver issues an accelerate command the speed of the car must increase.
the car always tries to keep a certain minimum headway distance from the car ahead.
if a driver issues both an accelerate and decelerate commands then the speed of the car should reduce.
when the car s ignition is off and the driver requests an ignition turn on then the car will be turned on.
the autosoft model in the smv language consists of state variables and was too large to be analyzed with the bdd implementation.
we left the model checker running for hours for property and terminated it after realizing that all of the available memory had been exhausted.
for the rest of the properties we set a cutoff time of second hours .
none of the bdd runs were capable of evaluating the property with a hour limit.
in an attempt to cope with the size problem we experimented with applying cone of influence coi reduction to the model.
this service of nusmv reduces a model based on the property to be verified leaving only the parts of the model that are relevant for the verification.
the coi reduction is applied separately for each property to get a reduced model customized for the property.
after applying coi the run times for the sat based methods were reduced significantly in some cases .
the bdd method however was not capable of completing any of the runs within the hour limit even for the reduced models.
table iii presents two results in seconds for each of the properties for the sat based methods.
the first is the run time for the original model with no reduction the size column gives the number of state variables in the model and the second is the time for the reduced model after coi reduction was applied.
the notation ax p first property of table iii stands for ax p axp .
note that ic3 was able to solve each property in less that minutes and imc in less than one minute.
icse florence italytable iii experimental results for the autosoft model .
t he set of products is bds lcc hp cc bds lcc hc cc t he set of products is bds dms hc cc lxc bds lcc hc cc .
property size result products bdd imc ic3 ag lxc execute!ax lcc active lxc takeoveralert x all ag lxc active!ax lcs engaged x all ag lcc lcc active steer steer angle !
x see ax lcc inactive ag accelerate!ax car speed car speed pre x all .
.
ag hc car headway car setheadway !
x see .
ax car goalspeed car goalspeed pre .
ag accelerate decelerate!ax car speed car speed pre 526pnone .
.
.
ag bds off igniteon!ax car ignition on bds on 526pnone .
.
threats to validity nusmv provides many configuration flags in which a model checking run can be invoked.
thus our configuration might not have been the optimal one.
finding the best configuration however is itself extremely time consuming.
also while our new methods significantly outperform the old one it is possible that part of this difference has to do with the differences in the underlying tool infrastructures.
vi.
r elated work family based symbolic model checking has been proposed in several works.
plath and ryan were the first to suggest the use of smv to model and verify feature interactions.
they proposed an extension to the smv input language that allowed modifying an existing system with additional features.
interactions between features can then be verified by model checking a property before and after adding a new feature.
the work of classen et al.
was mentioned before and it is the closest to ours.
while our method performs much better it currently supports safety actl properties only whereas classen et al.
support the full ctl language.
we note however that it is common practice in the model checking world to compromise expressiveness for better performance.
researchers have also proposed family based explicit state model checking.
lauenroth et al.
showed how product lines could be modeled as an extension to i o automata.
they adapted the original ctl model checking algorithm of clarke et al.
to verify a product line model.
a variability model which specifies the legal products of the product line ensures that the model checker explores only legal feature combinations.
gruler et al.
showed how features could be modelled in ccs and integrated into a product line.
the product line is represented as a labelled transition system whose transitions are annotated with feature combinations the model checking algorithm returns a set of products that satisfy a given formula.
classen et al.
implemented what they call a family based semi symbolic model checking algorithm that searches the explicit state space of products but represents sets of products in a symbolic data structure.
we consider this work as being in the camp of explicitstate model checkers.
in general explicit state and symbolic model checking approaches are complementary and cannot be directly compared since the models have different execution semantics interleaving vs. synchronized execution .
one chooses between explicit state and symbolic model checking based on the characteristics of the problem to be verified.
another related area is that of variability aware model checking in which modelling languages and modelchecking algorithms accommodate variability e.g.
optional behaviour but the variability is not packaged into features.
as a result the output of the model checker is not in terms of features and products that violate a property.
cimatti et al.
consider the synthesis of parameters for infinite state models.
they use ic3 with an smt rather than sat solver in the target of finding parameters that are feasible for a given system.
while the context of their work is very different from ours their ic3 algorithm to find the set of relevant parameters is close in nature to our algorithm for finding violating products.
vii.
c onclusion we demonstrated how pl support can be added to sat based symbolic model checking methods thus enabling the verification of pl requirement models much larger than before.
our experiments show that the imc method performs consistently better than the ic3 one a phenomena that is different from what is reported in the literature and would be interesting to investigate.
in our current implementations only a single property can be verified in one run.
this seems inherent in the algorithms as the model is modified during the verification to filter out violating products and thus cannot be used to model check other properties.
one way to deal with this is to modify the property rather the model.
experimenting with this idea is left for future work.
icse florence italyreferences software engineering institute software product lines overview oct. b. w. boehm software engineering economics.
prentice hall ptr .
t. th um s. apel c. k astner m. kuhlemann i. schaefer and g. saake analysis strategies for software product lines technical report fin school of computer science university of magdeburg germany.
l. aversano m. di penta and i. baxter handling preprocessorconditioned declarations in scam pp.
.
c. k astner s. apel t. th um and g. saake type checking annotationbased product lines in tosem vol.
no.
pp.
july .
s. apel w. scholz c. lengauer and c. kastner detecting dependences and interactions in feature oriented design in issre pp.
.
k. czarnecki and k. pietroszek verifying feature based model templates against well formedness ocl constraints in gpce pp.
.
f. heidenreich towards systematic ensuring well formedness of software product lines in fosd pp.
.
m. cordy a. classen g. perrouin p. y .
schobbens p. heymans and a. legay simulation based abstractions for software product line model checking in icse pp.
.
a. classen p. heymans p. y .
schobbens and a. legay symbolic model checking of software product lines in icse.
acm pp.
.
a. classen p. heymans p. y .
schobbens a. legay and j. f. raskin model checking lots of systems efficient verification of temporal properties in software product lines in icse pp.
.
a. gruler m. leucker and k. scheidemann modeling and model checking software product lines in fmoods pp.
.
k. lauenroth k. pohl and s. toehning model checking of domain artifacts in product line engineering in ase pp.
.
t. th um i. schaefer s. apel and m. hentschel family based deductive verification of software product lines in gpce pp.
.
k. mcmillan symbolic model checking.
kluwer academic publishers .
d. harel a. pnueli j. schmidt and r. sherman on the formal semantics of statecharts in lics pp.
.
c. l. heitmeyer and r. d. jeffords the scr tabular notation a formal foundation naval research lab tech.
rep. nlr mr nlr mr .
r. milner communication and concurrency.
new york prentice hall .
c. a. r. hoare communicating sequential processes.
uk prentice hall .
iso8807 lotos a formal description technique based on the temporal ordering of observational behaviour iso tech.
rep. .
n. g. leveson m. p. e. heimdahl h. hildreth and j. d. reese requirements specification for process control systems vol.
no.
pp.
september .
g. hamon a denotational semantics for stateflow in proceedings of the 5th acm international conference on embedded software ser.
emsoft pp.
.
p. shaker j. atlee and s. wang a feature oriented requirements modelling language in ieee international requirements engineering conference re sept pp.
.
e. clarke and e. emerson design and synthesis of synchronization skeletons using branching time temporal logic in proc.
workshop on logics of programs ser.
lncs .
springer verlag pp.
.
k. c. kang s. g. cohen j. a. hess w. e. novak and a. s. peterson feature oriented domain analysis foda feasibility study carnegiemellon university software engineering institute tech.
rep. cmu sei90 tr .
a. cimatti e. m. clarke f. giunchiglia and m. roveri nusmv a new symbolic model checker in sttt vol.
no.
pp.
.
a. classen m. cordy p. y .
schobbens p. heymans a. legay and j. f. raskin featured transition systems foundations for verifying variability intensive systems and their application to ltl model checking ieee transactions on software engineering vol.
no.
pp.
.
e. m. clarke e. a. emerson and a. p. sistla automatic verification of finite state concurrent systems using temporal logic specifications in toplas vol.
no.
pp.
.
r. bryant graph based algorithms for boolean function manipulation inieee transactions on computers vol.
c pp.
.
a. biere a. cimatti e. clarke and y .
zhu symbolic model checking without bdds in tacas pp.
.
a. r. bradley sat based model checking without unrolling in vmcai pp.
.
k. l. mcmillan interpolation and sat based model checking in cav pp.
.
m. sheeran s. singh and g. st almarck checking safety properties using induction and a sat solver in fmcad pp.
.
n. amla x. du a. kuehlmann r. p. kurshan and k. l. mcmillan an analysis of sat based model checking techniques in an industrial environment in charme pp.
.
a. r. bradley ic3 and beyond incremental inductive verification in cav p. .
understanding ic3 in sat pp.
.
r. k. brayton and a. mishchenko abc an academic industrialstrength verification tool in cav pp.
.
n. e en a. mishchenko and r. k. brayton efficient implementation of property directed reachability in fmcad pp.
.
m. plath and m. ryan feature integration using a feature construct in science of computer programming vol.
no.
pp.
.
n. e en and n. s orensson an extensible sat solver in sat pp.
.
e. morreale recursive operators for prime implicant and irredundant normal form determination in ieee trans.
comput.
vol.
no.
pp.
.
a. biere the aiger and inverter graph aig format i. beer s. ben david and a. landver on the fly model checking of rctl formulas in cav ser.
lncs .
springer verlag pp.
.
m. maidl the common fragment of ctl and ltl in focs pp.
.
s. ben david d. fisman and s. ruah automata construction for regular expressions in model checking june ibm research report h .
p. shaker j. m. atlee and s. wang a feature oriented requirements modelling language in re pp.
.
m. berry proving properties of the lift system master?s thesis school of computer science university of birmingham.
a. classen feature transition system p. shaker a feature oriented modelling language and a featureinteraction taxonomy for product line requirements ph.d. dissertation waterloo on canada .
a. classen m. cordy p. heymans a. legay and p. y .
schobbens model checking software product lines with snip in sttt vol.
no.
pp.
.
p. asirelli m. h. t. beek a. fantechi and s. gnesi a logical framework to deal with variability in ifm pp.
.
a. fantechi and s. gnesi formal modeling for product families engineering in splc pp.
.
a. cimatti a. griggio s. mover and s. tonetta parameter synthesis with ic3 in fmcad pp.
.
icse florence italy