map coverage a novel coverage criterion for testing thread safe classes zan wang college of intelligence and computing tianjin university china wangzan tju.edu.cn jun sun school of information systems singapore management university junsun smu.edu.sgyingquan zhao college of intelligence and computing tianjin university china zhaoyingquan tju.edu.cn xiang chen school of information science and technology nantong university china xchencs ntu.edu.cnshuang liu college of intelligence and computing tianjin university china shuang.liu tju.edu.cn huarui lin college of intelligence and computing tianjin university china linhuaruitju tju.edu.cn abstract concurrent programs must be thoroughly tested as concurrency bugs are notoriously hard to detect.
code coverage criteria can be used to quantify the richness of a test suite e.g.
whether a program has been tested sufficiently or provide practical guidelines on test case generation e.g.
as objective functions used in program fuzzing engines .
traditional code coverage criteria are however designed for sequential programs and thus ineffective for concurrent programs.
in this work we introduce a novel code coverage criterion for testing thread safe classes called map coverage short for memory access patterns .
the motivation is that concurrency bugs are often correlated with certain memory access patterns and thus it is desirable to comprehensively cover all memory access patterns.
furthermore we propose a testing method for maximizing map coverage.
our method has been implemented as a self contained toolkit and the experimental results on benchmark programs show that our toolkit outperforms existing testing methods.
lastly we show empirically that there exists positive correlation between mapcoverage and the effectiveness of a set of test executions.
i. i ntroduction concurrency bugs are notoriously hard to detect and debug and therefore concurrent programs must be thoroughly tested.
given a test suite for a concurrent program the question is how do we systematically measure the richness of the test suite?
for sequential programs this question has been answered in multiple ways.
in the setting of black box testing where the specification of the program is available we can measure the quality of a test suite based on its coverage of the specification.
for instance given a specification in the form of use cases we can measure the percentage of use cases that have been covered by the test suite.
in the setting of white box testing a rich family of code coverage criteria has been proposed and adopted in practice e.g.
statement coverage branch coverage and path coverage.
such code coverage criteria not only facilitate measuring the richness of a test suite but also provide guidelines for automatic test generation .
corresponding authorexisting code coverage criteria are however mostly designed for sequential programs and therefore ineffective for concurrent programs.
recently there have been several attempts on designing new coverage criteria for concurrent programs.
for instance taylor et al.
pioneered a hierarchy of concurrency coverage criteria.
bron et al.
presented coverage metrics that are useful for human developers to create concurrent tests.
the latest study is that choudhary et al.
proposed a coverage metric which measures the percentage of method pairs in a thread safe class covered by a test suite.
they further proposed a test generation method called covcon which aims to achieve high method pair coverage.
the results showed that covcon outperforms previous related studies on a set of concurrent benchmark programs.
in this work we propose a new coverage criterion for concurrent programs called map coverage short for memoryaccess pattern .
unlike previously proposed criteria mapcoverage measures the richness of a set of test executions instead of a set of test cases.
a test execution is the sequence of atomic steps executed by a test case i.e.
a program under testing which sets up multiple threads and provides inputs for each method call with a particular thread interleaving.
because the same test case may behave very differently with different thread interleavings we conjecture that a measurement over a set of test executions would be more accurate in capturing what behaviors of a concurrent program have been covered.
unlike existing approaches on measuring coverage of thread interleaving map coverage measures thread interleaving coverage in a highly abstract way.
that is mapcoverage abstracts test executions using memory access patterns and measures what memory access patterns are covered.
a memory access pattern captures a pattern of how a shared variable is accessed by multiple threads.
it has been shown that memory access patterns are often associated with the essence of multi threaded bugs and furthermore concurrency bugs can often be reduced to one or more of a set of generic memory access patterns .
we propose a testing method called maptest which aims 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to achieve high map coverage.
maptest works as follows.
given a class which is supposed to be thread safe it first automatically identifies all mutable shared state variables including those which can be accessed through de referencing .
next maptest statically analyzes every public method in the class to identify the variables which are read written by each method.
afterwards maptest generates test cases which can potentially cover certain memory access patterns.
the test cases are then automatically instrumented and executed with controlled thread interleaving while maptest monitors the memory access patterns which are covered by the test executions.
after that maptest generates new test cases which are likely to cover those uncovered memory access patterns.
the process continues until a bug is discovered or a testing budget is exhausted.
we remark that maptest is further integrated with the work in to use the method pair coverage as a heuristic in generating test cases.
maptest has been implemented in java and evaluated on java classes including all programs evaluated with covcon .
the results showed that maptest can successfully detect thread safety violations in all programs.
compared to covcon maptest detected the bugs using less time on most of the test programs i.e.
with an average speedup of 17x and a maximum speedup of 193x.
furthermore maptest s performance is consistent across different runs though there exists randomness in this method.
the results also show maptest is effective in achieving high map coverage.
lastly we conduct an empirical study to measure the correlation between map coverage and bug detection capability of a set of test executions.
the results show that they are correlated and are more so than the method pair coverage.
in short we make the following contributions in this work.
first we propose a new coverage criterion for concurrent programs called map coverage.
second we develop a testing method called maptest which aims to achieve high mapcoverage.
lastly we implement maptest and empirically show that maptest is effective in revealing concurrency bugs.
the remainders of the paper are organized as follows.
in section ii we define the problem to be addressed.
in section iii we present details of map coverage.
in section iv we show how maptest works.
maptest is evaluated in section v. we review related work in section vi and then conclude in section vii.
ii.
p roblem definition in this section we define our problem.
the input to our approach is a thread safe class cl.
a class is thread safe if it behaves correctly when multiple threads are allowed to access methods in the class concurrently without additional synchronization or other coordination on the part of the calling code .
in this work correctness refers to the absence of data races and atomicity violations.
without loss of generality we assume class clis composed of a set of mutable instance or static variables vand a set of public methods m. each method m mtakes an optional sequence of input parameters and accesses some variables in vfor either reading or1.public abstract class appenderskeleton ... .
protected priority th .
public boolean isassevereasthreshold priority priority .
return th null .
priority.isgreaterorequal th .
.
.
public void setthreshold priority threshold .
this .th threshold .
fig.
an example class writing which includes reading .
we use rm and wm t o denote the set of variables read and written by method m. for example fig.
shows a class from log4j1which is supposed to be thread safe.
for the sake of space only two methods are shown.
using maptest we identify a previously unknown bug in the class which intuitively can be explained as follows.
at line method isassevereasthreshold checks whether this null or not and returns true if it is.
otherwise priority is compared with that line .
if it so happens that after line is executed and before line is executed another thread executes method setthreshold and sets thbe to null a nullpointerexception is generated when line is executed.
a. test cases a test case for class clis a concurrent program which invokes one or more public methods in mpossibly through multiple threads.
a test suite is a collection of multiple test cases.
for instance fig.
a shows a test case for the class in fig.
.
it is written in the form of one prefix and multiple suffixes.
intuitively the prefix is a sequential part of the test case which is executed first and then multiple suffixes are executed afterwards by different threads concurrently.
in this example there are two threads t1and t2 t1executes the first suffix and t2executes the second.
note that although this test case potentially reveals the bug it is unlikely to if we simply run this test case multiple times.
the reason is that thread t2must be executed after t1executes line and before t1 executes line so that the bug can be revealed.
a test execution is a sequence of atomic steps which are executed during the execution of a test case with a particular thread interleaving.
without loss of generality we assume that each step in a test execution is of the form t i r w where tis a thread identifier iis an atomic instruction ris a set of variables read by the instruction and wis a set of variables written by the instruction.
for instance fig.
b shows a few steps of a test execution of the test case on the left where s4 and s5 s9 represents a step which executes line and in fig.
.
that is thread t1first reads the variable th with s4.
thread t2then writes variable thwith s9.
finally thread t1reads variable thwith s5.
a test case may result in multiple test executions due to different thread interleavings.
for instance the test case shown in fig.
may result in multiple test executions and only some of them result in a nullpointerexception .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
prefix .
nullappender var0 new nullappender .
priority var1 priority.debug .
.
suffix1 .
var0.isassevereasthreshold var1 .
suffxi2 .
var0.setthreshold null a a test case thread t1 thread t2 s1 t1 s4 th s2 t2 s9 th s3 t1 s5 th b a test execution fig.
sample test case and test execution b. coverage a coverage criterion can be useful in multiple ways.
for instance it provides a quantitatively measure for the richness of a test suite.
ideally the higher the coverage achieved by a test suite the more likely bugs in the program are revealed.2for another instance coverage can be used as an objective function in automatic test generation e.g.
the afl fuzzer is designed to maximize branch coverage .
thus a rich family of code coverage criteria have been proposed e.g.
statement coverage branch coverage and path coverage.
details of these criteria can be found in a survey .
unfortunately most existing code coverage criteria are defined for sequential programs and are thus ineffective for concurrent programs.
for instance one execution of the test case in fig.
covers all statements in the relevant methods of the program shown in fig.
and yet it is unlikely to reveal the bug as we explained above.
in recent years multiple code coverage criteria dedicated to concurrent programs have been proposed .
the latest study in proposes a coverage metric called the method pair coverage which measures the frequency of concurrent executions of method pairs.
while it makes sense to exercise different method pairs concurrently it may not be sufficient since covcon is based on test cases not test executions.
for instance in our experiment covcon generates the test case in fig.
correctly and yet fails to reveal the bug even if we run the test case with covcon ten times.
alternatively we can use thread interleaving coverage as a measurement .
the problem is that there are often many i.e.
exponential in the number of scheduling points thread interleavings.
covering all of them would be costly and wasteful since many of them could be considered equivalent in terms of revealing the bug.
for instance given the program in fig.
a there are many interleavings many of which are equivalently irrelevant to the bug.
in the following we identify requirements on a code coverage criterion for thread safe classes which will be used to guide our work.
r1 unlike code coverage for sequential programs we conjecture that a coverage criterion for a concurrent program should be a function from a set of test executions to a measurement e.g.
a number from to instead of a function from a set of test cases to a measurement.
this 2there are studies on whether this is true even for commonly used code coverage criteria for sequential programs .
code coverage criteria however remain relevant unless we have better alternatives.table i generic memory access patterns id memory access pattern ta si x tb sj x ta si x tb sj x ta si x tb sj x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x ta sk x ta si x tb sj x tb sk y ta sl y ta si x tb sj y tb sk x ta sl y ta si x tb sj y ta sk y tb sl x ta si x tb sj x tb sk y ta sl y ta si x tb sj y tb sk x ta sl y ta si x tb sj x tb sk y ta sl y ta si x tb sj y tb sk x ta sl y ta si x tb sj y ta sk y tb sl x ta si x tb sj y ta sk y tb sl x is because the same test case may result in different test executions under different thread interleavings and thus a measurement based on the test cases without considering the thread interleaving is likely misleading.
r2 the coverage should be correlated with the bug revealing effectiveness of the test executions i.e.
given a program a set of test executions which achieve higher coverage should be more likely to reveal bugs in the program.
r3 given a set of test executions the coverage should be relatively easy to measure.
otherwise the coverage would not be able to provide instant feedback to for instance tools for test case generation on the fly.
r4 last it should be intuitive so that software testers are likely to use it as a guideline for creating test cases.
iii.
map c overage in this section we define map coverage and discuss why it is meaningful for testing thread safe classes.
in the following we fix a thread safe class clwith a set of mutable variables vand a set of public methods m. a. memory access patterns intuitively a memory access pattern is a pattern describing how a shared variable is accessed by multiple threads.
it has been shown that memory access patterns are often associated authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm identify patterns from a test execution 1letpatterns xbe an empty sequence of steps 2for each step ein the execution do ifereads xby thread a thread tathen for each subsequent step e primedo ife primewrites xby thread tbs.t.ta negationslash tbthen add e e prime into patterns x with the essence of multi threaded bugs .
memory access patterns can be viewed as an abstraction of the test execution which allows us to ignore irrelevant details and yet preserve the cause of the multi threaded bug.
a memory access pattern is represented in the form of a sequence of steps.
in this work we adopt the set of memory access patterns defined in shown in table i where the second column shows the sequence of steps in the memory access pattern.
it is shown that this set is complete under a certain assumption as concurrency bugs can be reduced to one or more of these patterns .
for instance the fourth pattern is a scenario with three steps.
first one thread treads a variable x. second a different thread writes x. lastly thread treads variable xagain.
note that this pattern is presented in the executions of the program shown in fig.
and is very relevant to the bug.
given a test execution we can systematically identify the set of memory access patterns it contains by pattern matching.
that is for each variable x vand every pattern in table i we first match the first step in the pattern with a step in the test execution and then match the second step in the pattern with a subsequent step in the test execution and so on until all steps in the pattern are matched.
for instance algorithm shows how to identify instances of the first pattern in table i from a given test execution with regards to variable x. since there are at most four steps concerning two threads and at most two variables in any of the memory access patterns the number of memory access patterns in a test execution is bounded by c2 n c2 m c4 kwhere cn mis the number of combinations where nis the number of shared variables mis the number of threads and kis the total number of steps in the test execution.
given a test execution t we write patterns t to denote the set of memory access patterns in t or equivalently covered by t .
note that the thread identifiers only matter when we decide whether they are the same thread when we do the pattern matching.
for instance two instances of the first pattern in table i ta si x tb sj x and tc si x td sj x are considered the same since they only differ by the identifiers of the threads.
in the following we assume that only one for all equivalent instances of the patterns is kept.
b. map coverage given a thread safe class the map coverage of a set of test executions is then calculated by the number of patterns covered by tover the total number of memory access patterns.
in general identifying all feasible memory access patterns ofa program is challenging just like identifying all reachable statements for calculating statement coverage is challenging.
nonetheless just like we can over estimate the number of reachable statements by counting the total number of statements in a given program we can over estimate the number of memory access patterns as we explain below.
the number of the first pattern in table i is estimated as x v ix r ix w where xis a variable in v ix ris the set of atomic instructions in the program which read x ix wis the set of atomic instructions in the program which write x s is the size of a sets.
this is because it is in general possible to set up a thread to execute any of the instructions which read xand set up another thread to execute any of the instructions which write xafterwards.
similarly we can estimate the number of other patterns accordingly.
the total number of patterns denoted as tc is then calculated as follows.
tc x v2 ix r ix w pattern x v ix w 2pattern x v ix r ix w pattern x v3 ix r ix w 2pattern x v ix w 3pattern x y v3 ix w iy w 2pattern x y v6 ix w ix r iy w iy r pattern we remark applying the above formula to calculate tcin practice is still non trivial.
for instance identifying v ix r and ix wwould require aliasing analysis which is known to be challenging.
furthermore the above formula over estimates the number of possible patterns as not every instruction reading writing vmay be feasible and not every pair of instructions reading writing vmay be executed concurrently e.g.
due to happens before constraints .
we leave it to future work on developing more precise estimations of tc.
definition map coverage let tp be a concurrent program vbe a set of shared mutable variables in tp and te be a set of test executions.
we say that a memory access pattern pis covered if and only if there exists at least one test execution t te such that p patterns t .
the map coverage of tis measured as t tepatterns t tc where tcis defined as above.
for instance given the program show in fig.
without considering variables and methods which are not shown tcis calculated as follows.
as there are two read instructions and one write instruction on variable th tcis2 .
thus tc .
assume that there is only one test execution i.e.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
pattern t1 s4 th t2 s9 th pattern t2 s9 th t1 s5 th pattern t1 s4 th t2 s9 th t1 s5 th fig.
memory access patterns the one shown in fig.
b we can systematically obtain the patterns in the test execution as discussed in algorithm .
the results are shown in fig.
i.e.
three patterns are covered.
the map coverage then can be calculated as3 i.e.
this execution covers .
of the memory access patterns.
iv .
map c overage guided test genera tion in this section we develop a testing method called maptest which aims to achieve high map coverage.
the input is a class which is supposed to be thread safe.
the output is a set of test cases a set of test executions generated based on the test cases as well as a test report which summarizes the achieved map coverage.
the overall algorithm is shown in algorithm .
at line we statically identity all the shared mutable variables in the given class.
note that vnot only includes all those variables declared in the class but also those which can be accessed through de referencing or due to inheritance.
furthermore for each method m we identify rm orwm which is the set of all variables in vthat method mreads or writes .
note that we use existing approaches for aliasing analysis.
function identifypatterns is then invoked at line to identify all potential memory access patterns.
function identifypatterns takes the program as input and returns a set of all possible memory access patterns.
the details are shown in algorithm .
at line for every variable xinv we identify all instructions in all methods which read write x. this is done using traditional techniques including aliasing analysis and data flow analysis.
next for each variable or pair of variables we identify potential memoryaccess patterns on the variable or the variable pair .
for instance at line for every instruction which reads xand every instruction which writes x we add an instance of pattern type into patterns .
the resulting patterns then contains all possible patterns.
note that patterns may contain patterns which are infeasible due to happens before constraints among the instructions.
that is if a pattern in patterns has a step executing instruction iand then a step executing instruction j whereas jcan only happen before i the pattern is infeasible.
in maptest we implement a standard happens before inference procedure to help prune infeasible patterns from patterns .
for the example in fig.
assume that we only focus on th there are two instructions s4and s5inith r i.e.
line and and one instruction s9inith w i.e.
line .
we formalgorithm maptest overall algorithm 1identify v rmand wmfor each method minm 2letpatterns identifypatterns cl 3while patterns is not empty do ifthere is a pattern on xonly in patterns then let n selectmethods with input x else if there is a pattern on x yinpatterns then let n selectmethods with input x y lettc buildtestcase n lette textexecute tc print tcand te remove patterns te for each te te from patterns the following patterns.
ta s4 th tb s9 th ta s5 th tb s9 th ta s9 th tb s4 th ta s9 th tb s5 th ta s4 th tb s9 th ta s5 th ta s5 th tb s9 th ta s4 th ta s9 th tb s9 th ta s4 th note that the same instruction can appear in multiple steps.
for instance to form an instance of pattern a thread tamust perform two writes on variable th in the first and second step whereas in this example there is only one instruction which writes th i.e.
s9 .
as a result s9appears twice at the last line of the above example which means method setthreshold is to be called twice.
next the loop from lines in algorithm aims to generate test executions to cover the patterns in patterns .
in particular lines first calls function selectmethods to identity a sequence of up to methods which can be used to build a test case for exercising certain pattern.
the details of function selectmethods are shown in algorithm .
we write mx rto denote the set of methods which contain at least one instruction reading variable x and mx wto denote the set of methods which contain at least one instruction writing variable x. there are two cases.
one is that there are uncovered patterns which involve one variable x i.e.
lines .
the other is that there are uncovered patterns which involve two variables xand y i.e.
lines .
in order to cover a pattern concerning with only one variable x a sequence of two for patterns or three for patterns methods are identified.
for instance to identify a sequence of two methods for pattern we first identify a method which contains an instruction which reads xand then one that writes x. for the example shown in fig.
given the variable th method selectmethods first identifies a pair of methods which potentially cover pattern .
first a method reading this selected e.g.
method isassevereasthreshold .
next a method writing this selected e.g.
method setthreshold .
similarly sequences of methods are identified for other patterns.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm algorithm identifypatterns cl 1identify ix rand ix wfor each variable x 2for each xinvdo letpatterns be for each siinix rand each sjinix wdo add ta si x tb sj x into patterns for pattern add ta sj x tb si x into patterns for pattern for each pair of siand sjinix wdo add ta si x tb sj x into patterns for pattern for each siinix r sjinix w and skinix rdo add ta si x tb sj x ta sk x into patterns for pattern for each siinix w sjinix w and skinix rdo add ta si x tb sj x ta sk x into patterns for pattern add ta si x tb sk x ta sj x into patterns for pattern add ta sk x tb si x ta sj x into patterns for pattern for each siinix w sjinix w and skinix wdo add ta si x tb sj x ta sk x into patterns for pattern 17for each xinvand yinvdo for each siinix w sjinix w skiniy w and sliniy wdo add ta si x tb sj x tb sk y ta sl y into patterns for pattern add ta si x tb sk y tb sj x ta sl y into patterns for pattern add ta si x tb sk y ta sl y tb sj x into patterns for pattern for each siinix w sjinix r skiniy r and sliniy wdo add ta si x tb sj x tb sk y ta sl y into patterns for pattern add ta si x tb sk y tb sj x ta sl y into patterns for pattern add ta sj x tb si x tb sl y ta sk y into patterns for pattern add ta sj x tb sl y tb si x ta sk y into patterns for pattern add ta sj x tb sl y ta sk y tb si x into patterns for pattern add ta si x tb sk y ta sl y tb sj x into patterns for pattern 29return patterns if there are multiple methods containing instructions for reading or writing a variable the choice can be resolved in different ways.
either it could be completely random or we can adopt existing heuristics like the method pair coverage.
in the latter case we resort to covcon to recommend a ranked list of method pairs and check whether there exists a method pair which satisfies our requirement.
if there is we choose the top method pair otherwise we choose randomly.
details on how method pairs are ranked can be found in .
for instance to obtain a method pair for covering pattern on variable th w e search through the ranked list of method pairs from covcon.
the pair isassevereasthreshold setthreshold is selected as method isassevereasthreshold contains an instruction reading thand setthreshold contains an instruction writing th.
note that the same method can be selected more than once sometimes.
hereafter we use maptest random to denote an implementation of maptest which selects methods randomly and maptest to denote the one which selects methods accordingly to covcon s recommendations.
after the methods are selected at line in algorithm function buildtestcase is called to build a test case.
that is we set up an object cof type cland two threads taand tb which share a reference of c. note that this is sufficient given that all patterns shown in table i involve two threads only.
thread taand tbare then set up to invoke the sequence ofmethods in nin an alternating order.
note that we generate parameters for each method call including the constructor of cl using traditional methods .
for instance a test case for the class in fig.
is shown in fig.
.
first an object of type nullappender is created in the prefix which is a sequence of sequential code to instantiate the thread safe class as well as randomly call methods to change the state of the shared variable.
then based on the methods selected by selectedmethods two suffixes are created to call the methods.
the suffixes form the concurrent part of the test case i.e.
they are executed by different threads concurrently.
the constructed test case is then executed with a controlled scheduler at line in algorithm to obtain a set of test executions te through function textexecute .
function textexecute detailed in algorithm takes a test case as input and aims to generate a set of test executions which cover as many memoryaccess patterns as possible.
at line we first identify a set of patterns which could potentially be exercised by the test case in a way very similar to algorithm by assuming that the program contains only the methods called in the test case .
afterwards we aim to generate one thread interleaving for covering every pattern.
this is achieved with a scheduler which is controlled through code instrumentation.
that is we first statically insert a scheduling point in front of every instruction that reads authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm algorithm selectmethods 1let nbe an empty sequence 2ifthe input is a variable xthen add m n s.t.m mx rand n mx w for pattern add m n s.t.m mx wand n mx r for pattern add m n s.t.m mx wand n mx w for pattern add m n l s.t.
m l mx rand n mx w for pattern add m n l s.t.
m n mx wand l mx r for pattern add m n l s.t.
m l mx wand n mx r for pattern add m n l s.t.m mx rand n l mx w for pattern add m n l s.t.
m n l mx w for pattern 15ifthe input is a pair of variables x ythen add m n l k s.t.
m n mx wand l k my w for pattern add m n l k s.t.
m l mx wand n k my w for pattern add m n l k s.t.
m k mx wand n l my w for pattern add m n l k s.t.m mx wand n mx rand l my rand k my w for pattern add m n l k s.t.m mx wand n my rand l mx rand k my w for pattern add m n l k s.t.m mx rand n mx wand l my wand k my r for pattern add m n l k s.t.m mx rand n my wand l mx wand k my r for pattern add m n l k s.t.m mx rand n my wand l my rand k mx w for pattern add m n l k s.t.m mx wand n my rand l my wand k mx r for pattern or writes a shared variable at the bytecode level .
during dynamic execution we use a daemon thread to control the thread scheduling.
that is the daemon thread suspends all threads when a scheduling point is reached and then selects a suspended thread to continue.
if there is more than one thread which can be scheduled next to execute we eagerly schedule the thread which would execute a step in a pattern e.g.
if the step requires executing an instruction iand a thread tis to execute inext tis scheduled.
if multiple threads can be scheduled and none of them would exercise immediately a step in the pattern a thread is selected at random.
for instance given the test case in fig.
a and the pattern in fig.
after thread t1reads thats4 we reach a scheduling point where either t1proceeds to read th by executing line ort2proceeds to write th by executing line .
according to the pattern the next step should be a different thread writing th and thus thread t2is scheduled.
after t2executes s9 another scheduling point is reached and t1is scheduled for the same reason.
as a result the pattern is covered.
at line in algorithm the test case and the test executions are printed as a part of the report.
lastly all patterns covered by any test execution in te are removed from patterns .
the loop continues until patterns becomes empty or it reaches time out .
note that algorithms and always terminate.
however algorithm does not guaranteealgorithm algorithm testexecute 1let pbe the set of patterns which can be potentially covered by the test case 2for each pattern pinpdo generate a thread interleaving which eagerly schedules the steps in p 4execute the test case according to the generated thread interleaving to obtain a set of test executions te 5return te that the resultant test execution will cover the pattern and as a result the termination of algorithm cannot be guaranteed.
v. i mplementa tion and ev alua tion maptest is implemented based on jdk and it is open source.3it is built on top of the java bytecode analysis and modification tool asm which is used to insert code for controlling the thread interleaving at the bytecode level.
maptest uses the framework contege to generate test cases.
a. evaluation to evaluate the relevance of map coverage and the effectiveness of maptest we conduct a set of experiments to answer the following research questions rqs .
rq1 does maptest reveal bugs effectively?
rq2 does maptest achieve high map coverage?
rq3 is map coverage correlated with bug revealing effectiveness of test executions?
our test subjects are a set of buggy thread safe classes collected from various sources including all test subjects from .
these examples are widely used in previous studies .
table ii shows the details of these classes.
column class name shows the name of class.
column fields shows the number of variables defined in the class including those from its super classes.
note that we do not distinguish the access permission e.g.
public orprivate of the variables since all of the instance variables are by right shared.
column methods shows the number of public methods in the class including those from the super classes.
column loc shows the number of lines of code in the class including those from the super classes counted using statistic .4lastly column bug shows the type of bug in the class.
maptest uses a simple oracle which monitors unexpected exceptions including assertion failures if there are assertions in the program.
all results of the experiments presented below are obtained on a machine with two octa core cpus intel r xeon r cpu e5 .60ghz and 125g memory running centos linux7.
bit .
the timeout is set to be hour for each run.
to minimize the impact of randomness each experiment is repeated for times independently with different random seeds and we report the average result.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii benchmarks description id project v ersion package class name fields methods loc bug v1apache dbcp .4org.apache.commons.dbcp.datasources peruserpooldatasource data race v2 org.apache.commons.dbcp.datasources sharedpooldatasource atomicity v3 jdk1.
java.io bufferedinputstream atomicity v4 .
.
java.util concurrenthashmap atomicity v5 .
.
java.util hashtable data race v6 .
.
java.util.logging logger atomicity v7 .
.
java.lang stringbuffer atomicity v8 .
.
java.util synchronizedmap deadlock v9 .
.
java.util v ector atomicity v10 .
.
java.util v ector atomicity v11 jfreechart1.
.
org.jfree.data.time day data race v12 .
.
org.jfree.chart.axis numberaxis atomicity v13 .
org.jfree.chart.axis periodaxis data race v14 .
org.jfree.data.time timerseries data race v15 .
org.jfree.chart.plot xyplot data race v16 .
org.jfree.data xyseries data race v17 log4j .
.13org.apache.log4j.helpers appenderattachableimpl data race v18 org.apache.log4j fileappender atomicity v19 org.apache.log4j.varia nullappender atomicity v20 xstream .
.
com.thoughtworks.xstream xstream atomicity table iii results compared with covcon and maptest random idmapt est covcon maptest random comparison time s success rate time s success rate time s success ratem.
over c. m. over m r. m r. over c. speedup p value speedup p value speedup p value v1 .
.
.
.
.
.
.
.
.
v2 .
.
.
.
.
.
.
.
.
v3 .
.
.
.
.
.
.
.
.
v4 .
.
.
.
.
.
.
.
.
v5 .
.
.
.
.
.
.
.
.
v6 .
.
.
.
.
.
.
.
.
v7 .
.
.
.
.
.
.
.
.
v8 .
.
.
.
.
.
.
.
.
v9 .
.
.
.
.
.
.
.
.
v10 .
.
.
.
.
.
.
.
.
v11 .
.
.
.
.
.
.
.
.
v12 .
.
.
.
.
.
.
.
.
v13 .
.
.
.
.
.
.
.
.
v14 .
.
.
.
.
.
.
.
.
v15 .
.
.
.
.
.
.
.
.
v16 .
.
.
.
.
.
.
.
.
v17 .
.
.
.
.
.
.
.
.
v18 .
.
.
.
.
.
.
.
.
v19 .
.
.
.
.
.
.
.
.
v20 .
.
.
.
.
.
.
.
.
rq1 does maptest reveal bugs effectively?
in order to answer this question we systematically apply maptest to every class and measure the time elapsed before the first bug is revealed by any execution .
to examine whether there is a statistically significant difference between two methods we use the wilcoxon signed rank test .
the significance level is set to .
.
if p value is smaller than .
we reject the null hypotheses which means that the difference between two methods is statistically significant otherwise we accept the null hypothesis which indicates the difference is not statistically significant.
for a baseline comparison we compare maptest with the state of the art approach covcon which has been shown to significantly outperform other approaches like con tege autocontest and narada .
the results of the experiments are shown in table iii where column time shows the average time spent on revealing a bug and success rate shows how many times out of runs a bug is successfully revealed.
the last six columns report the speedup and statistical test comparison between different testing methods where column m. over c. is the results of maptest s compared to that of covcon.
we have the following observations based on the results.
first maptest successfully revealed bugs in all programs whereas covcon failed in two cases.
second maptest outperforms covcon in out of cases significantly better than covcon in cases and performs similarly in the remaining two cases.
overall maptest achieves an average authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
.
.
.
.
.
.
.
.
.
.
.
pattern pattern pattern pattern pattern pattern pattern pattern 5bug inducing patterns rat io fig.
most bug inducing patterns speedup of times and a maximum speedup of times over covcon.
third maptest performs consistently across different runs for the same program e.g.
maptest reveals a bug in every run for every program whereas covcon may sometimes miss the bug for out of programs.
we additionally compare maptest with maptest random to see whether testing guided by map coverage alone without using the method pair coverage heuristic is useful.
note that maptest random selects methods randomly in algorithm rather than applying the method pair coverage as a guideline.
the results are summarized in table iii where column m. over m r. represents the results of maptest s compared to maptest random and column m r. over c. represents the results of maptest random s compared to covcon.
comparing maptest random and covcon maptest random performs noticeably i.e.
more than times better for programs significantly better in programs and performs noticeably worse for programs.
furthermore maptest random and covcon complement each other as they perform better on different programs.
comparing maptest and maptestrandom maptest performs better in most of the cases i.e.
and performs noticeably worse for one program.
we conclude that maptest effectively reveals concurrency bugs and furthermore combining map coverage and method pair coverage is effective.
we further analyze which are the memory access patterns that successfully trigger the bug in each case.
the results are shown in fig.
.
the results show that some memory access patterns trigger more bugs.
the most bug triggering pattern is pattern i.e.
concurrent write write on a shared variable which accounts more than half of the cases.
this observation suggest that it might be useful to prioritize certain patterns during testing which we will explore in the future works.
rq2 does maptest achieve high map coverage?
in order to answer this question we systematically apply maptest to every class for a total of minutes and measure the map coverage achieved over time.
the results are shown on the left of fig.
where the vertical axis is the map coverage achieved.
note that we run maptest on each program for hours and take the number of patterns covered by them to be the total number of patterns since it is in general nontrivial to know exactly how many patterns are there.
the results show that the map coverage increases rapidly for all programs initially and continues to increase for most ofthe programs.
the rate of increment however varies from program to program.
for most of the programs a high mapcoverage is reached after minutes whereas for programs the map coverage remains low for minutes.
we conjecture that the reason for the latter is that maptest is unable to control the thread interleaving as expected to cover certain patterns.
to show the effect of selecting methods and controlling the thread interleaving in maptest we additionally implement a test engine called random which randomly selects method pairs for generating test cases and executes them without controlling thread interleaving.
we then measure the difference between maptest and random s map coverage over time.
the results are shown on the right of fig.
where the vertical axis is the value of maptest s map coverage minus that of random .
we can find that the difference increases monotonically over time.
furthermore the trend for each program is similar to that of the figure on the left.
this suggests that maptest improves map coverage effectively as expected whereas a random testing engine is ineffective at covering different memory access patterns.
rq3 is map coverage correlated with bug revealing effectiveness of test executions?
in order to answer this question we design an experiment which is inspired by the study in .
the general idea is to measure the correlation between the map coverage of a set of test executions with the number of bugs those test executions revealed.
first we systematically inject additional bugs into the test programs by removing all locking mechanisms e.g.
by tracking lock objects and the synchronized keyword in the programs.
the reason for injecting bugs is that there is typically only one bug in the test program which is insufficient for calculating correlation.
we then run each test program for two hours record the total number of different bugs encountered as the total number of bugs.
two failed test executions are considered to reveal the same bug if the same exception is observed from the same instruction.
we also record all the memory access patterns observed during the two hours as the total number of patterns.
we then run each program independently ten times with different random seeds each time for minutes.
we record the achieved map coverage and the number of bugs revealed after minutes minutes minutes and minutes respectively.
this gives us a total of data points for each program and in total.
afterwards we calculate the relationship between mapcoverage and bug coverage using kendall correlation coefficients .
kendall correlation is chosen instead of pearson product moment correlation as it has fewer assumptions e.g.
it does not assume that the variables are linearly related or the data has a normal distribution.
a kendall correlation coefficient ranges from to where a positive value means positively correlated and a negative value means negatively correlated.
according to the definition of correlation in guildford scale an absolute value of less than .
means that the positive or negative correlation is low an absolute value authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
v1v v2 v3v4 v5v v6 v7v8 v9 v10v11 v12 v13 v v14 v15v16v17 v v18v19 v20 .
.
.
.
time s a maptestmap coveragev1 v2 v3v4 v5v v6 v7v8 v9 v10v11 v12 v13 v v14 v15v16v17 v v18v19 v20 .
.
.
.
time s b randommap coverage difference fig.
map coverage achieved over time between .
and .
means that the correlation is moderate and otherwise the correlation is high.
for a baseline comparison we measure the method pair coverage and calculate the correlation between the methodpair coverage and the bug coverage similarly.
that is we firstrun each program using covcon for hours to obtain thetotal number of method pairs.
we then run each program usingcovcon ten times each time minutes to record the achievedmethod pair coverage and the number of bugs revealed after5 and minutes.
the results are shown in table iv where the second third and fourth columns show the total number of method pairs patterns and bugs covered after executing hours .
note thatfor programs no new bugs are injected as there are no locksin these programs.
the last two columns show the kendallcorrelation coefficients between map coverage and thenumber of bugs revealed and that between the method paircoverage and the number of bugs revealed.
note that an entry means that the same number of patterns method pairsare covered in the independent runs and thus the kendallcorrelation coefficients cannot be calculated and the means that the method did not find any bug.
we present theaverage correlation values across all programs in the last row.we can observe that there are moderate correlations for programs and high correlation for program in the case of map coverage whereas there are moderate correlations for3 programs in the case of method pair coverage.
on average map coverage shows a correlation of .
which is muchstronger than that of the method pair coverage which is0.
.
we thus conclude that map coverage is reasonablycorrelated to the bug revealing effectiveness of test executions.
limitations.
while the above experimental results show that maptest outperforms existing techniques it still has some limitations which require future research.
first it may notbe easy for test engineers to manually design test cases totable iv correlation results of maptest and covcon kendall idmethod pairspatterns bugsmaptest covcon v1 .
.
v2 .
.
v3 .
.
v4 .
.
v5 .
.
v6 .
.
v7 .
.
v8 .
.
v9 .
.
v10 .
.
v11 .
v12 .
.
v13 .
.
v14 .
.
v15 .
.
v16 .
.
v17 .
v18 .
.
v19 .
v20 .
.
all .
.
achieve high map coverage mainly due to the difficulty incontrolling the scheduling.
given a memory access pattern say on a certain shared variable x one way is to manually create a test case for covering the pattern is to introducemultiple threads reading writing xconcurrently which increases the chance of exhibiting the pattern .
furthermore explicit thread control like thread yield sleep and so on could be used to enforce certain ordering of reading writing the variable according to the pattern.
we do acknowledge that this could be time consuming and labor intensive.
second itis difficult in general to estimate the total number of feasiblepatterns.
the estimation in def.
is based on a simple staticanalysis and thus may be far from accurate.
knowing moreprecisely whether certain patterns are possible requires us toperform more complicated static analysis which will be left authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to future work.
lastly maptest s employs some heuristics e.g.
the one from covcon to achieve high map coverage which may or may not work in general.
threats to validity.
the above evaluation suffers from two threats to validity.
first while we tried our best to collect benchmark programs the number of programs is limited and thus it is not clear whether our conclusion above extends to other programs.
furthermore it remains to be tested whether maptest performs well on large thread safe classes which have more than a few thousand of lines of code.
as other classes may interact indirectly with a given class the scope of the analysis may need to be extended to several classes or packages.
second although we tried our best to eliminate bugs in our implementation or effect of randomness we cannot be completely sure.
vi.
r ela ted work this work is closely related to work on code coverage criteria for multi threaded programs.
covcon generates test cases which are likely to cover these uncovered method pairs by analyzing the recorded executions to extract method pairs that are frequently executed.
consuite statically analyzes the set of thread interleavings and examines the record of executions to check if a particular thread interleaving is covered.
consuite then applies genetic algorithms to generate tests that can cover more interleaving.
autocontest considers calling context information dynamically and iteratively computes the coverage requirements generates sequential tests based on sequential coverage and assembles sequential tests into concurrent tests.
hapset is a coverage guided concurrency testing algorithm.
the idea is to gather the ordering constraints in the program and to guide the testing of the program through analyzing the constraints.
tsa aims to achieve high synchronization coverage of concurrent programs by generating thread scheduling to cover uncovered coverage requirements.
yang et al.
proposed a def use pair coverage based on all du path coverage.
kena et al.
proposed a method to deriving new coverage metrics for testing concurrent software based on existing dynamic or static analysis approaches such as eraser and goldilocks .
they expanded multiple existing concurrent test coverage metrics e.g.
concurpairs definition use coverage and synchronisation pair coverage.
our work is different from the above work as we proposed a new coverage criterion called map coverage.
map coverage is more abstract than thread interleaving coverage and is more bug related than method pair coverage.
the experiment results show that maptest works more effectively than state of theart approaches.
this work is broadly related to work on detecting concurrency bugs .
research on concurrency bug detection usually focuses on three sub problems i.e.
how to improve the efficiency of the detection how to improve the effectiveness of the detection and how to reduce false positives.
happens before analysis andlockset algorithms are classic approaches for concurrency bug detection which are widely used to detect bugs of concurrent programs.
for instance racechecker is a data race detector which uses happens before relation to prune infeasible races before reporting potential races to be verified.
eraser proposed a lockset algorithm to detect bugs in lock based multi threaded programs by monitoring every shared memory