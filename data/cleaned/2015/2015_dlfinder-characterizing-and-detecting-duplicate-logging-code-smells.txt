dlfinder characterizing and detecting duplicate logging code smells zhenhao li tse hsun peter chen jinqiu yang and weiyi shang department of computer science and software engineering concordia university montreal canada lzhenha peterc jinqiuy shang encs.concordia.ca abstract developers rely on software logs for a wide variety of tasks such as debugging testing program comprehension verification and performance analysis.
despite the importance of logs prior studies show that there is no industrial standard on how to write logging statements.
recent research on logs often only considers the appropriateness of a log as an individual item e.g.
one single logging statement while logs are typically analyzed in tandem.
in this paper we focus on studying duplicate logging statements which are logging statements that have the same static text message.
such duplications in the text message are potential indications of logging code smells which may affect developers understanding of the dynamic view of the system.
we manually studied over 3k duplicate logging statements and their surrounding code in four large scale open source systems hadoop cloudstack elasticsearch and cassandra.
we uncovered five patterns of duplicate logging code smells.
for each instance of the code smell we further manually identify the problematic i.e.
require fixes and justifiable i.e.
do not require fixes cases.
then we contact developers in order to verify our manual study result.
we integrated our manual study result and developers feedback into our automated static analysis tool dlfinder which automatically detects problematic duplicate logging code smells.
we evaluated dlfinder on the four manually studied systems and two additional systems camel and wicket.
in total combining the results of dlfinder and our manual analysis we reported problematic code smell instances to developers and all of them have been fixed.
keywords log code smell duplicate log static analysis empirical study i. i ntroduction software logs are widely used in software systems to record system execution behaviors.
developers use the generated logs to assist in various tasks such as debugging testing program comprehension system verification and performance analysis .
a logging statement i.e.
code that generates a log contains a static message to be recorded variables and log verbosity level.
as an example a logging statement may be written as logger .error interrupted while waiting for fencing command cmd .
in this example the static text message is interrupted while waiting for fencing command and the dynamic message is from the variable cmd which records the command that is being executed.
the logging statement is at the error level which is the level for recording failed operations .
even though developers have been analyzing logs for decades there exists no industrial standard on how... catch alreadyclosedexception closedexception s logger.warn connection to amqp service is lost.
catch connectexception connectexception s logger.warn connection to amqp service is lost.
... fig.
.
an example of duplicate logging code smell that we detected in cloudstack.
the duplicate logging statements in the two catch blocks contain insufficient information e.g.
no exception type or stack trace to distinguish what may be the occurred exception.
to write logging statements .
prior studies often focus on recommending where logging statements should be added into the code i.e.
where to log and what information should be added in logging statements i.e.
whatto log .
a few recent studies aim to detect potential problems in logging statements.
however these studies often only consider the appropriateness of one single logging statement as an individual item while logs are typically analyzed in tandem .
in other words we consider that the appropriateness of a log is also influenced by other logs that are generated in system execution.
in particular an intuitive case of such influence is duplicate logs i.e.
multiple logs that have the same text message.
even though each log itself may be impeccable duplicate logs may affect developers understanding of the dynamic view of the system.
for example as shown in figure there are two logging statements in two different catch blocks which are associated with the same try block.
these two logging statements have the same static text message and do not include any other error diagnostic information.
thus developers cannot easily distinguish what is the occurred exception when analyzing the produced logs.
since developers rely on logs for debugging and program comprehension such duplicate logging statements may negatively affect developers activities in maintenance and quality assurance.
to help developers improve logging practices in this paper we focus on studying duplicate logging statements in the source code.
we conducted a manual study on four largescale open source systems namely hadoop cloudstack elasticsearch and cassandra.
we first used static analysis to identify all duplicate logging statements which are defined as two or more logging statements that have the same static text message.
we then manually studied all the over 3k identified duplicate logging statements and uncovered five ieee acm 41st international conference on software engineering icse .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
section ii identifying duplicate logging statementsidenti fied duplicate logsmanual analysispatterns of duplicate log code smells section iii patterns of duplicate logging code smells rq1 evaluate on exisitng systemsproblematic and justifiable cases of duplicate log code smell patterns section iv automatically detecting duplicate logging code smellsdlfinderevaluation results of dlfinderinquirying developers outcome of our studystudy stepsdata rq2 evaluate on new systems rq3 new instances introducedsource code section v an evaluation of dlfinder fig.
.
the overall process of our study.
the term duplicate logging statements is referred as duplicate logs for simplification.
patterns of duplicate logging code smells .
we follow prior code smell studies and consider duplicate logging code smell as a surface indication that usually corresponds to a deeper problem in the system .
however not all of the duplicate logging code smell are problematic and require fixes i.e.
problematic duplicate logging code smells .
in particular context e.g.
surrounding code and usage scenario of logging may play an important role in identifying fixing opportunities.
hence we further categorized duplicate logging code smells into problematic orjustifiable cases.
in addition to our manual analysis we sought confirmation from developers on the manual analysis result for the problematic duplicate logging code smells we reported them to developers for fixing.
for the justifiable ones we communicated with developers for discussion e.g.
emails or posts on developers forums .
we implemented a static analysis tool dlfinder to automatically detect problematic duplicate logging code smells.
dlfinder leverages the findings from our manual study including the uncovered patterns of duplicate logging code smells and the categorization on problematic and justifiable cases.
we evaluated dlfinder on six systems four are from the manual study and two are additional systems camel and wicket .
we also applied dlfinder on the updated versions of the four manually studied systems.
the evaluation shows that the uncovered patterns of the duplicate logging code smells also exist in the two additional systems and duplicate logging code smells may be introduced over time.
an automated approach such as dlfinder can help developers avoid duplicate logging code smells as systems evolve.
in total we reported instances of duplicate logging code smell to developers and all the reported instances are fixed.
figure shows the overall process of this paper.
in summary this paper makes the following contributions we uncovered five patterns of duplicate logging code smells through an extensive manual study on over 3k duplicate logging statements.
we presented a categorization of duplicate logging code smells i.e.
problematic or justifiable based on both our manual assessment i.e.
studying the logging statement and its surrounding code and developers feedback.
we proposed dlfinder a static analysis tool that inte grates our manual study result and developers feedback to detect problematic duplicate logging code smells.
we evaluated dlfinder for both the accuracy and generalization i.e.
on new systems and on the newer versions as systems evolve .
we reported instances of problematic duplicate logging code smells to developers dlfinder is able to detect of them and all of the reported instances are fixed.
paper organization.
the rest of the paper is organized as follows.
section ii describes how we prepare the data for manual study i.e.
duplicate logging statements and the studied systems.
section iii discusses the process and the results of our manual study and also developers feedback on our results.
section iv discusses the implementation details of dlfinder.
section v evaluates dlfinder for both the accuracy and generalization.
section vi discusses the threats to validity of our study.
section vii surveys related work.
finally section viii concludes the paper.
ii.
i dentifying duplica te logging sta tements for manual study in this section we describe how we define duplicate logging statements and how we identify them for conducting a manual study.
we also introduce the studied systems.
definition and how to identify duplicate logging statements.
we define duplicate logging statements as logging statements that have the identical static text messages.
we focus on studying the log message because such semantic information is crucial for log understanding and system maintenance .
as an example the two following logging statements are considered duplicate unable to create a new applicationid in subcluster subclusterid.getid and unable to create a new applicationid in subcluster id.
to prepare for a manual study we identify duplicate logging statements by analyzing the source code with static analysis.
in particular the static text message of each logging statement is built by concatenating all the strings i.e.
constants and values of string variables and abstractions of the non string variables.
we also extract information to support the manual analysis such as the types of variables that are logged and the log level i.e.
fatal error warn info debug o r trace .
log levels represent the verbosity level of the log and can be used to reduce logging overheads in production e.g.
only logging info level or above .
if two or more logging statements have the same static text message they are identified as duplicate logging statements.
we exclude logging statements with only one word in the static text message since those logging statements usually do not contain much static information and are usually used to record the value of a dynamic variable during system execution.
studied systems.
we identify duplicate logging statements from four large scale open source java systems hadoop cloudstack elasticsearch and cassandra which are commonly used in prior studies for log related research .
table i shows the statistics of the studied systems.
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i an overview of the studied systems in our manual study .
system version release date loc num .of num .of num .of med .words med .words logs dup .logs dup .log sets in dup .logs in non dup .logs hadoop .
.
nov. .69m .3k cloudstack .
.
aug. .18m .7k .3k elasticsearch .
.
nov. .12m .7k cassandra .
.
oct. 358k .6k studied systems use the widely used java logging libraries e.g.
log4j and slf4j .
hadoop is a distributed computing framework which is composed of four subsystems hadoop common hadoop distributed file system y arn and mapreduce.
cloudstack is a cloud computing platform elasticsearch is a distributed search engine and cassandra is a nosql database system.
these systems belong to different domains and are well maintained.
in our study we study all java source code files in the main branch of each system and exclude test files since we are more interested in studying duplicate logging statements that may affect log understanding in production.
in general we find that there is a non negligible number of duplicate logging statements in the studied systems to .
the median number of words in the duplicate logging statements are similar to that of non duplicate logging statements i.e.
both range from to words which shows that they have a similar level of semantic information in terms of the number of words .
iii.
p a tterns of duplica te logging code smells in this section we conduct a manual study to uncover patterns of potential code smells that may be associated with duplicate logging statements i.e.
duplicate logging code smells .
similar to prior code smell studies we consider duplicate logging code smells as a surface indication that usually corresponds to a deeper problem in the system .
such duplicate logging code smells may be indications of logging problems that require fixes.
furthermore we categorize each code smell instance as either problematic i.e.
require fixes or justifiable i.e.
do not require fixes by understanding the surrounding code.
not every duplicate logging code smell is problematic.
intuitively one needs to consider the code context to decide whether a code smell instance is problematic and requires fixes.
as shown in prior studies logging decisions such as log messages and log levels are often associated with the structure and semantics of the surrounding code.
in addition to the manual analysis by the authors we also ask for developers feedback regarding both the problematic and justifiable cases.
by providing a more detailed understanding of code smells we may better assist developers to improve logging practices and inspire future research.
manual study process.
we conduct a manual study by analyzing all the duplicate logging statements identified from the studied systems.
in total we studied sets of duplicate logging statements in the four studied systems more than 3k logging statements in total each set contains two or more logging statements with the same static message .the process of our manual study involves five phases phase i the first two authors manually studied randomly sampled based on confidence level and confidence interval sets of duplicate logging statements and the surrounding code to derive an initial list of duplicate logging code smell patterns.
all disagreements were discussed until a consensus was reached.
phase ii the first two authors independently categorized allof the sets of duplicate logging statements to the derived patterns in phase i. we did not find any new patterns in this phase.
the results of this phase have a cohens kappa of .
which is a substantial level of agreement .
phase iii the first two authors discussed the categorization results obtained in phase ii.
all disagreements were discussed until a consensus was reached.
phase iv the first two authors further studied all logging code smell instances that belong to each pattern in order to identify justifiable cases of the logging code smell that may not need fixes.
the instances that do not belong to the category of justifiable are considered potentially problematic and may require fixes.
phase v we verified both the problematic instances of logging code smells and the justifiable ones with the developers by creating issue reports and pull requests sending emails or posting our findings on developers forums such as stack overflow.
in particular we reported every instance that we believe to be problematic i.e.
require fixes .
we also reported a number of instances for each justifiable category.
results.
in total we uncovered five patterns of duplicate logging code smells.
table ii lists the uncovered code smell patterns and the corresponding examples.
table iii shows the number of problematic code smell instances for each pattern.
below we discuss each pattern according to the following template description a description of the pattern of duplicate logging code smell.
example an example of the pattern.
code smell instances discussions on the code smell instances that we manually found.
we also discuss the justifiable cases if we found any.
developers feedback a summary of developers feedback on both the problematic and justifiable cases.
pattern inadequate information in catch blocks ic .
description.
developers usually rely on logs for error diagnostics when exceptions occur .
however we find that sometimes duplicate logging statements in different catch authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii pa tterns of duplica te logging code smells and corresponding examples .
name example inadequate information in catch blocks ic inconsistent error diagnostic information ie log message mismatch lm inconsistent log level il duplicate log in polymorphism dp authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii number of problema tic instances verified by our manual study and developers feedback prob.
and total number of instances total including non problema tic instances .
ic ie lm il dp prob.
total prob.
total prob.
total prob.
total prob.
total hadoop cloudstack elasticsearch cassandra total 1developers acknowledged the problem but we did not report all the instances because systematic refactoring of dp would require supports from logging libraries.
blocks of the same tryblock may cause debugging difficulties since the logs fail to tell which exception occurred.
example.
as shown in table ii in the paramprocessworker class in cloudstack the tryblock contains two catch blocks however the log messages in these two catch blocks are identical.
since both the exception message and stack trace are not logged once one of the two exceptions occurs developers may encounter difficulties in finding the root causes and determining the occurred exception.
code smell instances.
after examining all the instances of ic we find that all of them are potentially problematic that require fixes.
for all the instances of ic none of the exception type exception message and stack trace are logged.
developers feedback.
we reported all the problematic instances of ic instances by using pull requests.
all the pull requests were accepted by developers and the fixes were integrated to the studied systems.
developers agree that ic will cause confusion and insufficient information in the logs which may increase the difficulties of error diagnostics.
pattern inconsistent error diagnostic information ie .
description.
we find that sometimes duplicate logging statements for documenting exceptions may contain inconsistent error diagnostic information e.g.
one logging statement records the stack trace and the other does not even though the surrounding code is similar.
example.
as shown in table ii the two classes create portforwarding rulecmd and create firewall rulecmd in cloudstack have similar functionalities.
the two logging statements have the same static text message and are in methods with identical names i.e.
create not shown due to space restriction .
the create method in create portforwarding rulecmd is about creating rules for port forwarding and the method increate firewall rulecmd is about creating rules for firewalls.
these two methods have very similar code structure and business logic.
however the two logging statements record different information one records the stack trace information and the other one only records the exception message i.e.
ex.getmessage .
since the two logging statements have similar context the error diagnostic information recorded by the logs may need to be consistent for the ease of debugging.
we reported this example which is now fixed to have consistent error diagnostic information.code smell instances.
as shown in table iii we find instances of ie and four of them are considered problematic based on our understanding.
from the remaining instances of ie we find three justifiable cases that may not require fixes.
justifiable case ie.
duplicate logging statements record general and specific exceptions .
for instances of ie we find that the duplicate logging statements are in the catch blocks of different types of exception.
in particular one duplicate logging statement is in the catch block of a generic exception i.e.
the exception class in java and the other one is in thecatch block of a more specific exception e.g.
applicationspecific exceptions such as cloudruntimeexception .
in all the cases we find that one log would record the stack trace forexception and the duplicate log would only record the type of the occurred exception e.g.
by calling e.getmessage for a more specific exception.
the rationale may be that generic exceptions once occurred are often not expected by developers so it is important that developers log more error diagnostic information.
justifiable case ie.
duplicate logging statements are in the same catch block for debugging purposes .
for instances of ie we find that the duplicate logging statements are in the same catch block and developers intention is to use a duplicate logging statement at debug level to record rich errordiagnostic information such as stack trace and the log level of the other logging statement could be error .
the extra logging statements at debug level help developers debug the occurred exception and reduces logging overhead in production i.e.
logging statements at debug level are turned off .
justifiable case ie.
having separate error handling classes .
for instances we find that the error diagnostic information is handled by creating an object of an errorhandling class.
as an example from cloudstack public final class libvirtcreatecommandwrapper ... catch final cloudruntimeexception e s logger.debug failed to create volume e.tostring return new createanswererrorhandler command e ... public class kvmstorageprocessor ... catch final cloudruntimeexception e s logger.debug failed to create volume e return new copycmdanswererrorhandler e.tostring ... in this example extra logging is added by using errorhandling classes i.e.
createanswererrorhandler and copycmdanswererrorhandler to complement the logging statements.
as a consequence the actual logged information is consistent in these two methods one method records e.tostring in the logging statement and records the exception variable ethrough an error handling class the other method records ein the logging statement and records e.tostring through an error handling class.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
developers feedback.
we reported all the instances of ie four in total that we consider problematic to developers as pull requests all of which are accepted by developers.
moreover we ask developers whether our conjecture was correct for each of the justifiable cases of ie.
we received positive feedback that confirms our manual analysis on the justifiable cases.
pattern log message mismatch lm .
description.
we find that sometimes after developers copy and paste a piece of code to another method or class they may forget to change the log message thus resulting in duplicate logging statements that record inaccurate system behaviors.
example.
as an example in table ii the method doscaledown is a code clone of doscaleup with very similar code structure and minor syntactical differences.
however developers forgot to change the log message in doscaledown after the code was copied from doscaleup i.e.
both log messages contain scaling up .
such instances of lm cause confusion when developers analyze the logs.
code smell instances.
we find that there are instances of lm that are caused by copying and pasting the logging statement to new locations without proper modifications.
for all the instances the log message contains words of incorrect class or method name that may cause confusion when analyzing logs.
developers feedback.
developers agree that the log messages in lm should be changed in order to correctly record the execution behavior i.e.
update the copy and pasted log message to contain the correct class method name .
we reported all the instances of lm that we found through pull requests and all of the reported instances are now fixed.
pattern inconsistent log level il .
description.
log levels e.g.
fatal error info debug o rtrace allow developers to specify the verbosity of the log message and to reduce logging overhead when needed e.g.
debug is usually disabled in production .
a prior study shows that log level is frequently modified by developers in order to find the most adequate level.
we find that there are duplicate logging statements that even though the log messages are exactly the same the log levels are different.
example.
in the il example shown in table ii the two methods which are from the same class compactionmanager have very similar functionality i.e.
both try to perform cleanup after compaction but we find that the log levels are different in these two methods.
code smell instances.
we find three justifiable cases in il that may be developers intended behavior.
we do not find problematic instances of il after communicating with developers developers think the problematic instances identified by our manual analysis may not be problems.
justifiable case il.
duplicate logging statements are in the catch blocks of different types of exception .
similar to what we observed in ie we find that for instances the log level for a more generic exception is usually more severe e.g.
error level for the generic java exception and info level foran application specific exception .
generic exceptions may be more unexpected to developers so developers may use a log level of higher verbosity e.g.
error level to record exception messages.
justifiable case il.
duplicate logging statements are in different branches of the same method .
there are instances belong to this case.
below is an example from elasticsearch where a set of duplicate logging statements may occur in the same method but in different branches.
if lifecycle.stoppedorclosed logger.trace failed to send ping transport message e else logger.warn failed to send ping transport message e in this case developers already know the desired log level and intend to use different log levels due to the difference in execution i.e.
in the if else block .
justifiable case il.
duplicate logging statements are followed by error handling code .
there are instances that are observed to have such characteristics in a set of duplicate logging statements some statements have log levels of higher verbosity and others have log levels of lower verbosity.
however the duplicate logging statement with lower verbosity log level is followed by additional error handling code e.g.
throw a new exception e .
therefore the error is handled elsewhere i.e.
the exception is re thrown and may be recorded at a higher verbosity log level.
developers feedback.
in all the instances of il that we found developers think that il may not be a problem.
in particular developers agreed with our analysis on the justifiable cases.
however developers think the problematic instances of il from our manual analysis may also not be problems.
we concluded the following two types of feedback from developers on the suspect instances of il i.e.
problematic ones from our manual analysis out of the instances of il .
the first type of developers feedback argues the importance of semantics and usage scenario of logging in deciding the log level.
a prior study suggests that logging statements that appear in syntactically similar code but with inconsistent log levels are likely problematic.
however based on developers feedback that we received il still may not be a concern even if the duplicate logging statements reside in very similar code.
a developer indicated that conditions and messages are important but the context is even more important .
as an example both of the two methods may display messages to users.
one method may be displaying the message to local users with a debug logging statement to record failure messages.
the other method may be displaying the message toremote users with an error logging statement to record failure messages problems related to remote procedure calls may be more severe in distributed systems .
hence even if the code is syntactically similar the log level has a reason to be different due to the different semantics and purposes of the code i.e.
referred to as different contexts in developers responses .
future studies should consider both the syntactic authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
structure and semantics of the code when suggesting log levels.
the second type of developers feedback acknowledges the inconsistency.
however developers are reluctant to fix such inconsistencies since developers do not view them as concerns.
for example we reported the instance of il that we discussed in table ii to the developer.
the developer replied i think it should probably be an error level and i missed it in the review could make an argument either way i do not feel strongly that it should be error level vs info level.
our opinions i.e.
from us and prior studies differ from that of developers regarding whether such inconsistencies are problematic.
on one hand whether an instance of il is problematic or not can be subjective.
this shows the importance of including perspectives from multiple parties e.g.
user studies discussions with developers in future studies of software logging practice.
on the other hand the discrepancy also indicates the need of establishing a guidance for logging practice and further even enforcing such standard.
pattern duplicate logging statements in polymorphism dp .
description.
classes in object oriented languages are expected to share similar functionality if they inherit the same parent class or if they implement the same interface i.e.
polymorphism .
since log messages record a higher level abstraction of the program we find that even though there are no clones among a parent method and its overridden methods such methods may still contain duplicate logging statements.
such duplicate logging statements may cause maintenance overhead.
for example when developers update one log message he she may forget to update the log message in all the other sibling classes.
inconsistent log messages may cause problems during log analysis .
example.
as shown in table ii the two classes powershellfencer and shellcommandfencer i n hadoop both extend the same parent class and implement the same interface.
these two classes share similar behaviors.
the inherited methods in the two classes have the identical log message.
however as the system evolves developers may not always remember to keep the log messages consistent in the two inherited methods which may cause problems during system debugging understanding and analysis.
code smell instances.
we find that all the instances of dp are potentially problematic that may be fixed by refactoring.
in most of the instances the parent class is an abstract class and the duplicate logs exist in the overridden methods of the subclasses.
we also find that in most cases the overridden methods in the subclasses are very similar with minor differences e.g.
to provide some specialized functionality which may be the reason that developers use duplicate logging statements.
developers feedback.
developers generally agree that dp is associated with logging code smells and specific refactoring techniques are needed.
one developer comments that you want to care about the logging part of your code base in the same way as you do for business logic code one can argue it is part of it so salute dry do not repeat yourself .
resolving dp often requires systematic refactoring.
however to the best of our knowledge current java logging frameworks such as slf4j and log4j do not support refactoring logging statements.
the way to resolve dp is to ensure that the log message of the parent class can be reused by the subclasses e.g.
storing the log message in a static constant variable.
we received similar suggestions from developers on how to refactor dp such as adding a method in the parent class that generates the error text for that case logger .error notaccessible field.getname or creat your own exception classes and put message details in them .
however we find that without supports from logging frameworks even though developers acknowledged the issue of dp they do not want to manually fix the code smells.
similar to some code smells studied in prior research developers may be reluctant to fix dp due to additional maintenance overheads but limited supports i.e.
need to manually fix hundreds of dp instances .
in short logging frameworks should provide better support to developers in creating log templates that can be reused in different places in the code .
we manually uncovered five patterns of duplicate logging code smells and six justifiable cases for the ie and il pattern where the code smell instances may not need fixes.
in total our study helped developers fix problematic duplicate logging code smells in the studied systems.
iv .
dlf inder a utoma tically detecting problema tic duplica te logging code smells the manual study uncovers five patterns of duplicate logging code smells and also provides guidance in identifying problematic logging code smells that require fixes.
to help developers detect such problematic code smells and improve logging practices we propose an automated approach specifically a static analysis tool called dlfinder.
dlfinder uses abstract syntax tree ast analysis data flow analysis and text analysis.
below we discuss how dlfinder detects each pattern of duplicate logging code smell.
detecting inadequate information in catch blocks ic .
dlfinder first locates the try catch blocks that contain duplicate logging statements.
specifically dlfinder finds the catch blocks of the same try block that catch different types of exceptions and these catch blocks contain the same duplicate logging statement.
then dlfinder uses data flow analysis to analyze whether the handled exceptions in the catch blocks are logged e.g.
record the exception message .
dlfinder detects an instance of ic if none of the logs in the catch blocks record either the stack trace or the exception message.
detecting inconsistent error diagnostic information ie .
dlfinder first identifies all the catch blocks that contain duplicate logging statements.
then for each catch block dlfinder uses data flow analysis to determine how the exception is logged by analyzing the usage of the exception variable in the logging statement.
the logging statement records the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
entire stack trace only the exception message or nothing at all.
then dlfinder compares how the exception variable is used recorded in each of the duplicate logging statements.
dlfinder detects an instance of ie if a set of duplicate logging statements that appear in catch blocks has an inconsistent way of recording the exception variables e.g.
the log in one catch block records the entire stack trace and the log in another catch block records only the exception message while the two catch blocks handle the same type of exception .
note that for each instance of ie the multiple catch blocks with duplicate logging statements in the same set may belong to different try blocks.
in addition dlfinder decides if an instance of ie belongs to one of the three justifiable cases ie.
ie.
.
if so the instance is marked as potentially justifiable and thus excluded by dlfinder.
detecting log message mismatch lm .
lm is about having an incorrect method or class name in the log message e.g.
due to copy and paste errors .
hence dlfinder analyzes the text in both the log message and the class method name i.e.
concatenation of class name and method name to detect lm by applying commonly used text analysis approaches .
dlfinder detects instances of lm using four steps for each logging statement dlfinder splits class method name into a set of words i.e.
name set and splits log message into a set of words i.e.
log set by leveraging naming conventions e.g.
camel cases and converting the words to lower cases.
dlfinder applies stemming on all the words using porter stemmer .
dlfinder removes stop words in the log message for each system.
we find that there is a significant number of words that are generic across the log messages in a system e.g.
on with and process .
hence we obtain the stop words by finding the top most frequent words each of our four studied systems has an average of unique words in the static text messages across all log messages in a system .
for every logging statement between the name set i.e.
from the class method name and its associated log set dlfinder counts the number of common words shared by both sets.
afterward dlfinder detects an instance of lm if the number of common words is inconsistent among the duplicate logging statements in one set.
for the lm example shown in table ii the common words shared by the first pair i.e.
method doscaleup and its log are scale up while the common word shared by the second pair is scale .
hence dlfinder detects an lm instance due to this inconsistency.
the rationale is that the number of common words between the class method name and the associated logging statement is subject to change if developers make copy and paste errors on logging statements e.g.
copy the logging statement in doscaleup to method doscaledown but forget to update the log message to match with the new method name doscaledown .
however the number of common words will remain unchanged i.e.
no inconsistency if the logging statement after being pasted at a new location is updated respectively.
detecting inconsistent log level il .
dlfinder detects an instance of il if duplicate logging statements in one set i.e.
have the same static text message have inconsistent log level.
furthermore dlfinder checks whether an instance of il belongs to one of the three justifiable cases il.
il.
.
if so the instance is marked as justifiable and dlfinder excludes this instance in the detection result.
detecting duplicate logs in polymorphism dp .
dlfinder generates an object inheritance graph when statically analyzing the java code.
for each overridden method dlfinder checks if there exist any duplicate logging statements in the corresponding method of the sibling and the parent class.
if there exist such duplicate logging statements dlfinder detects an instance of dp .
note that based on the feedback that we received from developers section iii we do not expect developers to fix instances of dp .
dp instances can be viewed more as technical debts and our goal is to propose an approach to detect dp instances to raise developers awareness regarding this issue.
v. a nev alua tion of dlf inder we evaluate our tool by answering three research questions.
rq1 how well can dlfinder detect duplicate logging code smells in the four manually studied systems?
we applied dlfinder on the same versions of the systems that we used in our manual study section iii .
since we obtain the ground truth i.e.
problematic code smells in these four systems from our manual study the goal of this rq is to evaluate the detection accuracy of dlfinder.
we calculated the precision and recall of dlfinder in detecting problematic duplicate logging code smells.
precision is the percentage of problematic code smell instances among all the detected instances and recall is the percentage of problematic code smell instances that dlfinder is able to detect.
the first five rows of table iv show the results of rq1.
note that all the numbers in table iv do not contain instances of justifiable cases since dlfinder focuses on detecting problematic ones and excludes the justifiable cases.
for the patterns of ic ie and dp dlfinder detects all the problematic instances of duplicate logging code smells in recall with a precision of .
for the il pattern since we do not find any problematic instances as discussed in section iii both of the columns of problematic instances in ground truth pro.
and detected t.det.
in table iv are .
for the lm pattern dlfinder achieves a recall of .
i.e.
dlfinder detects problematic lm instances .
we manually investigate the six instances of lm that dlfinder cannot detect.
we find that the problem is related to typos in the log message.
for example developers may write mlockall instead of mlockall .
hence the text in the log message cannot be matched with the method name when we split the word using camel cases.
the precision of detecting problematic lm instances is modest because in many false positive cases the log messages and class method names are at different levels of abstraction the log message describes a local code block while the class method name describes the functionality of the entire method.
for example encodepublickey and encodeprivatekey both contain the duplicate authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iv the results of dlf inder in rq1 and rq2.
i ne a c hp a t t e r n pro.
is the number of problema tic instances as the ground truth det.
is the number of instances detected by dlf inder and t .det.
is the number of true problema tic instances detected by dlf inder .
research ic ie lm il dp questions pro.
t.det.
det.
pro.
t.det.
det.
pro.
t.det.
det.
pro.
t.det.
det.
pro.
t.det.
det.
rq1 applying dlfinder on the same software versions as the manual studyhadoop cloudstack elasticsear ch cassandra precision recall .
.
n a rq2 applying dlfinder on new systemscamel wicket precision recall .
.
n a total logging statement unable to create keyfactory .
the duplicate logging statement describes a local code block that relates to usage of the keyfactory class which is different from the major functionalities of the two methods i.e.
as expressed by their class method names .
nevertheless dlfinder detects the lm instances with a high recall and developers may quickly go through the results to identify the true positives it took the first two authors less than minutes on average to go through the lm result of each system to identify true positives .
in the future we plan to improve the precision of dlfinder by adopting a ranking mechanism based on estimating whether the log message and class method name are at a similar level of abstraction e.g.
both describe the major functionality of a method .
moreover we plan to find a better summarization of the surrounding code of the logging statements by utilizing the state of the art research on code summarization .
rq2 how well can dlfinder detect duplicate logging code smells in the additional systems?
the goal of this rq is to study whether the uncovered patterns of duplicate logging code smells are generalizable to other systems.
we applied dlfinder on two additional systems that are not included in the manual study in section iii camel .
.
released on apr.
and wicket .
.
released on may which are both large scale open source java systems .7m and 380k loc respectively for message routing and web application development.
similar to our manual study the first two authors of this paper manually collect the problematic duplicate logging code smells in the additional systems i.e.
the ground truth used for calculating the precision and recall of dlfinder.
note that the collected ground truth of the two additional systems is only used in this evaluation but not in designing the patterns in dlfinder.
there are also no new patterns found in this process.
the sixth to eighth rows in table iv show the results of the two additional systems.
in total we found problematic code smell instances dlfinder detected in these two systems and all of them are fixed.
compared to the four systems in rq1 dlfinder has similar precision and recall values in the two additional systems.
similar to what we found in rq1 dlfinder cannot detect some lm instances due to typos in log message.
dlfinder detected three instances of il in camel however with the manual investigation and getting developers feedback these il instances are not problematic.
similar to what we discussed in section iii the differences in the log level are related to having different semantics in the code.table v the result of rq3 applying dlf inder to the newer versions of the studied systems .g ap.shows the dura tion of time in days between the original org.
and the newer release new.
releases ic ie lm il dp org.
new.
gap.
hadoop .
.
.
.
cloudstack .
.
.
.
elasticsearch .
.
.
.
cassandra .
.
.
.
total different from a prior study we found that all il instances are not problematic in the six evaluated systems.
future studies are needed to investigate the effect of il.
dlfinder detects dp instances with in recall and precision however we do not report them since developers are reluctant to fix them due to limited support from logging framework as discussed in section iii .
nevertheless the patterns of duplicate logging code smells that we uncovered can still be found in other systems.
rq3 are new code smell instances introduced over time?
we applied dlfinder on the latest versions of the four studied systems i.e.
hadoop cloudstack elasticsearch and cassandra.
we then compared the results with the ones on previous versions.
the gaps of days between the manually studied versions and the new versions vary from days to days.
table v shows that new instances of code smells are introduced during software evolution.
these detected code smell instances are all problematic and are all reported and fixed except for dp .
as mentioned in section iii and iv our goal of detecting dp is to show developers the logging technical debt in their systems.
in short we found that duplicate logging code smells are introduced over time and an automated approach such as dlfinder can help developers avoid duplicate logging code smells as the system evolves.
dlfinder is able to detect problematic code smell instances in the four manually studied systems and two additional systems.
the code smell patterns of dlfinder i.e.
uncovered from our manual study also exist in new systems and dlfinder can detect new code smell instances that are introduced as systems evolve.
vi.
t hrea ts to validity internal validity.
we define duplicate logging statements as two or more logging statements that have the same static authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
text message.
we were able to uncover five patterns of duplicate logging code smells and detect many code smell instances.
however logging statements with non identical but similar static texts may also cause problems to developers.
future studies should consider different types of duplicate logging statements e.g.
logs with similar text messages .
we conducted manual studies to uncover the patterns of code smells and study their potential impact.
to avoid biases two of the authors examine the data independently.
for most of the cases the two authors reach an agreement.
any disagreement is discussed until a consensus is reached.
in order to reduce the subjective bias from the authors we have contacted the developers to confirm the uncovered patterns and their impact.
external validity.
we conducted our study on four largescale open source systems in different domains.
we found that our uncovered patterns and the corresponding problematic and justifiable cases are common among the studied systems.
however our finding may not be generalizable to other systems.
hence we studied whether the uncovered patterns exist in two other systems.
we found that the patterns of code smells also exist in these two systems and we did not find any new code smell patterns in our manual verification.
our studied systems are all implemented in java so the results may not be generalizable to systems in other programming languages.
future studies should validate the generalizability of our findings in systems in other programming languages.
vii.
r ela ted work empirical studies on logging practices.
there are several studies on characterizing the logging practices in software systems .
y uan et al .
conducted a quantitative characteristics study on log messages for large scale open source c c systems.
chen et al .
replicated the study by y uan et al .
on java open source projects.
both of their studies found that log message is crucial for system understanding and maintenance.
fu et al .
studied where developers in microsoft add logging statements in the code and summarized several typical logging strategies.
they found that developers often add logs to check the returned value of a method.
different from prior studies in this paper we focus on manually understanding duplicate logging code smells.
we also discuss potential approaches to detect and fix these code smells based on different contexts i.e.
surrounding code .
improving logging practices.
zhao et al .
proposed a tool that determines how to optimally place logging statements given a performance overhead threshold.
zhu et al .
provided a tool for suggesting log placement using machine learning techniques.
y uan et al .
proposed an approach that can automatically insert additional variables into logging statements to enhance the error diagnostic information.
chen et al .
concluded five categories of logging anti patterns from code changes and implemented a tool to detect the antipatterns.
hassani et al .
identified seven root causes of the log related issues from log related bug reports.
compared to prior studies we study logging code smells that may be caused by duplicate logs with a goal to help developers improvelogging code.
the logging problems that we uncovered in this study are not discovered by prior work.
we conducted an extensive manual study through obtaining a deep understanding on not only the logging statements but also the surrounding code whereas prior studies usually only look at the problems that are related to the logging statement itself.
code smells.
code smells can be indications of bad design and implementation choices which may affect software systems maintainability understandability and performance .
to mitigate the impact of code smells studies have been proposed to detect code smells .
duplicate code or code clones is a kind of code smells which may be caused by developers copying and pasting a piece of code from one place to another .
such code clones may indicate quality problems.
there are many studies that focus on studying and detecting code clones .
in this paper we study duplicate logging code smells which are not studied in prior duplicate code studies.
in fact in our manual study we found that many duplicate logging statements may not be related to code clones.
future studies may further investigate the relationship between duplicate code and duplicate logging statements.
viii.
c onclusion duplicate logging statements may affect developers understanding of the system execution.
in this paper we study over 3k duplicate logging code statements in four large scale open source systems hadoop cloudstack elasticsearch and cassandra .
we uncover five patterns of duplicate logging code smells.
further we assess the impact of each code smell and find not all are problematic and need fixes.
in particular we find six justifiable cases where the uncovered patterns of duplicate logging code smells may not be problematic.
we received confirmation from developers on both the problematic and justifiable cases.
combining our manual analysis and developers feedback we developed a static analysis tool dlfinder which automatically detects problematic duplicate logging code smells.
we applied dlfinder on the four manually studied systems and two additional systems.
in total we reported problematic code smell instances in the six studied systems to developers and all of them are fixed.
dlfinder successfully detects out of the instances.
our study highlights the importance of the context of the logging code i.e.
the nature of logging code is highly associated with both the structure and the functionality of the surrounding code.
future studies should consider the code context when providing guidance to logging practices.
in addition more advanced logging libraries are needed to help developers improve logging practice and to avoid logging code smells.