break the dead end of dynamic slicing localizing data and control omission bug yun lin national university of singapore singaporejun sun singapore university of technology and design singaporelyly tran singapore university of technology and design singapore guangdong bai singapore institute of technology singaporehaijun wang nanyang technological university singaporejinsong dong national university of singapore singapore abstract dynamic slicing is a common way of identifying the root cause whenaprogramfaultisrevealed.withthedynamicslicingtechnique the programmers can follow data and control flow along the program execution trace to the root cause.
however the technique usually fails to work on omission bugs i.e.
the faults which are causedbymissingexecutingsomecode.inmanycases dynamic slicingover skipstherootcausewhenanomissionbughappens leading the debugging process to a dead end.
in this work we conduct an empirical study on the omission bugs in the defects4j bug repository.ourstudyshowsthat omissionbugsareprevalent .
among all the studied bugs there are repeating patterns on causes and fixes of the omission bugs the patterns of fixing omission bugs serve as a strong hint to break the slicing dead end.
based on our findings we train a neural network model on the omission bugs in defects4j repository torecommend where to approach when slicing can no long work.
we conduct an experiment byapplyingourapproachon3193mutatedomissionbugswhich slicingfailstolocate.theresultsshowthatourapproachoutperforms random benchmark on breaking the dead end and localizing the mutated omission bugs .
over .
.
ccs concepts software and its engineering software testing and debugging maintaining software keywords debugging program slice omission error empirical study acm reference format yun lin jun sun lyly tran guangdong bai haijun wang and jinsong dong.
.breakthedeadendofdynamicslicing localizingdataand controlomissionbug.in proceedingsofthe201833rdacm ieeeinternational conference on automated software engineering ase september montpellier france.
acm new york ny usa 11pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september montpellier france association for computing machinery.
acm isbn ... .
introduction a software fault is observed when the defect is propagated from the root cause through control and data flow.
in order to track the fault back to its root cause programmers usually need to trace throughincorrectdataandcontrolflowtolocatethebug.fromthis perspective dynamicslicingisausefulandefficientapproachfor debugging.
each time a programmer finds an unexpected step or a step with variable of incorrect value he or she can apply dynamic slicing to locate the step responsible for it.
however dynamicslicingcanonlytrackthroughtheexecuted code.
it means that it cannot locate bugs caused by missing executingsomecode i.e.
theomissionbug .whenanomissionbug happens dynamicslicingstartswithastepwithincorrectdataor controlflowandstopsatastepwhereeverythingiscorrect causing adead end where slicing can no longer work.
many research work have been proposed toenhancedynamicslicingforlocatingomissionbugs.zhanget al.
first proposed a force execution technique to include more results than reported by dynamicslicing.
in their approach they force the program to exercise the branches of unexecuted code toexposeimplicitdependenciesamongexecutedandunexecuted code.similartotheirwork wangetal.
proposedtheirrelevant slicing algorithm on java byte code trace aiming to include the relevant unexecuted code into the slicing result.
in recent years sakuaietal.
enhancedzhangandwang swork with point to analysis technique.
however all the above approaches have an underlying assumption that the unexecuted code exist in the project i.e.
executionomission so that they can analyze the source code and alter thecontrol flow towards them.
such an assumption may not always hold in practice.
our empirical study see section shows that the miss executed code in most of omission bugs does not exist in the project i.e.
code omission .
in this work we aim to understand omission bugs in a more fundamentalway.wewouldliketoanswerthequestionlikehow prevalenttheomissionbugsare howtheyarecaused andwhether they share some patterns guiding us to automate their localization.
to this end we conduct an empirical study on omission bugs in defects4j bug repository.
first we confirm that omission bugs are prevalent indeed which accounts for .
of our checked bugs.
second we find that the omission bugs caused by incorrect data and control flow are very different in terms of their causes and difficulty of being localized.
lastly we observe that the number of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yun lin jun sun lyly tran guangdong bai haijun wang and jinsong dong categories for causes of omission bugs are very limited which is a good indication for automating their localization.
basedonourfindings webuildaneuralnetworkmodeltopredict where to break the dead end of an omission bug when slicing can no longer work.
we first collect the training data from the omission bugs in defects4j repository.
based on the most common cause of omission bugs we mutate omission bugs from open source projects the result shows that our model can achieve .
.
and .
predication accuracy for various omission bugs more details at section .
moreover we conduct a simulated debugging experiment which simulates how programmer tracking incorrect data and control flow through slicing to locate those mutated omission bugs.
our results show that equipped with our prediction model for breaking the dead end of dynamic slicing our approach outperforms random benchmark on localizing the mutated omission bugs .
over .
.
inthispaper wemake thefollowingcontributions weconduct an empirical study to comprehensively study the omission bugs in defects4j repository.
we confirm their prevalence provide ataxonomyfortheircauses andshowpatternstopotentiallyguide the automation of their localization.
we build a tool for this empirical study which can visualize compare and apply step wise slicingonthebuggyandfixedtracefordefects4jbugs.
webuild apredictionmodelforbreakingthedeadendofomissionbugwhen slicing can no long work.
we conduct a simulated debugging experiment to confirm the effectiveness of our prediction model.
omission bug concepts and examples inthissection wedefineomissionbugandshowmultipleexamples of them.
first we assume a ground truth version or fixed version ofthebuggyprogramsothatweknowthecorrectnessofitsexecuting steps.
more specifically given a step on the trace of the buggy program weknow whetheritshouldhappen and whether thevalueofanyofitsusedvariablesiscorrect.suchanassumption canbefulfilledinpracticeeitherbyrequiringprogrammer sfeedbackorbycomparingthetracesofbuggyandfixedversionsofa program.inthisregard comparingtothetraditionalomissionerror defined for execution omission i.e.
bug due to missing executing existingcode weextendthedefinitionfroma tracepointof view which includes both execution omission and code omission bug dueto missing somecode .
in thefollowing wenote the kth step on trace as k k n kstarts at .
definition1.
data dependency path.
let beatraceand d and rbetwostepsof suchthat r d.if ddefinesavariable var and rusesvar and theredoesnot existastep kwhered k r such that kdefinesvar we call the path from dto ras adata dependency path with regard to var noted as angbracketleft d u angbracketright .i n addition we call das the data dominator of u. definition .
data omission bug.
given a data dependency path angbracketleft d u angbracketright ifthevalueofvariable varisincorrecton uand correct on d then we say that a data omission bug b happens.
we call the path angbracketleft d u angbracketright asb scritical path and variable varas b scritical variable.
l2 l16 ... ... ...minimum l12... figure critical path of data omission bug data omission bug indicates the critical variable should have been redefined before the end of critical path.example.
listing1shows an example of a data omission bug which comes from the 2nd bug of chart project in defects4j repository.
the bug is caused by missing assigning values to minimum andmaximumvariablesinacornercase line8 .fromadebugging point of view the programmer may observe that the value of minimumvariableisunexpectedtobe infinity atline16andapply dynamic data slicing to reach line where minimumis initialized.
figure1shows the critical path of such a data omission bug.
we note lnasthestepexecutingline n.inthiscriticalpath thecritical variableis minimum.moreover itisadatadependencypathstarts from l2where minimumisdefinedandendsat l16where minimum is used and no step in between l2and l16redefines minimum.
public static range iteratedomainbounds ... double minimum double.positive infinity double maximum double.negative infinity ... if .. for ... for ... if !double.isnan value minimum math.min minimum value maximum math.max maximum value uvalue getendxvalue series item if minimum maximum return null ... listing example of data omission bug definition3.
control dependency path.
giventwosteps c fsuch that c f cexecuting ncand fexecuting nf we call a path from cto fas acontrol dependency path ifnfcontroldepended1onnc and there does not exist a step k c k f executing nkandnfcontrol depends on nk.
we denote the condition of casconand the control dependency path as c f con .i n addition we call cas the control dominator of k. definition4.
control omission bug.
givenacontroldependency path angbracketleft c k angbracketright con i f kshould not happen and cis correct then we say that a control omission bug happens.
we call such a control dependency path angbracketleft c k angbracketright con asbu scritical path.
control omission bug indicates the control flow in between the critical path should have been altered to avoid the step at its end.example.
listing2showsanexampleofacontrolomissionbug which comes from the 3rd bug of math project in defects4j repository.thebugiscausedbymissingthecodetoreturninacorner case line6 .fromadebuggingpointofview theprogrammer may observe that line is unexpectedly executed and he can apply dynamiccontrolslicingtoreachline3wherethecondition len !
1a more detailed definition on static control dependency can be referenced in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
break the dead end of dynamic slicing localizing data and control omission bug ase september montpellier france b.leniscorrectlyevaluatedto false.thecriticalpathofsucha control omission bug is showed in figure .
public double linearcombination ... if len !
b.length throw new dimensionmismatchexception len b.length ... if len return a b final double prodhigh new double double prodlowsum ... listing example of control omission bug l3 l9 ... ... ...len !
b.length l8... figure critical path of control omission bug definition .
occur step and dead end step.
letpbe the criticalpathofacontrolordataomissionbug b whichstartsat s and ends at e we call sand eas the dead end step andoccur stepofbrespectively.
definition6.
break step.
letbbeanomissionbugontrace andthetraceafter bisfixedbe prime.the break step ofbiseither a stepbeforewhichthefixisapplied2or anincorrectstepinbetween the occur step and the dead end step which allows programmers to apply dynamic slicing for approaching the root cause.
example.
figure3shows an example for the first and second condition in definition 6for listing .
in figure the upper trace is buggy and the lower trace primeis obtained from applying the fix.each rectangleindicatesatrace stepanditsname lnmeans the line number nit visits.
the dotted lines represent the matching relation between two traces the solid lines represent the data flow and the dash lines represent the control flow.
in such case l12 the grey rectangle with solid border is regarded as the break step accordingtothefirstcondition asthefixisappliedbeforethisstep.
l3 l3 l12 l8 l9 l10 l11 l12 l16 l16 ... ... ... ...... ... ... ...minimum minimum... l8 figure example of break step now letusassumethatcodeinline8 11oflisting 1hasalready existedinthebuggyversion i.e.
theyarenotthefix and l3isstill thedatadominatorof l16withregardtovariable minimumbecause 2note that it is possible to have more than one fix options for an omission bug in such case we regard the step before which any possible fix option is applied as the break step.
l hg 9huvlrq xjj 9huvlrq 7udfh roohfwlrq hexjjlqj 6lpxodwlrq 7udfh 0dwfklqj5hvxow l hg 7udfh xjj 7udfh 0dwfklqj 5hvxowv figure study setup line9isnotexecuted.asshowedinfigure line8willbeexecuted at l8 which indicates that the condition !double.isnan value is evaluated to be false.
in such case l8is regarded as the break step according to the second condition as it allows us to apply dynamic slicing to further approaching the root cause.
empirical study in order to have a thorough understanding of data and control omission bugs we conduct an empirical study on defects4j repository with the following research questions rq1 howprevalentaretheomissionbugswithregardto all the bugs in repository.
rq2 whatarethemainreasonsforomissionbugsinrepository?
.
study setup identifying omission bugs figure4showshowweprocesseachdefects4jbuginourempirical study.defects4jrepositorydescribeseachbugbyitsbuggyversion its fixed version and the test cases which fail in the buggy version and pass in the fixed version.
given a defects4j bug and its failing test case we first collect the trace of its buggy version and that of its fixed version step .
then we leverage a trace matching technique to align the steps between the buggy trace and the fixed trace step .
with the reference to the fixed trace as indicated by the matching results we can know each step on the buggy trace iseithercorrectorincorrectfromdata readingwrongvariables or control should not happen point of view.
then we simulate programmers debuggingprocessonthebuggytrace step3 .more specifically starting from the end of the buggy trace where the fault is revealed we continuously conduct dynamic data slicing if a step reads incorrect variable and dynamic control slicing if astep should not happen .
after the debugging process stops andthe root cause cannot be located in such a manner we know the dynamic slicing comes to a dead end and it is an omission bug.
.
.
trace collection and matching.
whencollectingtheprogram trace we not only sequentially collect the executed statements we alsobuildthedataandcontroldependenciesforthetracesteps.weimprovedzhang scontrol flowbasedtracematchingalgorithm to make it work on two traces with different source code.
our improvementistomatchtracestepswithregardtothecodechanges.
for example if a ifkeyword is modified to a while the steps influenced by the if condition should be matched to steps in the firstiterationofthewhile loop.
basedonthematchingresult eachsteponthebuggytrace whosesourcecodeisnotmodified canfall into either of the following categories authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yun lin jun sun lyly tran guangdong bai haijun wang and jinsong dong algorithm debugging simulation input a fault revealing step stepfon the buggy trace output a critical path pathc 1stepd stepprev stepf 2whilestepdis not correct and stepd.sourceis not fixed do 3stepprev stepd 4ifstepdis data incorrect then var incorrect variable on stepd stepd data dom stepd var 7else ifstepdis control incorrect then stepd control dom stepd 9end 10ifstepdis correct then 11ifstepprevis data incorrect then var incorrect variable on stepprev return stepd stepprev 14else ifstepprevis control incorrect then con conditional expression on stepd return stepd stepprev con 17end 18else 19returnnull stepd.source is fixed 20end correct the step can be matched with a step on the fixed trace and all its read variables has the same value as its matched step.
data incorrect the step can be matched with a step on the fixed trace and some of its read variable has different value from that of its matched step.
control incorrect the step cannot be matched with any step on the fixed trace.
.
.
debugging simulation.
algorithm 1depicts how our debugging simulation process identify omission bug.
in the debugging process we continuously apply dynamic data or control slicing on the buggy trace until the process goes into a dead end or finds the rootcause.weconsiderthebugisanomissionbugintheformer case.
inalgorithm we startthesimulateddebuggingattheendof thebuggytrace whichiswherethefaultisrevealed.iftheworking step stepd is data incorrect we find its data dominator see definition bydynamicdataslicing line4 .iftheworkingstep iscontrolincorrect wefinditscontroldominator seedefinition by dynamic control slicing line .
the process continues until the working step is correct i.e.
dead end or the source code is modifiedasafix line2 .intheformercase weconsideranomission bug happens.
we record the critical path see definition 2and aseither angbracketleftstepd stepprev angbracketright or angbracketleftstepd stepprev angbracketright con forthe omission bug line .
.
implementation we build an eclipse plugin called tregression to visualize the bugs in defects4j repository.
a snapshot and demo video of our tool is available on its github website .
in our tool we visualize the buggy trace and its fixed trace on left and right panel.
users canclickthesteponeithertraceto checkitsreadandwrittentable overview of omission bug prevalence simulation resultprojecttotalchartclosurelangmathmockitotime omission bugscontrol data localizable bugs14727442015127 discarded bugsnondeterministic013101116 not applicable for slicing017327130 over longtrace07913200112 total variables compare its corresponding step on the other trace and comparethecode beforeand afterthefix.
moreover users can apply dynamic data and control slicing operation on each step.
.
study result .
.
rq1 omission bug prevalence.
table1showsanoverview of omission bugs in defects4j repository.
first 237outof395bugsareapplicableforthisstudy.wediscard bugs because of the following three reasons the bug is a non deterministic program our trace matching algorithm requires stable trace to replay the bug the buggy trace only contain correct step or either the buggy trace or the fixed trace is overlong i.e.
over100ksteps .wejustifydiscardingthebugsdueto the second and third reason as follows.
as for the second reason listing 3shows an example which is the simplified version of the 18th bug of time project in defects4j repository.inthisbug thebuggyversionmissenclosingthemethod invocation igregorianchronology.getdatetimemillis with try catch block.
it results in the termination of buggy version with an exception at line .
in contrast the fixed version does not terminateatline4andcontinueitsexecutiontoline6.asaresult every stepinbuggytraceiscorrectexceptthatthetracemissessomesteps for catching the exception .
in this case our simulated debugging approach is not applicable as the slicing technique cannot work.
moreover such bugs are also not our interested omission bugs.
public long getdatetimemillis ... ... try instant igregorianchronology.getdatetimemillis year monthofyear ... catch illegalfieldvalueexception ex ... ... listing3 exampleofthebugunapplicableforslicing as for the third reason we discard the bug with trace length over100kforthelimitedscalabilityofexistingjavatracecollection tool .
we will discuss more about this issue in section .
.
ofthe237bugswestudied 110bugs .
arereportedasomissionbugsbyalgorithm i.e.
trackingincorrectdataandcontrol cannot lead to the root cause.
of all the omission bugs we detected thecontrolomissionbugsaccountfor60.
andthedata authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
break the dead end of dynamic slicing localizing data and control omission bug ase september montpellier france a control omission bug b data omission bug figure critical path length a control omission bug b data omission bug figure over skipped step number omission bugs account for .
.
thus we conclude that omissionbugisprevalentamongallthedefects4jrepository and control omission bugs are of comparable proportion as data omission bugs.
moreover we further investigate the critical path length and over skipped step number i.e.
distance between the break step and the dead end step see definition for each omission bug.
critical path length indicates the worst effort for a programmerto manually break the dead end of an omission bug.
in contrast over skippedstepnumberindicatestheefforttobreakthedeadend of an omission bug if a programmer sequentially check throughthe trace from the dead end step.
figure 5and figure 6show the distributionofcriticalpathlengthandover skippedstepnumber of control and data omission bugs respectively.
inbothfigures wecanobservethatcontrolomissionbugsshow different characteristics from data omission bugs.
first both theaverage critical path length and the average over skipped stepnumber in control omission bugs are smaller than that in dataomission bug.
more specifically average critical path length ofcontrol omission bugs is .
and that of data omission bugs is .
in contrast average over skipped step number of control omissionbugsis32.2andthatofdataomissionbugsis432.
.second asshowedinfigure 6b onedataomissionbughasthephenomenon of under skip thatis therootcausehappens beforethedeadend step.in summary we conclude that in general data omission bugs are harder to be localized than control omission bugs.
moreover seldom as it is the root cause ofthebugmayhappenbeforethedeadendstepindataomission bugs.
.
.
rq2 omission bugs taxonomy.
forthose 110bugs wefurther studied how those omission is fixed in defects4j repository.
controlomissionbugstaxonomy.
fromasyntacticpointofview wesummarize5categoriesofcontrolomissionbugs i.e.
missing if block missing if throw invoking differentmethod missing trycatch block and passing wrong parameter.missingif block.
aconditionismissedinthecode.thiscategory includes missing if for whilecondition.
note that their block bodies do not include throwstatement.
missingif throw.
aconditionismissedinthecode.thiscategory includesmissing if for whileconditionandtheirblockbodies include throwstatement.
invoking incorrect method.
the control flow is unexpectedly altered by calling an incorrect method.
thus all the follow up stepsincurredbythatmethodinvocationarecontrolincorrect.a typicalscenarioisthemisuseofpolymorphism forexample the programmer forget to override a method in the superclass.missing try catch block.
try catch block can be considered as analternativeofif else block.missingatry catchblockcanlead programtocrashoutofunexpectedexception.asanexamplein listing4 fromthe83thbugofmockitoproject thebuggyprogram is unexpectedly terminated in line out of a cmdlineexception.
public int parsearguments parameters params ... string param params.getparameter string param null try param params.getparameter catch cmdlineexception e listing example of missing try catch block passing wrong parameter.
forsuchacategory anexpectedexception does not happen because of passing wrong parameter during a method invocation.
listing 5shows an example from 4th bug of time project the program is not supposed to run into line 10asanexpectedexceptionissupposedtohappenatline7.tracing throughdynamic controlflow leadsto line3 whichcauses an omission bug.
public partial with ... ... if ... return ... partial newpartial new partial ichronology newtypes newvalues partial newpartial new partial newtypes newvalues ichronology ... return newpartial listing example of passing wrong parameter strictly missingif throwisaspecialcaseofmissingif block we makethemexclusiveasthefollowreasons.fromtheperspective of occur step see definition i.e.
where the fault is revealed and where is the root cause we divide the influence of a control authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yun lin jun sun lyly tran guangdong bai haijun wang and jinsong dong omission bug into intra method and inter method.
if both occur stepandrootcausearewithinamethod weregardtheinfluence asintra method otherwise weregarditasinter method.theinfluenceofmissingif blockisintra method whilethatofmissing if throwissometimesinter method.forexample line8inlisting is unexpectedly executed because guess method line misses aif throwinsideitsmethodbody.insuchcase wherethefaultis revealed i.e.
occur step is not within the same method of the root cause we regard its influence is inter method.
public void testmath844 ... ... if ... return ... guesser.guess listing example of if throw missing ifblockmissing ifthrowinvoke different methodmissing trycatch blockpass wrong parameter figure solution for control omission bug figure7showsthedistributionofallthesecategories.wecan see that the majority of control omission bug is caused by missing if block and missing if throw while the rest ones are the minority.
data omission bugs taxonomy.
still from a syntactic point of view wesummarize4categoriesofsolutionfordataomissionbugs i.e.
missingassignment incorrect evaluatedcondition incorrect condition invokingnewmethod andmissingif block.itisstraightforwardtoseehowmissinganassignmentleadstoadataomission bug.
thus we explains other three categories.
private cluster t getnearestcluster ... ... cluster t mincluster null for cluster t c clusters double distance point.distancefrom c.getcenter if distance mindistance mindistance distance mincluster c return mincluster listing example of incorrect evaluated condition incorrect evaluated condition.
incorrect evaluated condition altersthecontrolflowtoavoidtheredefinitionofthecriticalvariable seedefinition .listing 7showsanexample fromthe79thbug of math project .
the value of variable mincluster at line isnull which is caused by the fact that the condition distance mindistance line never been true and line is never executed.
incorrect condition.
different from incorrect evaluated condition incorrectconditionavoidstheredefinitionofthecriticalvariable becauseofincorrectbooleanexpressionincode.listing 8shows an example from the 43th bug of math project .
the valuevariable line is not incremented due to incorrect comparison for varianceimpl andvariance in code.
public void addvalue ... ... if !
varianceimpl instanceof variance if varianceimpl !
variance varianceimpl.increment value ... listing example of incorrect condition miss invoking method.
missinvokingmethodcanberegarded asa specialcase ofmissing assignment.the differencelies inthat thenewmethodisusuallythelibrarymethodwhichassignsafield insidea library class.forexample the invocationof java.util.
calendar.gettime sets its fields field.
missing assignmentincorrect evaluated conditionincorrect conditioninvoking new method figure data omission bug cateogry figure8showsthedistributionofallthesecategories.compared tofigure thedistributionofcategoriesofdataomissionbugis more even in the four categories.
in summary we conclude that in general there are lots of syntactic means to alter data and controlflowtocreateomissionbugs.however fromanempirical point of view the omission bugs are caused by only a limited number of syntactic reasons.
.
threats to validity the major threat to validity in this empirical study is that we miss thebugswithtracelengthover100k.thereasonisthatthestate ofthe arttracerecodingtechniques donotscalewellforbuilding very large java trace model including the read written library variables of each trace step and the data and control dominance relationshipsamongtracesteps.fromthispoint wemaymisssomeomission bug categories in those large traces.
in the future we aim to build a more scalable trace recording technique to generalize our findings.
the other threat is that the fix version i.e.
ground truth of each omission bug is unique in this study.
in the future authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
break the dead end of dynamic slicing localizing data and control omission bug ase september montpellier france weneedtoconductmorestudytocomparethebreakstepswhen multiple fix options exist for an omission bug.
approach asourempiricalstudyindicatesstrongpatternstoescapethedead end of omission bugs we propose to localize an omission bug in a data driven manner.
in this section we design a technique for assistingslicing baseddebugging.morespecifically weassumethatprogrammerscandebugasoftwarefaultbyprovidingtheirfeedback e.g.
dataorcontrolincorrect ontracestepsandusingslicingto graduallyapproachtherootcause.whenthedeadendcausedby omissionbughappens i.e.
givenadataorcontroldependencypath starting from step sand ending by step e and eis incorrect while sis correct we aims to recommend a trace step in between sand e wherethecriticalvariableshouldhavebeenassignedforthe data omission bug or wherecontrolflowshouldbealteredtoavoidtheunexpected step for the control omission bug.
by observing the omission bugs in defects4j repository we first manually feature engineer these bugs for predicting break stepsof omission bugs.
more specifically the prediction model takes input as the features of the critical path of an omission bug and an arbitrarytracestepand outputstheprobabilityofthesteptoserveasthebreakstep.
tothisend wechooseneuralnetworktoconduct the predication for its rich expressiveness over other classification models such as naive bayes and svm .
we train the neural network model with the omission bugs in defects4j repository and test the model with our mutated omission bugs.
we mutate the omission bugs with regard to the omission bug taxonomy see section3.
.
sothatthemutatedomissionbugsareclosetoreal ones.ouraimistobuildamodelwhichcanfitwellinrealomission bugs and generalize well in mutated the omission bugs.
.
feature engineering inthissection weintroducethecommonfeaturessharedbycontrol and data omission bug as well as their specific features.
.
.
common features.
givenatracestep s andanomissionbug b thecommonfeaturesincludethelengthofcriticalpathandthe syntactic features of the occur step dead end step the trace step s andtheircontexts.thesyntacticfeatureofastep sdescribesthe encodingoftheminimumastnodecontainingthesourcelineof s. the encoding is represented by a vector of boolean variables.
encoding ast node.
wefirstcategorizingastnodetypesinto a taxonomy tree with regard to their similarity with each other.
in our implementation for java programming language we refer to eclipsejavaast document for building thetaxonomytreefor all the java ast node types.
a simplified tree is shown in figure .
infigure underthetopvirtualnodes therearetotally11nodesin the second layer representing abstract ast node such as variable declaration and expression.
the third layer has nodes each of whichrepresentsaconcreteastnodesuchassinglevariabledeclaration and field access.
thus we encode a ast node with a vector withlengthof103 eachdimensionrepresentsaconcrete nodeinthethirdlayeroranabstractnodeinthesecondlayer.anyexpression variable declaration single variable declarationfield access... ... ... variable declaration fragmentassignment figure simplified java taxonomy tree example ast node must fall in either of the nodes in the third layer concrete nodes along with its parent in the taxonomy tree.
therefore the corresponding two dimensions are set to and all the otherdimensions are set to .
the idea of using hierarchical structure allowssimilarastnodes e.g.
assignmentandfieldaccess toshare training results.encoding syntax of trace step.
for a trace step s we concern 6astnodes.theyaretheastnodesfor s occurstep deadend step as well as each of their ast parents in the code readers may refertofigure 10astheparent childrelationshipinast .theast parent indicates the context information.
for example the occur step line in listing we care about both the ast node type of line i.e.
return statement and the ast node type of its context i.e.
method declaration .
in summary the common features concatenate all the above features and vectors and hav e1 dimensions.
.
.
specific features for control omission bugs.
forcontrolomission bug we use ast walk and split data control dependency to embed the specific features of a trace step.
astwalk.
givenanomissionbug bwhoseoccurstep oanddead end step d and let kbe a step between oand d ast walk indicatesthesyntacticproximityfromthesourcecodeof ktothat of o.fromtheperspectiveofasttraverse the walkconsistsof three directions i.e.
up right and down in terms of ast of thecode.
taking the code in in listing 7as example the occur step happens at line and the break step is at line .
the ast walk fromline11toline6isshowedinfigure .infigure eachnode representsanastnode itsnumberindicatesthelinenumberin listing7 andarrowsrepresentsthewalkdirection.wecanseethat the walk from line to line takes ups rights and downs.
4for expression411return statement1method declaration for bodyfor statement 6assignment if statement figure ast walk example authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yun lin jun sun lyly tran guangdong bai haijun wang and jinsong dong split data andcontrol dependencies.
the break step of a control omission bug must lie in between the dead end step cand occurstep k.thus lookingforsuchabreakstepissimilartolookingforastep swhichcansplitthecodesothat angbracketleft c s angbracketrightisallowed while angbracketlefts k angbracketrightistobeavoided.thus wetakethenumberofdataand control dependencies between angbracketleft c s angbracketrightand angbracketlefts k angbracketrightas two features.
.
.
specific features for data omission bugs.
for data omission bug let its critical path be angbracketleft d u angbracketright we introduce critical conditionalstepandvariablesimilaritiestoembedthefeaturesofa trace step.
critical conditionalstep.
thecriticalconditionalstepsarethe tracestepson whereaconditionalexpressionisevaluatedand thenegationofitsvaluecanleadtotheexecutionofredefining var.
suchafeatureisabooleanvalue i.e.
atracestepiseitheracritical conditional step or not.read and written variable similarity.
given a trace step s w e definefeaturestomeasurehowsimilaritsreadandwrittenvariables to the critical variable var.
based on the variable type i.e.
field or local variable we use different number of dimensions to describe similarityfeatures.ifavariable varcisofdifferenttypewith var all its similarity dimensions are otherwise we use the following rules to create a vector for varc field ifthecriticalvariableisafield wehaveavectoroffour booleandimensions i.e.
whether varcsharesthesame parent objectusing varcasitsfield with var whether theparentof varchasthesamedatatypewith var e.g.
both of themare fields in calendar data type whether varc isofthesamedatatypewith varc and whether varcis of the same name with var.
local variable if the critical variable is a local variable we have have a vector of two boolean dimensions i.e.
whether varcis of the same data type with varc and whethervarcis of the same name with var.
note that a step may read or write multiple variables each of whichcanberepresentedbyavectorof kdimensions e.g.
kis4 ifthevariableisafieldand2ifthevariableisalocalvariable .in such case we select the most similar read written variable vector as the read written variable similarity vector for s. .
neural network structure figure11showsourneuralnetworkstructure whichhas1input layer hidden layer and output layer.
different from traditional fullyconnectednetwork thenumberofneuronsinthehiddenlayer corresponds to the number of groups in input features.
for example the three dimensions in ast walk corresponds to a neuron inthehiddenlayer group1infigure andthelast103dimensionsofastnodeencoding group9infigure correspondsto another.
therefore the network structures for control field and local variable omission bugs are different from each other.
we design such a network not only for predicting but for interpretation as well.
with such a network the weight on each edgefromhiddenlayertooutputlayerindicatesthesignificance of each group to the final probability and the weight on each edge from input layer to hidden layer indicates the significance of each dimension to its group.... ... ...... probability neurongroup1 ast walk group9 occur step syntax embedding figure neural network structure in this work we use cross entropy loss function to evaluate our model during the model training.
we use relu activation function for hidden layer and sigmoid activation function for output layer.
evaluation weconductourevaluationtoanswerthefollowingtworesearch questions rq1 whether our model can predict the break steps for omission bugs accurately?
rq2 enhanced dynamic slicing with our model can we localize the omission bugs efficiently?
.
training evaluation with the findings of our empirical study we define five types of mutations i.e.
removeanassignment removeaif condition i.e.
maketheif bodyalwaysbeexecuted negateaif condition remove aif throw andremovethewholeif block.thesefivemutationtypes cover the majority of causes described in section .
.
and they are effective to cause omission bugs.
we conduct the mutationon java open source projects as showed in table .
the valid mutation means the mutations successfully kill the test case and cause omission bugs.
table mutated project overview project version loc valid mutation aapache math .
apache lang .
jfreechart .
.
apache collections .
.
apache cli .
.
learning settings.
given the inputs and network structure are different for learning control omission bug field omission bug and local variable omission bug we tune their model with differentparameters as showed in table .
we decide the parameters by empiricaltrials.notethatthetrainingprocessoftheneuralnetwork isaprocesstoiterativelydecreasethelossvalueofcrossentropy loss function.
in this experiment we use loss threshold instead of iterationnumbertodecidewhenthelearningprocessstops.that is once the loss valueis below the threshold the learning process stops.
we also attach random seed for repeating our approach.learning effect.
table4shows our learning effect on control field and local variable omission bug i.e.
cob fob and lvob authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
break the dead end of dynamic slicing localizing data and control omission bug ase september montpellier france table parameter setting omission bug parameter learning rate threshold random seed control omission bug .
.
field omission bug .
.
local variable omission bug .
.
in table4 .
we compare learning effect in terms of true positive rate tprate truenegativerate tnrate andtotalaccuracy.in general our model achieve acceptable performance on control and localvariableomissionbugs.however themodeldoesnotperform well on field omission bugs.
our observation indicates that the difference between field omission bugs is much larger than control and local variable omission bugs.
in table the model achieves poortruepositiveratio .
andgoodtruenegativeratio .
ontrainingsetbutthesituationreversesontestingset ormutationset.itindicatesthatthedatadistributionoffieldomissionfluctuates morethantheothertwoomissionbugs.furthermore weinvestigateintotheseomissionbugsandfindthat theinfluenceoffield omissionbugsis usuallyinter methodwhilethat ofcontrolomission bugs and local variable omission bugs is usually intra method.
as a result field assignment can happen almost anywhere along the trace which is more random than local variable assignment.
table learning effect omission bug cobfoblvob trainingtp rate .
.
.
tn rate .
.
.
total .
.
.
testingtp rate .
.
.
tn rate .
.
.
total .
.
.
featuresignificance.
asmentionedinsection .
ourneuralnetworkstructureisalsodesignedforinterpretationtounderstandhow significant a feature is.
the larger the absolute value a weight has themoreinfluenceithasonthepredicationresult.thesignindicatesitspositiveornegativeimpactontheresult.table 5showsthe weightsforvariousomissionbugs.forexample controlomission is more influencedby the feature of ast walkas well as syntactic feature of occur step and dead end step.
for the weight of ast walk i.e .
it indicates that the break step usually appears in small walk from the occur step.
similarly the weight .
indicates that being a critical conditional step is a strong indicator for being a break step for a local variable omission bug.
for syntactic features theyindicatethattheastnodetypewithlarger e.g.
.
orsmaller .
indexusuallyhasstrongerinfluenceontheresult.
given the limit of paper space readers can refer to our website for our indexing for ast node.
.
simulated debugging experiment based on our prediction model we enhance the our simulateddebugging algorithm algorithm by suggesting breaker steps with our model.
algorithm 2describes our enhanced debugging simulation algorithm.
the algorithm takes three inputs a faultrevealingstep thenumberofbreakstepswecanrecommendfor an omission bug and a work list that we keep other suggested breakers.algorithm enhanced debugging simulation input a fault revealing step stepfon the buggy trace breaker numberlimit a stack for breaker steps worklist output whether the find is found 1stepstop ori inal simulated debu in stepf 2ifstepdis the root cause then 3returntrue 4end 5omission bu et omission bu stepstop 6breakers recommend breakers omission bu limit 7forbreaker breakers do 8worklist .push breaker 9end 10whileworklist is not empty do 11breaker worklist .pop 12enhanced debu in simulation breaker worklist 13end 14ifstackis emptythen 15returnfalse 16end in algorithm when we detect an omission bug line by the processdescribed inalgorithm line1 i.e.
dynamic slicing we get recommended break steps and keep them in the work list line .
then we retrieve a break step from the work list and restart debugging from the step in the same way the recursive call in line .
the algorithm stops either because we localize the root cause or the work list is empty.
inthisexperiment wetakearandomrecommenderasourbenchmark.therandomrecommenderindicatestheperformanceofomissionbuglocalizationifthesimulatedprogrammerchoosearandom stepasthebreakstep.wedeemourapproachasineffectiveifits performanceiscomparabletothatoftherandomrecommender.
we compare our approach with the benchmark by setting the number of recommended break steps to and .
that is we recommend top top and top breakers in our prediction model while and random steps as breakers for benchmark line .
we run our approachandrandomrecommenderonallthemutatedomission bugs from open source projects table 6shows the results.
table shows that our approach outperforms benchmark in all options on alltypesofomissionbugs.withregardtotable theperformance of bug localization is highly relevant to model prediction accuracy.
based on our prediction model we can accurately localize the controlomissionbugs evenwithtop 1option.
moreover table 6also indicatesthatfieldomissionbugsisthemostdifficultomissionbug tolocalize.noteworthy thoughourmodeldoesnotperformwell for field omission bugs we still improve the performance of the benchmark significantly.
in summary our evaluation shows that our approach can work well to localize certain specific omission bug such as control and local variable omission bugs combined with our predictionmodel wecanbreakthedeadendofslicingandlocalizethe omission bug more efficiently.
.
threats to validity onemajorthreatisthatweusesimulateddebuggingexperimentto imitate how human programmer debug their code.
it is essential to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france yun lin jun sun lyly tran guangdong bai haijun wang and jinsong dong table feature significance omission bugast walksplitdepcriticalconditional stepread var simwrittenvar simcriticalpath lengthstep syntaxstepcontext occur stepsyntax occur stepcontext dead endstep syntax dead endstep context control omission bug .
.
.
.
.
.
.
.
.
field omission bug .
.
.
.
.
.
.
.
.
.
local variable omission bug .
.
.
.
.
.
.
.
.
.
table simulation result omission bugtop top top model breakerrandombreakermodelbreakerrandombreakermodelbreakerrandombreaker control omission bug94.
.
.
.
.
.
fieldomission bug34.
.
.
.
.
.
local variable omission bug50.
.
.
.
.
.
total .
.
.
.
.
.
deliveratoolandcollectthefeedbackofhumanprogrammer.inour futurework wewillconductacontrolleduserstudyonhowour toolintegratedwithlearnedmodelcanhelphumanprogrammerin theprocessofdebugging.
theotherthreatisthelimitednumber ofmutationtypesforgeneratingmutatedbugs.wechoosethose mutation type based on the finding of our empirical study.
the experimentshowsthatthesemutationscangenerateomissionbugs in a much more efficient way than traditional mutation such as changingoperatorandnumbers.nevertheless moreexperiments are necessary to generalize our findings with more dynamic types of mutation.
related work omissionerrorresearch.
manyresearchwork havepointedoutthatdynamicslicingcannotbeusedtolocalizethe code shouldhavebeen executed.toovercometheshortcomingof the slicing technique zhang et al.
proposed a force execution techniqueandwangetal.
proposedtheirrelevantslicingalgorithm to this end.
moreover qi et al.
proposed a solver based approach to localize the regression bug.
by comparing the correct versionoftheprogram theirapproachcaninfercodeomissionerror by encoding the buggy program the correct program and the test case into a satisfiability problem.
in recent years sakuai et al.
enhanced zhang and wang s work with point to analysis.
alltheabovetechniques havetheassumptionthattheomitted codeexistsintheprojectsothattheycananalyzetheprogramto leadthecontrolflowtocodethatshouldhavebeenexecuted.however our empirical study showsthat their techniques only solve a small portion of the whole omission bugs i.e.
data omission bugs under the category of incorrect evaluated condition and incorrect condition.
based on our study findings we proposed a data driven approach to train the model to handle omission bugs in a more comprehensive way.
recordandreplayfordebugging.
ourapproachisanenhancement for record and replay debugging or time travelling debugging .suchatechniqueallowstheprogrammerstobuildadatacausalitychaintolocalizetherootcause .moreover basedontherecordedtrace differentqueriescanbe usedtolocalizetracesteps.forexample ressiaetal.
proposed an approach which can track steps by specific object instance.
the most relevant techniques are whylineproposed by ko et al.
andmicrobat proposedbylinetal.
.whylineallows user to select auto generated questions including why or why notquestion on program output as well as the recorded program trace and suggest the trace step based on slicing.
microbat asks four typesofuserfeedbacktosuggestsuspicioustracestepanditcan further learn these feedbacks to speed up reasoning the root cause.
our approach is complementary to both techniques to improve the localization of omission bugs.deltadebuggingandstatisticalfaultlocalization.
animportantbranchofdebuggingresearchisdeltadebugging and statistical fault localization .
zeller et al.
first proposed the concept of delta debugging and apply itonregressiontesting.then thetechniqueissoontoberefined by misherghi et al.
to improve the result and the concept is soon applied to simplify test cases isolate bug causing variable and etc.
we regard statistical fault localization as a specialcaseofdeltadebugging whichareusedtolocatebugsby comparing a set of passed and failed test cases.
the more timeexecuted by failed test cases a more suspicious a line of code is andviceversa.manymetricshavenproposedtorefinethestatisticalfault localization an overviewofspectrum based techniques can be checked in .
all the above approaches need a reference to infer where the buglies.similartoexistingdebuggingtechnique wefirstusethe correctversionofprogramasareferencetolookforomissionbugs.
however by learning through a large number of bug corpus we can localize the omission bug without any reference.
conclusion in this work we comprehensively studied omission bugs in de fects4j repository and provide a taxonomy on how they can be caused from a syntactic point of view.
based on the findings in our empiricalstudy webuildadeeplearningmodeltopredictthebreaksteps of both control and data omission bugs.
in the future we will generalizeourstudyonmorebugswithlongertracesandfurther improve the precision our prediction on break steps.
acknowledgement wethanktheanonymousreviewersfortheirvaluablecomments and suggestions.
this research is supported by the national research foundation singapore no.
nrf2015ncr ncr003 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
break the dead end of dynamic slicing localizing data and control omission bug ase september montpellier france