cora decomposing and describing tangled code changes for reviewer min wang peking university beijing china wangmin1994 pku.edu.cnzeqi lin microsoft research beijing china zeqi.lin microsoft.comyanzhen zou peking university beijing china zouyz pku.edu.cnbing xie peking university beijing china xiebing pku.edu.cn abstract code review is an important mechanism for code quality assurance both in open source software and industrial software.
reviewers usually suffer from numerous tangled and loosely related code changes that are bundled in a single commit which makes code review very difficult.
in this paper we propose cora code r eview a ssistant an automatic approach to decompose a commit into different parts and generate concise descriptions for reviewers.
more specifically cora can decompose a commit into independent parts e.g.
bug fixing new feature adding or refactoring by code dependency analysis and tree based similar code detection then identify the most important code changes in each part based on the pagerank algorithm and heuristic rules.
as a result cora can generate a concise description for each part of the commit.
we evaluate our approach in seven open source software projects and code commits.
the results indicate that cora can improve the accuracy of decomposing code changes by .
over the state ofart practice.
at the same time cora can identify the important part from the fine grained code changes with a mean average precision map of .
.
we also conduct a human study with eight participants to evaluate the performance and usefulness of cora the user feedback indicates that cora can effectively help reviewers.
index t erms code review code changes decomposition code changes description program comprehension i. i ntroduction code review is a common and important software engineering practice during software development which is recognized as a valuable way for preventing software defects and improving code quality in software projects .
software undergoes continuous changes through which new features are added bugs are fixed and performance is improved.
these code changes usually need to be understood by software engineers when performing their daily development and maintenance tasks in particular during the code review process .
however developers often bundle unrelated or loosely related code changes e.g.
bug fixing and refactoring in a single commit thus resulting in so called tangled commit .
in herzig and zeller s study they confirmed that tangled code changes occur frequently with up to of bug fixing change sets applied to the subject projects being tangled.
and also with the key laboratory of high condence software technologies ministry of education beijing china and the school of electronics engineering and computer science peking university beijing china.
y .
zou is the corresponding author.as tao et al.
pointed out in an exploratory study in industry understanding tangled code changes requires non trivial efforts and a tool feature for change decomposition is desired.
to address the problem of tangled code changes researchers proposed various tools for decomposing code changes in a commit .
most of their work considered lightweight code dependencies e.g.
def use information for clustering code changes.
however during the code review process reviewers prefer to get a complete view of the commit which requires the tool to be able to analyze more comprehensive relationships between code changes e.g.
similarity between code changes method override and classextends rather than just considering some lightweight code dependencies .
moreover there are still many trivial fine grained code changes in a cluster after the decomposition.
most of the previous work does not further analyze and deal with these trivial code changes e.g.
estimating the importance of fine grained code changes in a cluster which makes the code review still difficult .
our goal is to decompose and describe tangled code changes in a commit so as to provide a compact overview of the commit to reviewers.
compared with previous work our insights are we provide a richer set of relations between fine grained code changes so that each commit can be decomposed into several clusters we generate a concise natural language description for each cluster which is helpful for reviewers to understand the commit.
the main challenges we face are to decompose tangled code changes better we need to propose a more accurate code changes decomposition solution by deep mining more complex and comprehensive relationships between programs e.g.
similarity between code changes .
to generate concise descriptions for each code change cluster we need to identify the importance of fine grained code changes in each cluster.
as a cluster may involve many trivial code changes it will obviously be very verbose and impractical if we describe all these finegrained changes without primary and secondary points.
in this paper we propose cora code review assistant an automatic approach for decomposing and describing tangled code changes.
firstly cora decomposes a tangled commit into several code change clusters.
fine grained code 34th ieee acm international conference on automated software engineering ase .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
an example of code changes from commit 280f679 in lucene solr changes are clustered based on dependency and similarity relationships between them.
this is inspired by and extended from cluster changes which clusters code changes based on dependency relationships.
compared with c luster changes cora has extra consideration of the similarity between code changes i.e.
tree similarity between two abstract syntax trees which clusters implicitly related code changes together.
then cora generates natural language descriptions for each code change cluster respectively the importance of each finegrained code change in a cluster is estimated mainly based on the pagerank algorithm so that cora can describe these code changes with primary and secondary points natural language descriptions are generated based on the combination of natural language templates and program analysis techniques which help code reviewers understand each cluster.
we conducted experiments on seven open source java projects to compare the accuracy of cora s tangled commit decomposition module against the state of art techniques i.e.
cluster changes .
moreover we conducted an objective human study with eight participants to evaluate the usefulness and effectiveness of cora .
in a comprehensive evaluation the results demonstrate that cora is effective at tangled commit decomposition in the seven open source projects it achieved a median accuracy of which is better than the state of art techniques most of the natural language descriptions for code change clusters are reasonable for providing a compact overview of a commit in particular for identifying the most important parts in each cluster descriptions generated by cora are useful for reviewers in understanding code changes during the code review process.
in summary this work makes the following contributions.
we propose a novel method to decomposing a commit into several clusters in which not only code change dependencies but also code change similarities are incorporated to cluster fine grained code changes.
we propose a novel method to generating natural language descriptions for each code change cluster in which the importance of each fine grained code change is estimated so that we can prioritize descriptions for moreimportant code changes.
we propose cora an approach and corresponding tool to automatically decompose and describe tangled commits for reviewers.
experiments conducted on seven open source projects show that cora is effective to help code reviewers understand tangled commits.
ii.
m otiv ating example in this section we present a simple tangled commit selected from apache lucene solr1to further motivate our research.
fig.
presents an example of code changes decomposition result for commit 280f679 of apache lucene solr which consists of three clusters.
in this commit there are lines of code changes involving three java class files with additions and deletions.
we manually untangled this commit into three independent clusters and extracted some fine grained code changes in the diff file.
in cluster the declaration of afield named property block unknown is added the declaration of a field named block unknown is deleted and thus the variable named ois updated.
we found these code changes in cluster can be understood as a completely separate part.
similarly in cluster there are also code changes caused by definition and usage.
besides the def use information we can discover more dependency relationships between code changes.
for example if an abstract method has been changed thus the corresponding override method will also be changed.
similarly there are also some program dependencies e.g.
class extends other class between class and class.
even though the def use relationship is the most common in program we believe that mining more program dependencies will make the code changes decomposition more accurate especially when the code changes are very complicated.
so it motivates us to mine more comprehensive and complex program dependencies between code changes.
a more common occurrence in code changes is to modify similar code for the same purpose and it is worthwhile to mine this similarity relationship between code changes.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table i. definitions of different level code changes based on ast node type hierarchy definition ast node type description class level changesclassdeclaration innerclassdeclaration interface enum ...aclass level code change entity represents a change in the declaration of a class such as adding a new class or deleting a class .
it may cover method level orfield level changes.
method level changes methoddeclarationamethod level code change entity represents a change in the declaration of a method.
it may cover statement level changes.
field level changes fielddeclaration afield level code change entity represents a change in the declaration of a field.
statement level changessimplename if f or try expressionstatement ...astatement level code change entity represents other changes such as updating a ifstructure or adding a expression.
example in cluster the core of the code changes is a newly added ifstructure and there is another newly added ifstructure.
we can see that there is no any code dependency relationship between these two code snippets but we found that these two code snippets should be clustered together for reviewers because it seems that those code snippets are both for the purpose of printing debug log.
it will be helpful for code review if we can cluster these similar code changes i.e.
code changes for the same purpose .
consider the commit message in this commit solr7896 add a login page to admin ui with initial support for basic auth as we can see this commit message reveals the main intention i.e.
why did this code change of the commit from programmer which is helpful for code review.
but actually in addition to the main intent information the main code change information i.e.
what did in this code change and internal code logic information is also important for reviewers especially the commit is tangled.
however we cannot describe all the changes in a commit so we should identify the most important code changes.
for example in cluster we found that the declaration of the newly added field is more important and it is a field level code change so we can describe this cluster just like field level add a field named property block unknown in basicauthplugin.java and is used in a variable with object type named o. .
we believe these descriptions will be helpful for reviewers.
firstly it provides reviewers with key information on cohesive code changes.
second it assists reviewers to review those code changes.
so it motivates us to generate descriptions by identifying the most important parts in a commit.
to sum up our idea is to first decompose the code changes into independent parts which makes a cluster view of the decomposed code changes.
for each part we generate descriptions according to the importance of the fine grained code changes.
so we can provide a compact overview of the commit for code reviewers.
iii.
a pproach fig.
shows the workflow of our approach.
the framework consists of two phases namely the tangled commit decomposition phase and decomposed clusters description phase.
tangled commit decomposition.
this phase aims to decompose the tangled code changes by extracting a code change graph from a commit.
in detail firstly cora extractsthe commit from the version control system and converts the previous program and current program into the corresponding abstract syntax tree ast respectively.
then cora extracts the fine grained code changes by comparing the differences between the previous asts and current asts.
next cora identifies the dependencies such as inheritances declarations and method invocations between these fine grained code changes utilizing static program analysis technology.
and cora further explores the similarity between these code changes to cluster the fine grained changes.
finally we get a code change graph each node in the graph stands for a hierarchical fine grained code changes and the edges in the graph stand for the relationships between these code changes.
decomposed clusters description.
this phase aims to identify the most important parts of code changes so as to describe each cluster.
in general a complete and cohesive code change cluster usually contains a lot of trivial changes which are negligible for understanding code changes.
however we are unable to obtain the insight about which part of code changes is more important directly from the commit messages.
to address it we are inspired by the pagerank algorithm .
cora obtains directed graphs corresponding each cluster in the above phase.
on this basis cora utilizes a series of heuristic rules to assign initial value to each node i.e.
fine grained code changes in the graph.
then the pagerank algorithm is applied to identify the importance of these finegrained code changes by calculating the value of each node iteratively.
finally cora starts with the most important node and combines the predefined natural language templates to describe each cluster.
a. decomposing tangled commit in this subsection we describe the details for decomposing tangled commit.
extracting fine grained code changes we extract the change sets between two adjacent versions of a java project by using the jgit2.
then we utilize the g umtree i.e.
a tree based code changes differencing algorithm to extract fine grained code changes by parsing asts of two versions of the code.
finally we obtain the fine grained code change fragments i.e.
independent lines of code.
all fine grained authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
workflow of cora code changes can be represented by a triple of angbracketleft operation type angbracketright angbracketleftast node type angbracketright angbracketleftcode changed content angbracketright .
generating a code change graph by parsing and analyzing the ast node type hierarchy we define these code change fragments as four different levels of code change enti ties class method field statement.
the definition information is shown in table i. for example as shown in fig.
thenewly added field named property block unknown in cluster represents a field level code change entity and the newly added ifstructure in cluster represents a statementlevel code change entity.
we are inspired by c luster changes which clustered code changes based on a dependency graph.
we first follow thisidea to establish a more comprehensive code dependenciesbetween code change entities.
then we further cluster thesefine grained code change entities by additional process whichwe will introduce in the next step.
we utilize static program analysis technique to establish some code dependencies as follows definition usage edges we first establish the edge between a definition and an usage i.e.
if the declaration of avariable field or method is changed we scan all the codechange entities to discover the set of usages i.e.
refer ences to this declaration then we create a directed edgefrom the usage point to the definition.
the definitionusage edges are the most frequent relationships in code changes and they are also important criteria for judgingwhether the code changes are the same cluster.
method method edges consider the code dependencies between method level code change entities we can discover three types of code dependencies abstract method override method implement method.
in detail we tra verse all method level code change entities to discover abstract methods interface methods or methods then we can create a directed edge between two method level code change entities if their method signature are same.
class class edges in code changes an infrequent but important situation is the change of an abstract class i.e.
add delete or update an abstract class file andthus the corresponding inherited class has to be changed.similarly we create directed edges between these classlevel code change entities by traversing all class level code change entities.
the result is a directed graph which nodes represent these hierarchical code change entities and edges representthe identified code dependencies between these code changeentities.
we think those code dependencies can reveal thosecode changes that achieve a joint purpose and are thus morelikely to be part of the same cohesive changes in a tangledcommit.
clustering similar code changes we obtain the initial clusters of a commit by constructing a code change graph.however just considering the program dependencies betweencode change fragments is not enough for clustering.
a verycommon situation in code changes is that the developers modify the similar code snippets for closely related purpose e.g.
refactoring bug fixing and there is no program dependencybetween these changed code snippets but they should belongto the same cluster.
as shown in fig.
cluster presents a simple example of similar code change fragments.
the code changes of the firstifstructure and the code changes of the second ifstructure are very similar and both for the purpose of printing debug log.
ifwe just consider the program dependency we will miss a lotof code change snippets that should be clustered.
to address it we utilize the apted all path tree edit distance algorithm which is a state of art approach to calculate the similarityof two code change fragments.
in detail we first convert those code change fragments i.e.
all same types of nodes in the code change graph into corre sponding partial abstract syntax trees asts we translatethe similarity calculation of the code change fragments pair authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
into the similarity calculation of the asts pair.
then we adopt the tree edit distance as the standard measure for tree similarity which is defined as the minimum cost sequence of node edit operations that transform one tree into another.
in particular we consider following three edit operations on those asts delete.
it denotes a node deletion from the current ast and connect its children to its parent.
insert.
it denotes a node insertion between an existing node and its children.
update.
it denotes an update in the code content of a node.
finally we calculate the value of similarity between two asts pair by using apted algorithm and then we set a similarity threshold to determine whether the two code change entities should belong to the same cluster.
it is well tested that .
is an appropriate value in our scenario so we apply this heuristic threshold .
if they belong to the same cluster we create an undirected and unweighted edge between the two entities.
compared to c luster changes we not only consider more complex and comprehensive program dependencies but also further consider the similarity relationships between code changes.
we think this will significantly improve the effect of tangled commit decomposition which will be verified in later experiments.
b. describing decomposed clusters in this subsection we describe the details for summarizing decomposed change clusters.
calculating the importance of code changes this step aims to identify the importance of code change entities in each cluster based on the pagerank algorithm which is one of the most popular algorithm for web link analysis .
rahman and roy proposed a novel approach named coderank to evaluate the importance of terms in source code.
in our work the pagerank algorithm attempts to evaluate the importance of each code change entity through link analysis.
it is based on two heuristic assumptions as follows assumption important code change entities are generally referenced by more code change entities.
we fully consider dependency relationships between code changes by using a code change graph which is generated in the above.
in a code change graph nodes represent code change entities i.e.
lines of code with different level directed edges represent some dependency relationships i.e.
usage definition overridemethod abstractmethod subclass superclass etc.
we calculate the code change entity s importance value pr vi a s follows pr vi n summationdisplay vj mvipr vj l vj here pr vi andpr vj denote the importance value of nodevi i.e.
a code change entity and node vj i.e.
another code change entity respectively.
ndenotes the number of allcode change entities in a cluster mvidenotes the set of code change entities which points to vi i.e.
vj vi .l vj denotes the number of outgoing links of vj.
assumption important code change entities are generally high level and complex.
we further consider the complexity of the hierarchical code change entity itself based on a series of heuristic rules as follows the importance of code change entities is related to the code level we set the weights of class level method level field level statement level to respectively.
the importance of code change entities is related to the number of code lines in the code change snippets.
the importance of code change entities is related to the number of relationships with other code change entities.
we calculate the weighted average of these heuristic feature rules to evaluate the importance value of the code change entity hr vi as follows hr vi level vi lines vi rels vi here level videnotes the level of code changes we defined in the heuristic rule lines videnotes the number of lines of code change entity rels videnotes the number of relationships of nodevi.
finally we combine the score by the pagerank algorithm with the score by the heuristic rule algorithm as the final importance score of the code change entity.
score vi pr vi hr vi so we can identify the most important part of a cohesive code change cluster by score.
parameters and configurations.
equation is adapted from the pagerank algorithm .
in this algorithm is the damping factor which denotes the probability of randomly choosing a web page in the context of web surfing by a random surfer.
it is well tested that .
is a very generally applicable value for thus we also set to .
in equation .
moreover the pagerank algorithm needs to iteratively calculate the importance value of each node until convergence and we apply a heuristic threshold of .
for convergence checking as applied earlier .
in equation there are three hypher parameters and .
we adopt a simple method to estimate their values as our evaluation dataset contains seven software projects see section iv we tuned and on one of these projects the lucene solr project then applied these tuned parameters to the other six projects.
describing the code change cluster after calculating the importance ranking of code change entities in a cluster we automatically summarize the code change clusters based on natural language templates.
for each cluster we take the most important code change entity as the starting point to derive and summarize each cluster.
each description of the cluster is composed of two elements specific behavioral information of the most important code change entity e.g.
update a method fun1 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii.
natural language templates for descriptions of code change cluster type natural language templates t class level t angbracketleftaction angbracketrighta class named angbracketleftclassname angbracketrightin angbracketleftfilename angbracketright and lead to angbracketleftcode change entity angbracketright... method level t angbracketleftaction angbracketrighta method named angbracketleftmethodname angbracketrightin angbracketleftfilename angbracketright and be invoked in angbracketleftcode change entity angbracketright... field level t angbracketleftaction angbracketrighta field named angbracketleftfieldname angbracketrightin angbracketleftfilename angbracketright and be used in angbracketleftcode change entity angbracketright... statementlevel angbracketleftaction angbracketrighta statement named angbracketleftstateinfo angbracketrightin angbracketleftfilename angbracketright and related to angbracketleftcode change entity angbracketright... table iii.
natural language descriptions for clusters of code changes of commit 280f679 in lucene solr cluster type description cluster 1field leveladd a field named property block unknown in basicauthplugin.java and is used in a variable with object type named o. cluster 2method leveladd a new method named isajaxrequest which be called in method named authenticationfailure inbasicauthplugin.java cluster 3field leveladd a field named property realm in basicauthplugin.java and use it in ifstructure in sha256authenticationprovider .java .
derived dependency information related to the most important code change entity e.g.
add a method fun2 which call the updated method fun1 .
these information is summarized bycora for generating sentences and describing the cluster using the natural language templates listed in table ii.
the first column of table ii represents the hierarchy of the most important code change entity and the second column of table ii represents the natural language templates.
angbracketleftaction angbracketrightrepresents the operation type of the most important code changes i.e.
add delete update etc .
angbracketleftcode change entity angbracketright...represent the code change entity set which are derived by the most important code change entity.
it is entirely possible for a code change entity to derive multiple other code change entities here we summarize the top entities by their importance ranking.
for example we can describe the code changes example in fig.
as table iii.
the complete description of a tangled commit is a combination of individual description of each cluster.
iv .
ev aluation to evaluate cora s effectiveness and usability we have conducted a set of quantitative and qualitative experiments.
these experiments address the following questions rq1 to what extent is cora superior to the state ofart practice on the tangled commit decomposition task ?
and why?
the main object of our research is a tangled commit and we are concerned about the cora s performance on the commit decomposition task.
to evaluate it firstly we manually establish a ground truth in seven open source projects.
aftertable iv.
statistics of seven subject projects project domain loc c t c lucene solr search engine system .6k jfreechart java 2d chart library .8k okhttp http http client .5k glide image load cache library .2k spring framework spring framework 621k netty a network framework .3k jruby ruby on the jvm 253k that we make some comparisons between cora and existing approach i.e.
c luster changes .
and we further explore why cora is better than the previous approach.
rq2 how does the cora perform in identifying the importance of the code changes?
in our approach we identify the importance ranking of the code changes by the pagerank algorithm and heuristic rules.
we are concerned about the effectiveness of our approach.
rq3 does the description generated automatically by cora can cover the main change information of a commit concisely?
we are concerned about the quality of the description generated automatically by cora i.e.
which is the evaluation of the widely used key properties content adequacy conciseness expressiveness and we will further explain the specific meaning of these evaluation properties later.
a. evaluation setup to answer the above research questions we evaluate our approach in seven well known open source java projects.
to ensure the objectivity and versatility of the experiment datasets we selected open source projects implemented in java language differing in domain scale and the number of commits from github.
table iv presents the statistics about these projects including project name domain lines of source code the number of commits and the number of selected tangled commits.
it can be seen that the total number of selected tangled commits is and the scale is small.
however we selected the most complicated commits from seven different projects.
if our tool can work well on these complex commits then it can be assumed that our tool can work better on those simpler commits.
so building larger datasets has no practical meaning for our evaluation.
establishing ground truth to best of our knowledge there is no uniform ground truth available for existing work on code changes decomposition and commit description.
so firstly we establish the ground truth for tangled commits.
commits selection.
without having a document describing the applied changes it is very hard to judge whether code changes are tangled or not at least for a project outsider .
to address it we applied the similar way as kim et al.
to judge whether a commit is tangled or not i.e.
we identified a commit as tangled if the commit message clearly indicates that the applied changes tackle more than one issue report e.g.
fix jruby and jruby on trunk.
or the commit message indicates extra work committed along the issue fix.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v. questions and possible answers in the human subject study property question possible answers content adequacyconsidering only the content of the description and not the way it is presented do you think that the description?
.
is not missing any information .
is missing some information but the missing information is not necessary to understand the commit .
is missing some very important information that can hinder the understanding of the commit concisenessconsidering only the content of the description and not the way it is presented do you think that the description?
.
has no unnecessary information .
has some unnecessary information .
has a lot of unnecessary information expressivenessconsidering only the way the description is presented and not its content do you think that the description?
.
is easy to read and understand .
is somewhat readable and understandable .
is hard to read and understand then we randomly sampled a total of tangled commits from the seven projects see column in table iv .
participants selection.
to establish the ground truth for the above selected commits we hired eight participants to manually cluster these fine grained code changes for each commit.
in particular from our school we hired eight graduate students who had at least years of experience in java programming.
two of them had years experience the average experience was years.
all the participants are not the authors of this paper.
besides in order to ensure the quality of the ground truth we require that participants who are hired be very familiar with these open source projects.
so we used two principles of selecting participants to measure familiarity participants had to have used these open source projects for programming and or have worked on branches of these open source projects for example forking them on github .
ground truth establishment.
first we extracted fine grained code changes for each tangled commit using the c ldiff .
then the eight participants manually clustered these finegrained code changes for each commit.
in particular they were divided into groups of two participants and two participants in the same group labeled the same fine grained code changes for a commit i.e identify two fine grained code changes whether belong to the same cluster .
we also invited participants of other groups to make a further judgment if the original participants judgments are inconsistent.
after that we applied the same way to manually label the most important code changes in each cluster.
finally we obtained a complete and objective ground truth for our quantitative experiments later.
quantitative experiments metric we mainly conduct quantitative experiments for rq1 and rq2.
for rq1 to evaluate how well a clustering result matches the ground truth we utilize a standard metric i.e.
rand index from community detection .
in particular we obtain a fine grained code change graph section iii which nodes represent these hierarchical code change entities i.e.
lines of code snippets .
considering all possible pairs of nodes n n 2pairs for nnodes there are four kinds of results obtained from the experiments namely true positive tp false negative fn true negative tn and false positive fp .
specifically tp pair n1 n2 ccora pair n1 n2 cgtruthfn pair n1 n2 ccora pair n1 n2 cgtruth tn pair n1 n2 ccora pair n1 n2 cgtruth fp pair n1 n2 ccora pair n1 n2 cgtruth here pair n1 n2 denotes a pair of nodes i.e.
lines of code snippets ccora denotes the cluster division by cora and cgtruth denotes the cluster division by the ground truth.
and we calculate the accuracy as follows accuracy tp tn n n furthermore we explore the influence of different edges in the clustering.
we will explain the details later.
for rq2 to evaluate how well importance ranking result matches the ground truth we use the mean average precision and the mean reciprocal rank as our evaluation metric which are both widely used evaluation metrics in information retrieval.
in particular we calculate the map as follows map summationtextc k summationtextn i 1rank i n c here cdenotes the number of clusters in a commit n denotes the number of nodes i.e.
lines of code snippets in a cluster rank i denotes the importance ranking by cora .
for example consider that a cluster has nodes and they are ranked at by the ground truth and they are ranked at by cora respectively.
the average precision score of this cluster is .
.
then we calculate the mrr as follows mrr summationtextc k first i c here first i denotes the importance ranking of the most important node i.e.
node s importance rank at 1st position in ground truth in a cluster by cora .cdenotes the number of clusters in a commit.
for example consider that a commit has three clusters and their most important nodes are ranked at respectively.
the mrr of this commit is .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
accuracy of cora and c luster changes for projects commits.
qualitative experiments design we mainly conduct qualitative experiments for rq3.
for rq3 we are concerned about the quality of the description generated by cora based on the three properties content adequacy conciseness and expressiveness.
content adequacy judges whether the description contains almost important information about the commit.
conciseness assesses whether the description is concise i.e.
whether the description contains superfluous and useless information.
expressiveness evaluates whether the description is easy to understand.
we evaluated the quality of a property in description by adopting a points likert scale similarly to .
in particular we invited eight participants who established the ground truth to judge the descriptions because they are familiar with these commits.
then we asked participants some questions see table v by using an online tool.
b. results analysis table vi presents the statistics of the tangled commit decomposition by cora .
we obtained the code change graph after commit decomposition.
on average the number of nodes i.e.
fine grained code changes we extracted is the number of code dependencies i.e.
def usage edges methodmethod edges and class class edges we established is .
and we counted that the number of similar code changes in a commit is on average.
it indicates that similar code changes are very frequent in commits so we should take advantage of the similarity between code changes when clustering code changes.
finally we can cluster a tangled commit into about independent clusters.
however in the vast majority of commits there are always some fine grained code changes that have no relationship or similarity with any other code changes which are called trivial changes.
we counted that the number of trivial changes in a commit is .
on average.
rq1 to evaluate the accuracy of commit decomposition we calculated the rand index value for total commits from projects.
fig.
shows the results.
it can be seen that cora can achieve an average of clustering accuracy which is much higher than the average accuracy fig.
.
accuracy of cora without different edges for projects commits.
of .
achieved by c luster changes and cora can improve accuracy by over the state of art practice on some projects.
it means that cora can significantly improve the accuracy of fine grained code changes clustering.
in order to explore the impact of different code dependencies and code similarity relationships on commit decomposition and clustering i.e.
we are concerned about why cora can significantly improve the accuracy we conducted a series of comparative experiments by removing these edges i.e.
method method edges class class edges similar edges respectively .
fig.
shows the experimental results.
it can be seen that removing any kind of edges from cora will reduce accuracy to varying degrees.
among them the similarity between the code changes will significantly affect the clustering accuracy compared to other dependencies between the code changes.
it means that considering the similarity between code changes in clustering is significant.
rq2 to best of our knowledge we are the first to study the importance ranking of the fine grained code changes.
so we manually established the ground truth on the commits see part a of section iv .
and we evaluate the accuracy of the ranking using map and mrr which are both standard evaluation metrics in recommendation system and information retrieval.
table vii shows the results.
it can be seen that our approach can achieve an average of .
on the map metric.
it means that our importance ranking algorithm works well on the task of fine grained code changes ranking.
moreover as for the maximum map value the results show that our approach can achieve maximum ranking accuracy in some commits in each open source project.
we observed that this is because some commits are relatively simple and our heuristic rules and the pagerank algorithm can identify their importance.
as for the mrr value we only consider the ranking accuracy of the most important fine grained code changes i.e.
the 1st position code changes in ground truth .
the results show that our approach can achieve an average of .
value on the mrr metric.
it means that our approach can identify the most important code changes in a cluster in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table vi.
statistics of the tangled commits decomposition by cora .
projects commitsnodes code dependency similar changes trivial changes clusters max min ave max min ave max min ave max min ave max min ave lucene solr .
jfreechart .
okhttp .
.
glide spring framework netty .
jruby .
.
total .
.
.
.
.
table vii.
map and mrr results of fine grained code changes importance ranking by cora .
projects commitsmap mrr max min ave max min ave lucene solr .
.
.
.
jfreechart .
.
.
.
okhttp .
.
.
.
glide .
.
.
.
spring framework .
.
.
.
netty .
.
.
.
jruby .
.
.
.
total .
.
.
.
the vast majority of cases.
it is worth noting that the minimum mrr value is only .
.
this is due to the complexity of the fine grained code changes in a cluster but this is very rare.
rq3 we collected user feedback from eight participants who made human judgments on these questions in table v using a points likert scale.
each participant made judgments on commits descriptions.
fig.
presents the results.
as for content adequacy participants agree with the answer on .
commits i.e.
most participants think that description by cora does not miss any important information of commits.
however there is still one participant who believes that our description misses some important information i.e.
the intent of the code changes which is often mentioned in the commit message.
for this we believe that the intent of the code changes is undoubtedly important for understanding the code changes but in our work we are more concerned about the internal logical connection between these code changes and behavioural information of the commit and we think this part of the information is more cumbersome and more valuable to summarize.
as for conciseness most of the participants think that description has no unnecessary information.
participants agree with the answer on .
commits they think that description has a lot of unnecessary information because it sometimes provides too much trivial code details which developers may not care about.
it indicates that our approach still need improvements.
but in most cases we can eliminate most of the unnecessary information by using our code importance ranking algorithm.
as for expressiveness participants agree with the answer on .
commits i.e.
they think that our description is fig.
.
results to the questionnaire from user feedback.
easy to read and understand.
and another participants suggest that our tool should provide a better visualization tool to demonstrate the relationships between code changes which should be considered in the future work.
c. threats to validity internal validity threats to internal validity may come from the process of establishing ground truth.
considering the complexity of tangled commits manual labeling code clustering is a time consuming and labor intensive work and we understand that such a process is subject to mistakes.
to address it on the one hand we have introduced third party inspections to resolve different conflicting views.
on the other hand we preliminarily cluster the tangled commit to reduce the workload and complexity of judging fine grained code changes by using c ldiff .
external validity threats to external validity mainly come from two aspects.
first we evaluated the clustering accuracy and importance ranking accuracy with a total number of commits which may be not very large scale.
so could the results be generalized?
to address it we randomly selected commits from open source projects which have different scales and come from different domains so we believe our datasets are generic and objective.
second our human study results might have been affected by the differences between individual participants.
to address it we used the way of grouping participants to minimize the subjective impact of human judgment.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
v. r elated work we discuss related work from two aspects the first is decomposing code changes the second is describing code changes with natural language.
a. code changes decomposition herzig and zeller first proposed that developers frequently group separate changes into a single commit resulting in tangled code changes when committing changes.
ram et al.
also conducted an empirical investigation on code change reviewability and they proved that composite changes will make code review difficult.
and tao et al.
also presented an exploratory study to indicate that developers need to decompose changes in order to understand them better which is one of the principal motivations of our work.
there have been some prior practices towards the challenge of decomposing tangled commits.
kirinuki et al.
utilized the longest common subsequence algorithm to identify the tangled code changes by comparing previous code changes to the one being committed.
herzig and zeller proposed a multi predictor approach to untangle code changes by using information such as file distance and call graph of the code changes.
similarly tao and kim proposed a heuristic based approach to automatically partition composite changes such that each sub change in the partition is more cohesive and self contained.
barnett et al.
introduced the cluster changes an automatic technique for decomposing changesets which utilize the def use information.
dias et al.
proposed the epiceauntangler which leverage machine learning and clustering to decompose tangled code changes by relying on the code changes information e.g.
code structure message sending and variable accessing during development.
zhou et al.
proposed the infox for identifying features in forks their approach clusters cohesive code fragments using code and network analysis i.e.
community detection algorithm techniques.
an alternative approach to decompose large changes is to cluster and order their parts.
baum et al.
have proposed a theory on how to conduct this ordering and spadini et al.
have conducted an experiment showing that the order in which test code is presented with respect to production code changes the effectiveness of the code review.
b. code changes description automatic summarization of software artifacts with natural language has been widely investigated by researchers and most of the existing techniques work mainly on code changes description .
originally researchers proposed the line based program analysis approach to summarize the differences in a commit.
jackson and ladd designed a semantic diff tool that takes two versions of a procedure and generates a report describing the semantic differences between them.
similarly other practices that improve line based differencing tools are ldiff by canfora et al.
and idiff by nguyen et al.
.
recently researchers proposed the tree based programanalysis approach to describe the code differences .
fluri et al.
proposed c hange distiller a tree differencing algorithm for fine grained source code changes extraction.
based on the ideas of c hange distiller dotzler and philippsen proposed a novel move optimized tree differencing algorithm that has a higher accuracy in detecting moved code parts.
huang et al.
proposed the c ldiffto generate concise linked code differences whose granularity is in between the existing code differencing and code change summarization methods based on existing work g umtree .
other strategies have been explored to describe code changes including program static analysis and machine learning.
buse and weimer introduced the d eltadoc which captures the behavioral changes for every method and the conditions under which they occur by using symbolic execution and summarization techniques.
changescribe is designed to generate commit messages by taking into account commit stereotype changes type and the impact set of the underlying changes.
jiang et al.
adapted neural machine translation to automatically translate diffs into commit messages.
liu et al.
performed an in depth analysis of the nmt approach by jiang et al.
and they proposed a simpler and faster approach named nngen to generate concise commit messages using the nearest neighbor algorithm.
some work utilized related software artifacts e.g.
bug reports or mail listings to describe code changes.
rastkar and murphy proposed the use of multi document summarization and machine learning based techniques to generate a concise natural language description of why code changed.
similarly moreno et al.
introduced the arena an approach for the automatic generation of release notes.
arena extracts changes from the source code summarizes them and integrates them with information from versioning systems and issue trackers.
vi.
c onclusion this paper introduced cora a novel approach for automatically decomposing and describing tangled code changes.
cora first extracts fine grained code changes from a tangled commit then it clusters these code changes using code change graph and mining similar code changes.
next cora identifies the importance ranking of these code changes for eliminating trivial changes and then describes each cluster based on pre defined natural language templates.
cora has been evaluated with a total number of commits from seven different projects aimed at accessing the clustering accuracy importance ranking accuracy of code changes quality of the description and the usefulness of cora .
acknowledgment we are grateful to alberto bacchelli for his insightful comments and constructive suggestions.
this paper is supported by the national natural science fund for distinguished young scholars grant no.
and the national key research and development project of china grant no.
2016yfb1000800 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.