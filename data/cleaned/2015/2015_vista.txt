visual web test repair andrea stocco university of british columbia vancouver bc canada astocco ece.ubc.carahulkrishna yandrapally university of british columbia vancouver bc canada rahulky ece.ubc.caali mesbah university of british columbia vancouver bc canada amesbah ece.ubc.ca abstract web tests are prone to break frequently as the application under test evolves causing much maintenance e ort in practice.
to detect the root causes of a test breakage developers typically inspect the test s interactions with the application through the gui.
existing automated test repair techniques focus instead on the code and entirely ignore visual aspects of the application.
we propose a test repair technique that is informed by a visual analysis of the application.
our approach captures relevant visual information from tests execution and analyzes them through a fast image processing pipeline to visually validate test cases as they re executed for regression purposes.
then it reports the occurrences of breakages and potential xes to the testers.
our approach is also equipped with a local crawling mechanism to handle non trivial breakage scenarios such as the ones that require to repair the test s work ow.
we implemented our approach in a tool called v .
our empirical evaluation on test cases spanning releases of four web applications shows that v is able to repair on average of the breakages a increment with respect to existing techniques.
ccs concepts software and its engineering software testing and debugging keywords web testing test repair computer vision image analysis acm reference format andrea stocco rahulkrishna yandrapally and ali mesbah.
.
visual web test repair.
in proceedings of the 26th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november lake buena vista fl usa.
acm new york ny usa 12pages.
introduction test automation techniques are used to enable end to end e2e functional testing of web applications .
in this context the tester veri es the correct functioning of the application under test aut by means of automated test scripts.
such scripts automate the set of manual operations that the end user would perform on the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci c permission and or a fee.
request permissions from permissions acm.org.
esec fse november lake buena vista fl usa association for computing machinery.
acm isbn .
.
.
.
application s graphical user interface gui such as delivering events with clicks or lling in forms and they are typically used for regression testing .
despite their wide adoption e2e tests are known to be fragile.
changes as simple as repositioning gui elements on the page or altering the selections in a drop down list can cause the test to break.
in literature instances of these problems are known as test breakages .
a test breakage is de ned as the event that occurs when the test raises exceptions or errors that do not pertain to the presence of a bug or a malfunction of the application under test.
this is di erent from cases in which tests expose failures meaning they raise exceptions which signal the presence of one or more bugs in the production code.
in the latter case the developer is required to correct the application whereas in the former case the tester must nd a x for the broken test.
researchers have categorized breakages happening as test suites for web applications are maintained .
web element locators have emerged as the main cause of fragility of tests con rming previous anecdotal ndings .
existing automated web test repair techniques essentially consider only the dom of the web page as a source where to nd possible repairs.
thus these techniques are in many cases either unable to correct breakages or produce many false positives.
moreover breakages do not always occur at the precise point in which the test execution stops which renders automated repair even more challenging.
to detect their root causes testers manually inspect the tests interaction with the application carefully verifying the action performed by each test step on the gui which is tedious and time consuming.
in this paper we propose a novel test repair algorithm implemented in a tool named v that leverages the visual information extracted through the execution of test cases along with image processing and crawling techniques to support automated repair of web test breakages.
the key insight behind our approach is that the manual actions and reasoning that testers perform while searching for repairs can be automated to a large extent by leveraging and combining di erential testing computer vision and local crawling.
v performs visual online monitoring capturing visual snapshots of the correct execution of the test cases.
when the tests are replayed on a new version of the application it uses the web elements visual appearance to validate each test statement prior to their execution.
on the occurrence of a breakage v triggers a series of repair heuristics on the y to nd potential xes to report to the user.
upon inspection the tester can con rm or discard the suggestions.
in addition using an automated local visual based crawl exploration mechanism v is able to handle complex breakage scenarios such as those that break the test s execution work ow e.g.
when elements are moved to another page or a new web page is added in between test steps.esec fse november lake buena vista fl usa a. stocco et al.
we evaluated v on a benchmark of individual breakages from test cases spanning releases of four open source web applications.
for each of them we documented the type of breakage and the position of the associated repair resulting in a taxonomy of test breakages in web applications from a repair oriented viewpoint.
our paper makes the following contributions the rst repair oriented taxonomy of test breakages in web applications.
an algorithm for visually monitoring and validating web test cases based on a fast image processing pipeline.
a novel approach for repairing broken test cases using visual analysis and crawling.
an implementation of our algorithm in a tool named v which is publicly available .
an empirical evaluation of v in repairing the breakages found in our study.
v was able to provide correct repairs for of breakages with a increment over an existing dom based state of the art approach.
a web test breakage travelogue e2e web tests are known for being fragile in the face of software evolution .
even a minor change in the dom or gui might break a previously developed test case.
the test would then need to be repaired manually to match the updated version of the application even if conceptually the functionality is unaltered and no errors are present in the application code.
characterization of a breakage.
in order to clarify the scope of our work it is important to emphasize the di erence between test breakages andtest failures .
we consider a test breakage as the event that occurs when a test tnthat was used to work and pass on a certain version vn fails to be applicable to a version vn k k due to changes in the application code that interrupt its execution unpremeditatedly.
this is di erent from cases when tests desirably expose a program failure and hence do something for which they have been designed i.e.
exposing regression faults .
in this paper we focus our analysis on test breakages.
study of breakages.
in a recent study researchers have categorized breakages as test suites for web applications were evolved .
the study shows that web element locators are the main cause of fragility of the totality of breakages .
indeed the mapping between locators and dom elements is massively a ected by structural changes of the web page that may render tests inapplicable just because the locators and not the tests themselves become ine ective .
the addition or repositioning of elements within the dom can in fact cause locators to non select or mis select elements across di erent versions of the same web page.
in the former case a locator is unable to retrieve the target element whereas in the latter case a locator selects a di erent dom element from the one that was used to target.
concerning the temporal characterization of test breakages researchers distinguish between direct propagated and silent breakages .
a breakage is called direct when the test stops at a statement sti and stihas to be repaired in order to let the test pass or continue its execution.
with propagated breakages on the other hand the test stops at a statement sti but another statement stj preceding sti i.e.
i j must be repaired in order to make thetest pass or continue its execution.
finally silent breakages do not manifest explicitly because the test neither stops nor fails but yet diverges from its original intent and only by manually checking its execution for example by looking at the actions performed on the gui the tester can detect the mis behaviour.
existing web test repair approaches.
test repair techniques have been proposed in recent years .
in the web domain the state of the art test repair algorithm is w a di erential technique that compares the execution of a test over two di erent releases one where the test runs correctly and another where it breaks.
by gathering data about these executions w examines the dom level di erences between the two versions and uses heuristics to nd and suggest potential repairs.
while the repair procedure of w has a straightforward design and can manage a considerable number of cases related to locators or assertions it has a number of limitations that derive from its dom related narrowness first considering only on the dom as a source where to nd possible repairs may be insu cient to nd candidate xes.
second this can lead to a large number of false positives .
third the algorithm attempts repairs always at the point in which the test stops which makes it impossible to handle propagated breakages.
a study on test breakages repairs .
breakages root cause analysis given the predominance of locator related test breakages we focus our analysis on locator problems.
existing taxonomies related to web and gui breakages lack a temporal quanti cation of breakages even less they propose approaches to repair them.
indeed knowing the exact position in which a test fails is arguably a prerequisite for developing e ective automated test repair solutions.
although repairing locators seems mostly a mechanical and straightforward activity to conduct an e ective root cause analysis testers must consider all aspects behind breakages e.g.
their causes and positions in the tests and link them together to devise possible repairs that do not change the intended test scenario.
.
study design to gain an understanding of the variety of web test repairs we conducted a study to categorize the breakages from a repair oriented perspective.
the ndings of our study highlight the complexity and the variety of breakage scenarios that can occur in web tests which automated test repair techniques should aim to handle.
with the intention of studying realistic test regression scenarios we selected open source web applications that were used in the context of previous research on web testing for which multiple versions and selenium test cases were available.
table web applications shows information about the selected applications including their names the numbers of releases considered and the average number of lines of code counted using cloc .table test suites provides data on the test suites including the total number of test cases counted across all releases along with the average number of test cases per release and the total number of statements in all test cases counted across all releases along with the average number of statements per test case.
procedure.
to collect breakage information for each web application we followed a systematic and iterative procedure similar tovisual web test repair esec fse november lake buena vista fl usa1 driver.findelement by.name user .sendkeys user driver.findelement by.name password .sendkeys pass driver.findelement by.xpath input .click driver.findelement by.linktext add new .click driver.findelement by.xpath input .sendkeys name driver.findelement by.xpath input .sendkeys lastname driver.findelement by.xpath input .sendkeys company a a version .
.
driver.findelement by.name user .sendkeys user driver.findelement by.name password .sendkeys pass driver.findelement by.xpath button .click driver.findelement by.linktext add new .click driver.findelement by.name next .click driver.findelement by.name input .sendkeys name driver.findelement by.xpath input .sendkeys lastname driver.findelement by.xpath input .sendkeys company b b version .
.
figure addressbook web application version .
.
1a and version .
.
1b along with selenium webdriver tests.
an analogous data collection study .
for each subject and for each version vnand its accompanying test suite tn we executed tnon the subsequent version vn .
as locator breakages occurred we noted information about the type of each breakage the position of the associated repair and assigned descriptive labels.
reviewing these descriptions allowed equivalence classes to be identi ed to which descriptive labels were also assigned.
to continue the experimental work however we had to repair the breakages.
to minimize bias and subjectivity we utilized the same construct used by the locator i.e.
if an idattribute is changed we used the new idattribute .
in the cases where this was not possible we favoured locators that we believe were the most robust and reliable .
we repeated this process until all the versions were taken into account.
our benchmark comprises individual test breakages distributed as follows for addressbook for claroline for collabtive and for ppma.
table subject systems and their test suites w a t s releases locs k tot avg locs k addressbook claroline collabtive ppma total average .
test breakages and how to repair them we rst describe the breakage scenarios our study revealed.
basic terminology.
at a high level each web test statement is a tuple locator action value .
the locator component speci es the web element the test statement is interacting with.
a locator lis a function on a dom state d. notationally l d!
e where eis the web element returned by the locator lwhen applied to d. non selection same page.
a non selection occurs when a locator lapplied to a dom state dreturns no elements formally l d!
but the target element eis still present on the page e2d .
then possible repairs require to nd another locator l0 l0 d!e.let us consider the login page of addressbook in figure 1a and the accompanying webdriver test a .
in the new subsequent version .
.
as a result of the application evolution the login button gets modi ed as follows input value login input becomes button login button .
when executed on version .
.
the test b will stop at line while attempting to locate the login button.
at a visual inspection of the two guis a tester would expect the test to work because her perception is immaterial as far as changes at dom level are concerned.
it is indeed evident that the target element is visually still present on the page and its position on the gui has not changed.
non selection neighbouring page.
notationally this can be expressed as l d!
e d 9d02nei h d l d0!
e .
as a concrete example consider figure 1a speci cally the pages in which the user can insert a new entry.
the test a clicks on the add new link on the home page line and lls in the first name last name and company text elds lines .
when executed on the successive version .
.
b the test will raise an exception of kind nosuchelementexception at line when attempting to locate the first name text eld.
indeed a new intermediate con rmation page has been added and the navigational work ow of the test must be corrected to re ect that of the new web application.
from a testing perspective the first name text eld can no longer be found on the web page test state following the execution of the statement at line .
however conceptually the repair action that needs to be triggered in order to correct the test has nothing to do with the locator at line .
in fact by only looking at the exception it is arduous for the tester to understand what the actual problem is unless the visual execution of the test is taken into consideration.
a possible solution would require to detect that the web element eno longer exists as part of the test state stiin version v try to match the ein the neighbouring states of stiin the new version v0 which in turn requires to nd a web element e02stisuch that e0 sti !stj the next button in figure 1b .
non selection removed.
the third and last non selection scenario concerns a web element being removed from a web page.
formally this can be expressed as l d!
d02nei h d l d0!
e .
let us consider the application being evolved in the reverse order as depicted in figure i.e.
from version .
.
to version .
.
.
the test b would stop at line when trying to select the next button which was on a page that is no longer present.
in this case the only possible x is to delete the statement at line .esec fse november lake buena vista fl usa a. stocco et al.
removed2.
same page88.
direct .
neighbouring page .
propagated .
mis selection non selection figure causal inner pie and temporal outer pie repairoriented characterization of locator breakages.
mis selection direct and propagated.
the addition or repositioning of elements within the dom can cause locators to misselect elements across di erent versions of the same web page.
speci cally a mis selection occurs when a locator selects a di erent dom element from the one that was used to target.
notationally l d!
e inv and l d0!
e0 inv0where e e0.
consider figure again.
suppose that the test a is repaired so as to reach the edit page on version .
.
for instance as in b .
on the new version .
.
the statements at lines will execute correctly whereas at line in the new version the test will ll in the eld nickname instead of the eld company .
the mis selection problem can lead to unpredictable test executions that diverge from the test s intended behaviour.
the test may continue its execution until it reaches a point in which an action cannot be performed or an element cannot be found but the actual repair has to be triggered in a previous test statement .
in fact the point in which the repair must be applied varies depending on where the mis selection rst originated.
repairing mis selections requires nding another locator l0 l0 d0!
e .
.
findings figure shows the distribution of the di erent classes of locator breakages and relative repairs.
our study revealed two major categories each of which has speci c subtypes.
the most prevalent category concerns non selection of web elements all raising direct breakages in the tests.
concerning the associated repairs the vast majority were found on the same page whereas other scenarios refer to web elements that were moved to a neighbouring page or being removed from any web page.
the second main category consists of mis selection of web elements whose repairs were always found within the same page and of which 3led to direct breakages and 3topropagated breakages.
we have not observed silent breakages in our benchmark.
additionally we collected test failures meaning the tests exposing actual bugs and failures due to obsolete assertion values.
in this work we only focus on repairing locator breakages.
overall tests exhibited at least one breakage and of those tests su ered from multiple breakages.
figure shows box plots of the distribution of such breakages per test in0 12all appsppmacollabtiveclarolineaddressbookfigure distribution of test breakages per broken test case.each subject system.
we observe that on average between 4breakages are present per test.to summarize test suites break frequently as the web appli cation evolves breakages may occur multiple times within thesame test breakages fall into multiple recurrent patterns whichwe call breakage scenarios in this paper.
approachthe goal of our approach is to detect the occurrence of locatorbreakages as tests execute and nd potential xes to report to theuser.
our focus is on the classes of breakages described insection .
.in a nutshell our approach captures the visual execution trace ofeach test statement for a versionvnand uses it to validate theircorrectness or to nd potential repairs when they are executedon a subsequent versionvn k k .figure 4illustrates the usage scenario of our approach whichrequires a correct version of the web applicationvalong with itsworking test suitets i.e.
in which all tests pass .
a tester wouldruntsby means of the rst module of the presented approach thevisual execution tracer .
such a module collects for each test a variety of visual information e.g.
screenshots .
then as theapplicationvevolves into a new versionv0 a tester may wish tousetsto check if regressions have occurred .
to this aim thetester would use the second module of our approach the visualtest repair which runs each test case oftsagainst the newversionv0 and makes use of the information about the previousexecution traces tovalidateeach test statement.
on the detectionof breakages our approach attempts to nd candidate repairs thatcan x them.
at the end of the process the approach outputs thevalidated and eventually repaired test suitets0 together withreport informationa.
the tester can then manually analyze thereport along with the repaired test cases.ts0now represents aworking test suite for the versionv0which can be used as a baselinefor our approach whenv0will evolve further.
the manual e ortrequired is potentially signi cantly reduced in comparison to a usercarefully verifying each executing test and manually searching for xes as breakages occur.
we now detail each step of our approach.
.
visual execution trace collectionin the rst part the approach captures information about thedy namic visual execution traceof the test cases associating each teststatement with its visual information.more in detail for each test statement our approach capturesthe screenshot of the web page and the coordinates and size of theweb element s bounding box in order to get a visual locator .visual web test repair esec fse november lake buena vista fl usa app v 1visual execution tracervisual test repair test suite ts repaired dynamic visual execution trace2536 test suite ts4 reportapp v test suite ts testscreenshotvisual locator app v figure overview of our approach .
visual test repair algorithm illustrates the main procedure of our algorithm for the visual augmented execution of test cases.
the procedure takes as input a test case t the dynamic visual execution trace exof ton a version vof the web application and the url uof the subsequent version v0of the web application.
the outputs are a testt0 validated or corrected to work on v0 and the map of repairs.
initialization.
the initial part involves loading the dynamic visual execution trace ex and opening a webdriver session with the new version v0 lines .
visual augmented execution.
the information contained in ex is used to visually validate each statement stioft when executed onv0 main loop lines .
the validation proceeds as follows.
first the dom based locator utilized by stiis extracted along with its visual locator i.e.
an image in v lines .
then the driver instance is used to query the dom of v0to observe if the original dom locator returns a web element line .
detecting and repairing non selection breakages.
if no element is returned we treat it as a non selection happening on the same page .
given that sti if executed will break in v0 we attempt to nd a candidate repair through a series of countermeasures.
the rst heuristic tries to search for the web element visually on the same page.
the visualsearch function line uses advanced computer vision algorithms to retrieve the target web element by matching the visual locator captured in von the current gui of v0 see details in section .
.
if a result is found the corresponding dom element s xpath is retrieved and saved in the map of candidate repairs line .
before proceeding to the next statement the approach outputs the outcome of the veri cation phase to the user who can inspect con rm or enter a manual x before executing sti for brevity such details are encapsulated within the confirmenterrepair andexecutestatement functions at lines and .
if the visual search on the same page returned no elements then our approach assumes that such an element no longer exists on the current page and considers it as a broken work ow.
a localalgorithm visual test repair input t a test case developed for web application v ex execution trace of twhen executed on v u the url of subsequent version v0 output t0 a veri ed repaired tworking on v0 repairmap repairs for each test step 1trace loadexecutiontrace ex 2driver loadapp u 3statements getstatements t repairmap maphstatement repair locator i 4foreach test statement sti2statements do locator getlocator sti vislocator getvisuallocator trace sti webelement driver .
ndelement locator manage non selection of web elements.
ifwebelement null then webelemvisual s driver sti vislocator ifwebelemvisual null then webelemvisual c driver sti vislocator ifwebelemvisual null then repairmap .add sti remove null else repairmap .add sti addbefore webelemvisual end else repairmap .add sti update webelemvisual end manage mis selection of web elements.
else if webelement null then webelemvisual s driver sti vislocator if webelement webelemvisual false then repairmap .add sti update webelemvisual end end e r repairmap sti driver s sti v0 30end 31t0 t repairmap 32return t0 repairmap exploration of the application state space is hence triggered procedure localcrawling of line in order to nd the element in a neighbouring page see details in section .
.
in each new state discovered by the exploration the crawler executes the visualsearch procedure to locate the target element.
if a match is found in at least one of those states the xpath of the element to reach that page is saved in the map of repairs line and marked as a test statement that needs to be added before stiin the repaired test case thus creating the missing transition .
on the contrary if a match is not found i.e.
no elements were found through local crawl our approach considers the web element asremoved from the application thus it suggests the deletion of sti line .
detecting and repairing mis selection breakages.
if a web element was returned by the original dom locator line our approach attempts to validate the correctness of the selection by using the previously collected visual information lines .
the equivalent function checks the equivalence of the web elements found by the dom locator and the visual locator.
if they do di er our approach considers it a possible case of mis selection that could lead to a direct or propagated breakage.
the procedure stores the alternative web element s xpath line it reports the mismatch to the user and asks for her input.
outputs.
at last a repaired test t0is automatically created upon the given suggestions manual repairs line and the algorithm terminates.
in the following section we describe the visualsearch andlocalcrawling procedures that underlie at the functioning of our approach.esec fse november lake buena vista fl usa a. stocco et al.
a b c d feature extraction feature detection template matching filteringdom queryhtmlheadtitlebodyformlabelinputlabelinputinput s1 s2e1e3 s3 s4 s1 s0 e2next evisual based local crawlingfigure computer vision pipeline for robust web element detection left and visual based local crawling for work ow repair.
.
visual search of web elements computer vision cv provides techniques for analyzing web pages the way end users perceive them.
thereby we provide a short background of the cv solutions that are relevant in this work.
challenges of template matching.
identifying web elements visually across di erent versions i.e.
pages of a web application can be tackled with an image analysis technique known as template matching .
template matching aims to detect the occurrence of a speci c object image template in another reference image .
the template is slid over the image and a similarity measure is computed at each pixel location.
the top left corner point of the area where the maximum similarity has been found is then returned.
in our context the matching technique must handle translation i.e.
the captured template can be shifted with respect to the reference image and scaling i.e.
the aspect ratio of the template is not preserved in the reference image or a di erent font is used problems.
indeed web applications are often modi ed to accommodate cosmetic or stylistic changes to align the gui with the latest trends.
these changes may render our technique fragile because the visual locators captured on the oldgui might be ine ective on the new gui of the application.
additionally standard template matching algorithms are not e ective in detecting the presence absence of a template which is instead of paramount importance for the accuracy of our algorithm.
even though stricter similarity threshold values might be used in our exploratory experiments this strategy failed to provide robust or generalizable results.
thus we explored a more advanced cv solution namely feature detection.
feature detection.
the philosophy of this method is to nd certain important points key points in the template image and store information about the neighbourhood of those key points key point descriptors as a description of the template.
then after nding the descriptors of key points in the reference image the algorithm tries to match the two descriptor sets one from the template and one from the reference image using some notion of similarity and see how many descriptors match.
thus the visualsearch procedure adopts a pipeline of cv algorithms which is graphically illustrated in figure .
feature detection for template absence presence.
we implemented a detector based upon two extensively used and accurate feature detection algorithms from the cv literature sift and fast .
the detector uses these algorithms to detect the key points from the template image using sift descriptors a and then adopts a flann based descriptor matcher with a distance threshold ratio of .
as per lowe s paper .
the detector returns a positive result on the presence of the template if at least of the key points are matched.
we used a combination of twofeature detection algorithms because we found through experimentation that sift and fast complement each other.
as such sift performs well mostly for textual based templates whereas fast can handle the cases where the template represents an empty text eld as it is speci cally designed for corner detection.
in our pictorial example a most of the key points detected by sift are in fact nearby the login label orange circles whereas fast detected key points also in proximity of the corners blue circles .
in b we can see how the algorithms matched the key points onto the new gui of the application.
for further details the interested reader is referred to the relevant literature .
template matching with visual filtering and nms.
in the next step if the feature detection returned a positive result about the presence of the template image a template matching technique is executed c .
we experimented with di erent algorithms available in the open source computer vision library opencv .
we found the fast normalized cross correlation algorithm with a similarity threshold .99to be optimal in our setting.
yet any template matching technique might return false visual matches as well as multiple overlapping bounding boxes around the area of interest.
since our procedure ought to return exactly one result a post processing algorithm is responsible for discarding the false matches and merging all redundant detections.
in brief the matches that do not fall in the region where the key points have been found are discarded and a non maxima suppression operation nms is also applied basically nms assumes highly overlapping detections as belonging to the same object .
thus only the closest match is returned see the green thick rectangle over the login button .
to summarize the three cv algorithms sift fast and fast normalized cross correlation operate synergistically to nd a consensus on the location of the best match.
from gui to dom.
at last in order to retrieve the dom element corresponding to a speci c point of coordinates x the visualsearch function queries the browser through javascript to retrieve the dom element whose bounding box centre contains x and d .
otherwise a dom ancestor of the searched web element as aform ordivcontainer will be erroneously returned .
local crawling for work ow repair.
manually repairing every broken work ow is tedious and frustrating since even a mediumsize web application may contain tens of gui screens and hundreds of gui actions.
it is hence likely infeasible for a tester to quickly explore this state space to choose replacement actions from.
fortunately a web crawler can do this automatically.
to this aim the localcrawling function explores the state space of v0looking for a visual match in the immediate neighbouring pages of the currentvisual web test repair esec fse november lake buena vista fl usa web page.
if a match is found the work ow is repaired by adding a transition to that page through the matched element figure d shows how the local crawling approach works for the example of figure 1b b .
otherwise our approach considers the element as removed.
thus to repair the work ow it suggests the deletion of the corresponding test step.
.
implementation we implemented our approach in a tool called v visualtest repair which is publicly available .
the tool is written in java and supports selenium test suites written in java.
however our overall approach is more general and applicable to test suites developed using other programming languages or testing frameworks.
v gets as input the path to the test suites collects the visual execution traces by means of pesto .
our visual detection pipeline adopts algorithms available in the open source computer vision library opencv .v makes use of the traces to retrieve potential repairs and generates a list of repaired test cases.
for the local crawling exploration v features a crawljax plugin that incorporates the visualsearch function.
in our evaluation we limited the crawler s exploration depth to one its running time to minutes and con gured it to return the rst match found.
this was a conservative choice since the number of dom states and events can be numerous.
while this limits the search capability this design choice kept the running time acceptable.
for the interested reader more technical details can be found in our accompanying demo paper .
empirical evaluation we consider the following research questions rq1 e ectiveness how e ective is the proposed visual approach at repairing test breakages compared to a state of the art dom based approach?
rq2 performance what is the overhead and runtime of executing the visual approach compared to the dom based one?
rq1aims to evaluate the e ectiveness of v at detecting and repairing test breakages and how this varies across the breakage classes.
rq 2aims to evaluate the overhead and running time of the two main modules of v the visual execution tracer and the visual test repair.
object of analysis.
we used the same subjects and test suites discussed in section .
for which breakages were identi ed.
independent variables.
in our study the visual aided approach is represented by v .
as a dom based approach we chose w .
however we have not adopted the implementation described in the original paper .
in fact there are fundamental design di erences between the algorithms w is an o ine technique that runs a test collects information about the breakages and runs the repair as apost processing procedure.
our algorithm instead is designed to analyze the test suite at runtime and to attempt repairs in an online mode.
given that the scope of this paper is to compare the e ectiveness at repairing breakages we implemented a dom based version of our approach by i customizing the visual execution tracer to collect dom information and ii invoking w s repair heuristics referred to as repairlocators in within ourmain algorithm .
for simplicity however in the evaluation section we refer to the two competing tools as v andw .
dependent variables.
to measure e ectiveness rq we counted the number of correct repairs as well as the amount of manual repairs triggered by the two techniques on our benchmark.
regarding e ciency rq we utilize two metrics.
first we measured the overhead imposed by the visual execution tracer on the test suite to create the visual traces.
as a second metric we counted the time spent by each competing technique at repairing breakages.
procedure.
for each subject application we applied w and v to each test tnin which a breakage was observed on the successive release vn .
for each tool and for each breakage we manually examined the rst proposed repair repto determined its correctness.
if repwas found correct upon manual inspection we incremented the number of correct repairs.
when both tools were unable to repair we incremented the number of manual repairs.
.
results e ectiveness rq .table presents the e ectiveness results.
for each subject the table reports the number of breakages and the amount of correct repairs triggered by w andv both numerically and percentage wise.
the results are further divided into the various breakage classes.
totals across all applications are also provided.
overall we can notice that w was able to repair breakages whereas v found correct repairs for breakages .
v was hence able to correct breakages more than w a increment.
looking at the speci c breakage classes each tool performed well with respect to same page w repaired correctly of the times whereas v .
concerning neighbouring page no correct repairs were found by w while v was successful.
about elements being removed both tools performed equally detecting cases .
the main di erence between the two approaches emerges when considering mis selection cases w was never able to detect any mis selection of elements whereas v detected and repaired correctly on average of them avoiding of direct breakages and preventing of propagated ones .
overall the visual approach implemented by v was constantly superior to w over all the considered applications.
individual improvements range from for addressbook to for claroline.
table compares the two approaches further.
the rst row shows the number of cases in which both tools were able to correct the breakages.
the second row instead illustrates the cases in which v prevailed whereas the third row reports the cases that w repaired correctly whereas v did not.
lastly the last fourth row indicates the number of breakages that neither tool was able to correct and that were hence xed manually.
in more than half of the cases both tools found the correct repair.
however in cases v repaired a breakage that w could not x. conversely only in three cases w prevailed over the visual approach.
finally of breakages were repaired manually because neither technique was able to x them.
we will discuss those cases in section .esec fse november lake buena vista fl usa a. stocco et al.
table repair results across all applications and across all breakage classes addressbook claroline collabtive ppma all appsbreakages rep. w rep. v breakages rep. w rep. v breakages rep. w rep. v breakages rep. w rep. v breakages rep. w rep. v non selection same page neighbouring page removed mis selection direct propagated total table comparison between dom and visual repair strategies for all breakages and amount of manual repairs.
addressbook claroline collabtive ppma all apps v 4w v 4w v 8w v 8w performance rq .to assess the performance of running our approach we measured the execution time on a macos machine equipped with a .3ghz intel core i7 and gb of memory.
table trace generation shows the average time required to run the test suites without column and with column the visual execution tracer vet module and column reports the relative slowdown.
overall our technique imposed a .
slowdown compared to normal test suites execution minutes .
the biggest overhead occured for collabtive minutes whereas the lowest occured for addressbook minutes .
concerning the execution time of our repair technique table repair time shows the total running time in seconds for each tool.
to allow a fair comparison we split the results between the cases in which the tools were successful columns and and unsuccessful columns and .
in the former case w was overall faster than v which employed nearly minutes more.
in the latter case w was slower as compared to v .
application wise w was faster on addressbook and claroline about and minutes respectively but slower on collabtive and ppma s and .
minutes respectively .
we will comment those results in section .
discussion in this section we discuss some of our ndings tool design decisions and limitations as well as threats to validity of our study.
our empirical study con rmed the fragility of e2e web tests when used for regression testing scenarios section .
.
although such tests did fail times due to actual bugs breakages are still a largely predominant issue a ecting test suite maintenance.table performance results trace generation repair time seconds correct s incorrect s original with vet slowdown w v w v addressbook .
claroline .
collabtive .
ppma .
total .
this is why repairing web tests is often considered a tedious activity that leads the test suites to be abandoned .
this is certainly due to the high frequency at which those tests break but also due to the dearth of solid tooling solutions in this area.
.
explaining results across approaches e ectiveness.
our evaluation revealed that our visual based approach can successfully repair a large number of breakages correctly outperforming an existing dom based solution.
we investigated why allbreakages were not repaired.
we enumerate some of the main reasons next which pertain both to the inherent nature of our subjects and tests and some of the design choices and limitations of the two competing approaches.
w could not detect any mis selection case because the misselected element is among those retrieved by its heuristics.
v on the contrary does not trust a priori dom based locators and validates them by means of their visual appearance.
for analogous reasons the dom based repair strategy was ineffective when searching elements with local crawling neighbouring page cases whereas v could detect nearly one third of them.
the failing cases were due to the retrieving of no elements or wrong ones .
in ppma a challenging case occurred the desired elementvisual web test repair esec fse november lake buena vista fl usa was hidden in a hoverable drop down menu whereas the crawler does not detect such interaction patterns as it was instructed to search in the neighbouring pages.
concerning the removed cases both techniques failed seven times because the crawler retrieved a wrong element.
for the same page category both techniques performed quite well however v achieved a improvement in the correct repair rate.
for the claroline application w outperformed v in three cases.
these breakages concerned buttons whose dom attributes were stable across the two considered releases whereas their visual appearance did change substantially making our visual technique ine ective.
looking at the results on a per application basis addressbook and collabtive tests experienced breakages pertaining to all classes.
on such applications v performed better than w with and improvements on the number of correct repairs respectively.
for addressbook the dom evolved quite frequently across the releases.
thus for a tester it would be challenging to nd reliable attributes upon which to create stable web element locators and hence robust test suites .
also the gui of the web application evolved e.g.
with changes in background colour and font size to make it more appealing and user friendly.
however our approach demonstrated to be robust to both shifting and scaling invariant to translation and scale transformation .
five mis selection breakages could not be corrected by either of the two approaches.
those cases refer again to buttons whose tag changed from img to i as well as their visual appearance from buttons to icons .
in collabtive the high number of breakages is explained by the numerous xpath locators used in the test suite which are typically impacted by minor dom changes.
however such dom level modi cations did not jeopardize the e ectiveness of w .
also v had its best best repair results because the gui remained quite stable across the analyzed releases.
for claroline and ppma almost all repairs were found on the same page with v being and more e ective than w respectively.
claroline and ppma were also the applications in which more manual repairs were needed.
claroline experienced signi cant dom and gui evolutions whereas for ppma our technique failed due to timing issues e.g.
delays or page reloads that were needed to display the web elements on the gui .
performance and overhead.
when the tools are successful their running time is comparable with w being on average slightly faster than v across all breakages.
however looking at the results in conjunction with the repair rate suggests a di erent picture.
w repaired breakages correctly in minutes .
s repair whereas v repaired breakages correctly in minutes .
s repair .
on the contrary when the tools were unable to repair w employed minutes more than v .
vs .
s repair .
these low results are explained by two reasons if the dombased heuristic fails to nd the target element on the same state the local crawling is unnecessarily executed and one of w s heuristics searches for web elements having similar xpaths to the target element s. being real world applications our subjects have web pages with signi cant dom sizes.
thus w was often forced to compute the similarity score on dozens of web elements whereas v required only two feature detection and one template matching operations on images of reasonable sizes.
this gives us con dence in the applicability of our technique in common web testing scenarios.
.
estimated manual e ort saving our study revealed that tests of our benchmark experienced at least one breakage for which the test engineer must nd an appropriate repair for.
manually inspecting the application to nd a correct x and creating a locator for each broken statement can be however a time consuming task.
in a recent test repair work authors report an average manual repair time of minutes breakage.
on our dataset hypothetically speaking the estimated manual e ort reduction thanks to our technique would be hours .
our own experience in repairing tests gained during the empirical study corroborates the costliness of the task.
for example in addressbook one test for the search functionality broke times when applied from version .
to version .
.
due to three non selections removed and seven mis selections direct .v created the dynamic visual execution trace of this test in s and then found correct repairs for all breakages in s. thus in this speci c case our technique is advantageous only if the manual detection and repair performed by a human tester takes more than s s breakage which seems likely infeasible in practice.
however comparative experiments with human testers are necessary to measure the costs associated with repairs.
before undertaking such a study we evaluated whether our technique has prospect for success against a state of the art repair algorithm.
.
applications v can be used by test engineers to validate and repair their e2e web test cases.
each statement of the tests is associated with its visual trace.
hence this information can also aid testers to monitor the behaviour of the test suite across time and perform more e ective root cause analysis .
our technique can also play a role in automating software oracles .
a similar approach is implemented in tools such as applitools where testers can manually inject visual checks at speci c places of the test s execution.
this has two drawbacks the insertion of the check points must be performed manually this extra code clutters the initial test code with statements that do not pertain to the test scenario itself.
on the contrary our technique can be introduced smoothly in existing testing infrastructures as it neither impacts nor modi es the source code of the test cases.
v can be utilized as a runtime monitoring technique for the detection of tests misbehaviours.
our study shows that v goes beyond simple detection and can e ciently suggest a high number of correct repairs at runtime while requiring a low overhead.
hence our approach can be utilized as an automated self repair testing technique and can also be integrated with robust locator generation algorithms .
finally our taxonomy can drive the design of automated test repair techniques such as the one presented in this work.esec fse november lake buena vista fl usa a. stocco et al.
.
limitations v depends on the uniqueness of the templates used to identify web elements.
when feature detection fails template matching is not executed thus undermining the applicability of our approach.
concerning the local exploration since crawling depth is limited to one we manage work ow repairs that pertain to the addition removal of one statement only.
however if two subsequent statements needs to be removed our technique does so by running the crawler twice.
moreover our implementation does not currently support the creation of general purpose statements such as the ones that need input data or the repair of assertion values.
.
threats to validity we limited the bias of having produced test suites ourselves by choosing existing test suites.
this also ensures to some extent that the chosen objects of analysis are non trivial therefore representative of test suites that a real web tester would implement.
the manual evolution task poses a threat to validity that we tried to mitigate by following a systematic approach in repairing the breakages.
concerning the generalizability of our results we ran our approach with a limited number of subjects and test suites.
however we believe the approach to be applicable in a general web testing scenario unless strict timing constraints apply even though the magnitude of the results might change.
to limit biases in the manual selection of the versions we considered allthe available releases after those for which the test suites were developed for.
lastly we constructed our taxonomy based on the analysis of several hundreds of tests on real world applications.
however we do not claim that our taxonomy represents all possible breakage scenarios.
however taxonomies typically evolve as additional observations are made.
related work web and gui test repair.
we already discussed and evaluated w .
a recent work adopted w to repair the breakages happening to the intermediate minor versions between two major releases of a web application.
grechanik et al.
analyze an initial and modi ed gui for differences and generate a report for engineers documenting ways in which test scripts may have broken.
zhang et al.
describe f f a tool that repairs broken gui work ows in desktop applications.
memon presents an event based model of a gui which is used to determine the modi cations during software evolutions.
in similar fashion gao et al.
present sitar a modelbased repair algorithm of unusable gui test scripts.
r a is a tool to repair mainly assertions in unit tests for java applications .huang et al.
describe a genetic algorithm to automatically repair gui test suites by evolving new test cases that increase the test suite s coverage while avoiding infeasible sequences.
di erently from the aforementioned works our test repair technique uses a computer vision based approach to x classes of breakages speci c to the web testing domain that have not been reported in general gui desktop applications.breakage prevention.
recent papers have considered increasing the robustness and maintainability of web test suites.
in order to make test scripts robust several tools producing smart web element locators have been proposed .
a study by leotta et al.
discusses the development and maintenance cost associated with both dom and visual test suites for web applications.
additionally stocco et al.
investigate the automated generation of page objects that con ne causes of test breakages to a single class a form of breakage prevention.
computer vision to assist se tasks.
recently software engineering community has witnessed an increasing adoption of cv techniques to assist or solve common software engineering tasks.
one of the foundational works on computer vision applied to testing is by chang and colleagues.
their tool s allows testers to write a visual test script that uses images to specify which gui components to interact with and what visual feedback to be observed.
their work shows how this approach can facilitate a number of testing activites such as unit testing regression testing and testdriven development.
on the same line ja is a visual record and replay tool for the testing of gui based applications.
cv techniques have been employed to detect cross browser incompatibilities xbis .
w s compares whole images with a perceptual di erence technique whereas w d and x pert utilize an image similarity technique based on image colour histogram matching.
the tool pesto migrates dom based web tests to visual tests.
it does so by using a standard template matching algorithm for the automatic construction of visual locators which we used for the development of the visual execution tracer.
feng et al.
use a combination of visual analysis and nlp techniques to assist the inspection of crowdsourced test reports.
ramler and ziebermayr use visual test automation joint with computer vision techniques to test physical properties of a mechatronic system whereas k ra and colleagues used an image processing pipeline for test oracle automation of visual output systems.
bajammal et al.
use visual methods generate reusable web components from a mockup in order to facilitate ui web development.
in another work bajammal et al.
use visual analysis to infer a dom like state of html canvas elements thus making them testable by commonly used testing approaches.
conclusions and future work in this paper we proposed v a novel web test repair technique based on a fast image processing pipeline.
first we used tests spanning releases of four subject systems to collect a dataset of individual test breakages for which a repair oriented taxonomy has been presented.
then we empirically evaluated our technique at repairing these breakages.
overall v was able to repair correctly on average of such breakages outperforming the state of the art solution while incurring an acceptable overhead.
for future work we plan to investigate the potential for hybridization i.e.
joining dom and visual heuristics in a single solution.
we also intend to run a controlled experiment with human subjects to measure the accuracy of the suggested repairs.
lastly we plan to experiment our technique with more subjects and study its capabilities to repair mobile test suites.visual web test repair esec fse november lake buena vista fl usa