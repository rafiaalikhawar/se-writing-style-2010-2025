adaptively generat ing high quality fixes for atomicity violations yan cai state key laboratory of computer science institute of software chinese acad emy of sciences beijing china ycai.mail gmail.com lingwei cao state key laboratory of computer science institute of software chinese academy of sciences and university of chinese academy of sciences beijing china lingweicao gmail.com jing zhao school of computer science and technology harbin engineering university harbin china jingzhao.duke gmail.com abstract it is difficult to fix a tomicity violations correctly .
existing gate lock algorithm gla simply inserts gate locks to serializ e executions which may introduce performance bugs and deadlocks .
synthesized c ontext aware gate locks by grail require complex source code synthesis .
we propose fixer to adaptive ly fix atomicity violations.
it firstly analyses the lock acquisitions of a n atomicity violation .
then it either adjust s the existing lock scope or insert s a gate lock.
the former addresses cases where some locks are used but fail to provide atomic accesses .
for the latter it infers the visibility being global or a field of a class struct of the gate lock such that the lock only protects related accesses.
for both cases fixer further eliminates new lock orders to avoid introducing deadlocks .
of course fixer can produce both kinds of fix es on atomicity violations with locks.
the experimental results on previously used atomicity violations show that fixer correctly fixed all atomicity violations with out introducing deadlocks.
however gla and grail both introduced deadlocks .
hfix that only targets on fixing certain types of atomicity violations only fixed atomicity violations and introduced deadlocks .
fixer also provide s an alternative way to insert gate locks by inserting gate locks with proper visibility considering fix acceptance .
ccs concepts software and its engineering software testing and debugging theory of computation program verification.
keywords atomicity violations fix repair concurrency bugs deadlock multithreaded program lock order acm reference format yan cai l ingwei cao and j ing zhao .
.
adaptively generating high quality fixes for atomicity violations .
in proceedings of 11th joint meeting of the european software engineering conference and the a cm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
.
introduction concurrency bugs widely exist in multithreaded programs .
they are difficult to detect and to reproduce as well as to correctly fix .
manual bug fixing not only takes a long time but also is error prone .
recently automated bug fixing becomes popular .
however almost all existing techniques on fixing concurrency bugs insert new locks known as gate locks statically or dynamically to serialize all executions of thread s involved in a concurrency bug including afix axis grail gadara and .
as the i nserted gate locks prevent two or more threads from executing concurrently the original incorrect thread interleaving is eliminated.
we refer to the techniques that insert gate locks as gate lock algorithms gla .
however introducing gate locks may intro duce performance bugs as they always serialize threads of the targeted concurrency bugs.
to solve it grail inserts synthesized gate locks it maps the hash values of the variables from the concurrency bugs to unique gate locks.
however the synthesized gate locks may sometimes reduce fix acceptance .
besides introducing gate locks e.g.
gla or modifying lock scopes e.g.
hfix may introduce various deadlocks .
this is common even for manual bug fixing e.g.
.
incorrect fix es indeed introduce d new deadlocks .
if deadlocks are introduced axis further iteratively fixes these introduced deadlock s by inserting more gate locks .
grail improves afix and axis by adopt ing petri net analysis to avoid introduc ing deadlocks .
however grail is limited to analyse two threads only .
hence grail fails to avoid introducing deadlocks involving other threads out of the targeted concurrency bugs .
hfix targets on fixing a subset of atomicity violations by modifying lock scopes.
it may also introduce performance issues.
a recent work named dfixer introduces lo ck pre acquisitions to fix deadlocks.
as deadlocks involve high level lock acquisitions it is possible to avoid introducing deadlocks by eliminating new lock orders .
however atomicity violations involve low l evel memory accesses.
they may involve lock acquisitions protecting some of their accesses or may involve no lock.
in the latter case gate locks might be necessary however in the former case gate locks together with existing lock acquisitions may form deadlocks.
hence it is more difficult to correctly fix atomicity violations.
hence many existing techniques differentiate concurrency bugs as deadlock and non deadlock bugs as they require different techniques to detect and to fix.
corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with cre dit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany copyright is held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
esec fse september paderborn germany y. cai l. cao and j. zhao in this paper we focus on atomicity violations.
an atomicity violation occurs if an expected atomic set of memory accesses fails to be atomic .
for example figure a shows an atomicity violation two accesses to a pointer p from thread t1 can be interleaved by a write access from thread t2 as indicated by two solid arrows resulting in a npe error null pointer exception .
to fix such atomicity violation s existing works may introduce various problems as discussed above also see section .
we propose an ad aptive approach to fix atomicity violations known as alphafixer or fixer for short.
given an atomicity v iolation fixer firstly identif ies all involved lock acquisitions in it.
if most of the accesses of the atomicity violation are protected by the same lock fixer then tries to fix it by either extending an existing lock scope or combining two existing lock scopes to provide an atomic region to put all accesses under the protection of the same lock.
otherwise fixer inserts a gate lock to fix it.
in the latter case fixer further infer s the visibility1 of the gate lock in order to exactly protect the related accesses that may be involved in the atomicity violations.
to guarantee a deadlock free fix fixer conservatively restricts its lock scope extension or combi nation into three cases see section .
if necessary fixer adopts multiple lock acquisitions i.e.
to acquire multiple locks at a time to eliminate new lock orders.
we have implemented fixer for c c programs and evaluated it on atomicity violations.
we compared fixer with gla grail and hfix where hfix is designed to fix certain types of concurrency bugs.
the evaluation is on the following three aspects correctness2 performance and code readability.
for performance we followed the approach for comparison purpose .
the experiment result s show that fixer fixed all atomicity violations correctly without introducing any deadlock .
however both gla and grail introduced deadlocks hfix was only applicable to fix atomicity violations but introduced deadlocks .
fixer only incurred .
overhead on average however gla grail and hfix incurred a significantly larger overhead .
.
and .
respectively .
fixer also provided a new way to insert gate lock considering the visibility of the variables in the given atomicity violation which is an alternative way to improve fix acceptance .
the main contributions of this paper are as follows it proposes a new strategy fixer to adap tively fix atomicity violations by producing more effective and efficien t fixes.
fixer can insert gate locks to fix atomicity violation s. however it is able to infer the visibility of the gate lock to provide an alternative way to improve the acceptance of fixes.
we have implemented a prototype tool to evaluate fixer cs.ios.ac.cn yancai alphafixer .
the experiment results demonstrate the effectiveness and efficiency of fixer compar ed with existing works .
in this paper the visibility of a variable means that whether it is a global variable or a class struct field.
for the latter case a variable is accessed based on an instance of its class struct .
to fix concurrency bugs thread inter leaving space is usually reduced to be a subset of that before fixing if no deadlock is introduc ed.
therefore the correctness here refers to whether any deadlock is introduced.
.
background and motivations .
preliminaries we focus on two kinds of events in multithreaded programs memory accesses and lock operations .
the later include s lock acquisition s acq m tryac q m acq m n and lock release rel m .
note that acq m blocks its executing thread if lock m is acquired by another thread but tryacq m does not acq m n indicates that a thread tries to acquire two lock s at the same time.
if a thread firstly acquires a lock m and then acquires a nother lock n before releasing lock m there is a lock order from lock m to lock n denoted by m n. if another lock order exists n m or n ... m for multiple threads we say it is a reversed lock order of the lock order m n. there is a special case that if a thread acquires two locks m and n at the same time via acq m n then there is no lock order produ ced between the two locks .
this is because a thread performing acq m n immediately releases any acquired lock if one of them cannot be acquired .
a resource deadlock occurs if a lock order and its reversed lock order occurs at the same time .
but the absence of a lock order and its reversed lock order indicates no deadlock on these lo cks.
.
motivations gla fixes an atomicity violation by inserting a gate lock to serialize the executions of the involved threads .
it could reduce the parallelism of executions from different threads due to over synchronization known as performance bugs and may also introduce deadlocks .
grail may improve performance but may produce fixes with low acceptance due to its lock synthesis .
overall these works focus on th e correctness of their fixes but seldom consider the q uality e.g.
whether the fix code is acceptable and understandable to developers of their fixes .
this point is extremely important when a program is developed by many developers and is developed continually to produce different versions e.g.
mysql .
we show these limitations in the next two subsections with examples .
.
.
performance and acceptance of fixes .
atomicity vi olation av figure shows an atomicity violation av1.
it involves two threads t1 and t2 and two variables buf output and buf outcnt .
the variable buf output is a fix ed size buffer and the variable buf outcnt points to the end of buf output .
please ignore the four highlighted lines starting with i.e.
lines and for now.
the function ap bufferred log writer buffer s characters into buf output and then increments buf outcnt .
however these two operations are not protected by any lock.
as a result if two or more threads concurrently call the function and the executions of two threads could be interleaved as what the a thread t2 p null thread t1 p new obj p.test b thread t2 acq g p null rel g thread t1 acq g p new obj p.test rel g figure .
an atomicity violation a and its fix by gla b .
adaptively generating high quality fixes for atomicity violations esec fse september paderborn germany two solid arrows indicate an atomicity violation will occur corrupting both buf output and buf outcnt .
atomicity violation av figure shows an atomicity violation av2 involving one variable gcur rscript .
the atomicity violation occurs when thread t2 writes a null value to gcurrscript in between the write to gcurrscript at line and the invocation of compile on gcurrscript at line by thread t1 as indicated by the two solid arrows.
although t he original program contains a lock l at lines to protect accesses to gcurrscript this protection is only on the individual access.
it fails to provide an atomic region for two accesses to gcurrscript from th read t1.
to fix av1 gla inserts a lock g to serialize two threads.
this fix is shown in lines starting with i.e.
lines and .
to fix av2 gla inserts a lock g at lines and to prevent the write to gcurrscript at line from occurring in between the two accesses by thread t1.
gla may introduce high runtime overhead.
for example on av1 if the variable bufs of two threads are different then the two variables buf output of two threads are also different .
hence no atomicity violation may occur and the two threads can be executed concurrently .
however after fixed by gla the two threads always execute sequentially due to the unique global gate lock g incurring runtime overhead.
the latest work grail follows gla but synthesizes a context aware gate lock g according to all variables of the targeted atomicity violation as follows g contextl hash v1 hash v2 ... where v1 v2 ... are variables from the atomicity violation and the function contextl ... returns a unique lock corresponding to the inputs i.e.
the hash values of all variables .
thus if the actual variables of two threads are different grail computes two different gate locks.
hence the two threads are able to execute concurrently.
in this way grail does not reduce parallelism if no atomicity violation may occur.
figure shows the two gate locks generated by grail to fix av1 and av2 respectively.
however there are three main limitations of grail .
firstly the readability of fix by grail might be worse than that by gla.
for example on fixing av1 and av2 the inserted lock acquisition by gla is simply acq g where the lock g is globally defined once.
whereas the gate lock inserted by grail are g contexl hash buf outcnt hash buf output acq g and g contextl hash gcurrscript acq g respectively.
these fixes may be difficult for developers to understand.
secondly a synthesized context aware lock may not be always required.
if an atomicity violation involves only glo bal variables e.g.
on av2 a global lock is enough.
in this case even if the gate lock is produced by grail the produced gate locks will always be the same.
otherwise if an a tomicity violation involves class including struct level variables a gate lock of the same class level will be enough e.g.
on av1 .
thirdly the implementation of contextl ... might be complex.
for example the original implementation uses string .intern function provided by native code of jdk.
this implementation maintains a hashtable structure and a lock to protect operations on it.
on each call to string .intern the hashtable is iterated to search for a unique string object which is taken as a lock in java see the function jvm internstring in jvm.cpp .
for c c a similar pair of map table and lock is also require d. considering above discussions the fix es generated by grail may have a low acceptan ce to developers.
of course different developers may hold differ ent views on what kind of fix es they may prefer to accept.
.
.
introduc ing deadlocks .
on av1 gla inserts a lock g to serialize two threads.
this is a correct fix.
however on av2 after gla inserts a lock it also introduces three new lock orders two l g i.e.
from line to line and from line to line and one g l from line to line as shown in three dotted arrows .
the two lock orders l g i.e.
from line to line and g l from line to line form a deadlock.
actually another deadlock is introduced from two locks orders l g from line to line and g l from line to line if they can be formed by multiple threads at the same time .
grail further relies on petri net analysis to prevent introducing deadlocks which is limited to two threads only .
for some special atomicity violations like av2 where the same lock e.g.
lock l is used to protect part of accesses a recent work hfix suggests a fix mov e either an acquisition or a release thread t1 .ap buffered log writer ... .
.
acq g .
idx buf outcnt .
s buf output .
buf outcnt len .
rel g .
thread t2 .ap buffered log writer ... .
.
acq g .
idx buf outcnt .
s buf output .
buf outcnt len .
rel g .
struct buffered log apr size t outcnt char outbuf figure .
an atomicity violation av from apache with bugid and a fix to it by gla .
thread t1 .
acq l .
... .
acq g .
gcurrscript ... .
... .
rel l .
... .
acq l .
... .
gcurrscript compile .
rel g .
... .
rel l thread t2 .
acq l .
... .
acq g .
gcurrscript null .
rel g .
... .
rel l figure .
an atomicity violation av from mozilla and its fix by gla .
thread t2 acq l ... g contextl hash gcurrscript acq g gcurrscript null rel g ... rel l thread t2 ap buffered log writer ... g contextl hash buf outcnt hash buf output acq g idx buf outcnt s buf output buf outcnt len rel g a b figure .
the two gate locks genearted by grail to fix av a and av b .
esec fse september paderborn germany y. cai l. cao and j. zhao statement to protect all other accesses not protected by the same lock.
on av2 hfix may either move rel l at line to a location right after line or move acq l at line right before line .
however t his fix actually introduces a self deadlock as thread t1 will acquire lock l twice where the second acquisition is blocked.
besides it may still introduce other deadlocks.
for example if there is a lock acquisition acq m between line s and a new lock order l m will be introduce d. then a deadlock is introduced if another thread form s a lock order m l. .
our approach .
rationale and overview an atomicity violation involves at least three accesses to a set of shared variables.
it is possible that these accesses are protected by some locks e.g.
on av2 .
but it is also possible that no lock protects the involved accesses e.g.
on av1 .
therefore our insight is it is not always necessary to introduce new loc ks to serialize threads to fix atomicity violation s. if there are already some locks protecting most of the involved accesses the locks could be slightly adjusted to fix these atomicity violations.
for example in figure av2 could be fixed by combining the two separated locking regions i.e.
removing rel l at line and acq l at line .
by so the two accesses to gcurrscript from thread t1 are fully protected by lock l hence the access at line by thread t2 cannot be interleaved in between the two accesses.
and av2 is fixed.
on the other hand no lock may protect any access from an atomicity violation.
in this case a new lock is necessary.
however when introducing a new lock the introduced lock orders if any must be carefully handled to avoid introducing deadlocks.
besides if a new lock is required the visibility of the l ock should also be carefully determined .
unlike grail that synthesize s a gate lock it would be better if we could insert a lock with the same visibility as that of the involved variables.
although the first step is to adjust any existing lock protection a gate lock can also be inserted to fix an atomicity violation.
it is difficult to say which fix is better.
for example if the two accesses of an atomicity violation are far away to each other and if the same lock protects the two accesses separately th en adjusting the two lock scopes may incur high runtime overhead.
there fore if an atomicity violation can be fixed by adjusting its lock scopes fixer further produces a second fix by inserting a gate lock.
the second fix can also be an option to developers.
overall as shown in figure fixer firstly analyses the given atomicity violation to identify all involved lock acquisitions and then de termine s whether to adjust the lock scope or to insert a gate lock.
for the latter as a new lock is required fixer infers the visibility of the involved variables to determine whether the new lock should be a global one or a class field one.
next fixer analyses the involved locks to avoid introducing deadlocks.
.
adjust lock scopes to fix atomicity violations for atomicity violations that already involve some locks protecting the accesses they might be fixed by slightly adjusting the lock scope s. in this paper we only focus on three scenarios as shown in figure where a box with a lock indicates a pair of lock acquisition and release case a all accesses e.g.
a1 a2 and a3 are separately protected by the same lock .
in this case the atomicit y violation could be fixed via combination comb ine two separated lock scopes of the same lock of the corresponding thread i.e.
thread t1 in case a .
case b and case c only part of accesses from a thread is protected by a lock and other accesses from the second thread are all protected by the same lock.
then the atomicity violation could be fixed via extension extend the lock scope of the first thread to also protect the remaining accesses from this thread i.e.
thread t1 in cases b and c .
there might be other cases where the lock scope s can be changed to fix atomicity violations.
our criterion is that there must be the same lock protect ing at least one access of each thread.
hence for other cases we fix them by inserting gate locks see the next subsection .
note that hfix has a similar suggestion as case b and case c. however hfix does not distinguish case a from cases b and c. hence on case a hfix can introduce self deadlocks as discussed in section also see our experiment in section .
.
adjust lock scope generate a patchinsert a new lock g infer lock visibility avoid introducing deadlockyes yesnono global or class fieldany lock already?
any other acquisition?an atomicity violation figure .
an overview of our fixer .
case a case b case ca3a1 a2 a3a1 a2 a3a1 a2thread t1 thread t2 a3a1 a2 a3a1 a2 a3a1 a2thread t1 thread t2legend a original lock scope combination extension extensiona changed lock scope figure .
the three cases to fix certain atomicity violations where the arrows also indicate the error interleaving .
adaptively generating high quality fixes for atomicity violations esec fse september paderborn germany .
introduce new locks to fix atomicity violations a new lock is necessary to fix an atomicity violation via gate lock strategy .
unlike gla that introduce s a global gate lock fixer tries to introduce a context aware gate lock.
unlike grail that introduces a synthesized lock fixer automatically infers the lock visibility of the new locks to avoid synthesizing gate locks .
as a result fixer provides an alternative way to insert gate locks .
.
.
infer visibility of gate locks .
we found that for an atomicity violation the visibility of the involved variables is usually determined either global variables or class field variables.
here the fields refe r to the variable member of class in object oriented languages e.g.
c or struct e.g.
c .
for example the variables outcnt and output in figure are two fields of the struct buffered log and the variable gcursc ript in figure is a global variable.
hence given an atomicity violation if all its variables are global an explicit global lock is enough otherwise if all involved variables are fields of the same class instance a field lock within the same class is also enough.
in these two cases even if we follow grail to synthesize gate locks the synthesized gate lock s are always the same global lock for the former case or are always the same lock of the same class instance .
hence there is no need to additionally synthesiz e gate locks dynamically a unique global gate lock or a class level gate lock is enough.
for single variable atomicity violation the involved variable is deterministically a global one or a class field.
however for multi variable atomicity violations the involved variables may contain global variables only or field variables of the same class instances or both global ones and class fields or multiple fields of different class or fields of the same class but differe nt class instances.
the first two cases can be handled in the same way as handling single variable atomicity violations because all involved variables are either global ones or fields of the same class instance .
however t he last three cases are more complex.
to fix them fixer simply insert s a global lock to serialize two threads.
admittedly the synthesized gate locks by grail may perform better than the global lock s theoretically .
note that the fields of a class struct may also be global e.g.
declared to be static .
such cases can be easily handled and hence are not discussed in this paper.
.
.
insert gate locks .
once the visibility of a gate lock is determined it is straightforward to insert th e gate lock to serialize the two threads of the given atomicity violation.
this step is the same as what gla performs see figure b where the gate lock is the lock g .
.
avoid intro ducing deadlocks .
.
why can deadlocks be introduced?
fixer fixes an atomicity violation by either adjusting lock scope of an existing lock or inserting a gate lock.
in both cases deadlocks may be introduced.
we discuss the two cases below.
deadlocks may be introduced by adjusting lock scope s. recall that adjusting lock scopes consist s of either combination or extension.
the c ombination of two separated lock scopes may introduce new lock orders if in between the two separated scopes there are other l ock acquisitions.
consider the example in figure a where a pair of acquisition and release on lock m exists in between two lock scopes on lock l. after combining the two lock scopes on lock l into one a new lock order l m is introduced .
similarly the extension of a lock scope to protect more accesses may also introduce new lock orders as shown in figure b .
then for above two scenarios deadlock s are introduced if a different thread has the lock order m l as shown in figure c .
if a gate lock is introduced deadlocks may also be introduced.
we have demonstrated this in figure b .
to ease the presentation w e refer to locks that are nested in combined or extended lock scopes or inserted gate lock scopes as inner locks i.e.
lock m in figure and lock l at line in figure and we refer to the corresponding new lock orders a s inner lock orders i.e.
l m in figure and g l in figure .
similarly we refer to new lock orders from other existing locks to adjusted locks or to insert ed gate locks as outer lock orders l g in figure and we refer to the former existing locks as outer locks lock l at line in figure .
.
.
how to avoid introducing deadlocks .
for the inner lock orders e.g.
l m or g m if the inner locks i.e.
lock m can be identified then these lock orders can be eliminated by acquiring two locks together i.e.
acq l m or acq g m .
this is because the inner locks if any exist in between the two accesses of one thread and the two accesses usually have a short distance in term of source code lines.
otherw ise if the inner locks cannot be acquired together with the adjusted locks or the inserted gate locks fixer gives up fixing the atomicity violation .
when an inner lock m is acquired together with the adjusted lock l it is possible that th is lock m is actually the lock l. in this case a self deadlock is introduced as the lock will be acquired twice.
however it is difficult to statically know whether the two locks l and m are the same one especially when the class struct instances are involved .
to solve this challenge we change the property of lock m to be reentrant i.e.
recursive lock because a reentrant lock can be acquired and released multiple times in a nested manner by the same thread .
for the inserted gate lock g we also set both lock g and any inner lock m to be a reentrant lock considering recursive function calls.
if an inner lock e.g.
lock m in figure is acquired together with adjusted locks or inserted gate locks e.g.
acq l m or acq g m to avoid introducing new lock orders we do not remove the original lock acquisition e.g.
acq m on inner locks.
because the a thread t2 acq l a1 acq m rel m a2 rel l thread t1 acq l a1 rel l acq m rel m acq l a2 rel l thread t2 acq l a1 acq m rel m a2 rel l thread t1 acq l a1 rel l acq m rel m a2 b thread t3 acq m acq l c figure .
new lock orders are introduced if lock scopes are adjusted.
esec fse september paderborn germany y. cai l. cao and j. zhao original lock acquisition may exist in a different function which can be called from a different control branch.
otherwise we have to adopt ad hoc synchronization to fix program control as adopted in dfixer to fix deadlocks which is usual ly harmful .
for the second type of outer lock orders introduced due to inserted gate locks i.e.
k g where lock k is acquired before the acquisition on lock g if all inner lock orders are elimina ted i.e.
g m no deadlock will be introduced.
this is because outer lock orders alone without their reversed lock orders cannot form any deadlock s. however for the second type of outer lock orders introduced by lock adjusting i.e.
k l where lock k is acquired before the acquisition on lock l even if we eliminate their reversed lock order l k a third thread may still form their reversed lock orders l k. this is because unlike inserted gate locks these locks already exist before fixing.
in this case we give up fixing such atomicity violation s by adjusting locks instead we try to fix it by introducing a gate lock as shown in figure .
of course in this case the fix ing approach via adjusting locks can be a suggestion.
besides lock acquisitions and releases other additional lock synchronizations e.g.
wait l and notify l may be involved in one or more threads of atomicity violations.
such cases are complicated .
therefore we only consider one case where a lock is adjusted to fix an atomicity violation and the additional synchronization s is with in the lock scope protected r egion of the adjusted lock before and after adjusting .
in this case no new lock order is introduced.
for other cases fixer gives up its fixing.
limitations .
fixer may fail to fix an atomicity violation in two cases there is other inner lock in between the two accesses of a thread and such lock s cannot be acquired together with the inserted gate lock or the adjusted lock and synchronizations except lock acquisitions and releases will be contained within the adjusted lock scope or the sc ope of the inserted gate locks except the case discussed in the last paragraph .
to guarantee a theoretical correctness fixer gives up fixing such atomicity violation s. .
.
guarantee of fixer .
fixer does not guarantee to fix all atomicity violations as discus sed in the last subsection.
however if it generates a fix it guarantees to fix the atomicity violation without introducing deadlocks as theorem .
theorem .
given an atomicity violation av if fixer generates a fix it does not introduce any deadlock.
proof sketch.
we prove the theorem via three cases showing that the fix does not introduce resource deadlocks communication deadlocks and self deadlocks respectively .
and we mainly prove the scenarios where a gate lock is inserted .
the scenarios where a lock is adjusted can be proved similarly.
a suppose that fixer introduced a gate lock g to fix av.
if no new lock order is introduced there is no way for fixer to introduce a resource dead lock.
now s uppose that there are other locks within the scope of gate lock acquisitions these locks are acquired together with the gate lock g by following fixer approach see the first paragraph of section .
note if any inner lock cannot be acquired together with gate lock fixer does not produce any fix see the last paragraph of section .
hence any potential inner lock orders are eliminat ed.
next s uppose that some outer lock orders from an outer lock is introduced say k g where k is an outer lock.
however as no any inner lock order e.g.
g l where the lock l may be the lock k is introduced.
hence no reversed lock order of the introduced outer lock order k g is introduced.
therefore no resource deadlock is introduced by fixer .
b if there are other synchronizations e.g.
wait and notify by following fixer approach see the 6th paragraph of section fixer only adjusts lock scope if before and after adjusting the synchronizations are always within the original scope .
that is after adjusting the lock orders remain the same as that before adjusting the lock scope.
hence fixer does not block any communication i.e.
not in troduce communication deadlocks .
c if any lock is inserted or adjusted fixer changes it to be re entrant lock see the 1st paragraph of section .
this enables a thread to acquire the same lock multiple time s without blocking itself.
hence fixer does not introduce self deadlocks.
based on the above analysis theorem is proved.
.
our approach on examples the fix to av1 by fixer is shown in figure a where we only show one thread as two threads share the same code lines .
on av1 no lock is found .
then fixer introduces a gate lock g to fix it.
this fix is the same as gla.
however fixer firstly inserts a lock g to the struct buffered log before insert ing lock acquisition and release acq buf g and rel buf g .
this brings an alternative fix code lines besides that by grail see figure .
to fix av2 fixer combines the two lock scopes of lock l for thread t1 as shown in figure b .
this fix is obviously simple and different from that by gla and grail .
besides on av2 no deadlock is introduced by fixer whereas hfix introduces a self deadlock see the last paragraph of section .
.
fix program control flow like other approaches fixer also needs to fix program cont rol flows which is similar to existing works .
for example when an acquisition acq g is inserted its corresponding release rel g should be inserted at each exit branch containing the inserted acq g .
ap buffered log writer ... acq buf g idx buf outcnt s buf output buf outcnt len rel buf g struct buffered log apr size t outcnt char outbuf lock g b how fixer fixes av2.
a how fixer fixes av1.thread t1 acq l ... gcurrscript aspt ... rel l ... acq l ... gcurrscript compile ... rel l thread t2 acq l ... gcurrscript null ... rel l figure .
one way to fix av and av by fixer .
on av we only show one thread as two threads share the same code lines.
on av the fix is to combine two separated lock scope corresponding to case a in figure .
the second fix to av by fixer i.e.
inserting a gate lock is omitted.
adaptively generating high quality fixes for atomicity violations esec fse september paderborn germany .
user study of grail and fixer this section presents our user study on the fix es to the atomicity violations av1 and av2.
we decided to conduct the user studies on these two atomicity violations as they are representatives among all benchmarks in our experiment see section .
the questionnaire firstly offered a brief introduction to atomicity violation s. the second part s were the two original pieces of code with two atomicity violations and two short description s on how they could occur as well as the two fixe s of grail and fixer which were referred to as tool1 and tool2 respectively .
we designed four selection questions between tool1 and tool2 which fix is more understandable unders tandabil ity which fix is more readable readability which fix may incur larger overhead and which fix do you prefer ?
for each question we offered an any option to indicat e an equal or an unclear preference.
we also requested participants to fill their occupations and any additional comments.
our questionnaire was distributed via the social network community wechat see our tool website .
there was no time limit for participants to answer the questions before we collected the results at the paper submitting time .
totally there were participants from mathematics from finance from it companies.
table presents the results.
from the table it shows that more than participants held a preference on fixer other than on grail in terms of und erstandability and readability.
on overhead more than participants regarded that grail incurs larger overhead .
finally fixer was well accepted preferred by more than participants .
among the participants only of them filled their comments and comments obviously pointed out that tool2 i.e.
fixer should be more readable straightforward adaptive and simpler e.g.
different fix for different variable visibility .
the remaining one did not point ou t whic h one is better .
.
experiment .
benchmarks we selected a set of real world benchmark s including benchmarks.
w e excluded of them deadlock duplicated bug i.e.
cherokee order violations and atomicity violation involving java code .
including our two motivating examples where av1 is from apache there are benchmarks.
some benchmarks can not be correctly compiled in our experiment environment .
we follow ed an existing work to extract the source code containing atomicity violations.
all these atomicity violations are listed in table including whether we used the original benchmarks or the extracted one s under the column original .
.
implementation and experimental setup we have implemented fixer gla i.e.
the afix algorithm grail and hfix within llvm .
framework .
llvm ir does not support class struct information .
we modified clang frontend to generate the information for fixer to infer lock visibility .
grail synthesizes context aware gate locks which is based on string.intern from java library .
we extracted the openjdk impleme ntation of string.intern .
after applying the four techniques to all benchmarks we ran each fixed p rogram by each technique for times and collected th e results .
during this runs we inserted a set of random sleep before and after each lock acquisition of the fixed programs to amplify the probabilities for any introduced deadlock to occur .
we also ran them for additional times without sleep t o collect their execution time except on those where deadlocks frequently occurred after fixing .
to evaluate the performance scalability of the fixed programs we followed to amplify the overhead introduced by each technique for comparison purpose .
we configure d the number of threads to be and .
note that this amplification only applies to execution of the code lines involved in atomicity violations.
this is the same as the previous work .
our experiments were conducted on a thinkpad workstati on with a processor i7 4710mq installed with ubuntu .
.
.
result analys es in this section we firstly present the summary of fixing results .
next we separately compare fixer with hfix first and then compare fixer with gla and grail .
this is because hfix is only applicable to atomicity violations with some lock s by merg ing two lock scopes.
among our benchmarks only out of benchmarks can be handled by hfix.
.
.
fixing summary .
table summarizes the fixing results by all four techniques on all atomicity violations.
overall both gla and grail correctly fixed i.e.
atomicity violations.
hfix only correctly fixed i.e.
atomicity violations.
our fixer correctly fixed all i.e.
atomicity violations.
besides on performance scalability testing with threads gla incurred the largest overhead .
on average followed by grail incurring .
average overhead.
hfix incurred an average overhead of .
.
fixer only incurred an average overhead of .
.
from the summary fixer outperforms all other techniques considering both effectiveness and efficiency .
.
.
comparisons on effectiveness.
table a and b show the fixing result s. the first three columns show the benchmark information.
the fourth major column show s the fix es by fixer .
the table also shows the results of fixer and hfix on the atomicity violations involving locks .
in the table adjl a means that fixer fixed the benchmark by adjusting an existing lock table .
fixing summary of all techniques.
total of fixed atom.
violations avg.
overhead gla grail hfix fixer gla grail hfix fixer .
.
.
.
table .
statistics on user studies.
tool1 grail tool fixer any av understandability .
.
.
readability .
.
.
larger overhead .
.
.
preferred fix .
.
.
av understandability .
.
.
readability .
.
.
larger overhead .
.
.
preferred fix .
.
.
esec fse september paderborn germany y. cai l. cao and j. zhao adjl according to case a as shown in figure .
the sub column l type shows the lock visibility global or field that fixer adjusted or inserted.
the remaining columns of table a show the number of new lock orders introduced by each technique in form of outer inner the number of deadloc ks introduced by each technique the average overhead of each technique at the number of threads to be .
in the last row we also show the sum mation values or the average values for the last three major columns.
table b shows the results of fixer gla and grail on fixing all atomicity violations.
table b can be read in the same way as table a except the fourth column which shows whether fixer inserts a global or a field gate lock.
in table the mark s under the last major column average overhead indicate that no data was collected because for gla grail and hfix after fixing deadlock s frequently occurred explained below .
note that both kinds of fix es by fixer were listed in table for comparison purpose.
hfix was only applicable to atomicity violations.
among these atomicity violations three of them fall into case a one of them falls into case b and the remaini ng two fall into case c. from table a it is observe d that hfix introduced inner lock orders and they formed self deadlocks.
from table b we observe d that both gla and grail introduced new lock orders on benchmarks fixer introduced new lock orders on benchmarks.
however fixer only introduced out er lock orders but no inner lock orders and it did not introduce any deadlock s. this is consistent with its guarantee.
but both gla and grail introduced deadlocks respectively .
subsection .
.
will discuss why hfix gla and grail introduced deadlocks .
.
.
comparisons on efficiency .
from table a we observe d that on the only two benchmarks that hfix was able to fix correctly both hfix and fixer introduced almost the same overhead i.e.
.
vs .
and .
vs .
.
this is because the two techniques produced the same fix except some fix code by fixer to avoid introduce deadlocks.
from table b it is observe d that fixer incurred significantly lower overhead than that by gla and grail even on benchmarks that all the three techniques handled correctly.
compared with gla grail incurred lower overhead.
this is because fixer is able to infer the lock visibility and can insert a class field gate lock however gla always inserts global locks and grail always inserts synthesized locks wh ich may take effect but may introduce additional overhead on maintaining the map from a hash value to a unique lock .
figure show s the performance scalability of all techniques with increasing number of threads.
the x axis of each sub figure shows the number of threads from to and the y axis shows the time in microsecond s .
particularly figure a shows the scalability comparison of hfix and fixer and figure b shows the scalability comparison of gla grail and fixer .
note if hfix gla or grail failed to correctly fix an atomicity violation and no data was collected the time of fixer is still shown for comparison with that f rom the original runs.
the advantage of fixer on inferring lock visibility is clearly reflected in figure where we highlight the sub figures in gray background if a field lock was adjusted or inserted by fixer .
figure a shows that on two benchmarks that hfix were able to fix correctly both hfix and fixer intro duced almost the table .
a detailed comparisons of adjusting lock fixes by hfix and fixer .
benchmark original?
loc fixer of new out er inner lock orders of deadlocks average overhead case l type hfix fixer hfix fixer hfix fixer mozilla adjl a global .
apache .34k adjl a field .
apache .86k adjl b field .
.
mysql adjl a global .
mysql adjl c field .
mysql adjl c field .
.
sum avg.
.
.
b detailed comparisons of gate lock fixes by gla grail and fixer .
benchmark original?
loc fixer of new out er inner lock orders of deadlocks average overhead l type gla grail fixer gla grail fixer gla grail fixer mozilla global .
aget .
.32k global .
.
.
apache .34k field .
apache .61k field .
.
.
apache .61k field .
.
.
apache .86k field .
cherokee .
.
.76k field .
.
.
memcached .27k global .
.
.
mysql global .
mysql field .
mysql field .
.
.
mysql field .
.
.
mysql field .
.
.
mysql field .
.
.
mysql field .
.
.
sum avg.
.
.
.
adaptively generating high quality fixes for atomicity violations esec fse september paderborn germany same overhead .
figure b shows that fixer obviously incurred the least overhead compared with that by gla and grail .
on sub figures not highlighted i.e .
figure b.b and b.h all techniques incurred the similar overhead.
on remaining sub figures not highlighted i.e .
figure b.a and b.i all techniques except fixer failed to fix the atomicity violations and no data was collected for gla and grail.
on the other hand from figure b among most of sub figures gla incurred the largest overhead and grail incurred less overhead than that by gla.
this is consistent with the previous experimental result .
however on three atomicity violation s aget .
memcached and mysql i.e.
figure b.b b.h and b.k gla incurred less overhead than that by grail .
we have identified that on the first two the involved variables are global ones .
hence grail always synthesized the same gate locks.
on the last one although the variables are class fields there is a global lock named lock open that is firstly acquired by both threads.
hence grail gained no advantage by synthesizing a gate lock.
instead its synthesizing process increased its overhead.
.
.
case studies and discussions .
one of the main contributions of fixer is if a gate lock is inserted the ability to infer lock visibility to reduce potential fixing overhead .
we have presented how our fixer inserted a class struct field gate lock to fix av1 from apache .
the case on mysql is almost the same as av1 where an atomicity violation occurs between two writes to log type from a thread and a read to it from a different thread.
and this variable log type is from a class mysql log .
to fix this atomicity violation grail also inserted a synthesized hash lock g contextl hash this log type acq g which unintentionally indicates that the lock g has nothing to do with the c lass mysql log .
however fixer identified that log type is a member of class mysql log and then inserted a lock g as a member of this class.
finally it only inserted an acquisition acq this g and acq mysql log g in another thread .
this fix might be more understandable as it is clearly reflected that the lock g is used to protect its neighbor member lock type of the same class mysql log .
hence such kind of fixes provides an alternative way to improve fix acceptance to developers.
a performance scalability of hfix and fixer.
b performance scalability of gla grail and fixer.
figure .
performance scalability where the x axis shows the increasing number of threads from to and y axis shows the execution time s .
f mysql169afixer orig hfix a mozillaafixer orig b apache21285 afixer orig c apache45605afixer orig hfix d mysql12228afixer orig e mysql12848afixer orig k mysql 169afixer gla grail orig l mysql 2011afixer gla grail orig m mysql 3596afixer gla grail orig n mysql 644afixer gla grail orig o mysql afixer gla grail orig0600120018002400 g cherokee .
.2afixer gla grail orig h memcached 127afixer gla grail orig f apache 45605afixer orig i mysql 12228afixer orig j mysql 12848afixer orig02004006008001000 b aget .4afixer gla grail orig d apache 21287afixer gla grail orig e apache 25520afixer gla grail orig a mozillaafixer orig c apache afixer orig esec fse september paderborn germany y. cai l. cao and j. zhao study on deadlock introduction.
from table gla and grail both introduced deadlocks.
on mozilla the introduced deadlock is shown in figure and w e have analysed the reason.
the other deadlocks on apache apache mysql and mysql are similar to that on mozilla .
among our benchma rks hfix is only applicable to fix atomicity violations but introduced deadlocks see table a .
these deadlocks are self deadlocks.
we have analysed the introduced deadlock on mozilla .
figure shows another case from mysql .
in figure the atomicity violation occurs if in between line and line two writes to qsize a second thread reads the value of qsize.
this program contains a lock gmutex protect ing the two accesses at lines and hence hfix is applicable to fix it by enlarg ing the lock scope of gmutex between line s and to protect the write to qsize at line .
that is hfix moves the lock release rel gmutex to line i.e.
rel gmutex .
then all three accesses to qsize are protected by lock gmutex.
however at line there is a call to function init cache which also contains a pair of lock acquisition and release on lock gmutex.
hence thread t1 is blocked when it enters function init cache to acquire lock gmutex as which has been acquired by itself at line .
thus a self deadlock occurs.
fixer is able to correctly fix this atomicity violation.
according to figure this atomi city violation falls into case c. hence fixer also tries to fix it by extending the lock scope of gmutex which is the same as hfix .
next fixer has to ensure that no new inner lock order is introduced from lock gmutex to other locks in between line and line .
then fixer found a pair of lock acquisition and release on the same lock gmutex after lock scope extension .
finally fixer put this lock acquisition together with lock acquisition at line i.e.
in form of acq gmutex gmutex and modified the property of this lock to be reentrant.
in this way this potential self deadlock is avoided.
discussion on hfix .
hfix can also be adapted to change the locks to be re entran t locks to avoid introducing self deadlock.
however it still cannot avoid introducing other deadlocks as it may introduce new lock orders see section .
besides hfix only targets on fixing atomicity violations involving locks.
from our benchmarks we see t hat there are still many atomicity violations e.g.
out of not involv ing locks hfix fails to fix these atomicity violations .
what s more in some cases even if an atomicity violation can be fixed by adjusting a lock gate lock strategy might be better.
for example on mysql a global lock lock open is used to protect a class field variable .
in such cases a field lock under the same clas s might be better.
it is difficult to say which fix is better without deep ly understanding the source code.
however fixer can produce both kinds of fixes.
.
related work concurrency bugs widely exist in multithreaded programs .
many techniques have been proposed to fix them automatically .
many of these techniques insert gate locks to serialize executions of threads involved in the bug .
the inserted gate lock may introduce performance bugs and deadlocks as already noticed .
although deadlocks could be theor etically detected via reachab ility analysis or model checking they cannot scale up to la rge scale programs .
we have extensively discussed gla grail and hfix .
dfixer adopts lock pre acquisiton to fix deadlocks by eliminating the hold and wait condition that is a necessary condition for a deadlock to occur .
however dfixer is not applicable to fix concurre ncy bugs involv ing memory accesses.
fixer is specially designed to fix atomicity violations.
flint tries to fix linearizability violation in concurrent compositions i.e.
map data structure .
concbugassist automatically infers wrong interleaving and then applies constraint s i.e.
gate locks wait and notify operations to fix concurrency bugs .
unlike fixer concbugassist may introduce deadlocks.
concurrency bugs can also be prevented or avoi ded .
gadara and dimmunity prevent previous ly occurred deadlock s by invoking gate locks depending on whether a deadlock may occur based on execution context matching .
fixer could be adopted into these techniques to infer the visibility of gate locks to be inserted to improve runtime overhead.
recovery techniques coul d be considered once a concurrency bug occur s. conair tries to recover most concurrency bugs with low overhead .
sammati and aim to provide deadlock recovery by rolli ng back executions .
lin et al.
propose to change lock acquisition primitives i.e.
from acq to tryacq .
however recovery might be infeasible as discussed in considering unrecoverable operations e.g.
file io operations .
.
conclusion concurrency bugs are difficult to be fixed correctly .
we present ed fixer to fix atomicity violations adaptively .
it analyses the lock acquisitions involved in a given atomicity violation to determine whether to adjust existing lock acquisitions or to insert gate lock s to fix atomicity violation s. for the latter case u nlike existing approaches that insert global or synthesized gate locks fixer tries to insert either global lock s or class struct field lock s to generate fixes that are more efficient .
besides fixer guarantees deadlocks free fixes .
we demonstrat ed the effectiveness and the efficiency of fixer over a set of real world benchmarks.
acknowledgement we thank anonymous reviewers for their invaluable comments and suggestions on improving this work.
this work is supported in part by national natural science foundation of china nsfc grant no.
and national program of china 2014cb340702 and the youth innovation promotion association of the chinese academy of sciences yicas .
thread t1 .resize ... .
acq gmutex .... .
qsize .... .
rel gmutex .... .
qsize init cache .
rel gmutex .
thread t2 .... .acq gmutex .... .if qsize ... .... .rel gmutex init cache acq gmutex ... rel gmutex ... figure .
the atomicity violation from mysql .
adaptively generating high quality fixes for atomicity violations esec fse september paderborn germany