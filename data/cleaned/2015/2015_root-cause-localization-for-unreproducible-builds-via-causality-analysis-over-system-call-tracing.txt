root cause localization for unreproducible builds via causality analysis over system call tracing zhilei ren key laboratory for ubiquitous network and service software of liaoning province school of software dalian university of technology zren dlut.edu.cnchanglin liu department of computer and data sciences case western reserve university cxl1029 case.edu xusheng xiao department of computer and data sciences case western reserve university xusheng.xiao case.eduhe jiang school of software dalian university of technology jianghe dlut.edu.cntao xie department of computer science and technology peking university taoxie pku.edu.cn abstract localization of the root causes for unreproducible builds during software maintenance is an important yet chal lenging task primarily due to limited runtime traces frombuild processes and high diversity of build environments.
toaddress these challenges in this paper we propose r eptrace a framework that leverages the uniform interfaces of system call tracing for monitoring executed build commands in diverse build environments and identifies the root causes for unreproduciblebuilds by analyzing the system call traces of the executed buildcommands.
specifically from the collected system call traces r eptrace performs causality analysis to build a dependency graph starting from an inconsistent build artifact across two builds via two types of dependencies read write dependenciesamong processes and parent child process dependencies andsearches the graph to find the processes that result in the inconsis tencies.
to address the challenges of massive noisy dependenciesand uncertain parent child dependencies r eptrace includes two novel techniques using differential analysis on multiplebuilds to reduce the search space of read write dependencies and computing similarity of the runtime values to filter outnoisy parent child process dependencies.
the evaluation results of r eptrace over a set of real world software packages show that reptrace effectively finds not only the root cause commands responsible for the unreproducible builds but also the files topatch for addressing the unreproducible issues.
among its top identified commands and files r eptrace achieves high accuracy rate of .
and .
in identifying the root causes respectively.
index t erms unreproducible builds localization system call tracing i. i ntroduction a software build is reproducible if given the same source code build environment and build instructions any user cangenerate bit by bit identical copies of all specified artifacts .in this definition the source code refers to a copy of thecode checked out from the source code repository and thebuild artifacts include executables distribution packages and file system images.
note that relevant attributes of the build environment including build dependencies build configu ration and environment variables are kept as part of thetable i snippet of v aria tions according to the reprotest tool chain v ariation first build second build env tz gmt gmt env lang c.utf one of fr ch.utf zh cn es es ru ru.cp1251 kk kz.rk1048 umask filesystem default file system disorderfs... ... ... input for building the artifacts.
a reproducible software build plays a critical role in various important applications such as build environment safety software debugging and continuousdelivery .
reproducible build validation has emerged in recent years as one important software development practice which aimsto construct an independently verifiable bridge between thesource code and the build artifacts.
many open source softwareprojects have initiated their validation processes such as debian guix and f droid .
in particular to validate the reproducibility of software packages in different build environ ments variations aside from the specified build environmentcould be introduced deliberately.
for example disorderfs a userspace file system that introduces non determinism intometadata is used to validate whether the issue of file ordering affects the reproducibility of the build.
table i illustratesexample variations introduced by the validation tool chainnamed reprotest 2of the debian distribution.
once a build is identified as unreproducible i.e.
there exists any artifact with different checksum values over buildenvironments with variations it is critical yet challengingto perform causality analysis that identifies the root causes usually one or more build commands for the unreproduciblebuilds since build processes usually produce insufficient run time traces for locating root causes.
as shown in a previousstudy the main source of runtime traces available for ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxb sf ohjoffsjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
locating problematic files that result in unreproducible builds is the build log being the verbose output of the make build system.
however the build log contains only high level buildcommands and cannot capture the low level build commandsinvoked by the high level build commands these low levelbuild commands can play a critical role in causality analysis.for instance consider a posix shell script invoked in amakefile.
from the build log the execution of the scriptcould be reflected but we cannot know what underlying buildcommands have been invoked inside the script.
also the buildlog often contains a lot of noises for causality analysis such asgreeting information progress indicator and test case output.such irrelevant information makes it difficult to extract usefulinformation.
another major challenge for causality analysis is to deal with the high diversity of build environments.
indeed it ispossible to instrument the build commands for tracing thedependencies between the inconsistent artifacts and the build commands for some specific build systems.
however such an intrusive approach is not practical in many industrial softwareprojects because modern software projects such as linuxdistributions often use different types of build systems such asautomake 3and cmake4 for different components.
additionally these projects use many build maintaining scripts written in posix shell python perl etc .
it is difficult to instrument all these scripts for tracing the executed commands.
to address these challenges in this paper we propose a framework r eptrace that collects the system call traces of the executed build commands i.e.
the processes spawnfrom the commands and performs causality analysis overthe traces for identifying the root causes for unreproduciblebuilds.
our work is inspired by the recent successes of systemcall tracing in monitoring executed commands for variousresearch fields such as intrusion detection computationalreproducibility and system profiling .
in particular system call tracing provides two unique benefits.
first system call tracing provides a uniform interface for monitoring theoperating system such as process control file management and communications.
hence it is possible to capture more ac curate information of the build process.
second since systemcall tracing does not rely on certain types of build systems it can be used in different build environments.
to conduct causality analysis with system call tracing r eptrace builds a dependency graph of inconsistent artifacts based on two types of dependencies and searches the graph to identify the process that causes the inconsistencies.
specifically r eptrace defines two types of dependencies read write dependency two processes p1andp2are said to have the read write dependency if p1writes to a file and then p2reads from the file parent child process dependency two processes p1andp2are said to have the parent child dependency if p1spawnsp2.
based on these dependencies reptrace starts from the inconsistent artifact and then iden3 the responsible processes based on the dependencies ofthe artifact.
if there are other processes that have dependencieson the identified process and these processes also produceinconsistent artifacts or generate inconsistent runtime values r eptrace continues to trace back from these processes.
this tracing process stops if there are no more dependencies andthen reports the last found processes as the root causes of theunreproducible build.
however in order to effectively identify root causes causality analysis over system call traces needs to address two majortechnical challenges massive noisy dependencies .
the raw data of system calls are noisy and of a huge volume .
even onlyconsidering the read write dependencies the number ofsystem call traces per package could be up to tens ofthousands in our work.
however most of the system calltraces are irrelevant to the root causes for unreproduciblebuilds.
for example on average only .
of the write system calls generate different data between different rounds of build.
uncertain parent child dependencies .
when a command spawns a new process as commonly seen inthe build process the dependencies may or may notbe carried over to the child process.
simply discarding all parent child dependencies might fail to capture thepropagation trajectories toward the inconsistent artifacts.
in contrast establishing dependencies for all parent childprocesses can produce many false warnings.
to tackle these two technical challenges r eptrace includes two novel techniques to capture the essential dependencies relevant to unreproducible builds.
to address the first challenge r eptrace narrows down the search scope by applying differential analysis over system call traces of multiple builds.more specifically r eptrace identifies the write system calls that output different data between different builds and traceshow these differences propagate to the inconsistent artifacts.
to address the second challenge r eptrace computes the similarity of the runtime values extracted from the system call arguments see section ii passed between parent andchild processes to determine whether a dependency should beestablished.
to assess the effectiveness of r eptrace we conduct an evaluation over real world packages from the debian repository.
for the task of build command localization r eptrace accomplishes accuracy rate of .
for the topmostranked build command.
if we further consider the top ranked build commands the accuracy rate reaches .
.furthermore r eptrace is effective in locating the files to patch for unreproducible builds compared with a relatedstate of the art approach r eptrace achieves .
percentage improvement considering the accuracy rate for the topmost retrieved results.
this paper makes the following main contributions the r eptrace framework being the first to conduct system call tracing and causality analysis on the collected authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
traces for locating root causes of unreproducible builds.
the definition of two types of dependencies read write dependencies among processes and parent child processdependencies for causality analysis.
two novel techniques differential analysis on multiplebuilds and similarity computation of runtime values to address massive noisy dependencies and uncertainparent child dependencies.
comprehensive evaluation on real world packagesto demonstrate high effectiveness of r eptrace and its superiority over a related state of the art approach .
ii.
b ackground and motiv a ting example in this section we first describe the background of system call tracing and our representation of the captured system calls.
then we provide a motivating example to illustrate the causality analysis based on system call tracing.
the exampleuses a real world package i.e.
airstrike .
.0pre6a a game packaged by the debian repository.
a. background and definitions to identify the root cause of unreproducibility we first apply system call tracing on both rounds of reproducibility validationand collect the traces.
a typical system call trace snippet ofthe first round of build is presented in fig.
.
from each lineof system call snippet we can obtain the process identifier pid the parent process identifier ppid the system call name and the arguments.
we can also obtain each system call s start and end time which is not illustrated in the figure.in this work we are interested in the file manipulation suchasread write and rename and the process control related system calls such as execve .
with these system calls we could gain more insights into the build process.
for instance table ii shows the processes that have the last access time tothe inconsistent artifacts as well as typical build commands.also with the pid and ppid information we are able to restore the process tree structure of the build.
to model the reproducibility validation two rounds of build are introduced as b 1andb2 respectively.
each round of build comprises a sequence of processes e.g.
p p2 p3 ... .
specifically a process is represented as a tuple angbracketleftpid ppid slist angbracketright where the first two fields are selfexplanatory and the slist field indicates a list of system call traces.
each system call s slist is represented by a tuple angbracketlefttype start time end time source target data angbracketright.
for the type field we are interested in a subset of system calls related to file manipulation and process control including read write rename execve open and fcntl .
the start time and the endtime fields represent the starting and end time of the system call.
the remaining fields are system call specific read represents the read system call and its variants such asreadv and preadv .
the source field specifies the file to read and the data indicates the bytes read from source .
write represents the write system call and its variants such as writev and pwritev .
the target field specifies the14213 execve usr bin ld o airstrike ... execve usr bin cc cc o airstrike g o2 ... execve usr bin make make c src ... write .log cc o airstrike .
players.o .
airstrike.o ... execve bin sh bin sh c cc o airstrike ... read pipe .
players.c n. airstrike.c n ... write pipe .
players.c n. airstrike.c n ... fig.
.
system call trace snippet for airstrike file to write and the data indicates the bytes written to target .
rename represents the system calls of rename renameat renameat2 and linkat .
the source and target fields are used to specify the file names for renaming changing from source totarget .
execve represents the family exec system calls i.e.
execve and execveat .
the data field represents the build command invoked including both the executable and thearguments.
open represents the system calls of open openat and creat .
the source and data fields indicate the file and the corresponding flags assigned to the file.
fcntl manipulates a file descriptor.
the source and the data fields indicate the file and the corresponding flags assigned to the file.
note that we use an underscore to denote that a specific field of a system call is ignored.
for example for the rename system call only the source and target fields are used and the data field is ignored.
definition runtime value given a process p its runtime value is defined as a set v s.data s p.slist s.type read write orexecve .
the underlying motivation of runtime value is that the data of the read write and execve system calls play an important role during the propagation of the inconsistencies.
definition read write dependency given two processes angbracketleftpid ppid slist angbracketright angbracketleftpid ppid slist angbracketrightof the same build a read write dependency pid 1f pid is established if angbracketleftread st1 et1 f data angbracketright slist angbracketleftwrite st2 et2 f data angbracketright slist such that et1 et2 o ri f angbracketleftread st1 et1 f1 data angbracketright slist angbracketleftwrite st2 et2 f data angbracketright slist and another system call angbracketleftrename st3 et3 f f1 angbracketrightfrom any process of the same build such that et1 e t e t .
definition parent child process dependency given two processes p1andp2with pid sp1andp2 respectively of the same round of build if p1.ppid p2.pid there exists a parent child process dependency between the two processes denoted as p p2.
b. motivating example based on these notations and definitions we next present a running example to motivate r eptrace .
with the captured 5in this definition only single rename is considered in this type of dependency.
it is straightforward to extend to the case of multiple renames.in this work no significant difference is observed between the two variants.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
dependency graph for airstrike table ii inconsistent artifacts and typical build commands for the dependency graph of airstrike pid artifact .
usr games airstrike pid build command objcopy debian airstrike usr games airstrike strip debian airstrike usr games airstrike cp reflink auto a debian tmp usr games debian airstrike usr install airstrike usr games airstrike ld o airstrike .
players.o .
airstrike.o as i o players.o tmp cc3wlobl.s as i o airstrike.o tmp cclbhlnx.s collect2 o airstrike .
players.o .
airstrike.o sh c cc o airstrike .
players.o .
airstrike.o make c src airstrike find .
name .c system call traces we are able to capture the dependencies between the processes within the same build.
the depen dency graph for airstrike contains in total nodes.
each of node represents a process.
starting from the process in which the inconsistent artifact .
usr games airstrike is last accessed process with pid we are interested in how the inconsistency is introduced by the root cause and how itis propagated.
fig.
shows part of the dependencies between the processes for airstrike .
in the figure the solid arrows and the dashed arrows indicate the read write dependencies and the parent child process dependencies respectively.
by traversingthe dependency graph we can locate the root cause for the unreproducibility.
however there may exist many irrelevantdependencies in the graph.
the reason is that the criterionfor establishing dependencies between process is loose anddoes not take the read written data into consideration.
we should note that not all these processes in the graph introduce inconsistencies between the two builds.
for example considerthe build command ldin the process with pid which is the gnu linker to create an executable from object files.with the dependency rule described in definition w eh a v et o further investigate all the processes that write to the associated object files.
there are object files during the link stage leading to edges in the dependency graph.
however inthis case all the object files are actually consistent betweendifferent builds implying that the corresponding edges allrepresent irrelevant dependencies.
in fact the inconsistency for airstrike results from the order of the linker arguments the order is propagated fromits parent process with pid .
the corresponding build command is collect2 a gcc utility to arrange to call various initialization functions and invoke the linker.
by carefullyinspecting the traces we find that the dependency between thispair of processes could be revealed from the text similarity between their build command arguments .
following this clue we could traverse to the process with pid cc .
at this point the hint for further traversal comes from the data field of the write system call for the make command see table ii .
finally we can discover a dependency toward a find command f where f pipe indicating that the make command reads the output of find through a pipeline.
to this end we could gain better understanding for the root cause ofthe inconsistent artifact i.e.
the file traversal order of find is not guaranteed to be deterministic.
consequently because the link order relies on the output of find the build artifact turns out to be unreproducible.
based on these observations r eptrace filters out the build commands that write identical data between the two builds of the validation this filtering can effectively simplify the dependency graph.
second to identify the parent child processdependencies we calculate the similarity of the runtime valuesof the parent process and the child process and establishdependencies only for those parent child processes that share similar runtime values.
in this way we could identify the relevant dependencies without introducing too many irrelevantdependencies.
iii.
o urreptrace framework in this section we describe the design and implementation of the proposed r eptrace framework.
as illustrated in fig.
given the source package we first adopt the toolchain of reproducibility validation to build the source codeunder the build environments with variations.
during thebuild process we collect the system call traces of the twobuilds using strace a popular diagnosis utility.
then we construct the dependency graph based on the sliced abstractedsystem call traces which are produced by applying differentialanalysis over the two sets of system call traces.
after that we intend to augment the dependency graph by detecting the parent child process dependencies with runtime values.by improving the dependency graph with the runtime value induced dependencies the root causes could be better locatedwith the traversal over the improved dependency graph.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fig.
.
the r eptrace framework a. dependency graph generation and augmentation as mentioned in section i a major challenge of analyzing system call traces lies in the massive volume of the gathereddata.
to extract the useful information meanwhile reducingthe noises our key idea is to perform differential analysis ofthe system call traces.
in this work because we are interestedin how the inconsistencies are generated between multiplebuilds and how these inconsistencies are propagated to thebuild artifacts we construct the dependency graph basedon the differences extracted from the system call traces.
in particular in the dependency graph produced by r eptrace the read write dependencies are replaced with the difference induced dependencies as defined below definition difference induced dependency for the two builds b 1andb2of the reproducibility validation write diff is denoted as a set uniontext p b1 uniontext s p.slist s.type writemd5 s.data uniontext p b2 uniontext s p.slist s.type writemd5 s.data .
given two processes angbracketleftpid ppid slist angbracketright b1 angbracketleftpid ppid slist angbracketright b1 a difference induced dependency did denoted as pid 1f arrowhookleft pid is established if pid 1f pid and angbracketleft write st et f data angbracketright slist such that md5 data write diff .
algo.
shows the pseudo code of the dependency graph construction based on difference induced dependencies.
the proposed algorithm comprises two phases.
first the set writediff is calculated based on the data field of each write system call.
the unique feature of our graph construction is that toreduce the noises within the system calls the dependencypropagation focuses on the inconsistencies generated by thewrite system calls between builds.
then each pair of write and read system calls are examined whether a difference induced dependency should be established between the correspondingprocesses.
in particular for each write system call s 1with respect to write diff line we examine whether there exists aread system call reading from s1.dest after time s1.et.
if so a dependency is established lines .
similarly if the files .dest is renamed by a rename system call s3tos3.dest and later read by a read system call a dependency should also be established lines .algorithm difference based dependency graph generation input system call traces for read write and rename 1begin g emptygraph write hash uniontext p b1 uniontext s p.slist s.type writemd5 s.data write hash uniontext p b2 uniontext s p.slist s.type writemd5 s.data write diff write hash write hash for write system call s1where md5 s1.data write diff do pid write pid of s1 for read system call s2do ifs2.src s1.dest ands2.et s .et then pid read pid of s2 add edge g pid read pid write end for rename system call s3do ifs3.src s1.dest ands3.dest s2.src and s2.et s .et s .etthen pid read pid of s2 add edge g pid read pid write end end end end return g 22end furthermore to tackle the challenge of the uncertain parent child process dependency r eptrace utilizes the text similarity of the runtime values.
as discussed in section ii the runtime values passed between the processes can be usedto reveal the dependencies.
in particular for script based buildsystems the runtime values are mostly in the format of plaintext.
consequently we could leverage text similarity to make decisions on whether dependencies should be established.
specifically the relevance value is calculated as follows.
definition relevance value given two processes with pid sp 1andp2 each with a sequence of runtime values v1 v11 v12 ...v 1m andv2 v21 v22 ...v 2n the relevance between the two processes is calculated as relevance p1 p2 max v1 v1 v2 v2 max cossim v1 v2 lcssim v1 v2 wherecossim andlcssim represent the cosine based and the longest common substring based similarity re spectively.
note that for lcssim we consider the longest common substring percentage with the value ranging within .
the motivation behind the similarity measurement is that the length of the runtime values might be of arbitrary length.
hence using only one type of similarity might notbe effective for various cases.
specially we skip the pairs ofruntime values when the runtime values contain binary data byassigning to the similarity value.
with the relevance value the runtime value induced dependency is defined as follows.
definition runtime value induced dependency g i v e n two processes with pid sp 1andp2of the same round of build there exists a runtime value induced dependency rid denoted as p1i p2 i fp1 p2 and the relevance value between the processes is larger than the pre defined threshold.
based on definition the dependency graph constructed with algo.
can be further improved based on algo.
.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm dependency graph augmentation input dependency graph g relevance threshold threshold 1begin g prime g for node g primedo pid pid of node parent pid parent of node calculate relevance with eq.
.
ifrelevance threshold then add edge g prime pid parent pid end end return g prime 12end each node that represents a process we calculate its relevance value with its parent process.
if the relevance value is greaterthan the given threshold a runtime value induced dependencyshould be established.
running example using the package airstrike we explain how the two mechanisms work.
first when evaluating theprocess with pid the ldcommand for those input files of the ldcommand that are consistent between builds it is obvious that their corresponding write system calls are associated with the same hash values.
hence these processes could be neglected.
second similarly to demonstrate that theparent child process dependency works consider the child pro cess with pid and the parent process with pid .
the relevance value calculated by eq.
is .
whichprovides strong evidence that there should be a dependency between the two processes.
b. graph traversal based causality analysis after constructing and augmenting the dependency graph r eptrace traverses the graph searching for the root causes for the unreproducible builds.
as shown in algo.
r eptrace starts the traversal from the nodes that represent the processes directly accessing the inconsistent artifacts.
from these nodes r eptrace performs a breadth first search and obtains a set of nodes without outgoing edges to other un visited nodes in the graph line .
since the edges in thedependency graph indicate the trajectories of the inconsis tency propagation these nodes indicate that the inconsistencypropagation stops at these nodes i.e.
no more inconsistenciespropagated to other processes.
with these nodes obtained r eptrace then ranks them based on their relevance values among other nodes in the dependency graph lines .
the higher the accumulated relevance value is the higherprobability the corresponding nodes would be the root causes.
finally to realize the file level localization we start from the ranked list of build commands retrieved by algo.
insearch of the most relevant files.
more specifically based on the preliminary investigation two different paradigms of patches are identified.
case for those packages in which scripts are responsible for the unreproducibility such as the wildcardfunction of makefiles and the hash table traversal of perlscripts the scripts are to be patched being opened in the same process as the one where the root causes are identified.algorithm graph traversal based root cause localization input improved dependency graph g 1begin node set breadth first search g for node m node set do pid m pid of m node weight for node n gdo pid n pid of n node weight node weight relevance pid m pid n end end ranked list sort node set node weight return ranked list 13end algorithm file level localization input node set node set weights for the nodes node weights file set file set 1begin for filef file set do file weight for node m node set do pid m pid of m switch typeof m do case search in the current process do for filefopened with cloexec flags do file weight file weight node weight end end case search in the parent process do ppid m parent of m t1 get execve text m for filefopened with cloexec in process ppid mdo t2 get text f sim max cossim t1 t2 lcssim t1 t2 file weight file weight node weight sim end end end end ranked file list sort file set file weight return ranked file list 24end case for the build commands that may introduce inconsistencies such as the gzip and the date commands.
in this case the scripts to be patched are typically opened inthe parent process of the identified process.
for example in the motivating example airstrike the inconsistency is introduced by the find command.
however the file to be patched is the makefile in which find is invoked see fig.
.
to distinguish the two cases we adopt a heuristic rule based on the flags associated to each opened file.
in particular the scripts are typically opened with the cloexec flags fd cloexec or o cloexec indicating that the files are to be closed automatically after successful execve system calls.
during our preliminary experimentation we observethat the cloexec flags are generally effective in classifyingthe scripts and the other files with two exceptions i.e.
theprocesses invoking python scripts or the tar compressing utility which are processed in a specialized way.
with the heuristic classifying rule the process of localization for the file to patch is described in algo.
.
running example for the package airstrike after obtaining the dependency graph the root cause for the unreproduciblebuild can be found by traversing the graph.
as shown in fig.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a src makefile b src makefile cflags shell sdl config cflags isprite i. isupport dinline inline cflags dpkg buildflags get cflags cfiles shell find .
name .c cfiles sort shell find .
name .c objects cfiles .c .o fig.
.
patch snippet for airstrike we can observe that the node with zero outgoing unvisited edge process with pid the find command is the root cause.
furthermore since no file is opened with the cloexec flags in the process with pid r eptrace checks its parent process and locates the file to be patched src makefile which is shown in fig.
.
iv .
e v alua tion in this section we apply r eptrace on real world software packages and evaluate the effectiveness of r eptrace .w e seek to investigate the following research questions rqs rq1 i sr eptrace effective in locating the root causes for unreproducible builds?
rq2 how effectively can the did and rid mechanisms improve the construction of dependency graphs?
rq3 i sr eptrace sensitive to the parameter in the runtime value induced dependency?
rq4 i sr eptrace helpful in locating the problematic files to patch?
among these rqs rq1 evaluates the ability to accurately identify the root causes for unreproducible builds becausethe command level localization is the unique feature of r eptrace .
in particular by comparing various variants of r eptrace we intend to examine how each component contributes to r eptrace .
rq2 evaluates the impact of the two mechanisms on the search space.
by comparing the statisticsof the dependency graphs induced by the different variants of r eptrace we could gain more insights into both the did and rid mechanisms.
rq3 evaluates the sensitivity of the parameter on r eptrace .
finally rq4 evaluates the ability of file level localization of r eptrace by comparing with the best known results.
a. evaluation setup reptrace is implemented in java .
and the evaluation is conducted on an intel xeon .
ghz server with gbmemory running debian .
.
metrics .
to evaluate the effectiveness of r eptrace we measure the accuracy rate precision recall f score and meanreciprocal rank mrr in identifying root causes for unre producible builds.
the metrics are computed by examining theranked build commands rq1 and files rq4 returned by r eptrace .
the top nbuild commands files in the ranked list are called the retrieved list and are compared with the relevance list to compute the precision recall and f score represented using p n r n and f n respectively .
in particular top naccuracy rate e.g.
a n is used to measure the percentage of packages for which the top nlist provides a box plot statistics b comparison of build time fig.
.
comparison of build time statistics at least one problematic command file .
besides mrr is an aggregate metric to evaluate the quality of the retrievedresults.
tools under comparison .
in our evaluation we compare r eptrace with a set of variants.
first a set of three variants of r eptrace are chosen each considering part of the mechanisms of r eptrace .
for example we denote reptrace did as the variant of r eptrace in which the difference induced dependency is not employed.
there are also two other variants denoted as r eptrace rid and r eptrace did rid in which parent child dependencies are not considered.
with these variants we investigate how theproposed mechanisms collaborate as an integrated framework.second we compare r eptrace with r eploc the state ofthe art tool for file level localization .
dataset .
we use a set of packages from the debian repository following previous work as our evaluation dataset.the reasons that the scale of the dataset is relatively small areas follows.
first due to the evolution of the debian repository especially the build tool chain and the build dependencies some old packages used in the previous work could not be builtfrom source.
second due to the necessity of manual annotationfor the root causes to evaluate the ability of causality analysis we do not consider all the packages as in the previous work.besides since we focus on the identification of the root causes which are represented as build commands we do not considerthe packages for which the patches are within source code.
in the dataset the root causes cover the following categories timestamp such as gzip date and tarthat capture the current date and or time randomness such as dict hash table traversal of python and perl scripts file ordering such as find infindutils and the wildcard issue of make locale such as sort and lynx without setting the locale environment variable uname and hostname uname and hostname that capture the system information .
to construct the ground truth for evaluating causality analysis we check the execve system call traces that match the patches obtained from the bug tracking system of debian.for each package we check not only according to the build command line text but also the context indicated by the path from the root of the process tree to the problematic build authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table iii results of reptrace and other approaches for the command level localiza tion task approach a a a p p p r r r f f f mrr reptrace did rid .
.
.
.
.
.
.
.
.
.
.
.
.
reptrace did .
.
.
.
.
.
.
.
.
.
.
.
.
reptrace rid .
.
.
.
.
.
.
.
.
.
.
.
.
reptrace .
.
.
.
.
.
.
.
.
.
.
.
.
table iv results of wilcoxon signed rank test for the command level localiza tion task metrics r eptrace vs. p value effect size p 1reptrace did rid .
.
reptrace did .
.
reptrace rid .
.
r 1reptrace did rid .
.
reptrace did .
.
reptrace rid .
.
command.
meanwhile for the file level localization we adopt an approach in the literature i.e.
we extract the file namesfrom the patches as the ground truth.
overhead of system call tracing .a sr eptrace is built upon system call tracing we measure to what extent systemcall tracing slows down the build process.
we compare thestatistics of the build time under two circumstances i.e.
withor without system call tracing.
in fig.
the box plots andthe scatter plot represent the distribution of build time overall the packages.
from the figure we observe that whenusing system call tracing build time increases accordingly.for the two cases the median build time is .77s and .84s respectively.
meanwhile the maximum build time for the twocircumstances is of the same order of magnitude.
such resultsindicate that the overhead of system call tracing is acceptablefor industrial level builds.
b. rq1 command level localization as discussed in section iii a unique feature of r eptrace lies in its ability to locate the root causes for unreproducible builds.
prior to this work the localization task realized by reploc is mainly at the file level.
hence the guidance toward the patch of the unreproducible builds tend to be limited.
in contrast with the system call tracing especially thedata provided by the execve system call r eptrace is able to identify the potential build commands that are responsiblefor the unreproducible issues.
in this rq we compare the results of causality analysis in table iii.
the table is organized as follows.
the first column represents the names of the approaches in comparison including r eptrace and its three variants.
then columns indicate the measurements employed to evaluate eachapproach i.e.
the accuracy rate precision recall f score and mrr.
from the table we could observe that r eptrace is able to effectively locate the root causes responsible for the unrepro ducibility.
especially when considering the topmost retrievedbuild command r eptrace is able to achieve an accuracy rate of .
.
the accuracy rate increases to .
if we consider the top results implying that for .
of thepackages we can obtain at least one build command that isamong the root causes by traversing the top results.
in contrast the results for the variants of r eptrace are not so promising.
we should note that from the table we observethat the precision and f score values are not very high.the reason for the low values of precision and f scoremight be that for the unreproducible packages the numberof processes that construct the root causes is relatively small.
within the dataset there are packages for which there is single build command that causes unreproducibility andthe average number of root causes is .
.
consequently theprecision value for the top results tends to be low alsoinfluencing the f score.
under such circumstance the mrr metric reflects the ability to rank root causes to the top of results.
from the table we observe that r eptrace is able to achieve the best mrr.
to gain higher confident on drawing conclusion from the comparison results we employ the nonparametric wilcoxon signed rank test.
for the null hypothesis we assume that there exists no significant difference with respect to the resultsobtained by the approaches under comparison.
table iv showsthe comparison results organized as follows.
the first columnindicates the metrics over which the comparison is conducted.the second column specifies the approaches against which r eptrace is compared.
the third and fourth columns present the p value and effect size also known as the rank biserial correlation respectively.
from the comparison results we observe that under each comparison scenario except whencomparing r eptrace with r eptrace rid over the p metric the null hypothesis is rejected with p value .
.
this observation confirms that the did mechanism contributesmore to the performance.
fig.
shows the results obtained by r eptrace and its variants against the length of the retrieved list.
we con sider the precision and recall as the measurements.
whenwe compare the behavior of the variants we could measurethe improvement brought by each mechanism.
for example when we compare r eptrace did rid with r eptrace rid we could see that for both the measurements the curves for r eptrace did rid are always below those of r eptrace rid .
this observation confirms the contribution of the did mechanism which not only providesa smaller dependency graph see rq2 for more discussion but also helps locate the root cause more accurately.
a similar observation could be made when we compare r eptrace did and r eptrace .
furthermore to understand whether the rid mechanism works we compare r eptrace with r eptrace rid .
from fig.
we could see that reptrace outperforms r eptrace rid .
answer to rq1 reptrace is able to effectively identify authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a trend for precision b trend for recall fig.
.
comparison of r eptrace and its variants the root causes that are responsible for unreproducible builds and these root causes are helpful in understanding why reproducibility validation fails.
c. rq2 impacts on dependency graph construction in r eptrace there are two main mechanisms i.e.
the reduction based on differential analysis which intends toshrink the scale of search space and the runtime value baseddependency identification which may enlarge the dependencygraph.
hence in this rq we analyze the statistics of thedependency graphs constructed by r eptrace and its variants to explore whether the did mechanism is able to achieve thereduction of search space and yet preserve the precision incausality analysis.
to gain an intuitive understanding of the influence of the two proposed mechanisms in fig.
we present thecomparison of the graph statistics of the dependency graphgenerated by the variants of r eptrace respectively.
for each variant we report the statistics of the dependency graph for allthe packages to reflect the influence of each mechanism.
foreach sub figure we plot the distribution of typical properties inlog scale including the number of nodes num nodes number of edges num edges average node degree avg degree and maximum node degree max degree .
all the statistics are illustrated as box plot.
from the figure we could observe the following two interesting phenomena.
on one hand when comparing fig.
a and fig.
b we could see the reduction effect of the did mechanism.
without the did based reduction mechanism there are on average .
nodes in the dependency graph.meanwhile with the reduction there are on average .64nodes in the dependency graph being of a much smaller scale.also for other graph attributes similar phenomena could beobserved.
for instance the maximum node degree of the graphfor r eptrace did rid is larger than that for r eptrace rid implying that without the did mechanism there may exist nodes with more dependencies.
consequently the possibility of incorporating irrelevant dependencies mayalso increase.
this observation to some extent explains whythe results of the variants without did are not satisfying inrq1.
on the other hand when comparing fig.
b and fig.
d we could observe that if the rid mechanism is consideredover the did reduced dependency graph there are not manynodes and edges introduced by the runtime value induceddependency mechanism.
hence the overhead caused by the runtime value induced dependencies is in general acceptable.
in contrast when comparing fig.
a and fig.
c weobserve a drastic increase in attribute values of dependencygraph implying that if the rid mechanism is considered overthe dependency graph without reduction the correspondinggraph would be much more complex.
this observation to someextent explains why r eptrace did performs the worst among the variants.
furthermore fig.
shows the distribution of the execution time in log scale for r eptrace and its variants.
from the figure we could observe that r eptrace rid is the fastest variant with median execution time of .88s.
the reason is that the scale of the dependency graphs for this variant issmaller than other variants.
r eptrace is slower with median execution time of .51s but is within the same order ofmagnitude.
in contrast the two variants without did are muchslower.
in particular r eptrace did is the least efficient variant in comparison due to the lack of reduction realized bythe did mechanism and the extra dependencies introducedby the rid mechanism.
this observation also conforms withfig.
c which presents the statistics of the most complex dependency graph.
answer to rq2 in this rq we confirm that the did mechanism is able to effectively reduce the search scope ofthe localization task.
also the extra edges introduced by the rid mechanism is acceptable when the did mechanism is applied.
with the dependencies induced by the differences ofthe write system call and the runtime values r eptrace is able to achieve median execution time of .51s.
d. rq3 parameter sensitivity analysis as mentioned in section iii a we introduce a threshold in the rid mechanism to detect the potential dependenciesbetween parent processes and child processes.
hence we shallevaluate r eptrace s sensitivity to the threshold.
fig.
shows the results of the sensitivity analysis over a subset of the40 randomly selected packages.
the figure is organized asfollows.
the x axis represents the value of the parameter which ranges from to with the step of .
.
the y axis indicates the quality measurement i.e.
the precision and recallconsidering the top result.
from the figure we could observe that r eptrace is not very sensitive to the threshold in terms of both measurements.for example for all the parameter values the precision value authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a r eptrace did rid b r eptrace rid c r eptrace did d r eptrace fig.
.
dependency graph statistics for variants of r eptrace fig.
.
comparison of execution time for variants of r eptrace is always above .
.
also both the recall and accuracy rate reach the best results around .
answer to rq3 reptrace is not very sensitive to the parameter and generalizes well over different packages.
hence for the other parts of the evaluation the parameter value isassigned with .
.
e. rq4 file level localization in this rq we evaluate whether r eptrace is effective in locating the problematic file in which the unreproducibleissues should be patched.
specifically we report the resultsobtained by r eptrace and other approaches under comparison in table v. the table is organized similarly as table iii except that r eplocis also considered.
from the table we can observe that r eptrace is able to rank the relevant files at the top of the retrieved list.compared with r eploc the top accuracy rate is .
which is much higher than the results achieved by r eploc.
the underlying reason might be that with the system call based dependency graph r eptrace is able to accurately locate the build commands for which there exists at leastone path in the dependency graph leading to the inconsistentartifacts.
consequently the file ranking based on these buildcommands could provide valuable hints toward the problematic files to be patched.
in contrast r eploc relies on the fig.
.
results of parameter sensitivity build log based query augmentation which is based on the text similarity between the inconsistent artifact names and thebuild commands and using this text similarity tends to be lessaccurate.
in addiction an interesting observation is over the variants without the did mechanism.
for example despite not per forming well in rq1 r eptrace did achieves an r of .
in this rq.
a similar phenomenon could be foundfor r eptrace did rid as well.
the reason might be that the retrieved build commands by these two variants maystill be relevant to the inconsistent artifacts even when they arenot the root causes for unreproducibility.
hence these buildcommands may be helpful in file level localization.
similar to rq1 we present the results of hypothesis testing in table vi.
the table is organized the same way as rq1.
fromthe table similar phenomena could be observed.
moreover when comparing the topmost retrieved files by r eptrace with r eploc we find that r eptrace outperforms r eploc except that the p value is slightly larger than .
when the recall metric is considered.
answer to rq4 reptrace is able to accurately locate the problematic files that are responsible for the unreproduciblebuilds.
from the comparisons with both the state of the art approach and the variants of r eptrace r eptrace demonstrates the superiority over these approaches.
v. t hrea ts to validity in our evaluation there are two major threats to validity.
first an important threat to validity is that we assume the completeness of the necessary system call traces whichmay introduce inconsistencies during the build process.
forexample in our evaluation all the builds are conducted underan isolated environment and do not need to communicatewith external systems once the build dependencies are met.
hence we do not capture the network related system calls.
in real world environments inconsistencies could originatefrom various sources.
hence the linkage from the inconsistentartifacts toward the root cause may be broken.
during theconstruction of the dataset we have mitigated this issue bymanually inspecting the patches and the build scripts to ensurethat the unreproducible issues are caused within the package.
second in our evaluation we adopt the off the shelf diagnosis tool strace to capture the system call traces.
strace is based on ptrace and is available under gnu linux.
to generalize r eptrace to other platforms adaptations have to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table v results of reptrace and other approaches for the file level localiza tion task approach a a a p p p r r r f f f mrr reptrace did rid .
.
.
.
.
.
.
.
.
.
.
.
.
reptrace did .
.
.
.
.
.
.
.
.
.
.
.
.
reptrace rid .
.
.
.
.
.
.
.
.
.
.
.
.
reploc .
.
.
.
.
.
.
.
.
.
.
.
.
reptrace .
.
.
.
.
.
.
.
.
.
.
.
.
table vi results of wilcoxon signed rank test for the file level localiza tion task metrics r eptrace vs. p value effect size p 1reptrace did rid .
.
reptrace did .
.
reptrace rid .
.
reploc .
.
r 1reptrace did rid .
.
reptrace did .
.
reptrace rid .
.
reploc .
.
be made.
to mitigate this issue we model the system calls in a uniform way see section ii b so that porting to other platforms would be straightforward.
the adaptation could be realized by replacing strace with a platform specific tracing system e.g.
dtrace for bsd like os and etw for windows.
vi.
r ela ted work a. system calls recent years have witnessed the growing research interests of leveraging system call traces as a high quality source ofsystem wide information to help boost the performance ofvarious tasks.
for instance gao et al.
propose to usesystem calls to capture the trajectories of malware behav iors which could be further used to detect intrusion or conduct forensic analysis.
licker and rice address the challenge of discovering the hidden dependency in the buildscripts and detect bugs in the build process.
neves et al.
develop a system call tracing based diagnosis framework fal con to achieve trouble shooting functionality under distributed environments.
pasquier et al.
propose a whole system provenance system that leverage system call to capture mean ingful provenance without modifying existing applications.v an der burg et al.
address the license compatibilityproblem and devise a system call based approach to detectpotential license conflict.
liu et al.
systematically review the studies focusing on host based intrusion detection with system calls.
unlike the existing system call based research in this work we focus on a novel problem domain i.e.
the localization taskof the root causes for unreproducible builds.
b. reproducibility as a new research problem there are relatively few approaches focusing on the localization task for unreproducible builds.
the most relevant work is the work by ren et al.
inwhich the localization task is modeled as a task of informationretrieval aiming to search for the problematic files that areresponsible for the unreproducibility.
also in their work thelocalization is realized at the file level unlike the level of build command achieved in this work.
besides the localization task for unreproducible builds there exist a series of closely related research directions.
amongthese directions a typical example is reproducible research.for example guo proposes a system call based framework cde which realizes the functionality of packagingthe program execution environment.
following the idea there exist several related approaches such as reprozip andprovtoolbox .
ivie and thain make a systematicsurvey for the research topic.
compared with these previousapproaches which emphasize the success of re executing the programs in diverse environments in this work we are more interested in tracing back along the system calls to locate theroot cause for inconsistencies.
vii.
c onclusion in this paper we have presented the r eptrace framework to identify the root causes for unreproducible builds.
theframework leverages system call tracing s uniform interfacesfor monitoring executed build commands in diverse build environments.
to tackle the challenges of leveraging system call tracing based information r eptrace filters irrelevant dependencies among processes by using the differences of thewrite data and the runtime values.
our extensive evaluationover real world packages demonstrates that r eptrace is able to achieve promising solutions for unreproducible builds.
in future work as r eptrace relies on the heuristic detection of the dependencies between parent processes and childprocesses we plan to explore more accurate techniques fordependency identification.
also it would be interesting to explore the possibility of automatically patching unreproducible builds.
a cknowledgments tao xie is also affiliated with the key laboratory of high confidence software technologies peking university ministry of education.
this work is supported in part bythe national key research and development program of china under grant no.
2018yf b1003900 the national natural science foundation of china under grant no.
and nsf under grant no.
cns ccf cns .
r eferences reproducible builds team definition of reproducible builds https reproducible builds.org docs definition accessed .
m. perry deterministic builds part one cyberwar and global compromise accessed .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
b. bzeznik o. henriot v .
reis o. richard and l. tavard nix as hpc package management system in proceedings of the f ourth international workshop on hpc user support tools .
acm pp.
.
debian accessed .
guix accessed .
f droid z. ren h. jiang j. xuan and z. yang automated localization for unreproducible builds in proceedings of the 40th international conference on software engineering .
acm pp.
.
s. mcintosh m. nagappan b. adams a. mockus and a. e. hassan a large scale empirical study of the relationship between build technologyand build maintenance empirical software engineering vol.
no.
pp.
.
y .
r egis gianas n. jeannerod and r. treinen morbig a static parser for posix shell in proceedings of the 11th acm sigplan international conference on software language engineering .
acm pp.
.
y .
tang d. li z. li m. zhang k. jee x. xiao z. wu j. rhee f. xu and q. li nodemerge template based efficient data reduction forbig data causality analysis in proceedings of the acm sigsac conference on computer and communications security .
acm pp.
.
f. chirigati d. shasha and j. freire reprozip using provenance to support computational reproducibility in proceedings of the 5th usenix workshop on the theory and practice of provenance .
c. curtsinger and e. d. berger coz finding code that counts with causal profiling in proceedings of the 25th acm symposium on operating systems principles .
acm pp.
.
b. zong x. xiao z. li z. wu z. qian x. yan a. k. singh and g. jiang behavior query discovery in system generated temporalgraphs proceedings of the vldb endowment vol.
no.
pp.
dec. .
strace accessed .
cosine similarity apidocs org apache commons text similarity cosinesimilarity.html ac cessed .
longest common substring percentage webfolder technetwork data quality edqhelp content processor library matching comparisons longest common substring percentage.htm accessed .
x. ye r. bunescu and c. liu learning to rank relevant files for bug reports using domain knowledge in proceedings of the 22nd acm sigsoft international symposium on f oundations of softwareengineering .
acm pp.
.
d. s. kerby the simple difference formula an approach to teaching nonparametric correlation comprehensive psychology vol.
p. .it.
.
.
dtrace accessed .
m. jacobs and m. satran about event tracing com en us windows desktop etw about event tracing accessed .
p .
gao x. xiao z. li f. xu s. r. kulkarni and p .
mittal aiql enabling efficient attack investigation from system monitoring data inproceedings of usenix annual technical conference .
usenix association pp.
.
p .
gao x. xiao d. li z. li k. jee z. wu c. h. kim s. r. kulkarni and p .
mittal saql a stream based query system for realtime abnormal system behavior detection in proceedings of the 27th usenix conference on security symposium .
usenix association pp.
.
n. licker and a. rice detecting incorrect build rules in 41st acm ieee international conference on software engineering .
acm ieee pp.
.
f. neves n. machado and j. pereira falcon a practical log based analysis tool for distributed systems in proceedings of the 48th annual ieee ifip international conference on dependable systems andnetworks .
ieee ifip pp.
.
t. pasquier x. han m. goldstein t. moyer d. eyers m. seltzer and j. bacon practical whole system provenance capture in proceedings of the symposium on cloud computing .
acm pp.
.
s. v an der burg e. dolstra s. mcintosh j. davies d. m. german and a. hemel tracing software build processes to uncover license compliance inconsistencies in proceedings of the 29th acm ieee international conference on automated software engineering .
acm ieee pp.
.
m. liu z. xue x. xu c. zhong and j. chen host based intrusion detection system with system calls review and future trends acm computing surveys vol.
no.
p. .
p .
j. guo cde run any linux application on demand without installation in proceedings of the 25th usenix international conference on large installation system administration .
usenix association pp.
.
l. moreau b. v .
batlajery t. d. huynh d. michaelides and h. packer a templating system to generate provenance ieee transactions on software engineering vol.
no.
pp.
.
p .
ivie and d. thain reproducibility in scientific computing acm computing surveys vol.
no.
p. .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.