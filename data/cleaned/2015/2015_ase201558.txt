configuration aware change impact analysis florian angerer andreas grimmer herbert pr ahofer paul gr unbacher christian doppler laboratory mevss institute for system software johannes kepler university linz austria florian.angerer andreas.grimmer herbert.praehofer paul.gruenbacher jku.at abstract understanding variability is essential to allow the configuration of software systems to diverse requirements.
v ariability aware program analysis techniques have been pro posed for analyzing the space of program variants.
such tech niques are highly beneficial e.g.
to determine the potentialimpact of changes during maintenance.
this paper presents aninterprocedural and configuration aware change impact analysis cia approach for determining possibly impacted products whenchanging source code of a product family.
the approach furthersupports engineers who are adapting specific product variantsafter an initial pre configuration.
the approach can be adaptedto work with different variability mechanism it provides moreprecise results than existing cia approaches and it can beimplemented using standard control flow and data flow analysis.using an industrial product line we report evaluation results onthe benefit and performance of the approach.
keywords change impact analysis program analysis maintenance configuration.
i. i ntroduction variability plays an essential role in software systems which need to be configured to meet a wide range of customer requirements.
dealing with variability however leadsto many challenges for developing maintaining testing andanalyzing systems.
for instance developers need to ensurethat different software variants behave as expected.
however it has been shown that generating and analyzing all possi ble system variants is computationally infeasible even forsmall systems .
research on variable software systems hasprogressed significantly.
for instance researchers in softwareproduct lines and feature oriented software development havedeveloped family approaches that allow analyzing thewhole space of software variants by exploiting commonalitiesbetween variants.
such approaches have been shown to bevery effective particularly for program analysis .
manyexisting approaches assume that the source code is annotateddirectly with variability information which is the case e.g.
in annotation based product lines that use preprocessors .however other variability mechanisms such as testing con figuration options loaded from a file or provided via programarguments play an equally important role and analysis supportis also needed for such cases.
an important application area for program analysis is change impact analysis cia i.e.
the identification of thepotential consequences of a change or the estimation of whatneeds to be modified to accomplish a change .
our aimis to improve support for cia of variable software systems an area of high practical relevance particularly for clone and own product lines .
in this paper we thus presentan interprocedural and configuration aware cia approach thatuses and propagates variability information.
our approach canhandle load time configuration options representing softwarevariability.
while some program analysis approaches e.g.
can handle such runtime variability by attaching path con ditions to system dependence graphs sdgs to improve theprecision of slices their scalability to large programs is limited as path conditions need to be extracted for nearly everyconditional statement.
our approach thus uses a conditional system dependence graph csdg an extended representationof an sdg we presented in earlier work .
we demonstrate the benefits of our approach using two use cases derived from an analysis of development practicesof our industry partner we illustrate how the ap proach facilitates development and maintenance in domain engineering by supporting software engineers that need to determine the impact of changing a set of source code elementsof a product family.
specifically we demonstrate how ourconfiguration aware cia allows to automatically determinethe set of possibly impacted products.
such analysis hasmajor benefits for software evolution for instance it helpsreducing regression testing to the affected product variants.
itfurther simplifies software deployment as updates only needto be rolled out to customers affected by certain changes.we further show how our approach supports development and maintenance in application engineering by supporting software engineers changing a specific product variant whichneeds to be adapted after deriving it from a product line.
this isa frequent case in clone and own product lines whenengineers customize and extend the software to the specificrequirements of customers.
again manual cia would be error prone and infeasible due to the high configurability of manylarge systems in this case.
the contribution of this paper is an interprocedural cia approach which annotates potentially impacted elements withvariability information to determine the set of affected productsafter a change.
specifically our configuration aware cia pro vides the following benefits compared to existing techniques i the approach can be adapted to work with different variabil ity mechanisms.
our technique does not assume that the source code is directly annotated with variability information i.e.
unlike existing approaches it does not assume an annotation based mechanism that is resolved at compile time.
instead it can handle configuration options that remain constant afterbeing loaded during the startup of an application.
ii the approach provides more precise results than existing cia.specifically it discovers contradicting product configurationsand determines source code that can never be executed.
thisallows reducing the size of the change impact.
iii the approach uses standard control flow and data flow analyses.we avoid the use of new control and data flow analyses toease the implementation of the approach in different contexts.
30th ieee acm international conference on automated software engineering .
ieee our paper is organized as follows section ii illustrates the research problem using a small example.
section iii presents our configuration aware cia approach and its implementation.section iv shows the results of evaluating the approach regard ing its benefit and performance.
section v presents relatedwork.
section vi rounds out the paper with a conclusion andan outlook on future work.
ii.
p roblem illustration change impact analysis allows to automatically determine and systematically review the possibly impacted source codefor changes.
however state of the art cia techniques do not consider load time variability.
for example list ing shows an illustrative program example that can be con figured by enabling or disabling the configuration options c0 andc1.
existing cia techniques do not provide information about the product variants that are affected by a change.even this small configurable program shows that manuallydetermining the set of affected products is difficult due tomany dependencies as can be seen in the simplified sdg forlisting shown in figure .
assume a developer changing thereturn statement in line represented as a node in the lower right corner of the sdg.
existing cia techniques follow theforward edges and mark all visited nodes as possibly impactedby the intended change i.e.
the nodes labeled return d. bar d.bar return d.bar int res obj.foo d and system.out.println res are in the set of impacted statements.
performing configuration aware analysis is much harder as one needs to consider if the statements are executed and thedata flows are valid under certain conditions.
for example thestatements object new b return and object new c depend on the conditions c0and c0 c1.
therefore the bodies of classes bandcalso depend on these conditions.
in class d an additional local condition c1appears.
hence statement return is only executed if the condition c0 c0 c1 c1holds while statement system.out.
println res is executed if c0holds.
however combining and simplifying both conditions results in false i.e.
changing the statement return has no impact on the statement system.out.println res .
researchers have already developed variability aware program analysis techniques considering the variability of aprogram e.g.
when performing data flow analysis .
how ever many current techniques assume source code to beannotated with variability information that is resolved duringcompilation by only considering the syntactic structure of aprogram.
but many product lines and configurable softwaresystems use further mechanisms to deal with variability.
anexample are configuration options which are loaded and thenevaluated in many different locations of a program.
thereare some approaches e.g.
that are able to considerruntime variability but they do not differ between configurationthat remains constant over execution and regular control flowof a program.
in the example in listing the value of aconfiguration option is stored in a local variable line which is used subsequently to decide which other configurationoption to load line .
currently available analysis techniquescannot handle such situations as they assume a strict separationof the variability mechanism from program control flow i.e.
1class main static properties p properties.load conf.prop static boolean c0 on .equals p.getproperty c0 static boolean c1 on .equals p.getproperty c1 public static void main string args a obj new a dd new d if c0 obj new b return else if c1 obj new c int res obj.foo d system.out.println res class a int foo d d return class bextends a int foo d d return d.bar d.bar class cextends a int foo d d return d.bar class d int bar if !c1 return return listing small configurable program.
1class main static properties prop properties.load conf.prop public static void main string args boolean c0 on .equals prop.getproperty f boolean c1 if c0 c1 on .equals prop.getproperty x else c1 on .equals prop.getproperty y a obj if c1 obj new a1 indirectly depends on c0 else obj new a2 indirectly depends on c0 obj.foo listing influence of configuration options on program execution.
they do not consider that the execution of the statements in lines and also depends on the configuration option c0.
in this small example it is obvious that the execution of thestatements in lines and also depends on conditions c0 c1 and c0 c1.
finally the call in line also depends on both configuration options since the reaching objects dependon both configuration options.
386 int res obj.foo d main a obj new a obj new b system.out.println res d d new d if c0 if c1 obj new c b.foo c.foo d.barreturn d.bar d.bar return d.bar if !c1 return return 1return a.foo return2 fig.
sdg for the small configurable program in listing .
iii.
a pproach change impact analysis cia is commonly performed by following edges in a system dependence graph sdg .
an sdg consists of nodes representing concrete and abstractprogram elements and edges encoding control and data depen dencies between the elements.
to make the cia configuration aware the variability of the program must be representedin the sdg.
in this work we use a conditional system dependence graph csdg an extension of the sdg that represents variability in form of presence conditions .
sincethe csdg uses presence conditions a configuration awarecia can be performed that also considers the different productconfigurations.
presence conditions are attached to edges in the csdg and have the following interpretation.
an edge labeled with apresence condition is only valid if the presence condition issatisfied with respect to a concrete product configuration.
ifthe execution of a program element depends on a particularproduct configuration the presence condition attached to acontrol edge represents the conditional execution of that pro gram element.
analogously a presence condition attached toa data dependence edge means that the data flow only existsin the product variant satisfying the presence condition.
figure gives an overview of our approach.
first the sdg is created and initial presence conditions are obtainedby analyzing the source code giving an initial csdg.
thenthe presence conditions are propagated over the edges.
once fig.
the three main steps of our approach building the csdg propagating the conditions and computing the change impact.
the edges are labeled with the propagated presence conditions the change impact can be computed by following the edgesand collecting nodes also considering the variability of thesystem.
the following sections iii a iii b and iii d willpresent these different steps in detail.
we implemented our configuration aware change impact analysis approach in java based on the soot analysis frame work .
we use soot s control flow data flow and pointeranalysis to build the sdg.
the propagation algorithm operateson the sdg and is therefore largely language independent.however the statements represented by an sdg node must beinvestigated to know how the configuration propagates throughthe program.
our current implementation uses binary decisiondiagrams bdds to represent presence conditions.
a. analyzing programs for configuration options our approach extracts variability information from source code.
it is therefore required to know how variability is implemented in a software system.
our approach specifically targetsload time configuration options a frequently used mechanismfor implementing variability which is applicable regardless ofthe programming language used.
the configuration options areusually stored in configuration files which are loaded in thestart up phase.
the options are stored in program variables which define the program s behavior but remain constantduring program execution.
our approach is not limited to thisform of variability but can easily be adapted to work withother variability implementation mechanisms analogously.
in the following we assume that configuration options are encoded in the form of boolean configuration conditions indicating if particular options are enabled.
our approach analyzesthe source code of a system to find statements which load and possibly combine configuration options to store themin program variables i.e.
statements that assign configuration conditions toconfiguration variables.
those configuration conditions become presence conditions attached to edges in the sdg as they are propagated as shown next.
b. propagating configuration conditions our approach propagates presence conditions and the values of configuration variables along control and data edges in the csdg to determine the effective conditions that apply tocertain program elements e.g.
statements .
for example whenchanging the statement in line of listing one needs toknow the condition that effectively applies to this statement.this seems to be easy at first sight as the statement isdirectly protected by a branch statement testing a configurationvariable.
however the actual condition may be even stricter ... ... x fb ... a updating a reaching condition set by a new configuration condition introduced by assigningconfiguration variable x.x fa x fb stmt ...... b joining reaching condition sets.
the twoincoming definitions of configuration variable x are combined disjunctively.... if f0 stmt c introducing a presence condition on a controledge.
the branch statement tests variable f0and therefore causes the presence condition to beupdated.
... ... ... ... d joining presence conditions.
the presenceconditions f0andf1are combined disjunctively as the control flow merges.... if !x stmtx f0 f1 e introducing and using new configuration vari ables.
the reaching condition x f f1 is used by branch statement if !x.
therefore a new presence condition is created by negatingthe reaching condition.... ... stmt ...... f propagating presence conditions to data de pendence edges.
the outgoing edge will onlybe valid if the statement is executed i.e.
c0is satisfied and if at least one incoming data edgeis valid i.e.
f0 f1is fulfilled.
fig.
basic cases of propagating presence conditions.
the newly created presence conditions are shown in framed text boxes.
especially if the method bar is only executed under a certain condition.
the effective conditions for statements can be computed by propagating the conditions along edges and combining them if a node has more than one incoming edge.
as explainedpreviously our approach can handle load time configurationoptions i.e.
during propagation we need to know whichconfiguration conditions can be used at a particular point ina program.
this can be achieved using a kind of reachingdefinition analysis for configuration variables based on thecontrol and data dependence edges of the sdg.
therefore propagation works with pairs where pis the presence condition that applies to an edge and rc is the set of reaching conditions defining which configurationvariables carry which configuration conditions.
the pairs arepropagated along the edges.
reaching conditions are propa gated based on data dependencies and presence conditions arepropagated based on control dependencies.
we will explain thepropagation approach by explaining six basic cases shown infigure .
a updating reaching condition sets.
this case deals with propagating a reaching condition set across a node introducinga new configuration condition cf.
figure 3a .
the reachingcondition set of the outgoing data dependence edge is updatedwith the new definition for variable x i.e.
x fb overwrites definition x fa .
b joining reaching condition sets.
in this case a node has two incoming and one outgoing data dependence edge.
thereaching conditions are combined using a union operation butreaching conditions for the same variables x fa and x fb are combined using a logical oroperator cf.
figure 3b .
c introducing presence conditions on control edges.
in this case a branch node tests a configuration condition fig ure 3c .
the incoming edge to node if f0 will only be executed if condition cis satisfied.
however the branch node further tests a configuration condition f0.
hence the control dependence successors will only be executed if this node isexecuted and if the generated presence condition is satisfied.therefore the outgoing edge leading to the node representingthe then branch is labeled with presence condition c f .
similarly the edge to the node representing else branch islabeled with cand the negation of f0.
d joining presence conditions.
in this propagation case a node has multiple incoming control dependence edges each 388carrying distinct presence conditions cf.
figure 3d .
the presence conditions of the input edges are combined disjunctivelyand the combined condition is then applied to every outgoingedge.
e introducing and using new configuration variables.
figure 3e shows the transformation from a reaching conditionto a presence condition.
a new configuration variable xis introduced which stores a combination of two configurationconditions f0andf1.
a data dependence edge propagates this definition to an if statement using the variable xin its branch condition.
thus the outgoing control edge is labeled with apresence condition !
f0 f1 .
f propagating presence conditions to data dependence edges.
the last case shows how presence conditions on incoming control and data dependence edges are propagated toan outgoing data dependence edge cf.
figure 3f .
first thepresence conditions of incoming control dependence edgespropagates to all outgoing data dependence edges as the datadependence of the node only occurs if the node is executed.therefore the outgoing data dependence edge gets a presencecondition c0in the example.
secondly there are incoming data dependence edges with presence conditions f0andf1.
however the statement can only be executed if one of theseedges provides data.
the outgoing data dependence edge isthus only valid if the statement is executed and if there isincoming data i.e.
the condition c0 f0 f1 is satisfied.
c. propagation semantics we provide a formal definition of the propagation semantics in terms of a data flow problem.
this allows us to infer twoproperties i the algorithm will terminate since all data flowproblems are fixpoint problems ii the runtime behavior of thealgorithm is the same as for other data flow problems i.e.
inthe worst case the runtime complexity is o n .
however an important difference to other data flow problems like reachingdefinitions is that our problem is defined on the csdg andnot on the control flow graph.
in order to describe a data flowproblem we define insets and outsets for the csdg nodes.
since we propagate both the presence conditions and thereaching conditions we separate these two aspects to simplifythe formulation.
equations formally describe the propagation semantics of the presence conditions.
we distinguish presence conditionsfor control and for data dependence edges as they are propa gated differently.
the symbol p ctrl innis the incoming control dependence presence condition and symbol pdata innis the incoming data dependence presence condition for node n. accordingly pctrl out nandpdata out nare the outgoing sets.
the set ctrl preds nrepresents the control dependence predecessors and data preds nrepresents the data dependence predecessors of a csdg node n. as shown in equations and the presence condition of an incoming edge is thedisjunction of the presence conditions of the outgoing edgesof predecessors both for control edges and data edges.
p ctrl inn logicalordisplay pred ctrl preds npctrl out pred pdata inn logicalordisplay pred data preds npdata out pred pctrl out n pctrl inn ext rcinn n pdata out n pctrl inn pdata inn equation defines the propagation of presence conditions for outgoing control edges i.e.
the presence condition ofthe incoming edge is anded logically with ext rc inn n .
function ext rcinn n provides the configuration conditions node nintroduces e.g.
by a branch condition cf.
figure 3c which is dependent of the incoming reaching condition setrc inn.
equation finally defines the presence condition for the outgoing data dependence edge as an and combination ofthe presence condition of the incoming control edge and datadependence edge cf.
figure 3f .
equations formally describe the propagation semantics of the reaching conditions.
recall that reaching conditions aresets of configuration variable definitions i.e.
sets of pairsrc confv ariables conditions where confv ariables is the set of configuration variables and conditions is the set of all possible configuration conditions.
rc inn circleplusdisplay pred data preds nrcout pred rcout n rcinn circleminusrckill n rcgen n the operators and circleminusare similar to the set union operator and set difference operator but also consider introducing and killing of configuration conditions.
we defineoperator to form the union of two given reaching condition sets rc 1andrc2but definitions affecting the same variables are joined by combining the condition disjunctively.
for ex ample x f0 y f1 x f1 z f2 x f0 f1 y f1 z f2 .
thus equation defines the reaching condition set of an incoming data dependence edge as the combination of the outgoing predecessor data dependence edges.
equation defines the case when the statement of an csdg node modifies the reaching conditions set cf.
fig ure 3a .
if the statement redefines the value of a configurationvariable all pairs of the incoming reaching conditions set forthis variable are killed and a new pair with the new valueis generated.
therefore we define the operation rc circleminusrc2for two reaching conditions sets rc1andrc2by removing all pairs x c1 from rc1if there is a pair y c2 rc2with x y. function rcgen n returns the definitions x c introduced by node n e.g.
a definition introduced by a node representing an assignment of a configuration condition cto a configuration variable x. the function rckill n is the set of definitions which are possibly killed by node n i.e.
any definition to a variable x which is overwritten by n. d. computing the configuration aware change impact we can now perform the configuration aware cia using our algorithm to propagate conditions to every csdg node.we expect that in most cases changes will affect only a subsetof the source code.
propagating the conditions globally and inadvance would thus be wasteful for determining the changeimpact.
therefore our configuration aware cia algorithmpropagates presence conditions only in the required domain asfollows we first determine the backward slice starting withthe nodes for which we want to compute the change impact 389i.e the cia criterion.
we then propagate the conditions within the computed backward slice such that presence conditionare attached to all incoming edges of the cia criterion.
theactual change impact analysis is performed in the third stepstarting with the cia criterion by propagating the conditionsaccording to the propagation rules.
however we need to knowthe presence conditions and reaching conditions for all nodesin the change impact to compute the correct conditions.
wethus mark all nodes with incoming edges that have no presenceconditions yet.
after collecting these nodes we compute abackward slice to determine the final propagation domain.finally we apply the propagation algorithm in this domain andlabel all edges in the change impact with the correct conditions.in this way we assure that we do not miss any conditions andavoid a global propagation across the entire csdg.
iv .
e v aluation our evaluation investigates the benefits regarding complexity reduction and the performance of the configuration awarecia approach in two use cases i development and mainte nance in domain engineering i.e.
for determining the differentproduct variants affected by a change and ii development andmaintenance in application engineering i.e.
for determiningcode affected by a change made to a specific product variant.specifically we use product families of our industry partnerto explore the following research questions rq1.
how beneficial is the configuration aware cia for maintaining a product line?
our approach is highly beneficial in situations of high variability complexity.
we thus estimatethe benefit by computing the degree and complexity of vari ability information a domain engineer needs to consider whendetermining the impact on product variants after changing codein a product line.
rq2.
how beneficial is the configuration aware cia for maintaining a specific product variant?
this situation is common in clone and own product lines.
some of the variabil ity has already been resolved e.g.
by setting configurationoptions.
however developers still need to adapt and fine tune the product variant to meet specific customer needs.
weestimate the benefit by computing the increased precision ofthe change impact as a smaller change impact will reduce thedevelopment effort.
rq3.
is the performance of the configuration aware cia sufficient for realistic maintenance tasks?
a major problem of static program analysis is high run time complexity.
weperform benchmarking to show the practicality and suitabilityof the approach in realistic maintenance tasks.
a. case study and code base selected for the evaluation to investigate these research questions we applied our tool to real world software systems provided by our industry partner keba ag a medium sized com pany developing and producing tools hardware and softwarefor the industrial automation domain.
one of their systems iskeplast a comprehensive solution for the automation ofinjection molding machines.
the core of keplast is a con figurable control software framework which is implementedin a proprietary dialect of the iec standard a widely adopted programming language standard for im plementing industrial automation systems.
keplast exists inmultiple different product families addressing different marketsegments.
keba uses a custom developed product configurationtool to select components from their keplast platform basedon customer requirements.
the selected components are thenadapted and extended by application engineers to meet specificcustomer needs not yet covered by the platform.
in this stage the derived software is still configurable by using load timeconfiguration options the variability mechanism targeted byour approach.
as a baseline for our evaluation we derived product variants from keplast s families which contain a maximum number offeatures selectable together in the product configuration tool.these maximum products do not contain the full code baseof the product line but are an approximation good enough forthe purpose of our study.
in particular we used differentstill configurable product variants with a size ranging from kloc family4 t o302 kloc family2 .
furthermore these maximum product variants of a family indeed have commonalities and differences.
in the case of ourindustry partner s product families the common code i.e.
themandatory features is a substantial part of the source codebecause it includes implementations for basic data structuresand algorithms used in all product variants.
we therefore con centrate on the variable part of the analyzed product familiesto obtain data that is most relevant for our research questions.specifically we only considered change impacts containing atleast one presence condition.
this was the case for of all change impacts in our case study median across productfamilies .
b. tool implementation and adaptation keplast has been developed in a proprietary dialect of the iec standard for which no parser or compiler suitable for program analysis was available.
we thus first had to createa parser frontend using the parser generator coco r andan abstract syntax tree ast to represent the parsed sourcecode.
our ast implementation is based on modisco animplementation of the omg astm standard that defines anast meta model.
based on the ast we generate jimple codewhich is the input for the analysis framework soot .
adetailed description of our parser and analysis is available asa technical report .
the result of a cia is a subgraph of the csdg.
we thus also implemented a graph viewer based on the eclipse framework which uses d3.js to visualize the results for developers.
our change impact visualization allowsto interactively expand the change impact.
users can inspectdetails like types source code locations presence conditions and many other attributes of the nodes.
c. rq1 domain engineering as argued above the benefit of the configuration aware cia depends on the complexity of the variability information and the contradictions of the presence conditions which al low pruning the change impact.
recall that in our approachvariability information is propagated based on the program k10 k15 k20 k25 k30 k35 k40 k .
.
.
.
.
.
.
.
.
1number of change impacts portion of nodes with variability informationfamily0 kloc family1 kloc family2 kloc family3 kloc family4 kloc family5 kloc family6 kloc family7 kloc family8 kloc a rq1 variability complexity.
k4 k6 k8 k10 k12 k14 k16 k18 k 32number of change impacts number of interacting variables b rq1 variability interaction order.
k10 k15 k20 k25 k30 k35 k40 k .
.
.
.
.
.
.
.
.
1number of change impacts portion of contradicting nodes c rq1 contradicting conditions ratio.
k10 k100 k .
.
.
.
.
.
.
.
.
1number of change impacts relative size of the reduced change impact to original size d rq2 relative change impact size.
fig.
results for rq1 and rq2 computed by applying our tool to a set of real world product families provided by our industry partner.
dependencies and is therefore usually not visible directly in the source code.
we define three metrics to characterize the variability of a code base.
the v ariability complexity is the ratio of edges with variability information to the total number of edges within achange impact.
our approach is more beneficial if more edgesare annotated with variability information as this would makea manual cia even harder.
the v ariability interaction order measures the average number of involved distinct configuration options in the vari ability information.
this is computed by counting the numberof distinct configuration options in a single presence conditionand computing the mean of these numbers over all edges.
forexample if the two presence conditions a band a care in a change impact the interaction measure would be .
this metric thus represents the interaction between differentconfiguration options.
the benefit of the approach increaseswith the order of the variability interaction as manuallyanalyzing complex interactions is hard to infeasible.
contradicting conditions ratio.
the propagation of presence conditions may result in contradicting presence condi tions which can never become valid regardless of the productconfiguration.
such invalid edges allow removing statementsfrom the change impact.
our measure is the ratio of invalidedges to the total number of edges.
a higher value is betterbecause the change impact is smaller and more precise.method.
we performed the configuration aware cia for every single statement in the selected product families.
thiswas done in two phases in phase we built the csdg forthe product family.
this included parsing the source code performing control flow data flow and pointer analysis to buildthe sdg and extracting the initial conditions from the sourcecode.
in phase we performed the configuration aware changeimpact analysis as outlined in section iii d. specifically weiterated over allstatement nodes in the csdg and performed a configuration aware cia.
results.
figure 4a shows the results of our evaluation for the metric v ariability complexity.
the x axis shows the complexity values i.e the portion of nodes with variabilityinformation.
we grouped the values into intervals of width .
.
thus the x axis represents intervals .
.
.
.
... an interval is denoted by its middle value on the xaxis.
the y axis is the number of change impacts contained ina certain interval.
the chart shows the cumulative distributionof change impacts for these groups.
for example the datapoint at .65of the family2 says that approximately change impacts had a variability complexity value in interval .
.
.
therefore a presence condition was available for up to70 of the statements in the change impact.
figure 4b shows the results for metric v ariability interaction order.
the x axis shows the average number of configu ration options involved in the presence conditions of a changeimpact.
the y axis is the number of change impacts that have acertain average number of involved configuration options.
for 391example the family6 has a peak at x i.e.
around change impacts involve on average 4configuration options.
figure 4c shows the results for metric contradicting conditions ratio.
the x axis shows the portion of nodes that are invalid because of a contradicting condition.
we again groupedthe values into intervals of width .
.
the x axis therefore represents intervals .
.
a n interval is denoted by its middle value on the x axis.
the y axisagain represents the number of change impacts as in figure 4a.the chart shows the cumulative distribution of change impactsfor these groups.
for example in family2 atx .15the size of33 000change impacts could be reduced by up to .
discussion.
the results of metric v ariability complexity shown in figure 4a show that the approach is beneficialgiven the complexity of variability in real world systems.
thegraph shows a cumulative distribution function.
the steepera line the more variability information is available in thecomputed change impacts.
the chart also shows that largerproduct families provide even more variability information.for example consider family2 the largest product family in our study.
it first grows moderately until .45but then it starts to grow faster i.e.
of the statements in most change impacts had variability information available.
when combiningthe data in figure 4a to one value we see that overall thechange impacts have presence conditions available on average median .
we therefore conclude that our approachis even more beneficial in larger systems as more variabilityinformation needs to be considered.
the results for metric v ariability interaction order shown in figure 4b show a similar picture.
dealing with interactionsinvolving 2or3configuration options is already quite cumbersome.
the results show that the majority of all change impactshad presence conditions with up to 5configuration options involved on average.
other empirical studies have shown aninteraction degree of 2or3to be common similar to our results.
however there were also quite a few changeimpacts with higher numbers of 10to35configuration options perpresence condition an order that is almost infeasible to comprehend by developers.
in section iv a we described that our analysis is performed on product families which have already been partially config ured and can be compiled.
therefore the product families source code does not contain any mutually exclusive featureimplementations.
so regarding the contradicting conditions ratio we did not expect a significant increase of the precision of change impacts by finding contradicting presenceconditions.
this did in fact happen for the analyzed productfamilies family0 family4 and family5.
we see no increase in the corresponding lines in figure 4c i.e.
we could not removeany statements from the change impacts.
however we stillcould increase the precision of change impacts in the otherproduct families.
for example the difference between the lasttwo data points of family2 shows that it was even possible to find approximately 000change impacts whose size could be reduced by .
d. rq2 application engineering for this use case we perform cia for a specific product configuration i.e.
we remove elements from the result thathave not been used in this specific configuration.
again we distinguish between change impacts with and withoutvariability information because the latter one covers mostcommonly just library code which is less interesting in termsof variability.
we define metric relative change impact size to measure the reduced numbers of edges in the changeimpact after evaluating the presence conditions compared tothe original change impact.
the original change impact is theconfiguration aware change impact but ignoring the presenceconditions.
method.
analogously to the method for rq1 we performed the configuration aware cia for every single statementof our product families phase .
however for answeringrq2 we created concrete product configurations by randomlygenerating boolean values for each known configuration option phase .
when computing the change impact the presenceconditions were then evaluated using these randomly generatedvalues for the configuration options.
we measured the reduc tion of the change impact size compared to its original size.this was repeated times with different generated values tocompute an average for the relative change impact size.
results.
figure 4d shows the results for rq2.
each line corresponds to one of the analyzed product families.
the x axis and y axis represent the same as in figure 4a.
the resultsare again grouped into intervals of width .
.
for example the data point at x .85offamily4 means that the size of approximately change impacts has been reduced by to20 .
discussion.
we observe that evaluating the presence conditions after computing the change impacts reduces the sizeto90 in most cases.
figure 4d shows a sharp edge at the end of all lines which means most change impacts arein the last group.
we expected these numbers to be moredistributed across the other groups.
but there are also manychange impacts that could be reduced to less than of their original size.
to answer rq2 we conclude that evaluating thepresence conditions yields noticeable benefit for maintenancebecause fewer statements have to be considered although weexpected to do better.
e. rq3 performance one major problem of static program analysis techniques is commonly their analysis time.
we therefore measured the analysis time of our tool when analyzing our industry partner sproduct families.
method.
the performance evaluation needs to consider both building the csdg and performing the configuration awarecia.
we already showed in that building the csdg including the time needed to do all required analyses is ina nearly linear relation to the size of the analyzed software.the same is true for the peak memory consumption.
in thisevaluation we thus report performance results for the technicalcontributions of this paper.
we therefore measured the size ofall configuration aware change impacts and the time requiredto compute them cf.
phase of rq1 and rq2 .
results.
the results of this evaluation part are shown in figure .
a cross in the chart represents a change impact.
thex axis lists the size of the change impacts in terms of included 140000time size of change impact fig.
rq3 average time required to compute configuration aware change impacts of a specific size.
statements.
the y axis shows the time required to compute the change impacts in milliseconds.
the performance evaluationhas been executed on an intel core i7 .
ghz gbddr3 ram machine running ms windows bit.
discussion.
the results show that the computation of a change impact is fast and never takes longer than .5seconds.
it also seems that the time required to compute a changeimpact does not depend on its size because we cannot observeany linear or higher order dependency on the change impactsize.
we assume the time is dominated by the first step ofthe ca cia algorithm i.e.
computing the backward sliceto determine the possible influencing presence conditions.however computing the change impact is negligible comparedto the time required to build the sdg which took between and270seconds .
f .
threats to v alidity there is a potential bias caused by the selection of product families in a specific application domain that havebeen developed in a specific programming language.
we thuspresent detailed evaluation results and avoid generalizationsof how well the approach would work for other programminglanguages and pls.
however our evaluation focuses on load time configuration options a variability mechanism that iswidely used in all programming languages.
also given thatcompanies typically do not provide access to data about theirproduct lines we believe that our evaluation results are valuableand promising.
specifically our evaluation is based on partially configured product families that have been derived from a productline by selecting all features defined in a custom developedconfigurator.
we could not analyze the full code base of theproduct line as the variability information is stored implicitlyin the configurator.
as a result the evaluation is based on aless configurable code base e.g.
certain alternative featuresare not included.
however this means that the results wouldbe even more favorable for the full code base.
a prerequisite of our approach is that the mechanism for implementing variability in source code is known.
this couldbe a problem in software projects without any conventions forthis aspect as extracting the initial conditions might not bepossible.
however related work indicates that most ofthe time it is known how variability is realized.
furthermore reisner et al.
show that open source systems heavily useconfiguration options to implement variability.
the analyzed product families are executed in a runtime environment that provides library functions whose implemen tation is unknown.
this is also a source of imprecision whenbuilding the csdg.
however such system functions occurin almost all execution environments and must be handledappropriately.
our implementation handles this problem byassuming the worst case if something is not known.
forexample if a system variable returns a reference to a variableand this reference cannot be determined we assumed thatevery reference may be returned.
this is the common strategyto preserve soundness but sacrifices precision.
we have taken several measures to mitigate the risk of incorrect computations we use the data flow and pointer analysisof the widely used soot tool suite to build the sdg so we havea high confidence that this part of the implementation producescorrect results.
furthermore the part of our implementationthat extracts variability information from source code hasalready been reviewed by a developer of our industry partnerin a qualitative process in our previous work .
finally weperformed unit testing and manual reviews for the results basedon test input.
v. r elated work we structure our comparison to related work into work concerning i tracking configuration options ii variability aware program analysis and iii program slicing and changeimpact analysis.
tracking configuration options.
lillack et al.
developed an approach for tracking load time configuration options.they use a modified taint analysis to determine source codedepending on configuration options and also compute presenceconditions for the code.
the propagation phase of our algo rithm is comparable to their taint analysis but their tool com putes a different information.
they create mappings betweenconfiguration options and source code statements whereas ourapproach globally propagates variability information and pro vides this information for an arbitrary change impact.
lillacket al.
implemented their approach in a tool called lotrack by modifying soot s taint analysis.
the implementation ofour approach works at a higher level i.e.
the csdg andis therefore less dependent on the analysis implementationsrequired to build the csdg.
we think this is an importantproperty because modifying existing implementations is oftendifficult and error prone.
xu et al.
introduce a tool named spex that analyzes a program s source code to infer constraints for configura tion options by tracking the data flow of each configurationvariable.
they also use program slicing to reduce the domainto consider but only on a configuration variable s data flowgraph.
the reduced domain is then used to infer constraintsfor configuration options by analyzing the statements usingthem.
this is related to our approach as we also analyze howa configuration variable is used by considering the data flowgraph of the variable.
however their two phase algorithm mayinfer invalid constraints whereas the fixpoint algorithm we use 393computes an over approximation i.e.
the results are sound but may provide false positives.
v ariability aware program analysis.
several authors have presented analysis techniques considering program level vari ability mechanisms.
variability aware program analysis tech niques exploit the similarities among individual variants toreduce program analysis effort.
k astner et al.
present the tool typechef which parses unpreprocessed c source code and encodes the variability in the abstract syntax tree usingpresence conditions.
brabrand et al.
present an approachto automatically lift standard intraprocedural dataflow analy ses to feature sensitive analyses.
a lifted analysis can thenanalyze the whole program space of a preprocessor basedproduct line at once.
liebig et al.
provide variability aware type checking and a variability aware liveness analysisfor preprocessor based product lines also based on encodingvariability using boolean formulas.
they also use a fixpointalgorithm to compute the result for single program elements as in all dataflow analyses.
the work introduces the patterns ofearly joining and late splitting which is crucial for scalability.
while we also use these patterns to keep the number ofexplicitly stored result data minimal our approach differswith respect to when the variability information is added.the above approaches extract variability information from avariable ast then build a variable control flow graph cfg and finally carry out the variability aware analysis.
in ourcase the variability information is added in the last step afterbuilding sdg.
however considering variability in the ast andcfg could further increase the precision of building the csdgand therefore improve the overall results of our analysis.
butsince in our context variability is mainly implemented usingrun time configuration options instead of ifdef directives we do not need variability aware parsing.
k astner et al.
provide comprehensive support for creating feature models locating feature code based on manualseeds and rewriting code into conditional compilation andfeature modules.
our approach also employs program analysistechniques to build the csdg.
however our goal is not tolocate or rewrite feature code although the propagation of thepresence conditions could be used for feature location.
zhang and ernst present the confdiagnoser approach which uses static analysis dynamic profiling and statisticalanalysis to reveal the root cause of configuration errors.
ourapproach also exploits static analysis techniques and usesconfiguration files as input however we do not focus ondetermining configuration options leading to an error.
reisneret al.
empirically analyze how configuration options affectprogram behavior.
in particular the authors use symbolicevaluation to discover how run time configuration optionsaffect line basic block edge and condition coverage fordifferent subject programs.
we also compute the influenceof configuration options to statements.
our approach is notlimited to compute the impact when changing a configurationoption but works with arbitrary statements.
program slicing and change impact analysis.
our approach builds on earlier cia research like arnold et al.
orprogram slicing approaches as summarized in xu et al.
.in particular the implementation of our approach is basedon the interprocedural program slicing technique describedby horwitz et al.
.
the approach presented in this paperfurther uses the csdg we have presented in our previouswork .
in contrast to most existing change impact analysisapproaches our approach extracts and propagates conditionsover the csdg similar to snelting who aims at in creasing the accuracy of slices by eliminating impossibleexecution paths.
this is done by extracting path conditionsfrom all conditional statements and employing an smt solverto eliminate infeasible paths.
in contrast we only extractconditions considering configuration variables and only dealwith variability that can be represented by boolean formulas.since we extract fewer conditions and can use a sat solver forreasoning our approach can deal with much larger programscompared to data reported by .
vi.
c onclusions and future work this paper presented a configuration aware change impact analysis approach which is based on program slicing tech niques and a conditional system dependence graph csdg an extension of an sdg.
the approach can deal with load time configuration options.
it propagates presence conditionsrepresenting the variability of the analyzed software system.we implemented the approach based on the soot analysisframework .
we additionally built a front end for sootfor an industry partner s software systems and programminglanguage.
we then evaluated the benefit and performance ofour approach on product families of the industry partnerto investigate the distribution and complexity of variabilityinformation and the required analysis time.
regarding rq1 we found high variability complexity demonstrating the benefit for our approach in industrial sizesystems.
specifically in more than of all computedchange impacts to60 of the impacted nodes carried variability information.
regarding variability interaction or der we also observed very high interaction orders of up to35 configuration options.
with respect to rq2 the evaluationshowed a noticeable benefit because fewer statements haveto be considered in maintenance tasks.
regarding rq3 theruntime performance of building the sdg and computing thechange impacts allows the use of our technique in typicaldevelopment and maintenance tasks.
as future work we plan to formalize our approach using the framework by midtgaard et al.
which allows toderive variability aware analyses for software product lines.we want to show that our configuration aware cia can bederived from a standard cia approach.
furthermore we alsoplan to extend our tool to support multi language softwaresystems as outlined in .
this is important for industrialsoftware systems which often comprise subsystems writtenin different languages.
for instance it is common practice toload configuration options in one subsystem and communicatethis information to other subsystems using different languages.performing a configuration aware cia in such an environment will require extensions to our approach allowing to jointlyanalyze the subsystems.
a cknowledgment this work has been conducted in cooperation with keba ag and has been supported by the christian dopplerforschungsgesellschaft austria.
394references j. liebig a. von rhein c. k astner s. apel j. d orre and c. lengauer scalable analysis of variable software in proc.
of the 9th joint meeting on f oundations of software engineering esec fse n e w york ny usa pp.
.
t. th um s. apel c. k astner i. schaefer and g. saake a classification and survey of analysis strategies for software product lines acm computing surveys csur vol.
pp.
.
c. k astner p. g. giarrusso t. rendel s. erdweg k. ostermann and t. berger variability aware parsing in the presence of lexical macrosand conditional compilation in proc.
oopsla pp.
.
r. s. arnold software change impact analysis.
los alamitos ca usa ieee computer society press .
l. linsbauer f. angerer p. gr unbacher d. lettner h. pr ahofer r. lopez herrejon and a. egyed recovering feature to code map pings in mixed variability software systems in proc.
of the 30th int l conf.
on software maintenance and evolution icsme .
j. rubin and m. chechik a framework for managing cloned product variants in proc.
of the 35th int l conf.
on software engineering icse pp.
.
c. hammer j. krinke and g. snelting information flow control for java based on path conditions in dependence graphs in proc.
ieee int l symposium on secure software engineering pp.
.
f. angerer h. pr ahofer d. lettner a. grimmer and p. gr unbacher identifying inactive code in product lines with configuration awaresystem dependence graphs in proc.
of the 18th int l software product line conf.
splc florence italy .
d. lettner f. angerer h. pr ahofer and p. gr unbacher a case study on software ecosystem characteristics in industrial automationsoftware in proc.
of the int l conf.
on software and systems process icssp nanjing china .
d. lettner f. angerer p. gr unbacher and h. pr ahofer software evolution in an industrial automation ecosystem an exploratorystudy in proc.
int l euromicro conf.
on software engineering and advanced applications verona italy .
k. c. k. chen and v .
rajich ripples tool for change in legacy software proc.
ieee int l conf.
on software maintenance.
icsm .
j. j asz a. besz edes t. gyim othy and v .
rajlich static execute after before as a replacement of traditional software dependencies inieee int l conf.
on software maintenance icsm pp.
.
s. bohner extending software change impact analysis into cots components 27th annual nasa goddard ieee software engineering workshop .
proceedings.
.
s. black computing ripple effect for software maintenance journal of software maintenance and evolution research and practice vol.
no.
pp.
.
g. snelting combining slicing and constraint solving for validation of measurement software in static analysis se ser.
lecture notes in computer science r. cousot and d. schmidt eds.
springer berlinheidelberg vol.
no.
springer pp.
.
s. horwitz t. reps and d. binkley interprocedural slicing using dependence graphs acm transactions on programming languages and systems toplas vol.
no.
pp.
.
p. lam e. bodden o. lhot ak and l. hendren the soot framework for java program analysis a retrospective in cetus users and compiler infastructure workshop cetus .
d. lettner m. petruzelka r. rabiser f. angerer h. pr ahofer andp.
gr unbacher custom developed vs. model based configuration tools experiences from an industrial automation ecosystem in proc.
of the 17th int l software product line conf.
splc workshops .n e wyork ny usa acm pp.
.
iec iec programmable controllers part programming languages .
.
available a. w o m. l oberbauer and h. m ossenb ock ll conflict resolution in a recursive descent compiler generator in modular programming languages ser.
lecture notes in computer science.
springer berlinheidelberg vol.
pp.
.
h. bruneliere j. cabot g. dup e and f. madiot modisco a model driven reverse engineering framework information and software technology vol.
no.
pp.
.
a. grimmer f. angerer h. pr ahofer and p. gr unbacher developing a multi language program analysis approach for industrial automationsystems experiences and lessons learned christian dopplerlaboratory mevss johannes kepler university linz technicalreport .
.
available s. apel s. kolesnikov n. siegmund c. k astner and b. garvin exploring feature interactions in the wild the new feature interactionchallenge in proc.
of the 5th int l workshop on feature oriented software development ser.
fosd .
new york ny usa acm pp.
.
t. berger s. she and r. lotufo variability modeling in the real a perspective from the operating systems domain measurement pp.
.
e. reisner c. song k. k. ma j. s. foster and a. porter using symbolic evaluation to understand behavior in configurable softwaresystems in proc.
of the 32nd acm ieee int l conf.
on software engineering v olume .
acm pp.
.
m. lillack c. k astner and e. bodden tracking load time configuration options in proc.
of the 29th acm ieee int l conf.
on automated software engineering ser.
ase .
new york ny usa acm pp.
.
t. xu j. zhang p. huang j. zheng t. sheng d. yuan y .
zhou and s. pasupathy do not blame users for misconfigurations in proc.
of the twenty f ourth acm symposium on operating systems principles ser.
sosp .
new york ny usa acm pp.
.
c. brabrand m. ribeiro t. tol edo and p. borba intraprocedural dataflow analysis for software product lines in proc.
of the 11th annual int l conf.
on aspect oriented software development ser.
aosd .
new york ny usa acm pp.
.
c. k astner a. dreiling and k. ostermann variability mining consistent semi automatic detection of product line features ieee trans.
software eng.
vol.
no.
pp.
.
s. zhang and m. d. ernst automated diagnosis of software configuration errors in 35th int l conf.
on software engineering san francisco ca usa pp.
.
b. xu j. qian x. zhang z. wu and l. chen a brief survey of program slicing sigsoft softw.
eng.
notes vol.
no.
pp.
mar.
.
j. midtgaard c. brabrand and a. wasowski systematic derivation of static analyses for software product lines in proc.
of the 13th int l conf.
on modularity ser.
modularity .
new york ny usa acm pp.
.
f. angerer variability aware change impact analysis of multilanguage product lines doctoral symposium paper in proc.
of the 29th acm ieee int l conf.
on automated software engineering ase .
new york ny usa acm pp.
.