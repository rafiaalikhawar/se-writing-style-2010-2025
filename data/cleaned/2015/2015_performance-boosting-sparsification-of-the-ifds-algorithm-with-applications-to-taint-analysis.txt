performance boosting sparsification of the ifds algorithm with applications to taint analysis dongjie he haofeng li lei wang haining meng hengjie zheng jie liu shuangwei hu lian li and jingling xue unsw sydney australia skl of computer architecture ict cas china university of chinese academy of sciences china vivo ai lab china abstract the ifds algorithm can be compute and memoryintensive for some large programs often running for a long time more than expected or terminating prematurely after some timeand or memory budgets have been exhausted.
in the latter case the corresponding ifds data flow analyses may suffer from falsenegatives and or false positives.
to improve this we introduce asparse alternative to the traditional ifds algorithm.
instead of propagating the data flow facts across all the program points along the program s interprocedural control flow graph wepropagate every data flow fact directly to its next possible usepoints along its own sparse control flow graph constructed onthe fly thus reducing significantly both the time and memoryrequirements incurred by the traditional ifds algorithm.
in our evaluation we compare f low droid a taint analysis performed by using the traditional ifds algorithm with oursparse incarnation s parse droid on a set of android apps selected.
for the time budget hours and memory budget 220gb allocated per app s parse droid can run every app to completion but f low droid terminates prematurely for apps resulting in an average speedup of .0x.
this implies that when used as a market level vetting tool s parse droid can finish analyzing these apps in .
hours by issuing leak warnings while f low droid manages to analyze only apps in the same time period by issuing only leak warnings .
index t erms ifds data flow analysis taint analysis i. i ntroduction the ifds interprocedural finite distributive subset data flow problems formulated in are solved in a widerange of application areas including model checking program verification slicing pointer analysis dynamic test generation bug detection security analysis and taint analysis .
insuch an interprocedural data flow problem the set of data flowfactsdis finite and the data flow functions in d mapsto 2d distribute over the meet operator intersectionsq union or intersection .
when formulating the ifds problems reps et al.
introduced a polynomial time algorithm for solving each asa special kind of graph reachability problem reachabilityalong interprocedurally realizable paths .
this ifds algorithmoperates on the interprocedural cfg g n e of a program consisting of the cfgs for all its functions connectedby call and return edges .
interprocedurally the data flow facts indare propagated from a callsite to an invoked callee foo corresponding authoring via a call edge to foo s cfg and then back from the foo s cfg via a return edge to the same callsite contextsensitively over a balanced parentheses language by matchingcall and return edges.
intraprocedurally the data flow facts indare propagated across the edges in foo s cfg.
this algorithm runs in o e d until a fixed point is found.
this classic ifds algorithm can be compute and memoryintensive as it propagates the data flow facts across all the program points along all the edges in g .
its multi threaded versions can speed it up but still unsatisfactorily for some programs.
for example f low droid includes a multi threaded ifds solver that deploys multiplethreads on multiple cpu cores to propagate the data flowfacts concurrently along different edges in g .
however when applied to perform taint analysis for a set of androidapps on a computer server with intel xeon cpu cores equipped with 730gb ram its ifds solver with even many compromises made can spend hours on one app byusing all the memory resulting in apps still unanalyzable .
such premature terminations will cause the underlyinganalysis to report either more false negatives i.e.
miss morebugs or more false positives i.e.
false warnings or both.
in practice static analysis tools have become part of the core developer workflow in software industries such as google .as part of nightly builds static analysis tools are expected tobe efficient especially for handling large codebases .
in this paper we focus on accelerating the ifds algorithm by propagating the data flow facts sparsely rather than densely in g orthogonally to multi threaded acceleration .
our key insight is that the traditional ifds algorithm propagates too many data flow facts redundantly across toomany edges in g before they are actually used resulting in excessive time and memory requirements for some programs.we can speed it up significantly if we can cut down its cpuand memory usage.
we will achieve this by propagating adata flow fact sparsely i.e.
directly to its next possible use points in g .
the challenge lies in how to identify such next possible use points for a data flow fact efficiently without losing the performance benefits reaped from its subsequentsparse propagation.
the key novelty here is to build a sparsecfg scfg for each data flow fact on demand i.e.
onlywhen needed to enable its profitable sparse propagation.
ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxb sf ohjoffsjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
to demonstrate the performance benefits for sparsifying the ifds algorithm we consider taint analysis for findinginformation leaks in android apps a significant client analysissolved as an ifds problem.
currently f low droid represents a state of the art tool for solving taint analysis byusing a multi threaded implementation of the traditional ifdsalgorithm .
f low droid applies its two passes iteratively a forward one for discovering more tainted access paths anda backward one for discovering more aliases until a fixedpoint has been reached.
as its sparse alternative our newtool s parse droid aims to improve its performance by employing our sparse ifds algorithm in both of its two passes.
this paper makes the following main contributions we present a new approach for sparsifying the traditional ifds problems to accelerate its performance.
we introduce a sparse ifds based taint analysis fordetecting information leaks in android apps.
we have evaluated s parse droid against f low droid driven by a non sparse ifds algorithm on androidapps with from fossdroid and from googleplay .
given a time budget hours and memory budget 220gb per app s parse droid runs every app to completion but f low droid terminates prematurely for apps resulting in an average speedup of .0x.
thisimplies that when used as a vetting tool s parse droid can finish analyzing these apps in .
hours byissuing leak warnings while f low droid analyzes only apps in the same time period by issuing only 147leak warnings even if timeout apps are ignored .
the rest of the paper is organized as follows.
section ii provides an overview of and motivates our sparse ifds analysis.
section iii introduces our sparse ifds framework.section iv contains a concrete instantiation of our sparseframework for performing sparse taint analysis.
section vpresents and analyzes our experimental results.
section videscribes the limitations of our sparse algorithm.
section vii discusses the related work.
finally section viii concludes.
ii.
m otiv a tion we motivate our sparsification of the ifds algorithm by considering taint analysis as an instantiation.
in sec tion ii a we introduce an example program and find itstainted access paths manually.
in section ii b we describe how f low droid does this automatically by applying the traditional ifds algorithm.
in section ii c we explain how sparse droid our sparse version of f low droid works.
a. an example program let us focus on analyzing foo in figure by assuming thataanda.g passed from its callers are untainted and the call to a line has no effect on our analysis.
to find all the tainted accesses manually we need to keep track of allthe relevant access paths data flow facts flowing along thecontrol flow while also being mindful about their aliases.
initially bis tainted in line .
then both a.f an instance field and a.h a static variable are tainted in lines and respectively.
however a.h becomes untainted after each call toa.bar lines and as it is killed in a.bar .i n line as a.f is tainted x.k.f gets tainted.
as candxare aliases c.k.f is tainted in line too.
with k limiting all the access paths that are longer than kare truncated.
b.f low droid the ifds based taint analysis flow droid applies the traditional ifds algorithm to solve the taint analysis problem as illustrated in figure a .flowdroid operates on the interprocedural cfg icfg i.e.
supergraph g n e of the program.
g consists of the cfgs of all the functions in the program.
there are fourtypes of edges.
in addition to the normal i.e.
intraprocedural edges in a cfg every callsite is connected to a called functionby a call edge a return edge and a call to return edge to enable the interprocedural data flows across the callsite .
in actuality g is exploded by associating its edges with all the data flow facts i.e.
access paths in dtracked during the taint analysis.
the meet operator intersectionsqused is as an access path is considered as tainted at a joint point if it is tainted in any of incoming control flow paths.
each edge has a flow functionthat takes the set of old facts arriving at the edge as input andsends the set of new facts across the edge as output.
f low droid proceeds iteratively by performing two passes repeatedly a forward pass for discovering tainted accesses anda backward pass for dicovering aliases until a fixed point isreached.
in the first forward pass f low droid discovers b a.f a.h x.k.f anddto be tainted at different program points except that a.h becomes untainted after each call to a.bar .
for example as a.f is a tainted fact in line the flow function associated with its edge ending at line 15will cause x.k.f to be tainted.
in the ifds algorithm 0denotes an empty fact allowing new facts to be generated at a program point e.g.
line .
as x .
k a is a store f low droid starts a backward pass to search for the aliases ofx.k.f finding c.k.f to be aliased with x.k.f after line .
for this standard pass we refer to for more details.
in a subsequent forward pass c.k.f is propagated forwards and recognized as being tainted just after line .
two points are made about the traditional ifds algorithm dense propagation of facts.
the traditional ifds algorithm employed by f low droid propagates many dataflow facts across many program points redundantly beforethey are actually used as highlighted by many such solid dots in figure a .
take a.f tainted in line for example.
all the subsequent propagations before it reaches line and14 are a waste of both cpu and memory resources.
multi threading.
in the ifds framework all the flow functions are distributive.
as also in f low droid takes advantage of multi threading to process propagations for different edges in different threads.
c.sparse droid our sparse ifds based taint analysis instead of propagating data flow facts densely as in f low droid based on the traditional ifds algorithm figure a our sparse version s parse droid based on our sparse ifds authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
class a public a static void bar p a.h kill void foo a b source a.f b a.h b if z a.g a.bar z else d a.f a.bar d x new a c x x.k a sink a.f tainted sink a.h untainted g1004 g271 g258 g856 g296 g4 g856 g346 g282 g1004 g4 g856 g346 g393 g69 g381 g396 g373 g258 g367 g3 g28 g282 g336 g286 g400 g3 g894 g296 g381 g396 g449 g258 g396 g282 g895 g18 g258 g367 g367 g3 g28 g282 g336 g286 g400 g18 g258 g367 g367 g882 g410 g381 g882 g90 g286 g410 g437 g396 g374 g3 g28 g282 g336 g286 g400 g90 g286 g410 g437 g396 g374 g3 g28 g282 g336 g286 g400 g1004 g271 g258 g856 g296 g4 g856 g346 g282 g393 g272 g856 g364 g856 g296 g454 g856 g364 g856 g296 g454 g856 g364 g856 g296 g272 g856 g364 g856 g296 g69 g381 g396 g373 g258 g367 g3 g28 g282 g336 g286 g400 g3 g894 g271 g258 g272 g364 g449 g258 g396 g282 g895 a f low droid non sparse ifds based taint analysis void foo a b source a.f b a.h b if z a.g a.bar z else d a.f a.bar d x new a c x x.k a sink a.f tainted sink a.h untainted g1004 g271 g258 g856 g296 g4 g856 g346 g282 class a public a static void bar p a.h kill g1004 g4 g856 g346 g393 g272 g856 g364 g856 g296 g454 g856 g364 g856 g296 b s parse droid sparse ifds based taint analysis fig.
.
comparing non sparse and sparse ifds based taint analysis by discovering tainted access paths aliases in a forward backward pass itera tively.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
g286 g374 g410 g396 g455 g286 g454 g349 g410 g1007 g855 g3 g258 g856 g296 g3 g1089 g3 g271 g1006 g855 g3 g271 g3 g1089 g3 g400 g381 g437 g396 g272 g286 g894 g895 g1008 g855 g3 g4 g856 g346 g3 g1089 g3 g271 a b g286 g374 g410 g396 g455 g286 g454 g349 g410 g1007 g855 g3 g258 g856 g296 g3 g1089 g3 g271 g1013 g855 g3 g282 g3 g1089 g3 g258 g856 g296 g1005 g1008 g855 g3 g454 g856 g364 g3 g1089 g3 g258 g1005 g1009 g855 g3 g400 g349 g374 g364 g894 g258 g856 g296 g895 b a.f g286 g374 g410 g396 g455 g286 g454 g349 g410 g1008 g855 g3 g4 g856 g346 g3 g1089 g3 g271 g1005 g1010 g855 g3 g400 g349 g374 g364 g894 g4 g856 g346 g895 g1011 g855 g3 g4 g856 g271 g258 g396 g894 g460 g895 g1005 g1004 g855 g3 g4 g856 g271 g258 g396 g894 g282 g895 c a.h g286 g374 g410 g396 g455 g286 g454 g349 g410 g1013 g855 g3 g282 g3 g1089 g3 g258 g856 g296 g1005 g1004 g855 g3 g4 g856 g271 g258 g396 g894 g282 g895 d d g286 g374 g410 g396 g455 g286 g454 g349 g410 g1005 g1007 g855 g3 g272 g3 g1089 g3 g454 g1005 g1006 g855 g3 g454 g3 g1089 g3 g374 g286 g449 g3 g4 g894 g895 g1005 g1008 g855 g3 g454 g856 g364 g3 g1089 g3 g258 e x.k g286 g374 g410 g396 g455 g286 g454 g349 g410 g1005 g1007 g855 g3 g272 g3 g1089 g3 g454 f c.k fig.
.
the scfgs built on demand by s parse droid for figure b .
algorithm figure b will propagate them sparsely only to where they are needed reducing significantly the time andmemory requirements with much fewer dots remaining now .
observation .
even if the flow function associated with an edge is not the identity function which will simply let all factspass through the edge unchanged many data flow facts willstill pass through the edge unchanged without affecting theother facts and being affected by the other facts.
in this case we can simply propagate such facts sparsely i.e.
directly to their next possible use points in the same function .
when propagating a data flow fact din the cfg g pof a function p we exploit this observation by building ondemand a sparse cfg scfg for d gp d as a sub graph ofgp and then propagate dacross its edges instead.
for taint analysis both its forward and backward passes are sparsified.
in addition all the access paths v.f1 v.f .f2.
.fn share exactly the same scfg gp v.f theorem .
sparse droid works sparsely as follows.
let us consider the first forward pass.
when bis tainted in line s parse droid buildsgfoo bin figure a which contains all the statements where bis used accessed .
according to gfoo b b should be sent to lines and first and then directly to the exit offoo .
similarly in line where a.f is tainted we build gfoo a.fin figure b by including the statements where a ora.f is used.
this allows a.f to be propagated directly to lines and .
in line we build gfoo a.hin figure c by including the statements accessing a.h and all the callsites infoo conservatively since a.h is a global variable .
in line dis tainted we build gfoo din figure d .
when line is analyzed x.k.f is tainted.
as this is a store a backward alias analysis pass is triggered.
at this point we build g foo x.kin figure e in order to propagate sparsely all access paths sharing x.k as its prefix theorem .
in line we find c.k.f to be aliased with x.k.f .a sc.k.f is new we then build gfoo c.kin figure f in order to propagate sparsely all access paths abstracted by c.k .
finally in the last forward pass c.k.f is recognized to be tainted in line .
a number of salient properties about our sparse ifds framework are summarized as follows sparsity.
while we sparsify only the intraprocedural analysis of the ifds algorithm our approach can be regardedas being full sparse.
once propagated from a callsite to acallee all the data flow facts are propagated sparsely again.
on demand scfg construction.
scfgs are built ondemand and reused later reducing the unnecessary over heads that would be otherwise incurred in a pre analysis.
multi threading.
sparsification is orthogonal to multithreading parallelization.
for example s parse droid has reduced significantly the number of edges that are concurrently processed by multiple threads in f low droid .
precision and efficiency.
by sparsifying the ifds algorithm we maintain its precision while significantly reducing its time and memory requirements despite the small timeand space overheads incurred for managing scfgs .
iii.
t hesparse ifds f ramework we describe how to sparsify the classic ifds framework in a formal setting.
section iii a reviews the classic ifdsalgorithm .
section iii b describes its sparsification.
insection iv we will revisit taint analysis as an instantiationand have the opportunities to give some illustrating examples.
a. the non sparse ifds framework in figure we reproduce the classic ifds algorithm from with a few notational changes .
there are threecases with the first two cases lines and responsible forthe interprocedural analysis and the last case line for theintraprocedural analysis.
as discussed in section ii only the intraprocedural analysis needs to be sparsified.
however for completeness we introduce briefly the entire analysis below.
an instance ip of an ifds problem is a five tuple ip g d f m intersectionsq whereg n e is the supergraph of the program dis a finite set of data flow facts f 2d 2d is a set of distributive functions m e fis a map fromg s edges to data flow functions representing typically traditional transfer functions defined in terms of gen andkill and the meet operator intersectionsqis either union or intersection depending on the problem modeled .
g known traditionally as the interprocedural cfg icfg of the program consists of a collection of cfgs g1 g2 one per function one of which gmain represents the program s main .
for a function p its cfg gpconsists of a unique start nodesp a unique exit nodeep and the remaining nodes representing its statements and predicates in the usualmanner.
however a callsite is split into two nodes a call node and a return site node.g has four types of edges.
the ordinary intraprocedural edges in an individual cfg gpare called normal edges .
for each callsite with its call node cand return site node r wherepis called three edges are included to capture its interprocedural data flows an intraproceduralcall to return edge from ctor an interprocedural call edge fromctos p and an interprocedural return edge fromeptor.
to solve ip context sensitively as a graph reachability problem g is extended into an exploded supergraph g ip n e where n n d ande authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
algorithm tabulate g ip letg ip n e 2pathedge angbracketleftsmain angbracketright angbracketleftsmain angbracketright 3worklist angbracketleftsmain angbracketright angbracketleftsmain angbracketright 4s forwardtabulateslrps forn n do 7xn d2 d d1 d s.t.
angbracketleftsfun n d1 angbracketright angbracketleftn d angbracketright pathedge function prop e ife pathedge then inserteintopathedge inserteintoworklist function forwardtabulateslrps whileworklist negationslash do pop angbracketleftsp d1 angbracketright angbracketleftn d angbracketrightfromworklist switch n casen callsites p ford3s.t.
angbracketleftn d angbracketright angbracketleftscallee n d3 angbracketright e do prop angbracketleftscallee n d3 angbracketright angbracketleftscallee n d3 angbracketright ford3s.t.
angbracketleftn d angbracketright angbracketleftretsite n d3 angbracketright e s do prop angbracketleftsp d1 angbracketright angbracketleftretsite n d3 angbracketright casen ep forc callers p do ford4 d5s.t.
angbracketleftc d angbracketright angbracketleftsp d1 angbracketright e and angbracketleftep d2 angbracketright angbracketleftretsite c d5 angbracketright e do if angbracketleftc d angbracketright angbracketleftretsite c d5 angbracketright s then insert angbracketleftc d angbracketright angbracketleftretsite c d5 angbracketrightintos ford3s.t.
angbracketleftsfun c d3 angbracketright angbracketleftc d angbracketright pathedge do prop angbracketleftsfun c d3 angbracketright angbracketleftretsite c d5 angbracketright casen np callsites p ep for angbracketleftm d angbracketrights.t.
angbracketleftn d angbracketright angbracketleftm d angbracketright e do prop angbracketleftsp d1 angbracketright angbracketleftm d angbracketright fig.
.
the ifds algorithm from with some notational changes .
angbracketleftm d angbracketright angbracketleftn d angbracketright m n e d2 m m n d1 .
note that 0signifies an empty set of facts allowing new facts to be generated at a program point and m m n fis the flow function associated with the edge m n e .
for efficiency reasons g ipis usually built from g at run time.
in figure an ip is solved with dynamic programming ino e d .
for a function p callsites p is the set of its call statements and callers p is the set of call statements inp s callers where pis invoked.
for a call statement n retsite n denotes its return side node and callee n the function invoked.
for a node n n fun n identifies its containing function.
finally ssummarizes the interprocedural data flow facts obtained across the function boundaries.
pathedge records the set of path edges with each angbracketleftsp d1 angbracketright angbracketleftn d angbracketrightrepresenting the suffix of a realizable path from angbracketleftsmain angbracketrightto angbracketleftn d angbracketright implying that the path edge from angbracketleftsmain angbracketrightto angbracketleftsp d1 angbracketrightis realizable.
starting with angbracketleftsmain angbracketright angbracketleftsmain angbracketright line s2 forwardtabulateslrps collects all possible path edges in pathedge line with a case analysis by handling the interprocedural data flows entering a function lines the interproceduraldata flows leaving a function lines and theintraprocedural data flows within a function lines .finally a data flow fact d dexists at a program pointfunction forwardtabulateslrps whileworklist negationslash do switch ndo casen callsites p do ford3s.t.
angbracketleftn d angbracketright angbracketleftretsite n d3 angbracketright e s do 17a ifg p d3is not constructed yet i.e.
not in the scfg cache then 17b buildg p d3 n p d e p d according to 17c for angbracketleftn d angbracketright angbracketleftm prime d3 angbracketright e p d3do 17d prop angbracketleftsp d1 angbracketright angbracketleftm prime d3 angbracketright casen epdo casen np callsites p ep do for angbracketleft d3 angbracketrights.t.
angbracketleftn d angbracketright angbracketleft d3 angbracketright e do 27a ifg p d3is not constructed yet i.e.
not in the scfg cache then 27b buildg p d3 n p d e p d according to 27c for angbracketleftn d angbracketright angbracketleftm prime d3 angbracketright e p d3do 27d prop angbracketleftsp d1 angbracketright angbracketleftm prime d3 angbracketright fig.
.
the sparse ifds algorithm adapted from figure with its line line replaced by lines 17a 17d lines 27a 27d .
id s.s a s. a f s.ifb sthens a elses a z s. a b a b0 a b a b0 a b c a b c0 a b a b fig.
.
edge specific flow functions illustrated with the first two from .
n n iff there exists a realizable path in g ipfrom node angbracketleftsmain angbracketrightto node angbracketleftn d angbracketright line s6 .
for our taint analysis problem ip g d f m intersectionsq figure a gives its exploded supergraph.
as explained insection ii dis the set of access paths intersectionsqis andfandm were discussed earlier but will be formalized in section iv.
b. sparsification as the ifds algorithm in figure spends the majority of its analysis time on propagating data flow facts intraprocedurally it suffices to sparsify its intraprocedural analysis only.
oursparse algorithm which is given in figure is conceptuallysimple and easy to implement as well as both time and spaceefficient.
let us describe our sparsification below.
consider any ifds problem ip g d f m intersectionsq .
according to observation even if the flow function m m n 2d mapsto 2dis not the identity function many data flow facts x dare propagated through m n unchanged without affecting the other facts and being affected by the other facts.our key insight is to propagate such facts in xsparsely i.e.
directly to their next possible use points in the same function thereby reducing both time and space requirements overall.
figure illustrates a few edge specific flow functions which can be understood as traditional transfer functions composed using gen and kill .
here idis the identity function agenerates a new fact abut kills everything else in s fgenerates kills aifb s b s and zkills everything ins.i fm m n id we can avoid propagating all the facts authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
along m n by sending them directly to their next use points.
however even if m m n negationslash id such sparse propagations are still possible for some facts as motivated in figure .
toachieve this we introduce fact specific identity functions.
letf f d mapsto 2dbe a flow function associated with edge m n .
letd dbe a fact.
we say that fis ad specific identity function denoted f fd if the following holds x 2d d x d f x x 2d d f x d f x d d for any fact darriving at m dwill emerge at nwithout being affected by the other facts by the first condition and ddoes not affect the other facts reaching nby the second condition.
let us re examine each flow function associated with an edge m n e in figure .
as idis an identity function by itself idis ad specific identity function for any d.f o r a w eh a v e a aa asathat reaches mis regenerated and propagated to n b u t a negationslash ab asbis killed .
for f i ti sn o t hard to see that f negationslash fa f negationslash fbbut f fc.
finally zis not a d specific identity function for any d as all facts are killed .
for a call statement n there is a unique intraprocedural edge from nto its return site node retsite n .
whether m n retsite n is ad specific identity function where d d depends on the underlying ifds problem as will be discussed in section iv.
conservatively we can always assumem n retsite n negationslash m n retsite n dfor every d d. givend d we are motivated to propagate dsparsely across a cfg.
let gp np ep be the cfg of a function ping .
letg p n p e p be the exploded cfg of gpingip.
we will propagate din a sparse cfg scfg gp d np d ep d as a subgraph of gp.
to construct gp d we construct below its exploded version g p d n p d e p d as a subgraph of g p .
in practice gp dis actually built first and then exploded into g p d. for convenience we assume the existence of a pseudo start exit node s prime p e prime p i ng p such thatm s prime p sp negationslash m s prime p sp dandm ep e prime p negationslash m ep e prime p d. letpd p n1 nk def n0 n1 nk nk be a sparsifiable path ing p wherek greaterorequalslant2 such that m n0 n1 negationslash m n0 n1 d m ni ni m ni ni d where lessorequalslant i k and m nk nk negationslash m nk nk d. starting at n1 we will send ddirectly to nkby skipping these intermediate edges.
the scfg gd p n p d e p d is defined as follows e p d m d n d prime e p m m n negationslash m m n d m d n d pd p m n is sparsifiable n p d uniontext m d n d prime e p d m d n d prime for our motivating example we examined a few scfgs in figure and will discuss them in more detail in section iv.
frequently many facts share the same scfg as motivated in section ii and discussed further in section iv .
if gp d1 gp d2 then the same scfg is shared by d1andd2.
we can now understand our sparse algorithm given in figure easily.
for reasons of symmetry it suffices to explainits lines 27a 27d.
whenever the non sparse ifds algorithm g90 g286 g410 g437 g396 g374 g3 g4 g367 g349 g258 g400 g3 g47 g374 g296 g381 g396 g373 g258 g410 g349 g381 g374 g90 g286 g395 g437 g286 g400 g410 g3 g4 g367 g349 g258 g400 g3 g47 g374 g296 g381 g396 g373 g258 g410 g349 g381 g374 g94 g18 g38 g39 g24 g258 g410 g258 g882 g38 g367 g381 g449 g3 g38 g258 g272 g410 g400 g47 g18 g38 g39 g62 g286 g258 g364 g400 fig.
.
the workflow of s parse droid .
is just about to propagate a fact d3at nodemdensely line of figure our sparse algorithm propagates d3on its own scfgg p d3 built on the fly but reused subsequently sparsely.
theorem correctness .the sparse algorithm figure computes the same results as the non sparse one figure .
proof sketch.
follows from the fact that every data flow fact d3is now propagated sparsely in g p d3 figure rather than densely in g p figure by skipping only the statements that are irrelevant as far as d3is concerned by .
iv .
t hesparse taint analysis we describe an instantiation of our sparse algorithm for finding tainted accesses in android apps.
figure depicts sparse droid our sparse version of f low droid .
we reuse f low droid s modules taint analysis and alias analysis for discovering tainted accesses and aliases in the forward and backward passes respectively section ii .
the three modules with the light gray background are added byus to support sparse analysis.
the sparse ifds solver implements our sparse ifds algorithm figure which ismulti threaded exactly as in f low droid .
the sparse cfg cache manages all the scfgs constructed so far while the build scfgs module constructs an scfg for a data flowfact on the fly if it not cached yet according to .
for the ifds based taint analysis let us revisit its five tuple ip g d f m intersectionsq .
in figure g is the icfg i.e.
supergraph provided to the analysis.
note that dis the set of access paths and intersectionsqis .
in section ii we discussed informally the flow functions in fthat are mapped to the edges in g bym.
in this section we will define what mis precisely.
section iv a introduces the intermediate representation ir used.
section iv b formalizes the flow functions used for taint analysis.
section iv c discusses scfg construction.
a. intermediate representation table i gives eight kinds of statements used in our ir.
by convention x defx0 xn 1is a possibly empty list of elements.
to handle both virtual and static callsuniformly a virtual call a .foo a1 an is written as foo a0 an and a static call t.foo a0 an is written as foo a0 ... a n by dropping the irrelevant t. all local variables are assumed to be in ssa form resulting in the phi instruction being used as is standard.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a source a. a source v. f v negationslash a v. f a ... v. f v a a new t v. f v negationslash a v. f a b v. f v b v. f a. f a b v. f v a b v. f a2 a0 a1 v. f v a0 a1 v. f a .
f a2 a0 a1 v. f v a0 a1 a2 v. f a .f prime b t v. f v car f f prime v. f a. cdr f a .f prime b t v. f v negationslash a v negationslash car f negationslash f prime v. f .f prime b a t v. f v b v. f .f prime.
f .f prime b a t v. f v car f f prime .f prime b a t v. f v negationslash b v negationslash car f negationslash f prime v. f r foo a v. f v aiai apiisai primescorresponding formal parameter in foo pi.
f r foo a v. f v a r foo a t. f t. f r foo a v. f v a v t r foo a v. f v a r v negationslash t v. f retfoor v. f v pi piisfoo s formal parameter aiispi primescorresponding actual argument ai.
f retfoor0 v. f v r0 r1 foo a callers foo r1.
f retfoor t. f t. f fig.
.
the flow functions for taint analysis operating on the ir given in table i with the alias analysis performed orthogonally as illustrated in figure .
table i intermedia te representa tion for taint analysis .
name instruction name instruction source a source phi a2 a0 a1 new a new t assign a b loada b.fstorea.f b a t.f t.f b call r foo a return return pr b. flow functions figure gives all the flow functions used for taint analysis in our ir.
in the ifds framework a flow function f 2d mapsto 2d wheredis the set of access paths distributes over the meet operator intersectionsq f x intersectionsqx xf x .
given a flow function fassociated with a control flow edge from a statement sat a source node to a statement s primeat a target node in the cfg a rule for smaps the singleton fact set x on entry of stof x on entry of s prime.
ifxis tainted then f x contains all the tainted facts by s. for a non source statement f 0is omitted.
for a list x car x and cdr x return the first and the rest of the list respectively.
to simplifythe presentation of our rules v. fdenotes an access path i.e.
a local variable vor a field access v.f1.
.fn wheren greaterorequalslant1andt.fdenotes an access path t.f .
.fn wheren greaterorequalslant1.
the rules for handling non call statements are simple.
at a tainted source a source a. signifies that aand all its associated access paths are tainted.
in and ifv.f v. then car f primeis assumed to hold always and a.cdr a. .
now consider the three rules for handling a call statement and .
there are two cases in handling r foo a .
a fact that is a static variable t.f is propagated to its entry and then its exit if it remains tainted at the end .
a fact that is an instancevariable v.f is handled in the same way if vis one of foo s arguments and propagated to the call s return node otherwise.
c. scfg construction as motivated in section ii we will construct an scfg g p d on demand for every new fact dgenerated when a function p is analyzed.
our sparse ifds algorithm given in figure willthen operate on g p d which is exploded from gp daccording to during the sparse analysis section iii b .
for a given ifds problem many facts may have identical scfgs.
for taint analysis we rely on the following theorem.
theorem .
let .f1.
.fnbe an access path where a t .
thengp .f gp .f fi wherepis any function.
proof.
follows from figure as all the field accesses in the ir are limited to only a single field as shown in table i .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
therefore we only need to build scfgs for three types of data flow facts a local variable v a field access v.f and a global variable t.f.
letgp np ep be the cfg of a function p. to build these scfgs according to it is just a simple matter of going through the flow functions m m n for all the edges m n eand checking to see if each is a fact specific identity function or not by gp v.m m n negationslash m m n viffvappears in the statement at nodem.
in this case gp vconsists of all the nodes in gp wherevis referred to figures a and d .
gp v.f .m m n negationslash m m n v.fiff the statement at m refers tovalone without a field access or v.f.
thus gp v.f consists of all such nodes in gp figures b e and f .
gp t.f .m m n negationslash m m n t.fiff the statement at maccessest.f or is a callsite as t.f may be killed indirectly .
thus gp t.f consists of all such nodes in gp figure c .
finally there is one f low droid specific implementation detail concerning when to activate aliases as being tainted.
consider figure again.
during a forward analysis x.k.f is found to be tainted by x .
k a in line .
then a backward pass is started to search for its aliases.
in line c.k.f is found as an alias.
in a subsequent forward pass c.k.f is propagated forward and recognized as being tainted after ithas passed x .
k a its so called activation statement .
in s parse droid we propagate c.k.f ingfoo c.kshown in figure rather than gfoo.
if its activation statement x.k a does not appear in gfoo c.k which is true in this case we can simply activate c.k.f in the first nodes in gfoo c.kthat are reachable from this activation statement in gfoo along its outgoing paths .
the exit in gfoo c.k andgfoo satisfies this condition.
note that by construction c.k.f will simply be propagated through lines and before reaching the exit.
v. e v alua tion we demonstrate the significant performance benefits achieved by our sparse ifds algorithm by comparing s parse droid and f low droid for solving taint analysis in android apps as a major application.
our sparse analysis is fairly gen eral.
other possible applications include pointer analysis typestate analysis uninitialized variables constantpropagation and android compatibility detection .
for the taint analysis problem as motivated in figure f low droid relies on the traditional non sparse ifds algorithm figure while s parse droid takes advantage of our sparse ifds algorithm figure .
by theorem s parse droid is equivalent to f low droid in terms of their precision i.e.
leak finding capability except that s parse droid is sparse.
we have validated the correctness of s parse droid by extensive benchmarking.
in the case of d roid bench containing small unit tests with each consisting of dozens oflines of code for example s parse droid has successfully passed all the test cases that f low droid has passed with a caveat on implicit data flows discussed in section vi .
we will therefore focus on evaluating the performance advantages of s parse droid over f low droid by using relatively large android benchmarks and real world android apps.our evaluation as described below will attempt to address the following four research questions rq1.
is s parse droid faster?
rq2.
is s parse droid more memory efficient?
rq3.
is the sparse ifds algorithm effective?
rq4.
is the on demand scfg construction effective?
a. experimental setup a implementation for f low droid we use its latest version 0967ca2 implemented in soot .
s parse droid is a sparse version figure .
given an app its dalvik bytecode is converted into soot s shimple ir in ssa form operated on by both tools.
in f low droid all access paths are abstracted with k limiting with k by default .
we also use its source and sink definitions for taint analysis.
b benchmarks we have selected android apps with from fossdroid an alternate web interface for thef droid repository and from google play.
from foss droid we pick randomly apps from the top most popularapps in each of its categories.
note that graphics has apps in total.
from google play we obtain pokemongo a game app word a microsoft word app outlook a microsoft outlook app reader an adobe acrobat reader bk a burger king app and oeffi a journey planner .
c platform our experiments are done on an intel xeon e5 v4 cpus .20ghz server with 256gb ram running ubuntu .
.
lts xenial xerus .
for jvm we set the maximum heap size as 220gb with xmx .
for both tools we turn on mergedexfiles to enable analyzing multiple dex files for an app and use the dt option to set hours as the per app time budget for their ifds solvers.
asour platform has cores threads are used to process all thepath edges in worklist in figures and .
d results table ii contains the results for f low droid fd and s parse droid sd .
the analysis time of an app is the average of runs.
as indicated in its caption f low droid terminates prematurely in apps with running out of timeand running out of memory .
however s parse droid has successfully run every app to completion within the timeand memory budgets given.
for each app columns we compare their analysis times columns for rq1 memory usage columns for rq2 and pathedges solved columns for rq3.
finally we examine scfgconstruction columns for rq4.
b. rq1 speedups as shown in columns of table ii s parse droid is significantly faster than f low droid with the speedups ranging from .1x to .3x averaged to .0x.
so s parse droid outperforms f low droid in every single app evaluated.
the largest speedup .3x occurs on nya.miku.
wishmaster for which f low droid spends .
seconds to analyze it while s parse droid spends only .
seconds.
for org.gateshipone.odyssey exhibiting the second largest speedup .0x f low droid terminates prematurely authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table ii performance of flow droid fd and sparse droid sd .
f low droid runs out of time in three apps with their analysis times indica ted in blue incolumn 5and out of memory in six apps with their memory usage marked with oom incolumn .
category app v ersion apk mb analysis time s memory usage gb pathedges scfg construction fd sd fd sd fd sd fd sd fd sd fd sd scfgs acc paths time sd time fd connectivitybe.mygod.vpnhotspot .
.
.
.
.
.
.
.
.
.
.
.
ca.cmetcalfe.locationshare .
.
.
.
.
.
oom .
.
.
.
developmentorg.csploit.android .
.
.
.
.
.
.
.
.
.
.
.
de.k3b.android.contentproviderhelper .
.
.
.
.
.
.
.
.
.
.
.
.
gamescom.ghstudios.android.mhgendatabase .
.
.
.
.
.
.
.
.
.
.
.
net.ddns.mlsoftlaberge.trycorder .
.
.
.
.
.
.
.
.
.
.
.
graphicsrodrigodavy.com.github.pixelartist .
.
.
.
.
.
.
.
.
.
.
uk.co.richyhbm.monochromatic .
.
.
.
.
.
.
.
.
.
.
.
internetnya.miku.wishmaster .
.
.
.
.
.
.
.
.
.
.
.
acr.browser.lightning .
.
.
.
.
.
.
.
.
.
.
.
moneyorg.totschnig.myexpenses .
.
.
.
.
.
.
.
.
.
.
.
.
com.igisw.openmoneybox .
.
.
.
.
.
.
.
.
.
.
.
.
multimediacom.poupa.vinylmusicplayer .
.
.
.
.
.
.
.
.
.
.
.
org.gateshipone.odyssey .
.
.
.
.
.
oom .
.
.
.
navigationcom.ilm.sandwich .
.4f .
.
.
.
.
.
.
.
.
.
com.vonglasow.michael.satstat .
.
.
.
.
.
.
.
.
.
.
phone smsopencontacts.open.com.opencontacts .
.
.
.
.
.
.
.
.
.
com.github.yeriomin.dumbphoneassistant .
.
.
.
.
.
.
.
.
.
.
readingnightlock.peppercarrot .
.
.
.
.
.
.
.
.
.
.
.
org.decsync.sparss.floss .
.
.
.
.
.
oom .
.
.
.
sci educom.ichi2.anki .
.
.
.
.
.
.
.
.
.
.
.
com.luk.timetable2 .
.
.
.
.
.
.
.
.
.
.
.
securitycom.kunzisoft.keepass.libre .
.
.0beta18 .
.
.
.
.
.
.
.
.
.
eu.faircode.netguard .
.
.
.
.
oom .
.
.
.
sports healthorg.openpetfoodfacts.scanner .
.
.
.
.
.
.
.
.
.
.
.
org.secuso.privacyfriendlyactivitytracker .
.
.
.
.
.
.
.
.
.
.
.
systemdk.jens.backup .
.
universal .
.
.
.
.
.
.
.
.
.
com.github.axet.callrecorder .
.
.
.
.
.
.
.
.
.
.
.
themingorg.materialos.icons .
.
.
.
.
.
.
.
.
.
.
org.adw.launcher .
.
.
.
.
.
.
.
.
.
.
.
timename.myigel.fahrplan.eh17 .
.
.
.
.
.
.
.
.
.
.
.
com.app.zensuren .
.
.
.
.
.
.
.
.
.
.
writingcom.orgzly .
.
.
.
.
oom .
.
.
.
org.secuso.privacyfriendlytodolist .
.
.
.
.
.
.
.
.
.
.
googleplaycom.nianticlabs.pokemongo .
.
.
.
.
.
.
.
.
.
.
.
com.microsoft.office.word .
.
.
.
.
.
.
.
.
.
.
.
.
com.microsoft.office.outlook .
.
.
.
.
.
.
.
.
.
.
.
com.adobe.reader .
.
.
.
.
.
.
.
.
.
.
.
.
com.emn8.mobilem8.nativeapp.bk .
.
.
.
.
.
oom .
.
.
.
de.schildbach.oeffi .
.
google .
.
.
.
.
.
.
.
.
.
after .
seconds after running out of memory s parse droid takes only .
seconds to run it to completion.
for opencontacts.open.com.opencontacts with the smallest speedup .1x com.ghstudios.android.
mhgendatabase .3x com.luk.timetable2 .3x and net.ddns.mlsoftlaberge.trycorder .4x the performance benefits from our sparse analysis are small.these apps can be analyzed by both tools within .
seconds.
for org.openpetfoodfacts.scanner com.nianticlabs.pokemongo andcom.microsoft.office.outlook flow droid times out for a hour time budget given but sparse droid has finished analyzing these three apps in .
mins .
mins and .
mins respectively.
c. rq2 memory requirements as shown in columns of table ii also plotted in figure f low droid consumes more memory than sparse droid for all the apps except for the five marked inbold font in column discussed below in particular flow droid runs out of memory for the six apps marked with oom in column .
in contrast s parse droid can finish analyzing all the apps by consuming a maximum of .2gbmemory.
for each app we consider the maximum amount ofmemory used.
this is calculated by using java runtime apis.
with the six oom apps excluded the memory usage ratios of f low droid over s parse droid range from .5x com.ichi2.anki to .2x com.vonglasow.
michael.satstat with an average of .7x.
let us examine the five apps for which s parse droid uses more memory than f low droid .f o r de.k3b.android.
contentproviderhelper com.ilm.sandwich andopencontacts.open.com.opencontacts the extra amount of memory used is small.
in each case the total amountof memory used by s parse droid is below .5gb.
for com.ichi2.anki andcom.github.axet.callrecorder sparse droid uses about twice memory as f low droid due to the extra space taken by the scfg cache used.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
39avg050100150200oom oom oom oom oom oommemory gb flowdroid sparsedr oid fig.
.
memory usage of f low droid and s parse droid for the apps.
d. rq3 effectiveness of sparse analysis as discussed in sections v b and v c s parse droid is significantly faster and more memory efficient than f low droid .
the key reason is that f low droid which uses the traditional ifds algorithm in figure solves a significantly larger number of path edges pathedges than s parse droid which uses a sparse version in figure for an app as shown in columns of table ii.
the ratios of flow droid s pathedges over s parse droid s pathedges range from .6x to .5x with an average of .5x.
as motivated in figure solving an ifds problem sparsely cuts down substantially both the time and memory required.
in each ifds algorithm worklist contains all the path edges for an app to be solved by its ifds solver.
figure shows thatflow droid primes non sparse ifds solver time sparse droid primes sparse ifds solver timecorrelates well positively withflow droid primes pathedges sparse droid primes pathedgesacross the apps with both axes drawn in the log2scale.
the three blue s represent the three apps for which f low droid runs out of time and the six red s represent the six apps for which f low droid runs out of memory.
the two blue s org.openpetfoodfacts.scanner andcom.nianticlabs.pokemongo deviate slightly from the projected trend yielding better than expected speedups table ii possibly dueto excessive system resources consumed by f low droid .
note that there is no correlation between the speedup of sparse droid over f low droid achieved for an android app with its bytecode size.
this is as expected since the effectiveness of s parse droid depends on the tainted sources present in the app and their data dependent statements tracked figure with aliases considered which are all accurately reflected by the percentage of pathedges reduced figure .
when used as a vetting tool s parse droid can analyze all the apps in seconds .
hours by issuing leakwarnings.
by analyzing these apps lexicographically for thesame time period f low droid can only analyze apps by issuing only leak warnings even if the nine apps for which flow droid runs out of either time or memory are ignored.
e. rq4 on demand scfg construction as a sparse version of f low droid s parse droid performs its taint analysis on demand by detecting the leaks froma set of specified sources to a set of specified sinks in an app.
as such our on demand scfg construction has turned outto be effective by building the scfgs for only the access paths encountered figure as shown in columns oftable ii.
for each app scfgs gives the number of scfgsbuilt and acc paths gives the number of access paths seen i.e.
the number of scfgs that would have been built iftheorem were not applied .
in addition time sd and time fd give the percentages of the scfg contructiontime over the total analysis times spent by s parse droid and flow droid respectively plotted in figure graphically .
certainly scfg construction incurs overheads ranging from .
to .
with an average of .
over s parse droid s analysis time but only from .
to .
with an average of .
over f low droid s analysis time.
as highlighted in bold font in the last column of table ii out of the six apps with double digit percentage overheads relativeto f low droid com.app.zensuren is the only one taking over second for f low droid to analyze.
in this case despite .
seconds taken in building scfgs s parse droid has reduced f low droid s analysis time from seconds to .
seconds achieving still a speedup of .7x.
overall theoverheads incurred in scfg construction are significantly more than offset by the performance benefits reaped.
vi.
l imita tions this work can be further improved in a number of directions.
first just like the traditional ifds algorithm our sparse ifds algorithm figure is applicable only tothe ifds data flow problems.
second by making f low droid sparse our tool s parse droid figure is also limited to detecting only the information leaks caused by explicit data flows via data dependent assignments .
howto track the sensitive information flowing implicitly throughcontrol dependent assignments i.e.
if h then l true else l false is beyond the scope of this paper.
third on demand scfg construction may introduce performance penalties for small cfgs.
however by applying this to all the cfgs in an app the performancebenefit seems to significantly more than offset the overheadsincurred.
finally the findings reported in this paper may bedependent on the set of android apps selected.
vii.
rela ted work ifds data flow analyses are widely used in software testing program verification program understanding and maintenance and compiler optimization.
reps et al.
initially introduced an efficient framework for solving the ifds problems andsubsequently generalized it to the ide framework forinterprocedural distributed environment problems where thedataflow facts are maps environments from some finite set of symbols to some possibly infinite set of values.
later naeem et al.
give several extensions makingit applicable to a wider class of interprocedural data flowproblems and also introduced a concurrent alternative im plemented based on scala s actor framework.
w ala contains a memory efficient bit vector based ifds algorithm.
recently bodden has provided a generic multi threaded authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
6hqr.
qb b lqm at b2 a6.a bqhp2 f at b2.
qb b at b2 a6.a aqhp2 u log2v6hqr.
qb b os i?
2b f at b2.
qb b os i?
2b u log2v fig.
.
correlating pathedges with their solving time in an ifds framework.
39avg010203040506070scfg construction flowdroid scfg construction sparsedroid fig.
.
percentage of the time spent by s parse droid on building scfgs on demand over the total analysis time by each tool for an app.
implementation of a generic ifds ide solver in soot .
while the prior work takes advantage of multi threading to accelerate ifds analyses this work exploits theirsparsity to improve their performance in an orthogonal way.
sparse analysis has also been successfully applied in pointer analysis.
hardekopf et al.
speed up flow sensitive pointeranalysis for c by employing a sparse data flow graph ratherthan a dense control flow graph initially for top level variables and then for also address taken variables .
sui etal.
detect memory leaks in c programs by using a sparsevalue flow graph that captures def use chains and value flowsvia assignments for all memory locations represented by bothtop level and address taken variables and also performdemand driven flow and context sensitive pointer analysis for c programs sparsely .
unlike these earlier efforts focussing on standard pointer analysis algorithms this paperrepresents the first work for sparsifying the ifds algorithm by constructing sparse cfgs on demand instead of during a pre analysis in order to boost its performance significantly.
recently synchronized pushdown systems are investigated as an alternative to the traditional storeless k limited access path model for supporting pointer and data flow analysis .their pushdown systems contain many redundant rules which can be sparsified similarly to achieve performance gains.
taint analysis is a form of data flow analysis aiming at secure information flow.
given android s popularity manytaint analysis tools exist including amandroid didfail droidsafe evotaint f low droid and iccta among which f low droid remains to be a stateof the art static taint analysis tool .
however f low droid with its taint analysis performed in an ifds ide framework is still compute and memory intensive .
by sparsifying the traditional ifds algorithm used theperformance of f low droid has been significantly improved.
viii.
conclusion we have introduced a sparse analysis to scale the ifds algorithm significantly by reducing its time and memoryrequirements.
we have demonstrated that our sparse ifdsalgorithm can improve substantially the scalability of taint analysis one of the most important interprocedural data flow analyses on a range of android apps.
by constructing sparsecfgs on the fly for the data flow facts propagated in boththe forward taint analysis and backward alias analysis phasesin the sparse ifds framework we have observed significantperformance improvements.
in future work we plan to furtherreduce memory space consumed by taint analysis.
we will alsoapply our sparse ifds algorithm to other data flow analyses.
a cknowledgement we would like to thank all the reviewers for their valuable inputs.
this work is supported by the national key r dprogram of china no.
2016yfb1000201 the innovation re search group of national natural science foundation of china no.
the national natural science foundation of china u1736028 and and australian research council grants dp170103956 and dp180104069 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.