p3 partitioned path profiling mohammed afraz indian institute of science indiadiptikalyan saha ibm research indiaaditya kanade indian institute of science india abstract acyclic path profile is an abstraction of dynamic controlflow paths of procedures and has been found to be useful in a wide spectrum of activities.
unfortunately the runtime overhead of obtaining such a profile can be high limiting its use in practice.
in this paper we presentpartitioned path profiling p3 which runskcopies of the programin parallel each with the same input but on a separate core and collects the profile only for asubsetof intra procedural paths in each copy thereby distributing the overhead of profiling.
p3 identifies profitable procedures and assigns disjoint subsets of paths of a profitable procedure to different copies for profiling.
to obtain exact execution frequencies of a subset of paths we design a new algorithm called pspp.
all paths of an unprofitable procedure are assigned to the same copy.
p3 uses the classic ball larus algorithm for profiling unprofitable procedures.
further p3 attempts to evenly distribute the profiling overhead across the copies.
to the best of our knowledge p3 is thefirst algorithm for parallel path profiling.
we have applied p3 to profile several programs in the spec benchmark.
compared to sequential profiling p3 substantially reduced the runtime overhead on these programs averaged across all benchmarks.
the reduction was23 and56 on average for and cores respectively.
p3 also performed better than a coarse grained approach that treats all procedures as unprofitable and distributes them across available cores.
for cores the profiling overhead of p3 was on average5 less compared to the coarsegrained approach across these programs.
for and cores it was respectively18 and25 less.
categories and subject descriptors d. .
diagnostics f. .
semantics of programming languages program analysis general terms algorithms performance keywords parallel distributed path profiling divide and conquer1.
introduction collecting execution frequencies of dynamic controlflow paths of procedures reveals a wealth of information about the runtime behavior and usage patterns of a program.
acyclic path profile is an abstraction of dynamic controlflow paths of procedures and gives execution frequencies of acyclic paths in a procedure.
acyclic path profile has been found to be a useful measure in a wide spectrum of activities ranging from compiler optimizations to testing debugging and maintenance .
unfortunately the runtime overhead of obtaining such a profile can be high limiting its use in practice.
for example vaswani et al.
reported an average runtime overhead of50 with worst case overhead of132 .
other studies e.g.
also report similar overheads.
we believe that with the prevalence of multi core systems and computing clusters parallelizing acyclic path profiling has become an attractive option to reduce profiling overhead.
surprisingly to date there is no algorithm that exploits parallelism for path profiling.
in this paper we present such an algorithm.
we propose to runkcopiesof the programin parallel each with the same input but on a separate core or cluster node and collect the profile only for asubsetof intra procedural paths in each copy thereby distributing the overhead of profiling.
a straightforward approach to achieve this is to use the classic ball larus algorithm to instrument only a subset of procedures in each copy in a way that every procedure is profiled in exactly one copy.
we call this approachparallel ball larus profiling pbl in contrast to sequential ball larus profiling sbl which profiles all the procedures in one copy.
in practice the number of acyclic paths may differ widely across procedures and consequently also the profiling overheads.
for example consider a programmwith three proceduresp qandr requiring100 10and5instrumentation probes to profile all their paths respectively.
an instrumentationprobeis a statement added by a profiling algorithm to a procedure to track the path ids and their execution frequencies.
the number of probes gives a static estimate of the runtime overhead of profiling.
if3cores are available pbl may assign one procedure to each copy core .
the copy profiling the procedurepis likely to be much slower than the others.
the benefit of parallelization is limited by the speedup of theslowestcopy.
thus pbl may fail to exploit parallelism to the fullest.
we therefore propose a novel approach which attempts to get a more uniform distribution of profiling overhead by sub dividing the job of profiling all paths of a procedure into sub jobs of profiling disjoint subsets of paths of the procedure.
the subsets are assigned to different staticinstancesof a procedure which are then distributed across multiple copies.
for example our approach may obtain three instances sayp p2andp of the procedurepabove and assign them to separate copies.
the subsets of paths of a propermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august september bergamo italy c acm.
... .
485cedure are constructed so that they form a partition.
hence we call our approachpartitioned path profiling p3 .
p3 essentially provides more opportunity for load balancing across cores by constructing smaller jobs from bigger jobs.
there are three key challenges that p3 needs to overcome which procedures to select for partitioning and how to partition their paths how to instrument an instance of a partitioned procedure so as to obtain exact execution frequencies of the paths profiled in it and how to distribute the instrumented procedures to achieve good load balancing.
we observe that even if the subsets of paths being profiled are disjoint across two instances of a procedure some instrumentation probes may getduplicatedbetween them see section .
for an example .
we consider profiling of sequential programs.
therefore once wefix an input all copies of the program follow the same dynamic controlflow path and hence the duplicated probes along that path get executed in multiple copies.
in general a path which is not profiled in an instancep imay still go through some probes inp i. thus on one hand we reduce the number of instrumentation probes per instance.
whereas on the other hand we may increase the runtime overhead due to the possibilities mentioned above.
p3 therefore only selectively partitions procedures by identifying what we call asprofitable procedures.
the profitable procedures and the partitioning of their paths are identified by a static analysis that uses both intra procedural and inter procedural controlflow information.
this addresses thefirst challenge.
we now consider the second challenge.
an existing approach selective path profiling spp has been proposed to profile only asubsetof pathss.
we could have used spp on each instance of a profitable procedure to profile the subset of paths assigned to it.
unfortunately we noticed that spp can assign thesamepath id to a pathp sand a pathp s see section .
for an example .
this means that it can over approximate the execution frequencies of paths in particular by counting the execution frequencies ofp as those ofp.
we therefore design a new algorithm calledprecise selective path profiling pspp which overcomes this issue in spp and use it in p3 for instrumenting the instances of a profitable procedure.
the immediate benefit of pspp is that we can obtain the overall profile of a profitable procedure by merely collating the partial profiles obtained from its instances.
for unprofitable procedures we use the ball larus algorithm.
thus the exact acyclic path profiles of all procedures can be obtained.
finally towards addressing the third challenge p3 uses the number of instrumentation probes as a cost measure and distributes the instrumented procedures to different copies.
the optimal distribution in this setting is an np complete problem .
p3 therefore uses a round robin approach that produces a4 3th approximation of the optimal distribution .
if multiple instances of a profitable procedure are assigned to the same copy p3 takes the union of the sets of paths being profiled in them and instruments a single instance for all the paths in the union.
our approach differs from the existing approaches that attempt to lower the profiling overhead.
some approaches attempt to reduce the memory overhead whereas others attempt to reduce the runtime overhead by focusing on a subset of paths that are relevant in specific contexts .
in contrast our goal is to reduce runtime overhead while profilingallpaths.
our approach is also applicable if only a subset of paths is of interest but we donotmake this assumption about the usage scenario to speed up profiling.
we have implemented the pspp and p3 algorithms for sequential c c programs and applied them to profile several programs in the spec benchmark .
compared to sbl p3 substantially reduced the runtime overhead on these programs averaged2 exitv0entry v1 v2 v3v4 v5 v6 v7 v8 v9 v10 v11v12 v13 v14 v15 v16 v17 v18 v19v20 v21892 exitv0entry v1 v2 v3v4 v5v6 v7 v8 v9 v10 v11v12 v13 v14 v15 v16 v17 v18 v19 v20 v21 a p a b p b figure a partition p a pb of a procedurep across multiple inputs.
the reduction was23 and56 on average across these programs for and cores respectively.
the profiling overhead for an input is taken to be the maximum of the number of times instrumentation probes are executed on the same input across the individual copies.
it is essentially the overhead incurred by the slowest copy.
p3 also performed better than pbl.
we used the round robin approach of distribution for both p3 and pbl.
for cores the profiling overhead of p3 was on average5 less compared to pbl across these programs.
for and cores it was respectively18 and25 less.
we summarize the main contributions of our work as follows we present p3 an algorithm for efficient parallelization of path profiling.
to the best of our knowledge this is thefirst algorithm for parallel path profiling.
we present pspp an algorithm to obtainexactexecution frequencies of a subset of paths of a procedure which is used in p3.
pspp on its own can be used in applications such as residual testing .
we have implemented p3 and show its effectiveness compared to the sequential and parallel ball larus profiling on several spec benchmark programs for2 4and8cores.
.
overview wefirst present the definitions used in the paper and some background.
we then illustrate the key steps of p3 through examples.
.
definitions and background consider a directed acyclic graph dag gwhich represents all acyclic intra procedural paths of a procedurep.
we refer the reader to on how such a dag is constructed from the control flow graph of a procedure.
formally g v e entry exit wherevis afinite set of vertices representing basic blocks ofp the set of edgese v vapproximates the controlflow between the respective basic blocks andentryandexitare respectively the unique entry and exit vertices ofg.
for example figure a shows a dag for some procedure.
for a vertexv v the set of successors is given bysucc v w v v w e .
given apathping edges p gives the set of edges inp.
for a pathppassing through a vertexv suff p v denotes the suffix ofpstarting withv.
we usen vto denote the number of paths passing throughv.
alabeling functionlassociates a natural number called anedge label to each edge ing.
thepath idof a path pis the sum of edge labels of edges inedges p and is denoted bypathid p .
as a convention zero valued edge labels are not 4860v0 v1 v2nv1 nv1 n v2 v3 figure ball larus labeling shown.
the path id ofp entry .
.
.
v v6 v7 v9 .
.
.
exit is10.
a profiling algorithm assigns edge labels and instruments the edges to compute the path id at runtime.
thus each edge with a non zero label is instrumented with a statement called an instrumentationprobe.
for a procedurep overhead p is the total number of non zero edges in the dag ofpand is taken as an estimate of the runtime overhead of profilingp.
under the labeling shown in figure a the overhead for that procedure is6.
for a procedurep if there are multiple instances used for profiling a partition of its paths we denote the set of paths being profiled in an instancep ibyinteresting p i .
we call a labeling functionl ifor an instancep i a valid labeling if every pathp interesting p i has a unique path id under the labelingl i which is distinct from the path ids of paths which are not ininteresting p i .
formally a labelingl iis avalid labelingof an instancep iif a p q interesting p i pathid p pathid q b p interesting p i r interesting p i pathid p pathid r a valid labeling generates the exact execution frequencies of the interesting paths of a procedure from a single copy.
this in turn simplifies the job of obtaining exact frequencies of all paths of a procedure spread across multiple copies.
we note that a valid labeling may assign the same path id to two paths not ininteresting p i .
if there is onlyoneinstance of a procedurep that is its set of paths is not sub divided then the classic ball larus algorithm already yields a valid labelingl.
we give a brief overview of the ball larus algorithm.
in thefirst step it visits the vertices in the dag in the reverse topological order and labels a vertex vby the number of pathsn vpassing through it.
the algorithm considers an arbitrary order among the outgoing edges of a vertex.
for thefirst edgee l e 0and for anith edgee i l e i l e i n vi 1wheree i v v i .
figure shows how the outgoing edges of a vertexv 0are labeled.
if an edge v v i is labeled before an edge v v j then the labeling ensures that all the paths passing though the edge v v j have greater path ids than path ids of paths passing through the edge v v i .
in the next step a maximum spanning tree of the dag is computed and labels are revised using an event counting algorithm and placed only on the chords complement of spanning tree edges .
.
examples partitioning paths of a profitable procedure.let a procedurep whose dag is shown in figure a be a profitable procedure.
we describe our approach of classifying procedures into profitable and unprofitable in section .
.
suppose the two instancesp aandp bof the procedure shown in figure a and figure b are constructed for profiling disjoint sets of paths ofp.
a pathpis profiled in an instance if all the edges inedges p are shown in solid lines in that instance.
for example the path entry v exit is profiled in the instancep bbut not in pa. the edges in both the instances are labeled with valid labeling.
we have overhead p a 6andoverhead p b .
now consider another partition of the paths ofpgiven by two instances p aandp bshown in figure a and figure b also labeled with valid labeling.
here overhead p a 5andoverhead p b exitv0entry v1 v2 v3v4 v6 v5 v7 v8 v9 v10 v11v12 v13 v14 v15 v16 v17 v18 v19 v20 v211610 exitv0entry v1 v2 v3v4 v5v6 v7 v8 v9 v10 v11v12 v13 v14 v15 v16 v17 v18 v19 v20 v21 a p a b p b figure a partition p a p b of the procedurepwhich results in less overheads than the partition of figure .
.
since the maximum overhead of p a p b is smaller than the maximum overhead of p a pb the partition p a p b is likely to yield better performance than the partition p a pb .
we now analyze the cause of inefficiency in p a pb .
consider a pathp entry v v7 v8 exit .
this path encounters two probes respectively at v v7 and at v v10 inp aand one probe v v7 inp b. thus the runtime overhead due to execution of this path affects both the instances.
similar is the case for the paths passing throughv v v15 v18 v21 .
in general it may be difficult to avoid such situations but p3 performs a controlflow analysis whereby it assigns all the paths passing though a sequence of conditionals that do not have other conditionals nested within them to only one instance.
this is seen for the partition p a p b shown in figure .
here all the paths passing throughv v v7 v10 are profiled inp a whereas all the paths passing throughv 2are profiled inp b. due to the resultant labeling the runtime overhead due to execution of those paths includingp will affect only one instance.
this partitioning strategy reducesoverlapping profiling overheads.
for this example p3 can compute p a p b as the partition of paths ofp.
computing valid labeling of profitable procedures.the selective path profiling spp algorithm is designed to compute an edge labeling that assigns unique path ids to a chosen subset of pathss.
however for a labeling to be valid we additionally require that the path ids of paths insshould bedistinctfrom those of paths not in s. spp does not satisfy this requirement as demonstrated below.
consider the set of interesting pathssprofiled in an instance of a procedurepshown in figure a .
an edge that appears in some uninteresting path is shown in dashed lines in figure a and figure b .
we refer to such edges asuninteresting edges.
similar to the ball larus algorithm in thefirst step spp proceeds in the reverse topological order except that at each vertex it processes all uninteresting outgoing edges before the interesting ones.
figure a shows the edge labels thus computed.
in the next phase spp visits the vertices in the topological order and if v w is the only incoming edge towthen spp adds its label to the labels of all the outgoing edges ofwand sets the label of v w to zero.
the labels obtained after this step are shown in figure b .
in the third andfinal step it sets the labels of all uninteresting edges to zero.
in our example the non zero labels of uninteresting edges v v11 and v v15 are set to zero.
the other uninteresting edges are anyway zero after the second step see figure b .
the labeling after the third step is not shown due to space constraints.
exitv0v1 v2 v3v4 v5v6 v7 v8 v9 v10 v11v12 v13 v14 v15 v16 v17 v18 v19 v20 v21entry0 exitv0entry v3v4 v5v6 v7 v8 v9 v10 v11v13 v14 v15 v16 v17 v18 v19 v20 v21v2v12v1 a b figure steps of spp a labeling after thefirst step and b labeling after the second step.
consider two pathsp entry v v7 v8 exit and p entry v v15 v16 v18 v19 exit wherep s andp s. however under the labeling computed by spp in the third step the path ids of the two are thesame equal to3.
since the edge v v15 is uninteresting as stated above spp sets its label to zero in the third step resulting in this situation.
in order to overcome the overlapping path ids assigned by spp and to obtain valid labeling for individual instances of a profitable procedure we design a variant of spp called the precise spp pspp algorithm.
figure a shows the labeling obtained by pspp for the same subset of paths as in figures a and b .
in particular the pathspandp identified earlier respectively get distinct path ids 11and3in figure a .
we explain the computation of the valid labeling by pspp in the next section.
.
algorithms in this section wefirst present the pspp algorithm for profiling a subset of paths followed by the p3 algorithm.
.
precise selective path profiling our precise selective path profiling pspp algorithm is a variant of the spp algorithm and computes only valid labeling.
before we design the algorithm we analyze spp in more depth.
in depth analysis of spp .let us consider our running example in figure a and understand the reason why spp cannot construct a valid labeling.
in thefirst step of spp an uninteresting edge may get a zero label but it may become non zero after the second step which propagates edge labels in the topological order as described in section .
.
for example the uninteresting edge v v11 has a zero label in figure a but gets a non zero label in figure b .
in the third step spp sets non zero labels of uninteresting edges to zero.
we use the termabsorbto denote when the non zero label of an uninteresting edge is made zero in the third step of spp.
a pathpabsorbswhen an edge inedges p absorbs.
since interesting paths do not contain uninteresting edges they are always unabsorbable.
note that before the third step path ids produced by spp are unique and only after absorption path id of some uninteresting path may overlap with that of some interesting path.
letpid p v called apartial identifier denote the sum of edge labels of the suffixsuff p v of a pathpfrom vertexvonwards.
clearly pathid p pid p entry .
consider two pathspandp going through a vertexvsuch that they are respectively uninteresting and interesting paths.
further let an edge v w be an uninteresting edge that appears inp.
sim ilarly let an edge v w be an interesting edge that appears inp .
spp processes the uninteresting edges before interesting edges at vin thefirst step to try to make sure thatpid p v pid p v .
pid p v remains less thanpid p v after the second step and in particular after absorption the third step .
example .atv the uninteresting edge v v3 is processed by spp before the interesting edge v v4 in figure a .
consider an uninteresting pathp entry v v2 v3 v11 exit going throughv .
in figure a pid p v2 is less than thepidof the suffix starting atv 2for any interesting path passing throughv .
after absorption pid p v2 still remains less thanpids of suffixes starting atv 2for the interesting paths going throughv .
unfortunately pid p v of an uninteresting pathpwhich goes through aninterestingoutgoing edge ofvcan bemorethan that of an interesting path going throughv.
spp does not ensure that they will not become equal after absorption as shown next.
example .consider pathsp entry v v7 v8 exit andp entry v v15 v16 v18 v19 exit in figure b which get the same path id equal to after the edge v14 v15 absorbs as discussed in section .
.
the key observation from figure a is the following.
in thefirst step of spp while processingv s outgoing interesting edges v v2 is processed before v v12 .
this assigns the value to the edge v v12 as there are paths passing throughv .
this labeling is faulty as even though it makespid p v1 pid p v they become equal after the absorption.
the central problem of spp is that it does not assign any order in processing of the interesting outgoing edges.
the pspp algorithm.we now present the pspp algorithm to remedy the faulty labeling arising in spp.
while spp picks interesting outgoing edges of a vertexvduring thefirst step in anarbitrary order pspp enforces a specific order among those edges.
for a vertexv pspp processes the outgoing edges v w inthe decreasing order ofw.minwherew.minis defined as the minimumpid of theinteresting pathsstarting fromw.
this together with the processing of uninteresting outgoing edges before the interesting outgoing edges ensures valid labeling.
specifically it ensures that an uninteresting pathppassing throughvafter absorption results in pid p v v.minand therefore will not have same path ids with the interesting paths passing throughv.
this holdsirrespectiveof whetherpstarts with an uninteresting or an interesting edge atv.
this is in contrast with spp since such a claim is valid for spp only ifpstarts with an uninteresting edge atvas discussed earlier.
with this intuition we next describe the pspp algorithm in detail see algorithm .
pspp takes a daggand an edge seteiof edges appearing in interesting paths as input and produces avalid labeling of edges ing.
the label of an edgeeis denoted bye.val.
algorithm initializesv.minto for all vertices ofgexcept theexitvertex line .
for theexitvertex it initializesexit.min to zero andn exitto one line .
in the loop at lines pspp iterates over the vertices ofg excluding theexitvertex in the reverse topological order.
this is similar to thefirst step of spp but differs from spp in the order in which interesting outgoing edges are processed as explained below.
for each vertexv it initializes nvto zero line .
in the loop at lines itfirst iterates over the uninteresting outgoing edges ofvand for each uninteresting edge e v w it setse.valto zero.
it also accumulates the value of nwinn v line .
then in the loop at lines it iterates over the interesting outgoing edges in the decreasing order ofw.min.
for each such edgee v w it assigns the current value of nvtoe.val line updatesn vby addingn w line and updates the value ofv.minby taking the minimum of the current 488algorithm pspp g ei input a dagg v e entry exit and a set of interesting edgesei e output a valid edge labeling ofg 1begin 2foreachv v exit dov.min 3exit.min n exit 4foreachnon exit nodevin reverse topological orderdo nv foreachuninteresting edgee v w do e.val n v n v n w end foreachinteresting edge e v w in decreasing order ofw.mindo e.val n v nv n v n w v.min minimum v.min w.min e.val end end foreachnon exit nodevin topological orderdo ifvhas only one edgee i u v ande i.val 0then foreache o v w do eo.val e o.val e i.val end ei.val end end foreachedge e not in eidoe.val 23end value ofv.minandw.min e.val.
the loops at lines and line implement the second and third steps of spp respectively.
in particular the loop at line performsabsorption.
example .we now revisit the scenario of faulty labeling of the outgoing edges ofv 1by spp discussed in example and show how pspp remedies it.
the processing of thefirst step of pspp will yield the same edge labeling as spp for the subgraphs rooted atv2andv 12as shown in figure a .
whenv 1is processed v .min corresponding to the path entry v v6 v7 v8 exit andv .min corresponding to the path entry v v15 v17 v18 v20 exit .
therefore v v2 is processedlaterthan v v12 which makes e1.val 0ande .val 8wheree v v12 ande v1 v2 .
thefinal labeling obtained after propagation and absorption of labels by pspp is shown in figure a .
the paths p entry v v7 v8 exit p entry v v15 v16 v18 v19 exit will have path ids and respectively after the absorption step absorbs the label on v v15 propagated from entry v .
consider another pathp entry v v2 v3 v11 exit in figure a .
since it passes through an outgoing uninteresting edge fromv pid p v2 same aspathid p due to absorption remains less thanv .minand consequently less thanv .min.
this prohibits any chance of colliding with interesting paths passing throughv .
besides it can be seen that any uninteresting pathp havingpid p v2 higher thanv .minisunabsorbableand hence its path id will not be changed by pspp.
proof of correctness.we show that thefinal labeling produced by pspp is a valid labeling as defined in section .
.
a detailed proof of this claim is included in appendix a. .
partitioned path profiling we now present the partitioned path profiling p3 algorithm.
p3 uses the pspp algorithm presented in section .
as a sub routine.
data structures and helper functions.a programmis a set of procedures.
for a dagg v e entry exit of a procedure p g.eandg.vrespectively denote the set of edges and vertices ofg.
for a vertexv v v.pathcountgives the number of paths from theentryvertex tov.tdenotes a set of tasks where each task denoted byt corresponds to a subset of paths sayt p in the program.
for eacht t we maintain twofields t.eand t.costwheret.eis the union ofedges p for allp t pand t.costgives the number of instrumentation probes required by pspp for profiling the paths int pift.e g.e.
ift.e g.e thent.costis the number of probes required by the ball larus algorithm for profiling the paths int p. the function bl dag p returns the dag based on the dag construction algorithm for a procedurepand bl g returns the edge labeling for profiling all paths in a daggusing the balllarus algorithm.
the functionsize x returns the number of elements in the setx.
the functioncaller count p gives the number of call sites ofpin the programm.
for a dagg a set of four vertices a b c d forms adiamondif they have the following edges among them a b a c b d c d .
for example v4 v5 v6 v7 in figure a forms a diamond.
atriangleis a set of three vertices a b d such that they have the following edges among them a b a d b d .
we call the verticesaanddas beginandendvertices.
these controlflow structures respectively represent if else and if statements containing only straightline code within the branches equivalently they do not contain nested conditionals .
the functionreduced graph g returns a new dag called areduced dag where all diamonds and triangles ingare replaced by new vertices calleddummy vertices.
the incoming edges to the begin vertex of a diamond or a triangle ingare added as incoming edges to the dummy vertex it is replaced with.
the case of outgoing edges of the end vertex is analogous.
letesbe a set of edges in the reduced dagg obtained from a dagg.
for an edgee v d ore d w such thatd is a dummy vertex letoriginal e contain the set of edges in gbelonging to the diamond or triangle thatdreplaced while obtainingg .
ifxandyare the begin and end vertices of the diamond or triangle corresponding todthen we also add v x v d es y w d w es tooriginal e .
the functionget original edges es g g returns the set of edges v w es v ware not dummy vertices e original e e v d ore d w for some dummy vertexding ande es .
finally the functionreachable edges v g returns all the edges reachable fromving .
the p3 algorithm.the p3 algorithm is presented in algorithm .
it takes a programmand afinite setcof identical cores.
for each corec i c we maintain the followingfields c i.e set of edges of the paths profiled inc i c i.load computed as the number of edges inc i.eand c i.probes set of probes inc i output of p3 .
lines .if the paths in the dag of a procedure are partitioned and assigned to different copies there may be overlap of probes across the copies.
this can cause increase in runtime for both the copies.
since we cannot completely eliminate such overlap we try to limit its impact by considering only those procedures that may get called at most once in any execution.
p3 therefore applies partitioning to procedures by callingfind partition at line which have no more than one caller.
for the rest of the procedures it 489algorithm p3 m c input a programmand afinite setcof identical cores output an assignment of instrumented copies ofmto the cores 1t a global variable to store tasks 2begin 3foreachprocedurep mdo dagg bl dag p ifcall count p 1thenfind partition g else probes bl g t.e g.e t.cost size probes addttot end end foreachtaskt tin the decreasing order oft.costdo letc ibe the core with the minimum load ci.e c i.e t.e ci.load c i.load t.cost end foreachc i candp mdo g bl dag p ep g.e c i.e ife p g.ethenadd bl g toc i.p robes elseadd pspp g e p toc i.p robesend end 23end 24functionfind partition g 25begin letg v e entry exit g reduced graph g foreachv g .v entry dov.pathcount v.se entry.se entry.pathcount totalpathcount s foreachvertexv g .vin topological orderdo totalpathcount totalpathcount v.pathcount foreach v w g .edo add v w tos foreaches v.sedo addes v w tow.se incrementw.pathcountandtotalpathcountby1each iftotalpathcount then gotolbl end end end lbl foreachvs.t.
u v s v w sdo foreaches v.sedo foreach v w g .e v w sdo add v w reachable edges w g toes end t.e get original edges es g g probes pspp g t.e t.cost size probes addttot end end 53end applies the classic ball larus algorithm to determine the probes lines and creates a task for each such procedure.
lines .thefind partition function combines the paths in gthat pass through some diamonds or triangles into one task.
it does so byfirst creating a reduced dag as explained earlier.
these paths will share lots of overlapping instrumentation probes and are therefore more suited for profiling in the same core.
example .consider the example in figure .
it containsfive diamonds.
the corresponding reduced dag is formed by replacing thefive diamonds with dummy vertices.
there will be four paths inthe reduced dag and corresponding to each such path p3 creates one task.
note that the resultant four tasks in the above example can be profiled without any overlapping probes among them.
for large procedures the number of paths in the reduced graph can be large.
therefore we employ a threshold on the number of tasks generated from a procedure.
the tasks in the presence of a threshold are computed on the reduced dag as follows.
for a vertexvin the reduced dag each element of the setv.se denoted byes refers to the set of edges corresponding to a path fromentry tov.
starting fromentry the vertices of the reduced dag are traversed in topological order line .
while processingv w.se is updated line for each successorwofv.
the process terminates when the number of paths found totalpathcount is equal to the threshold .saccumulates all the edgescoveredduring this process.
in the loop beginning at line a vertexvis selected which is eitherexitor not all of its successors are processed in the previous iteration.
forv all edges reachable fromvtoexitpassing through uncovered edges are added to each edge set inv.se line .
each such edge set is mapped to the edges ingusing the functionget original edges line and a task is created using the edge set defined overg.
for some procedures e.g.
those without diamonds or triangles even iffind partition is invoked at line it will return only a single task.
a procedure on whichfind partition is invoked and it returns multiple tasks is called aprofitable procedure.
lines .for getting optimal benefit out of the distribution one has to minimize the maximum time taken across all cores.
it turns out that the optimal distribution to minimize the maximum cost across all cores is an np complete problem.
the hardness can be shown by reduction from multiprocessor scheduling problem .
in the multiprocessor scheduling problem msp we are givenmidentical machinesm .
.
.
m mand n jobsj .
.
.
j n. jobj ihas a processing timep i 0and the goal is to assign jobs to the machines so as to minimize the maximum load.
the load of a machine is defined as the sum of the processing times of jobs that are assigned to that machine.
in our context a task t is considered as equivalent to a job in msp andt.costis considered as the processing timep ifor a jobj i. we use a known 3th approximation algorithm for multiprocess scheduling for distribution in p3.
here in a loop the highest cost task among the remaining non distributed tasks is assigned to the core with least load.
example .in the example in figure the four tasks have cost entry v exit entry v exit for the paths passing throughv and for the paths passing throughv .
if only two cores are available the 4th task is assigned to thefirst core andfirst three tasks are assigned to the second core.
this results into the distribution shown in figure .
lines .finally for each core p3 collects all the interesting edges of the same procedure in the core and calls pspp or bl to get thefinal set of probes for the procedure on those edges.
.
experimental evaluation in this section we explain our implementation and experimental setup.
we then report the experimental results on several programs from the spec benchmark .
.
implementation we have implemented the pspp and p3 algorithms for sequential c c programs using the llvm .
infrastructure .
llvm has an implementation of the ball larus algorithm and we use it as a sub routine in p3 s implementation.
for the experiments for each 490table benchmark characteristics id program name loc procedures profitable procedures .astar .gcc .gobmk .hmmer .h264ref .lbm .libquantum .mcf .milc .rand .rand .sjeng .sphinx3 procedure we choose the threshold on the number of partitions that p3 creates as the maximum of the out degree of theentryvertex of its dag and the number of cores.
note that bl dag can create a dag having vertices with out degree more than two.
we specialized our p3 implementation to derive an implementation of theparallel ball larus strategy pbl outlined in the introduction.
more specifically in our pbl implementation all procedures are considered asunprofitableand are instrumented using the ball larus algorithm to be distributed subsequently.
thesequential ball larus strategy sbl is same as the ball larus profiling on a single core.
we compare the profiling overheads ofthreedifferent techniques p3 pbl and sbl.
.
experimental setup setup.we use programs from the spec benchmark for experimental evaluation.
spec benchmarks are popular evaluation targets in the profiling literature.
we could run the ball larus implementation supplied with llvm on13c c programs from this benchmark.
we evaluate the profiling algorithms on all these programs see table .
these comprise both large programs such as .gcc and some small programs such as .rand.
most programs have several thousand lines of code and a few hundred procedures.
the spec benchmark also provides a few tests per program.
to evaluate the runtime overhead of profiling we run each of the programs in table on all the tests available for it.
the experiments were conducted on ubuntu linux .
on an intel xeon w3520 .67ghz machine with cores and gb ram.
we simulate different cores by running the distinct copies generated by the profiling algorithms separately on a single core of this machine.
we present results of the parallel path profiling techniques on and cores.
quantifying profiling overhead.we quantify the runtime overhead of profiling using a metric called hit count.
thehit countof a procedurepon a testxis the number of timesinstrumentation probesinserted intopgot executed while running the testx.
the hit count of a copycon a testxis the summation of the hit counts of all the procedures in that copy onx.
the time overhead for profilingpunderxon a copycis proportionate to its hit count.
measuring real time can have some inaccuracies based on the processor load and other environmental factors.
further we have to accurately distinguish between the actual execution time and the time taken by instrumentation probes.
hit count directly quantifies the profiling overhead independent of these issues.
if an algorithmagenerateskcopiesc .
.
.
c kfor a program mthen the profiling overhead ofaformon a testxis taken as the maximum of the profiling overheads ofc iformonx for i k. for a programmand an algorithma we consider1 avg020406080100 program id profiling overhead of sblp3pbl figure profiling overhead of p3 and pbl relative to sbl on cores lower is better avg is the average over the programs.
the average of the profiling overhead ofaacross all the tests ofm as theprofiling overhead.
average across all programs is simply referred to as average and identified by avg in thefigures.
.
experimental results rq1.
how many procedures were deemed to be profitable by p3?
as discussed in section .
p3 automatically identifies profitable procedures by a static controlflow analysis.
table shows the number and percentage of procedures that p3 deemed profitable for each of the programs.
for each of them p3 could generate at least disjoint subsets of paths.
the profitable procedures range from6 of all procedures across the programs.
thus in each of the programs p3 could identify opportunities for load balancing across cores through profitable procedures.
rq2.
does p3 reduce profiling overhead compared to sbl?
the key test of effectiveness of p3 is whether and how much reduction in profiling overhead defined in section .
does p3 achieve compared to the sequential ball larus sbl strategy.
in figure we plot the profiling overhead of p3 relative to sbl on cores.
on the x axis we represent different program ids assigned to the programs in table .
the y axis is labeled with the percentage of the profiling overhead of sbl at the intervals of .
afilled gray bar shows the percentage of p3 s profiling overhead relative to that of sbl for the same program.
lower the value of a y coordinate the more reduction in profiling overhead p3 achieved.
it can be seen that with only cores p3 could reduce the profiling overhead for most of the programs.
for8programs the reduction is more than or equal to20 whereas for3programs ids and it is only marginal.
the average reduction across all the programs is23 as shown in the last bar of figure .
in figure and figure we plot the profiling overhead of p3 relative to sbl for and cores respectively.
for cores the reduction is more than or equal to47 for8programs whereas for 5programs ids and it is less than or equal to30 .
the average reduction for cores is43 .
finally for cores the reduction is more than or equal to50 for11programs whereas it is less than or equal to25 for the remaining two programs.
the average reduction for cores is56 .
overall p3 achieved substantial parallelization benefits for most of the programs across as well as cores.
rq3.
does p3 reduce profiling overhead compared to pbl?
we now compare p3 and pbl.
similar to p3 for each of the avg020406080100 program id profiling overhead of sblp3pbl figure profiling overhead of p3 and pbl relative to sbl on cores lower is better avg is the average over the programs.
avg020406080100 program id profiling overhead of sblp3pbl figure profiling overhead of p3 and pbl relative to sbl on cores lower is better avg is the average over the programs.
programs we plot the profiling overhead of pbl relative to sbl for and cores in figures and respectively.
the bars with cross lines correspond to pbl.
for cores figure for8programs p3 shows more reduction compared to that of pbl.
on an average across all the programs the profiling overhead of p3 is5 less compared to pbl.
for cores figure p3 gives more reduction than pbl on all but1programs.
on an average across all the programs the profiling overhead of p3 is18 less compared to pbl.
finally for cores figure p3 outperforms pbl in all except2cases.
on an average it has less overhead than pbl.
we see two reasons behind the cases where p3 could not perform better than pbl overlapping of probes among the copies and selection of profitable procedures did not have any effect on the result.
in summary p3 is more effective in exploiting parallelism in path profiling compared to pbl.
p3 s strategy of automatically identifying profitable procedures and sub dividing the task of profiling their paths helps reduce profiling overhead compared to pbl s coarsegrained strategy of distributing entire procedures.rq4.
how much time does p3 take to construct different instrumented copies and assign them to different cores?
p3 constructs different instrumented copies of a programmand assigns them to different cores by a static analysis ofm.
p3 took a maximum of48m for the largest program in table .
on an average it took5m across all the programs with programs taking less than minutes.
we highlight that this is only a one time cost for any program for a given number of cores.
the program can then be profiled in parallel for any number of inputs.
.
discussion trade off between overlapping probes and load balancing.overlapping probes are those probes that may get executed in an instancep ifor a path profiled in another instancep j. an important factor in achieving reduction in profiling overhead through p3 is to achieve a trade off between overlapping probes which can increase the profiling overhead and load balancing that can be achieved through profiling only a subset of paths in each core.
our experimental results show that this is indeed possible in practice.
in particular we observed that in several cases multiple acyclic paths of a procedure were exercised on the same core while using pbl but they were profiled ondifferentcopies when p3 was used.
in addition the overlapping probes between those copies for the procedure did not overshadow the benefit of distribution of the paths.
threats to validity.there are some threats to validity for our experimental results.
the main among them being the limited number of programs and test inputs for them.
we attempt to mitigate it by considering the spec benchmarks which are widely used in the profiling literature and generally in performance analysis.
nevertheless in future we wish to run our experiments on other programs.
the second threat is due to possible non determinism in the paths being explored in different copies.
however we consider only sequential programs and evaluate them on the same machine see section .
.
thus once wefix an input all copies of the program follow the same dynamic controlflow path.
we give a detailed proof see appendix a of correctness of pspp to eliminate the possibility of a theoretical glitch.
finally we reduced the possibility of bugs in our implementation by manual inspection and repeated experiments on both smaller hand written examples and the spec benchmarks.
.
related work program profiling.ball and larus introduced the notion of acyclic intra procedural path profiling and provided an algorithm to compute it.
the ball larus algorithm has been extended to profile inter procedural paths by melski et al.
and to cyclic paths by d elia et al.
.
we believe that p3 can be extended to cover these extensions.
extending p3 to profile inter procedural paths is an immediate future work for us.
recently li et al.
presented an algorithm to overcome the impreciseness of spp .
their algorithm called modified spp mspp deletes a label from an uninteresting edge only if it does not result in an invalid labeling.
mspp is an exponential algorithm in worst case whereas pspp is linear in the size of the dag.
vaswani et al.
introduced preferential path profiling ppp which reduces the overhead of path profiling by profiling a given set of paths with an objective of compact numbering.
the compact numbering facilitates the use of arrays for updating the frequency for each acyclic path thereby reducing the overhead caused by the use of hashtable.
it can be shown with an example that their algorithm does not ensure computation of valid labeling.
in contrast the pspp algorithm computes only valid labeling.
as a workaround ppp uses ball larus labeling for distinguishing interesting and un492interesting paths.
this workaround cannot be used in our scenario as the overhead will be same as overhead for ball larus labeling irrespective of the interesting paths.
chilimbi et al.
extended ppp for inter procedural paths and used it for residual path profiling.
we plan to extend pspp for efficient residual path profiling.
pertinent path profiling introduced a new control flow entity namely pertinent paths that pass though a given set of nodes called pertinent nodes.
it generates a unique numbering for pertinent paths and generates compact numbering of path ids.
they do not try to reduce the number of probes instead try to reduce the path table size.
targeted path profiling addressed the profiling overhead problem by leveraging edge profiling information in the context of staged dynamic optimization systems.
parallelizing edge profile in itself can be an interesting research problem.
in p3 the task cost can take into account such profiling information for better distribution of tasks into cores.
one program many copies.closest to our work is distributed program tracing .
it collects a single program trace corresponding to a given input by distributing the witnesses across multiple copies of the program and run them parallel on the same input to collect the partial traces.
the partial traces are then merged to produce the whole trace.
though the same code replication based divide andconquer strategy is applied in the context of a different problem the challenge there was to devise the necessary and sufficient condition which guarantees that the originalorderof basic blocks can be constructed by merging.
the distribution of witnesses and merging algorithm are therefore crucial for soundness of the algorithm.
in contrast here the distribution is addressing the efficiency of the technique and the pspp algorithm applied on each procedure locally on each core is ensuring the soundness.
in both the works the distribution strategies further address the efficiency of profiling or tracing.
in tracing a sequence of diamonds is put together in one copy as they can becoveredby less number of witnesses whereas p3 uses the notion of profitable procedures to optimize.
software tomography splits monitoring tasks across many instances of the software so that partial information may be collected from users by means of light weight instrumentation and merged to gather the overall monitoring information.
although sounds similar the main difference is that they do not try to obtain accurate profiling information for a given set of paths.
there technique distributes the monitoring tasks to different users who can use the software at will with different inputs.
their goal is to gather enough information for each sub task.
for example for path coverage they discover whether each path is executed in a given set of executions whereas our goal is to obtain precise execution frequencies in a given task.
thus their framework is more suitable towards efficient distributed profiling estimation based whereas our algorithm is more suitable towards accurate parallel path profiling.
additionally their algorithm is not accurate as it is as based on spp .
diep et al.
consider distribution of probes to multiple program variants where each variant contains a subset of probes where the subset size can be bounded to meet the overhead requirements.
however the aim there is to profile a set of events and not paths.
.
conclusions and future work in this paper we presented an algorithm called p3 for parallel path profiling.
to the best of our knowledge this is thefirst algorithm for parallel path profiling.
p3 profiles the path of a program by distributing all acyclic paths into multiple cores running on the same input.
p3 judiciously performs partitioning of paths of some selected profitable procedures to reduce the common overhead caused by the execution of a path in multiple cores.
it uses an ap proximation algorithm to evenly distribute the overhead based on number of probes.
to precisely estimate execution frequencies for each subset of paths in a profitable procedure we have developed an algorithm called pspp which we use in p3.
this paper opens up some interesting research problems how to extend p3 for inter procedural or cyclic paths which poses the challenge of extending pspp for such paths.
as the ball larus algorithm can benefit by previously available profiling information for determining low frequency chords to place the probes p3 s distribution algorithm can be extended to get benefit from such information.
in the absence of dynamic profiling information it is possible to do static estimation based on program s inter procedural cfg.
this paper also opens up possibility of optimizations based on better selection strategy of profitable procedures and threshold.
appendix a. correctness of pspp we now show that thefinal labeling produced by pspp is a valid labeling as defined in section .
.
wefirst define local validity of a labelinglat a vertexv.
leti vand ivdenote the set of interesting and uninteresting paths passing through the vertexvrespectively.
the labelinglislocally validatvif the following conditions hold forpids obtained usingl a p q i v pid p v pid q v b p i v r iv pid p v pid r v this definition is similar to the definition of valid labeling but uses partial identifierspids instead ofpathids.
sincepathid p pid p entry a locally valid labeling for v entryis same as a valid labeling.
thus by proving local validity for each vertex we can prove the validity of the labeling produced by pspp.
we now give names to the different steps of pspp for simplicity.
the loop at lines is called theinitial step.
the loop at lines is called thepropagation stepand finally the loop at line is called theabsorption step.
it is easy to see that local validity holds at every vertex for the edge labeling obtained after the initial step.
in pspp the propagation and absorption steps are performed after the initial step is over for all the vertices.
to show that local validity holds for each vertex after the absorption step we define a variant of the pspp algorithm calledpspp in which propagation and absorption steps areinterleavedwith the loop of the initial step.
in particular the propagation and absorption loops are run within the loop of the initial step immediately after a vertexvis processed in each iteration of the loop at lines by treatingvas the entry vertex of the subgraph ofgrooted atv.
wefirst show equivalence of pspp and pspp and then prove correctness of pspp .
lemma .the edge labeling computed by pspp and pspp are identical.
proof .
this follows from the fact that pspp also performs the propagation and absorption at theentryvertex same as that in pspp.
since the propagation step is iterative and it considers each vertex in the topological order for propagation of edge labels to the outgoing edges of vertices with in degree1 thefinal edge labeling of the interesting edges is the same for both pspp and pspp .
all the uninteresting edges are labeled in both pspp and pspp .
letsucc i v w v w ei .
henceforth we refer to visit of a vertexvby pspp as the visit ofvin its outermost loop.
lemma .for a vertexv the valuev.minis only updated line of algorithm for thefirst interesting edge v w pspp and also pspp visits in the initial step.
the valuev.minis at leastw .min.
also w i succ i v w i.min v.min.
493v b w w2nbpv w2 w1 a e bpq a b figure a case first non interesting edge ofpstarts from v b case first non interesting edge ofpstarts after prefix qfromv proof .
pspp essentially follows ball larus edge labeling for interesting edges and the above lemma follows from the fact that ball larus edge labeling always gives higherpidto the paths passing through the edges that are visited later.
thus the interesting path fromvwith minimum path id always passes through thefirst interesting edge visited by pspp.
since the value assigned to an interesting edge is at least0 the minimum path id of an interesting path throughvis atleastw .min.
also w i succ i v as wi.min w .min we deducew i.min v.min.
lemma .after pspp visits a vertexv it ensures that an uninteresting pathphavingpid p v higher thanpid p v of any interesting pathp is always unabsorbable.
proof .
we prove this by contradiction.
suppose there exists such an uninteresting pathpwhich is absorbable.
letw w2.... w n be the successors ofv.
let a b be thefirst uninteresting edge of preachable fromv.
we consider two cases forp.
first case a b is the leading edge of the subgraph rooted at v meansa v .
refer to figure a for an illustration.
all the interesting paths will be assigned higherpids than thepidof the uninteresting pathpsince interesting edges are processed after uninteresting edges.
this contradicts our assumption.
second case a b is not the leading edge see figure b .
that means there exists a prefixqconsisting of all interesting edges without more than one incoming edge till the edge a b of this path which makes it absorbable.
now consider a pathqequal to entry .
.
.
v w x1 x2 .
.
.
x n a .
.
.
exit .
for an interesting edgeepassing through the vertexa e.valwill get higher value than thepidof the uninteresting path with respect toabecause interesting edges are processed later than uninteresting edges.
thus the value ofa.minwill be higher than thepid p v as after pspp completes processing ofv all labels of edges inqand a b are zero due to propagation and absorption fromv.
using lemma x n.min a.min.
lemma can be used to show the inequalityx.min a.minforxranging over all the vertices xn .
.
.
x w1 v since each of the vertices is the successor of the next node.
hence v.min a.min.
this means that the minimumpidof the interesting path passing fromvis at leasta.min.
buta.min pid p v .
this contradicts our assumption.
theorem .given a dag and a set of interesting edges after pspp visits a vertexv the labeling obtained is locally valid atv.
proof .
the proof is by induction on theheightof a vertex in the dag.
the height of a vertexvis the smallest number of edges betweenvand theexitvertex of the dag.
base case vhas height equal to zero that is v exit .
the theorem trivially holds.induction step we show that the theorem holds for any vertex vof heighth .
since we are considering a dag all successorsw w2.... w nofvhave height less thanh so by induction hypothesis the local validity holds on allw i. the algorithm assigns ball larus edge labeling to the interesting edges and after computing propagation and absorption steps thepidof all the interesting paths remains intact since there are no uninteresting edges in interesting paths.
so thepids of the interesting paths satisfy part a of the definition of locally valid labeling.
for proving part b of the local validity definition partition the uninteresting paths passing throughvin two groupsn 1andn .n 1consists of all the uninteresting paths which pass through leading uninteresting edges ofv whereasn 2consists of all the uninteresting paths passing through leading interesting edges ofv.
again its trivial to see that p n 1and q i v pid p v pid q v since all the interesting edges are processed later than the uninteresting edges and interesting edges are assigned in increasing order.
for proving the distinctness ofpids of paths ini vand those in n2 we consider following two cases case a paths passing through the same interesting edge from v wefirst prove the distinctness of the path ids of interesting paths ivand path ids of the paths inn 2which pass through the same outgoing edgee v w i ofv.
consider two such pathsp n andp i v. by induction hypothesis pid suff p wi w i pid suff p wi w i .
we need to prove that after propagation and absorption ofe s edge label say theirpids w.r.t.v are disjoint.
by lemma onw i p1is absorbable ifpid suff p wi w i pid suff p wi w i .
as no absorption happens to interesting paths pid p v pid suff p wi w i .
for such ap pid p v pid suff p wi w i as some absorption happens inp .
thereforepid p v pid suff p wi w i pid p v .
in the other case p 1is not absorbable therefore itspid p v will not change after absorption and remain different thanpid p v .
case b paths passing through different outgoing edges from v we now prove the distinctness of thepids of the interesting paths and the path ids of uninteresting paths inn 2passing through different edges v w i and v w j .
let without loss of generality wi.min w j.min.
pspp processes edge v w i before edge v w j and assigns v w j .vala value which is greater than all thepids of the paths passing through v w i .
thus all the interesting paths passing throughv w jhave higher pids than the uninteresting paths passing through v w i .
consider an uninteresting pathp 1passing through v w j and an interesting path passing through v w i .
say v w j .val and v w i .val .
ifp 1is unabsorbable thenpid p v pid p v .
ifp 1is absorbable then by lemma 3pid p v pid suff p wj w j w j.min.
sincew j.min w i.min pid p v w i.min.
since by definition pid p v w i.min thereforepid p v pid p v .
theorem proves the correctness of pspp .
if local validity of the labelinglcomputed by pspp holds at theentryvertex then validity oflalso holds.
the output of both pspp and pspp are same by lemma .
we therefore have the following theorem.
theorem .given a dag and a set of interesting edges pspp computes a valid labeling.
note that pspp is same as the ball larus algorithm if all paths in the dag are marked as interesting and additionally if all edges are interesting even though some paths are uninteresting the pspp algorithm is same as the ball larus algorithm.
finally for two sets of pathssands wheres s the number of zero edges obtained by pspp forsis more than or equals to that ofs .
.