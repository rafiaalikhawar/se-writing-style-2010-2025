a temporal permission analysis and enforcement framework for android alireza sadeghi department of informatics university of california irvine usa alirezs1 uci.edureyhaneh jabbarvand department of informatics university of california irvine usa jabbarvr uci.edunegar ghorbani department of informatics university of california irvine usa negargh uci.edu hamid bagheri department of computer science and engineering university of nebraska lincoln usa bagheri unl.edusam malek department of informatics university of california irvine usa malek uci.edu abstract permission induced attacks i.e.
security breaches enabled by permission misuse are among the most critical and frequent issues threatening the security of android devices.
by ignoring the temporal aspects of an attack during the analysis and enforcement the state of the art approaches aimed at protecting the users against such attacks are prone to have low coverage in detection and highdisruption in prevention of permission induced attacks.
to address this shortcomings we present terminator a temporal permission analysis and enforcement framework for android.
leveraging temporal logic model checking terminator sanalyzer identifies permission induced threats with respect to dynamic permission states of the apps.
at runtime terminator senforcer selectively leases i.e.
temporarily grants permissions to apps when the system is in a safe state and revokes the permissions when the system moves to an unsafe state realizing the identified threats.
the results of our experiments conducted over thousands of apps indicate that terminator is able to provide an effective yet non disruptive defense against permission induced attacks.
we also show that our approach which does not require modification to the android framework or apps implementation logic is highly reliable and widely applicable.
ccs concepts security and privacy mobile platform security access control theory of computation modal and temporal logics keywords android access control permission temporal logic acm reference format alireza sadeghi reyhaneh jabbarvand negar ghorbani hamid bagheri and sam malek.
.
a temporal permission analysis and enforcement framework for android.
in proceedings of icse 40th international conference on software engineering gothenburg sweden may june icse pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn .
.
.
.
introduction popular mobile operating systems such as android apply a permission based model to patrol resources that each application is allowed to access.
in this model critical system and application resources are protected by an explicit permission which then must be obtained by any application that would like to access the resources.
yet in the past few years since the inception of android a number of flaws have been identified in its permission mechanism that canlead to serious security and privacy breaches .
a large body of research thus has been devoted to address detection and prevention of permission induced attacks in android .
the state of the art approaches however fail to consider the temporal aspects of permission induced attacks during the analysis and enforcement thereby suffer from shortcomings that aggravate their effectiveness.
detection of several permission induced attacks such as those exploiting the toctou time of check to time of use vulnerability in android requires careful consideration of the order of events.
hence existing detection techniques which ignore the element of time in their analysis are prone to miss important security breaches.
additionally due to the highly dynamic state of an android system the identified security vulnerabilities may only be exploitable at specific time intervals e.g.
when some specific permissions are granted.
hence the existing conservative prevention techniques which regardless of the system state enforce security rules permanently tend to produce plenty of false alarms.
as a result users can be unnecessarily disrupted even in the absence of material security threats and prevented from taking full advantage of the apps on their device.
finally the proposed approaches are mostly realized through modification of either the android framework or the implemenation logic of apps .
but such modifications are not necessarily expected nor properly tested by the application developers resulting in all sorts of undesirable side effects suchas app crashes and unexpected behaviors.
to address this state of affairs a pragmatic approach for detection and prevention should explicitly consider the temporal aspects of attack during analysis and enforcement.
moreover the realization of the approach should be naturally compatible with the implementation practices in android.
this paper contributes a novel approach and accompanying tool suite called t erminator short for temporal p ermi ssionanalysis and enforcemen tframew ork for and roid.
unlike all prior techniques t erminator incorporates the notion of time as a first class entity in both detection and prevention of permission induced attacks.
our approach has the potential to greatly improve our ability acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. sadeghi et al.
to thwart permission induced attacks by introducing the concept of temporal permissions i.e.
the temporary granting of permissions to apps.
specifically constructed atop temporal logic t erminator leverages temporal permissions to formulate dynamic aspects of the system over time and reason about the security properties thereof as the system transitions from one state to another risk detection and regulate app permissions at runtime based on the current state of the system risk prevention .
terminator provides a safe reliable yet non disruptive approach to protect mobile users against permission misuses.
upon receiving a permission request from an app t erminator evaluates the security posture of the system with respect to the currentstate of the granted permission configuration as well as potential threats conservatively identified via the state of the art static analysis tools.
if granting the requested permission does not lead to a real security threat given the current state of the system t ermina tor leases i.e.
temporarily grants that permission to the requester.
the leased permission is then automatically revoked as soon as a change in the system status is observed that may lead to realization of an identified security threat.
t erminator uses tla model checker tlc as an analysis engine for temporal permissions.
to prevent permission induced attacks t erminator relies on the android s dynamic permission mechanism without needing to make any modification to the android framework or the implementation logic of apps.
our experiments indicate that t erminator is up to more successful in preventing permission induced attacks while issuing significantly less false alarms.
it also causes less disruption in the availability of permission protected app functionality due to restrictive permission configurations.
to summarize this paper makes the following contributions theory to the best of our knowledge this is the first attempt at leveraging temporal logic and incorporating the notion of time in modeling and analyzing the security properties of android tool a fully automated framework t erminator that realizes the idea of temporal permissions for android which we have made publicly available experiments empirical evaluation of the approach on real world android apps demonstrating its efficacy.
the remainder of this paper is organized as follows.
section motivates our research through various examples of permissioninduced security attacks.
section formally specifies those attacks and introduces our approach to effectively thwart them.
section provides details of our approach and its implementation.
section presents the experimental evaluation of the research.
the paper concludes with an outline of the related research and future work.
permission induced attacks to motivate the research and demonstrate the need for temporal permissions we describe four types of permission induced security attacks in android identified in prior research .
permissioninduced attacks are security breaches enabled by android permissions misuse.
this section elaborates on the attack scenarios summarized in figure .
we will later show how temporal permissions help thwart these attack scenarios with minimum disruption.
.
privilege escalation privilege escalation occurs when an application with less privilege is not restricted from accessing components of a more privileged application .
in the case of the particular example shown infigure a mal app can indirectly reach the permission protected interface of the privileged app by exploiting the vulnerability of the victim app that is an unprotected exposed interface shown to be quite common in the app markets .
the collusion attack carried out by multiple malicious apps through combining a set of permissions to perform unauthorized actions is also categorized under this group of attacks.
the state of the art techniques for preventing inter app security attacks conservatively assume that this vulnerability is exploitable as soon as the apps are installed on the device.
however a more careful look at the timeline of the attack scenario shown in figure a would reveal that the presented security vulnerability is only exploitable during the unsafe time slot where the following two conditions hold at the same time the malware and victim apps are both active i.e.
running in foreground or background and permission pis granted to victim app.
if those applications are installed but not active the vulnerability cannot be exploited.
on the other hand if permission pis not granted to the victim app the permission protected interface of the other app is not accessible.
.
unsafe pendingintent in android pendingintent is a wrapper around intent that enables performing the intent s action in future even if the original app that sent the intent is not active anymore.
for this purpose android transfers the permission and identity uid of the sender app to the target app that receives the pendingintent.
as such careless use of pendingintent can lead to severe security consequences.
examples include the privilege leakage vulnerability in the android settings application cve .
for this reason android s developer guidelines strongly discourage using blank base pendingintents the base intent you supply should have the component name explicitly set to one of your own components to ensure it is ultimately sent there and nowhere else .
despite that many app developers fail to follow such security principle in action.
figure b shows an example of using unsafe pendingintent exploited by mal app to illegally access permission protected interface provided by privileged app.
this example is similar to the privilege escalation attack illustrated in figure a except that the conditions for exploitability are more relaxed in two ways first the victim app does not need to be necessarily active and second its permission p may be revoked prior to malware executing the wrapped intent.
.
identical custom permission besides the predefined built in permissions such as sms location etc.
android apps can define their own custom permissions and request those permissions from other apps.
however the custom per mission model suffers from a security vulnerability rooted in a design flaw if two apps define the same custom permission whichever app is installed first is the one whose definition is used .
a malicious app can exploit the custom permission vulnerability to illegally access the interface of another app protected by that custom permission.
a sample attack scenario is shown in figure c .
in this example victim andmal apps have both defined the same custom permission i.e.
the names of permissions pandp prime defined by the permission element in the manifest are identical.
since the malicious app is installed prior to the victim app permission p prime defined in the manifest of the mal app at the normal level is the one recognized by the android framework.
consequently mal app can access the interface defined by the victim app which is intended authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a t emporal permission analysis and enforcement framework for android icse may june gothenburg sweden !
.
!
!
!
!
.
!
!
.
!
!
!
!
!
.
!
!
!
!
.
.
!
.
.
!
!
.
!
!
!
.
!
.
.
!
.
.
?
!
!
!
.
!
.
.
!
!
.
!
.
figure examples of permission induced security attacks that could be thwarted using temporal permission.
in each example the top of the figure shows the elements involved in the attack and the bottom shows a possible attack scenario over time.
the permission can be leased i.e.
temporarily granted during the safe time slots.
in all of the scenarios the malicious communications are distinguished by dashed lines.
to be only accessible to those requesting the custom permission p such as benign app.
the custom permission breach can happen even though the permissions with the same name have different protection levels.1essentially the malware can define a permission with normal protection level rather than dangerous orsignature protection level to evade user attention and interaction.
.
passive data leak a passive data leak occurs when an app does not properly protect its internal database that contains sensitive data .
a malware can exploit this vulnerability by retrieving the stored data without having the permission needed for directly accessing such sensitive information.
thereafter the malicious app can transfer the sensitive data to an untrustworthy location.
figure d depicts an example of passive data leakage.
in this attack scenario victim app with an access to sensitive data due to obtaining source permission e.g.
permission for accessing phone identifier stores this information in its internal database which is not properly protected.
as a result mal app can retrieve the sensitive data and send it to an untrustworthy location if it has been granted with a sinkpermission e.g.
sms permission .
from the attack scenarios shown in figure we can see that the notion of time is critical in the precise description of all attacks.
in other words a precise analysis should keep track of the security posture of the system as it moves from one state to another over time.
hence to formally describe the attack scenarios we need to formulate the system properties in terms of time.
for this purpose we leverage temporal logic as described in the next section.
1the protection level indicates the trustworthiness of an application that may be granted this permission.
2the system automatically grants normal permission to a requesting application at installation without asking for the user s explicit approval.
temporal permission in this section we describe a formal model of the android system with a focus on its security properties such as permission status.
using this model we then define a set of safety formulas corresponding to the permission induced security attacks described in the previous section.
finally we demonstrate that control of the permissions granted to apps is sufficient for effectively thwarting all such attacks.
.
modeling the android system we model the android system as a kripke structure a variation of transition system that mathematically models dynamic systems .
determines whether app is installed on the device installed app determines whether app is running ei ther in the foreground or background active app determines whether permission is declared by app declared app permission determines whether permission is requested by app requested app permission determines whether permission is requested by and granted to app at runtime granted app permission determines whether app defines an exposed interface reaches to permission required capability exposed app permission determines whether app sends a pendingintent with blank base intent w o explicit target containing permission required data payload blankpi app permission determines whether a pp retrieves permission protected data e. g. imei location etc retrieve app permission data determines whether app sends data throug h permission protected channels e.g.
sms internet etc.
send app permission data determines whether data is stored by the app in an unprotected database storeunprotected app data figure atomic propositions ap defined for modeling thesecurity properties of android system.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. sadeghi et al.
.
.
.
.
.
.
?
?
.
.
?
?
?
.
.
.
figure a subset of kripke structure for a hypothetical android system nodes represent the reachable states of the system and edges represent state transitions.
each node is also labeled with a set of properties that hold in the corresponding state.
more formally we model the system as a tuple m s i r l where sis a set of states i sis the set of initial states r s sis a total transition relation and lis the labeling function that assigns to each state the subset of properties that are valid in the state.
to define the labeling function we first need to define atomic propositions o r ap which is a set of boolean expressions that specify the properties of the system s. for instance granted app a perm p states that the permission pis granted to the app a. we use atomic propositions to define the labeling function as follows l s ap true fa ls e .
in other words for each system state s s the labeling function l determines whether the atomic proposition ap apholds at that state or not.
modeling the android operating system in its entirety with all its compound structures would be infeasible.
we thus concentrate on the parts that are particularly relevant to the permission mechanism how permissions are granted and maintained and how they con strain the behavior of an application.
figure provides the set of atomic propositions defined as parameterized predicates.
for instance granted app permission has two arguments the first one is an app and the second one is a permission requested by that app.
as a concrete example figure shows a small subset of the kripke structure of a hypothetical android system with six states the initial state s0 ialong with five other states s1 s. also two kinds of actions triggering state transitions r r are shown here namely start stop actions that alter the system configuration apropos of the active proposition and grant revoke actions that alter the system configuration apropos of the granted proposition.
interacting with the user and other environmental actors android system moves from one state to another in the kripke structure over time.
as a result under specific sequence of actions the systemcan move to an unsafe state a state that violates the security of the system.
for instance in figure s3represents an unsafe state corresponding to the red time slot of the privilege escalation attack scenario shown in figure a .
s3is unsafe since a privilege escalation attack is possible when the system moves to this state.
.
formulating safety rules we specify safety rules in terms of conditions that need to hold throughout the states of the system.
for this purpose we leverage linear time temporal logic ltl .
temporal logics enable specifying a system s behavior as it evolves over time.
indeed in temporal logics the truth of a statement is not fixed in the semantics rather relies on the point in time when it is considered.
temporal logics thus besides the usual logical operators such as and or not and implies also contain temporal operators such as eventually always anduntil.
for instance sms permission can eventually be grantedto the messenger app or sms permission should not be granted to the messenger app until the malware app is terminated are two examples of such statements that can be expressed using temporal logic.
in ltl time is represented by a sequence of discrete time steps.
privilege escalation the first formula sa f etyrule pe specifies the conditions needed to hold in order to prevent the privilege escalation attack recall section .
.
sa f etyrule pe app vic app mal apps p permissions vul pe app vic app mal p square granted app vic p active app mal the precondition of rule checks for the privilege escalation vulnerability vulpe which is formulated as follows vul pe app1 app2 perm requested app1 perm requested app2 perm exposed app1 perm according to the above expression for the given two apps app1and app2 and the android permission perm the hosting android device is vulnerable to the privilege escalation attack if app1 granted permission perm exposes an unprotected interface to a capability protected by perm while perm is not requested by the other app.
sa f etyrule pestates that the system is safe against the privilege escalation attack if none of the system s apps expose the aforementioned vulnerability or otherwise the unsafe permission of the vulnerable app should remain as not granted as long as malicious app is active.
note the usage of temporal operator square read henceforth3 in the safety rule specified in formula which states that the conditional consequent should hold in all future states.
unsafe pendingintent the second formula sa f etyrule upi specifies the conditions needed to hold in order to prevent the attacks exploiting an unsafe pendingintent recall section .
.
sa f etyrule upi app vic app mal apps p permissions vulupi app vic app mal p granted app vic p active app mal the precondition of rule checks for the unsafe pendingintent vulnerability vulupi which is formulated as follows vulupi app1 app2 perm requested app1 perm requested app2 perm blankpi app1 perm unlike the privilege escalation exploits pendingintent exploits do not require the breached permission to be granted to the vulnerable app prior to the attack.
this is essentially because the required permission is already transferred to the mal app through the pendingintent.
hence the temporal operator read eventually4 is used in the conditional consequent.
according to formula the system is safe against exploiting unsafe pendingintent if there is no such vulnerability or the vulnerable app is not granted with the breached permission.
otherwise the system is unsafe as soon as the mal app is activated.
identical custom permission the third formula sa f etyrule icp specifies the conditions that need to hold to square means is true at all future states means is true in some future state authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a t emporal permission analysis and enforcement framework for android icse may june gothenburg sweden prevent the attacks exploiting the identical custom permission vulnerability recall section .
.
sa f etyrule icp app vic app mal apps p permissions vul icp app vic app mal p installed app mal square granted app mal p installed app vic the precondition of rule checks for the unsafe identical custom permission vulnerability vulicp which is formulated as follows vul icp app1 app2 perm declared app1 perm declared app2 perm recall from section .
that the order of installation matters in the case of identical custom permission.
to formulate this chronological order henceforth temporal operator square is used.
according to rule if a potentially malicious application with a declared custom permission phas been already installed on the device no other app declaring the same permission is allowed to be installed as long as that permission is granted to the first app.
passive data leak the last formula sa f etyrule pdlspecifies the conditions needed to hold in order to prevent the leakage of sensitive data stored in an unprotected app database recall section .
.
sa f etyrule pdl app vic app mal apps p1 p2 permissions vul pdl app vic app mal p1 p2 granted app vic p1 granted app mal p2 passive data leak vulnerability formally defined below vulpdl occurs when a sensitive i.e.
permission protected data is sent out of the device by another app via a typically permission protected channel vul pdl app src app snk psrc psnk data phonedata requested app src psrc retrieve app src psrc data storeunprotected app src data requested app snk psnk send app snk psnk data according to rule the system is safe against the passive data leak if either there is not such a vulnerability or the vulnerable app has never been granted the permission to access sensitive data.
otherwise the system is unsafe as soon as the malicious app is granted the permission allowing the app to send data out of the device.
.
leasing temporal permissions to keep the android device safe against the attack scenarios described in section one should guarantee that the corresponding safety rules hold at all times.
a careful revisit of the safety rules rules reveals that the granted app permission proposition is incorporated in all formulas.5therefore permanently revoking specific permissions can guarantee the safety of the system.
this approach however is too conservative as it revokes app permission even when the other criteria needed for exploitation of security vulnerability is not satisfied.
in other words since granted proposition is qualified in terms of time it is not necessary to satisfy itover all system states.
instead the app permission should only be revoked during specific unsafe states and can be granted in the rest of system states.
5in the safety rule vul upi granted active is logically equivalent to vul upi granted active .based on this intuition we propose a defense mechanism against permission induced attacks called t erminator .
upon receiving a permission request from an app t erminator leases i.e.
temporarily grants that permission to the requester only if granting the requested permission does not violate any safety rule.
the leased permission is automatically revoked as soon as a change in the system status could lead to the violation of the safety rules.
to appreciate the advantage of temporal permissions consider thevictim app in figure a that requires the permission pto accomplish its main functionality e.g.
location permission in a navigator app .
permanently revoking of the permission p by the existing approaches makes this app practically useless.
however a careful investigation of the attack scenario makes it clear that the permission p should only be revoked during the unsafe time slot.
in other words leasing permission p during the safe time slots cannot pose a security risk yet enables the user to take the full advantage of this app.
as a result an analysis and enforcement approach based on temporal permissions provides less disruption in the normal execution flow of apps.
another significant advantage of t erminator attributed to its permission based approach is the high coverage of permissioninduced attacks that it can thwart.
the existing enforcement techniques only consider certain types of breaches thereby fail to protect those attacks carried out differently.
for instance according to a recent study the majority of android security research approaches only consider intent based communications to identify inter component security vulnerabilities while there are other potentially vulnerable communication methods such as data sharing or remote procedure call which could be exploited by malicious apps.
through meticulous regulation of the common element in all such permission induced attacks i.e permissions t erminator is able to effectively thwart all of them regardless of the specific channels exploited by the attackers.
the third distinguishing characteristic of t erminator is its reliability .
by leveraging the dynamic permissions in android our approach avoids any unintended side effects as it is naturally compatible with the development constraints imposed by the latest versions of android.
specifically with the introduction of dynamic permission mechanisms in the latest versions of android an app shouldcontinue to work properly even if the user does not grant some of the permissions requested by the app .
the app in such a case of course performs in a downgraded mode i.e.
with some functionalities disabled.
here we leverage the same feature to revoke an unsafe permission without risking app failure.
terminator in the previous section we introduced the idea of using temporal permissions to provide an effective yet non disruptive defense against permission induced attacks.
this section describes how we realized this idea using android s dynamic permission mechanism.
.
approach overview figure depicts a high level overview of t erminator comprised of two phases analysis and enforcement.
the analysis phase runs once for a set of apps and identifies the potential security risks threatening the android system risk detection .
the enforcement phase runs continuously and prevents the security threats to occur at run time risk prevention .
the enforcement components are deployed as an android app embedded in the device while the analysis components are deployed externally.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. sadeghi et al.
a b 1c d1 ?
e. f .
.
?
a b f ?
figure overview of t erminator framework to identify the potential security threats t erminator relies on the state of the art static analysis tools represented as analysis toolbox in figure .
recall from section .
that the safety rule formulas include the specification of security vulnerabilities.
in terminator analysis toolbox is responsible for analysis of the installed apps and detecting any instance of the atomic propositions listed in figure constituting the security vulnerabilities of the given sa f etyrules.
as discussed in section it is overly conservative to assume that identified security risks could be realized in all states of the android system.
to accurately identify the exact conditions under which the identified risks can be realized t erminator relies on a temporal model checker and tracks down any counterexample violating the safety rules with respect to the state transitions of the system.
the analysis results are then stored in the unsafe traces database.
two components are involved in the enforcement of safety rules state monitor andpermission adapter.
state monitor keeps track of the system states particularly those affecting the security properties of the system and attempts to match the current state of the system against the unsafe traces provided by model checker.
upon detecting the possibility of a security attack permission adapter adopts appropriate countermeasures to prevent the attack from occurring.
for this purpose permission adapter refrains to lease the requested permissions enabling the attack or revokes the previously leased permissions.
once the system moves to a safe state the adapter re grants the previously revoked permissions.
in the next two sections we provide a more detailed description of the components involved in the analysis and enforcement phases.
.
analysis the set of security risks identified by the analysis toolbox are only realizable in specific system states.
the analysis phase of t ermi nator involves identifying those state transitions of the android system that lead to realization of the security risks.
recall from section that we modeled an android system as a transition system m s i r l and formulated the safety conditions of the system as a set of temporal rules i.e.
sa f etyrules .
given an android system m and a temporal safety ruler sa f etyrules terminator is intended to ensure m r. for this purpose the model checker attempts to find any violations in terms of counterexamples of the temporal rules.
to realize the model checker component t erminator uses tlc which is intended to check the specifications written in tla .
tla or temporal logic of actions and its extension tla are originally designed to provide a simple and practical language for high level specifications of concurrent and distributed systems .
tla specifies the behavior of a system as a sequence of states where each state is an assignment of values to variables.
to model the state transitions tla defines next state relation describing how variablesare changed in each step.
for this purpose it uses the primed variable to represent the value of the variable in the next state.
for instance consider the following tla formula defined in terminator to model the state transition of the android system that occurs due to granting the permission perm to an app grant app perm defines perm requestedperms permstat revoked permstat prime permstat except !
granted unchanged appstat in this tla formula two variables are used to model the state of the system permstat representing the current state of the permission configuration for each app and appstat specifying the state of each individual app.
types of those two variables are formally defined via the following type invariant assertion typeinvariant defines appstat permstat apps perms granted revoked formula defines the grant action as an operator with two arguments app andperm .
the first two lines of the formula specify the state conditions enabling the grant action perm should be among the requested permissions of the app and perm should not be previously granted to the app.
if both conditions are satisfied in a state the system can move from that state to the next state described in the third line of the formula.
using the action formulas such as formula the next state of the system is defined as the disjunction of all possible next state actions next app perm defines app apps run app terminate app perm perms grant app perm revoke app perm ... note that in this formula only four next state actions including grant action defined in formula are shown.
to see the full list of tla next state actions defined for t erminator refer to our online documentation .
finally the specification of android system is formulated as follows spec definesinit square angbracketleftappstat permstat angbracketright in this tla formula initrepresents the initial state of the system not shown here where all apps are inactive and all permissions are revoked.
according to the specification formula there are two possibilities for the next state of a system state either one of the actionsincorporated in the next formula formula will take place or the state variables namely appstat andpermstat will leave unchanged.
in addition to modeling the behavior of an android system using the above formulas model checker should reason about the security properties of the system.
more specifically model checker should identify any sequence of actions i.e.
state transitions that leads to the violation of safety rules.
for this purpose the following theorem is defined as the system invariant needed to be checked theorem spec typeinvariant logicalanddisplay rule sa f etyrules according to theorem given the specification of an android system spec all system behaviors should satisfy the safety rules such as rules defined in section .
6in tla those steps leaving state variables unchanged are called stuttering steps authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a t emporal permission analysis and enforcement framework for android icse may june gothenburg sweden in this formula typeinvariant is also added to the theorem to ensure that the model checker only explores the valid states of the system as specified by definition .
having the specification of android system and safety rules in tla tlc model checkers verifies formula .
for this purpose tlc explores reachable states looking for any unsatisfying safety rules.
in case of finding a violation it reports the minimal length trace from an initial state that leads to an unsafe state.
the unsafe traces are then stored in the unsafe traces database in the android device.
.
enforcement state monitor keeps track of the android system states looking for violating traces that match any of the traces stored in the database.
the monitor component is realized as an android app that uses xposed module for collection of runtime data .
the xposed module instruments the root process of android without making any changes in the apps apk files.
the implemented module intercepts those events corresponding to tla action operators defined in section .
.
examples of monitored events include but not limited to granting revoking of a permission via a permission request dialog granting revoking of a permission via system settings and running or terminating an app.
if the state monitor finds a match it marks the matching unsafe trace in the database which triggers the permission adapter component.
the goal of this component is to regulate the permission configuration of apps such that the system remains in a safe state.since the identified security risks are all permission induced it is sufficient to revoke the corresponding risk enabling permissions to thwart the attack.
in its effort to thwart an attack permission adapter may encounter a situation in which there are multiple candidate permissions for revocation.
for instance consider the inter app data leak where a sensitive data protected by the source permission in app1 is leaked through a sensitive channel protected by the sinkpermission in app2.
in this case permission adapter has two choices since revokingeither of the source or sink permissions would prevent the leak form happening.
to provide an effective yetnon disruptive defense against permission induced attacks permission adapter applies the following method to select the best permission.
it first calculates two scores for each candidate permission risk score that reflects the number of attacks enabled by granting the permission.
a permission with high involvement in the identified security threats would have a higher risk score.
the risk score iscalculated based on the analysis results of model checker.
usage score that indicates the usage frequency of the app requesting the permission.
if the permission is requested by an app that is highly used by the user that permission would receive a high usage score.
unlike the risk score the usage score is based on user behavior and calculated by the state monitor component using the android s usage stats service apis.
afterwards permission adapter selects the permission with the highest revoke score which is calculated as a function parameterized by both the risk score and the reverse of the usage score i.e.
f riskscore usagescore .
in other words to prevent a security risk permission adapter revokes permissions with higher security risks that are requested by less frequently used apps.
since t erminator is not aware of the user s context in certain situations the user may disagree with the way in which it prioritizes permissions for revocation.
this might happen for example whenthe user anticipates using a rarely used app.
our implementation allows the user to override the t erminator s decision by adding exception rules.
such rules exclude specific app permissions from being revoked even if they violate the safety rules.
ev aluation our evaluation of t erminator addresses the following research questions rq1.
coverage how does t erminator compare against alternative approaches in preventing the variety of permissioninduced attacks?
rq2.
disruption how effective is t erminator in reducing the unnecessary disruptions due to unavailability of permissionprotected app functionality?
rq3.
applicability reliability what percentage of android apps are compatible with t erminator ?
does the temporal enforcement of t erminator cause any unexpected behaviors?
rq4.
performance what are the performance characteristics for each phase of t erminator ?
.
rq1 coverage for a thorough evaluation we compared the coverage of t ermi nator with the other state of the art approaches enumerated in table under the alternative approaches column.
we considered two criteria in selecting other approaches for our comparative analysis.
first the approach should support both detection and prevention of security attacks.7second the approach should provide a publicly available tool suite.
in accordance with the above criteria we selected three alternative approaches intended to prevent permissioninduced security attacks namely s epar sealant and deldroid .
separ enforces fine grained security policies synthesized by a sat based constraint solver to prevent capability leaks.
s ealant extends android framework to provide an interceptor that blocks potentially malicious intents.
finally deldroid uses a multiple domain matrix to eliminate the security vulnerabilities violating the least privilege property of the system.
to eliminate bias in favor of t erminator we built a collection of subject apps consisting of the apps used in the evaluation of the three mentioned prior approaches as well as a reputable benchmark collection namely droidbench .
the resulting dataset consisted of a collection of subject apps with known security issues.
out of this collection of apps we selected those that target android .
api level or newer versions.
older versions of the android framework provide just a static permission model and do not allow users to dynamically grant or revoke permissions at run time.
we then ended up with a total of apps suitable for our experiments.
to evaluate the extent t erminator can prevent security attacks we executed the attack scenarios from our dataset on an android phone running t erminator .
recall from section t erminator relies on static analysis tools to identify the potential security threats.
in our experiments we used a combination of two static analysis tools namely flowdroid and ic3 that have also been used in the construction of three prior approaches to which we compare.
table shows the result of assessing the effectiveness of t ermi nator compared to the state of the art techniques.
the first three columns of table show the attack scenarios their source dataset and the permissions involved in the attack scenarios respectively.
7approaches such as iccta jitana c overt dialdroid etc.
are excluded in our study as they only perform detection not prevention.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. sadeghi et al.
table ability of t erminator in preventing permission induced attacks in comparison with alternative approaches.
permission induceddata setinvolvedterminatoralternative approaches attack type subtype permissions separ deldroid sealant custom permission dd storage sms squaremultiply square square square privilege escalation db location storage squaremultiply squaremultiply squaremultiply squaremultiply passive content leak cp dd storage sms squaremultiply square square square passive content leak cp dd sms squaremultiply square square square passive content leak cp dd storage sms squaremultiply square square square privilege escalation db read phone state storage squaremultiply squaremultiply squaremultiply squaremultiply custom permission dd storage sms squaremultiply square square square privilege escalation ah dd storage sms squaremultiply square squaremultiply boxcircle privilege escalation dcl dd storage sms squaremultiply square squaremultiply boxcircle custom permission dd sms squaremultiply square square square passive content leak cp dd storage sms squaremultiply square square square privilege escalation pr sp wake lock squaremultiply square squaremultiply square privilege escalation pr dd set wallpaper squaremultiply square squaremultiply square custom permission dd storage sms squaremultiply square square square privilege escalation sl sms squaremultiply squaremultiply squaremultiply squaremultiply passive content leak cp dd storage sms squaremultiply square square square privilege escalation bt sp wake lock squaremultiply square squaremultiply square privilege escalation sl location squaremultiply square squaremultiply squaremultiply privilege escalation sh dd sms squaremultiply square squaremultiply squaremultiply privilege escalation pr dd location sms squaremultiply squaremultiply squaremultiply boxcircle privilege escalation sl contacts squaremultiply square squaremultiply squaremultiply custom permission dd storage sms squaremultiply square square squaremultiply privilege escalation pr dd location sms squaremultiply squaremultiply squaremultiply squaremultiply privilege escalation mal dd sms squaremultiply squaremultiply squaremultiply square privilege escalation db location storage squaremultiply squaremultiply squaremultiply squaremultiply privilege escalation sl location squaremultiply square squaremultiply square privilege escalation pr dd sms squaremultiply square squaremultiply squaremultiply privilege escalation db read phone state storage squaremultiply squaremultiply squaremultiply squaremultiply passive content leak cp dd sms squaremultiply square square square privilege escalation db read phone state storage squaremultiply squaremultiply squaremultiply squaremultiply privilege escalation pr dd sms squaremultiply squaremultiply squaremultiply square privilege escalation pr dd location squaremultiply square squaremultiply squaremultiply privilege escalation dcl dd storage location squaremultiply square squaremultiply square passive content leak cp dd storage sms squaremultiply square square square privilege escalation ah dd storage squaremultiply square squaremultiply square custom permission dd storage sms squaremultiply square square square privilege escalation db read phone state sms squaremultiply squaremultiply squaremultiply squaremultiply privilege escalation ah dd storage squaremultiply square squaremultiply square privilege escalation db access fine location squaremultiply squaremultiply squaremultiply squaremultiply privilege escalation db location storage squaremultiply squaremultiply squaremultiply squaremultiply custom permission dd sms squaremultiply square square square total thwarted attacks coverage true positive rate .
.
.
squaremultiply square attack scenario is not prevented by the approach boxcircle the approach crashed during the analysis attack subtypes pr permission re delegation ah activity hijack sh service hijack bt broadcast theft mal malicious activity lunch dcl dynamic class loading content provider cp data sets dd deldroid sl s ealant sp s epar db droidbench the other columns indicate whether each of the four approaches assessed was successful in preventing the attack squaremultiply or not square boxcircle .
according to the results t erminator is able to prevent all the attack scenarios with no false negatives.
the success rate of the other techniques in preventing the permission induced attacks ranges from .
to .
.
a detailed look at table indicates that most ofthe missing attacks are those whose detection requires temporal analysis.
for instance consider the attack scenario where a malicious application has defined a custom permission identical to the permission defined by a vulnerable app to protect its internal database.
as a result the malware can illegally access sensitive information stored in the vulnerable app.
this vulnerability however is only exploitable if the malware is installed before the victim app.
thereby all prior non temporal approaches fail to detect such attacks.
to tackle this issue a conservative approach might prevent the aforementioned attack by permanently revoking database access of the victim app.
this approach however would cause unnecessary disruptions particularity when the vulnerability is not exploitable i.e.
the victim app is installed before malware in this case.
in the next research question rq2 we investigate the consequences of permanently revoking the permissions of vulnerable apps through additional experiments.
.
rq2 disruption for this research question we focus on alternative permission based enforcement techniques.
generally speaking permission based security enforcement can be applied at install time or run time .
an install time approach prevents the installation of vulnerable apps while a run time approach revokes the permissions upon identification of an attack scenario.
run time approaches can further be either permanent whereby the permission decisions are final ortemporal as in the case of t erminator whereby the permission decisions are adjusted over time.
since the prior tools implementing the competing techniques are either not available as is the case with appfence and appguard or outdated and inapplicable as is the case with kirin we implemented both install time and permanent run time enforcement approaches described in the prior work to compare against t erminator s enforcement strategy.
to evaluate the level of disruption due to unavailability of permission protected app functionality we needed access to legit imate use cases for apps in our dataset.
attack scenarios used in the evaluation of rq1 are not representative of the apps functional use cases thereby they are not suitable for evaluating the level of disruption caused by the revocation of app permissions.
to that end we followed a semi systematic approach to extract functional usecases for the vulnerable apps in our dataset.
we first downloaded the description of subject apps from the app markets google play or f droid .
we then asked a group of graduate students to construct if possible functional use cases for each sentence or bullet in the app description.
additionally we used available system tests for opensource subject apps as another source for identifying the legitimate use cases.
in total we were able to derive legitimate use cases for subject apps in this research question.
the full set of use cases and subject apps are publicly available on the project website .
to measure the disruptions caused by the two run time approaches we first executed the attack scenarios from table to instigate an enforcement decision i.e.
force the approach to adjust the permission configuration.
subsequently we ran the legitimateuse cases involving the apps in the attack to determine if the usecases can be executed successfully or not.
table summarizes the results of comparing different enforcement strategies for permissionbased approaches.
the first column shows the subject apps.
the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a t emporal permission analysis and enforcement framework for android icse may june gothenburg sweden table efficacy of permission based techniques in reducing the unnecessary disruptions.
vulnerable apps use allowed scenarios cases run timeinstall timetemporal permanent de.
.geobookmark com.
.multismssender com.
.calendar com.
.smsscheduler org.
.trackbook com.
.simpledeadline com.getback gps com.
.camera com.
.gallery com.
.manager com.
.anki com.
.screennotification com.
.notes cz.
.forcastie com.
.loginexample com.
.sms com.
.opps wrong tab code.
.sendsmstest org.
.myexpenses com.
.ukweather com.
.client fr.
.ommons total allowance disruption false positive rate .
second column shows the number of legitimate use cases for the subject apps.
the last three columns show the number of use cases allowed by each approach.
the results from this analysis confirm that the run time temporal approach adopted in t erminator outperforms other enforcement techniques in terms of unnecessary disruption i.e.
false positive rate.
the install time enforcement approach performs worst false positive as it does not allow the installation of a vulnerable app.
the run time permanent approach with false positive on the other hand allows installation yet revokes unsafe permissions permanently.
therefore some of the legitimate permission protected use cases can never execute after revocation even in the absence of a security threat.
for example the security analysis performed by t erminator identified getbackgps app com.getback gps in table as being vulnerable to privilege escalation attack attack scenario in table whereby its sensitive location information can be leaked.
this vulnerability is only exploitable if two conditions are satisfied simultaneously a malware app with access to a sink channel e.g.
sms is installed and running on the phone and the malware has been granted the sink permission.
since the app is vulnerable the install time approach simply does not allow its installation to avoid any chance of leaking user s location information.
the runtime permanent approach on the other hand allows the installation of getbackgps yet permanently revokes its location permission to remove the vulnerability.
our run time temporal enforcement approach however leases location permission to getbackgps as long as the above conditions are not satisfied during which all of the legitimate use cases of the app are available.
.
rq3 applicability reliability .
.
applicability .
recall from section .
t erminator relies on the dynamic permission mechanism supported by android and newer versions of the framework to regulate app permissions at runtime.
however not all the apps available on the android marketplace are compatible with the new versions of android.
to investigate the extent to which t erminator is applicable to android apps we measured percentage of the apps on the official android marketplace i.e.
google play that target api level android and above.
to that end we randomly collected apps from different app categories and distinguished android compatible apps by examining the targetsdkversion tag specified in their manifest file.to avoid any bias in the results we did not use any particular criteria such as high popularity or high ranking in selection of the apps to beanalyzed.
table demonstrates percentage of the apps targeting api level and above among the apps collected from different app categories of the google play repository.according to the results on average .
of the g.play apps support dynamic permissions.
to further investigate the support for dynamic permissions among popular apps we also collected top popular apps on googleplay.
as shown in the last column of table all of the top apps on google play support dynamic permissions thereby are compatible with t erminator .
these results indicate that a large majority of the apps on the android official marketplace can benefit from t erminator for run time security enforcement.
.
.
reliability .
although the majority of collected apps support android and above it is possible that they do not properlyhandle dynamic permissions.
failing to adjust the functionality of an app to dynamic permissions can lead to unexpected behaviors e.g.
app crashes if the user decides to revoke a permission.
hence we also need to investigate the reliability of adopting an approach like t erminator which revokes permissions at run time.
to investigate reliability of t erminator we recorded logcat outputs during the execution of both the attack scenarios and canonical use cases for subject apps discussed in rq1 and rq2.
we later explored collected logs searching for any crash messages due toimproper handling of dynamic permissions.
out of the subject apps in our dataset we found one app sms scheduler marked with in table that crashes due to the permission revocation.
from this data low percentage around .
of apps crashing when revoking their permissions and high percentage around .
of app compatibility with recent versions of android we conclude that t erminator can reliably be applied to a large majority of android apps available on the market.
.
rq4 performance to examine the performance characteristics of t erminator w e measured the execution time taken for each phase of t erminator i.e.
analysis andenforcement .
we performed our experiments on a pc with an intel core i7 .
ghz cpu processor and gb of main memory for the analysis phase and a nexus 5x phone operated by the android framework version for the enforcement phase.
tlc is configurable in two operating modes simulation and model checking.
in the simulation mode tlc verifies the system behavior up to a fixed number of system states.
in the model checking mode on the other hand there is no limit for the number of states to be explored.
applying an upper bound over the state exploration may lead to the possibility of missing attacks concealed within states not explored.
we configured tlc to operate in the simulation mode to guarantee the termination of the analysis phase.
this guarantee is required for t erminator given that the reachable states of our model for the android system is infinite.
in our experiments t ermi nator was able to identify all of the attack scenarios see table .
for these attack scenarios tlc took at most seconds to find the attack through the exploration of over states.
to determine the performance of the enforcement phase we calculated the overhead of running monitor and adapter components of t erminator during the execution of attack scenarios and canonical use cases scenarios exercised in rq1 and rq2.
we repeated the execution of each scenario times to ensure confidence interval for the reported values.
according to our experiments the run time overhead of t erminator enforcement phase authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden a. sadeghi et al.
table percentage of android compatible apps in google play randomly selected by categoryaveragetop art books finance food health maps music news photo shopping social tools video weather game .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
is milliseconds on average for each use case.
given that the average execution time for each use case is seconds this overhead is negligble as it is less than the threshold users can perceive slowness in an app according to offical android documentation .
note that the analysis phase is performed once per system configuration while the enforcement component runs continuously as the user interacts with the apps.
related work we provide a discussion of the related efforts in light of our work.
assessment of security properties.
a large body of research focuses on performing security analysis in the context of android.
using a taxonomy sadeghi et al.
classified over research papers for security assessment of android apps.
according to this taxonomy our work is classified under the group of research that leverages formal analysis to reason about security properties of a system.
several approaches under this category leverage formal methods to abstract the semantics of application code and express the security properties of the apps.
using the derived model of the program this group of techniques are able to identify security issues such as data leakage.
another group of formal approaches perform the security analysis at a higher level of abstraction i.e.
architectural level.
this thrust of research model an android system as a set of components that communicate with each other through connectors.
working at this level of abstraction allows the research to detect more involved security attacks such as privilege escalation attacks or app collusion.
in contrast to terminator all of the prior formal approaches fail to incorporate the notion of time in their model of android permissions that is they assume all requested permissions are permanently granted to an app as soon as the user accepts to install the app.
enforcement of security policies.
in addition to the security analysis t erminator enforces policies at run time.
similar to our work a plethora of approaches h a v e been constructed to enforce security policies in android devices.
in their survey of security solutions for android sufatrio et al.
categorized this group of research based on the security attacks they can prevent.
in another study heuser et al.
classified this group of research based on the authorization hook semantics.
to enhance the security of the system the proposed techniques place additional constraints on different elements of android system from inter component communication icc to network access and content providers .
hence each technique might fail to protect those attacks carried out through the other channels that are not hooked by the approach.
for instance intent based preventive methods are not able to prevent interapp security attacks exploiting unprotected content providers.
by identifying and thwarting the root cause of all permission induced attacks i.e.
unsafe permission terminator is able to prevent all of them regardless of the type of vulnerable elements being exploited.
moreover due to modification of android framework or individual apps the prior approaches are prone to place the app in an unexpected state or even cause itto crash.
t erminator avoids any such side effect as it relies ondynamic permission mechanism which is officially provided by the android framework and adopted by app developers.
enhancement of permission model.
the other relevant thrust of research has focused on enhancing the permission model of android in order to mitigate the risk associate with permission misuse.
a comprehensive study of permission induced security issues along with the proposed countermeasures are provided by fang et al.
.
coarse granularity is a shortcoming of android permissions discussed in several research papers.
to overcome this issue several finer grained implementation of permissions have been proposed .
dissimilar to this group of the approaches that limit the scope of permissions to specific components termina torrestricts the availability of permissions over the time dimension.
to enhance the permission mechanism of android several approaches provide easy to use interfaces that allow users to selectively grant permissions to apps.
beside thefact that such feature is officially supported by the android ver sion and above enabling users to revoke permissions either via android s build in interface or through the academic approaches is not a solution for security enhancement of the system.
rather it shifts the problem from installation time to run time.
the users still do not know when it is safe to grant a requested permission to an app.
using temporal permission terminator lets user take full advantage of app functionality while protecting them against permission induced attacks.
conclusion and future work we presented a permission analysis and enforcement framework that in contrast to the prior work considers the temporal aspects of permission induced attacks for their detection and prevention.
the framework called t erminator is realized in two phases.
in the analysis phase it uses a temporal logic model checker to identify the security risks with respect to dynamic states of the system.
in theenforcement phase it relies on android s dynamic permission mechanism to prevent the identified security threats from materializing by regulating the permission configuration of the system.
our evaluation results indicate that t erminator is able to provide an effective yet non disruptive defense against permission induced attacks.
the results also show that our approach which is implemented without modification of android framework or implementation logic of apps is highly reliable and compatible with the great majority of android apps available on the marketplace.
in this work temporal rules are enforced at the app level meaning that permissions are leased to the whole app.
a more fine grainedtemporal rule that reduces an app s attack surface further through leasing permissions to a subset of its components is potentially an interesting avenue of future research.
acknowledgement this work was supported in part by awards ccf cns1629771 and ccf from the national science foundation hshqdc c b0040 from the department of homeland security andfa95501610030 from the air force office of scientific research.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
a t emporal permission analysis and enforcement framework for android icse may june gothenburg sweden