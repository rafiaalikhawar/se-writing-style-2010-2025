parti a multi interval theory solver for symbolic execution oscar soria dustmann comm.
and distributed systems rwth aachen university germany dustmann comsys.rwth aachen.deklaus wehrle comm.
and distributed systems rwth aachen university germany wehrle comsys.rwth aachen.decristian cadar department of computing imperial college london uk c.cadar imperial.ac.uk abstract symbolic execution is an effective program analysis technique whose scalability largely depends on the ability to quickly solve large numbers of first order logic queries.
we propose an effective general technique for speeding up the solving of queries in the theory of arrays and bit vectors with a specific structure while otherwise falling back to a complete solver.
the technique hastwo stages a learning stage thatdetermines the solution sets of each symbolic variable and a decision stage that uses this information to quickly determine the satisfiability ofcertaintypesofqueries.themainchallengesinvolvedeciding which operators to support and precisely dealing with integer type casts and arithmetic underflow and overflow.
weimplementedthistechniqueinanincompletesolvercalled parti partial theory solver for intervals directly integrating it into the popular klee symbolic execution engine.
we applied kleewithpartiandastate of the artsmtsolvertosyntheticand real world benchmarks.
we found that parti practically does not hurt performance while many times achieving order of magnitude speedups.
ccs concepts theory of computation constraint and logic programming softwareanditsengineering softwaretestingand debugging keywords constraint solving symbolic execution multi intervals acm reference format oscar soria dustmann klaus wehrle and cristian cadar.
.
parti amulti intervaltheorysolverforsymbolicexecution.in proceedingsof the 33rd acm ieee international conference on automated software engineering ase september3 montpellier france.
acm new york ny usa 11pages.
introduction symbolic execution is a popular testing and analysis technique whichhastheabilitytoexploremultiplepathsintheprogramunder permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september montpellier france copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
.at ahighlevel symbolicexecutionrunstheprogramon symbolicinput whichisinitiallynotconstrainedtoanyparticularvalue.whenever executionreachesabranchthatdepends directlyorindirectly on thesymbolicinput executionmaybesplitintwo onthe thenpath theinputisconstrainedtosatisfythebranchcondition e.g.
x whileonthe elsepathitisconstrainedtosatisfythenegationofthe branch condition e.g.
x .
on each path a constraint solver is used to determine whether the current conjunction of constraints collected at each branch called the path condition is satisfiable.
if itisnot thatpathisterminatedasitisinfeasible.finally whena pathfinishesexecution aconstraintsolvercanprovideasolution for the path condition which represents a test input that can be usedtoreplaythecorrespondingpath e.g.
fordebuggingpurposes.
the effectiveness of symbolic execution depends directly on the effectiveness of the underlying constraint solver as often morethan of the total execution time of a symbolic execution engineisspentinthesolver .modernsymbolicexecutiontools rely on existing satisfiability modulo theory smt solvers which can answer satisfiability problems in a given theory e.g.
linear arithmetic.
perhaps the most popular theory employed by modern symbolicexecutionenginesisthatofquantifierfreearraysand bit vectors qf abv asitcanbeused toprecisely model the semantics of popular programming languages such as c c or java and we will therefore consider only this theory in the remainder of this paper.
state of the art smtsolvers such as boolector stp and z3 generally start with a pre processing and optimisation stage in which an instance of qf abv is simplified using various strategies followed by a bit blasting stage in which the query is translated from the level of the theory to that of a boolean satisfiability sat problem.whilethepre processingandoptimisation stage tries to exploit the characteristics of the theory it is oblivious to those of the queries generated during symbolic execution.
as a result symbolic execution engines perform their own pre processingandoptimisationstagebeforeinvokingtheunderlyingsmtsolver.
examples include performing simple arithmetic simplifications cachingsolutions exploitinglogical implications and rewriting complex array constraints .
inthispaper weintroduceanewconstraintsolvingoptimisation techniqueforsymbolicexecution implementedinanincomplete solver called parti partial theory solver for intervals which aimstoexploitconstraintsolvingquerieswhosesolutionscanbeexpressed as the union of a small number of intervals.
hence parti provides a mechanism to solve only a subset of smtproblems fast and resorts to an off the shelf solver for other queries.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france oscar soria dustmann klaus wehrle and cristian cadar instance such queries are generated by inequality conditions involvingasymbolicinputandaconstantvalue andareprevalentin real programs as indicated by our evaluation cf.
.
furthermore theyoftenoccurinsomesymbolicexecutionimplementationsin thepointerresolutionstage whendeterminingvalidobjectsofa symbolic pointer value.
at a high level when deciding a query parti keeps track of all possible values for each symbolic variable.
for instance the solution set of an unsigned bit integer symbolic variable xcould be .
if laterxis constrained to be greater than byfollowingthe thensideofthebranch if x itssolution set becomes just as none of the values in satisfy x .withanefficientrepresentationofthesolutionset parti can quickly solve certain types of queries and bypass the more expensivecompletesolver.e.g.
itcanquicklydeterminethatthe queryx 200isunsatisfiable sincethevaluesfor xarein .
the first challenge is to precisely deal with integer type casts and arithmetic underflow and overflow.
to better understand this challenge consider our previous example where valid solutions arex .i fxis now type cast to a signed bit variable y with a range of the solution set for yis as some values in overflow.
thesecondchallengeistheselectionofsupportedoperandsand anefficientrepresentationofthesolutionsetinordertobalanceapplicability and performance the sketched approach clearly cannot efficientlysolveeverysingle smtqueryastheexplicitderivationof thesolutionsetofallvariablesisimpossibleinthegeneralcaseand even when possible it may lead to exponential blowup depending on the representation of the solution set.
our contribution is firstly a scheme for effectively reasoning aboutsuchintervalqueriesinthecontextofsymbolicexecution together with a comprehensive analysis of the operations that we decide to handle secondly an implementation of the presented techniqueandathoroughevaluationoftheperformancegainsit can achieve.
preliminaries we denote a qf abv smt queryqas a pair e c whereeis a query expression whose satisfiability we try to determine and cis thesetofconstraintsthatareknowntohold.forexample thequery eq a ule a ule a isansmtquerythatissatisfiable but not a tautology cf.
table .
if the solution set for a variable x is independent from other variables we denote its solutions as llbracketx rrbracket e.g.
llbracketa rrbracket .
each expression has a bit width.
e.g.
eand all expressions in c havebit width1 i.e.theyarebooleanexpressions.werepresent an expression by an abstract syntax tree ast .
this tree consists of internal vertices representing operators combining one or more sub expressions e.g.
add and leaf vertices representing either a constant e.g.
const or a read from a free variable e.g.
read x .
for readability we may omit explicitly specifying thereadandconstoperators.notethattheremaybeseveralreads with different offsets and bit widths from a free variable in one ast butwerestrictpartitosuchqueriesthathavenopartially overlapping reads for any given variable.table the relevant qf abv operators for this paper.
full smt encompasses a longer list including e.g.
modulo.
operator children semantics const leaf constant value read leaf free variable lshr logical right shift not negation zext sext1 unsigned signed type conversion add sub2 addition subtraction eq equality mul multiplication ule sle2 unsigned signed less than or equal to ult slt2 unsigned signed less than the list of relevant operators discussed in this paper is depicted in table .
note that all queries are assumed to be normalised to exclude operators such as not equal as these can be trivially lowered to the given operators.
core design parti has been designed to enable very fast solving of a subset ofsmtquerieswithastructurethatmanyprogramsproducefrequentlyduringsymbolicexecution.thatis partiattemptstosolve aquerybutmaygiveupatanytimewhileprocessingtheexpression ortheconstraints.thiswillbecommunicatedtoacomplete smt solverwhichactsasafall back.wedistinguishbetween complete solvers that givenenoughresources cansolveall smtqueries and incomplete solvers suchasparti thatcanonlysolve efficiently a subsetofsmt.inthissection wecharacterisethesubsetsupported by our incomplete solver and describe its operation in detail.
.
overview weassumethatthesolverispresentedwithaquery qconsistingof anexpressionandasetofconstraints asdefinedin .theresultof the solver can either be always true always false true or false or unknown .
if is returned the query could not be solved and a complete solver must be consulted.
as parti is an incomplete solver by design it has some limitations as to which queries it can answer.
this is reflected in the operatorsitcanprocess.forinstance themodulooperatorisentirelyunsupported whileotheroperatorsmaybesupportedonly insomecases.hence atanymoment whenweencounterapart ofthequerythatcannotbeprocessed partiimmediatelyaborts processing the query and returns .
the operation of parti is divided into two stages learning and decision.beforewediscusstheindividualstepsindetailin .
and .
wefirstillustratethegeneralideaofthesestagesbyprocessing the following example query eq add x y ule x ule x ule sub y authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parti a multi interval theory solver for symbolic execution ase september montpellier france lh2 am y squigglerightam y squiggleright y figure processing the constraint ule sub y in the learningstage whereconstraintsareprocessedtop downin order to derive information about the solution sets of variables yin this case.
x 2y squiggleright1 2y squiggleright1 y figure two steps in evaluating the query expression in the decision stage.
the expression will eventually evaluate to .
as opposed to the learning stage cf.
figure an expression is processed bottom up in the decision stage.
.
.
learningstage.
duringthelearningstage partiextracts information about all involved symbolic variables from the constraints.
we assign to each variable xa structure angbracketleft x angbracketright which representsanapproximationofthesolutionset llbracketx rrbracket.witheachprocessed constraint angbracketleft x angbracketrightis refined reaching anexact representationof the admissible values for xonce all constraints have been processed.
hence untilallconstraintshavebeenprocessed angbracketleft x angbracketrightremainsan approximation of x s solutions llbracketx rrbracket.
for the subset of constraints ule x ule x we have llbracketx rrbracket .
while learning the first constraint we would record angbracketleft x angbracketright .
then when processing the second constraint this approximationwouldberefinedto angbracketleft x angbracketright llbracketx rrbracket where maxcorresponds to the maximal value of x s type.
eachconstraintisprocessedtop down thatis theinitialimplicit truth value of the expression is recursively pushed down along the ast as illustrated in figure the expression ule sub y mustevaluateto astheconstraintisknowntobetrue.therefore itcanbereasonedthatitsleftoperand sub y mustevaluate to .
this in turn implies that ymust evaluate to .a syis aleafexpressionthatcannotbetakenapartanyfurther wehave learnt that angbracketleft y angbracketright and necessarily llbrackety rrbracket .
the result of the learning stage is an exact solution set for all relevant variables.
.
.
decision stage.
in the second stage all occurrences of variablesinthequeryexpressionaresubstitutedwiththeirsolution setandthetreeissubsequentlycollapsed asdepictedinfigure .
giventheconstraintsover xandylearnedabove theexpression eq add x y is first substituted with eq add y .
afterwards by evaluating the solution sets of the addexpression and substituting y we obtain eq which in turn may be true as and have a non empty intersection e.g.
or false as we can choose different representatives from each of thesets e.g.
6and10 .thisleavesuswiththesolutionset meaning that the query expression can be both true or false.
in summary wefoldverticesinthe astinabottom upfashion until thetop mostoperatorisevaluated.asimplelinear timepost order walk through the ast is sufficient to decide the given expression.
theresultof thedecisionstageandtheoverall resultofparti is a value in as discussed above.
.
representation of solution sets after having presented the general overview of the solving algorithm we now motivate the design of its primary data structure multi intervals bystudyingtherequirementsthatarisewhentrying to represent a simple solution set.
.
.
signedness.
inoursetting symbolicvariablesareuntyped withregardtotheirsignednessandhaveafixedbit width cf.
.
hence theirsemanticvaluedependsontheoperatorusingthem or their sub expressions and might therefore implicitly change depending on the context.
assume for instance a one byte symbolicvariablewithasolutionsetwiththebit vectorrepresentation b b .whenusedinasignedcontextthiscan be expressedwith theinterval as11111111 bis interpreted as and bas and we have and no integer between and .
however if in an unsigned context b would be interpreted as for which holds that and thus the interval would be ill formed while would be incorrect.
in an unsigned context the same solution set cannotbe represented as a single interval.
the same problem can arise analogously when casting from unsigned to signed.
.
.
multi intervals.
weobservethatkeepingasingleinterval isinsufficientevenforverysimpleproblems.asshownabove sign conversion alone is sufficient to illustrate this limitation but it also applies to all operators that can result in integer overflows.
for instance the operation add x y for llbracketx rrbracket and llbrackety rrbracket results in llbracketadd x y rrbracket for bit variables in an unsigned context.
a sufficiently expressive representation is to rather than using a single interval keep a set of intervals for each variable a multi interval.
however this repr esentation allows for exponential blowupifthesetofsupportedoperationsisnotchosencarefully.
forthisreason weaddsomefurtherrestrictionsinthedesignofthe algorithm and choose to explicitly not implement some operators that in theory could be represented by this data structure.
weencodemulti intervalsassortedsetsofpairsofintegerssuch that the individual intervals never overlap.
for instance the unsignedadditiondepictedabovewouldresultinthemulti interval angbracketleft angbracketrightu8.notethatmulti intervalsmaybetyped wedenotethetypeassubscript e.g.
u8 asinthisexample indicatingan bit unsigned integer.
analogously an sindicates a signed integer.
weomitannotatingthetypeifitisinconsequential.thecardinality h of a multi interval h denotes the number of intervals it contains forexample angbracketleft angbracketright .weusethepreviouslyintroduced angbracketleft x angbracketrightnotationinordertoreferto x smulti interval angbracketleftbig ... angbracketrightbig .
inthefollowing wepresentallsupportedoperatorsinthelearning stage .
and the decision stage .
discussing both the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france oscar soria dustmann klaus wehrle and cristian cadar table cost incurred while processing each supported operator.
in the learning stage we process an expression op e c v withnthe cardinality of the multi interval representing vandmthecardinalityofthecurrentsolution set.
in the decision stage niis the cardinality of the multiinterval for the ith argument.
operations marked with an asterisk are only partially supported.
section operator output size computation learning stage .
.
eq not o .
.
ult slt ule sle1 o .
.
add sub n o n .
.
mul n o n .
.
zext sext n o n .
.
read max n m o n m decision stage .
.
eq o n1 n2 .
.
not o .
.
ult slt ule sle1 o .
.
zext sext n1 o n1 .
.
add sub n1 n2 1o n1 n2 .
.
lshr div max n1 n2 o n1 n2 .
.
mul max n1 n2 o n1 n2 computational complexity of each operator and the sizes of theresulting multi intervals.
we summarise all operators in table .
in .5we end our analysis with an overview of the algorithm s limitations.
.
operations for the learning stage to obtain the admissible multi interval for each symbolic variable weextractitfromallconstraintsduringthelearningstage.here eachconstraintisprocessedindependently refiningthepreviousap proximation.
after the last constraint is successfully processed the extracted multi interval will exactly as opposed to approximately reflect the solution set.
the top down approach presented here is restricted to binary caterpillartrees containing asingle read.such binarycaterpillar trees i.e.
trees where each branch has one side with depth occurofteninpractice asshowninourevaluation.however ifanyconstraint with a different type of tree is encountered the learning stage will be aborted and returned.
whilewedescendsuchatree foreachbinaryoperator opwe alwayshaveaconstantside candasidewithanarbitraryexpression e aswellasanassignmentofavalue v denotedas op e c v.w e derivetheadmissiblevaluesfor ebyinspecting c v and op.initially everyconstraintisimplicitly trueatthetop mostlevel therefore it is of the form op0 op1 e c1 c0 v0withv0 .f r o m c0we canthen derivea newvalue v1depending onthe semantics ofop0and recursively process op1 e c1 v1.
finally we have e v2withv2derived from v1 c1and the semantics of op1.
.
.
equalityandlogicalnegation.
consider w.l.o.g.
eq e c v wherevmaybeeither or .forv theremainderoftheconstraintcanbeignoredasitisirrelevantwhether it holds or not.
if vis we can simply continue recursively withe c.i fvis the solution set is c i.e.
a multi interval containing exactly all values that cdoes not contain.
as the multiinterval angbracketleft c angbracketrightmustbeoftheform angbracketleft angbracketright thisset minusoperation can be computed in constant time and its size is bound by .
the logical negation not e vcan be lowered to eq e v aseandvmustbeone bitvalues.thus if not e isassigned v then this is equivalent to enot being equal to v which in turn is expressed by assigning toeq e v .
the same bounds as for eqapply.
.
.
comparison.
assumeacomparison l e c vwith l ult ule slt sle .
the inverse case l c e vis analogous.
again v may be disregarded as the expression would be a tautology.
if we have v we may recursively continue by learning e whereais the minimum of the respective datatypeof l e.g.
128foran8 bitsignedtype.thisisbecause the constraint l e c only imposes some upper bound con the sub expression e while not imposing any lower bound.
for the same reason bis eithercorc depending on whether or not the operation is a less than or less than or equal to operation.
so istheintervalmatchingthe typeof landindicatingthat e s upperboundis c.thesizeoftheresultingmulti intervalistrivially exactly and is computed in constant time.
.
.
addition and subtraction.
the subtraction operator is analogous to the addition operator so we will only investigate add e c v. observe that now vis not limited to a boolean value but may be an arbitrarily complex multi interval.
in order to continuetherecursionwith e wwemustdetermineasuitable w.logically wehave e c v e v c w sowfollowsas thedifferencebetweenthemulti intervalrepresenting vandc.asc isstilllimitedtoaconstant theoperation v ccanbecomputedin lineartime bysubtracting cfromallintervalsin v.thismaycause atmostoneintervaltospantheunderflowpointandhencebesplit into two.
all other intervals invcan trivially be transformed to .theexpressionisthencontinuedtobeprocessed recursively e w v c.hence theresultingmulti interval w is computed in linear time and is bound by v .
.
.
multiplication.
by the same logic as with addition and subtraction operators mul e c vis resolved by a division of v byc.
due to the nature of multiplication some intervals may be mergedor dropped leadingto the resultingmulti intervalhaving angbracketleft w angbracketright angbracketleft v angbracketright .
as with add mulhas linear complexity.
ontheotherhand a div e c vremovesinformationfrom e. hence this operation cannot be reversed efficiently in this context asrepresentingallcorrectsolutionsinamulti intervalwouldpotentiallyleadtoalargenumberofintervals so divisnotsupported by parti.
.
.
typeconversion.
therearetwokindsoftypeconversions asign cast changing the signedness of an expression and a type castchanging the bit width of an expression.
for each of these we distinguishtwocases.forasigncast wecanbecastingfromsignedtounsignedorvice versa whileforatypecastwemightbecasting down that is reducing the number of bits or casting up that is extendingthenumberofbits.w.l.o.g.weonlydiscussunsigned authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parti a multi interval theory solver for symbolic execution ase september montpellier france typecastsassignedtypecastsareanalogousandcanbeloweredto unsigned type casts.
hence we assume an operation zext e v where the expression zext e has sizekandehas sizek prime.
in the case of an upcast the operator extends the number of bits.
when traversing it backwards the argument v primeof the recursive calle v primeis restricted in the number of bits i.e.
k prime k. this canbeeasilycomputedbytruncatingtheintervalsthatexceed 2k primesuch that they are bound by 2k prime.
the resulting multi interval v primeis computed in linear time and v prime had an upper bound of v .
inthecaseofadowncast theoperatorwouldremoveinformation.
therefore the multi interval that would correspond to e cannot be computed from the multi interval that corresponds to zext e without risking an exponential blowup.
asan illustratingexample fromtheinformationthatanexpression eoftype u16 satisfies eq zext u8 e we can derive the solution set ... whichcannotbeefficientlyrepresented by a multi interval.
hence this operation is not supported.
.
.
leaf operators.
once the tree has been descended to the onenon constantleaf wehaveanoperationoftheform read x vwithvguaranteedtomatchthewidthofthereadastypecasts arealwaysexplicit.hence ifthisisthefirstprocessedconstraint touchingvariable x themulti intervalof vcanbedirectlyrecorded as angbracketleft x angbracketright thecurrentapproximationofthesolutionsetof x.incase xhasalreadybeenreadbyapreviouslyprocessedconstraint we ensure that the offset and size of the previous read s either match the new read s offset and size exactly or read disjoint bytes cf.
.
anypartialsolutionsetcannotbeextendedbyfutureconstraints but only restricted.
the result of applying the information from thenewmulti intervalcorrespondstotheintersectionofthecurrentsolutionsetwiththenewmulti interval.asamulti interval is a sorted sequence of intervals the intersection of two can be computed in linear time.
.
operations for the decision stage we next describe the operations that are employed during the bottom up decision stage after the learning stage has finished.
a summary of all operators supported in the decision stage together with the size of the output multi interval and the associated computational cost is given in the bottom part of table .
.
.
equality.
whentwosymbolicvariables a barecompared for equality eq a b it is insufficient for them to merely share the exact same solution set to return .
they must both have thesame singleton solutionset asotherwisetheymightevaluate to differing values.
hence only if both multi intervals are of the form angbracketleft angbracketright forsomeconstant k theresultis .conversely if their non singleton solution sets have a non empty intersection theequalityissatisfiable butnotatautology andtheresultis .
finally if they have no solution in common the result is .
.
.
logical negation.
the logical negation angbracketleft r angbracketright angbracketleft not a angbracketright ofamulti interval angbracketleft a angbracketrightcanbecomputedbyinvertingtherespective truth values.
that is if angbracketleft a angbracketrightcontains then angbracketleft r angbracketrightmust contain .
and if angbracketleft a angbracketrightcontains then angbracketleft r angbracketrightmust contain .
this implies that if angbracketleft a angbracketright then notis idempotent and the result is angbracketleft r angbracketright .
asamust have width no value outside of can be contained in angbracketleft a angbracketright.
clearly angbracketleft r angbracketright .
.
.
comparison.
for a comparison l a b with l ult ule slt sle we must determine if indeed for all llbracketa rrbracketand all llbracketb rrbracket we have l .
to solve this problem efficiently we rely on the representation of multi intervals and extract the closurecl angbracketleft a angbracketright of angbracketleft a angbracketrightand the closure cl angbracketleft b angbracketright of angbracketleft b angbracketright.
the closure cl angbracketleft x angbracketright of a non empty multiinterval angbracketleft x angbracketright angbracketleftbig ... angbracketrightbigcan be computed in constant time by extracting the lower bound of the first interval and the upper bound of the last interval cl angbracketleft x angbracketright .
then l a b evaluates to ifl min max t o if we have l max min and to if both conditions are satisfied.
.
.
type conversion.
an extending type cast from the multiinterval angbracketleft a angbracketright angbracketleftbig ... angbracketrightbig miform u s to angbracketleft r angbracketright angbracketleftbig ... angbracketrightbig mjwithj iis trivial as none of the intervals are affected and we have angbracketleft r angbracketright l k angbracketleft a angbracketright withallintervalsbeingidentical.for j i theresultingsolution set is bound to some angbracketleft angbracketrightand those intervals with i minormax i 0are dropped from angbracketleft r angbracketright.
any intervals including the minormaxbound are truncated to fit inside .aseachintervaliseithershrunkordroppedwehave angbracketleft r angbracketright angbracketleft a angbracketright .
a sign cast must comply with two s complement semantics for an unsigned to signed cast every interval strictly smaller thanthe boundary h 2i 1is preserved while every interval strictly greater than or equal to his also preserved but moved left in the sorted list of intervals to preserve the strict order.
finally if there existsanintervalthatincludesboth handh itissplitintwo one with the upper bound h and one with the lower bound h.asigned to unsignedcastisperformedanalogously whilethe boundary his set ath and intervals are moved to the right not theleft.asuptooneintervalmightbesplitintwoandeveryother interval is preserved we have angbracketleft r angbracketright angbracketleft a angbracketright .
.
.
additionand subtraction.
theplusoperator add a b is implemented by successively adding individual intervals of bto aakin to a cross product.
for this algorithm we break down the operationtoaddingtwointervals 0 0 1 1 s.i fshappens to overflow or underflow it is split in two as described in .
.
.
finally all resulting intervals are merged into one multi interval.
for each pair of intervals from angbracketleft a angbracketrightand angbracketleft b angbracketrightwe may get up to two intervals.
however as all intervals that lead to an underflow or overflow will be merged we have in total angbracketleft r angbracketright angbracketleft a angbracketright angbracketleft b angbracketright .
subtraction is analogous to addition.
.
.
non rotatingshift.
fromthetwopotentialshiftoperators left shiftandright shift theleft shiftoperatorbehavesanalogously to a multiplication which we discuss in .
.
.
a right shift with a non constantshiftamountmayleadtoexponentialblow upand thusisnotsupported.aright shiftbyaconstant angbracketleft r angbracketright lshr a c potentiallycondensesthemulti interval i.e.
angbracketleft r angbracketright angbracketleft a angbracketright sow e support it.
for instance the right shift by of the multi interval angbracketleft angbracketrightu8resultsinthefirsttwointervalsmerging angbracketleft angbracketrightu8.
.
.
multiplication.
leftshift andbyextensionintegermultiplication presentsuswithapotentialexponentialblow up.for instance consider the multi interval angbracketleft angbracketrightu8.
a left shift of or authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france oscar soria dustmann klaus wehrle and cristian cadar amultiplicationwith21wouldresultinasolutionsetcontaining all the even integers from to i.e.
it would have the form angbracketleft ... angbracketrightu8.
however our problem analysis shows that multiplication with constants of the form 2iare verycommon especiallystemmingfrompointerresolutionlogic see .
.
.
therefore we extend multi intervals in the decision stage to carry a left shift attribute lsa .
that is the operation mul angbracketleft angbracketrightu8 will result in the multi interval angbracketleft angbracketrightu7with anlsaof .
in the general case this gives us angbracketleft r angbracketright angbracketleft a angbracketright .
subsequentbinaryoperationslike addwillthenstillabortifpresented with two operands with differing lsas but may succeed when the lsas are the same.
similarly inequality operators can apply the lsa when computing the closure without incurring blow up.
.
limitations bydesign ourapproachhassomelimitations.inthelearningstage wecannotprocessconstraintswithmorethanone readasweneed todescendonthecentralpathfromtheroottothesingularvariable.
ontheotherhand wecanprocessmultiplereadsinthedecision stage.
in both stages some operators are not supported as they may lead to an exponential blowup.
foreveryquery partidecideson the flywhetheritcancontinue to process it or has to abort.
this results in an overall complexity that is at worst quadratic in the size of the entire query and exponential in thenumber of add suboperators in theexpression cf.
table .
evaluation weevaluateourapproachbycomparingacompletestate of the art smtsolver namely z3 with parti in conjunction with the same complete solver.
we first validate parti s results with those of z3 finding no discrepancy over the entire course of our several cpu weekslongevaluation.hence theremainderofthissection will assess the performance of parti.
weimplementedthepartialgorithmdirectlyinthekleesymbolic execution engine in version .
.
intercepting queries before they are being handed to the back end solver.
this is facilitated by the solver chain of klee which allows to inject an incompletesolverandthenautomaticallyconsultthenextsolver in thechain oncethe injectedsolver failsto solvethe givenquery.
by default klee also invokes the final complete solver by forking the current process.
this is done to enforce the solver timeout i.e.
to terminate the solver should it consume too much time.
we deactivatethismechanism asforkingwouldcreateasubstantial overheadandbiastheevaluationinfavourofparti.however thatresultsinsolverfailuresofz3 whichoccurquiteinfrequently tobe propagateduptoklee requiringonereruneveryapproximately runs.
wechoosez3asithasfinertime outcontrolbuiltinthanklee s defaultsmtsolverstp.runningthelatterwouldincurtheoverhead stemming from process forking or make it impossible to reliablymeasurethesolvertimeduetoextremelylong runningqueries beingprevalentinmanyruns.however wealsocomparetheperformance of parti under both solvers on a smaller benchmark which does not produce such time out breaking queries in .
.
.our evaluation was run on an intel xeon with threads at3.4ghzwith0.25tbramandwithhyper threadingdisabled.
we ran no more than processes in parallel and no swapping occurred during any run.
westructuretheevaluationintotwomainparts afunctional analysis .
and a performance evaluation .
.
in both cases each experiment is repeated several times as time measurements always result in noisy data.
the exact number of repetitions and the semantics of the depictedconfidence intervals isdenoted oneach figurewhere itapplies.
toalso minimisenoise as much as possible we use the dfs deterministic searcher which descendsononeexecutionpath onlypursuingotherpathsafterthe currentoneterminates.asthiswillgeneratebothshortandlong simpleandcomplexqueries itprovidesagoodcollectionofqueries.
wealsodeactivatedquerycachesinkleetoenhancedeterminism.
.
functional analysis as a means of obtaining an insight into the strengths and limitations of parti we first perform a functional analysis of mostly synthetictestprograms.here weevaluatetheterminationtimeforacompletecoverageoftheinputprogram imposingnotimeoutfor klee.
each run is repeated manifold with parti z3 and with z3.
.
.
objectresolution.
inklee objectresolutionforsymbolic pointers includingarrayindexes dependsonaseriesofcomparisons checkingifthepointervaluecouldpointinsideeachofthe memory objects on the current path.
for instance when klee encounterstheaccess a whereiisanunconstrainedsymbolic index which could thus refer to other arrays too it compares the symbolic value a iagainst the bounds of all possible objects on that path.
this causes a large number of comparison queries slowing down such operations to the extent that users of klee repeatedly complain about this shortcoming.
weanalysethisscenariowithrespecttodifferentarraytypesand lengths in figure .
the performance here heavily depends on the support of multiplication in the decision stage in this scenario we can identify most queries to have the form l parenleftbigb mul parenleftbigx 2i parenrightbig parenrightbigwhere bandiare constants and xis a symbolic pointer.
if we deactivate thesupportfor lsas cf.
.
.
everythingbutthespeedupforthe 8bitrunsdropsto1.with lsasweobserveahugespeedupwell above a factor of xfor all array types as to be expected the array size horizontal axis has no influence on the execution time.
as our example only performs the indexing operation no query is produced that cannot be solved by parti directly.
.
.
worst case scenario.
we analyse parti s behaviour in a worstcasescenario.tocreateanadversarialprogram weheavily exploitthemulti intervalexplosionintroducedbyan addoperation duringthedecisionstage.first wecreateaseriesof nvariables vi andconstraintheirsolutionsettothevalues braceleftbig 2i bracerightbig fori ... n. second we compute the sum over all viand multiply with an additional variable with the solution set .
this creates a value with the solution set braceleftbig ... 2n bracerightbig which is correctly represented by parti but incurs an exponential blowup.
finally parti has toabort computation becauseof the unsupportednonconstant multiplication.
for a control experiment we omit the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parti a multi interval theory solver for symbolic execution ase september montpellier france length of the indexed array n 14080120160200240280klee speedup .
conf.
reps. bit bit32 bit bit figure speedup when indexing an arrayofsize nandvariousdatatypeswith a symbolic bit index.
here the relative time does not depend on the size or the type of the array as constant multi plication is supported due to lsas.
number of symbolic variables2 121232527time in s .
conf.
reps. control z3 control parti z3 worst case z3 worst case parti z3 figure runtime for the symbolic exe cutionoftheworstcaseandcontrolpro grams cf.
.
.
.
parti performs well forupto16 addexpressions.afterwards theexponentialblowupduetoadditions in the decision stage take over.
number of symbolic variables2526272829210211212peak res in mb .
conf.
reps. control z3 control parti z3 worst case z3 worst case parti z3 figure5 peakresidentmemoryforsym bolic execution of the worst case andcontrolprograms.parti performswell up to a number of addexpressions whenthenumberofindividualintervals in one multi interval surpasses .
multiplication allowing parti to succeed instead of having to additionally invoke z3.
notethatweonlyanalyseonepathinthisexperiment artificially constraining the solution set of vi.
in a real setting we would experience path explosion of the magnitude 4i with most of the paths not incurring worst case queries in parti.
figure4showsabsoluteruntimesofkleeforanexecutionofthis worstcaseprogramfordifferentvaluesof n whilefigure 5depicts thepeakresidentmemoryforthesameexperiment.withasmall number of symbolic values the control run shows a noticeable speed up while the worst case run shows that parti can only decidethequeriesgeneratedwhilestilladdingconstraints.around variables theoverhead beginsto overtakethe speedupand the exponentialblowupdominatestheoverallperformanceofklee both in the control as well as in the worst case.
a very similar behaviour can be observed for the memory consumption.
this also means that while the cardinality of all involved multiintervals remains below the overhead of parti remains negligible compared to that of klee and z3.
.
.
sorting algorithms.
to get an insight into the efficacy of parti in specific scenarios we investigate its behaviour on a suite ofclassicalsortingalgorithms suchasmergesortandquicksort.
ourtestfunctionsortsanarrayofconcretedataandafixednumber of symbolic entries placed at random positions within the array.
foreachofsixsortingalgorithms wemeasurethetimeuntilklee explores all paths and terminates on its own.
depending on thenumber of symbolic array entries and the tested algorithm the time to finishmayrangefromfractionsofaseconduptooveran hour.figures 6and7showthatdependingonthesettings different algorithms produce more favourable queries for parti for instance when analysing a single symbolic entry both the merge and heap sort algorithms show a speedup of around 10x slowly declining with larger input arrays while selection sort achieves speedups well above .
when analysing the same algorithms with two symbolic entries insteadofone thespeedupdropssignificantlyforallalgorithms.while the variance is greatly increased for three algorithms we still measure speedups ranging from .5x to 10x.
the different performance in figure 7is due to the order in which these algorithms comparethedata to sort.whenanalgorithmsuchasbubblesort touchesthefirsttwoentriesinitsveryfirstcomparisonandthey are both symbolic in the second query there will already be a constraint that contains reads from more than one symbolic value barring parti from processing any subsequent query on that path.
hence nosubsequentquerycanbeansweredbypartiasitwill abort each time during the learning stage.
so the speedup depends onthealgorithm smemoryaccesspatternsandthepositionsofthe symbolic entries.
thisdemonstratesthatthesuccessofpartiisheavilydependent on the nature of the queries generated by the target program.
forinstance ifthereisonlyonesymbolicvaluepresent thegenerated constraints will have the structure of a binary caterpillar tree with only one symbolic read such that the learning phase can succeed.
in the second scenario the symbolic execution introduces a comparison between two symbolic values in every path at some point.
therefore parti can be applied only for a portion of the queries ascanbeseenbythestarklyreducedspeedupinfigure approx.
.5x to 10x compared to figure approx.
10x to 50x .
.
performance evaluation weevaluateparti sperformanceonanumberofreal worldprograms to understand the speedup we would see in the wild.
again we run each experiment with parti z3 and with z3.
.
.
coreutils.
thegnucoreutils arewidelyusedforthe analysis of the efficacy and efficiency of symbolic execution.
we run the coreutils suite version .
using individual programs as a benchmark set with a configuration corresponding to .
to compare the runtime of klee configured with parti z3 versus just z3 we first ran the respective utility e.g.
sum for a fixed amount of time e.g.
900s and logged the number of instructions i klee managed to process in that time.
then we rerun theexperiment withoutanimposedtime out butinstructklee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france oscar soria dustmann klaus wehrle and cristian cadar length of the sorted array1510152025303540455055klee speedup .
conf.
reps. bubble sort heap sort insertion sortmerge sort quick sort selection sort figure speedup for sorting algorithms with symbolic field and n concrete fields when using parti z3 versus z3 alone.
compared to figure this experiment offers significantly more opportunities for our solver as there is no comparison between two symbolic values.
length of the sorted array123456789klee speedup .
conf.
reps. bubble sort heap sort insertion sortmerge sort quick sort selection sort figure speedup for sorting algorithms with symbolicfield and n concrete fields when using parti z3 versus z3 alone.
as bubble selection and insertion sort have very long runtime they are run with much fewer repetitions while still achieving adequate confidence in the mean.
klee timeout s 2123456789101112131415161718192021222324klee speedup .
conf.
reps. dir dirname du expand factor fmthead mv pathchk printenv sum tac figure8 speedupwhenexecuting98coreutilstools.theleg end shows those tools with the highest and lowest speedup.
the confidence intervals of some tools include portions belowthe1xline indicatingthatsmallslowdownsarepossible.manytimeshowever wemeasureasignificantspeedup.
klee timeout s 21234klee speedup .
conf.
reps. addr2line ar as new bfdtest1 bfdtest2 elfeditld new objcopy ranlib size strip new sysinfo figure9 speedupwhenexecuting17binutilstools.theleg end shows those tools with the highest and lowest speedup.
weobservethatthevarianceissignificantlyhigherthanfor the coreutils experiments and parti achieves little to nooverallspeedup.
to terminate after processing iinstructions.
we then record the time klee takes to terminate when using parti z3 versus z3 alone.duetonon determinisminklee cf.
thevarianceof themeasuredtimescanvarygreatly especiallysincewedecided to include all coreutils.
hence some results may exhibit higher variance and therefore show larger confidence intervals.
figure8showsthemeasuredspeedupofparti z3versusjust z3.
it shows that many programs benefit from a speedup up to 2x while only seldom falling slightly below the neutral mark of 1x.aroundtenprograms runatleasttwiceas fastwithparti while two namely dirname and printenv even climb above a speedupof 20x.
so while in many cases only moderate speedup can be achieved in some instances klee s performance can be improved drastically from an hour down to a few minutes.
.
.
binutils.
for a set of programs with different characteristics weanalysegnubinutils asuiteoftoolsformanipulation and creationof binaryfiles.
weuse the binutilssuite version2.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
parti a multi interval theory solver for symbolic execution ase september montpellier france total queries0.
.
.
.
.
.0success rate portion of queries solved by parti b900 .
b1800 .
b3600 .34 c900 .
c1800 .
c3600 .12binutils binutils binutils coreutils coreutils coreutils figure10 acomparisonofparti ssuccessrateonthecoreutilsandbinutilssuites.eachdotrepresentsonerunofonetool.thecurvesrepresentlinearbestfitsofthedatapoints.
including17individualprograms.wemeasurethetimeforthepro cessingofapre determinedsetofinstructions aswiththecoreutils evaluation cf.
.
.
.
asdepictedinfigure thereisnosignificantspeedupforthe binutils suite.
the number of exploitable queries here is smaller aspartidoesnotsupportbitwiseoperators.thesearemoreprevalent whenprocessingbinarydataandhencetobeexpectedingreater number in the binutils suite compared to the coreutils suite.
this indicates that although parti can often result in an advantage ascouldbeobservedwiththecoreutilsevaluation wherea numberofprogramsexperienceaspeedupofwellover2x other programstructuresarelesssuitedforourchoiceofsupportedoperators.
furthermore we see a greater variance of execution times in thissuite suchthatwecanonlystatethatthereisneveraslowdown worsethat1.5xandneveraspeedupbetterthan3x.
.
.
gnu sort.
we analysed gnu sort from coreutils in more detail.wepassapartiallysymbolicfileandinstructsorttocheck whether the file is already sorted.
attempts to actually sort a symbolicfilewithklee whetherwithorwithoutparti resultedin hundredsofgboframbeingusedwithinminutes preventinga proper investigation of anything but the most trivial cases.
we tested sort con a file with a total of nalternating symbolic and random concrete lines of uniform length m showing our findings in figure 11for values of m .
notethatthecomplexityofthegeneratedqueriesgrowswiththe lengthofthesymboliclines asmorebytesneedtobecompared.in this experiment we observe that the more complicated the queries are for different values of m the better parti performs relative to z3.
in addition the more queries generated by symbolic execution the more queries are sped up yielding an approximately linear speedup as all queries can be solved by parti in this setup.
therefore especially in settings with a significant amount of queries parti s ability to quickly resolve some queries results in a high1 total number of input lines n with length m1234567891011121314151617181920klee speedup .
conf.
reps. m stp m z3 m stp m z3 m stp m z3 m stp m z3 figure completing gnu sort candnalternating concrete and symbolic input lines of fixed length m. thespeedup grows both with the length of lines and with thenumber of lines.
overall speedup.
further the overall speedup increases with the length of the file s lines as the complexity of the queries increases.
for this experiment we also investigated the performance gains between using z3 and stp as the baseline solver.
the results show thatwith.99confidencenodifferencecanbeidentifiedbetweenthe two solvers even though the plotted average appears to indicate a slight advantage for stp.
.
.
success rate.
the total execution time is most relevant to the user of a constraint solver or symbolic execution engine.
however it provides no information about the ratio of queries that can be answered by parti.
figure 10shows the distribution of the successrateonthecoreutilsandbinutilssuiteswithrespecttothe total number of queries issued by the respective tool.
thisdistributionmatchesthespeedupweseein .
.1and .
.
seeingasignificantlysmallersuccessrateformostofthebinutils toolsandawidespreadforthecoreutilstools.additionally wecan observe that there appears to be no significant relation betweenthe number of coreutils queries and the success rate of solving them.however thenegativecorrelationforthebinutilsexplains the ineffectiveness on that suite with more queries and a more complexprogramissuingunsupportedoperations fewerqueries fall in the supported set and only short runs are sped up.
the success rate of the gnu sort evaluation in .
.
is not included in figure10as it reaches for all runs.
related work asdiscussedintheintroduction ourapproachissimilarinspirit to other constraint solving optimisations employed by modernsymbolic execution engines.
for instance prior work has usedcaching of satisfiability queries and counterexamples expression simplifications logical implications o r rewritingofcomplexarrayconstraints toeitheravoidcalling authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
ase september montpellier france oscar soria dustmann klaus wehrle and cristian cadar the smt solver or call it with simpler queries.
similar to these approaches partiaimstospeedupacertain classofconstraint solving queries.
manysmtsolvers for qf abv are built on top of sat solvers and may perform theory specific optimizations before bit blasting thequeryintoasatformula.forinstance thestpsolver performs optimizations such as arithmetic expression simplifications and array based refinement before bit blasting the formula to sat.
solverslikez3 oryices alsouseaconjunctionof various theory solvers together with the sat solver.
lazysolvershavealsobeenproposedbybruttomessoetal.
whichproposesalayeredsolverdesign mathsat.itusesvarious rewriting rules to simplify a given query applying faster passes whichsupportasmallersetofproblemsbeforeresortingtomore complex ones.the second layeris similar toparti as itemploys anumberofdeductionrulespertainingtothepropertiesofvarious operators.
contrary to parti however these apply to relations betweendifferentvariables suchasthetransitivityof andyields notadefinitesolutionbutasimplifiedquery.similarsimplifications are also part of klee s internal query optimisation.
hadarean etal.
discuss a staged solver that leverages equality inequality andbit blastingtheorieswithacoresolver.similarly to parti all solvers in this chain are incomplete with respect to smtbut can solve subsets in polynomial time and are called in orderoftheircomplexity beginningwiththefastest.thetheory solversarecalledrepeatedlyfromthemainsolverloopandsome such as the bit blasting theory solver may employ a sat solver.
approaches like stratevo concern themselves with the adjustment and selection of solving strategies within a solver such as z3 .
here genetic algorithms are employed to evolve the selection process towards the fastest strategies.
conversely the multi solverversionofkleepresentedin proposestoruna collectionofcomplete smtsolversinparallelsuchthatdifferences in their performance can be exploited.
interval arithmetic ia has been employed for several decades now .iaoperates in the domain of real numbers r representedbyieeefloating pointmachinenumbersandwasin itsinfancyappliedtoprovideabettermeansofavoidingfloatingpoint roundingerrors inprolog .
itsolves thetask offinding the solution set represented as an interval of a list of variablesgiven a finite number of constraints.
to this end it repeatedly attempts to approach the solutionset by an enclosing of cartesian products of intervals.
this is quite different from the approachpresented in this paper as parti represents the solution set ofeach variable as a set of intervals while iarepresents the total solutionsetasasetofproductsofsingularintervals.thismakes therepresentationmorepowerful butalsoitscomputationmore complex.
additionally ia s aim is to tackle non linear problems on floating point numbers.
although it has been applied to nonnegativeintegralnumbers itisnotdesignedforthebehaviourof two s complement integer arithmetic.
solvers like isat3 andrasat employ iaandconstraintpropagationtechniques to sharpen approximations ofsolution sets.
these operate similar to the merging step in the learning stage and the procedure of the decisionstage butasoptimisationsonapproximationsofreal value sets lacking multiplication gaps and overflows.
conclusion inthispaper weapproachedthechallengepresentedbytherelianceofsymbolicexecutionon smtsolversandthecorrespondingbottleneck.thefundamentalcomplexityoftheunderlying np complete problem severely impacts the efficacy with which symbolic executioncananalyseprogramsanddetectdefects.wedemonstratedhow our approach improves the performance of solving smtqueries in the context of symbolic execution.
by designing a lightweight incomplete solver parti we are capable of exploiting the structure of many queries that can besolved efficiently leaving the remainder for a complete solver to handle.
we discussed the theoretical complexity of our solver and verifiedempiricallythatitsoverheadisnegligible.hence theoverall solver performance is not impaired while often being improvedsignificantly exhibiting order of magnitude speedups in severalcases.
for instance tools from the binutils suite such as sysinfo experiencenospeedup whiletoolsfromthecoreutilssuite such as dirname and printenv are sped up by more than 20x.
our solver relies on a two stage approach first extracting informationaboutsymbolicvariables fromthegiven constraints and secondsubstitutingreadsfromthesevariableswiththeextracted information.
we find our proposed multi interval data structure to be a suitable representation of this information as it lends itself to an efficient manipulation of results while consuming very little memory.
experimental results indicate the viability of this approach in quickly answering queries that can be solved efficiently by oursolver but would require more time to be solved by a complete state of the art smtsolver such as stp or z3.
for some coreutils tools we observe that practically every single query can be an swered by parti yielding a high speedup.
in general while wecan observe a number of examples without significant speedups weoftenmeasureconsistentandreproduciblespeedupswellabove a factor of 2x and up to a factor of 20x.