symbolic model extraction for web application v erification ivan boci c and tevfik bultan department of computer science university of california santa barbara usa bo bultan cs.ucsb.edu abstract modern web applications use complex data models and access control rules which lead to data integrity and access control errors.
one approach to find such errors is to use formal verification techniques.
however as a first step most formal verification techniques require extraction of a formal model which is a difficult problem in itself due to dynamic features of modern languages and it is typically done either manually or using ad hoc techniques.
in this paper we present a technique called symbolic model extraction for extracting formal data models from web applications.
the key ideas of symbolic model extraction are to use the source language interpreter for model extraction which enables us to handle dynamic features of the language to use code instrumentation so that execution of each instrumented piece of code returns the formal model that corresponds to that piece of code to instrument the code dynamically so that the models of methods that are created at runtime can also be extracted and to execute both sides of branches during instrumented execution so that all program behaviors can be covered in a single instrumented execution.
we implemented the symbolic model extraction technique for the rails framework and used it to extract data and access control models from web applications.
our experiments demonstrate that symbolic model extraction is scalable and extracts formal models that are precise enough to find bugs in real world applications without reporting too many false positives.
keywords formal v erification model extraction web applications i. i ntroduction web applications are used in all aspects of life.
due to the convenience of cloud based data stores many web applications store private and sensitive user data loss or leakage of which could be disastrous for individuals and organizations.
the complexity of data models and access control rules used by modern web applications leads to programming errors that can compromise both integrity and privacy of data.
hence eliminating data integrity and access control errors from web applications is a critical problem.
in recent years dynamically typed interpreted languages such as javascript python and ruby have become commonly used for web application programming.
these languages compared to statically typed languages offer more flexibility and typically require less source code to implement the same program.
moreover web application frameworks such as rails and django utilize dynamic features of these languages this work is supported in part by the nsf grant ccf .to provide a rich set of tools to developers.
the increased expressiveness however comes at a cost.
certain compiletime guarantees of correctness become impossible to achieve in general.
these include guarantees that are taken for granted in statically typed languages such as the guarantee that every invoked function or method exists.
there exists a significant body of work on model based verification of web applications .
these approaches rely on extraction of formal models where the extracted model is an abstraction of the program focusing on a particular feature or behavior of the program.
these models are then verified using model checkers or theorem provers .
some of this research specifically targets applications written in dynamically typed languages .
extracting a formal model from programs written in dynamically typed languages is a challenging problem in itself.
because of the difficulties in model extraction web applications verified in most research papers tend to be simple.
third party libraries that augment the default behavior of the development frameworks are generally avoided.
to statically verify such applications verification tools require either that the applications do not use these features or they pre process applications to make declarative constructs explicit .
even with these limitations that are due to challenges in model extraction model based verification techniques were able to find various previously unknown security and data integrity bugs in open source web applications .
in this paper we present symbolic model extraction a technique for automatic extraction of formal models from applications written using dynamically typed interpreted languages.
symbolic model extraction takes a program in a source language as input and generates a model in a target modeling language as output such that the generated model abstracts the behavior of the input program.
symbolic model extraction is based on the following ideas we instrument code such that executing the instrumented code returns the model that corresponds to the original code we implement the instrumentation function in the source language itself such that we can instrument newly dynamically generated code as it is encountered the instrumentation function replaces branches with code that handles both paths of the branch in a single execution in order to achieve full path coverage.
ieee acm 39th international conference on software engineering ieee acm 39th international conference on software engineering .
ieee authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1class article activerecord base acts as paranoid 3end 4class articlescontroller applicationcontroller load resource before action destroy do redirect to back unless current user.verified?
end def destroy article.destroy!
end end fig.
ruby on rails example.
symbolic model extraction has its own limitations.
our approach may not correctly handle code dynamically generated from user input.
this is not a significant problem in our experience as directly evaluating user supplied code is unsafe and slow and hence is not common practice.
moreover under certain conditions the presence of mutually conflicting code generation under different program paths may result in extraction of inaccurate models.
we did not experience this in practice although it is a theoretical possibility.
to validate our approach we implemented symbolic model extraction for data model verification of rails applications.
our tool is open source and available online1.
our experiments show that symbolic model extraction can be used to extract models from real world web applications very efficiently.
we extracted models from open source rails applications spanning up to kloc ruby source only .
extracting the entire model of most applications took under seconds and seconds for the largest application.
automated verification of the extracted models took .
seconds per property on average.
on these applications we verified properties.
properties failed and we manually confirmed that these are due to real bugs in the application code.
we also observed false positives.
these results demonstrate that symbolic model extraction is fast and precise enough to be useful for finding bugs in practice.
the rest of the paper is organized as follows.
section ii presents a portion of a rails application demonstrating why model extraction from applications written in dynamically typed web applications can be difficult.
in section iii we discuss the foundations of symbolic model extraction.
section iv explains how we implemented symbolic model extraction to extract models of rails applications that focus on data integrity or access control.
section v presents the experimental evaluation of our extraction.
section vi discusses related work and in section vii we conclude the paper.
ii.
a m odel extraction example consider the excerpt of a rails application in figure .
lines declare a model class which is a class whose objects can be stored in the database.
this particular class article defines articles that are managed by this web application.
this class does not contain any fields or additional methods for the sake of clarity.
lines define the articlescontroller .
articlescontroller applicationcontroller def destroy article article.find params redirect to back unless current user.verified?
article.deleted at time.now article.save!
end 8end fig.
static equivalent to action in figure .
controllers define actions which are executed in response to user requests.
the one action in this example is called destroy lines .
this action seemingly deletes the object stored in the article variable using the destroy!
method line .
due to dynamic features that are often used in rails the source code of the action is deceptive.
the action does much more than deleting an object.
first it is not clear which article object is being deleted.
in line of figure we see the load resource declaration defined by the cancan gem .
this declaration will ensure that before an action executes the framework will preload an object and store it in a variable to be accessed from inside the action.
the specifics of this preload operation are subject to a number of conventions such as the name of the controller the name of the action and configurations.
second the before action declaration in lines prepends a filter to the action.
filters execute before or after an action and are usually used to prepare data for an action or to conditionally prevent an action from executing any further.
in this case if the current user is not verified line the filter will redirect to a different page.
this redirection will prevent the action from executing.
finally in line the action invokes the destroy method on the object in order to delete it.
however in line the acts as paranoid declaration provided by the actsasparanoid gem overrides the destroy!
method for the article class.
instead of deleting an object the object is simply marked as deleted but not removed from the database.
this allows for article objects to be restored later if need be.
figure contains a destroy action that is semantically equivalent to the action in figure but with its semantics directly understandable from the source code.
this is a simple example of how actions can be enhanced using dynamic features of the ruby language.
there exists a rich set of libraries that rails developers can use to similarly enhance the framework.
some of these libraries such as activeadmin can even generate entire actions that are not present statically.
this way of developing applications makes static analysis and model extraction difficult as the semantics of an application are fully defined only at runtime after libraries have had the opportunity to augment them.
we explain symbolic model extraction and its application to data model verification in the following sections but here we wish to demonstrate the result of symbolic model extraction when applied to the example in figure .
as the target modeling language we focus on abstract data store language adsl which has been defined in our earlier work .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1action destroy article oneof article if return end 6end fig.
model extracted from figure .
we discuss features of adsl later in section iv.
when applied to the example in figure symbolic model extraction extracts the adsl model in figure .
this model is an abstraction of the original method.
in line an object is read from the database but there are no specifics on which object is loaded.
lines will abort the action depending on a nondeterministic condition.
finally the model will correctly omit the delete operation that was seemingly present in the original source code.
this model is a sound abstraction of the full semantics of the action including its dynamic features.
iii.
s ymbolic model extraction we explain symbolic model extraction on an abstract programming language l. let us assume that lis an interpreted dynamically typed imperative programming language with functions as first class citizens e.g.
functions can be assigned to variables passed as arguments to function calls etc.
.
for simplicity we will represent a program written in l as a statement s. since a sequence of statements is itself a statement this perspective is accurate.
at runtime programs written in lare executed using the interpreter iwherei evaluates statements to migrate the program from one state to another state.
because this is a dynamically typed language the types of objects assigned to variables may change over time.
in addition the type system in the program can change in any number of ways classes can be defined at runtime methods can be added or even replaced at runtime.
letlbe the set of program states in l. these states include the program counter the stack and heap memory states.
this lets us define a statement sas a set of state transitions s l l in words given an initial state l l executing a statement swill migrate the program state to some state l primesuch that angbracketleftl l prime angbracketright s. furthermore we constrain the definition of statements to have at least one state transition from any program state.
let sbe the set of all statements in language l. for model based verification in order to verify a program statement s s we need to extract s sharp the model of a statement sin some modeling language l sharp.
this model is an abstraction of the original statement meaning that if there are behaviors in s they can be detected in s sharp.
letl sharpbe the set of abstract program states.
each abstract program state l sharp l sharpis a set of concrete program states l sharp l similarly an abstract statement s sharpis a set of transitions between abstract states that abstracts a concrete statement s.s source programtinstrumenter i interpreters sharpmodel fig.
overview of symbolic model extraction more precisely for every state transition in s s sharpcontains the transition of corresponding abstract states angbracketleftl l prime angbracketright s angbracketleftl sharp l sharp prime angbracketright s sharp l l sharp l prime l sharp prime we can see that s sharpsimulates the behavior of s i.e.
for each behavior in sthere exists a corresponding behavior in s sharp.
hence s sharpis an abstraction of s. note that this definition of statements does not account for expression return values.
we are using this set of definitions to simplify the presentation.
a. symbolic model extraction rules symbolic model extraction uses the interpreter for the source language and an instrumentation function that is accessible during runtime to execute the input program in an instrumented path insensitive environment to explore static as well as dynamically generated code and extract the model for the given program in the target modeling language.
we illustrate the high level information flow in the symbolic model extraction in figure where the input program s i n the source language is passed to the instrumenter function t .
the instrumenter will instrument the given program and pass it to the interpreter for execution.
when new code is encountered or dynamically generated the interpreter will pass this new code to the instrumenter for immediate instrumentation.
the execution of the instrumented program returns the extracted model s sharp in the target modeling language.
in order for this approach to work without developing a custom interpreter the instrumenter has to be implemented in the source programming language itself.
newly generated code can then be investigated and instrumented using metaprogramming.
key to our approach is the symbolic model extraction instrumentation function t or the instrumenter in short.tis a functiont s sthat given a statement s s returns the instrumented statement t s .
when executed by the interpreter i t s evaluates to the model of s i t s s sharp in words the instrumenter transforms a statement such that executing the transformed statement using the source language interpreter returns the model of the original statement.
after implementing tin the source language we can use it to instrument and extract a model of a dynamic program using the source language interpreter.
we instrument and invoke the program s entry point within the same runtime.
our instrumentation ensures that instrumentation will propagate as new code is discovered or even generated.
additionally we override all methods that are relevant to our abstraction to make them execute symbolically.
for authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
rule s t s i t s 1 2 ... n ins block t 1 t 2 ... t 3 sharp sharp ... sharp n fn 1... n t fn t 1 ...t n fn sharp sharp ... sharp n 3if then else ins if t t t if sharp sharp sharp sharp 4while ins while t t while sharp sharp sharp op ins op op t t sharpop sharp sharp ifop sharpexists within the abstraction otherwise var result t var symvar.new result.sym type var ins assignment var result var sharp sharp var var var sharp t able i statement instrumentation example if we aim to extract a model that focuses on database operations methods that communicate with the database will be overridden such that instead of communicating with the database they return a model that describes the nature of communication that was attempted.
the instrumenter s behavior is not obvious when it comes to dynamic language features control flow and data flow features such as scoping and assignments that appear in the source program.
table i demonstrates how the instrumenter could be implemented with regards to basic language constructs.
sequences of statements rule in table i demonstrates how a sequence of statements is instrumented in order to extract the model of the sequence.
let us extract the model of a sequence of statements s 1 2 ... nusing symbolic model extraction.
we instrument the sequence in such a way that executing the instrumented sequence returns the model of the sequence.
to achieve this we replace each statement kwith its instrumented version t k and pass these instrumented statements as arguments to an ins block function.
as such t s ins block t 1 t 2 ... t n note that this instrumented statement is still a valid statement in the source language.
ins block is a method provided by our instrumentation library that merges a sequence of models of statements into a block model.
when executing t s the interpreter will first evaluate each argument for ins block in order.
the result of each argument t k will be sharp k the model of the statement k. finally these models will be merged by ins block into the sequence of statements in the modeling language.
method calls rule in table i refers to how function or method calls are treated by the instrumenter.
any call to a function fn 1 ... n in the source program is replaced with a call to t fn t 1 ... t n .
in words the instrumented function gets executed instead of the original function with arguments having been instrumented as well.
the result of this execution as defined by the instrumenter will be the model of the function s body.
to illustrate this approach consider figure a .
it illustrates the execution of a program that dynamically generates a method and subsequently invokes it.
since code generation is done at runtime it poses a problem for standard model extraction techniques.
figure b demonstrates how symbolic dynamic method callsexecution over time... generate method g1 invoke method g1instrumented dynamic method callsexecution over time... generate method g1 instrument g1 invoke method g1 execution of instrumented g1 ...symbolic arguments model that corresponds to g1 s source code execution of g1 ...arguments return value a normal execution b instrumented execution fig.
symbolic model extraction from dynamically generated methods.
model extraction extracts the model of a dynamically generated method.
after generating the method the interpreter instruments the generated method at runtime.
the instrumentation alters the method such that after it is invoked with symbolic arguments the instrumented method returns its own model.
this is how instrumentation is propagated through the program all functions are instrumented just before they are invoked allowing us to extract statically available source code as well as source code that might not exist statically.
control flow dynamic program analysis is typically subject to the problem of path explosion.
symbolic model extraction bypasses this problem by exploring all paths of the program at the same time.
we transform branches into a sequence of three symbolic executions one for the condition one for the then block and one for the else block.
we execute all these in an instrumented environment in order to extract models of the condition and both branches.
finally we combine the resulting three models into a branch statement in our modeling language.
rule in table i summarizes our approach for extracting models of branches.
given a branch where is the condition and and are the then and else block respectivelly the instrumenter replaces the branch with a call to ins if t t t which will consecutively instrument and execute the condition and both paths.
the results of executions of instrumented elements are the models of each element which are combined into a model representation of the branch itself.
note that contrary to intuition this approach can handle some often encountered situations where different paths have seemingly conflicting side effects such as assigning different authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
1do a article.new a.destroy!
4end1ins block result ins call article new a symvar.new result.sym type a ins assignment a result ins call a destroy!
a create article delete a a rails code b instrumented rails code c extracted model fig.
symbolic model extraction example.
values to the same variable.
this will be made clear in section iii a5.
loops are handled analogously rule in table i .
instead of executing the loop body a number of times the loop can be instrumented and executed only once to extract the model of the loop body.
expressions rule in table i explains how our approach handles expressions.
even though this discussion assumes that the expression is a binary operator the principle generalizes to any number of arguments.
given an expression o p we first extract the model of and by instrumenting and evaluating them.
then depending on the operation op itself and sharpand sharp using the ins op function we return either the model that correctly abstracts the expression sharpop sharp sharp or representing any possible value.
the specifics of the treatment of expressions is highly dependent on the specifics of the modeling language.
any expression that can be represented in our modeling language should be instrumented so that executing the instrumented code evaluates to the corresponding model.
otherwise the instrumented expression should result in a symbol representing any possible value.
for example if the abstraction handles integer addition but not string concatenation ins op sharp sharp would check whether sharpand sharpare both integers.
if they are ins op should return the model of an addition operation with appropriate models for arguments.
otherwise the result ofins op would be a symbol representing any possible value.
v ariables and scoping rule in table i refers to how variable assignments are treated by the instrumenter and rule explains how variable reads are treated by the instrumenter.
these two operations are closely tied to each other as we actually instrument variable reads as a side effect of instrumenting assignments.
given an assignment var the instrumenter should generate code that when executed returns the model representation of an assignment operation.
similarly when a variable var is read in the original program the corresponding model should represent the variable reading operation.
as shown in rule in table i the instrumenter replaces the assignment with a sequence of three statements.
the first statement instruments and extracts the model of the assigned expression storing it in a temporary local variable result .
the second statement creates a model of the variable read operation and stores it in the assigned variable along with the type of the assigned expression and the name of the variable.
that way whenever this variable is subsequentlyread by the interpreter the interpreter will identify the correct variable using the scoping rules of the language and return the proper variable read model.
this approach not only reduces the amount of work needed to implement symbolic model extraction as we need not worry about variable scoping rules in the source language but this is especially useful in ruby where it is not trivial to distinguish variable reads from method calls made without parenthesis and arguments.
finally the third statement constructs and returns the model of the assignment operation itself.
since variables do not contain a value that is tied to the expression that was assigned to the variable symbolic model extraction does not have a problem with the source program assigning different values to the same variable in different program paths.
during symbolic model extraction from such a program although a different models will be extracted from each assignment all assignments will assign the very same value to the variable in question.
dynamic code generation symbolic model extraction is built on the assumption that the dynamic features of the source language are used input independently within the abstraction of choice.
in other words all dynamically generated code has an identical abstraction in every execution of the program.
this assumption holds in rails very often as code generation is almost exclusively used to make the developers work easier generating code that s identical every time the web application starts.
during instrumented extraction code generation is executed concretely with all symbolic values concretized into arbitrary values within their abstraction.
b. symbolic extraction example we will proceed to demonstrate how symbolic model extraction can be used for model extraction on an example.
this example is designed to demonstrate key features of the technique and how the approach deals with difficulties more straightforward techniques could not handle easily.
assume that we wish to extract a model from the ruby block in figure a .
this block creates a new article object article.new and assigns it to a variable called ain line .
in line the destroy!
method is invoked on the previously created object deleting the object from the database.
these statements are wrapped in a block lines .
the target modeling language is adsl which we will discuss in more detail in section iv.
the model we will eventually extract should be understandable regardless and is presented in figure c .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
program transformation the instrumenter will automatically transform the block in figure a to the block in figure b .
we refer to the code in figure b as instrumented code to distinguish it from the original code.
instrumented code is generated as a transformation of the abstract syntax tree of the original block and is executed instead of the original code.
this instrumented code follows the instrumentation rules previously discussed in table i. the block presented in lines of figure a corresponds to the ins block statement that spans lines of figure b .
this is a direct application of rule in table i. the two arguments of ins block spanning lines and of figure b directly correspond to the two statements in lines and of figure a respectively.
when executing the instrumented code arguments of ins block will be evaluated one at a time evaluating to their models.
the models of these statements will be conjoined into the extracted block by the ins block call.
the assignment in line of figure a is transformed into the sequence of statements in lines of figure b as described by rule in table i. the statement in line of figure b instruments and evaluates the new method storing the result model in a temporary variable.
we implemented ins call to facilitate instrumentation and invocation of the instrumented method line of table i. in this case the expression is invoking the new method on the article class.
this is a core rails method that creates a new model object which we overrode to return the model of the object creation operation create article .
the statement in line assigns a model of a variable read operation to a. this value mimics the type that was assigned to the variable in the original program but otherwise has no state.
whenever any subsequent statement reads variable a the value it reads will be the model of the operation of reading a. the statement in line creates a model representation of an assignment operation.
this model will be returned to the ins block call in lines of figure b as the first argument.
the method call in line of figure a is transformed into the method call in line of figure b .
this is in concordance with rule presented in table i. the ins call statement will execute a method in an instrumented environment in two steps find the method that will be invoked on the provided object with any provided arguments and instrument it.
invoke the method with any provided arguments.
by default in rails the destroy!
method deletes an object from the database.
during instrumented execution calling destroy!
on an article object returns the model of a delete operation on the called object.
in this case since variable a contains the model of the variable read operation from destroy!
we extract the model statement present in line of figure c .
c. limitations symbolic model extraction has limitations.
for one the approach assumes that the application does not utilize input dependent dynamic features.
if it does for example if a user is given the ability to enter code that will be executed by theapplication symbolic model extraction will not extract a sound abstraction of the original source code.
in practice generating code from user input is avoided for performance and security reasons so we did not encounter this issue.
our treatment of branches is designed under the assumption that different paths in the program will not use mutually conflicting code generation.
consider a branch statement that executes statement aif the condition holds true and statement b if the condition holds false.
let aandb generate a method under the same name with different source codes.
insideayou would see a s method during both concrete and symbolic execution inside byou would see b s method during both executions.
however after the branch symbolic model extraction would only consider b s implementation.
although this is a problem in theory in practice we did not encounter such programs.
we believe that this problem can be avoided by keeping track of every generated method and using aliasing to access different versions of the same method.
iv .
s ymbolic extraction for data model verifica tion we used symbolic model extraction to models from ruby on rails applications.
we used these models for two purposes to verify data integrity and access control properties.
in this section we present the abstract data store language adsl the target modeling language we used for verification of data integrity in rails applications.
we also discuss the extension of adsl called adsl that enhances adsl with access control information although for brevity adsl is discussed in less detail.
in addition to presenting the modeling language we show how we employed symbolic model extraction to extract models in these target modeling languages.
a. data model v erification models since our goal is to verify data integrity or access control the models we extract need to encompass operations the application does on its data.
for data integrity we need to focus on the way data can be modified by the application as well as automated validators and constraints that prevent data invalidation.
for access control we additionally need to extract the specifics of the permissions system as well as observe which objects might be read or modified by different users.
at the core of adsl is a data store .
a data store ds is a tuple angbracketleftc r a angbracketrightwherecis a set of classes ris a set of associations and ais a set of actions.
classes and associations define the types of entities stored in the data store while actions define possible ways to modify or query the data store.
data store states define the exact set of data being stored in the data store.
we define ds to be the set of all possible data store states of ds .
formally a data store state is a tuple angbracketlefto t angbracketright ds whereois the set of objects and tis the set of tuples denoting associations among objects in o. classes and associations given a data store ds angbracketleftc r a angbracketright cis the set of classes and it identifies the types of objects that can be stored in the data store.
each class has a authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
set of superclasses superclass c c and transitively the superclass relation cannot contain cycles.
given a data store state angbracketlefto t angbracketright ds ois the set of objects that are stored in a data store at some point in time.
each object o ois an instance of a class c c. we use the notation octo denote all objects in owhose class is cor whose superclass is c directly or transitively .
we define o to be the set of all sets of objects that appear in ds .
associations define how objects of particular classes can be related to one another.
an association r angbracketleftname c o ct angbracketright rcontains a unique identifier name an origin class co c and a target class ct c. we omit the definition of cardinality constraints for brevity.
similarly to how objects are instances of classes tuples are instances of associations.
each tuple t tis in the form t angbracketleftr oo ot angbracketrightwhereris an association r angbracketleftname c o ct angbracketright r andoo ocoandot oct. for a tuple t angbracketleftr oo ot angbracketrightwe refer toooas the origin object and otas the target object.
notice that this model does not include fields as part of the class definition.
adsl abstracts basic types away for several reasons.
first rails natively supports validators that effectively ensure that only valid basic type data can be saved in the database.
as such verification is unlikely to yield useful results.
second verification of basic types is difficult especially in case of strings which are still unsupported by most smt solvers that we use for verification.
this would limit our choice of theorem provers.
in addition there is nothing that prevents symbolic model extraction from extracting basic type field operations.
if necessary this would be a simple addition to our implementation.
actions given a data store ds angbracketleftc r a angbracketright adenotes the set of actions.
actions are used to query and or update the data store state.
each action a ais a set of executions angbracketleftq q prime angbracketright ds ds owhereq angbracketlefto t angbracketrightis the pre state of the execution q prime angbracketlefto prime t prime angbracketrightis the post state of the execution and o primeis the set of objects shown to the user as the result of this action s execution.
for example given an action a aand an execution angbracketleftq q prime angbracketright a we can define the sets of objects this execution created deleted and read as follows o created angbracketleftq q prime angbracketright o negationslash q o s prime o deleted angbracketleftq q prime angbracketright o q o negationslash q prime o read angbracketleftq q prime angbracketright o in adsl an action is a sequence of statements.
statements are state transitions specified using a combination of boolean and object set expressions.
boolean expressions have the usual semantics and object set expressions represent a set of objects.
to illustrate how statements correspond to state transitions let us define the semantics of the delete expr statement.
note that this statement operates with an object set expression.
assuming that is the set of objects that the expr argument evaluates to and that angbracketleftq q prime angbracketright ds ds whereq angbracketlefto t angbracketrightandq prime angbracketlefto prime t prime angbracketright are the pre and post states of the statement this statement transitions from qtoq primeif and only if x x o prime x o x negationslash x x t prime x angbracketleftr xo xt angbracketright t xo negationslash xt negationslash in other words xis an object in the post state if and only if it is an object in the pre state that is not in xis a tuple in the post state if and only if it is a tuple in the pre state and neither the origin or the target object of xare in .
adsl includes statements for creating and deleting objects creating and deleting tuples between objects variables and assignments branches and foreach loops.
updating objects and tuples is outside our abstraction as objects do not contain basic type fields and as such have no state that can be updated.
adsl expands on the above definition of data models by modeling authentication different user roles the access control policy as well as runtime access control checks that are implemented in the source web application.
the formal definition of these models is discussed in prior work .
b. implementation of symbolic model extraction for rails and activerecord for both adsl and adsl in order to run instrumented execution we have to first install and configure the analyzed application on our own computer.
once we can start the web server we add to it our own symbolic model extraction library that overrides core rails methods with their symbolic versions.
finally we start model extraction of each action by generating http requests that will execute them.
the set of requests the server responds to are dynamically extracted from the configuration of the instrumented server.
this process is fully automated.
activerecord is the object relation mapping orm library employed by rails.
it provides the methods by which data can be managed or stored in the data store.
as such both our models heavily rely on overriding activerecord methods with their symbolic counterparts.
the configuration and usage of activerecord is highly relevant to our models.
table ii shows parts of the target modeling languages that are common to the models we used to verify data integrity or access control.
table ii a contains class static methods and table ii b contains instance object methods.
the first column represents various ruby on rails methods.
the second column explains the semantics of the corresponding method.
finally the third column defines the expression in the target modeling language adsl that is extracted from said method.
this list is not exhaustive because many methods in ruby on rails have multiple aliases different names that achieve the same functionality for developer convenience.
for example model.create attrs is a constructor.
developers can use this method to create a new object of type model setting the newly created object s fields corresponding to the attrs argument.
similarly model.all will return a collection of all objects of type model that exist in the database.
our library will when the rails application is booting up replace core activerecord methods with their instrumented versions.
other libraries that build on top of activerecord do authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
activerecord method semantics adsl expression class.create attrs creates an object with provided attributes basic type values create class class.all load all model objects of this type from the database allof class class.where ... load all model objects in the database that satisfy some criteria subset class class.find id finds an object using the provided unique identifier oneof class a class methods activerecord method semantics adsl expression expr.select ... returns all objects in expr that meet some criterion subset expr expr.association returns object s related to expr via the association expr .association expr.association expr2 associates object expr with expr2 via association association createtuple expr association expr2 expr.association expr2 mutates an association expr .association expr2 expr.delete!
deletes the object delete expr expr.destroy!
deletes the object propagating deletion to associated objects delete expr .assoc delete expr expr.destroy all!
deletes all objects in a collection expression delete expr expr.each block executes block once for each element in expr foreach v in expr block expr.nil?
checks whether expr is null or not isempty expr expr.any?
checks whether expr has at least one object not isempty expr b instance methods t able ii table of various activerecord methods and corresponding adsl expressions not need to be manually specified and overridden as when they implement their functionality on top of core activerecord they become implicitly prepared for instrumentation.
after overriding the core activerecord methods we identify the set of actions that the rails application contains.
we instrument them and execute them one at the time.
each action will return the model of itself and these models make part of the entire model we extract from the applications.
for data integrity verification we make an additional step to extract invariants .
these invariants are written in ruby using a library we developed for this purpose.
adapting our extraction method to extract invariants was straightforward.
for example we added quantification to activerecord objects that can be used to quantify over sets.
adsl similarly requires an additional extraction step and even though it is more involved than invariant extraction it is essentially identical to extraction of other model features.
we extract access control information from cancan configuration .
similar to how we handled activerecord we have manually overridden a few key methods for policy declaration and runtime checks of access control.
v. e xperiments we used symbolic model extraction to extract models from rails applications in order to verify their data integrity and access control properties.
the result of our experiments are summarized in table iii.
we analyzed a total of open source rails applications.
we found these applications from various sources.
we looked at the most starred open source rails applications on github according to the opensourcerails.com website a compilation of open source rails applications categorized by domain and applications investigated by related work.
our implementation of symbolic extraction does not support all versions of rails as that would require a substantial engineering effort.
our tool supports rails up to and including rails .
.
furthermore since we focused on howapplications employ activerecord we did not extract models from applications that bypass activerecord for example if they are not backed by a relational database.
column loc ruby shows the number of ruby lines of code in these applications.
this number does not include javascript html dynamic html generation through irb files or configuration files.
columns classes actions and invariants show the number of model classes actions and invariants respectfully.
as invariants are not part of the core rails framework we wrote them manually for each application after investigating their source code.
we did not write any invariants for bootstrap and illyan because their models were too simple to warrant any non trivial invariants.
column access control shows whether the application employs access control through cancan .
for applications that do we verified access control in addition to data integrity.
column extraction time shows the total amount of time it took to extract models from these applications.
this includes booting up the rails application instrumenting it and executing each action as described in section iv.
we obtained these results on a computer with an intel core i52400s processor running 64bit linux.
memory consumption was typical for starting and running a rails application.
we manually confirmed that the extracted models are correct.
we find the performance and the quality of our model extraction to be more than acceptable for real world use potentially both as part of verification of applications during the quality assurance process and for daily developer use.
a. v erification results for each model that was extracted we used data model integrity verification and access control to verify each application.
for data integrity verification our tool generated set of first order logic fol formulas for each action invariant pair.
we refer to these sets of formulas as verification queries .
a verification query can be used to verify whether an action could potentially invalidate an invariant.
given an action aand authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
loc access extraction v erification avg time per falseapplication ruby classes actions invariantscontrol time sec queries query sec v erified bugs timeoutspositives avare check .
.
bootstrap check .
.
communautaire check .
.
copycopter .
.
corm check .
.
fatfreecrm check .
.
fulcrum .
.
illyan check .
.
kandan check .
.
lobsters .
.
obtvse2 .
.
quant check .
.
redmine .
.
s2l check .
.
sprintapp check .
.
squash .
.
tracks .
.
trado check .
.
wm app check .
.
totals .
.
t able iii experimental results invariant i assuming a pre state in which all invariants hold is it necessarily true that iwill hold in the post state?
if not verification fails and reports an error.
if the application employs access control we generate verification queries that verify access control enforcement in the application.
this verification technique is detailed in prior work .
given an action athat may execute an operation such as create or read over objects in set assuming that the action is invoked by a user with any role is necessarily a subset of the set of objects that users are permitted to operate on?
if not verification fails and reports an error.
v erification queries are translated both for z3 an smt solver and spass a fol theorem prover.
we ran z3 and spass concurrently for each verification query.
if either prover reaches a conclusive result with secods we accept it otherwise we halt both provers and mark the result as inconclusive.
we consider this an acceptable time limit as very few queries for which we reach a conclusive result take more than a second.
spass outperformed z3 in only queries out of .
using our tool to verify models extracted from real world web applications using symbolic extraction we found numerous bugs.
these applications are publicly available and have been developed over years by multiple developers.
neither the original developers or verification by related approaches caught these bugs before us.
most bugs we found are access control bugs.
in particular invalidated verification queries relate to access control.
for example corm a customer relationship manager allows administrators to import data into the database by accessing a special admin panel.
our tool found that the access control check for managing imports is incorrect anybody can import and export data if they know the correct url.
data integrity bugs were present as well having caused invalidated verification queries.
for example in redmine a project management web application when a user is deleted associated data is not properly cleaned up in the database.
thisleads to crashes and strange patterns in the user interface when this invalid data is accessed.
column v erification queries in table iii shows the number of verification queries that were generated for each application.
column avg time per query shows the average time provers took per verification query to reach conclusive results.
column v erified shows the number of verification queries that were proven correct showing that an action preserves an invariant or correctly enforces some aspect of access control.
column bugs shows the number of queries that reported an error and we manually confirmed the error is caused by a bug.
these queries demonstrate either a way to invalidate an invariant or to expose restricted information to the user.
column false positives shows the number of queries that reported an error but that were caused by a deficiency in our implementation instead of an application bug.
all false positives we found were detected by an application creating objects that would invalidate the database but never saving them in the database.
our implementation does not distinguish between objects that were saved in the database from those that are not which we plan to improve on.
finally column timeouts lists the number of verification queries that caused our theorem provers to time out.
b. v erifiability our tool is open source and available online2.w ea l s o uploaded our experimental set online3so that our results can be reproduced.
this includes all configuration and changes we made to run our tool.
this will still require installation of ruby rails corresponding gems and database configuration.
to extract a model from an application the developer needs to first install and setup the application.
this process is different for each application but typically requires installing an appropriate version of ruby associated gems and setting up the database.
even though we do not communicate with authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the database during symbolic model extraction the application still has to establish a connection and validate the schema to start up.
finally the model is extracted using the command rake adsl translate as for verification our library has an executable called bin adsl verify .
in addition to installing ruby and dependencies of our library theorem provers spass and z3 need to be installed and added to the system path variable.
after extracting a model assuming it is stored in a file it can be verified using command bin adsl verify file .
additional command line options can be used to get a more detailed verification report.
vi.
r ela ted work near et al.
developed rubicon a web application verification tool that adds quantification to unit tests for verification using alloy .
their symbolic execution is fully explained in a technical report .
like them we use the dynamic features of an unmodified ruby runtime to override concrete methods with their symbolic counterparts.
they both override methods with their symbolic counterparts only once before symbolic execution has started.
considering that they use classical symbolic execution in a ruby interpreter there are some key differences between our methods most importantly we extract models from dynamically generated source code and don t depend on smt solvers for branch condition resolution.
recently they used their symbolic execution technique to extract access control signatures from rails programs .
their experiments are limited to applications much smaller and simpler than ours.
we suspect this is caused by their extraction method not supporting dynamic code generation.
rubyx is a tool for symbolic execution in rails that can be used to find access control bugs.
it uses manually written scripts each of which has to setup a database with symbolic values execute an action manually capture relevant output of the action and check whether specific post conditions hold.
we require no manual effort from the developer both in terms of specifying expectations of correctness and scenarios under which these expectations should be met.
furthermore symbolic model extraction does not rely on smt solvers and a custom symbolic runtime.
because we do not use smt solvers during model extraction we are not limited to conditionals that can be specified in decidable logic fragments.
we accomplish model extraction without a custom runtime that keeps track of symbolic values.
furthermore they use drails to make specific usages of rails code explicit whereas we capture metaprogramming natively.
railroadmap is an automated tool for verification of access control in rails using cancan and pundit.
their program analysis is limited to parsing a few specific rails files and examining the ast not even taking file dependencies into account.
as such their program analysis is difficult to make usable in practice.
their experimental evaluation focuses on small applications all but a few had a single developer and were abandoned in weeks.
we extracted semantically rich models from some of the applications they analyzed.
we couldnot extract models from all of their applications because they were written in rails a long deprecated version of rails which our tool does not support.
this work relies on previous work for data model integrity verification and access control verification .
these earlier contributions are on efficient detection of bugs and verification of rails web applications using theorem provers.
this is achieved by extracting models from rails applications and translating them to first order logic.
these earlier papers focus on translation of real world behaviors to first order logic in a way that will be analyzed by theorem provers quickly and with high probability of success.
this paper in contrast focuses on model extraction.
the extraction techniques we used previously were limited e.g.
they did not support branch conditions and had a number of problems caused by an unprincipled solution that was implemented out of necessity.
in addition these previous papers did not elaborate on the extraction method they employed.
this paper presents a novel model extraction method that is applicable to other programming and modeling languages.
access control bugs are sometimes found with techniques not specifically tailored for finding access control bugs .
these methods typically require more effort than our automated method and may miss bugs.
symbolic execution is a well known technique for program analysis.
instead of executing source code in a normal runtime symbolic execution will execute source code in an alternate runtime operating on symbolic values instead of concrete values.
these symbolic values are abstractions of concrete values.
sa t and smt solvers are used in branch conditions to determine if branch conditions are satisfiable in order to guide path exploration for the purpose of testing.
we use an unmodified ruby runtime which makes our technique easier to implement and we do not use solvers to resolve branch conditions as our purpose does not extend beyond extracting the model of a branch condition.
concolic execution extends on symbolic execution by keeping track of concrete values as well as symbolic.
this is useful when solvers are not able to check satisfiability or find satisfying assignments to a branch conditions.
one could look at our treatment of dynamic features as concolic as we execute them concretely instead of symbolically.
vii.
c onclusion in this paper we presented an approach for model extraction from applications written in dynamically typed interpreted languages.
this is done by using the source language interpreter in order to handle dynamic code generation instrumenting code so that executing it returns the model that corresponds to it implementing instrumentation in the source language in order to be able to instrument dynamically generated code and executing both branches of a branch statement in order to fully explore code.
we experimentally demonstrate that symbolic model extraction can be used to efficiently extract models of real world applications and to verify data integrity and access control properties.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.