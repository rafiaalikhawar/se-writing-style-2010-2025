locking discipline inference and checking michael d. ernst alberto lovato damiano macedonio fausto spoto javier thaine university of washington usa universit di verona italy julia srl italy mernst cs.washington.edu alberto.lovato univr.it damiano.macedonio juliasoft.com fausto.spoto univr.it jthaine cs.washington.edu abstract concurrency is a requirement for much modern software but the implementation of multithreaded algorithms comes at the risk of errors such as data races.
programmers can prevent data races by documenting and obeying a locking discipline which indicates which locks must be held in order to access which data.
this paper introduces a formal semantics for locking specifications that gives a guarantee of race freedom.
a notable difference from most other semantics is that it is in terms of values which is what the runtime system locks rather than variables.
the paper also shows how to express the formal semantics in two different styles of analysis abstract interpretation and type theory.
we have implemented both analyses in tools that operate on java.
to the best of our knowledge these are the first tools that can soundly infer and check a locking discipline for java.
our experiments compare the implementations with one another and with annotations written by programmers showing that the ambiguities and unsoundness of previous formulations are a problem in practice.
.
introduction concurrency allows computations to occur inside autonomous threads which are distinct processes that share the same heap memory.
threads increase program performance by scheduling parallel independent tasks on multicore hardware and enable responsive user interfaces .
however concurrency might induce problems such as data races concurrent access to shared data with consequent unpredictable or erroneous software behavior.
such errors are difficult to understand diagnose and reproduce at run time.
they are also difficult to prevent testing tends to be incomplete due to nondeterministic scheduling choices made by the runtime and model checking scales poorly to real world code.
the standard approach to prevent data races is to follow a locking discipline while accessing shared data always hold a given lock when accessing a given shared datum.
it is all too easy for a programmer to violate the locking discipline.
therefore tools are desirable for formally expressing the locking discipline and for verifying adherence to it .
the book java concurrency in practice jcip proposed the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may austin tx usa c copyright held by the owner author s .
publication rights licensed to acm.
isbn .
.
.
.
guardedby to express a locking discipline and ensure threadsafety.
the intention is that when a locking discipline is expressed with guardedby then no set of operations performed sequentially or concurrently on instances of a thread safe class can cause an instance to be in an invalid state a thread safe class is one that use synchronization whenever accessing the state .
this annotation has been widely adopted for example github contains about uses of the annotation in files in an appendix jcip proposed a specification for guardedby .
one of our contributions is our observation that this widely used specification is ambiguous indeed different tools interpret it in different ways .
a more important observation is that the specification is incorrect every interpretation of it permits data races and therefore violates its design goal.
another of our contributions is a formal specification for guardedby that satisfies its design goals and prevents data races.
this paper describes the semantics and gives examples but for reasons of space the full formal development appears in a companion paper .
we have instantiated this specification in two styles of analysis abstract interpretation and type based analysis.
we have also implemented two tools that implement our specification.
one tool uses type checking to validate guardedby annotations that are written in java source code.
the other tool uses abstract interpretation to infer valid guardedby annotations for unannotated programs.
our techniques are not specific to java and generalize to other languages.
it is not the goal of these implementations to detect race conditions or give a guarantee that they do not exist.
the inference tool determines what locking discipline a program uses and the checking tool determines whether a program obeys a given locking discipline without judging whether the discipline is too strict or too lax for some particular purpose.
in an experimental evaluation we compared these tools to one another and to programmer written annotations.
our evaluation shows that programmers who use the guardedby annotation do not necessarily do so consistently with jcip s rules and even when they do their programs still suffer data races.
an informal definition of guardedby is that when a programmer writes guardedby e on a program element then a thread may use the program element only while holding the lock e. namely the documentation for jcip s guardedby states the field or method to which this annotation is applied can only be accessed when holding a particular lock .
section illustrates important ambiguities in this informal definition.
all of these need to be resolved by a formal definition.
the most important problem with jcip s definition is that it provides name protection rather than value protec1the desired locking discipline is unknowable some race conditions are benign a programmer may intend locking to be managed by a library or by clients locking may not be necessary for objects that do not escape their thread etc.
ieee acm 38th ieee international conference on software engineering tion .
name protection is fine for primitive values which cannot be aliased in java.
value protection is needed in order to prevent data races on reference values due to aliasing and because the java language specification defines locking in terms of values rather than names .
unfortunately most tools that check guardedby annotations use jcip s inadequate definition and therefore permit data races.
our definition prevents data races by providing value protection if a reference ris guarded by e then for any value v stored in r v s fields are only accessed while the lock eis held.
at run time a lock expression eis held on a given thread at a given time ifjava.lang.thread.holdslock e evaluates to true on that thread at that time.
checking and inference of this definition requires tracking values vas they flow through the program because the value may be used through other variables and fields not necessarily r. since this is relevant for reference values only this article considers value protection for reference variables and fields only.
the contributions of this paper include a sound semantics for guardedby that guarantees the absence of data races unlike the interpretation adopted by previous definitions and tools.
the semantics is defined in terms of uses of values objects rather than uses of names variables .
two instantiations of the locking discipline semantics using the formalisms of abstract interpretation and type systems.
two independent implementations for java as a modular type analysis and as a whole program abstract interpretation.
case studies of programmers use of guardedby in practice.
previous specifications of the annotation have been vague and we note places where the programmers interpretation does not provide a guarantee against data races.
furthermore we note where programmers have written annotations that are incorrect illustrating the need for tools like ours.
a practical comparison of the strengths of the two complementary and independent implementations above modular type based and global abstract interpretation.
the rest of this paper is organized as follows.
section justifies the need for a locking discipline in concurrent programs.
section describes the type system approach.
section presents the abstract interpretation approach.
section shows experiments with implementations of both approaches.
section presents related work.
finally section concludes.
.
locking discipline semantics this section shows how a locking discipline can enforce mutual exclusion and the absence of data races lays out the design space for a locking discipline semantics and discusses why such a semantics should provide value protection rather than name protection.
.
dining philosophers example to illustrate how to specify a locking discipline consider the traditional dining philosophers example.
more examples are given later.
a group of philosophers sit around a table there is a fork between each pair of philosophers and each philosopher needs its left and right forks to eat.
the locking discipline provides each fork with a lock and a philosopher must hold the lock in order to use the fork this guarantees mutual exclusion and the absence of race conditions.
to prevent deadlock the locks are acquired in increasing order but that is not a concern of this paper.
figure shows java code for the fork.
the fork contains mutable information which philosopher holds it in order to demonstrate how a locking discipline can protect access to a mutable field.
a philosopher figure is modeled as a thread whose runmethod repeatedly thinks locks its two forks eats and unlocks the forks.
the1 public class fork implements comparable fork private static int nextid private final int id nextid who is holding the fork or null if on the table private philosopher usedby null void pickup philosopher philosopher this.usedby philosopher void drop this.usedby null public int compareto guardedby itself fork other return id other.id public synchronized string tostring if usedby !
null return fork id used by usedby.getname else return fork id on the table figure a fork possibly held by a philosopher.
public class philosopher extends thread private final guardedby itself fork left private final guardedby itself fork right philosopher string name guardedby itself fork left guardedby itself fork right super name a fixed ordering avoids deadlock if left.compareto right this.left left this.right right else this.left right this.right left public void run while true think synchronized left left.pickup this synchronized right right.pickup this eat right.drop left.drop private void think ... holding left right private void eat ... figure a philosopher.
code illustrates a situation in which classes cooperate to implement a synchronization policy rather than the less challenging case of all code being in the same class.
in java each object is associated with a monitor or intrinsic lock.
a synchronized statement or method locks the monitor and exiting the statement or method unlocks the monitor.
java also provides explicit locks which our theory and implementations handle but which this paper omits for brevity.
the guardedby type qualifiers express the locking discipline.
in the semantics that we will introduce in this article the type qualifier guardedby itself on a variable s type states that the variable holds a value vwhose non final fields are only accessed at moments 1134when v s monitor is locked by the current thread.
our tools infer and verify the guardedby annotations in these figures.
the guardedby itself type qualifiers on fields left and right guarantee that philosophers use their forks only after properly locking them.
the unlocked access to the final field idon line of fig.
does not violate the guardedby itself specification.
.
design space for locking discipline semantics recall the informal definition of guardedby when a programmer writes guardedby e on a program element then a thread may use the program element only while holding the lock e. this definition suffers the following ambiguities related to the guard expression e. .may a definite alias of ebe locked?
given a declaration guardedby lock object shared is the following permitted?
object lockalias lock synchronized lockalias ... use shared ... .iseallowed to be reassigned while locked?
given a declaration guardedby lock object shared is the following permitted?
synchronized lock lock new object ... use shared ... what about other side effects to e?
given a declaration guardedby anobject.field object shared are the following permitted?
synchronized anobject.field foo might side effect anobject and reassign field ... use shared ... synchronized anobject.field foo might side effect but not reassign field ... use shared ... .should ebe interpreted at the location where it is defined or at the location where it is used?
given a declaration class c guardedby this object field ... are the following permitted?
c c synchronized this ... use c.field ... synchronized c ... use c.field ... the latter use assumes contextualization such as viewpoint adaptation .
the informal definition suffers further ambiguities in the interpretation of the program element being guarded .
these can be summarized by asking what is a use of the shared program element?
is it any occurrence of the variable name or only certain operations do uses of aliases count and are reassignment and side effects permitted?
more relevantly does the guardedby annotation specify restrictions on uses of a variable name name protection or restrictions on uses of values value protection ?
current definitions of guardedby do not provide guidance about any of the ambiguities regarding the lock expression.
thus there is a danger that different tools interpret them differently including unsound interpretations that do not prevent data races.
there is also1 public class observable private guardedby this list listener listeners new arraylist public observable public observable observable original copy constr.
synchronized original listeners.addall original.listeners public void register listener listener synchronized this listeners.add listener public list listener getlisteners synchronized this return listeners figure an implementation of the observer design pattern in which locking is performed on the container observable object.
this implementation suffers data races.
the implementation satisfies the nameprotection semantics for guardedby but not the value protection semantics.
a danger that programmers will assume a different definition than a tool provides and thus do not obtain the guarantee they expect.
current definitions of guardedby are clearer about what constitutes a use of the program element any access to that is lexical occurrence of the name.
this definition provides name protection but unfortunately it does not prevent data races.
a program that obeys this locking discipline might not be thread safe and may still suffer data races as illustrated below.
therefore any definition that provides name protection is in general incorrect because it does not satisfy the stated goals of the guardedby annotation.
.
name protection and value protection name protection and value protection are distinct and incomparable.
neither one implies the other.
to illustrate the differences consider an implementation of the observer design pattern which is a key part of model view controller and other software architectures.
figures and are patterned after the implementation found in the java jdk.
an observable object allows clients to concurrently register listeners.
when an event of interest occurs a callback method is invoked on each listener.
synchronization is required to avoid data races.
synchronization in the register method and copy constructor prevents simultaneous modifications of the listeners list which might result in a corrupted list or lost registrations.
synchronization is needed in thegetlisteners method as well or otherwise the java memory model would not guarantee the inter thread visibility of the registrations.
in fig.
synchronization is performed on the container object and in fig.
synchronization is performed on a field.
figure satisfies all interpretations of the name protection semantics every use of listeners occurs at a program point where the current thread locks its container.2nevertheless a data race is possible since two threads could call getlisteners and later access the returned value concurrently.
this demonstrates that the name protection semantics does not prevent data races.
figure does not satisfy the value protection semantics which prevent data races because the return type of getlisteners is not compatible with thereturn statement.
figure could be made to satisfy the valueprotection semantics by annotating the return type of getlisteners as guardedby this which would force the client program to do 2it also satisfies an interpretation of guardedby that does not do contextualization or viewpoint adaptation since the constructor is implicitly synchronized on this.
public class observable private guardedby itself list listener listeners new arraylist public observable public observable observable original copy constr.
synchronized original.listeners listeners.addall original.listeners public void register listener listener synchronized listeners listeners.add listener public guardedby itself list listener getlisteners synchronized listeners return listeners figure an implementation of the observer design pattern in which locking is performed on the listeners field.
its own locking and would prevent data race.
figure specifies a different locking discipline.
first consider the value protection semantics.
guardedby itself means that all dereferences field accesses of the value of listeners occur while the current thread locks that value.
the annotation on the return type of getlisteners imposes the same requirement on clients of observable .
the field listeners could have been annotated guardedby listeners but the syntax for the return type of getlisteners would have been more complex thus the guardedby itself syntax.
figure also satisfies the name protection semantics.
depending on how the semantics handles aliasing and side effects the semantics may prevent clients of this program from suffering data races.
figure s choice of locking the field rather than the container permits additional flexibility.
consider the following client code list listener l new observable original .getlisteners ... use l ... at the use of l there is no syntactic handle for the container and it might even have been garbage collected.
instead the annotation guardedby itself is perfectly meaningful for l. regardless of other choices for the semantics of guardedby the name protection and value protection variants are not comparable neither entails the other.
in fig.
field xis declared as guardedby itself .
this annotation holds in the value protection semantics since its value is only accessed at line inside a synchronization on itself but not in name protection semantics xis used at line .
field yis guardedby this.x for name protection but not for value protection its value is accessed at line via w. in some cases the semantics do coincide.
field zis guardedby itself according to both semantics its name and value are only accessed at line where they are locked.
field wis not guardedby according to any semantics its name and value are accessed at line .
.
definition of guardedby we can now state our semantics for the guardedby annotation.
in this article by dereference of a value vwe mean the access of a non final field of v. the key idea is that values are protected rather than names and that dereferences of vare considered uses of v. suppose that the type of expression xcontains the qualifier guardedby e .
a program satisfies the locking discipline if at program point pwhere the program dereferences a value that has ever been bound to x the program holds the lock on the value of expression e. furthermore the value of emust not change in any thread during the time that the thread holds the lock.
the protection is1 public class k private k1 x new k1 private k2 y new k2 private k1 z private k2 w public void m z x w new k2 synchronized z y z.f w y w.g new object class k1 k2 f new k2 class k2 object g new object name value var protection protection x gb itself y gb this.x z gb itself gb itself w figure comparison of name protection and value protection semantics for guardedby abbreviated as gb .
shallow since it applies to the value that xevaluates to not to all values reachable from it.
there is no restriction on copying values including passing values as arguments including as the receiver or returning values.
this definition resolves the ambiguities noted in section .
.
a definite alias of the guard expression eis permitted to be locked.
the guard expression is not allowed to be reassigned to a different value while locked.
side effects to the guard value are permitted since they do not affect the monitor.
the lock expression undergoes viewpoint adaptation so that it makes sense in the context of use.
a use of the program element is a dereference of any value it may hold regardless of aliasing reassignment and side effects.
we have formalized this definition and also an alternate one that provides name protection as a structural operational semantics in the style of plotkin .
our formalization includes a definition of a data race and a proof that our definition prevents data races.
for reasons of space the formal development appears in a companion paper .
a set of guardedby annotations expresses a locking discipline.
an inference tool infers a maximal locking discipline that the program satisfies.
a checking tool verifies that the program satisfies its locking discipline.
every program trivially satisfies the empty locking discipline.
.
definition of holding the guardedby annotation is sufficient for expressing a locking discipline.
inferring or checking a locking discipline requires reasoning about which locks are held at any given point in the program.
our implementations provide a holding e annotation to express these facts explicitly to aid in program comprehension or modular checking.3it annotates a method declaration to indicate that when the method is called the current value of e possibly viewpointadapted is locked.
an example appears on line of fig.
.
.
locking discipline checking we have expressed our semantics as a type system.
then we implemented the type system as a modular static analysis that verifies a locking discipline expressed as java guardedby and holding annotations.
it is publicly available at .
if the type checker issues no warnings for a given program then it guarantees that the program satisfies the locking discipline that is a value that is held in an expression of guardedby type in the program is never dereferenced unless the values of all the lock expressions indicated in the guardedby annotation are locked by the thread performing the dereference at the time of the dereference.
3jcip overloads the name guardedby for two distinct purposes as a field annotation and a method precondition.
for clarity this paper always refers to the latter as holding.
gb e1 e2 ... gb gb e1 gb e2 figure the subtype hierarchy of the guardedby type qualifiers in the locking discipline type system.
e1ande2are lexically distinct expressions.
our approach is standard for a static analysis.
the goal is to determine facts about values but the program is written in terms of variables and expressions.
therefore the analysis computes an approximation an abstraction in terms of expressions.
our static analysis simultaneously computes two approximations.
the analysis approximates the values that each expression in the program may evaluate to.
the analysis approximates the locks that the program currently holds.
the implementation represents these approximations using annotations such as guardedby and holding.
both abstractions are sound so that if the type system approves a program the program satisfies the locking discipline however the abstraction is conservative so the type system might reject a program that never suffers a race condition at run time.
.
type qualifiers and hierarchy the type system contains a single parameterized type qualifier guardedby .
figure shows the subtype hierarchy.
one surprising feature is that no two guardedby annotations are related by subtyping.
if eset16 eset2 then guardedby eset1 and guardedby eset2 are siblings in the type hierarchy.
it might be expected that guardedby x y tis a supertype of guardedby x t. the first type requires two locks to be held and the second requires only one lock to be held and so could be used in any situation where both locks are held.
our type system conservatively prohibits this in order to prevent type checking loopholes that would result from aliasing and side effects that is from having two