automatic inference of code transforms for patch generation fan long mit eecs csail usa fanl csail.mit.edupeter amidon ucsd usa peter picnicpark.orgmartin rinard mit eecs csail usa rinard csail.mit.edu abstract we present a new system genesis that processes human patches to automatically infer code transforms for automatic patch generation.
we present results that characterize the effectiveness of the genesis inference algorithms and the complete genesis patch generation system working with real world patches and defects collected from java projects.
to the best of our knowledge genesis is the first system to automatically infer patch generation transforms or candidate patch search spaces from previous successful patches.
ccs concepts software and its engineering automatic programming software testing and debugging keywords patch generation code transform search space inference acm reference format fan long peter amidon and martin rinard.
.
automatic inference of code transforms for patch generation.
in proceedings of 11th joint meeting of the european software engineering conference and the acm sigsoft symposium on the foundations of software engineering paderborn germany september esec fse pages.
introduction automatic patch generation systems hold out the promise of significantly reducing the human effort required to diagnose debug and fix software defects.
the standard generate and validate approach starts with a set of test cases at least one of which exposes the defect.
it deploys a set of transforms to generate a search space ofcandidate patches then runs the resulting patched programs on the test cases to find plausible patches that produce correct outputs for all test cases.
all previous generate and validate systems work with a set of manually crafted transforms to patch bugs that fall within the scope of these transforms.
.
genesis we present genesis a novel system that infers code transforms for automatic patch generation systems .
given a set of successful human patches drawn from available revision histories genesis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse september paderborn germany association for computing machinery.
acm isbn .
.
.
.
subsets of patches to infer transforms that together generate a productive search space of candidate patches.
genesis can therefore leverage the combined patch generation expertise of many different developers to capture a wide range of productive patch generation strategies.
genesis applies the inferred transforms to successfully patch bugs in previously unseen applications.
to the best of our knowledge genesis is the first system to automatically infer patch generation transforms or candidate patch search spaces from successful patches.
transforms each genesis transform has two template abstract syntax trees asts .
one template ast matches code in the original program.
the other template ast specifies the replacement code for the generated patch.
template asts contain template variables which match subtrees or subforests in the original or patched code.
template variables enable the transforms to abstract away application specific details to capture common patterns implemented by multiple patches drawn from different applications.
generators many useful patches do not simply rearrange existing code and logic they also introduce new code and logic.
genesis transforms therefore implement partial pattern matching in which the replacement template ast contains free template variables that are not matched in the original code.
each of the free template variables is associated with a generator which systematically generates new candidate code components for the free variable.
this new technique which enables genesis to synthesize new code and logic in the candidate patches is essential to enabling genesis to generate correct patches for previously unseen applications.
search space inference with ilp a key challenge in patch search space design is navigating an inherent tradeoff between coverage and tractability .
on one hand the search space needs to be large enough to contain correct patches for the target class of defects coverage .
on the other hand the search space needs to be small enough so that the patch generation system can efficiently explore the space to find the correct patches tractability .
genesis navigates this tradeoff by formulating and solving an integer linear program ilp whose solution maximizes the number of training patches covered by the inferred search space while acceptably bounding the number of candidate patches that the search space can generate.
.
experimental results we use genesis to infer patch search spaces and generate patches for three classes of defects in java programs null pointer np out of bounds oob and class cast cc defects.
working with a training set that includes np patches oob patches and cc patches drawn from open source applications genesis infers a search space generated by transforms.
our benchmark defects include np oob and cc defects from open source applications.
all of the benchmark applications are systematically collected from github and contain up to 235k lines of code.
with the inferred transforms genesis generates esec fse september paderborn germany fan long peter amidon and martin rinard correct patches for out of the defects np oob and cc defects .
we compare genesis with par a previous patch generation system for java that works with manually defined patch templates.
for the same benchmark set the par templates generate correct patches for fewer defects specifically np and oob defects .
we attribute these results to the ability of the automated genesis inference algorithms to navigate complex patch transform tradeoffs at scale.
genesis works with hundreds to over a thousand candidate transforms to obtain productive search spaces generated by tens to over a hundred selected transforms many more transforms than any previous generate and validate system.
deploying this many transforms enables genesis to capture a broad range of patch patterns with the transforms selected to ensure the overall tractability and coverage of the resulting patch search space.
.
contributions transforms with template asts and generators we present novel transforms with template asts and generators for free template variables.
these transforms enable genesis to abstract away patch and application specific details to capture common patch patterns and strategies implemented by multiple patches drawn from different applications.
generators enable genesis to synthesize the new code and logic required to obtain correct patches for defects that occur in large real world applications.
patch generalization we present a novel patch generalization algorithm that given a set of patches automatically derives a transform that captures the common patch generation pattern present in the patches.
this transform can generate all of the given patches as well as other patches with the same pattern in the same or other applications.
search space inference we present a novel search space inference algorithm.
starting with a set of training patches this algorithm infers a collection of transforms that together generate a search space of candidate patches with good coverage and tractability.
the inference algorithm includes a novel sampling algorithm that identifies promising subsets of training patches to generalize and an ilp based solution to the final search space selection problem.
complete system and experimental results we present a complete patch generation system including defect localization and candidate patch evaluation algorithms that uses the inferred search spaces to automatically patch defects in large real world applications.
we also present experimental results from this complete system.
to the best of our knowledge genesis is the first system to automatically infer patch generation transforms or candidate patch search spaces from previous successful patches.
all experimental data including the genesis source code inferred templates and generated patches are available at patchgen .
transform inference we next present via an example an overview of the genesis transform inference algorithm.
genesis works with a training set of successful human patches to infer a set of patch generation transforms.
in our example the training set consists of human patches collected from github repositories.
patch sampling and generalization the genesis inference algorithm works with sampled subsets of patches from the training set.
for each subset it applies a generalization algorithm to infer a transform that it can apply to generate candidate patches section .
.
figure presents one of the sampled subsets of patches in our example the first patch disjoins the clause mappertypeelement null to an if condition the second patch conjoins the clause subject!
null to a return value and the third patch conjoins the clause material.getmaterials gettypeid !
null to an if condition.
these patches are from three different applications specifically mapstruct 6d7a4d modelmapper d85131 and bukkit f13115.
genesis generalizes these patches to infer the transform p1 in figure .
when applied p1can generate all of the sampled three patches as well as other patches for other applications.
template anatomy each transform has a template .
in our example the template is v0 v3 op2 null op1 v0 figure presents this template in graphical form .
the transform has an initial template ast t0 which matches a boolean expression v0 in the unpatched program.
v0must occur within a function body if all of the training patches had modified if conditions t0would have reflected that more specific context .
the transform also has a replacement template ast t1 which replaces the matched boolean expression v0with a patch of the form v3 op2 null op1 v0 .
here v3 op2 and op1areunmatched template variables .
each such variable is associated with a generator which enumerates candidate code components for the variable.
generator constraints generator constraints control the components that the generator will enumerate.
the generator constraints for op2and op1 op2 !
and op1 simply specify sets of operators to enumerate.
the generator constraints for v3control the ast subtrees that the generator will enumerate for v3.v3 expr states that v3must be an expression.
nodes v3 call varstates that v3can contain only method calls or variable