assessing the threat of untracked changes in software evolution andre hora facom ufms brazil hora facom.ufms.brdanilo silva marco tulio valente aserg group dcc ufmg brazil danilofs mtov dcc.ufmg.brromain robbes swse group free university of bozen bolzano italy rrobbes unibz.it abstract while refactoring is extensively performed by practitioners many mining software repositories msr approaches do not detect nor keep track of refactorings when performing source code evolution analysis.
in the best case keeping track of refactorings could be unnecessarywork intheworstcase these untrackedchanges could significantlyaffecttheperformanceofmsrapproaches.sincethe extent of the threat isunknown the goal of this paper is toassess whether it is significant.
based on an extensive empirical study we answerpositively wefoundthatbetween10and21 ofchangesatthemethodlevelin15largejavasystemsareuntracked.thisresults in a large proportion of entities that may have their histories splitbythesechanges andameasurableeffectonatleasttwomsr approaches.
we conclude that handling untracked changes should be systematically considered by msr studies.
ccs concepts software and its engineering software evolution keywords mining software repositories software evolution refactoring acm reference format andre hora danilo silva marco tulio valente andromain robbes.
.
assessing the threat of untracked changes in software evolution.
in icse 40th international conference on software engineering may june gothenburg sweden.
acm new york ny usa pages.
https introduction mining software repositories msr techniques are helping to improveourunderstandingofsoftwaredevelopmentandcontributing totheimplementationofanewgenerationofsoftwareengineering tools.
many of the existing msr techniques are based on the analysis of changes performed on source code repositories .
for example change based techniques have been proposed to support library migration change prediction bug fixing warningsprioritization andexpertise calculation to name a few.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may june gothenburg sweden association for computing machinery.
acm isbn ... .
methods and classes changed on each commit.
for example by mining the history of the methods in a system change based techniques can learn that methods that depend on type aare often updated to depend on an improved type a .
a recommendation canthenbeprovidedtoalertdevelopersaboutthemethodsnotyet updated in the system.
however these techniques require tracking the changes along all versions of each individual method or class inthesystemunderanalysis.thechallengeisthatsomechanges invalidate this tracking when it is solely based on the names of the trackedentities.specifically refactoringsmayintroducediscontinuitiesinname basedtrackingstrategies.forinstance amethod rename or move can be misinterpreted as the disappearance of a methodandtheappearanceofabrandnewone splittingitshistory andthusinvalidatethetracking.wecallthechangesthataffectthe names of code entities untracked changes this definition is detailed insection2 .ifnotproperlyhandled untrackedchangesmayhave a negative impact on the accuracy of msr based techniques.
whilethethreatofuntrackedchangeshasbeenacknowledged intheliterature severalexamplesarepresentedinsection3 toour knowledge the actual extent of these changes on msr studies has notbeeninvestigated.assessingtheextentofthreatstomsrstudies is essential prior work has investigated bias in bug fix datasets ornon essentialchanges .inthispaper weperformsucha study we assess the frequency extension and impact of the threat of untracked changes.
we detail our methodology in section and our selection of case studies popular java systems in section .
we then answer the following research questions rq1.whatisthefrequencyofuntrackedchanges?
insection6 we find that between and of method level changes and2and15 ofclass levelchangesareuntracked.themost common ones are due to rename extract and move method.
rq2.whatistheextensionofuntrackedchanges?
section7 showsthat25 ofentitieshaveatleastoneuntrackedchange intheirhistories andthusmayhavetheirhistorysplit.in the most changed entities the proportion raises to .
rq3.whatistheimpactofuntrackedchangesinexistingmsrbasedapproaches ?insection8 weinvestigatetheconcrete impactofuntrackedchangesintwomsrapproaches namely apievolutionandapico usagerulemining.wefindthat on the median up to .
and .
respectively more rules are discovered when untracked changes are considered.
thus thecontributionsofthisworkaretwofold i weprovidean empiricalstudytoassessthefrequencyandextensionofuntracked changes at a large scale and ii we measure the concrete impact of untracked changes in two msr based approaches.
acm ieee 40th international conference on software engineering authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden andre hora danilo silva marco tulio valente and romain robbes wediscusstheimplicationsandthreatstovalidityofourstudyin sections9and10 respectively.finally wecoverrelatedwork studiesofthreatstomsrstudies andapproachestodetectuntracked changes in section and conclude in section .
tracked and untracked changes this section defines the two categories of changes that we analyze in this study.
during software evolution two kinds of changes can occur to code entities such as classes and methods tracked and untrackedchanges.a trackedchange preservestheentitynameand modifiesitssourcecode.thus anentityinversion ncanbedirectly matched to its following version n .
in contrast an untracked changemodifiestheentityname andmayalsomodifyitssource code.theyoccurdueto forexample renameormoverefactorings.
in addition an untracked change may also spawn a new entity for example as the result of extract method refactorings.
therefore an entity in version nis not matched to its version n unless the untracked change is resolved with the support of a refactoring detection approach e.g.
.
figure1illustratesexamplesoftrackedanduntrackedchangesin foursourcecodeversions.eachboxrepresentsaclassanditsmethods and each arrow represents an evolutionary change between two consecutive versions.
class fooand its method ma undergo sometrackedchanges solidarrow sincetheydonotchangeentity names.
thus to understand the evolution of fooandma one can trace them backward or forward.
for example the last version ofma can be straightforwardly traced back to its first version andvice versa.ontheotherhand class baranditsmethod mb undergo some untracked changes dashed arrow .
method mb is renamed to mx in version and then to my in version class barisalsorenamedto bazinversion4.inthiscase my inversion may not be traced back to its originating method mb in version duetothemethodrenaming.considernowthemorechallenging scenario method mc ismovedfromclass bartoquxinversion3 and then method me is extracted from mc in version .
notice that two non trivial untracked changes happen move and extract method.inthiscase methods mc andme inversion4haveboth theirorigininversion1of mc .therefore iftheuntrackedchange is not resolved method me may be simply misdetected as a new method and its actual origin may not be found.
class foo ma ... class bar mb ... mc ... class foo ma ... class bar mx ... mc ... class foo ma ... class bar mx ... class foo ma ... class baz my ... class qux mc ... class qux mc ... me ... tracked change untracked changeversion version version version legend figure example of tracked and untracked changes.
untracked changes at the class level e.g.
class renaming or moving behavesimilarly and ifunresolved canbemisdetected in the same fashion albeit on a larger scale since losing track of a class means also losing track of its methods.
1another name to trackedanduntracked changes could be history preserving and history destroying changes respectively.
the threat of untracked changes in this section we present three msr research lines affected by untracked changes.
we illustrate each scenario with real world examples extracted from open source projects.
we conclude the section by generalizing our discussion to other affected research lines and state the problem we investigate.
.
scenario mining code evolution the first scenario comes from a research line intended to mine codeevolution.themainideaistocomparetwoversionsofacode entity andtolearnfromthedifferences.applicationsofthisline are broad including learning how bugs are fixed detection of behavioralbreakingchanges andextractionofrulestosupport library migration .
figure illustrates an example in thecontextoflibrarymigration fromprojectwordpress android.
versionnhas a reference to class vectorthat is replaced by a reference to listin version n .
the example shows a tracked change method blog inversion nisdirectlymatchedtomethod blog inversion n .bycomparingthedifferencesbetweenboth method versions one may infer the rule vector list.
public blog int blog id throws exception instantiate a new blog vector object blogvals wordpress.wpdb.loadsettings blog id if blogvals !
null ... public blog int blog id throws exception instantiate a new blog list object blogvals wordpress.wpdb.loadsettings blog id if blogvals !
null ... version n version n figure two versions of method blog .
rule vector listcan be inferred by comparing both method versions project wordpress android .
considertheexampleinfigure3 fromprojectokhttp.3version nhas an invocation to fileinputstream that is replaced by an invocationto okio.source inversion n .theexamplepresents an untracked change method newinputstream in version nis renamed to newsource in version n .
thus unless the method renaming is resolved this change may be seen as a removal of newinputstream andanadditionof newsource .inthiscase these methods would not be matched and consequently the rule fileinputstream okio.source would not be inferred.
public source newsource int index throws ioexception ... try return okio.source entry.cleanfiles catch filenotfoundexception e ... public inputstream newinputstream int index throws ioexception ... try return new fileinputstream entry.cleanfiles catch filenotfoundexception e ... version n version n figure method newinputstream is renamed to newsource .
rule fileinputstream okio.source may not be detected after a renaming project okhttp .
2change available at 3change available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assessing the threat of untracked changes in software evolution icse may june gothenburg sweden theliteraturerecognizestheissuescausedbyuntrackedchanges suchasclassormethodrenaming.commonly theyaretreatedas threats to validity or limitations.
for example in the context of apievolution horaetal .
state apichangesareautomatically produced by applying the technique on the set of method call changesbetweentwoversionsofonemethod .similarly inthecontext of bug fixing kim et al .
notice our approach is based on comparing a source code file of two versions so the bugs captured andfixessuggestedareonlyfile by filebased .inbothcases rename refactoringsarenotresolved.raemaekersetal .
plainlystate wedetectrenamedormovedunitsasunitsthatareremovedfirstand added later .
in the domain of behavioral breaking changes soares etal.
note asimilarthingoccurswhenrenamingaclass.we cannot compare the renamed method s behavior directly .
.
scenario prioritizing code warnings thesecondscenariocomesfromaresearchlinemeanttoprioritize warnings orcodeviolations reportedbystaticanalysistools such as findbugs pmd and checkstyle .
these tools are used to find common programming issues related to performance security legibility etc.inpractice staticanalysistoolsareknownto report too many warnings.
consequently most reported warnings are unlikely to be fixed by developers which are known as false positives .
inthis context researcherspropose approaches tofilteroutfalsepositives e.g.
.acommon approach is to detect the most fixed warnings over time which are more likely to be relevant than warnings never fixed by any developer.
for example the warning method parameters should be final 4is systematically fixed in project easy properties.5thus such warning could receive a high prioritization in this project.
considernowtheexampleinfigure4 whichshowstwoversions ofmethod invoke inprojectapachetomcat.6versionncontains a warning i.e.
explicit initialization with null that seems to be fixed in version n .
however the warning is not fixed but only moved to methods findmethod andbuildparameters in version n as the result of a extract method refactoring.
in this case approachesmaymisclassifythewarningasfixediftheextract method refactoring is not taken into account.
static method findmethod ... method matchingmethod null extracted code static object buildparameters ... object parameters null extracted codepublic object invoke method matchingmethod null extracted code object parameters null extracted code public object invoke method matchingmethod util.findmethod ... object parameters util.buildparameters ... ...version n version nmoving warning explicit initialization figure warning explicit initialization with null is moved from method invoke tofindmethod and buildparameters afteraextractmethod projecttomcat .
5change available at 6change available at missingormisclassifingresultsmaybeproducedwhencodechanges are not tracked.
for example ayewah and pugh state if a method is renamed or moved to another class any issues in that method will be reported as being removed .
peters and zaidman note isunabletodetermineifanentityinrevision nhasbeenrenamedinrevisionn .kimandernst mention weexcluderemovedwarningsduetoanyfiledeletion.ifthereisa file deletion during a fix all warnings in the files are removed note that a class rename can be misdetected as a file deletion .
.
scenario detecting code authorship the last research line is intended to detect code authorship.
in short theideaistoinferexpertdeveloperswhoarebestqualified tomaintaincertaincodefiles e.g.
.
approaches in this area often take advantage of facilities provided byscmtoolssuchasgit svn andcvs.forexample gitprovides thefacility git blame8 whichshowswhatrevisionandauthorlast modified each line of a file.
by using this information approaches in thisdomain can discover the developer whocreated a file the developerwhomostmodifiedafile amongothers.however this process is sensitive to refactoring such as moving .
considertheexampleinfigure5 whichpresentsamovemethod refactoringinprojectokhttp.9methods computeage andcomputefreshnesslifetime are moved from class responseheadersin version nto class responsestrategy in version n .a s scmtoolscannottrackfine grainedrefactorings theactualauthor of these methods i.e.
jakewharton is lost after a move method.
in this case the author in version n 1would be misdetected as swankjesse i.e.
the one who performed the move refactoring.
public class responsestrategy ...long computeage responseheaders response long nowmillis ... long computefreshnesslifetime responseheaders response ... ... public class responseheaders ...public responseheaders uri uri rawheaders headers ... public responseheaders combine responseheaders network ... private long computeage long nowmillis ... private long computefreshnesslifetime ... ... public class responseheaders ...public responseheaders uri uri rawheaders headers ... public responseheaders combine responseheaders network ... ... version n version n 1author swankjesseauthor jakewharton figure actual author of methods computeage and computefreshnesslifetime i.e.
jakewharton islost after a move method project okhttp .
these limitations are recognized by related literature.
for instance avelino et al .
state the full development history of a filecanbelostincaseofrenamingoperations copyorfilesplit.we addresstheformerproblemusinggit facilities.ho wever weacknowledge the need for further empirical investigation to assess the true impact of the other cases .
similarly spinellis note the git blame command works by traversing backwards a repository s history .consequently deletedsnapshotswouldcreateadiscontinuity between them and prevent the tracing of code between them .
9change available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden andre hora danilo silva marco tulio valente and romain robbes .
other scenarios the aforementioned scenarios show some msr research lines and studies affected by the threat of untracked code changes.
notice however that the list of presented research lines is not intended to be exhaustive.
in addition to the previous ones other lines include studies and threats in the context of i bug introducing change detection10 e.g.
it is also possible tomissbug introducingchangeswhenafilechangesitsnamesincethe algorithmdoesnottracksuchnamechanges ii codeevolution understanding e.g.
to distinguish cases where a methodwasremovedandanewoneaddedfromcaseswhenamethod was renamed we use a heuristic that maps methods with different names iii codeevolutionvisualsupporting e.g.
doesnotperformanyrecoveryofrefactoringssuch as renaming pull or push down methods among other.
.
problem what is the extent of the threat of untracked changes?
the threat of untracked changes may be faced at a higher or a lower level by several msr based studies.
in practice however this threat is commonly not assessed by researchers therefore we arestillunawareaboutitsrealsize.basedonthat oneimportant questionappears whatisthefrequency extension andimpactofthe threat of untracked changes?
answering this question has practical consequences researcherscanbetterquantifythethreat simpactin msr based studies.
consequently they will have better support to decide whether the threat is large enough that they should address it oriftheycanignoreit.
intheremainderofthispaper weaimto answer this question.
assessing untracked changes .
detecting untracked changes refdiff.
we rely on refdiff to detect both tracked and untracked changes.
refdiff is a tool that identifies refactorings performed in the version history of a system.
the tool relies on a combination of heuristics based on static analysis and code similarity to detect well known refactoring operations that can lead to untrackedchangesattheclassormethodlevels.refdiffalsodetects tracked changes at both class and method levels as summarized in table1.essentially refdiffreceivesasinputtwoversions v1and v2ofasystem andoutputsalistofchangesperformedin v2 when compared to v1.
table types of tracked and untracked changes.
change type tracked same class same method untrackedrename class move class move and rename class extract interface extract superclass rename method move method extract method inline method pull up method push down method 10these studies are often affected by the same issues presented in scenario since they often make use scm facility tools.refdiff sauthorsprovidetwoevaluationsoftheirtool.first they evaluated the tool using an oracle with well known refactoring instances performed by students in seven java projects.
as presented intable2 columneval refdiffachievedaprecisionof100 in all refactoring types overall recall was .
ranging from pullupmethod to100 renameclassandmovemethod .
although the tool detects these refactorings in their evaluation refdiff sauthorsdidnotconsidertworefactoringoperations move and rename class and extract interface.
in this evaluation refdiff alsooutperformedtheresultsofsimilartools includingrefactoring miner refactoring crawler and reffinder .
thesementionedtoolsachievedaprecisionof96 and26 respectively regardingrecall theresultswere73 and64 respectively.
refdiff thus constitutes at the time of writing the state oftheartinrefactoringdetection .refdiff sauthorsprovideasecond evaluation using real refactoring instances from ten github projects.aspresentedintable2 columneval withtheserefactorings refdiffachievedanoverallprecisionof85.
andanoverall recall of .
.
table precision and recall of refdiff.
refactoringeval eval eval prec recall prec recall prec recall rename class .
.
move class .
.
.5extract superclass .
.
move and rename class .
extract interface rename method .
.
.
.
.
move method .
.
.
100extract method .
.
.
.
inline method .
.
.
.
.
pull up method .
.7push down method .
all refactorings .
.
.
.
.
to increase our confidence on refdiff s accuracy we manually validatedasetofrefactoringsdetectedbythetoolintheversionhistory of the projects investigated in this paper which are presented in section .
first we executed refdiff in the commit history of these systems.
we then randomly selected of such refactorings for manual validation by the second author of this paper with this sample size we ensure a confidence level of and confidence intervalof5 .11foreachrefactoring heinspectedthetextual difference produced by github for the respective commit he then classified the detected refactorings as true or false positives.
as presented in table column eval the overall precision in this third evaluation was .
ranging from .
move and rename class to extract interface and pull up push down method .
finally we evaluated refdiff s recall using well know refactoringsperformedintheversionhistoryoftheprojectsinvestigated inthispaper.tocreatethisgoldset wefirstsearchedinthetextual description of the commits performed in these systems for regular expressions denoting the refactorings considered in the study e.g.
extractmethod .then thesecondauthorofthispaperchecked 11this selection includes instances of all refactorings detected by refdiff with the exception of extract superclass since it is a rare refactoring no instance of this refactoring was included in the random sample of refactorings.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assessing the threat of untracked changes in software evolution icse may june gothenburg sweden whether these commits indeed include the refactorings declared in their descriptions.
in this way we created a gold set with validated refactoring instances which was used to compute recall.
as shown in table column eval the overall recall in this thirdevaluationwas89.
rangingfrom66.
extractsuperclass extractmethod andpullupmethod to100 moveandrename class and move method .changegraph.
tofacilitatetheevolutionaryanalysisofclasses methods and their related changes we model a graph the change graph whichisbuiltbyrunningrefdiffonasetofsystemversions i.e.
commits .inthisgraph eachclassormethodisrepresentedas anodewhileeachtrackedoruntrackedchangeisrepresentedasan edgebetweentwonodes.figure6presentsthechangegraphforthe exampledescribedinfigure1.wenoticetheentitiesrepresented as nodes and the changes represented as edges.
foo v1foo v2foo v3foo v4 ma v1ma v2ma v3ma v4 bar v1bar v2bar v3baz v4 mb v1mx v2mx v3my v4 mc v1mc v2qux v3qux v4 mc v3mc v4 me v4sc sc sc sm sm sm sc sc rc rm sm rm sm sc mm sm emtracked change untracked changelegend sc same class sm same method rc rename class rm rename method mm move method em extract method figure change graph for the example in figure .
.
measuring untracked changes aftergeneratingthe changegraph wecanassessthefrequencyand extension of tracked and untracked changes.
these assessments are later used to answer research questions and .
frequency.
the frequency of changes is assessed by counting the number of edges in the change graph.
each change can be thenclassified as tracked or untracked.
in figure the change graph has changes from which are tracked and are untracked.
specifically itcontainsthefollowingchangetypes 6sameclass sc 6samemethod sm 1renameclass rc 2renamemethod rm move method mm and extract method em .
extension.
the extension of changes is computed by assessing the paths in the change graph.
we consider a path to represent the history of an entity.
each path may be formed by tracked and or untrackedchanges.pathswithuntrackedchangesarenotdesirable becausetheirhistoriesmaybesplit iftheuntrackedchangesarenot resolved decreasing traceability of the entityhistory.in figure forexample thechangegraphhas7paths.threepathsincludeonly trackedchanges foov1...foov4 length3 mav1...mav4 length3 andquxv3...quxv4 length1 .fourpathsincludeatleastoneuntracked changes barv1...bazv4 length mbv1...myv4 length mcv1...mcv4 length3 and mcv1...mev4 length3 .thus traceability is more precise when untracked changes are resolved.
experimental design .
selecting case studies inthisstudyweanalyzetrackedanduntrackedchangesthathappen inreal worldandpopularsoftwaresystems.wecollectthe10most popularjavasystemshostedongithub assortedbythestarmetric.
we restrict our analysis to systems with more than 1k commits to filter out newer and less active ones.
we also filter out projects not relatedtosoftwaresystems.12inadditiontothesetop10popular systems weadded5relevantsystemsfromlargeorganizationssuch as google facebook and apache totalling case studies.
table presents an overview of the case studies in terms of commits contributors stars forks as well as a short description.
the most popular project is rxjava stars while the most forkedisspringframework 518forks .thecommitsrangefrom android image loader to kotlin while contributors rangefrom35 androidimageloader to837 elasticsearch .the selected systems cover distinct domains such as search engines programming languages and software tools.
table overview of case studies.
project com.
cont.
stars forks short description rxjava event based lib.
elasticsearch search engine retrofit http client okhttp http clientgoogle guava core lib.
for javampandroidchart android view lib.glide android image lib.
android image android image lib.
kotlin programming lang.spring support frameworkfacebook fresco android image lib.clojure programming lang.
google guice dependency injection apache storm distributed systemeclipse che eclipse ide .
selecting commits aftercollectingthecasestudies weneedtoselectthecommits i.e.
versions to be analyzed.
projects using distributed version control systemssuchasgitmayhaveseveralbranchesunderdevelopment.
to facilitate code evolution analysis in this study we focus on the evolutionofthemainbranch.forthispurpose weusethecommand git log first parent14toselecttheanalyzedcommits since the git documentation clearly states this option can give a better overview when viewing the evolution of a particular branch .
.
computing untracked changes inthisfinalstep weperformtheapproachesdescribedinsection4.
werunrefdiffforeachcasestudyanditsrespectivesetofcommits.
wethencomputethe changegraph toinvestigatethefrequencyand extension of untracked changes.
our source code implementation and results are publicly available.
12for example 13the data was collected on june .
15available at authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may june gothenburg sweden andre hora danilo silva marco tulio valente and romain robbes rq1 what is the frequency of untracked changes?
table4presentsthefrequencyofuntrackedchangesattheclassand methodlevels.atthe classlevel thesystemswithproportionally moreuntrackedchangesareapachestorm eclipseche andrxjava .incontrast theoneswithlessuntrackedchanges aregoogleguava mpandroidchart andfacebookfresco .whenconsideringallprojects ofthechangesareuntracked atclasslevel.atthe methodlevel thesystemswithmoreuntracked changes are glide android image and spring while rxjava kotlin and mpandroidchart have less.
when considering all projects of the method changes are untracked.
thus the threat of untracked changes happens at both levels but is more frequent for methods.
table frequency of untracked changes per project.
projectfrequency of changes totaltracked untracked class method class method rxjava elasticsearch retrofit okhttp google guava mpandroidchart glide android image kotlin spring facebook fresco clojure google guice apache storm eclipse che all projects table5showsthefrequencyofuntrackedchangespertype.the mostfrequentuntrackedchangeshappenatthemethodleveland are due to rename method 23k extract method 21k and move method 20k .incontrast theleastfrequentonesareduetoextract superclass .3k extract interface .8k and push down method .8k .therefore keepingtrackofclassicaluntrackedchangessuch as class or method renaming is important but not enough.
other changes such as method extraction and moving should also be addressed to ensure a more complete tracking.
table frequency of untracked changes per type.
level change type classmove class rename class move and rename class extract interface extract superclass methodrename method extract method move method inline method pull up method push down method untracked changes constitute up to of the changes at the methodlevelandupto15 attheclasslevel thereforetheyshould notbeneglected.thismaydirectlyaffectmsrstudiesthatcompare two versions of one class or method such as the ones presented in scenarios and .
moreover if one in five changes can result in losingtrackoftheentity thisisasignthatthisthreatisalsorelevant formsrstudiesthatrelyonentitytraceabilityoverseveralversions aspresentedinscenario3 .inthiscontext furtherinvestigationis performed in the next research question.
summary .theratioofuntrackedchangesrangesfrom10 to for methods and from to for classes.
in practice thus the threat is more frequent at the method level.
rq2 what is the extension of untracked changes?
in this research question we assess the extension of untracked changes.wefirstmeasuretheamountofentities i.e.
classesand methods that includes untracked changes in their histories.
we further detail the analysis by assessing the paths of these entities.
amount of entity histories with untracked changes.
entities withuntrackedchangesintheirhistoriesarenotdesirable because theirhistoriesmaybesplit.tobetterunderstandthisthreat table6 presentsthenumberofentityhistories i withonlytrackedchanges and ii with tracked and untracked changes.
the systems withproportionally more entity histories with untracked changes are android image mpandroidchart and okhttp .
the systems with less are kotlin rxjava and facebook fresco .whenconsideringallsystems oftheentitieshave at least one untracked change in their histories.
thus a relevant amount a quarter of entities potentially have their history split.
table6 amountofentityhistorieswithuntrackedchanges.
projectentity histories total tracked only tracked untracked rxjava elasticsearch retrofit okhttp google guava mpandroidchart glide android image kotlin spring facebook fresco clojure google guice apache storm eclipse che all projects in practice this threat is more critical when an entity has more changes in its history meaning that a long track can be lost.
to betterunderstandthemostchangedentityhistories table7focuses onthetop25 mostchangedentities.inthiscase thesystemswith more entities with untracked changes are android image googleguice andokhttp .incontrast thesystemswith lessarefacebookfresco googleguava andeclipseche authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
assessing the threat of untracked changes in software evolution icse may june gothenburg sweden .consideringallsystems ofthetop mostchanged entitieshaveatleastoneuntrackedchangeintheirhistories.wenotice that the proportion of entity histories with untracked changes increase when compared to the previous analysis overall from to37 .thisshowsthatthemostchangedentities i.e.
entities that areconstantly evolving and consequently that arethe most important and critical are also likely to have their histories split.
table7 amountofentityhistorieswithuntrackedchanges in the top most changed entities.
projectentity histories totaltracked only tracked untracked rxjava elasticsearch retrofit okhttp google guava mpandroidchart glide android image kotlin spring facebook fresco clojure google guice apache storm eclipse che all projects lengthofentityhistorieswithuntrackedchanges.
tofurther assessthedatapreviouslypresented figure7showsthepathlength distributionsofthetop mostchangedentities.eachboxplot presentsthepathlengthsoftheentityhistorieswithonlytracked changes left and with tracked and untracked changes right .
overall entityhistorieswithuntrackedchangeshavehigherlength.
for example the median path length for rxjava is for entity histories with only tracked changes and for entity histories with trackedanduntrackedchanges thethirdquartileis5against9 and the upper whisker is against .
thus entities with untrackedchanges in their histories also tend to have a longer lifespan.
if untrackedchangesareproperlyresolved thislonglifespancanhelp msr studies focused on traceability analysis to be more precise.
summary .
the ratio of entities with untracked changes in their histories varies from to .
for the most changed entities thisproportionishigher between22 and58 .overall these entities also tend to have a long lifespan.
rq3 what is the impact of untracked changes?
to further assess the practical impact of untracked changes in msr studies we evaluate how untracked changes affect two msr approaches based on association rule mining.
the first approach focuses on api evolution rule mining andinfersrulesintheformat removed added indicatingthat