metadata invariants checking and inferring metadata coding conventions myoungkyu song and eli tilevich dept.
of computer science virginia tech blacksburg va usa fmksong tilevichg cs.vt.edu abstract as the prevailing programming model of enterprise applications is becoming more declarative programmers are spending an increasing amount of their time and efforts writing and maintaining metadata such as xml or annotations.
although metadata is a cornerstone of modern software automatic bug finding tools cannot ensure that metadata maintains its correctness during refactoring and enhancement.
to address this shortcoming this paper presents metadata invariants a new abstraction that codifies various naming and typing relationships between metadata and the main source code of a program.
we reify this abstraction as a domain specific language.
we also introduce algorithms to infer likely metadata invariants and to apply them to check metadata correctness in the presence of program evolution.
we demonstrate how metadata invariant checking can help ensure that metadata remains consistent and correct during program evolution it finds metadata related inconsistencies and recommends how they should be corrected.
similar to static bug finding tools a metadata invariant checker identifies metadata related bugs as a program is being refactored and enhanced.
because metadata is omnipresent in modern software applications our approach can help ensure the overall consistency and correctness of software as it evolves.
keywords software maintenance bug finding refactoring enhancement frameworks domain specific languages metadata invariants.
i. i ntroduction a software application comprises functional and nonfunctional concerns.
in a modern enterprise application the programmer implements the functional concerns i.e.
business logic procedurally by writing source code and the non functional concerns e.g.
persistence security testing etc.
declaratively by writing metadata e.g.
xml configuration files or annotations .
the declared metadata configures various frameworks e.g.
orms encryption and authentication controllers etc.
that implement the required non functional concerns nfcs .
although the declarative programming model cleanly separates functional and nonfunctional concerns source code and metadata interconnect so tightly that neither one can be safely evolved independently.
for example an xml tag can refer to a specific class field by name and if the field s name changes the xml tag must be updated accordingly.
the programmer renaming a field may not even be aware that some xml configuration file