robust reconfigurations of component assemblies fabienne boyer lig universit e joseph fourier grenoble france fabienne.boyer imag.frolivier gruber lig universit e joseph fourier grenoble france olivier.gruber imag.frdamien pous cnrs grenoble france damien.pous ens lyon.fr abstract in this paper we propose a reconfiguration protocol that can handle any number of failures during a reconfiguration always producing an architecturally consistent assembly of components that can be safely introspected and further reconfigured.
our protocol is based on the concept of incrementally consistent sequences ics ensuring that any reconfiguration incrementally respects the reconfiguration contract given to component developers reconfiguration grammar and architectural invariants.
we also propose two recovery policies one rolls back the failed reconfiguration and the other rolls it forward both going as far as possible failure permitting.
we specified and proved the reconfiguration contract the protocol and recovery policies in coq.
index terms dynamic reconfiguration component models robustness i. i ntroduction a current trend in dynamically reconfigurable systems is the use of a model driven approach to govern the evolution and maintenance of component assemblies .
in this approach an administrator or an autonomic tool is provided with a component based model of the software architecture of the complex system he manages.
as needed he can introspect that model to analyze the current architecture and shape a desired software architecture.
given as input these two architectures a reconfiguration protocol is responsible for driving the effective evolution of the managed system from its current architecture towards the desired target architecture.
traditionally a reconfiguration protocol is based on an architectural diff that compares the current and target architectures producing a set of elementary reconfiguration operations to apply on software components .
through this apply process the reconfiguration protocol evolves the component assembly from its current architecture towards the desired one one reconfiguration operation at a time.
in the authors discuss the crucial role of this protocol a safe ordering of reconfiguration operations.
a safe ordering must respect the reconfiguration contract under which components have been programmed.
this contract classically defines a reconfiguration grammar specifying legal sequences of reconfiguration operations per component.
with this knowledge developers design each component as a finite state machine that reacts to the reconfiguration operations issued by the reconfiguration protocol.
as briefly described in the traditionally accepted ordering is the onederived from the reconfiguration protocol originally introduced in .
we argue that this traditional ordering suffers from two main limitations today.
firstly component models have evolved since then introducing different semantics on component dependencies optional and mandatory which controls if components are started or stopped.
this evolution of the component paradigm induces an evolution of the programming contract given to component developers extending the reconfiguration grammar and introducing architectural invariants.
while we suspect that the impacts on the ordering of reconfiguration operations has been considered by modern component based systems to the best of our knowledge these impacts have never been discussed in any published materials.
secondly the traditional ordering does not support failures occurring at reconfiguration time.
a component may indeed fail to successfully apply a reconfiguration operation.
to face this limitation advocate a rollback strategy based on inverse operations.
however this approach only tolerates a single failure since the rollback only succeeds if all inverse operations succeed.
given that inverse operations are regular reconfiguration operations there is no guarantee that they will succeed.
in case an inverse operation fails the rollback must be interrupted leaving human administrators or autonomic managers with the difficult task of introspecting and repairing a partially rollbacked and potentially inconsistent assembly.
the contributions of our work are the following.
first we propose the first reconfiguration protocol that orders reconfiguration operations such as to respect the reconfiguration contract given to component developers fulling specifying both the reconfiguration grammar and the architectural invariants that must be respected.
second our protocol is robust respecting the reconfiguration contract even in the case of multiple failures occurring during a reconfiguration.
third we formalized the complete protocol and proved it using the coq proof assistant providing one of the strongest degree of guarantee currently available with formal methods.
the core principle behind our solution is that the reconfiguration protocol always evolves the component assembly from one consistent architecture to another consistent architecture only through a path of architecturally consistent architectures.
this approach permits to manage failures as regular reconfigurations when a component fails to execute a requested operation our protocol stops marks the component as failed andthen propagates the effects of that failure throughout the component assembly.
since this propagation is a reconfiguration it may induce further failures that are processed identically.
once the impacts of all failures have been propagated the managed system is architecturally consistent which means that it can be safely introspected and further reconfigured.
importantly this means that an administrator or an autonomic tool can safely introspect this architecture and decide how to best repair the occurred failures.
the remaining of the paper is structured as follows.
section ii discusses component models.
in sections iii and iv we detail our reconfiguration protocol in the absence of failures while section v is devoted to the robust version of the protocol.
section vi evaluates the proposed protocol.
finally we discuss related works in section vii and we conclude in section viii.
ii.
c omponent model this section briefly recalls the growing consensus amongst component models regarding the concept of a component its lifecycle and its dependencies as well as the reconfigurability of a component assembly.
a component is a software entity that defines a set of exports and imports.
exports describe services that the component is willing to provide while imports describe services that it requires to function properly.
hence a component assembly can be shaped by wiring imports to exports.
imports are given either a mandatory or optional semantics while optional imports may be wired or unwired at any time during the lifetime of a component mandatory imports should be wired before a component is started.
in other words to be fully functional a component must have all its mandatory imports wired to exports.
the main reconfiguration operations that are provided are the following.
reconfiguration operations construct destruct components wire unwire components start stop components each component implements all these reconfiguration operations in a component specific manner but following a reconfiguration contract including a reconfiguration grammar andarchitectural invariants .
the reconfiguration grammar as depicted in figure specifies in which order and in which conditions a reconfiguration operation may be invoked.
this grammar relies on three main lifecycle states for a component stopped started and failed .
when first constructed a component is in the stopped state meaning it is not functional yet.
a component may reach the started state once it is resolved i.e.
once all its mandatory imports are wired.
a component may fail at any time reaching the failed state.
once failed a component may be removed from the assembly.
architectural invariants defined below constrain the architecture of a component assembly that corresponds to the stopped started constructstopstartwire unwire optional destructwire unwire mandatory optionalfailedfail failfig.
.
reconfiguration grammar description of which component compose the assembly what are their lifecycle states and how they are wired together.
more preciselly architectural invariants correlate the components lifecycle with the semantics of their imports optional vs mandatory .
these invariants define an architecturally consistent assembly of components meaning an assembly that can be safely introspected and reconfigured by an administrator or an autonomic tool.
they are not to be confused with higher level invariants that capture application specific and domain specific knowledge.
for instance application specific invariants might state that an application only works if all components are started or that certain components may be stopped and the application is still operational.
hence an architecturally consistent assembly might not be functional from an overall application perspective but it is reconfigurable in order to re establish a functional assembly.
definition .
architectural invariants i1 all started components have all their mandatory imports wired.
i2 all started components are wired only to started components.
i3 there are no wires to from failed or destructed components i4 there are no cycles through mandatory imports1.
the reconfiguration grammar along with the architectural invariants define the reconfiguration contract that enables component developers to approach the design of a component as a finite state machine.
for instance once started a component has the guarantee that all its mandatory imports have been wired.
reversely any component will be stopped before its mandatory imports are unwired.
this contract is therefore the cornerstone of component design helping developers to master the difficult challenge of designing components that can be dynamically reconfigured.
notation in the sequel we use letters c dto range over components andv w to range over wires.
a wire wlinks an import i of a component cto an export eof another component c0 we denote the source c byw src and the destination c0 byw dst .
we also use letter oto range over reconfiguration operations which we separate into down operations stop c 1this is a widely accepted limitation amongst component models .current architecture target architecture prepare commit managed systemreconfigured managed systemfig.
.
reconfiguration session unwire w destruct c fail c and up operations construct c wire i e start c .
iii.
r econfiguration challenge a reconfiguration protocol reconfigures a component assembly according to a desired target architecture specifiying which components should compose the system what are their lifecycle states and how they should be wired together according to section ii .
each reconfiguration is organized as a session with two phases as depicted in figure .
in the prepare phase a working copy of the current architecture can be freely reshaped to define the target architecture2.
then during the commit phase the reconfiguration protocol evolves the managed system towards the target architecture by applying reconfiguration operations.
the challenge of a reconfiguration protocol consists in finding a correct sequence of reconfiguration operations.
indeed a naive approach consisting in computing an architectural diff and directly applying the corresponding reconfiguration operations may violate the reconfiguration contract.
a very simple example illustrates this.
let s suppose that we have a simple assembly with three started components c c1 and c2 with a mandatory wire w from ctoc1.
let s further suppose that the administrator gives a target architecture where the three components are also started but where wnow points to c2.
the diff will produce only two operations unwire w andwire c c2 .
while the architecture is consistent before and after the reconfiguration it goes through an inconsistent state as soon as we apply the unwire operation we violate invariant i1 since we have a started component c with an unwired mandatory import.
in order to always respect the reconfiguration contract the managed system should always be reconfigured through incrementally consistent sequences definition .
given an architecture a an incrementally consistent sequence ics is a sequence o1 o nof reconfiguration operations such that 2note that the target architecture may also be selected from a version space or generated through model driven generative approaches.unwired w ifmandatory w stopped w src unwire w stopped c for all wsuch that w dst c ifmandatory w stopped w.src else unwired w stop c destructed c for all wsuch that w src corw dst c unwired w destruct c fig.
.
propagation rules for all i2 the architecture aiobtained by successively applying the ifirst operations o1 o ito ais consistent definition for all i2 the operation oiis allowed in the stateaiby the reconfiguration grammar figure .
intuitively a sequence is incrementally consistent if it can be applied incrementally to a system without ever violating the reconfiguration contract architectural invariants definition and reconfiguration grammar figure .
note that incrementally consistent sequences can be composed to build larger sequences that remain incrementally consistent.
the next section details how our reconfiguration protocol computes and applies incrementally consistent sequences icss .
iv.
r econfiguration protocol when a reconfiguration session commits using the current and target architectures as inputs the reconfiguration protocol computes and applies an ics that evolves the managed system into the target architecture.
to compute such an ics two phases are necessary.
the first phase focuses on down operations computing a first architectural diff between the current and target architectures called the apply down set ads see listing .
the ads only contains down reconfiguration operations and may be incomplete as explained earlier.
hence rather than considering the ads as a set of reconfiguration operations that should be applied the ads is considered as a set of reconfiguration goals that should be reached.
for instance if we have an operation unwire w in the ads we will consider that we have a goal unwired w .
similarly if we have an operation stop c we will consider that we have a goalstopped c .
the difference between a reconfiguration operation and its corresponding reconfiguration goal is that a reconfiguration operation is a standalone operation whereas a goal may require other goals to be reached in order to preserve the architectural invariants.
for instance in the previous example the goal unwired w requires the goal stopped w src to be reached to preserve the invariant i1 .
our protocol uses the propagation rules given in figure to saturate the ads with the missing reconfiguration opera optional unwire stop mandatory unwire destruct faild o w n p h ase u p p ha se constructmandatory wireoptional wire startfig.
.
ordering to obtain an ics tions producing the saturated apply down set sads .
the first rule translates an unwired goal into the corresponding unwire operation but also generates a stopped goal if the wire to be removed is mandatory thus enforcing the invariant i1 .
the second rule translates a stopped goal on a component cinto the corresponding stop operation but also generates additional goals to preserve the invariant i2 .
the third rule translates a destructed goal into the corresponding destruct operation but also generates unwired goals for all wires connected to or from the destructed component thus preserving the invariant i3 .
note that this propagation always terminates the only case where the algorithm could loop is when trying to stop a component belonging to a cycle of mandatory wires which is precisely forbidden by the invariant i4 .
then our protocol obtains a first ics by ordering the operations in the sads such as to respect the reconfiguration grammar as depicted in figure .
furthermore the stop operations are also ordered as to respect the invariant i2 .
applying this ics on the managed system ends the first down phase of the commit.
note that to apply an ics on the managed system the necessary quiescence must be established at the level of the component runtime .
the second phase of the commit is concerned with up operations.
to obtain the apply up set aus it is necessary to process an up diff between the current architecture that has just evolved through down operations and the unchanged target architecture.
note that this up diff may only be computed after the down diff has been computed and saturated as the saturation may forces additionnal down operations to be processed which will require a larger set of up operations to reach the target architecture.
the aus obtained from the up diff is saturated by definition since architectural invariants do not require any propagation regarding up operations.
this aus needs to be ordered into an ics using the ordering algorithm figure .
furthermore as it was the case for stop operations start operations are also ordered as to respect invariant i2 .
applying this ics ends the second up phase of the commit.
putting it all together the two phases of the commit are summarized below explaining the algorithm given in listing down phase.
our protocol first computes the ads by processing a diff between the current ac and target at architectures saturates the ads into the sads commit ac at f reconfigure the architecture ac of the managed system to match the target architecture at assert consistent ac consistent at ads aus sets of reconfiguration goals sads saus sets of reconfiguration operations ics sequence of reconfiguration operations down phase ads diff down ac at sads propagate ac ads see propagation rules ics order ac sads see figure a0 c apply ac ics up phase aus diff up a0 c at ics order at aus see figure a00 c apply a0 c ics assert isomorph a00 c at return a00 c g listing .
commit algorithm orders the sads into an ics and finally applies that ics on the managed system which evolves it to a new current architecture a0 c. up phase.
our protocol computes the aus by processing a diff between a0 candat orders this aus into an ics and applies this ics on the managed system with the architecture a0 c which evolves it to a new current architecture a00 c. at the end of the commit the architecture of the managed system a00 c is isomorphic to the desired target architecture at and the system has been reconfigured through two ics.
we conclude this section with an illustrative example.
consider the managed system with the current architecture acfrom figure with four started components d c c1 andc2 mandatory wires wfrom dtocandw1from c toc1 and an optional wire vfrom c1toc invariant i4 holds since it concerns only mandatory wires .
take atas target architecture where the wire w1is now replaced by a mandatory wire w2from ctoc2.
acdw c w166c1vvv c2atdw c w2 c1vvv c2 a0 cdw c c1 c2 fig.
.
example of a reconfiguration sessionthe apply down set returned by the first architectural diff is just the singleton funwired w1 g. by the above propagation rules we get the following saturated set of down operations sads funwire w1 unwire w stop c stop d g. this set is ordered into the following ics ics unwire v stop d stop c unwire w1 .
note that the component dhas to be stopped first because of its mandatory dependency on c. by applying this sequence on the managed system we get an architecture a0 cwhere c d are stopped and wis the only wire see figure .
we can finally engage in the up phase.
the second architectural diff between a0 candatgives the set aus fwire w2 wire v start c start d g which is ordered as follows into the following ics ics wire w2 start c start d wire v .
as expected applying this ics on a0 cresults in a managed system which is isomorphic to at.
v. r obust protocol during the commit phase of a reconfiguration session failures may occur since reconfiguration operations are invoked on components and components may fail executing these reconfiguration operations.
we assume that a reconfiguration operation that fails when invoked on a component c only impacted that component c. this section discusses how our protocol recovers from such failures.
when a reconfiguration operation fails the reconfiguration protocol suspends the on going reconfiguration and starts a recovery process.
this recovery process must not only mark the component that just failed as failed but it must also propagate the impacts of that failure throughout the managed system.
robust commit ac at f reconfigure the architecture ac of the managed system to match the target architecture at assert consistent ac consistent at a0 c failedcomp commit ac at if failedcomp null return a0 c else return recover current a0 c ffailedcompg g recover current ac failedset f account for failed components in the managed system sads propagate ac failedset ics order ac sads a0 c failedcomp apply ac ics if failedcomp null return a0 c failedset else return recover current a0 c failedset ffailedcompg g listing .
robust commit algorithm the corresponding robust commit algorithm given in listing wraps the regular commit ac at algorithm givenearlier in listing .
when a failure occurs the regular commit suspends itself and returns the identification of the component that just failed.
the robust commit enters its recovery process recover current starting with a failedset that only contains the component that just failed.
it computes a saturated ads sads for accounting this failure in the managed system using the three previous propagation rules figure and the following one for failed goals failed c for all wsuch that w src corw dst c unwired w fail c this sads is then ordered into an ics by ordering the operations as depicted in figure .
overall this ics propagates the impacts of the failure throughout the managed system and terminates by marking the component as failed .
since applying this ics invokes reconfiguration operations on components cascading failures may occur.
handling and recovering such failures is no special case.
the on going recovery suspends itself the component that just failed is added to the set of failed components and a new recovery is attempted.
this fixpoint always terminates since the number of components that may fail is finite.
when this recovery eventually completes the managed system is architecturally consistent.
from the perspective of the managed system the entire recovery phase appears as a sequence of icss all interrupted by new failures but for the last one that manages to complete the recovery of a consistent assembly.
vi.
e valuation we evaluated our reconfiguration protocol along three main aspects.
first we validated that our protocol always behaves as expected.
second we evaluated the usability of our icsbased approach to support advanced recovery policies.
third we evaluated the scalability of our protocol.
a. proving the protocol to validate that our protocol always does what it is supposed to do we formalized and proved the entire protocol using the coq proof assistant .
coq is an interactive theorem prover in the sense that it can be used to certify mathematical proofs using an interactive process where the user progressively writes the proof with the help of the assistant.
unlike automatic theorem provers or testing based approaches the user has to provide a complete proof a complex task that makes it possible to consider arbitrarily complex problems providing one of the strongest degree of guarantee currently available with formal methods.
in particular we proved that all our algorithms behave correctly in all possible cases including the ones that could not be tested due to material restrictions memory or time .
the coq development consists of about lines of coq code that can be browsed online .
given two finite sets of components andimports an architecture is modeled by a record record arch f status component!status wires component imports!option component g where status is a function indicating whether a given component is started stopped or failed and wires is a function describing how the imports of a component are wired to other components.
reconfiguration operations are represented using an union type op and we define the meaning of these operations using a function apply arch op!arch .
accordingly we model the propagation algorithm as a function propagate arch op!list op and the architectural diff algorithm as a function of type arch arch!list op .
using these functions together with auxiliary functions for sorting lists of operations we define a commit function that takes a current architecture and a target architecture and produces a list of reconfiguration operations to be applied.
to model failures we assume an arbitrary function eapply arch op list component !arch component which applies a given operation to an architecture knowing that the components given by list component are failed and can either return the new architecture if the operation could successfully be applied or return a newly failed component.
we then define the robust commit function as a fixpoint which uses the above eapply function to simulate an execution where an arbitrary number of failures may occur.
while we could state the various properties that should be ensured by the protocol using only theorems intermediate lemmas were required to prove them.
among the high level theorems we proved that the commit algorithm always produces ics which means by definition of an ics that the architectural invariants and the reconfiguration grammar are never violated without failures the commit algorithm always evolves the source architecture to the target architecture the robust commit algorithm properly acknowledges failed components whatever the number of failures all algorithms terminate.
among the auxiliary lemmas we had to prove that .
the propagation algorithm produces saturated sets of reconfiguration operations .
the above saturated sets can always be ordered into an ics .
the architecture reached after the down phase makes it possible to reach the target architecture using up operations only .
the diff algorithms are complete.
b. leveraging our protocol we leverage our protocol to design two recovery policies roll forward policy rfp and roll backward policy rbp see listing that both exploit the incremental consistency of our approach.
in case of failures the rfp policy is an automated attempt to pursue the reconfiguration as far as possible towards the desired target failure permitting.
from our previous work on repair management it appearedthat as much as possible of the originally intended reconfiguration may help the administrator to analyze and understand the failure and its impacts.
conversely the rbp policy is an automated attempt to rollback the reconfiguration session as much as possible failure permitting as well.
policies for reconfiguring the architecture ac of the managed system rfp commit ac at f roll forward policy a0 c failedset robust commit ac at if failedset return a0 c a0 t recover target at failedset recover reachability return rfp commit a0 c t g rbp commit ac at f roll backward policy a0 c failedset robust commit ac at if failedset return a0 c a0 t recover target ac failedset recover reachability return rfp commit a0 c ai g recover target at failedset f account for failed components in target arch.
at sdas propagate at failedset ics order at sads a0 t apply at ics cannot fail return a0 t g listing .
roll forward and roll backward commit algorithms in fact these two policies differ in their choice of the target architecture after a failure.
for the roll forward policy we keep the original target architecture atin the rfp commit algorithm .
for the roll backward policy we toss away the original target architecture and replace it with the initial architecture aithat the managed system had before it was reconfigured.
whichever is the new target architecture it must be revised to incorporate the failures that occurred.
this is performed by the recover target algorithm given in listing .
please note that since the target architecture is purely abstract reconfiguring it cannot induce cascading failures.
with a target architecture that is now reachable our protocol can resume its normal processing pushing towards the chosen target architecture either roll backing or roll forwarding.
notice that the roll forward algorithm is a fixpoint pushing towards the chosen target as far as possible.
note also that the roll backward algorithm switches to the roll forward algorithm upon the occurrence of the first failure.
the rationale is that despite new failures the commit should keep pushing towards the initial architecture of the system.
c. case study in this section we illustrate the use of our protocol to manage a web application server whose architecture is depicted in figure a .
in the figure a1anda2represent an http daemon t1andt2represent a servlet engine and db a target architecture b deployment result with one failurea1 t1 db1 a2 t2a1 t1 a2 t2 stopped failed started started started started started started started started db1fig.
.
typical clustered web architecture represents a database server.
all imports in the architecture are mandatory.
deployment scenario the first management task is the initial deployment of the web server.
the administrator starts with an initial current architecture that is empty and shapes the desired target architecture depicted in figure a .
when the administrator commits the session the reconfiguration will result in the deployment of the overall system.
the down phase of our protocol computes an empty apply down set since the current architecture of the managed system is empty.
the up phase of our protocol see listing computes the following apply up set apply up set commit algorithm construct t1 t2 db wire t1 db t2 db start t1 t2 db construct a1 a2 wire a1 t1 a2 t2 start a1 a2 our protocol then orders this apply up set into the following ics ics commit algorithm construct a1 a2 t1 t2 db wire a1 t1 a2 t2 t1 db t2 db start db t1 t2 a1 a2 without failures the apply of this ics results in the deployment of the desired clustered web server.
let s now force a failure to occur upon wiring tomcat to the database system e.g.
wire t1 db .
the administrator may choose to suspend the reconfiguration session knowing that the resulting system is consistent and reconfigurable.
in this particular instance the administrator would probably prefer to use the roll forward policy rfp commit algorithm in listing because isolated failures during a deployment usually do not justify to rollback the entire deployment.
the roll forward policy executes the recover current algorithm listing that accounts for the failure of the tomcat instance t1and produces the following ics fail t1 .
indeed propagating the failure of t1has no effects since no components were wired to t1at the time it failed.
effective architecture target architecturea1 t1 a2 t2a1 t1 db1 a2 t2db1 db2fig.
.
target architecture with two databases then the roll forward policy executes the recover target algorithm listing that accounts for the failure of t1in the target architecture.
t1is marked as failed which propagates in isolating t1 failed propagation rule .
removing mandatory wires to t1propagates into stopping components depending on these wires unwired propagation rule .
ultimately this produces the following ics stop a1 unwire a1 t1 fail t1 leading to the target architecture that is depicted in figure b .
committing this recovered target architecture allows to get a managed system that is running despite a partial failure during its deployment.
moreover it is consistent and thus ready to be reconfigured again.
sizing scenario we consider adding a new database server db and balancing the tomcat servers over the two database servers as depicted in figure .
being given the current and target architectures of figure our protocol computes the following apply down set and apply up set apply down set unwire t2 db apply up set construct db start db wire t2 db then through propagation and ordering our protocol generates the ics given below which is a longer ics because theunwire t2 db propagates a stop operation on both the tomcat and apache components.
they are also longer because of the larger up set to reach the target architecture.
indeed since the protocol just stopped a tomcat and an apache that are not stopped in the target architecture the diff for the up phase will produce the extra start operations needed.
down ics stop a2 t2 unwire t2 db up ics construct db wire t2 db start db t2 a2 without failure the reconfiguration achieves sizing up the clustered web server.
let s now force a first failure that occurs on the start on db .
the recover current algorithm computes the following ics unwire t2 db fail db .effective architecture before db s failure recovered effective architecturea1 t1 a2 t2a1 t1 db1 a2 t2db1 db2 db2 stopped stopped stopped stopped started started started started started started failed failed fig.
.
db2 s failure during reconfiguration initial target architecture recovered target architecturea1 t1 a2 t2db1 a1 t1 a2 t2 stopped failed started started started started started started started started db1 fig.
.
roll backward policy on db2 s failure this ics would recover a consistent architecture if applied entirely on the managed system.
however we will interrupt it considering the case of a cascading failure when attempting tounwire the tomcat instance t2.
the fixpoint on the recover current generates a new ics unwire a2 t2 fail t2 fail db .
this time we will consider that the apply of this ics succeeds meaning that the unwire on the apache instance a2succeeds and the recovery completes with a final fail set offt2 db 2g.
the figure shows the architecture of the managed system before the first failure occurring on the start of db and after the recovery process.
notice the post recovery architecture is architecturally consistent the administrator can therefore introspect the architecture discover and understand the failures fix the reasons for the failures if any and ultimately issue one or more reconfigurations to reach an acceptable configuration of the overall system.
d. protocol scalability in this section we wish to discuss the scalability of our protocol in terms of the number of reconfiguration operations it issues.
without considering failures our protocol issues a number of reconfiguration operations that is solely governed by the complexity of the current and target architectures and their relative distance.
given a current architecture acand a target architecture at the largest possible reconfiguration is to destroy entirely acand thereby entirely construct at.
in this worst case scenario our protocol issues a maximum number of operations that is less or equal than ndestruct nconstruct where ndestruct is the number of operations needed to entirely destruct acandnconstruct is the number of operations needed to entirely construct at.more precisely given an architecture with ccomponent andwwires the ndestruct andnconstruct numbers must be smaller that 2c w. indeed regarding ndestruct each component may at most be stopped and destructed while each wire may at most be unwired .
regarding nconstruct each component may at most be constructed and started while each wire may at most be wired .
notice that the saturation of the apply down set which is a fixpoint does not change the evaluation of this maximum number of operations.
indeed at the most this saturation may only add one unwire operation per wire and one stop operation per component operations that are already included inndestruct .
when considering failures our protocol goes through a recovery fixpoint that propagates the impacts of failures throughout the current architecture.
in the worst case all components will incrementally fail in which case the recovery propagation will issue at most one unwire operation per wire and one stop and fail operations per component.
consequently given an architecture awithccomponent and wwires we can define nrecover a as equal to 2c w. however since failures may occur at any time we need to consider the number nrecover that is equal to the maximum of the nrecover a for all architectures the managed system is going through from actoat.
hence even when considering failures our protocol issues less operations than ndestruct nconstruct nrecover a number of operations that is still linear with the complexity ofacandatarchitectures and their relative distance.
in the use case given in section vi c1 ndestruct is null as the initial system is empty and nconstruct is equal to construct 4wire and start and npropagate is also equal to unwire 5stop and fail .
vii.
r elated work many component models define a component lifecycle with two states started and stopped controlled by the mandatory and optional semantics of wires .
they provide reconfiguration operations that add remove components and wires between components.
however these operations are invoked individually with an immediate effect on the component assembly.
this means that anyone reconfiguring a component assembly must take care of the following complex and errorprone tasks.
first s he must apply reconfiguration operations in the correct order.
for instance only start a component after it has all its mandatory imports wired .
second s he must manually propagate the collateral effects of each reconfiguration operation such as stopping a client component before stopping a server one .
with a model driven reconfiguration approach one simply shapes the target architecture leaving these tasks to the reconfiguration protocol.
regarding approches that advocate model driven reconfigurations the focus is mainly on on the capture of application specific architectural constraints mostly through the use of architectural styles .
complementary to the architectural constraints that we considerin this paper application specific constraints do not require to be incrementally preserved during a reconfiguration they only need to be preserved by the target architecture.
in other words application specific constraints intend to shape functional architectures while architectural constraints guarantee reconfigurable architectures.
most of the above frameworks did not publish any details on their reconfiguration protocol with the noticeable exception of .
their protocol orders reconfiguration operations following only considering optional wires between components a choice that is consistent with their underlying component platform .
regarding failures only a few frameworks published about fault tolerance all advocating a rollback strategy based on the use of inverse reconfiguration operations a design that only supports a single failure per reconfiguration.
discusses failures occurring during recovery and states that it is a hard challenge for autonomic systems.
however the paper only presents early ideas suggesting that component dependencies can be used to plan the propagation of the impacts of failures throughout a component assembly.
the paper also suggests that recovery should be structured as a fixpoint but does not give any details.
in particular no algorithms are described.
the rapidware project is another component framework that shares similarities with our proposal.
it proposes a formal model to verify that during and after reconfigurations the system remains in correct states in terms of architectural and behavioral invariants.
as it proposes a reconfiguration process that handles failures that appear at commit time through inverse operations.
finally in a prior work we related our verification experience of an earlier version of the reconfiguration protocol.
the focus of the paper was the formal verification of our protocol using the cadp toolbox only briefly introducing our protocol as an example of a verification process of interest to the community of formal methods.
the paper only sketched our protocol including the notion of ics and its associated ordering algorithm depicted in fig .
in contrast the presented paper discusses the complete protocol at length including its detailed design and detailed algorithms.
in particular we acknowledge for the first time the novel ordering of operations based on four steps architectural diff saturate order and apply.
moreover this paper also reports on proving the protocol rather than verifying it providing on line the complete specification in coq.
finally this paper includes an evaluation of the protocol.
viii.
c onclusion this paper summarized the growing consensus of modern component models and the corresponding reconfiguration contract reconfiguration grammar and architectural invariants.
it proposed a reconfiguration protocol based on the concept of incrementally consistent sequences ics ensuring that any reconfiguration incrementally respects this reconfiguration contract.
the proposed protocol resists any number of failuresduring the reconfiguration always producing an architecturally consistent assembly of components that can be safely introspected and further reconfigured.
in that regards we proposed two advanced recovery policies the roll backward policy that rolls back a failed reconfiguration and the roll forward policy that pushes towards the desired target architecture both policies going as far as possible failure permitting.
we fully specified our protocol and proved it correct using the coq proof assistant and we evaluated its complexity linear with respect to the complexity of the desired reconfiguration .