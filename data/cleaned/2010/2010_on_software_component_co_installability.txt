on software component co installability j r me vouillon cnrs pps umr univ paris diderot sorbonne paris cit f paris france jerome.vouillon pps.jussieu.frroberto di cosmo univ paris diderot sorbonne paris cit pps umr cnrs f paris france roberto dicosmo.org abstract modern software systems are built by composing components drawn from large repositories whose size and complexity is increasing at a very fast pace.
a fundamental challenge for the maintainability and the scalability of suc h software systems is the ability to quickly identify the components that can or cannot be installed together this is the co installability problem which is related to boolean satisfiability and is known to be algorithmically hard.
this paper develops a novel theoretical framework based on formally certified.
semantic preserving graph theoretic transformations that allows to associate to each concrete component repository a much smaller one with a simpler structure but with equivalent co installability properties.
thi s smaller repository can be represented graphically giving a concise view of the co installability issues in the original repository or used as a basis for various algorithms related to co installability like the efficient computation of stron g conflicts between components.
the proofs contained in this work have been machine checked in coq.
keywords component dependencies conflicts co installability p ackage management open source general terms algorithms theory verification categories and subject descriptors d. .
software program verification formal methods g. .
graph theory hypergraphs partially supported by the european community s 7th framework programm e fp7 grant agreement n mancoosi project.
work performed at the irill center for free software research and innova tion in paris france.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.
.
introduction the mainstream adoption of free and open source software foss has widely popularised component based software architectures maintained in a distributed fashion and evolving at a very quick pace.
components are typically made available via a repository and each of these components is equipped with metadata such as dependencies and conflicts used to specify concisely the contexts in which a component can or cannot be installed.
a typical example of the metadata attached to a component taken from the debian gnu linux distribution is shown in example the logical language used for expressing dependencies and conflicts is quite powerful as it allows conjunctions symbol disjunctions symbol and version constraints.
example .the inter package relationships of postfix an internet mail transport agent in the debian gnu linux distribution currently reads 1package postfix 2version .
.
.
3depends libc6 .
libdb4.
ssl cert 4libsasl2 libssl0.
.
.
.8f 5debconf .
debconf .
6netbase adduser .
dpkg .
7lsb base .
8conflicts libnss db .
smail 9mail transport agent postfix tls 10provides mail transport agent postfix tls in most frameworks determining whether a single component can be installed at all is already an np complete problem albeit the concrete instances arising in real world systems like gnu linux distributions eclipse plugins or osgi component repositories turn out to be tractable .
for the maintenance of component repositories though moresophisticatedanalysesarerequired.
thisincludesidentifying for each component the other components in the repository that it absolutely needs and those that it can never be installed with .
more generally a fundamental challenge for component based software maintainability is the study of the problem ofco installability of components that involves identifying and visualising the relevant sets of components that can or cannot be installed together.
indeed from a maintenance point of view one needs to identify which components cannot be installed together in order to check whether these incompatibilities are justified or due to erroneous dependencies.
the dependency grapha b ce f d g figure graphical depiction of a repository is also too rich for end users which are interested in having a given set of functionalities provided by some components for instance they want a word processor and a web browser but do not care about the additional components also installed.
this is illustrated by the fact that some package managers keep track of these additional components and automatically remove them when they are no more needed.
the sheer size of current mainstream repositories with tens of thousands of components and hundreds of thousands of relations makes it completely unfeasible to study such properties of a repository directly visualising such large graphs is both technically challenging and of little interes t as one would need to follow recursively a large number of dependency and conflict relations to understand how components relate to one other.
in this paper we develop a novel theoretical framework based on formally certified.
semantic preserving graph theoretic transformations that allows to associate to each concretecomponentrepositoryamuchsmallerrepositorywitha simpler structure but with equivalent co installability prop erties.
this smaller repository can be represented graphically giving a concise view of the co installability issue s in the original repository or used as a basis for various algorithms related to co installability like the efficient computation of the strong conflicts defined in .
weidentifiedseveralbugsinthedebiandistributionusing the present work.
for instance the harden servers package meant to prevent the installation of unsafe packages was in conflict with packages proftpd etsendmail but did not prevent the installation of the corresponding binaries which were in fact in packages proftpd base etsendmailbin the first two packages were actually transitional packages used to ease the upgrade from a previous release .
the paper is organised as follows section recalls the basic notions about packages and dependencies and overviews the repository transformation developed in the paper which achieves impressive results on real world gnu linux distributions section .
the technical development follows repositories are equipped with a partial order in section put into a flattened form in sections and simplified by removing irrelevant dependencies and conflicts in section and quotiented in section .
finally we show how to draw a simplified graph of the kernel of a repository in section .
we discuss related works and conclude in section .
.
overall approach while the concrete details may vary from one technology to the other the core metadata associated to component based systems always allows to express a few fundamental properties a component called package in the following maydependon a combination of components expressed as a conjunction of disjunctions of components and a componentmayconflictwith a combination of components expressed as a conjunction of components.
extra properties like provides e.g.postfix tls in example or versioned constraints e.g.libc6 .
in example can be easily preprocessed out so that one can focus on a core dependency system that contains a binary symmetric conflict relation and a dependency functiond 1 ... 1 n1 ... k ... k nk that is satisfied when for each iat least one of the i jis installed.
an example repository in this core dependency system is depictedinfigure1 thatalsointroducesthegraphicalnotation used in the paper package ahas two dependencies and can be installed only if first either package bor package cis installed and second package fis installed package cconflicts with bandf neither packages bandc nor packages c andf can be installed simultaneously package ddepends on package e which in turn depends on both fandg.
.
repositories wefollowthenotationsofearlierworks thatwe recall here.
a repository is a tuple r p d c wherepis a finite set of packages d p p p p is the dependency function we writep x for the set of subsets of x and c a symmetric irreflexive relation over p is the conflict relation.
aninstallation i of a repository p d c is a subset of p. an installation iishealthywhen the following holds abundance everypackagehaswhatitneeds.
formally for every package i and for every dependency d d we have d i e atio slash .
peace notwopackagesconflict thatis c i i .
we calldependency a set of packages dincluded in d for some package p. one can give a logical interpretation of the dependency function and the conflict relation.
the logical variables are the packages p. a set of packages d p p is interpreted as a disjunction llbracketd rrbracket logicalordisplay d .
a set of set of packages d p p p is interpreted as a conjunction llbracketd rrbracket logicalanddisplay d d llbracketd rrbracket.
a dependency function dis then interpreted as the set of formulas of the shape llbracketd rrbracket where ranges over p which can also be written logicalanddisplay i n logicalordisplay j mi i j withd di i n anddi i j j mi .
a conflict relation cis interpreted as the set of formulas for c. a healthy installation is an assignment which simultaneously satisfies all these formulas.
.
co installability a package isinstallable in a repository if it is included in a healthy installation iof this repository.
a set of packagesa c1d1cidicndn... ... b1 bi bn figure repository that blows up when flattened areco installable in a repository if they are all included in some healthy installation iof the repository.
checking co installability has been shown equivalent to sat by taking advantage of the logical interpretation of repositories .
however ourexperienceisthatthisproblem iseasyinpractice sat solverbasedtoolsarecurrentlyused routinely to identify non installable components on repositories that contains dozens of thousands of packages and hundreds of thousands of dependencies and conflicts.
.
extracting a co installability kernel identifying all the sets of components that cannot be installed together is way more complex even if we limit ourselves to the simplest case of sets of non co installable com ponents of size also known as strong conflicts testing all possible pairs of packages is not a viable option as the package number is in the tens of thousands.
even using all the optimisations described in the computation takes almos t a week on a modern workstation.
in the present work we lay down the essential theoretical basis and algorithmic insight for tackling this non coinstallability problem the fundamental idea is to extract from the component repository a kernelrepository which is equivalent to the original one as far as co installability is concerned but which turns out in practice to be orders of magnitude smaller and easily manageable.
the key steps of our approach are now summarised.
the effect of each step on the example repository of figure is shown in figure .
flattening.
the recursive nature of dependencies is convenient for package developers as it allows them to describe the dependencies among the different packages very concisely in a modular way.
to study the properties of a repository though it is way more convenient to use only a special flattenedform hatwidedofdependencyfunctionsthat directlydescribes all dependencies of each package if hatwided 1 ... k1 ... 1 n ... kn n then the packages j iare all the packages relevant for installing package and only them.
any dependency function can be converted in this form by a sort of transitive closure that expands the dependencies of each intermediate package and then converts the result again in a conjunction of disjunctions using distributivity on our running example this amounts to adding a dependency from dtof and one from dtog figure 2b .
this transformation has some similarity with the conversion of logical formulae to conjunctive normal form and is likewise subject toexponential blow up see for instance the dependency function of the repository in figure has size 3n and when expanded gives rise to a repository whose dependency function has size 2n.this is a strong limiting result but we are only interested in studying co installability of packages so we need not fully maintain the logical equivalence of repositories.
in particular we can prune the expanded dependency function by removing any dependency containing a package with no conflicts without changing the co installability property.
i n practice this suffices to avoid the exponential blow up.
on our running example this pruning phase removes the dependencies from dtoe fromdtogand from etog leading to the repository of figure 2c.
we take a further action to render the repository more homogeneous we add a self dependency to each package with conflicts.
this sort of reflexive closure will be very useful when quotienting the repository in a later phase.
there is no point in adding self dependencies to other packages as they would be removed by pruning.
we then find it convenient to draw the repository using a two level structure on the top we have all packages on the bottom we have packages with conflicts dependencies connects the top laye r to the bottom layer conflicts are between packages on the bottom layer.
on our running example this leads to the repository of figure 2d.
the three phases of expansion pruning and addition of self dependencies can be performed in a single pass and we thereafter use the term flattening to denote all of them.
elimination of irrelevant dependencies and conflicts.
as asecondphase weidentify several classes of dependencies and conflicts that are irrelevant as far as co installabilit y isconcerned andremovethem.
infigure4 we cansee some interesting examples more are given in section in all of which the disjunctive dependency connecting package ato packages bandccan be dropped a ifsomebranchesofadisjunctionareforcedbyastronger dependency all other branches can be dropped b a package with no conflict can be added to any installation so dependencies on such a package are always satisfiable and all disjunctive dependencies containing it can be simplified out this is the pruning defined above c if a package has a disjunctive dependency containing a package here b that conflicts only with other packages in this dependency here c this dependency is always satisfiable and can be dropped either a package conflicting with package bis installed or package bcan be installed in both cases the dependency can be satisfied.
in figure the conflict between packages aandbis implied bytheconflictbetweenpackages canddandcanbedropped.
proving the soundness of such simplifications is far from trivial in general one has to rely on a peculiar structure of the repository to justify that a dependency can be removed but removing a dependency may modify this very structure.
therefore a suitable invariant has to be found that allows to remove most if not all irrelevant dependencies.
on our example repository the disjunctive dependency from package ato packages bandc corresponding to figure 4c can be removed yielding the repository of figure 2e.
quotienting equivalent packages.
it is now quite evident looking at figure 2e that packages a d eandfare as far as co installability is concerned reallyequivalent theysharetheverysamesetofdependenciesa b ce f d g a original repositorya b ce f d g b transitivitya b cd f e g c pruninga b cd f e f g b c d self dependency addition a b cd f e f g b c e simplificationb c a d e f g b c a d e f f quotientb c a d e f g g drawing figure transformations of a repository added dependencies are in bold dotted ones are removed in the n ext phase a b c d a implied dependencya b c d b dependency on package with no conflicta b c d c dependency on package with only internal conflicts figure some irrelevant dependencies a b c d figure a redundant conflict notice that this fact is easily detectable on the graph thanks to the self dependency of package fintroduced during the flattening phase .
as many packages in a repository share the same behaviour with respect to co installability it is useful to quotient the final repository identifying these packages this step contributes greatly in reducing the size of the repository as can be seen on our running example in figure 2f.
after removing self dependencies one gets the final repository of figure 2g where it is now quite easy to see which package can be installed with which other package and which package cannot.
.
experimental results the transformations described in this paper have been proven correct and all the proofs have been certified in coq .
an ocaml program implementing these transformations has been run on several mainstream gnu linux distributions debian testing full suite amd64 snapshot taken august ubuntu .
main suite x386 and mandriva .
main suite x386 .
running time were measured on a machine using a intel core duo processor e6600 at .4ghz.
the relevant statistics of the results are given on table .
we can notice that the number of packages is greatly reduced many packages share the same behaviour as far as co installability is concerned and the quotienting phase identifies them.
in particular many packages can alwaysbe installed which is good news for the gnu linux distributions they are thus mapped to a single equivalence class.
the number of dependencies is reduced even more manytable repository sizes debian ubuntu mandriva before after before after before after packages dependencies conflicts median cone size avg.
cone size .
.
.
max.
cone size running time s .
.
.
20000cone size package count a before0246810121416 1000cone size package count b after figure distribution of cone size debian testing dependencies are not relevant to co installability and are removed by our transformations.
the simplification shown in figure 4c turns out to be essential for example in debian thousands of packages depend on debconf which depends on either debconf i18n ordebconf english these two last packages being mutually exclusive removing the disjunctive dependency hugely reduces the size of the final repository.
as for conflicts we notice that distributions contain only few of them which explains that flattening is practical most of them cannot be removed.
finally toeachpackage pinarepositoryonecanassociate itscone the set of packages that are reachable from pby following the dependency relations the cone size of a package is typically quite large figure two third of the packages have a cone of more than a hundred packages.
on the other hand after simplification two third of the package equivalence classes have a cone of size one meaning that they do not depend on any other package than themselves.
after simplification the ubuntu distribution fits on a letter size paper see figure in section and can be easily inspected visually for errors.
the corresponding graph for the debian distribution is much larger but it is our experience that it can still be displayed in a usable way with a suitable graph viewer the visualisation of the de a b c a d a b b c a b c b d a b figure an example of dependency functions related by the preorder bian co installability kernel can be tested online at http ocsigen.org js of ocaml graph .
as a consequence of the small size of the kernel extracted from a repository many analyses can be performed very quickly.
for example it is easy to compute on the coinstallability kernel of a repository the pairs of packages that canneverbeinstalledtogether knownas strong conflicts which is the simplest case of co installability.
on the same data as the computation takes a few seconds instead of the several days reported there.
this time is in fact included in the running times of table as we use this information when drawing the simplified repository to emphasise packages that prevent the installation of many other packages.
.
ordering repositories a large part of our work consists of finding constraints that can be removed while leaving co installability invarian t. wemaketheideaofremovingconstraintsprecisebydefining a preorder on repositories.
we first define a preorder on dependency functions d d iff for every package for every dependency d d there exists a dependency d d such that d d. as an example the dependency function dof the repository shown in figure 7a is subsumed by the dependency function d of the repository shown in figure 7b.
this preorder corresponds exactly to the converse of logical implication d d if and only if the formulas llbracketd rrbracket llbracketd rrbracketcan be derived for all packages p. the preorder induces an equivalence relation over dependency functions and a canonical representative of an equivalence class can be defined by taking the element which is point wise the smallest.
given a dependency function d its canonical representative can be explicitly defined as d d d d d d d d d .
thisprovidesafirstwaytosimplifythedependencyfunction illustrated by figure 4a and our implementation aggressively put all dependencies in canonical form.
we cannow definea preorder onrepositories p d c p d c if and only if p p d d c c .
given two repositories related under this preorder going fromtherighthandsideonetothelefthandsideoneconsists in removing conflicts or relaxing dependencies thus making it easier to install packages.
theorem .when p d c p d c any healthy installation i of repository p d c is also a healthy installation of repository p d c .
.
flattening dependenciestheflattened form of a dependency function whose intuition has been given in the introduction is formally defined as follows given a repository p d c theflattened dependency function hatwidedis the smallest function with respect to point wise inclusion such that refl c hatwided trans 1 ... n d d1 hatwided 1 ... d n hatwided n uniondisplay i ndi hatwided astheaboverulesaremonotonous suchafunction hatwidedexists.
the rule transexpands the intermediate dependencies of a package and converts the result back into a conjunction ofdisjunctions thisrulesilentlydropscirculardependencie s adding a dependency d has no effect on hatwided .
the rule reflis designed to capture precisely the two properties we have outlined informally in the introduction on one hand we want to keep in hatwided only dependencies on packageswithatleastaconflict weproveinthenextsection that they are enough for keeping co installability invariant on the other hand we want hatwided to contain explicitly all the packages that are needed to install package so if has a conflict it will also be an explicit dependency of itself .
the application of the transformation on the repository of figure gives the following result illustrated by figure 2e d hatwided a b c f b c f b b c c d e f e f g f f f g packages d eandfnow have the same dependencies which reflects the intuition that they behave the same way as far as co installability is concerned.
.
strongly flat repositories a flattened repository satisfies two properties theorem below a reflexivity property if a package has a conflict then it depends on itself and a transitivity property dependencies are stable under composition .
co installabili ty in such repositories that we call strongly flat can be shown equivalent to a more convenient property that we call weak co installability theorem this is instrumental to prove the key result of this section a set of packages are coinstallableinarepositoryifandonlyiftheyareco installab le in the corresponding flattened repository theorem .
we define precisely these two properties and study repositories that satisfies them.
we define the composition d d of two dependency functions over a set of packages pas the smallest function with respect to point wise inclusion such that for every package p for every set 1 ... n d for every sets di d i we have uniontext i ndi d d .
to any conflict relation c we associate a dependency function cdefined as follows c braceleftbigg if cfor some p otherwisea repository p d c isstrongly flat when the following conditions hold reflexivity c d every package with conflict depends on itself transitivity d d d dependencies are closed under composition .
the flattening transformation produces strongly flat repositories.
theorem .let p d c be a repository.
let hatwided be the corresponding flattened dependency function.
the reposito ry p hatwided c is strongly flat.
intuitively strongly flat repositories have a two level structure.
looking for instance at figure 2e we find all packages on the top layer and typically only packages with conflicts that we refer to as features in the following at the bottom layer thanks to transitivity everything a package may need to be installed is fully described by d without recursive traversal of dependencies and thanks to reflexivity conflicts need only be considered on the image of d. we can take advantage of this to define a more convenient way of capturing co installability aconfiguration is a pair i f of a set iof packages and a setfof features we say that it is healthywhen the following conditions hold abundance everypackagehaswhatitneeds.
formally for every package i and for every dependency d d we have d f e atio slash .
peace notwofeaturesconflict thatis c f f .
this is subtly different from the homonymous definitions regarding installations.
conflicts are only checked in f and abundance only checked for packages in iw.r.t.f the sets fandimight as well be disjoint here.
a set of packages are weakly co installable if there exists a set of features f psuch that the configuration f is healthy.
in general this is a weaker notion.
in strongly flat repositories though the two notions are equivalent.
theorem .any set of packages weakly co installable in a strongly flat repository are also co installable.
it is interesting to remark that the result of the flattening operation can be mathematically characterised as follows.
lemma .the flattened dependency function hatwided associated to a repository p d c is the least dependency function d for preorder and up to equivalence such that c d d d d .
the essential result of this section is that co installabili ty is left invariant by flattening.
theorem .let p d c be a repository.
let hatwided be the corresponding flattened dependency function.
let be a set of packages.
the following propositions are equivalent .
is co installable in p d c .
is weakly co installable in p hatwided c .
is co installable in p hatwided c .a b cd e figure illustration of monotony requirement .
flat repositories in this section we focus on a particular class c p p of dependencies that can be safely removed theorem .
removing these dependencies may destroy the strongly flat structure of a repository but we introduce the weaker notion offlatrepository which is preserved theorem and for which co installability and weak co installability sti ll coincide theorem thus enabling further simplifications introduced in section .
we want to capture in the class ca set of dependencies that have the following two key properties always satisfiable any healthy configuration in the repository can be extended to satisfy these dependencies so they are irrelevant for co installability and we can remove them formally this means that if d c then for all f p p maximal with respect to set inclusion such that c f f we have d f e atio slash monotony a dependency which is in cmust still be alwayssatisfiableevenifweremovesomeconflictsfrom the repository formally if c c then c c .
themonotony property is necessary because in the next section we introduce further simplifications that remove redundant conflicts.
we want to be sure that removing a conflict later on does not invalidate the decision taken here of removing a dependency as illustrated in figure the disjunctive dependency on packages bandccan always be satisfied because the conflict between dandeprevents the simultaneous installation of dande but this dependency is not in csince it is no longer satisfiable if the conflict between dandeis removed.
this leads to the following definition .given a repository p d c the set c is the largest set such that d cif and only if for all c c for all f p p maximal with respect to set inclusion such that c f f we have d f e atio slash .
we can give a more explicit characterisation of the elements of c these are exactlythe dependencies that contain at least a package having only internal conflicts like in figure 4c.
theorem .let p d c be a repository.
the set c is the set of dependencies dsuch that there exists a package dsuch that for all pairs c we have d. notice that if a dependency dcontains a package with no conflict then it is in c so calso contains the redundant dependencies shown in figure 4b.
as we shall see weak co installability is left invariant by thetransformationthatremovestheelementsofset cfrom a dependency function dof a strongly flat repository.
but in general the strongly flat property is lost so we need a weaker notion that is preserved by this simplification.
we start by defining a coarser preorder on dependency functions that ignores dependencies in c d cd if and only if for every package for every dependency d d eitherd cor there exists a dependency d d such that d d. a repository p d c isflatwhen it satisfies the following properties reflexivity c cd transitivity d d cd.
flat repositories have a series of good properties they include strongly flat repositories co installability and weak co installability still coincide removing cpreserves flatness and keeps co installability invariant.
lemma .any strongly flat repository is flat.
theorem .any set of packages weakly co installable in a flat repository are co installable in this repository.
theorem .let p d c be a flat repository and d be the dependency function such that d d c for all p. the repository p d c is flat and coinstallability is left invariant by this transformation.
one can still reason on flat repositories as far as coinstallability is concerned as if their dependency function was transitive just choose installations i f where fis maximal and then any dependency obtained by composition is satisfied even when it is not explicitly in the dependency function.
for strongly flat repositories this holds for arbitrary sets f. .
irrelev ant constraints we review now several classes of dependencies and conflicts that are redundant and can be simplified out.
.
clearly irrelevant dependencies the results of the previous section let us remove the dependencies in cfrom a flat repository while leaving weak co installability invariant and keeping the repository flat.
.
conflict covered dependencies an example of another very interesting class of irrelevant dependencies is shown in figure where the dependency for package acan always be satisfied despite the conflict between packages eandf we assume the other packages in this dependency also have conflicts not explicited so th e dependency cannot be obviously removed indeed for this conflict to be relevant for the dependency fneeds to be installed but if fis installed at least one of packages cand dis installed as well and thus the dependency is satisfied without needing to install e. this generalizes to the case where package eis in conflict with several packages with the same property as package f. more formally we say that a dependency disconflict covered at if it contains a package such that for all c there exists a dependency d d such thatd d .
removing one such dependency leave co installability invariant.
lemma .let p d c be a flat repository dbe aconflict covered dependency and d be the dependency function obtained by removing dfrom d. any set of packages weakly co installable in p d c is weakly co installable in p d c .e fa c d b figure dependency covered by the conflict requirements.b c d e a figure redundant conflict belonging to a clique unfortunately removing such dependencies may destroy the flatness of the repository so we remove them one after another in a greedy way and only after checking that flatness is preserved by using the following result.
lemma .let p d c be a flat repository.
let p andd d. let d be the dependency function d where the dependency dof package has been removed.
if the following two conditions hold then p d c is flat.
d e atio slash for alld d d we have d e atio slash d .
in practice it can be simpler to get all possible dependenciesd above by taking all dependencies d d d and composing them with dependencies in d. thegraphreductionruledefinedbythissimplificationhas unsolvable critical pairs so the result of this simplification could depend on the order of removal.
in practice though we remove all instances present in the initial repository.
.
redundant conflicts we consider some of the conflicts that can be removed from a repository while leaving co installability invariant.
a conflicting pair 1 cisredundant if there exists a dependency d d 1 such that for all 2 d there exists a package 2such that 2 c 1 e atio slash 2 there exists d d 2 such that d .
redundant conflicts can be removed but only one at a time for example if two conflicts are considered redundant thanks to the existence of one another then removing both of them simultaneously is incorrect.
lemma .let p d c be a repository.
let 1 2 be a redundant conflict in this repository.
any healthy installation of repository p d c 1 2 2 1 is healthy in repository p d c .
removing redundant conflicts involves a trade off.
on one side it may allow to remove some additional dependencies on the other it can also break some interesting structures.
in figure the conflict between bandcis redundant but removing it breaks the clique a b c which is useful when drawing a simplified graph.
.
dependence on conflicting packages a special configuration may surface in the repository duringsimplificationwhentheinitialrepositorycontainsbroken packages as depicted in figure clearly package acannota b figure dependence on conflicting package be installed and leaving such a configuration in the repository would pollute the graphical representation.
in this case we mark explicitly package aas broken by replacing its dependencies by the empty dependency .
all conflicts involving acan then be also removed as they are redundant section .
.
the transformation preserves healthiness.
lemma .let be a package not installable in some repository p d c .
let d be the dependency function that coincide with d for all packages but and such that d .
any healthy installation of repository p d c is also healthy in repository p d c .
the flatness of the repository may be destroyed as some of the removed dependencies may be involved in transitivity.
thus after applying such simplification flattening should be performed again.
.
quotienting the set of packages in real world repositories many packages share the same behaviour as far as co installability is concerned for example a lot of packages can always be installed and some groups of packages only conflicts with a single other package.
in this section we define an equivalence relation between packages and show that the quotient w.r.t.
this relation preserves all the good properties of a repository.
we define two packages as equivalent in a repository p d c if they have the same dependencies if and only if d d .
we write for the equivalence class of package and extend this definition to set of packages .
thequotient repository p d c of a repository p d c is naturally defined as follows p is the set of all equivalence classes p p p the dependency function d is such that d d d for all p the conflict relation c is defined by c c .
if the original repository does not contain dependencies of the form of figure nor redundant conflicts then the quotient repository is indeed a repository the key point to check is irreflexivity of the conflict relation .
lemma .let p d c be a flat repository such that for all p and for all d d ifd for some p then e atio slash c. its quotient is indeed a repository.
quotienting preserves flatness and keeps co installability invariant.
theorem .a set of packages is weakly co installable in the flat repository p d c if and only if the set is weakly co installable in the associated quotient reposito ry.
theorem .if a repository is flat then the corresponding quotiented repository is flat as well.repeat p d c flatten p d c p d c canonise p d c p d c p d c c p d c remove clearly broken p d c p d c remove redundant conflicts p d c untilthe last two steps above have no effect p d c remove conflict covered deps p d c return quotient p d c figure simplifying the repository.
.
reflexive transitive reduction it would not be suitable to graph directly a repository after flattening as it would be polluted by dependencies which are not informative due to reflexivity we have packages where d and some dependencies can be deduced from others by transitivity.
thus we perform a kind of reflexive transitive reduction of the dependency function given a repository p d c we find a minimal dependency function d with the same flattening that is hatwided hatwiderd .
because of disjunctive dependencies the complexity of finding an optimal solution is high in constract with the case of reflexive transitive reduction for graphs.
as this ismostlyacosmeticissueforus weuseasimplenon optimal algorithm.
as a first step we iteratively remove dependencies which are implied from other dependencies by transitivity in a greedy way.
the second step is to remove all self dependencies that is dependencies d d such that d. co installability is left invariant by these operations.
lemma .let p d c be a repository.
let p be a package and d d be a dependency of this package.
let d d mapsto d be the dependency function d where the dependency has been removed.
if d d d then any healthy installation i of repository p d c is a healthy installation of repository p d c .
lemma .let p d c be a repository.
let d be the dependency function defined by d d d e atio slash d .
any healthy installation i of repository p d c is also a healthy installation of repository p d c .
.
putting all together we now have all the ingredients at handto performon any repository p d c the transformations that allow to produce the final repository which is suitable both for drawing a simplified graph or performing efficiently various analysis related to co installability.
.
extracting a co installability kernel the complete algorithm is shown in figure .
we first flatten the initial repository section canonise the depen dency function section and remove the clearly irrelevant dependencies in c section .
in our implementation all these operations are performed simultaneously this is significantly more efficient as we have less dependencies to consider while flattening.
then we set the dependencies of broken packages of the form of figure to the empty dependency section .
and we remove redundant conflicts section .
.
as changing the dependencies of broken packages may break flatness and removing may grow c thesea b c d a explicit representationa b c d b compact representation figure conflict clique fives steps are iterated until no change occurs.
the process terminates as at each iteration either d is set to for a package or a conflict is removed.
in practice only two iterations are performed more iterations are only needed in unlikely configurations where dealing with a broken package exposes another package as broken.
finally we remove the conflict covered dependencies that can be safely dropped section .
and the repository is quotiented section .
by combining the results of the previous sections we obtain the fundamental result on the simplification performed by the algorithm.
theorem .the transformation performed by the simplification algorithm leaves co installability invariant .
this algorithm produces a flat repository.
as noticed above on a repository with no broken package it is not necessary to iterate the flattening phase so the algorithm could run slighly faster but finding all broken packages is slower than performing the whole simplification as it requires to call a sat solver repeatedly on large problems.
on the other hand repositories with good quality control should contain no broken packages and a simpler version of the simplification algorithm could be used on them.
.
drawing a simplified graph before drawing the final repository we perform the transitive reflexive reduction of section .
the structure of the graph is then passed as input to the dotprogram of the graphviz toolkit that performs the layout.
it is important to name nodes using meaningful representatives of each equivalence class we give preference to packages that are directly involved in conflicts as they have more chances to be relevant for the repository maintainers these are easy to find by checking if d .
there can be many packages all mutually in conflict.
for instance this is the case of all mailer agents in debian.
we identify maximal such cliques and draw them in a more concise way as shown in figure .
we compute strong conflicts non coinstallable pairs of packages and use this information to emphasise packages that prevent the installation of many other packages.
.
visualizing ubuntu in figure we can see the result of applying the simplifications described in this paper to the main section of release .
of the ubuntu gnu linux distribution solid arrows indicate dependencies dotted lines indicate conflict s and conflict cliques are represented with a node containing a connected with dotted lines to all packages in the clique.
of the thousands of packages and dozens of thousands of relationships only a handful are left and it is possible to readinteresting information directly on the graph.
we give here just a couple of examples.
the isolated node in the middle left stands for packages that arealwaysinstallable.
the five conflict cliques are justified as they all correspond to incompatible implementations of libraries which are compiled with different backends.
one can see that package libjpeg8 dev is in conflict with other packages which is likely to make it unconvenient to use.
the core package ubuntu desktop is in conflict with a number of packages.
these packages should either be removed from the main section or the dependencies should be revised.
for instance packages foomatic db andlibgd2noxpmshould probably be removed.
on the other hand package libsdl1.2debian all provides a superset of the functionalities of libsdl1.2debian pulseaudio .
thus it should not be in conflict with ubuntu desktop .
overall there are few issues with this repository.
our tool is most useful for detecting issues proactively when the distribution is in flux during alpha and beta stages .
.
related and future work many relevant research issues stem from the concrete and widespread applications of software component repositories identifying components that can never be installable has been shown np complete but tractable in practice and there is currently very active research on computing installations that optimise some given objective functions organised around the mancoosi international solver competition determining what other components a package will always need and what pairs of packages are incompatible have been shown to be relevant for quality assurance in package repositories finally since feature diagrams used in software product lines can be encoded as component repositories all the problems related to configuration management can be equivalently stated in terms of repositories.
connections between component repositories and boolean satisfiability and constraint solving have been made only a few years ago in the framework of gnu linux distributions and the eclipse platform but these connections and other recent developments such as do not exploit thespecial structure of the dependencies and conflicts found in a repository.
the underlying structure of software component repositories exposed here can also be seen as a generalisation of some known mathematical structures prime event structure correspond to repositories without loops and disjunctions directed hypergraphs correspond to repositories without conflict arcs and dual horn theories correspond to repositories with conflicts .
in this paper we have developed a theory and algorithms to extract from a repository a co installability kernel which can be seen as a minimal representation of the dependency and conflict relations despite the apparent simplicity of the definition of the problem and the intuitive appealing of the hypergraph transformations we have developed the proofs of the crucial properties turned out to be surprisingly complex so we decided to machine check them using coq and a long version of this paper containing all the proofs is available onlin e as .
the results presented here pave the way to attacking significantly more complex problems concerning software component repositories.
more generally we believe this work clearlyshowstheinterestofthemathematicalobjectsunderlying software repositories which turn out to be amenableto an elegant formal treatment and of high practical interest.
artifact evaluation the tool coinstimplemeting the analysis described in this article has been evaluated by the esec fse artifact evaluation committee and it has be found to exceed expectations more information on this tool can be found online at .
.