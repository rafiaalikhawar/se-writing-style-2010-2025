simulation based abstractions for software product line model checking maxime cordy andreas classen gilles perrouin pierre yves schobbens precise research center university of namur belgium.
mcr acs gpe pys info.fundp.ac.bepatrick heymans precise research center university of namur belgium.
inria lille nord europe universi e lille france.
lifl cnrs france.
phe info.fundp.ac.beaxel legay irisa inria rennes france.
aalborg university denmark.
university of li ege belgium.
axel.legay inria.fr abstract software product line spl engineering is a software engineering paradigm that exploits the commonality between similar software products to reduce life cycle costs and time to market.
many spls are critical and would benefit from efficient verification through model checking.
model checking spls is more difficult than for single systems since the number of different products is potentially huge.
in previous work we introduced featured transition systems fts a formal compact representation of spl behaviour and provided efficient algorithms to verify fts.
yet we still face the state explosion problem like any model checking based verification.
model abstraction is the most relevant answer to state explosion.
in this paper we define a novel simulation relation for fts and provide an algorithm to compute it.
we extend well known simulation preservation properties to fts and thus lay the theoretical foundations for abstraction based model checking of spls.
we evaluate our approach by comparing the cost of fts based simulation and abstraction with respect to productby product methods.
our results show that fts are a solid foundation for simulation based model checking of spl.
keywords model checking software product lines formal methods simulation abstraction feature i. i ntroduction software product line spl engineering is an increasingly popular software development paradigm targeting families of similar software products.
it allows to make substantial economies of scale by taking into account the commonalities between the family members during the whole development life cycle.
the different variants of the system called products are identified upfront and a model of their differences and commonalities typically a feature diagram is created.
in this context features are atomic units of difference that appear natural to stakeholders and technicians alike.
spl engineering has become widespread in industry including critical applications such as automotive or avionics.
these software products require solid evidence that they work correctly according to their requirements and intended properties.
model checking is a well known technique for verifying system behaviour.
a simple method for checking fnrs research fellowa product line consists in applying single system model checking algorithms to each individual product.
however for an spl with nfeatures up to 2nexecutions of those algorithms may be needed.
this enumerative approach is clearly impractical and thus should be replaced by new verification approaches specific to product lines.
in our previous work we addressed this problem by introducing featured transition systems fts see example in figure .
fts are an extension of transition systems that represent the behaviour of allthe products of a given spl in a compact structure.
we also proposed fts specific model checking algorithms to verify the whole spl in a single execution.
more precisely these algorithms model check the spl against temporal properties expressed either in linear time logic ltl extended with features fltl or in an extended computation tree logic ctl fctl.
these logics can be used to express properties such as for all products with features fandg a request is always followed by a response .
given such a property our algorithms can compute the features required for the property to be satisfied and hence the products of the spl that do satisfy the property.
we call them fts algorithms .
we evaluated the efficiency of the fts algorithms through the implementation of several libraries and tools.
first we developed a haskell library for checking an fts against ltl formulae .
we also built an extension to the modelchecker nusmv to verify ctl formulae using the fts algorithms .
recently we developed snip an spl model checking toolset that combines the fts algorithms with promela the high level specification language used in the well known model checker spin .
early experiments have shown that the fts modelchecking approach is more efficient than the enumerative approach.
indeed when comparing the two approaches implemented within our tools we observe that fts algorithms generally outperform the enumerative method .
however our experiments also have shown that there is still much room for improvement.
spl verification theory is still at an early stage and needs to be further improved to target industry scale spl verification.
.
c ieee icse zurich switzerland model abstraction is an optimisation that aims to simplify a model prior to its verification .
roughly speaking an abstraction function is used to reduce the size of a model by merging similar states.
depending on the definition of this function the behaviour of the model may change that is new behaviours may appear existing ones may disappear or both.
characterising the abstracted model with respect to the original one is therefore essential since those behavioural modifications may impact on the satisfiability of temporal properties.
such a characterisation is generally obtained thanks to the definition of a simulation relation .
in this paper we lay the theoretical foundations for abstraction based model checking of spls.
first we extend the definition of simulation from transition systems to fts and propose an algorithm that computes this relation.
we then establish which properties are preserved by the simulation relation and for which products.
this is required to perform reliable checking.
then we define three abstractions based on the notion of simulation quotient that can be applied to remove redundant behaviour in an fts and thus reduce verification time.
in addition to abstraction simulation relations have numerous applications.
in particular simulation based model checking is an established verification method as ltl ctl model checking is.
our solution allows easier verification of properties modelled visually as automata rather than logical formulae which is more suitable for engineers.
studying fts simulation is thus as important as generalising ltl ctl model checking to fts.
we provide a concrete implementation for computing simulation and applying abstraction to fts.
we carry out a complexity evaluation and empirical evaluations that reveal substantial efficiency improvements over enumerative application of classical simulation.
this corroborates previous results by characterising the gain of fts based simulation model checking over enumerative ts based simulation model checking.
the structure of the paper is as follows.
in section ii we recall essential results theorems and properties related to the abstraction of transition systems as well as the definition of fts.
section iii is focused on the definition and the computation of the simulation relation.
section iv defines the simulation quotient as well as abstraction functions based on it.
section v describes or experiments and their results.
finally section vi presents related work in the fields of spl modelling and abstraction based verification.
ii.
b ackground in this section we first present the established concepts related to the verification and the abstraction of transition systems ts .
ts are a classical behavioural model for single systems.
we also briefly recall some definitions of our previous work that are needed in the paper.a.
single product model checking model checking is a well known technique for verifying both hardware and software against temporal properties.
basically given the model of a system mand a temporal property a model checking algorithm determines whether or notmsatisfies writtenm .
for single systems ts are used and are defined as follows .
definition a ts is a tuple s trans i ap l wheresis a set of states trans s sis a transition relation i s is a set of initial states apis a set of atomic propositions andl s 2apis a labelling function that associates every states with the set of atomic propositions satisfied by this state.
we call a behaviour of the system the sequence of atomic propositions satisfied during its execution.
the semantics of a ts noted ts is then its set of behaviours that is ts l s0 l s1 ... s0 i si si trans .
note that the definition of ts usually includes a set of actions.
however these are not considered in this paper and consequently they are ignored in our definition which thus boils down to a kripke structure.
ts can model a software product at different abstraction levels.
if a more abstract that is smaller model preserves the properties of a larger model it is more efficient to check properties on the abstract model.
it is therefore essential to be able to relate two models at different abstraction levels.
for single systems this information is formally captured by asimulation relation .
definition lettsi si trans i ii ap l i i be transition systems over ap.
a simulation for ts1 ts is a binary relation r s1 s2such that s1 i1 s2 i2 s1 s2 r and s1 s2 r it holds that a l1 s1 l2 s2 and b s prime post s1 s prime post s2 s prime s prime r. wherepost s s2 trans s s2 denotes the set of states that can be reached from s. then ts2simulatests1 denoted by ts1 precedesorcurlytsts2if there exists a simulation for ts1 ts .
according to this definition if ts1is simulated by ts2 then any behaviour of ts1can be reproduced in ts2.
we can extend this definition to couples of states instead of couples of tss.
in this case state s1is simulated by state s2iff s1 s2 r for somer also noted s1 precedesorcurlytss2.
intuitively this means that any behaviour produced from s1 can be produced from s2.
also precedesorcurlytsis a preorder it is reflexive and transitive .
additionaly when ts1 precedesorcurlytsts2 andts2 precedesorcurlytsts1 the two transition systems are called simulation equivalent notedts1 similarequaltsts2.
intuitively this673means thatts1andts2model exactly the same behaviour.
since precedesorcurlytsis a preorder similarequaltsis an equivalence relation .
the definition of simulation allows one to characterise the behaviour of an abstract transition system hatwidetswith regard to an original model ts.
informally an abstract transition system is obtained by merging states for which a so called abstraction function returns the same value.
the abstraction may add or remove behavioural options depending on the chosen abstraction function.
however a relevant analysis requires to have either ts precedesorcurlyts hatwidets ts precedesorcurlyts hatwidetsor both.
if this condition is satisfied we can show that the abstraction preserves the un satisfiability of properties of a certain type.
indeed there is a strong link between the simulation relation and the properties satisfied by two tss.
in this paper we focus on properties expressed in linear time logic ltl .
however the presented results can also be applied to specific fragments of the computation tree logic ctl .
if a simulation relation exists between two transition systems we can show that an ltl formula satisfied by the simulating ts is preserved in the simulated one .
property letts1andts2be two transition systems without terminal states and an ltl property.
then ts1 precedesorcurlytsts2 ts2 ts1 .
the following statement is equivalent if ts1does not satify neither does ts2.
finally if ts1 similarequaltsts2 then they satisfy exactly the same ltl properties.
in particular if ts2 is an abstraction of ts1 proving that the abstract ts verifies an ltl formula suffices to ensure that the formula holds for ts1.
therefore abstraction can drastically shorten the time and space cost of verification.
b. software product line verification while a ts is convenient to model the behaviour of an individual product of an spl it is not suitable for concisely representing all the possible products.
to overcome this we defined featured transition systems fts .
basically an fts is a ts augmented with transitions labelled with feature expressions see figure .
these features are described in afeature diagram fd that establishes the set of legal products .
for this paper it is enough to know that the semantics of a feature diagram ddefined over a set of featuresnis the set of all the valid products that is a set of sets of features denoted by fd p n .
schobbens et al.
give a more thorough and formal definition of fd.
also every transition of an fts is labelled with a feature expression that defines the products able to execute the transition.
formally fts are defined as follows .
definition an fts is a tuple s trans i ap l d where s trans i ap l are defined as in definition dis a feature diagram trans parenleftbig n parenrightbig is a total function labelling each transition with a feature expression b n i.e.
a boolean function over the set of features.
by we denote the set of products that satisfy t .
similarly with ts our definition of fts does not include a set of actions.
an fts can be seen as the merging of all the tss of the products that compose the spl.
because of that the successor operator must be redefined in order to take into account that a state can be a successor of another one only for a specific set of products .
definition the successors of s sfor products px p n are given by post s px s prime px prime s s prime trans px prime px .
furthermore any ts corresponding to a specific product can be obtained from the fts by applying a projection function.
in simple terms this function removes all the transitions of the fts whose feature expression is not satisfied by the considered product .
definition the projection of an fts ftsto a product p fd notedfts p is the tsts s trans prime i ap l wheretrans prime t trans p .
because the fts represents the behaviour of allthe products its semantics is defined as a function that associates a product with the set of behaviours of its projection.
definition the semantics of an fts fts is a function fts with domain fdsuch that p fd fts p ts.
finally in we extended ctl to define a property only on a subset of the valid products.
the same extension can easily be applied to ltl.
definition an fltl property is an expression where n is a feature expression and an ltl property.
an fts ftssatisfies an fltl property iff p fd fts p .
iii.
s imulation relation for spl m odels since a model abstraction does not necessarily verify the same properties as the original model it is essential to characterise the behavioural inconsistencies between the model and its abstraction.
in the previous section we presented the simulation for tss as a computable relation that can establish this characterisation.
however their definition is clearly unsuitable in our context because we are interested in abstracting spl models rather than models of individual systems.
in this section we thus introduce a definition674of simulation for fts.
we also propose an algorithm to compute it and we establish a link between the latter and the preservation of fltl formulae.
a. simulation relation for fts as a first step we extend the definition of simulation to fts.
for this purpose we first impose the restriction that a simulation relation can only hold between two fts defined over the same fd .
intuitively an fts simulates another one iff every valid product has more behaviour in the former fts than in the latter.
formally this condition can be expressed using the simulation on ts as defined previously.
definition letftsi si trans i ii api li d i i be fts with ap1 ap2.
then fts1is simulated byfts2for products fd where p fd fts1 p precedesorcurlytsfts2 p .
since the semantics fts1 precedesorcurlyftsfts2 is a set of products we see it as a feature expression.
furthermore fts1is completely simulated by fts2iff fd.
note that this definition does not consider illegal products that is products that are not included in fd.
thanks to the above definition we can already determine for which products an fts simulates another.
however this would require computing the simulation relation on ts for o 2n couples of ts which sums up to an overall time complexity bounded by o s .2n .
instead we aim to take advantage of the compact structure of fts as we did for solving the model checking problem for spl in our previous work .
hence we propose the following alternative definition.
definition letftsi si trans i ii api li d i i be featured transition systems with ap1 ap2.
a simulation for fts1 fts is a binary function r s1 s2 b n such that r s1 s2 l1 s1 l2 s2 ap1 logicalanddisplay s prime 1rvia s1 s prime s2 wherervia s1 s prime s2 is given by 1 s1 s prime logicalordisplay s prime r s prime s prime 2 s2 s prime with s1 s prime trans 1and s2 s prime trans .
then fts1is simulated by fts2for products logicalandtext i1 i1 logicalortext i2 i2rfts i1 i2 fd whererfts is the largest simulation for fts1 fts .
by largest we mean that for any states s1 s2and simulationrfor fts1 fts we have .
this definition can be seen as a generalisation of definition .
intuitively contains only productsstate transition ffeature a b s1 s prime a b b s2 s prime 2fs prime prime f f f figure .
two simulation equivalent fts.
for whichs2has more behaviour than s1.
in other words for each product p and transition s1 s prime available for p s2must have at least one successor s prime reachable by pand such that p rfts s prime s prime .
similarly rvia s1 s prime s2 contains only products for which s2 can simulate the transitions from s1tos prime .
let us note that according to our definition negationslash implies that all atomic proposition satisfied by s1 that is propositions in ap1 are satisfied by s2.
for givens1ands prime 1such thatrvia s1 s2 s prime px px prime it may happen that s2simulates a transition s1 s prime 1for products pxvia a transition s2 s prime 2and for productspx primethanks to another transition s2 s prime prime .
to illustrate this second remark let us consider the basic example presented in figure .
we observe that rfts s prime s prime fandrfts s prime s prime prime f. furthermore s2simulatess1for products through transition s2 s prime and for products via transition s2 s prime prime .
in the end we conclude that s2simulatess1for all products.
as established in the following theorem the two definitions of simulation for fts we have given are equivalent.
due to lack of space we omit the proof but the interested reader can find it in our technical report .
theorem letftsi i be fts.
letrfts be the largest simulation for fts1 fts .
then it holds that .
as for ts we can define simulation equivalence for fts.
intuitively two fts are simulation equivalent for products pxiff they have the same behaviour for all these products.
definition letfts1andfts2be two ftss.
if pxand px prime thenfts1andfts2are called simulation equivalent for products in px px prime.
furthermore they are called completely simulation equivalent iff .675b.
computing the simulation relation we proposed two equivalent definitions of the simulation relation for fts.
while the former is more intuitive it is cumbersome to compute for a large spl i.e.with a high number of products.
on the contrary the latter takes advantage of the compact structure of the fts.
in this subsection we present a method to compute the relation using this second definition.
basically rfts is obtained for all couples of states of a given fts by computing the greatest fixed point of a function.
first we need to define a partial order on the feature expressions.
let eande primebe two feature expressions.
we say thateis included in e prime notede e prime iff .
using this partial order we define that ris included inr prime noted r r prime iff s1 s2 r s1 s2 r prime s1 s2 .
then the simulation function can be computed as the greatest fixed point of the equations of rin definition denoted by t r .
note that r i t r r .
then according to the knaster tarski theorem rfts can be computed as follows rfts ri j i ri rj with s1 s2 r0 s1 s2 braceleftbigg b fd l s1 l s2 ap1 b otherwise ri s1 s2 t ri s1 s2 where for a set of products px b px denotes a feature expression such that px.
thanks to this algorithm we can compute fts1 precedesorcurlyfts fts2 for anyftsi si acti trans i ii api li d i .
for this purpose we apply it to the fts fts1 fts2 which is defined by fts1 fts2 s1 unionmultis2 trans trans i1 i2 ap ap2 l d where unionmultidenotes the disjoint union l s li s iffs si and t i t ifft trans i. using the value of rftsbetween each initial state of fts1and each initial state offts2 we determine fts1 precedesorcurlyftsfts2 .
note that baier and katoen present a similar method for computing the simulation relation between two ts.
c. property preservation the simulation relation for ts is particularly well known for its interesting preservation properties .
in particular if ts2simulatests1 then any ltl property satisfied by ts2is also satisfied by ts1.
as we show in this section a similar results holds for fts simulation.first we must define a new notion of satisfiability specific to product lines.
indeed the model checking problem for spl does more than determining the satisfiability of a formula it requires to identify all the products that do not satisfy the formula hence the need of a new satisfiability relation.
definition letfts be a fts and an fltl property.
then the f satisfiability of byfts noted fts f is a feature expression such that p fd p fts p .
similarly we define the f unsatisfiability of byfts noted fts negationslash f as a feature expression such that p fd fts p negationslash .
it has to be noted that is a partition of fd.
thanks to definitions and property can be generalised to fts as established in the following theorem.
again we omit the proof and refer the reader to our technical report .
theorem letftsi si acti trans i ii ap li d i i be two fts an fltl property andpx .
then it holds that p px p p p px p p .
in particular this theorem implies that two completely simulation equivalent fts have the same f un satisfiability.
iv.
fts s imulation quotient in the previous section we defined a simulation relation for fts and we established the link between this relation and the f satisfiability of an fltl property.
our objective is to present through the study of simulation quotient how we can define fts abstractions.
we also make use of the preservation properties see theorem to determine how the verification of an abstract fts provides information about the original system.
a. simulation quotient the first abstraction we introduce does not modify the behaviour of the fts to which it is applied.
it merely consists in defining the simulation quotient for fts.
this form of abstraction merges states that are completely simulationequivalent i.e.for all products in fd.
formally we define the binary relation similarequald fts s s s1 similarequald ftss2 rfts s1 s2 fd.
this relation is an equivalence since similarequaltsis also an equivalence relation .
therefore the state space of any fts can be partitioned into equivalence classes under similarequald fts.
our first676abstraction function merges states of the same equivalence class.
similarequald ftsdenotes the equivalence class of s. the function associates an fts fts with an abstracted ftsfts similarequald fts s prime trans prime i prime ap l prime d prime such that s prime similarequald fts trans prime similarequald fts similarequald fts s s prime trans i prime similarequald fts s i l prime similarequald fts l s prime similarequald fts similarequald fts logicalordisplay s prime prime s prime prime prime s prime prime s prime prime prime wheres prime prime similarequald fts s prime prime prime similarequald fts and s prime prime s prime prime prime trans .
it thus requires to compute first the simulation relation for every pair of states in the fts see section iii b .
such an abstracted fts has exactly the same behaviour as the fts on which the function is applied that is fts similarequalfts fts similarequald fts fd.
indeed we merge only states that are simulation equivalent for every products in fd.
thus the merging neither adds nor removes any behaviour.
it is only meant to remove redundancy.
according to theorem this implies that the two fts have the same f un satisfiability with regard to any fltl formula.
a formal proof is available in our technical report .
in spite of its straightforward computation this first abstraction function has shown to be inefficient when it comes to actually reducing the state space as we will see in section v. consequently we define more efficient abstraction methods.
b. reachability aware simulation quotient the second abstraction method is similar to the first one but it takes into account the reachability of each state when determining the equivalence classes.
it requires the computation of a function precedesorcurlyrch s s b n .
in simple terms s1 precedesorcurlyrchs2gives a feature expression satisfied by the products for which s1ands2simulate each other while considering the reachability relation associated with s1 ands2respectively.
more precisely we define the following s2trivially simulates s1for products that cannot reach s1 s2cannot simulate s1for products that can reach s1 but nots2.
according to this definition s1 precedesorcurlyrchs2 is given by reach s1 reach s2 rfts s1 s2 wherereach s denotes a feature expression satisfied by the products that can reach state s. next we define the binary relation similarequalrch s ssuch thats1 similarequalrchs2iff s1 precedesorcurlyrchs2 s2 precedesorcurlyrchs1 fd.
again similarequalrch is an equivalence relation.
it is obviouslyreflexive and symmetric.
its transitivity can be demonstrated by first observing that rfts s1 s2 rfts s2 s3 rfts s1 s3 see for a formal proof .
consequently the state space of an fts can be partitioned into equivalent classes under similarequalrch.
using this binary relation we define an abstraction function that merges the states of an fts according to their equivalence class under similarequalrch.
hence the results of applying the function on an fts ftsis an abstracted fts fts similarequalrch which is defined similarly to fts similarequald fts.
we can show that this abstracted fts has exactly the same behaviours as the original one that is fts similarequalftsfts similarequalrch.
again due to lack of space we present the proof only intuitively and we refer to .
let p fdbe a product.
ifs1 similarequalrchs2 thenpcan reach either both s1ands2or none of them ifpcan be reached by both s1ands2 it means that it has exactly the same behavioural options in s1ands2 by definition of similarequalrchandrfts.
therefore merging s1ands2would not add any behaviour to p. ifpcan reach neither s1nors2 then merging the two would not actually add behaviour to psince it would not be able to reach the resulting abstracted state anyway.
thus for any fltl property fts f fts similarequalrch f .
c. reachability aware preorder based abstraction unlike the previous ones the last abstraction actually modifies the behaviour of the fts on which it is applied.
although it preserves the existing behaviour it may add some.
informally for any couple of states s1 s2 if s1 precedesorcurlyrchs2 fd thens1is integrated into s2.
by integration we mean that all the transitions going to s1are redirected to s2ands2as well as its outgoing transitions are discarded.
since s2simulatess1for any product we do not remove any behaviour from the fts.
however new behavioural options may appear for products in fd see for a formal proof .
let us observe that this form of abstraction is not a function since for a given fts it may lead to several abstracted fts.
for example let s1 s2 s3be three states such that s1 precedesorcurlyrchs2 s1 precedesorcurlyrchs3 fd s2 precedesorcurlyrchs3 s3 precedesorcurlyrchs2 negationslash fdand there exists nos4such that s2 precedesorcurlyrchs4 s3 precedesorcurlyrchs4 fd.
this implies that s1can be integrated into either s2ands3 but these two will never be merged.
instead of defining formally the set of fts that can result from one of these abstractions we give an algorithm to greedily build one of its element see algorithm .
first we register the couples of states s1 s2 such that s1 precedesorcurlyrchs2 fdin a setr line .
next we677keep merging states as much as possible lines .
at each iteration we remove an element of r ands prime nondeterministically lines .
let s1 s2 be this element.
then s1is not part of s prime the state space of the abstract fts line .
furthermore if s1was an initial state then s2 becomes an initial state of the abstract fts lines .
as mentioned earlier each transition of the form s s1 s negationslash s1 is transformed into a transition s s2 and the new transitionlabelling function primeis modified accordingly lines .
algorithm computation of the preorder based abstraction require an fts s trans i ap l d .
ensure an abstract fts hatwiderfts smaller than fts and such that fts precedesorcurlyfts hatwiderfts fd.
r s1 s2 s1 negationslash s2 s1 precedesorcurlyrchs2 fd whiler negationslash do let s1 s2 r r r s s prime r s s1 s prime s1 s s s1 ifs1 ithen i i s2 s1 end if remove s s prime trans s s1 s prime s1 trans trans remove s s2 s negationslash s1 s s1 remove for alls s s1 s s2 trans do prime s s2 s s1 s s2 end for end while return s trans i ap l d prime v. e valuation this section describes a theoretical evaluation of the algorithms as well as experiments we conducted to evaluate the time and space gain obtained thanks to the abstraction methods.
a. theoretical evaluation at the heart of our method is the computation of the simulation function as specified in section iii b. theorem the time complexity of computing the simulation function is bounded by o s .23n wherenis the number of features.
letkbe the smallest such that j k rk rj.
for i k there is at least one triplet s1 s2 p s s fd such thatp .
consequently k s .2n.
assume we represent each r s1 s2 by a binary decision diagram bdd .
it is at most of size o 2n .
computingri 1is a conjunction or disjunction on pairs of transitions.
these operations are quadratic in the size of the bdd.
thus each step takes trans .22n s .22n.table i verification time of the simulation relation in seconds def.
def.
mbase precedesorcurlyftsmext .
.
mext precedesorcurlyftsmbase .
.
total .
.
to verify if the fixed point has been reached we must determine if for all s1 s2 s s ri s1 s2 ri s1 s2 .
establishing this comes to checking if ri s1 s2 r i s1 s2 is unsatisfiable which is of cost s .22n.
consequently the overall time complexity of computingrftsis bounded byo s .23n .
although it is theoretically dominated by 23n and thus in exptime in practice s 6is often bigger.
b. evaluation of simulation based verification to carry out these experiments we have integrated the computation of the simulation function as well as the three abstractions into our haskell fts library1 which we previously used for benchmarking our ltl model checking algorithms .
it allows us to validate our approach and to measure its efficiency when it comes to computing the simulation relation and reducing both the state space size of an fts and its verification time.
all benchmarks were run on a macbook pro with a ghz core duo processor and gb of ram.
the library was compiled using the glasgow haskell compiler2.
to avoid the influence of other running processes we repeated each experiment times.
our evaluation considers the mine pump controller defined in which we already used in our previous work .
the whole system is designed as the parallel composition of several processes a pump a water sensor a methane sensor and a controller .
the mine pump spl has nine features and products.
the fts modelling its behaviour noted mbase is composed of states and transitions see for a detailed description .
in section iii we introduced two methods for computing the simulation relation for two fts.
the former is based on an enumerative approach and determine for given fts1 andfts2 and each product p iffts1 p precedesorcurlytsfts2 p. the latter makes use of the compact structure of fts and is based on the computation of a fixed point as stated in subsection iii b. our first experiments evaluate the practical efficiency of both methods.
the evaluation considers the minepump system mbase as well as an extension of it.
basically we extended the behavioural options of some of the products by making them able to execute additional transitions.
this results in an extended model noted mext.
then we measured the time acs fts implementations haskell library by both methods to compute mbase precedesorcurlyftsmextand mext precedesorcurlyftsmbase.
benchmarks results are shown in table i. we observe that the algorithm based on definition is far more efficient than the one that enumerates the products and computes the ts simulation of their projection.
in spite of having a worse theoretical time complexity it is .
times faster than the enumerative algorithm.
note that the execution time of the enumerative algorithm includes the time needed for determining the projection of each product which amounts to about of the whole execution time.
c. evaluation of temporal property verification our second evaluation benchmarks the time needed for model checking abstractions combined with either the enumerative approach or fts algorithms.
the objective of the following experiments is to determine which abstraction method is more efficient.
for the former method we evaluate the verification time by enumerating all the products and computing their projection on the original model its ts simulation quotient m similarequalts and the model m precedesorcurlyts obtained by integrating a state s1into another s2iff s1 precedesorcurlytss2.
also we apply the aforementioned abstractions to obtain three abstract fts m similarequalfts m similarequalrch andm precedesorcurlyftsrespectively.
for the latter when a state can be integrated into more than one state our choice is based on the lexicographic order.
for example if we have s1 precedesorcurlyftss2 s1 precedesorcurlyftss3 b d then we integrate s1intos2rather than in s3.
for each fts we first compute the number of states and transitions in order to determine to what extent a given abstraction reduces the size of the original fts.
we observe that the abstraction based on the equivalence classes under similarequalfts yields no reduction at all.
its merging condition is too restrictive in the context of product lines.
since an fts models the behaviour of o 2n products it is very unlikely that two states have exactly the same behavioural options for all those products.
taking into account the reachability already allows to merge states although only a few of them.
the state space size is thus reduced to states and transitions.
finally the third abstraction yields a reduction of about states and transitions .
although these are the best results in terms of state space reduction we must keep in mind that like every efficient state space reduction method it augments the behaviour of the fts.
hence we may find false negatives i.e.products that violate a given property in the abstract fts but not in the original one.
in order to evaluate the impact of the state space reduction on the verification time we model checked the seven models against ten different properties expressed in ltl such as those defined in and .
the results are shown in table ii.
for every formula and every model we give the time needed to verify the model against the formula.
we also describe if the formula is verified by every legal product check or not .
the verification time of every property includes the computation time of the abstractions which represents about of the overall verification time in both cases.
this overhead could be partially avoided if the abstractions are computed once and for all.
we do not present the verification times for m similarequalfts.
since it has as many states and transitions as mbase any difference would be the result of random variations independent of the verification process.
let us first discuss the results for the enumerative and fts approaches separately.
when summing up all the times related to the enumerative approach we observe that the overhead due to the computation of both the abstractions based on ts simulation quotient m similarequalts and preorder m precedesorcurlyts is significant.
because of that the verification times ofm similarequaltsandm precedesorcurlytsare respectively and higher than the model checking time of mbase using the enumerative method.
furthermore false negatives appeared when checking m precedesorcurlytsagainst formula .
this formula is supposed to be satisfied by all products but one of them violates it in m precedesorcurlytsdue to the addition of behaviour.
applying abstraction to fts yields better results.
the abstraction under similarequalrchincreases the checking time of mbase with fts by .
this verification time decreases by whenm precedesorcurlyftsis model checked.
however it has to be noted that false negatives were found for formula .
if we compare these results with the ones of the enumerative methods we conclude that the fts based approaches outperform the enumerative ones.
furthermore applying abstraction to an fts can reduce its verification cost.
on the contrary combining an enumerative method with an abstraction function is inefficient.
although abstraction clearly permits to reduce the verification of an fts we are aware that the gain is not significant.
this illustrates the difficulty to find a good abstraction for fts a formalism that models the behaviours of a potentially large number of systems.
a good abstraction should either add behaviour or remove some but not both.
otherwise we would not be able to infer any property of the system using the verification results of its abstract counterpart since a property may be violated by an additional behaviour or satisfied thanks to the removal of an existing one.
therefore it is particularly difficult to find a state merging condition that both satisfies this requirement and makes a significant reduction.
in particular the purpose of simulation quotient is to eliminate redundancy not to produce coarse abstractions.
more research is required to find ways to design efficient abstraction functions and to finely evaluate their merits with respect to verification performance and false negatives induced by them.
the current abstractions are applied directly on the fts itself.
the most successful applications of abstraction like partial order reduction and statement merging make use of additional information like parallelism and variables scope.
these information are not679table ii verification time of ten ltl formulae in seconds enumerative method formula mbase m similarequaltsm precedesorcurlyts .
.
.
.
check .
check .
check .
.
.
.
check .
check .
check .
check .
check .
.
.
.
.
check .
check .
check .
.
.
.
.
.
.
check .
check .
check total .
.
.1fts algorithms formula mbase m similarequalrchm precedesorcurlyfts .
.
.
.
check .
check .
check .
.
.
.
check .
check .
check .
check .
check .
.
.
.
.
check .
check .
check .
.
.
.
.
.
.
check .
check .
check total .
.
.
found in such a fundamental formalism but instead in highlevel languages.
nevertheless it is interesting to observe that the most important speedups occur during the verification of the most time consuming properties.
this indicates that abstraction can play a role in improving the scalability of spl verification.
naturally this early indication needs to be confirmed by further experiments.
these results combined with previous experiments confirm that fts is a viable approach for verifying variability intensive systems.
d. threats to validity several threats to the validity of our conclusions have to be pointed out.
first our evaluation is solely based on one case.
other systems of different size and variability should be considered in order to analyse how the different approaches scale with the number of features and the size of the state space.
this case study has been implemented in haskell a programming language that makes use of the so called lazy evaluation.
it means that a value is computed only when it is needed.
although this evaluation method may have influenced our results the conclusions would certainly remain valid if we used another programming language.
the comparison between the enumerative methods and the fts algorithms is based on the verification of all the products.
however when a property or a simulation relation is required to hold for the whole spl we could stop the checking process as soon as a bad product is found.
even so this comes to the standard model checking problem and we are interested in identifying all the products that violate a property.
also we obtain the verification times related to the enumerative methods by summing up the verification times for each product individually.
in practice it is very unlikely that those products are verified sequentially without taking advantage of multi threading and parallel verification.finally independent processes running during the experiments might have influenced the results.
however each experiment has been repeated times.
this way the impact of those random variations is drastically reduced.
vi.
r elated work this section briefly describes relevant work related to modelling and verification of spl behaviour.
fischbein et al.
propose modal transition systems mts to model the behaviour of spls .
an mts is a ts where transitions are either mandatory or optional.
the mandatory transitions are available to all products whereas optional ones are specific.
although model checking an mts determines if a property is satisfied by all or only a subset of the products it does not keep track of the decisions made at variation points and it lacks the notion of feature.
therefore it cannot pinpoint exactly the products that violate the property.
asirelli et al.
associate mts with the mhml temporal logic to express constraints on features .
still since they do not have an explicit notion of feature inthe mts they suffer from the same limitations.
sassolas et al.
propose a method to identify inconsistencies between several mts based on traces comparison and a simulation relation.
the inconsistencies are characterised as calculus formulae.
unlike ours their approach is not specific to spl and cannot be used to identify products that cause inconsistencies.
instead of mts larsen et al.
apply i o automata to spl modelling .
in particular they define an spl as the composition of subfamily modelled with an i o automata.
however they do not address spl verification.
lauenroth et al.
define a ctl model checking algorithm for automata labelled with features .
there are two significant differences between their work and ours.
first they do not allow to label transitions with any arbitrary boolean expressions.
second the time complexity of their algorithms are exponential in the state space size and they have not applied state space reduction techniques.680ghezzi and molzam sharifloo verify non functional properties reliability energy consumption ... in spls with probabilistic model checking .
their work is complementary to ours but does not rely on a formal model.
transposing our approach to probabilistic model checking is a promising research perspective.
cassez et al.
make use of the simulation relation for alternating time temporal logic atl to prove the noninteraction of features in reactive systems.
they establish syntactic conditions for a feature to preserve properties.
similarly fisler et al.
krishnamurthi et al.
and li et al.
introduce an approach for compositional modelchecking of collaborations aspects and features.
both the base system i.e.
the system without features and the features are modelled as a finite state machine fsm .
enabling the feature means attaching its fsm to the one of the base system.
they propose algorithms that derive preservation constraints which if satisfied by the feature fsm ensure that a given ctl formula verified in the base system is also satisfied when the feature is enabled.
one limitation is that their features only add transitions and states.
in the same vein liu et al.
propose an alternate algorithm to derive the preservation constraints.
transposed to fts these ideas could open a way for compositional verification of spl.
vii.
c onclusion and future work in this paper we focused on providing theoretical foundations and empirical evidence to apply simulation based model checking to spls.
first we defined a simulation relation for fts a formalism meant to model the behaviour of all the products of a spl.
simulation relations add a significant milestone to spl verification theory being at the center of advanced behavioural analyses such as abstraction behavioural comparison compositional reasoning and more.
the second contribution is the study of simulation quotients for fts which results in several simulation based abstraction methods.
the third contribution is the evaluation of these abstractions for spl model checking.
the main conclusion of our experiments is that the combination of abstraction with the enumerative approach is inefficient.
this corroborates the claims we made in earlier work that spl model checking should be based on fts.
however our experiments also suggest that the application of abstraction to fts model checking only yields marginal efficiency gains.
to obtain more substantial improvements our approach should be extended with other abstraction methods.
counterexample guided abstraction refinement cegar looks particularly promising a coarse abstraction is rapidly and automatically computed and is then refined iteratively using the false negatives found during verification.
as other future work we plan to integrate our results in an spl model checking tool equipped with a high level specification language viz.
snip .
this would allow us to apply other forms of abstraction e.g.
partial orderreduction and statement merging and to evaluate them on larger models including industrial cases.
however it requires to extend definitions such as stutter equivalence to variability intensive models.
apart from abstraction there are many other uses of the simulation function we have defined.
for instance simulation based verification allows one to verify properties modelled as automata.
there are also spl specific uses of our theory.
for instance we can formally characterise the behavioural impact of features in an spl.
let fbe a feature fts resp.fts the fts modelling the behaviour of the products that have resp.
do not have f. then fts precedesorcurlyftsfts gives the products for which fdoes not remove existing behavioural options.
inter spl comparison is also possible.
if we consider two spls having an equal set of legal products the behavioural inconsistencies between them can be highlighted and presented in the form of an automata viz.an fts .
a similar approach for modal transition systems is studied by sassolas et al.
.
moreover we plan to investigate the use of the simulation for compositional reasoning and verification of variabilityintensive systems.
simulation relations are already at the core of existing research on compositional verification in particular for discrete and hybrid systems .
applying similar methods to verify behavioural variability models compositionally is an exciting but difficult challenge considering the numerous possible interactions between features.
finally we will extend the above results as well as our previous work on fts to the modelling and verification of variability intensive real time systems.
analysing the behaviour of such systems requires the definition of models that combine fts with timed automata the development of model checking algorithms for verifying time critical properties on these models and the definition of timed simulation for fts augmented with real time.
more generally this work is part of a larger project that aims to extend the theory methodologies and tools for the behavioural modelling and verification of spl.