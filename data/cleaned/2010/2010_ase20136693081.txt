automated planning for software architecture evolution jeffrey m. barnes ashutosh pandey and david garlan institute for software research carnegie mellon university pittsburgh pa jmbarnes cs.cmu.edu ashutosp cs.cmu.edu garlan cs.cmu.edu abstract in previous research we have developed a theoretical framework to help software architects make better decisions when planning software evolution.
our approach is based on representation and analysis of candidate evolution paths sequences of transitional architectures leading from the current system to a desired target architecture.
one problem with this kind of approach is that it imposes a heavy burden on the software architect who must explicitly define and model these candidate paths.
in this paper we show how automated planning techniques can be used to support automatic generation of evolution paths relieving this burden on the architect.
we illustrate our approach by applying it to a data migration scenario showing how this architecture evolution problem can be translated into a planning problem and solved using existing automated planning tools.
i. i ntroduction software architecture the discipline of designing the highlevel structure of a software system is today widely recognized as an essential element of software engineering.
however one topic that today s approaches to software architecture do not adequately address is software architecture evolution .
architectural change occurs in virtually all software systems of significant size and longevity.
as systems age they often require redesign in order to accommodate new requirements support new technologies or respond to changing market conditions.
at present however software architects have few tools to help them plan and carry out such evolution.
in our previous research we have developed an approach to support architects in reasoning about evolution .
in our model the architect considers a set of candidate evolution paths sequences of transitional architectures leading from the current state to a desired target architecture and a tool helps the architect to select which path best meets the evolution goals.
a significant limitation of this approach and other similar approaches that have been proposed is that they impose a substantial burden on the architect.
the architect must explicitly define the candidate evolution paths and specify the architectural transformations within each such path.
in this way the architect fully defines the evolution space of possible evolutions under consideration permitting various kinds of automated analysis.
however in a scenario with many candidate evolution paths and numerous transitions within each path this can be an onerous task.
a better approach would be to generate these evolution paths automatically.
rather than fully specifying the evolution space the architect could simply define the initial and target architec tures then a tool could select architectural transformations from a predefined library of domain relevant evolution operators and apply them in sequence to generate candidate paths from the initial architecture to the target architecture.
while this would alleviate the burden on the architect it introduces a new difficulty determining how to compose these operators together so as to generate the target architecture from the initial architecture.
given noperators each with mparameters ranging over a domain of darchitectural elements there are ndm levolution paths of length l. clearly an undirected brute force search for an optimal path would be unwise.
this problem is very much akin to the planning problem in artificial intelligence given a description of the state of the world a goal and a set of actions how can we generate a plan a sequence of actions leading from the initial state to the goal?
in this paper we describe our attempt to apply existing approaches and tools from automated planning to the architecture evolution path generation problem.
adapting these existing approaches to software architecture evolution is a difficult problem as it requires consideration of a number of concepts architectural changes technical and business constraints rich temporal relationships among events trade offs among evolution concerns that do not translate easily into the planning domain.
the paper is organized as follows.
section ii presents necessary background on architecture evolution and automated planning.
sections iii through v present our main contributions a systematic approach for translating architecture evolution problems into automated planning problems section iii an application of the approach to a scenario based on a real world evolution problem which we use to evaluate the practicality and efficacy of the approach section iv and a discussion of the fundamental challenges involved in applying automated planning technology to software architecture evolution section v .
finally section vi reviews related work and section vii concludes with a discussion of future work.
ii.
b ackground a. software architecture software architecture is the subdiscipline of software engineering that pertains to the overall structure of a software system.
software architects represent software systems in terms of the high level elements of which they are made.
at a basic level .
c ieee ase palo alto usa213 initial architecturetarget architecturetransitional architectures time fig.
.
a depiction of an evolution graph.
each node is a complete architectural representation of the system.
edges represent possible evolutionary transitions.
the architect s task is to select the optimal path through the graph.
a software architecture can be thought of as an arrangement ofcomponents the computational elements and data stores of a system and connectors interaction pathways among components .
although software architecture is a relatively young field it has grown rapidly in importance and influence.
today software architecture is practiced in some form at nearly all real world software organizations of significant size.
b. software architecture evolution the problem of understanding software architecture evolution however has just begun to be explored.
in recent years we and other researchers have been working to develop techniques and tools for understanding and modeling software architecture evolution .
in this section we describe the approach that we have developed in our own research .
however many other approaches share conceptual similarities with our own and so the general principles that we describe in the following sections are by and large applicable to these other approaches as well.
we discuss this further in section vi a. our approach is based on considering possible evolution paths from the initial architecture of the system as it exists at the outset of the evolution to the target architecture the desired architecture that the system should have when the evolution is complete .
each such evolution path can be represented as a sequence of transitional architectures leading from the initial architecture to the target architecture.
we can represent and relate these evolution paths within an evolution graph whose nodes represent transitional architectures and whose edges represent the possible transitions among them .
these transitions in turn may be understood as sequences of evolution operators reusable architectural transformations such as add adapter ormigrate database .
once the evolution graph is defined the next step is to apply analyses to select the optimal path the one that best meets the evolution goals while adhering to any relevant technical and business constraints and subject to concerns such as cost and duration.
to support the architect in selecting a path we provide two kinds of analysis evolution path constraints which define which paths are legal or permissible and path evaluation functions which provide quantitative assessments of qualities such as duration and cost.
operators and analyses are generally specific to particular domains of evolution for example an evolution of a desktop application to a cloud computing platformwill have different operators and analyses than an evolution of a thin client mainframe system to a tiered web services architecture.
further details are given elsewhere .
here it suffices to observe that while the analysis step i.e.
the execution of constraints and evaluation functions is easily automatable the definition of the evolution graph i.e.
the definition of evolution paths in terms of evolution operators and transitional architectures is a manual and time intensive process.
this limits the practical applicability of this kind of approach since in many cases it may be difficult to justify the time and effort necessary to model the evolution paths under consideration.
c. automated planning given a set of states s a set of actions a s!s an initial states02s and a set of goal states sg s the planning problem is the task of finding a sequence of actions that when applied tos0 yield one of the goal states.1the planning problem has broad applications from robotics to business management to natural language generation and has received a great deal of attention from artificial intelligence researchers.
a variety of approaches and tools for solving planning problems have been developed over the last several decades.
to solve a planning problem a planner must receive a specification of the problem in a standard format.
a number of specification languages for planning problems have been devised but by far the most popular the lingua franca of automated planning is the planning domain description language.
pddl was first introduced in and soon became a de facto standard in the planning literature facilitating reuse of research and allowing easy comparison of planners systems and models .
these qualities along with its feature set make pddl a good choice for our work.
pddl has undergone several revisions.
the version that we adopt in this paper is pddl2.
introduced in which greatly enhanced the language s expressivity by introducing numeric fluents which provided full support for modeling numerically valued resources such as fuel and distance durative actions which greatly enriched the temporal expressiveness of the language and plan metrics which allowed specification of a metric with respect to which a plan should be optimized e.g.
minimize fuel consumption .
all three of these are extremely useful for modeling architecture evolution problems as we will see later .
most of pddl2.
is now reasonably well supported by the leading planners.
there have subsequently been further additions to the language such as the introduction of derived predicates in pddl2.
and constraints and preferences in pddl3 .
while these features would certainly be useful to us they are not as broadly supported by planners so we chose to target pddl2.
.
1this is a very abstract formulation of the planning problem.
for a discussion of alternative definitions including some that are more computationally oriented see ghallab et al.
.214d.
structure of a pddl specification a pddl specification comprises two parts which appear in separate files a domain description consisting chiefly of a description of possible actions that characterize domain behaviors and a problem description consisting of the description of specific objects initial conditions and goals that characterize a problem instance .
thus a domain description can be shared across multiple planning problems in the same domain.
both the domain file and the problem file are expressed in a lisp like syntax as a list of parenthesized declarations.
in pddl2.
a domain file can declare a set of types to which objects may belong.
each type may optionally declare a supertype.
if a type does not declare a supertype it is deemed to be a subtype of the built in type object all types are ultimately subtypes of object perhaps indirectly .
a type is simply a name it does not define a set of properties or methods.
rather predicates functions and actions can specify the types that they govern.
a set of predicates over objects.
a set of functions that map objectn!r.
a set of action schemata each comprising a list of parameters the conditions under which the action may be taken and the effects of the action.
a durative action additionally specifies its duration.
a problem file declares a list of objects .
the initial conditions consisting of truth assignments for predicates and numeric value assignments for functions.
thegoals which are defined in first order predicate logic.
ametric to be minimized or maximized.
a planner takes a domain description and problem description as input and produces a plan as output a timed list of actions with parameters specified that achieves the specified goals.
iii.
a pproach the problem of generating an evolution path from an initial architecture to a target architecture can be framed as a planning problem in the sense of section ii c as follows s the set of states is defined to be the set of legal software architectures.
a the set of actions is defined to be the set of evolution operators.
s0 the initial state is defined to be the initial architecture.
sg the set of goal states is defined to be the singleton set consisting of the target architecture of the system.
with the problem framed in this manner we can apply automated planning tools to the task of generating evolution paths.
in the remainder of this section we will describe an approach for translating an architecture evolution problem into a planning problem expressed in pddl.
a summary appears in table i. in section iv we will make this discussion concrete by showing how we applied it to a specific architecture evolution problem and used off the shelf planners to generate evolution paths.table i summary of ourapproach for translating elements of an architecture evolution problem into pddl evolution element pddl translation transitional architecture state architectural element type object type architectural element object relationship among architectural elementspredicate evolution operator action parameter action parameter precondition action condition architectural transformation action effect property action duration or action effect modifying function value evolution path plan initial architecture initial state target architecture goal state path constraint pddl3 constraint or action condition supported by predicates to track the state path evaluation function metric a. representing the initial and target architectures the first step of modeling an architecture evolution problem is to specify the initial and target architectures.
as noted in section ii a a software architecture is conventionally conceived as an arrangement of components andconnectors .
of course this is a simplification.
architectural specifications may be enriched in various ways for example by adding further elements such as ports and roles or by decomposing architectural elements to reveal their substructure.
we will see an example of architectural decomposition in section iv.
these components and connectors are often expressed in terms of component types such as webservice ordatabase and connector types such as eventbus orhttpconnection .
pddl s type system though simple is quite adequate for our needs.
we can define component and connector types as types in the pddl domain description then define the components and connectors themselves as pddl objects of the defined types.
finally the relationships among the components and connectors can be expressed using predicates which are defined in the domain description and assigned truth values in the problem description.
fig.
shows a simple example.
the specification of the initial architecture will appear within the init block which defines the initial conditions and the specification of the target architecture will appear within the goal block which defines the goals.
b. representing evolution operators an evolution operator of course corresponds to a pddl action.
but how can we actually capture an evolution operator as an action using the specification facilities that pddl provides?
in our model of architecture evolution an operator comprises a set of parameters .
for example a wrap legacy component operator will take as a parameter the component to wrap.
in pddl an action likewise specifies its parameters.
a description of the architectural transformations that the operator effects.
these are expressed as a sequence of elementary architectural changes such as delete component215client1 server1httpconn1domain description types component connector object client server component httpconnection connector predicates connects ?c connector ?a ?b component problem description objects httpconn1 httpconnection client1 client server1 server init connects httpconn1 client1 server1 fig.
.
an extremely simple software architecture and its pddl representation.
orattach connector .
in pddl we can represent these transformations via the action s effects.
a description of the operator s preconditions .
these map into pddl in a straightforward manner in pddl any action may declare its preconditions in terms of predicates and functions over the action parameters.
a list of properties of the operator used to support evaluation functions.
examples of properties are the time needed to carry out the operator the cost of so and the operator s effects on system performance.
in pddl the duration property is given special prominence due to its importance in temporal reasoning a durative action must specify its duration.
as for the other properties these are best captured via pddl effects.
for example if an evolution operator has a cost property indicating that it costs we can define a cost function in the pddl specification then add anincrease cost effect to the action.
one subtlety worth noting is that pddl does not permit actions to create new objects nor destroy existing ones .
this is significant because many evolutions entail the creation of new architectural elements or the decommissioning of existing ones.
as a result in an evolution that may involve creation of new elements we must declare some potential objects that do not exist in the initial architecture but may be used to stand in for elements created during the evolution.
in this case we can define anisreal predicate that is false for such potential objects and becomes true when an action creates a new architectural element out of a potential object.
such approaches have substantial limitations and are rather cumbersome and frank et al.
identify this as an important limitation of pddl.
a related point is that a pddl specification can have only finitely many objects while the set of software architectures reachable via a set of evolution operations may be infinite in general.
c. representing path constraints path constraints are perhaps the most challenging element of an architecture evolution problem to translate into pddl.
2for durative actions this is generalized to include other kinds of conditions not only preconditions conditions that must hold at the start of an action but also conditions that must hold at the end of an action or over its entire duration.
these are specified with the temporal annotations at start at end and over all .
these can also be applied to effects.
in our previous work we have represented path constraints using an extension of linear temporal logic ltl .
temporal logic provides a natural way of representing a wide variety of path constraints.
for example a constraint such as the legacy bus must not be removed until the new enterprise service bus is installed can be quite simply represented in ltl by the formula legacybuspresentuesbinstalled where legacybuspresent andesbinstalled are predicates over architectural models.
unfortunately pddl2.
does not have any means to define constraints using temporal formulas.
one way of addressing this would be to develop a way of translating temporal formulas into pddl directly.
indeed there is previous work in this direction cresswell coddington present a means of compiling an ltl goal formula into pddl.
they use a two step process first they generate a finite state machine that accepts traces of the ltl formula then they encode this automaton as a collection of facts in pddl and modify the actions to track the current state.
this process is conceptually complex and encumbers the specification with numerous state variables.
therefore we leave to future work the challenge of extending this compilation process to the augmented version of ltl that we use to capture path constraints.
to avoid such conceptual complexities here we take a pragmatic approach we characterize certain restricted classes of path constraints with an eye toward the kinds of constraints that will arise in the example of section iv and show how they can be easily represented using the existing facilities of pddl.
constraints that must hold throughout an evolution.
the simplest possible kind of constraint is one that must hold continuously through the entire duration of the evolution e.g.
a system must always be protected by a firewall or a trusted component may never connect directly to an untrusted one .
in ltl such a constraint takes the form for some propositional formula .
despite their simplicity these constraints are quite common.
such a constraint amounts to an architectural constraint that persists through an evolution.
in pddl we can model such a constraint easily if verbosely as a condition on every action.
ordering constraints.
another common class of constraints comprises constraints that govern the order of the operations that are to be carried out in the course of an evolution.
for example a firewall must be installed before connections to a protected resource are permitted a high priority client should receive a service upgrade before a low priority one.
such constraints are also generally easy to model in pddl.
if an operator bmust be preceded by an operator a then we can have action aset a predicate aexecuted that is a precondition for operator b. timing constraints.
constraints on the time at which evolution operations are carried out or the time by which certain goals must be achieved are extremely common in real world evolution.
in the simplest case there may be a requirement that the evolution be completed by a specific date.
in more complex cases there may be a set of such requirements feature a must be available for client by april feature b for client by july 216and so on.
these can be modeled in pddl by setting appropriate conditions on durative actions.
a more complex kind of timing constraint is a constraint that certain actions can be performed only at certain times.
a realworld example is that many retailers such as amazon.com and costco refrain from making major software changes during the christmas shopping season so as not to introduce bugs during a period of heavy use.
in section iv we will see another example in which certain operations can be carried out only on certain days of the week.
these are also expressible in pddl.
there are some challenges however which we explore in section iv.
there are many constraints that do not fit into these categories but in our experience many of the constraints that arise in realworld evolutions do fall into these groups.
in section iv we will see how various constraints can be represented in pddl.
a final point to note is that pddl3 has its own notion of a constraint.
like our constraints pddl3 constraints express conditions that must be met by an entire plan in contrast with conditions in pddl2.
which are evaluated locally with respect to a particular point in time .
moreover these constraints are expressed in a syntax reminiscent of temporal logic with operators such as always sometime at most once and so on.
however there are substantial restrictions most significantly these modalities may not be nested.
as a result this constraint language is less expressive than ltl.
nonetheless pddl3 constraints would be a useful way of expressing a broad class of evolution path constraints.
however because we are targeting pddl2.
here we do not discuss them further.
d. representing path evaluation functions as described earlier an evaluation function provides a quantitative evaluation of a path.
there may be evaluation functions for various dimensions of concern such as cost and availability.
ultimately the architect s aim is to select the path that best meets the goals of the evolution.
in an evolution with multiple competing concerns we can define an evaluation function that captures a notion of overall path utility which may be a weighted composite of primitive functions such as cost and availability.
all of this can be translated into pddl.
evaluation functions such as cost and availability can be modeled as nullary functions in pddl and their values can be modified by actions as appropriate.
finally we can use these values to set a plan metric in the problem description which planners will try to optimize in generating a plan.
this metric can simply be a reference to a function or it can be an arbitrary arithmetic expression.
the metric can also incorporate the total duration of the plan by using the built in variable total time .
iv.
a pplication to show how this approach can be used in practice and to provide a demonstration of its applicability we applied it to an evolution scenario.
the scenario is based loosely on a real world data migration experience that we had previously elicited for other purposes from a practicing software engineer.
we elaborated this experience into a complete description of an architecture evolution problem so that it would be specificenough to operationalize as a planning problem section iv a .
then using the approach described above we translated this scenario into pddl sections iv b through iv f .3finally we used two different off the shelf planners to generate plans and evaluated the results section iv g .
a. evolution scenario our example is based loosely on a real world data migration scenario in which a company had to migrate a number of services from an old data center to a new data center.
the planning for this migration was nontrivial because there were a number of interacting constraints governing how the various services had to be moved.
for example different services had different kinds of availability requirements.
for example some services had to be continuously available for regulatory reasons zero planned downtime .
in other cases there were periods when certain services were required to be online e.g.
the payroll system had to be online at the end of each payroll period .
different services had to be moved in different ways.
some services particularly those hosted on unix systems could be easily cloned into the new data center using the corporate storage area network.
other services were more finicky and could not be cloned automatically manual intervention was required to migrate these services.
and there were a few unique legacy services that were running on custom built special purpose hardware.
these services were so closely tied to the machines on which they were running that the only practical way to migrate them was to load the machines onto a truck and drive them to the new data center.
no services could be established in the new data center until a firewall was installed there.
in the real world experience on which our scenario was based the architects experienced significant difficulty in managing these interacting constraints to develop a satisfactory plan.
the planning process ultimately took roughly six months and the migration itself was carried out over several weekends.
we elaborated this scenario by adding additional architectural details as necessary to create a complete specification of an architecture evolution problem.
for example although we had general information about the kinds of architectural elements and evolution constraints we did not have a list of specific service names and locations so we invented fictitious service names and assigned them to hosts at will.
the initial architecture is shown in fig.
.
there are five hosts in data center dc1 each with one or more services all of which must ultimately be migrated to dc2.
we defined a number of specific evolution constraints based on the realworld constraints above.
for example we specified that the payroll service in fig.
must be available on mondays to permit payroll processing and we defined rules governing how the services could be moved e.g.
unix services can be cloned to 3space constraints permit us to show only snippets of our pddl specification here.
however for the sake of replicability we have made our entire specification available at internetpayrollservice accountingservice financehost win safetydbservice safetydbhost unix analyticsservice analyticshost win clientwebsiteservice1 clientwebsiteservice2 clientwebsitehost1 unix clientwebsiteservice3 clientwebsiteservice4 clientwebsitehost2 unix dc1 empty dc2 service host data centernetwork connectionkey fig.
.
deployment view of the initial architecture of the data migration scenario.
a new data center over the network but the analytics engine is tied to special purpose hardware that must be physically relocated .
we defined six evolution operators install network switch install firewall decommission host clone host manually transfer service and physically relocate host .
finally we defined two ways of evaluating path quality cost and duration.
cost is affected by when and how systems are migrated migrating a system on weekends is more expensive than during normal working hours and physically moving a host is much more expensive than cloning a host over the network .
duration refers to the overall time to complete the evolution.
b. representing the initial and target architectures we represented the initial architecture following the approach described in section iii.
in the domain description we defined pddl types for the architectural element types datacenter service and host with subtypes unixhost andwindowshost .
we defined predicates to indicate relationships among elements such as an is in predicate that holds when a given host is in a given data center and an is on predicate that holds when a given service is on a given host.
with these types and predicates defined we were able to translate the initial architecture in fig.
into a pddl description of the initial state.
representing the target architecture as a set of goal conditions on the other hand entails some subtleties.
in principle we could define the target architecture by the same method that we defined the initial architecture specify exactly which services are on which hosts and which hosts are in which data center.
in practice however this would be a bit too restrictive.
because services can be migrated in multiple ways cloning manual service by service migration or physical relocation there are actually multiple legal end states.
for example we could clone clientwebsitehost1 onto a new host in dc2 anddecommission clientwebsitehost1 or we could instead move clientwebsitehost1 itself to dc2.
these would result in slightly different end states but either is permissible from the standpoint of path correctness the choice should be left to the planner.
thus we defined the goals of the evolution in more general terms we defined a permissible end state to be one in which all services end up in dc2 and no hosts remain in dc1.
in principle these goals are easy to represent in pddl goal and all services end up in dc2.
forall ?s service exists ?h host and is on ?s ?h is in ?h dc2 no hosts remain in dc1.
not exists ?h host is in ?h dc1 unfortunately practical considerations prevent such a straightforward approach.
many planners including the optic planner that we use in section iv g do not support goals with negative or existential operators.
to get around this we defined helper predicates such as was migrated to indicate that a service has been migrated and was removed from to indicate that a host has been removed from a data center and modified the actions to update them throughout the evolution.
we then declared our goals as follows goal and all services end up in dc2.
forall ?s service was migrated ?s no hosts remain in dc1.
was removed from clientwebsitehost1 dc1 was removed from clientwebsitehost2 dc1 was removed from safetydbhost dc1 was removed from financehost dc1 was removed from analyticshost dc1 this complicated the domain description but it allowed us to express our goals crisply despite the limitations of planners.
c. representing the evolution operators we represented the operators as actions in accordance with the approach described in section iii.
fig.
shows an example the action for manual migration of a service from one host to another.
much of this is straightforward.
the action first defines its parameters the service being migrated the hosts it is moving from and to and the current day we will explain this parameter in section iv d .
then it defines its duration .
hours.
many of its conditions correspond directly to preconditions of the evolution operator.
for example to migrate a service s from hosth1to hosth2 clearlysmust be onh1at the outset.
we also require that h1is in dc1 and h2is in dc2 we only want to move services from dc1 to dc2 and we require that the firewall and network switch are already installed.
the conditions that reference no work in progress today and time since last day are used in modeling the passage of time which we describe in section iv d. many of the effects are straightforward specifications of the evolution operator s architectural transformations.
when themanuallymigrateservice operator is applied the effect on the architecture is that service sis now on host h2.
we218 durative action manuallymigrateservice parameters ?s service ?h1 ?h2 host ?d day duration ?duration .
condition and at start is on ?s ?h1 over all is in ?h1 dc1 over all is in ?h2 dc2 over all has firewall dc2 over all network switch installed at start not yet migrated ?s over all can be migrated individually ?s over all ok to move on ?s ?d at start no work in progress over all today ?d over all allowed downtime ?s .
at start time since last day .
effect and at end is on ?s ?h2 at end was migrated ?s at end not not yet migrated ?s at end not is unused ?h2 at start not no work in progress at end no work in progress at start increase total cost cost multiplier ?d at end increase current hour .
at end increase time since last day .
fig.
.
expression of an evolution operator in pddl.
also must set here a number of helper predicates as mentioned in section iv b such as was migrated not yet migrated andis unused .
the effects that mention no work in progress current hour and time since last day are used to support the modeling of the passage of time and will be discussed in section iv d .
finally the effect that increases total cost is used for cost optimization described in section iv f. d. representing time the most difficult part of representing this scenario in pddl was capturing its temporal aspects.
the temporal features that pddl provides fall well short of this scenario s needs.
in particular this scenario like many evolution problems is steeped in