checking conformance ofa producer and a consumer evandriscoll amandaburton andthomasreps computer sciences department university of wisconsin mad ison driscoll burtona reps wisc.edu abstract this paper addresses the problem of identifying incompatibilities between two programs that operate in a producer consumer relationship.
it describes the techniques that are incorporated in a tool called pcca producerconsumer conformance analyzer which attempts to i determine whether the consumer is prepared to accept all messages that the producer can emit or ii find a counterexample a message that the producer can emit and the consumer considers ill formed.
categories andsubjectdescriptors d. .
interoperability generalterms algorithms reliability keywords producer consumer compatibility language containment visibly pushdown automata .
introduction complex systems today are made up of many communicating components.
for instance a modern fuel injected engine has a number of sensors that send their current measurementstotheengine controlunit whichdecideswhatth e optimum fuel air mixture should be.
it emits messages to other components such as the fuel pumps and fuel injectors to carry out its decisions.
supported by nsf under grants ccf ccf cc f0904371 and ccf by onr under grants n00014 m by arl under grant w911nf and by afrl under grants fa9550 and fa8650 c .
any opinions findings and conclusions or recommendations exp ressed in this material are those of the author s and do not necessari ly reflect the views of the sponsoring agencies.
permission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bearthisnoticeandthefullcitationonthefirstpage.
tocop yotherwise to republish topostonserversortoredistributetolists re quirespriorspecific permission and orafee.
esec fse september5 szeged hungary.
copyright2011acm ... .
.in such systems it is vitally important to ensure that the messages that one component sends to another are understood by the receiving component otherwise runtime errors will occur.
send receive incompatibilities can drive up th e cost of developing a system because different components of asystemareoftendevelopedbydifferentdevelopmentteams or different subcontractors and thus compatibility proble ms may not be detected until integration time.
the cost of fixing errors found late in the development process is usually much higher than that of errors found earlier.
consider an example system made up of the producer and consumer shown in figs.
and respectively.
the producer is a program that monitors a sensor and periodically sends a packet of data to the consumer.1the system uses an abbreviated protocol if the sensor data has not changed since the last message then only the boolean literal false is sent.
line in fig.
makes this decision.
as presented these components are correct both speak the same protocol.
however consider a buggy version of the consumer that does not account for the possibility that the producer sends an abbreviated message and always expects the full packet.
this code is shown in fig.
.
to find this bug can we reason about the languages over which each component operates?
in the consumer we know that theupdatereading function always reads a doubleand then abool.
furthermore each time through the loop in the buggy version of main the consumer reads a boolthen the double boolsequence from updatereading .
thus we can determine that the input language of the buggy consumer expressed as a regular expression over types that the consumer reads is bool double bool .
similarly we can determine that the output language of the producer expressed as a regular expression is bool bool double bool .
from these two language descriptions we can see that one of the components is buggy the string bool bool is in the producer s language but not in the consumer s. this disparity suggests that some execution of the producer could output two boolean values but noexecution of the consumer would expect to read that message.
a similar analysis suggests that fig.
s consumer is correct.
the language it expects is bool double bool ?
which is equivalent to what we inferred for the producer.
wedescribeatechniquefordeterminingwhethertwocomponents are compatible which proceeds along lines similar to this example we infer a model of the output language of the producer infer a model of the input language of the 1we use packetto refer to the data that the components communicate each time through their loop .
sendreading sensor device int prev if device setting prev then writebool false else writebool true writedouble device setting writebool device valid loop sensor device int prev ... update device with new readings 10sendreading device prev if ...then loop device device setting main 14sensordevice 15loop device figure example producer updatereading int setting bool valid setting readdouble valid readbool main int setting bool valid while ...do if readbool then updatereading setting valid ... do something with current readings figure example consumer consumer and determine whether the two descriptions are compatible.
however we also investigate using a richer fam ily of languages than just regular languages for the format descriptions and thus the check of whether the models are compatible is more than straight language containment.
this paper addresses the following problem given two programs that operate in a producer consumer relationship i determine whether the consumer is prepared to accept all messages that the producer can emit or ii find a counterexample a message that the producer can emit but the consumer considers ill formed.
we have implemented our technique in a tool called pcca forproducer consumer conformance analyzer .
given the two source programs along with information about which functions perform i o see .
pccainfers a description of the language that the producer generates and a description of the language that the consumer expects and roughly speaking determines whether the former is a subset of the latter.
pccastarts out by creating an automaton pthat models the producer which accepts an over approximation of the language that the producer emits.
we have two versions of pcca one creates a pushdown automaton pda and the other creates a standard finite automaton fa .
similarly pccaproduces an automaton cfor the consumer which accepts an over approximation of the language that the consumer expects.
our goal becomes determining whether l p l c .
for the fa version we do this directly.
for the pda version this question is undecidable with a direct1 main while ...do readbool updatereading setting valid ... do something with current readings figure example buggy consumer.
updatereading is the same as in fig.
.
approach thus we actually use a restricted form of pdas calledvisibly pushdown automata vpas to model the components behaviors.
while less powerful than full pdas vpas provide enough power to recognize important classes of non regular languages such as balanced parentheses.
unlike pdas the restrictions on vpas allow them to retain closure under complementation and intersection and thus language containment is decidable.
however when using vpas we must make internal calls and returns explicit in thewordsofthelanguagesthat pccainfersfromthecomponents.
if pccawere to check containment of these languages directly we would be requiring that the two components have the same internal call return structure which is undesirable.
to compensate pcca enriches the consumer s vpac and hence its language l c so that differences in the call return structures of the producer and the consumer do not preclude answering the language containment question.
this step is explained in more detail in .
.
to test language containment pccaperforms a setdifference operation to compute l p integerdividel c for the fa version or l p integerdividel enrich c for the vpa version by complementingtherighthandautomatonintersectingthere sult with p. finally it tests whether the language of the vpa produced by the intersection is empty.
if so then the subset holds and pccareports the components are compatible if not then there is a counter example in the difference andpccareports the components are incompatible.
the techniques used in pccaare transport agnostic as long as the producer and the consumer use a stream like interface to communicate.
that is pccacan analyze a pair of programs or even the sameprogram playing the roles of both producer and consumer that share files send information over sockets or use standard i o. because it is necessary to approximate each component s language the technique we have developed has some limitations.
both approximations are over approximations i.e.
the producer s model may say that the producer can emit a string that can never actually be emitted by the producer and similarly for the consumer.
consequently the compatibility checking technique can have both false positives and false negatives which puts pccaamong other bug hunting approaches such as work developed by engler et al.
as well as many other authors.
our contributions can be summarized as follows we describe our approach to format inference inspired by lim et al.
and its application to component compatibility.
the model of the program can be described using a context free language but testing language containment for cfls is not decidable.
we describe how to side step this problem by using vpas making the internalcallsandreturnsofthecomponentsexplicit and performing our enrich operation.m main entry l loop entry sendentry sendexit loopexit mainexit an bracketle t m an bracketle t l bool double bool an bracketri ht l an bracketri ht m an bracketle t l an bracketri ht l an bracketri ht l an bracketri ht l an bracketri ht m figure the producer s vpa.
to reduce clutter all transitions to the implicit stuck state are omitted and sendreading is abbreviated as send.
we compare the results of a vpa based model to those obtained by using ordinary finite automata.
we describe a new algorithm for determining the emptyness of a vpa which builds on existing work related to pushdown systems.
we implemented our techniques in a tool called pcca and demonstrate its utility on several examples.
organization.
the remainder of the paper is organized as follows discusses our goals and the methods we use to achieve them.
discusses the indiv steps that that make up our technique when pccais operating using vpas.
describes the prototype implementation.
presents experimental results.
discusses related work.
has a brief discussion of future work.
.
overview wenowgiveadescriptionofourtechnique framedaround how it operates on the example considered in the introduction.
we first consider the producer and the correct version of the consumer as presented in figs.
and respectively.
ex.
.
covers the buggy version of the consumer.
from the standpoint of checking that the producer and consumer are compatible even this simplified example has a number of challenging features.
in particular .
the producer s loopprocedure uses recursion instead of iteration.
in contrast the consumer is more straightforward it reads values in a loop.
.
the calls to the write functions in the producer and the read functions in the consumer are organized differently.
the producer calls all the write functions from the same procedure while the consumer reads the second two fields double bool in a different procedure from the one in which it reads the first bool .
pccais provided the information that the read and write functions are special in that they perform i o in .
we discuss how this information can be supplied.
as mentioned earlier pccais able to use two different formalisms to model the components visibly pushdown automata vpa and standard finite automata fa .
.
visibly pushdownautomata from each component we infer a visibly pushdown automaton when operating in that mode.
vpas are a re m main entry m main exit updatereading exit updatereading entrybool an bracketle t m double bool an bracketri ht mbool figure the consumer s vpa.
striction of ordinary pushdown automata and can be used in program analysis to capture the matched call and return structure of execution traces through multi procedure programs.
in essense each alphabet symbol describes whether a vpa is allowed to push or pop a symbol from its stack.
we formally define vpas in .
but for purposes of this section it suffices to know that even though they share some power with general pdas determining language containment of two vpas remains decidable in contrast to pdas.
in our application the alphabet consists of the types that are emitted by the producer and read by the consumer as well as distinguished call and return symbols an bracketle tand an bracketri ht.
for expository purposes we talk about the producer automaton emitting strings.
neither fas nor vpas actually emit anything except a yes no answer what we mean is that a given string is accepted by the producer s automaton.
however if a string is accepted by the producer s automaton that means it could be emitted by the producer program and it is often convenient to think of the automata as being the components themselves rather than models.
.
inferringthe i oformat the first step in the process is to infer an automaton that approximates the language of each component.
in the case of the producer we wish to infer the language of all possible outputs in the case of the consumer we wish to infer the language of all expected inputs.
the idea behind our technique is to create automata that mimic the control flow behavior of the source programs.
eachautomatonthat pccagenerateshasthesamelanguage as one created by transliterating the program s interproce dural control flow graph icfg in the following manner .
there is one state cfor each icfg node c. .
if a call site ccan call an i o function that outputs or expects a value of type we add a transition on from cto its corresponding return node.
in the vpa model this transition does not modify the stack.
.
if a call site ccan call a non i o function fwith entry nodefeand exit node fx we add one transition from cto feand a second transition from fxto the corresponding return site.
in the fa model both transitions are transitions.
in the vpa model the first transition is on the symbol an bracketle tand pushes conto the vpa s stack and the second transition is on the symbol an bracketri htunder the condition that cis at the top of the stack which is then popped .
.
allothertransitionsintheicfgbecome transitions.
in the vpa version these do not modify the stack.
.
the entry node of main becomes the start state and the exit node becomes the sole accepting state.
however if we used this naive translation the result ing automata would be extremely large which would cause problems during the determinization phase of pcca.
instead of treating the icfg as a whole pccaproceeds procedure by procedurethrough the program.
for each procedure it looks at the intraprocedural cfg and carries out the above translation except that step is replaced by the following if a call site ccan call a non i o function f we add an internal transition from cto the corresponding return labeled with a generated symbol call f. also the vpa s starting and accepting states are the entry and exit nodes of that procedure.
even in the vpa version because each procedure s automation has no transitions that modify the stack stack operations only happen on a call or return it can be interpreted as a standard finite state machine.
we do this and use the standard algorithms to determinize and minimize each procedure s machine.
pcca s implementation uses the openfst library for this purpose .
the efficiency upshot is that this technique turns what would be a multiplicative factor into an additive one thus dramatica lly reducing the time spent in determinization.
once we have the collection of minimized automata we combine all the automata into one and restore the call and return transitions.
we replace each transition that moves from state ctorwhen reading a symbol call fwith a pair of transitions that match those in the original step we add a transition from ctof s entry point.
in the fa version this is an transition in the vpa version it is on the symbol an bracketle tand pushes conto the stack.
weaddatransitionfromtheexitpointof ftor.
inthe fa version this is an transition in the vpa version it is on the symbol an bracketri htand requires that cappears at the top of the stack which is then popped .
finally we have to perform one more determinization step in case connecting the procedures adds nondeterminism.
this translation essentially abstracts the program to its controlflow only data is not considered.
one could envision a higher fidelity translation that weaves selected data ele ments or abstractions of data elements into the automata we infer but of course there is a trade off between precision and automaton size.
figs.
and show the vpas that are inferred from the codeinfigs.1and2 respectively.
toreduceclutter figs .
and have transitions collapsed which removes states and a comparablenumber of transitionsin each automaton.
call transitions have labels of the form an bracketle t x where xis the state at the source of the transition and xmeans that xis pushed onto the call stack.
return transitions have labels of the form an bracketri ht x which means that the machine can make the transition only if state xis on the top of the stack in so it pops x. the fa version is similar except that all call and return transitions are replaced with transitions.
knowledgeabouti ofunctions.
pccaneeds information aboutwhatfunctioncallscanperformi o.thereareanumber of ways the user can provide such information see .
.
one important point is that there needs to be agreement between the producer and consumer regarding what types 2as shown in determinization dominates execution time.are used.
the first and easiest issue related to this point i s that the names of the types must agree.
the second issue is that the granularity of the i o function specifications must agree.
consider our example.
as written both the producer and consumer have i o operations expressed in terms of their constituent c types.
it would also be possible to have the producer and consumer store values in a two element structure sensordata and do a bulk read write with fread fwrite to operate on the struct as a whole.
in such a case it would be reasonable to say that the type of that i o operation was sensordata .
however the two approaches cannot be mixed the consumer and producer need to agree on the granularity.
remark .
the need for agreement between the producer and consumer on the granularity of types is not a fundamental limitation it would be possible to have the user specify thatsensordata is a double bool struct at either the format inference stage or after the vpas are constructed and it should even be possible to extract this information from struct definitions in the code.
we have not investigated these avenues at this point however with the current implementation the user has the ability to specify for example that a particular call to fread fwriteoperates on a doubleand then a bool.
.
enrichingthe consumer svpa this section applies to the vpa version of pccaonly .
describes the operation formally.
it would be too restrictive to demand that the producer and consumer perform calls and returns at corresponding moments during their executions.
the vpas that we infer from the producer and consumer follow the same call return behavior as the original programs thus the strings in the languages of the producer and consumer models contain internal call and return symbols that are not actually present in the messages between components.
checking containment of the languages of the inferred models would require that the components agree in this respect.
our running example illustrates the issue.
each packet consists of a boolean optionally followed by a double and a boolean.
the producer sends the entire packet within one function sendreading but the consumer reads the first boolean and then calls another function updatereading to read the remaining values of the packet.
the consequence of the producer and consumer having different calling structure is that the substrings that correspond to the same packet are different in the producer s language and the consumer s language.
example .
consider the string bool double bool emitted by fig.
s code when the producer performs just one iteration hence the string contains just a single packet.
f or the producer s vpa the string would be an bracketle t an bracketle tbool double bool an bracketri ht an bracketri ht while for the consumer s vpa the corresponding string would be bool an bracketle tdouble bool an bracketri ht.
these strings have an bracketle tand an bracketri htin different locations.
to accommodate the different nesting structures we enrich the consumer s vpa so that it can use nondeterminism to guess when the producer makes an internal call or return and insert the corresponding symbol into its own strings.
example .
for the example discussed in ex.
.
the languageoftheconsumer senrichedvpacontainsnotjust bool an bracketle tdouble bool an bracketri htbut also an bracketle t an bracketle tbool double bool an bracketri ht an bracketri ht.
the latter string is in the languages of both the producer s vpa and the consumer s enriched vpa.
after enrichment a counterexample to the language containment and an indication of incompatibility is a string that the producer s nwa can emit where it is impossible to add and or remove balanced parentheses and arrive at a string that the consumer s nwa accepts.
example .
for the buggy consumer in fig.
the original language contains strings such as bool an bracketle tdouble bool an bracketri ht but not for instance bool bool which is in the producer s vpa s language .
denote by cethe vpa inferred for the buggy consumer.
no matter how you add parentheses to bool bool you will not arrive at a string in the language of enrich ce this will be a counterexample to language containment.
if an analyst knows that both components use the same call returnstructure he can omit the enrichmentstep to ob tain a more precise comparison of the two languages.
without the approximation caused by enrich a compatible result is more credible however if there is uncertainty in th e call return assumption an incompatible result is less c redible.
.
language containment once we have the producer automaton pand the consumer automaton c for the vpa version c is the enriched consumer automaton determining the set difference and thus containment of their languages is straightforwar d l p integerdividel c iffl p l c .
both fas and vpas are closed under all of these operations so all that is necessary is to take c complement it intersect it with p and test the resulting vpa for emptiness.
discusses this step in greater detail for vpas.
.
helping pccaimproveits results we now return to the running example to illustrate how the programmer could improve the results of the analysis.
we start by describinga bug that pccawould not be able to find and then explain how to modify the code but without changing the actual protocol so that the bug isfound.
suppose that the specification of the protocol changed during development the final boolfield was not originally needed but was added later.
suppose that the implementation of the producer waschanged to emit this field but the consumer was not updated.
in other words line in fig.
was added at the time the specification changed.
the consumer shouldhave been changed to add line in fig.
but that line was erroneously omitted.
this situation would almost certainly signify a bug but it would notbe detected by our tool.
the reason is that there is no association between the function call on lines and in the producer which writes the first boolin each packet and line in the consumer which reads it.
instead the consumer could use the call on readbool on line to consume the final field of the previous packet then not call updatereading during that iteration.
we can modify the source code of the producer and consumer to make it possible for our technique to detect the previous bug.
the problem that our technique has with detecting this bug is that what the producer and consumerthoughtwerepacketsgotoutofsync.
byinsertinga phony i o call at the start or end of each loop e.g.
in the ellipsis on line of the producer and between lines and in the consumer we can make the packet divisions visible topcca allowing it to check that the producer s and consumer s packets cannot get out of sync.
the phony calls would have a type that does not appear in the packet itself in our experiments we have called it sep. the key point to realize is that this type does not have to have any material presence in any of the communications and in fact the function that performs the phony i o can be completely empty.
this idea can be generalized to hijack the compatibility algorithm to ensure that eventsthat should occur during the execution of the producer and consumer occur in the proper order.
from this point of view a write operation is essentially an event during which the fact that the program communicates is only incidental.
.
formalization of vpa based containment checking thissectiondiscussesthedetailsofhowpccadetermines whethertheproducer slanguageis asubsetofthe enriched consumer s when using visibly pushdown automata vpas .
using vpas provides a potential benefit over fas see .
butintroducesanumberofcomplicationstotheprocessthat are not present with standard finite automata.
.
visiblypushdownautomata definition .
a vpa is a pushdown automaton pda that operates on a tagged alphabet and whose stack accesses are restricted by the current symbol.
a tagged alphabet is a partition of a normal alphabet into disjoint subsets c and r. in our application c an bracketle t r an bracketri ht and is the set of types on which the program being analyzed operates.
in program analysis pairs of symbols in cand rare often used to model program calls and returns they can also be used to represent other matched entities such as opening and closing xml tags.
avisibly pushdown automaton vis a tuple q q0 f where qis the set of states is a tagged alphabet is the stack alphabet with a special bottom of stack symbol and integerdivide q0 qis the initial state and f qis the set of final states.
the transition relation is the union of three components i q q c q c q r q r q a vpamreads its input and makes transitions on each symbol as follows.
if the current symbol is the current state isq and is at the top of the stack then if then mselects a transition q q from iand changes its control state to q .
if c mselects a transition q q from c pushes onto its stack and changes to state q .
if r mselects a transition q q from r pops from its stack and changes to state q .
the vpa accepts its input if there is a run that ends in a final state f f. the behavior above can be expressed as limiting the operation of a standard pda in the following way when reading the vpa cannot access the stack when reading c c the vpa must push exactly one symbol and when reading r r the vpa must pop exactly one symbol.
in this way the vpa s stack accesses are visible in each input.
we refer to the asinternal symbols the c c and the positions in a string at which they appear as calls and r r and their positions as returns .
we take qand construct vpas that when in state qwith a call as the current symbol push qonto the stack.
we also allow internal transitions in the natural way.
.
enrichment as discussed at a high level in .
it is unreasonable to demand that the producer and consumer have the same call return structure so we introduce an enriching oper ation denoted by enrich that when applied to the consumer s vpa will relax the requirement.
enrich creates new transitions in the consumer s vpa that allow it to make arbitrary calls and returns.
in essence this allows the con sumer s vpa to emulate the call returnstructureof the producer s vpa.
enrich is defined as follows definition .
given vpa a q q0 f augment with the following transitions .
for every state p introduce a call transition c p an bracketle t p .
.
for every pair of states p q introduce a return transition r p q an bracketri ht p .
.
for every call transition c p an bracketle t q in the original vpa introduce a transition i p q .
.
for every return transition r p p an bracketri ht q in the original vpa introduce a transition i p q .
items and allow the consumer s enriched vpa to perform extra call or return moves to emulate the producer vpa while items and allow the consumer s enriched vpa to omit calls or returns in case the producer has fewer.
example .
the example discussed in exs.
.
and .
requires all four steps to match the producer the consumer needs to add two calls to the beginning of the input string add two matching returns to the end of the input string and remove the extra call between the first bool and double and its corresponding return.
while in theory it is possibleeither to enrich the consumer to match the producer or enrich the producer to match the consumer in practice only the former is reasonable.
the goal of the containment check is to determine the emptiness l p integerdividel c .
enriching a vpa enlarges its language so this operation adds some error eto one of the operands resulting in either l p e integerdividel c orl p integerdivide l c e .
unfortunately the error introduced by enriching the producer s vpa invariably leads to false positives for the consumer to accept everything that the enriched producer emits the consumer would have to accept every possible call structure of every string the producer emits.
.
benefitsof usingvpas there are several kinds of automata that we could have chosen.
for instance the fa version of pccamodels each 3following this restriction is called a weaklyhierarchical vpa and does not reduce the expressiveness.
outputint 2writeint producermain if ...then outputint else writechar outputint writechar inputint1 9readint inputint2 11readint consumermain if ...then inputint1 else readchar inputint2 readchar figure components that illustrate the benefits of vpas program as a single finite automaton.
this approach removes the need for the enrich operation because calls and returns are not represented explicitly in the languages.
the trade offs between vpas and fas mirror trade offs that one can make in traditional interprocedural dataflow analysis.
the simplest way of performing such analysis is to build the icfg and run the analysis as if call and return edges were just normal intraprocedural control flow edges.
however that approach loses precision because of suprious data flows from one call site c1 into the called function f and then out the return edge to a different call site c2.
a similarkindofimprecisioncanaffectthefaversionof pcca.
for instance fig.
shows a producer and consumer for which fas and vpas produce different results.
due to space constraints we omit diagrams of the inferred automata.
the fa version of pccainfersint char int char for the language of the consumer but int char int int char char int char for the producer.
the producer s language contains two words that are not in the language of the consumer thus the fa version of pccareports that the components are incompatible.
one way of getting around this problem is to perform function inlining each call site cgets its own copy of the procedure f which is only called from cand only returns toc.
this eliminates the suprious control flows but at the cost of a potentially exponentially larger model.
it would be possible to do exactly the same thing in our domain create a single fsm but inline procedures.
a more sophisticated mechanism for eliminating these spurious flows uses context free language reachability tec hniques .
this marks each call return edge pair with a distinct set of matched parentheses possible executions of the program correspond only to strings with matched parentheses.
thedataflowproblemcanbeformulatedsothatonly flows along such well matched paths are considered.
our use of vpas closely mirrors this approach for the producer.
4cfl reachability distinguishes acceptable return edges from unacceptable ones by whether the brackets match our vpas distinguish them by whether the corresponding call site is on the vpa s stack.the code in fig.
benefits from this increase in precision.
the vpa s constraints on the return transitions from the exit node of outputint to each of the two return sites restricts the data flow thus the producer s language is inferr ed to be an bracketle tint an bracketri ht char an bracketle tint an bracketri htchar.
the vpa version of pcca reports that the two components are compatible.
unfortunately this benefit only applies to the producer s model the enrich operation we do to the consumer essentially makes a regular approximation out of the original.
we have not investigated applying the ideas of inlining to obtai n increased precision although we think it would be possible .
in other words using vpas to model the components provides a way to obtain a context sensitive analysis in one of the components without the exponential blowup of inlining.
.
complementandintersection as mentioned in .
determining the set difference of the producer vpa and the enriched consumer vpa is straightforward l p integerdividel enrich c iffl p l enrich c and vpas support all of the required operations.
.
checkingemptiness although other algorithms are known even for general pdas for completeness we describe a new algorithm that we devised which harnesses previously known operations for answering reachability queries on pushdown systems pdss .
our approach is purely automata theoretic and does not translate the vpa language to a context free grammar.
we can use the witness tracing feature supported by the pds reachability operation post to trace nonemptiness answers back to a string that is in the producer s vpa s language but not in the consumer s such a string suggests a potential bug in one of the components.
to describe the algorithm it is necessary to review some known results about pdss .
definition .
apushdown system pds is a threetuplep p where pis a finite set of control locations is a finite set of stack symbols and p p is a finite set of rules.
aconfiguration ofpis a pair an bracketle tp u an bracketri htwherep pandu .
a rule r is written as an bracketle tp an bracketri ht an bracketle tp u an bracketri ht wherep p p and u .
the rules define a transition relations on configurations of pas follows if r an bracketle tp an bracketri ht an bracketle tp u an bracketri ht then an bracketle tp u an bracketri ht an bracketle tp u u an bracketri htfor allu .
because the number of configurations of a pds is unbounded it is useful to use finite automata to describe certain infinite sets of configurations.
definition .
aconfiguration automaton that defines a language of configurations of pds p p is a finitestate automaton c s p f where sis a finite set of states cusesp s set of stack symbols as its alphabet s sis the transition relation the set of initial states consists of p s set of control locations p which must be a subset of s andf sis the set of final states.
we say that a configuration an bracketle tp u an bracketri htisaccepted by configuration automaton cifccan accept u in the ordinary sense from the theory of finite state automata when it is started in the statep that is pu s where s f. a set of configurations is said to be regular if some configuration automaton accepts it.
2let denote the reflexive transitive closure of .
for a set of configurations c pre p c def c c c c c andpost p c def c c c c c i.e.
backward and forward reachability respectively with respect to tr ansition relation .
when cis a regular language of configurations automata for the configuration languages pre p c andpost p c can be constructed by algorithms that run in time polynomial in the size of p .
given a vpa a the first step of checking whether l a is to convert ato a pds pa. definition .
given vpa a q q q f we define pds pa s q where each transition of ais converted to one or two rules in as follows for each transition q q has a rule an bracketle ts q an bracketri ht an bracketle ts q an bracketri ht.
for each transition q c q has a rule an bracketle ts q an bracketri ht an bracketle ts q q an bracketri ht.
this pushes q onto the stack the top of which is currently q. for each transition q r q has two rules an bracketle ts q an bracketri ht an bracketle tsx an bracketri htand an bracketle tsx an bracketri ht an bracketle ts q an bracketri ht.
conceptually this can be thought of as a single transition an bracketle ts q an bracketri ht an bracketle ts q an bracketri htof a prefix rewriting system .
one can interpret this conversion as simply moving the information in the vpa s finite control into the top symbol of the stack.
in our application the initial state of the producer s vpa ismainentry and the only final state is mainexit.
assuming that mainis never invoked recursively we only consider perfectly matched strings those with balanced calls and re turns and whether the set of perfectly matched strings is empty.
to test this condition we create trivial configuratio n automata for the languages of initial state and final state configurations where the machine has an empty stack l initialconfigurations an bracketle ts q0 an bracketri ht an bracketle ts mainentry an bracketri ht l finalconfigurations an bracketle ts f an bracketri ht f f an bracketle ts mainexit an bracketri ht we can check whether the set of perfectly matched strings is empty by answering the question of whether there is a path in the transition relation from a configuration in l initialconfigurations to a configuration in l finalconfigurations .
one way to answer this question is to check whether the language of the finite state automaton constructed as follows is empty finalconfigurations post pa initialconfigurations .
this reduces the question of vpa emptiness to emptiness of the language of an ordinary fa.
remark .
the more general question of vpa emptiness when non perfectly matched strings are of interest can also be addressed using eqn.
one merely has to use more elaborate languages of initial and final configurations.
.
implementation this section describes a prototype implementation of the ideaspresentedin 2and 3inatoolcalled pcca producerconsumer conformance analyzer .
pccahastwophases inferenceandcompatibility.
during the inference phase pccauses codesurfer c to per form pointer analysis and build an interprocedural controlflow graph icfg and call graph for each component.
it traverses the icfg to create a list of all call sites that directly call an i o function see .
then traverses the call graph to determine which procedures to prune see .
.
it then traverses the icfg again to create the automaton for each procedure as described in .
minimizes each of them and combines them into our model of the program.
during the compatibility phase pccareads the automaton produced for each component and proceeds with the compatibility check according to pcca s mode.
for the vpa mode pccaactually uses a formalism called nestedword automata nwas instead of vpas buteach is essentially an alternative expression of the other .
we use an extension to the wali library that implements nwas .
.
seedingthe systemwith i o functions pccarequires information about i what function calls of the producer can perform output and ii what function callsoftheconsumercanperforminput.
thereareanumber of ways such information can be supplied to pcca .
theusercanprovidealistofi ofunctions e.g.
readboolean writeint as in the example and their associated types.
for calls to standard functions such as puts pccais already equipped with such mappings.
.
for calls to printf orscanf style procedures if the format string is a constantin the code pccawill parse the string to determine the types being operated on.
the implementation is flexible enough so that the producer or consumer can contain user defined procedures with printf scanf like format strings provided that the format string syntax is either the same as what is used by printfor what is used by scanf.
pccajust needs to know the name of the procedure and which formal parameter holds the format string.
.
if all else fails the user can supply comments that annotate procedure call sites to specify that a particular call site performs either input or output.
the annotation includes the type that is operated on.
this method also allows the user to selectively choose only some call sites to a particular procedure.
.
finally the list of procedure call sites that the tool should consider to be i o functions is explicitly materialized in a text file so the user can add remove or change call sites in that list or even generate it by different means.
in fact in the current version of pcca the techniques described in items and are implemented by one program and the technique described in item is implemented by a second program.
.
removingirrelevantprocedures to reduce the size of the inferred vpa pccaprunes procedures that cannot possibly participate in i o operations .
if there is no path from the entry of procedure pto the exit of procedure palong which an i o procedure is invoked p can be discounted entirely.
one of the first steps of pccais to traverse the call graph generated by codesurfer determine which procedures can transitively call an i o function and ignore all others.
as illustrated in columns and of fig.
see the effect of pruning is substantial reducing the number of procedures by as much as .
.
experiments to test the capabilities of pcca we ran it on a small corpus of examples whose characteristics are listed in columns and of fig.
.
the experiments were run on a system with dual quad core .27ghz xeon e5520s processors however pccais entirely single threaded.
the system has gb of memory and runs red hat enterprise linux .
the experiments were designed to test whether pcca would detect bugs in producer consumer pairs that were buggy correctly identify presumably correct code as having the language containment property and scale to realis tic programs.
we also compared the results between the fa and vpa based modes of operation to determine whether the potential benefits discussed in .
arose.
each example consisted of a pair of programs a producer and a consumer.
in several cases we used the program as both the producer and the consumer which makes sense for programs that read and write the same format.
the examples are as follows ex prod ex consmake up our running example stubs for the i o functions are included in the count ex prod ex cons fig3 usesthebuggyversionoftheconsumer presented in fig.
ex prod .
ex cons .5are buggy versions of the running example modified as described at the end of .
with the separator to mark the packets gzipandbzip2are the common unix compression decompression utilities gzip fixed uses a modified version of gzip discussed below to eliminate an erroneous report png2ico is an image conversion program which we compare to a hand written specification.
reported times are the median of runs.
the numbers for the fa version use nwas with no call or return transitions.
this gives an apples to apples comparison wi th nwas but is slower than an alternative implementation that converts each nwa to an openfst acceptor determinizes with openfst and converts back.
all times are less than sec.
with the latter approach.
there isan intrinsic cost to using an nwa representation but we feel that most of the difference between our fa numbers and openfst s indicates room for improving the wali implementation.
that would improve the nwa version as well.
we also performed an informal experiment using the vpa versionwithoutenrich asmentionedattheendof .
.
we tested programs that read and write trees in infix and prefix notation.
both the standard vpa version of pccaand the no enrich version reported that the infix components are compatible with each other that the prefix components are compatible with each other and that each is incompatible with the other.
as discussed in .
the compatibility results are more credible for the no enrich version the incompatibilityresultsaremorecredibleforthestandardvp a version.
omitting the enrich step also dramatically decreased determinization time even the gzip fix cons could be determinized in less than one second.
thus it might be beneficial to try to combine enrichment and determinization.
two of the tests gzipandpng2ico required relatively minor modifications.
gzipuses input and output operations 5our experiments can be found at edu wpis examples pcca funcs infervpa version sec.
fa version sec.
test loc orig.
pruned q i o aut.
c total ok?
c total ok?
ex prod .
.
.
y .
.
y ex cons .
ex prod .
.
.
n .
.
n ex cons fig3 .
ex prod .
.
.
.
n .
.
n ex cons .
.
gzip prod .
n n gzip cons .
gzip prod .
y y gzip fix cons .
bzip2 prod .
.
y .
y bzip2 cons .
png2ico prod .
.
.
y .
.
y ico spec cons n a n a n a n a figure the experiments.
loc is lines of code orig.
is the number of functions in the program pruned is that number after pruning.
q is the number of states in the inferred automaton equal betw een the two variants .
i o is the static number of calls to i o functions.
infer aut.
is the time sec.
to produce the automata for every procedure in the program.
th e output of this step is used for both the vpa and fa versions.
for both the vpa and fa version c is the time sec.
to determinize and complement the automaton.
determinizing each procedure s fa is not inclu ded in this time but takes a negligible amount of time in all experiments.
total is the end to end time f or analysis including the inference step.
ok?
reports the output of pcca.
muchlikethoseinourrunningexample exceptimplemented as macros.
because pccauses the control flow graph generated by codesurfer c these macros are not visible so we replaced the macro definitions with functions.
in addition gzipcalls the function that actually performs the compression or decompression through a function pointer.
codesurfer c performs points to analysis but pccadoes not yet take such indirect calls into account thus we modified the source to call the function directly.
this is not a fundamental limitation of our technique though imprecise pointer analysis could lead to further imprecision.
a final modification that applies in a similar manner to both gzip andpng2ico will be described in their respective sections.
as shown in fig.
pccareports that some commonlyused programs operate in a correct manner with regard to their i o behavior regardless of the automaton model used.
pccaalso detects synthetic programming errors in small examples as shown by the second pair of examples.
as can be seen in the results the potential vpa benefits did not appear to affect the results of the analysis.
pcca does report different results for the example in .
but we do not include that experiment in fig.
.
this result surprised us and in the future we plan to look at additional examples to see whether any of them benefit from vpas.
gzip.the analysis of gzipreported a erroneous bug in the distributed version we examine the issues more closely here .
forgzip the actual compressed data appears as just a sequenceofbytes sothecompatibilitycheckessentiallyistes ting the compatibility of the code that reads and writes the header and footer.
fig.
describes the header format of a gzipfile.
the code that writes this header in zip.c corresponds very closely to the header format put byte gzip magic magic header put byte gzip magic put byte deflated compression method ... put byte flags general flags put long time stamp ... put byte uch deflate flags extra flags put byte os code for this code pccainfers the format specified in fig.
.
however the code that readsthe header is reported to be incompatible this is a false positive.
unlike the output functions input is always done one byte at a time stamp ulg get byte stamp ulg get byte stamp ulg get byte stamp ulg get byte because the consumer reads the time stamp field as four bytes instead of one long it appears incompatible.
this is similar to the issue of granularity of types discussed in .
.
to address this we replaced this code and similar code that reads longfields in the footer with a new get long function.
this function can be implemented in terms of four bytewise reads as long as pccais told that get long performsi o pccawillrecognizethecallasreadinga long.
in addition to helping pcca we feel that the modified code is cleaner by having the code for reading and writing a longin one place it is easier for the programmer to see that those functions agree for instance by reading and writing the bytes in the same order.
it should even be possible to use our techniques to perform this check as well by giving different types to each byte in the long.
aftermakingthischange pccareportsthattheprograms are compatible.
it is unclear why there is such a dramatic difference between the time it takes to determinize each version of the consumer in the vpa version.
the input vpas are of almost identical size and makeup but it appears that the extra longalphabet symbol in the revised version causesid1 id2 cm flg mtime xfl os ... id1 id2 fixed constants gzip s magic number cm compression algorithm flg flags as a bitmap mtime the modification time of the original file xfl compression method specific flags os id of the os where the file was compressed figure the specification of gzip s header format.
each field is byte except for mtime which is .
the determinized vpa to be much bigger states vs. .
note that neither of these automata are minimal it could be that the extra size in the revised version could be reduced to be more in line with the original version.
the sizes of the two automata in the fa version are much closer.
png2ico.
forpng2ico we demonstrate a slightly different application of our techniques.
instead of comparing a producer to a consumer we compare a producer to a manuallycrafted specification acting as the consumer.
this checks that the producer emits only messages that are allowed by the specification.
in the case of png2ico we see that the program indeed appears to conform to the specification.
we manually crafted an automaton that describes the format of an icon file and used that as the consumer.
for the ico format this was reasonably straightforward and took less than two hours.
the automaton allows pccato check header information similar to gzipbut with a much richer format.
an icon file can hold several different images.
in addition to a global header that mainly says how many images there are there is a directory that gives the offset and other information about each image and a header for the image data itself.
we can check all of this leaving only the raw image data itself appearing as a meaningless byte stream.
we cannot check that the image headers actually appear at the correct offsets however.
while most of the output from png2ico is done through the functions writebyte writeword andwritedword there are three places where a raw write is done using fwrite.
two of these locations write a sequence of raw bytes of an image to the file.
we could reasonably infer just byte for those calls similar to how the actual compressed data comes across in gzip however we decided to put in a bit of extra effort to obtain higher confidence in the result.
the two fwritecalls correspond to the xor mask and and mask of the bitmap.
we manually specified that the first fwrite call outputs xor mask bytes and the second call outputs and mask bytes and required that each bitmap in the icon file contains a sequence of xor mask bytes followed by a sequence of and mask bytes.
however there is one call towritebyte amongst those writing the xor mask so we had to manually change the type of that call to match that of the preceding fwrite.
we repeated the experiment but just used byte andpccastill reported compatibility.
the third call to fwriteis used instead of a sequence of fourwritebyte calls the reason the author choose this is not clear.
we replaced this fwritewith the four individual writebyte calls.
in the future we hope to implement theability to automatically break apart a write such as this to make such manual intervention unnecessary.
we only report the results for the version with specific types.
the other variants we tried did not have much effect.
.
relatedwork inferring input or output formats of programs.
pcca s format inference techniques as well as the problem in general was inspired by the file format extractor tool ffe by lim et al.
.
ffe infers output models of x86 executables using a weighted pushdown system.
we skip the wpds step performing the procedure discussed in .
instead.
the minimization we perform on each procedure s model gets us the benefits intended by ffe s use of wpdss and produces far smaller automata.
inferring input formats of executables has received much attention lately particularly in the context of protocol re verse engineering for network security .
however most of this work involves the use of dynamicanalysis techniques.
komondoor and ramalingam developed methods to recover an object oriented data model from a program written in weakly typed languages such as cobol .
it is capable of recovering information about the record structure of entities that occur in a file as well as information about subtyping relationships between such entities.
checking compatibility conformance.
rajamani and rehof developed a way to check that an implementation modeliextractedfromamessage passingprogramconforms to a specification s. their goal was to support modular reasoning they established that if iconforms to sandpis any environment in which pandscannot starve waiting to send or receive messages then pandialso cannot starve.
a related question is checking conformance of software components as software evolves and components are replaced or upgraded.
clarke et al.
survey several approaches that have been devised to answer the question including interface automata behavioral subtyping input output based compatibility of upgrades and model checking.
there have also been many papers on session types starting with .
in some sense this body of work has the same goal that we have helping to ensure that different components communicate properly but their approach is far different.
session types at a high level convey much the same information as our inferred languages.
for instance in the syntax of int char double is the type of a componentthat emits an intfollowed by either acharordouble.
some recent work e.g.
is integrating session types into common programming languages.
in most of this literature session types need to be incorporated into the language being used to write the components which means they cannot be applied to legacy software without rewriting it.
in contrast to these papers our work analyzes existing c c code for compatibility by inferring the format.
in return for this re engineering sess ion types support richer interactions than we currently do most notably it can specify bidirectional communications.
recently there have been advances in inferring session types which is much closer to our goal.
mezzina andcollingbourne and kelly each developed such an algorithm.
collingbourne s is particularly related as they im plemented their technique in a source to source translator for c .
however neither paper really gives enough information on how it performs in practice to compare to pcca.
in a similar vein and actually of equivalent power are channel contracts from the singularity os .
channel contracts specify a protocol between two endpoints as a state machine where each state specifies messages that each endpoint can send or receive.
f ahndrich et al.
describe an analysis that verifies certain memory safety properties in programs that use channel contracts.
more recent work has analyzed channel contracts with respect to deadlocks and developed formal type theories for channels .
.
futurework wehaveanumberofextensionstothebasicideadescribed in this paper in mind we describe two of them here.
the discussionin this paperis framed from thepointof view that the vpa alphabet consists of the actual programming language types used by the programs.
however our approach is more flexible.
it is possible to have even finer granularity types.
to do this we would use types that do not correspond to those in c. for instance it would be possible to have anint ascii symbol for an integer expressed in ascii digits e.g.
the three byte sequence and int bin for an integer in binary e.g.
the four bytes 0x000000ff .
.
described how a particular way of using a phony i o call to helppccadetect bugs this idea expands that technique.
it should also be possible to extend our work to include information about the valuesthat are read or written for instance to specify that write int outputs a or that write int outputs a value in the range and similarly for the input operations of the consumer .
this would require a change to the compatibility portion as well.
second therearesomeengineeringtasksthatshouldmake it easier to get more helpful results.
for example we can implement the technique mentioned in the remark at the end of .
where we make it possible to break apart automatically a structure or array type into its component fields.
this would allow the producer and consumer to use data structures that are organized differently from one another but have the same semantic meaning and would avoid the most invasive changes we had to make in our experiments.
.