assigning time budgets to component functions in the design of time critical automotive systems ernest wozniak cea list france and mcgill university canada ernest.wozniak cea.frmarco di natale scuola superiore sant anna italy marco sssup.ithaibo zeng mcgill university canada haibo.zeng mcgill.ca chokri mraidha cea list france chokri.mraidha cea.frsara tucci piergiovanni cea list france sara.tucci cea.frs bastien g rard cea list france sebastien.gerard cea.fr abstract the adoption of autosar and model driven engineering mde for the design of automotive software architectures allows an early analysis of system properties and the automatic synthesis of architecture and software implementation.
to select and con gure the architecture with respect to timing constraints knowledge about the worst case execution times wcet of functions is required.
an accurate evaluation of the wcet is only possible when reusing legacy functionality or very late in the development and procurement process.
to drive the integration of sw components belonging to systems with timing constraints automotive methodologies propose to assign wcet budgets to functions.
this paper presents two solutions to assign budgets while considering at the same time the problem of sw hw synthesis.
the rst solution is a one step algorithm.
the second is an iterative improvement procedure with a staged approach that scales better to very large size systems.
both methods are evaluated on industrial systems to study their e ectiveness and scalability.
keywords design design space exploration real time end to end deadlines time budgeting autosar optimization genetic algorithm .
introduction vehicles are today very complex high technology products with an increasing number of software features.
this evolution is not matched by quality and speed improvements in the software development processes.
the autosar automotive standard has been de ned to improve the design and integration of automotive sw components.
the autosar methodology makes use of model driven engineering principles mde i.e.
the use of models as basic permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
blocks for software and hardware description in a top down process in which the top most level consists of the speci cation of a platform independent software architecture application components and their connections and a separate hardware model de ning the network of nodes and buses .
in a re nement process the functional components are mapped to the hardware nodes generating the node con guration and the de nition of the os tasks.
the result of the mapping is the application deployment i.e.
a set of communicating tasks running on the nodes and communicating through messages sent on buses.
the autosar methodology is de ned according to the typical automotive supply chain process.
the integrator car maker has control over the functional architecture design at the system level and selects the execution platform including the distributed hw architecture and the basic sw rtos middleware drivers .
the integrator de nes the sw components that are needed for the implementation of the functionality and sends the autosar specications of their interfaces and behaviors to the suppliers.
starting from version .
timing constraints become part of the autosar standard .
this requires the integrator to validate the correctness of the architecture solution with respect to time constraints end to end deadlines and de ne the partitioned timing constraints that apply to the component speci cations for the suppliers .
the validation of timing properties during the development is a continuous process.
since re nements are topdown deadlines can only be validated under assumptions abstracting the lower level details such as the worst case execution times wcets of functions.
in autosar functions are called runnables and represent the atomic executable entities de ning the internal behavior of components.
an application deployment is valid if and only if the set of tasks that execute the runnables is schedulable.
unless the implementation of runnables is re used from previous systems precise knowledge of wcets of runnables is not available before code implementation in the design process.
to de ne a system architecture supporting functions with time constraints and provide the speci cation of its components to the suppliers automotive developers and domain experts propose a time budgeting activity as part of the development methodology.
the system integrator speci es and assigns time budgets.
these time budgets areconstraints on worst case execution time that must be respected by the suppliers delivering the component imple235 mentation .
if all the delivered components ful ll their local constraints the end to end deadlines are satis ed.
in the meantime based on the budget assumptions the system integrator can synthesize and optimize an architecture con guration.
.
related work the problem of de ning time budgets for components and runnables is similar to the issue of end to end deadline partitioning.
several research works have investigated the option of partitioning the end to end deadline into time windows or intermediate deadlines upon the assumption that the interaction model allows the composition of the local response times to compute end to end response times.
a graph based algorithm for deadline partitioning to maximize the minimum slack is presented in and an approach for periodic processes in .
more recently deadline partitioning schemes for transaction chains scheduled under edf or xed priority can be found in .
other e orts have been speci cally tailored to automotive architectures.
the timmo use project discusses the need for time budgeting in the context of the process stages dedicated to the re nement of the system architecture.
the project deliverables discuss a set of guidelines for budgeting the worst case response times wcrts based on the designer experience and do not provide a speci c algorithm.
scheickl et al.
considers a similar process in which the de nition of the wcrt budgets is based on the experience of the designer.
similarly wcrts are budgeted in with a discussion on how di erent activation patterns event or time driven in uence the speci cation of time budgets.
nevertheless as in the previous two works the approach relies on the experience of the designer.
the methodology of partitioning deadlines on response times is more suitable to the concept of federated automotive architectures when suppliers provide hardware units or ecus with operating systems and tasks or at the very least when the responsibility of the task design is delegated to the suppliers.
in the new concept of integrated architecture enabled by autosar the de nition of the tasks and the design of the hardware architecture pertains to the integrator.
therefore budgeting should be performed at the level of the wcet of the runnables.
the concept of time budgeting in the integration of automotive systems is among the research topics of the all times project .
the approach proposed in the project deliverables takes as an input an already deployed architecture i.e.
the software components are already assigned to tasks and mapped onto the hardware platform.
since wcets are not known the deployment choices assumed as predetermined and not subject to optimization could very well be suboptimal and a ect the nal result the assigned budgets .
in the budgeting problem is formulated and solved by applying parametric linear temporal logic pltl .
a method is presented to automatically decompose end to end deadlines into a set of time budgets.
the authors automatically compute a set of linear constraints for which they nally nd a valuation using a solver that guarantees all deadlines and maximizes the values of the time budgets.
the proposed solution also integrates the consideration of non functional properties related to the ecu utilization .
as in all previous works the authors assume that the deployment i.e.
the integration of the software architecturewith the hardware platform and the design of the task is already known.
in addition the deployment choices could not have been done in a qualitative way as wcets for certain runnables were missing.
.
our contributions in this paper we incorporate the problem of budgeting worst case execution times in the design optimization.
all the other works budget the worst case response time which does not t well to the idea of the integrated architecture as supported by the autosar.
di erent from previous work on wcet budgeting we assume that the function deployment is not known in advance.
accordingly our objective is to jointly nd the deployment of functions and the optimal assignment of time budgets given a functional autosar model with end to end timing constraints and an execution hardware os platform.
since time budgeting and deployment are both np hard problems our solutions consists of two heuristic approaches based on evolutionary algorithms.
the rst provides a holistic one step solution to the problem whereas the second divides it into two subproblems solved one after the other.
on the other hand as shown in the experiments due to the scalability issues it is impractical to employ the time budgeting algorithm as speci ed in with our algorithm exploring the deployment.
the paper is organized as follows section formalizes the model and problem considered by the approach section details the proposed technique for time budgeting and section presents its improvement in a form of staged approach section gives experimental evaluation results nally section sketches some future work and concludes the paper.
.
formalism this section starts by introducing basic de nitions and assumptions on the system model.
then the time budgeting problem is formalized together with constraints on timing and deployment.
.
system model the input system model matches the modeling abstractions in autosar.
the autosar functional model consists of a set of components.
each component has a set ofrunnables de ning its functional behavior and cooperating by exchanging data and synchronization signals over ports.
of the possible interaction models allowed by autosar we focus on a model of synchronous transactions in which runnables exchange activation signals in a linear sequence.
in addition even if they are extremely important in the supply process and as an abstraction mechanism in the context of our analysis components are only containers of runnables and are therefore omitted.
we assume the runnable interaction model is represented as a system level graph.
ge fve eeg in which ve fr1 r2 rngis the set of vertices representing the runnables andee fs1 s2 smgis the set of edges or links between them representing data signals.
the length of a data signalsiis denoted as lsi in number of bits .
the set of transactions is f lg.
each transaction is an ordered interleaving sequence of runnables and signals i e.g.
from the runnable reading sensor data to the runnable communicating with the actuator .
src i ri1is the transaction source and snk i rikits sink.
the function ri returns the trans236action to which ribelongs.
we assume that transactions are linear and the activation pattern is event triggered i.e.
each transaction is triggered by a periodic event of period p i. this event is then propagated by the runnables starting from thesrc i through their communication links each connection carries an activation event together with the associated data signal .
the response time of the transaction iisr iand its deadline d i. figure shows an example model based on the cruise control case study from .
ms limp home diagnosisswc5 swc6 2 d 2 input acquisitionapplicationswc1 swc2 swc3 swc4 function controller11 d speed inputconditionbasic20 ms interpretationsetpoint figure an example of linear transactions for a cruise control theexecution platform is represented by an undirected graphgh fvh ehg.
nodes are computing resources or ecus vh fe1 e2 esgand edges represent the communication links buses between them eh fb1 b2 bpg.
the function e bi returns the set of ecus connected to bi.
runnables are partitioned in two sets.
rw is the set of legacy runnables that are simply reused and for which an estimate of the wcets on the available ecus is known.
rbis the set of runnables under development for which a budget assignment must be provided.
the wcet of a generic runnable ribelonging to rw is represented as a vector cri cri cri cri n where cri kis the wcet of riwhen executed on ek.
the execution time budget of a runnable ribelonging to rbis denoted as tbri.
we also denote the set of all time budgets astb ftbri tbrj tbrkg.
in the deployed architecture represented with the code of each runnable entity executes in a context of an os task.t f tgis the set of tasks.
similarly the signal needs to be transmitted in one of the messages m fm1 m2 mug if the communication is between runnables mapped to di erent ecus otherwise it is considered as local communication.
the function ri returns the task on which runnable riis partitioned and m si the message transmitting the signal si.
the function e ri returns the ecu on which riis allocated whereas b si is the bus through which siis sent.
tasks and messages are assumed to be scheduled according to a xed priority mechanism or transmitted in the order of their priority respectively.
the automotive standards e.g.
autosar os and controller area network can are signi cant examples of such policies.
the priority of a task i messagemi is denoted as i. considering the possible bit stu ng of the can protocol the worst case transmission time wctt of a message mi is calculated as cmi g 8lmi g 8lmi bit wheregis the number of protocol bits subject to bit stu ng g for standard format with bit identi ers or g 54for extended format with bit identi ers lmiis the data length of the message bytes unit and bitis the transmission time for a single bit.
the data length of message mi is the least integer number of bytes between and that is greater than the sum of the data signals packed in mi lmi p sj m sj milsi figure shows one possible partitioning of runnables into tasks and assignment of tasks onto ecus for the functional model of figure .
the index of a task represents its priority lower value means higher priority .
in the gure some signals exchanged between runnables are mapped onto messages e.g.
the one between speed setpoint and application condition .
can bus3 5input20 ms interpretation msbody controller ecu diagnosis engine management ecu limp home basic function conditionapplication controller speed setpointinput acquisition 1 figure example of a deployment con guration for a cruise control .
problem formulation the problem tackled in this work consists of four subproblems.
placement of runnables on execution nodes and signals on buses assigning values to e ri andb si .
partitioning i.e.
the de nition of the operating system tasks set t and messages set m and the mapping function that assigns runnables and signals to them.
scheduling i.e.
assignment of priorities to tasks and messages.
time budgeting i.e.
the de nition of the time budget values i.e.
nding tbrifor eachri2rb.
these four problems have signi cant cross dependencies.
ideally they should be solved as an integral problem but this could be very challenging in terms of the computational e ort that is required.
alternatively the problem can be solved in stages with the possibility of early choices restricting the set of available decisions for later stages.
in our work we try to lessen this problem by wrapping the staged solution in an iteration loop in which the rst stage is performed several times trying to improve on the results of the previous cycle.
.
deployment constraints in order for the placement partitioning and scheduling to be correct several constraints need to be respected to guarantee the functional correctness of the deployed architecture.
we list them according to their purpose without a formal description which is straightforward for all of them .
placement constraints resources utilization de ning a maximum capacity utilization for all execution nodes and buses each runnable signal can be placed only on one ecu bus xed placement the placement of selected runnables is constrained to a subset of all ecus e.g.
a runnable responsible for collecting sensor data can be placed only on ecus linked to that sensor software compo237nents constraint all the runnables of the same atomic software component need to be placed on the same ecu each global signal i.e.
communicated between two runnables mapped on di erent ecus must be transmitted over a bus connecting the ecus where its sender and receiver runnables tasks are allocated.
partitioning constraints harmonic rate two runnables signals with non harmonic periods pri prj primod prj6 cannot be partitioned in the same task message.
the period of a runnable prior signalpsiequals the period of a transition to which runnable signal belongs.
functional partitioning each runnable must be partitioned exactly in one task.
likewise each global signal must be partitioned in one message.
scheduling constraints local order tasks messages allocated on the same ecu bus must be assigned with unique priorities runnables order the priorities assigned to tasks must be consistent with the order of execution of the runnables partitioned on them.
that is if runnables riand rjare on the same ecu and runnable riprecedes runnable rjthenrishould be partitioned in a task with priority higher than that of the task executing rj.
.
timing constraints all transactions must complete within their end to end deadlines lr l d l the veri cation of this constraint requires the evaluation of the end to end response time r lof each transaction l which equals the wcrt of its sink runnable ri i.e.r l rriandri snk l .
we use the response time analysis with jitter propagation given in and reformulate it to consider runnables see equations where jriis the release jitter of the runnable w q riis the completion time of theqthinstance of runnable ri.
instance of a runnable riis a distinct execution of riafter activation in the busy period.
the function hp ri returns the indexes of all the runnables allocated on the same ecu with a priority higher than that ofri.
the completion time is computed for q until the busy period ends that is an instance completes at or before the activation of the next instance.
w q ri q cri k x rj ri rj crj k x rj2hp r i w q ri jri prj crj k r l rri max q wq ri q pri jri the jitter of runnable riinherits the response time of the signalsi 1sent by its direct predecessor in the transaction.
jri rsi if a signalskis local its response time is the same as its sender runnable rk .
rsk rrk otherwise the wcrt of skis computed as the response time of the message mp m sk carrying this signal.
rsk rmp to calculate the response time of message mp a set of formulae similar to is used except for an additional term bmpthat represents the blocking time causedby the impossibility of preempting lower priority messages as in a can bus a reduction in the queuing delay wmpsincempcannot be preempted.
we use the approximated su cient formulation provided in in which bmpis the longest transmission time largest wctt of any message that shares the same communication bus or simply the longest bit message in the can bus .
w q mpis the start time of the q th instance of message mp.
w q mp bmp q cmp x mj2hp m p w q mp jmp pmj cmj rmp max q wq mp q pmp jmp cmp the queuing jitter of mpis the largest among all the jitters of signals packed in mp.
the jitter jskof a signalskequals the response time of a runnable rk 1that sends the signal sk i.e.jsk rrk .
jmp max sk m sk mpjsk .
optimization objective we consider an optimization metric expressing the relaxation of time budgets within the end to end deadline constraints.
the function ftb tb in is de ned as the minimum time budget value for all runnables in rbnormalized with respect to the target range tbm ri tbm ri .
the optimization objective is to maximize ftb tb or equivalently to maximize the minimum normalized time budget among runnables in rb.
to represent the speci c valuation of time budgets from the set tbwe use the notation tba .
henceftb tba refers to a speci c computed value.
ftb tb min rk2rbtbrk tbm rk tbmrk tbmrk the designer has the option to provide a minimum value fortbriastbm ri its intuitive meaning is a preliminary evaluation of the minimum required execution time for the functionality based on the experience of the designer .
if it is not speci ed then tbm ri .tbm riis the maximum time budget for the runnable ri.
if not set by the designer it is assigned with the period of the transaction to which ribelongs.
providing for a time budget that allows for additional slack time mitigates the design risks associated with uncertainties about the execution time of the runnable implementation delivered by the supplier.
the authors of propose a method to derive a certainty of obtaining a feasible system con guration under the assumption of uncertain design parameters such as wcet of new runnables.
they de ne an uncertainty function that enables the system integrator to estimate the risk of obtaining an infeasible design and consider it in the de nition of the contract with a supplier.
indeed relaxation of budget values lies in the interest of the .
employs the binary sensitivity analysis which searches for an upper bound of the runnable execution time so that the system remains schedulable.
the proposed algorithm is designed to consider the relaxation of only one runnable which is why the metric of interest does not need to be normalized.
in our case relaxation should a ect all the runnables in rb.
accounts for more than one runnable by simply returning a schedulability region of all the possible combinations of the time budgets for runnables in rb.
238our proposed metric in instead targets at only the best combination i.e.
one that equally distributes the budget constraints among di erent suppliers delivering implementation of runnables from rb.
.
a one step solution to solve the time budgeting problem de ned in the previous section we rst consider a one step approach and a solution based on a genetic algorithm ga and milp mixed integer linear programming .
a genetic algorithm from was used and slightly modi ed to nd solutions for the deployment problem which includes placement partitioning and scheduling the rst three sub problems de ned in section .
.
the ga implementation for this particular problem requires the speci cation of the encoding and evolution operators along with the tness function and stop condition sections .
.
.
for a given deployment solution the time budgets of runnables the fourth sub problem in section .
are assigned using algorithm which has as inputs the maximum value of runnable time budgets.
the maximum value of time budgets is formulated and computed by a milp framework.
these algorithms are described in sections .
and .
.
.
encoding each solution to the problem is encoded as a chromosome chj representing a speci c deployment con guration.
this work uses the value encoding in which each gene gi subset of bits inchjcontains a speci c value.
a gene relates to either a runnable entity or a data signal.
the sequencing of genes forming a chromosome is random but the same for all chromosomes.
for a runnable gene gi chj rk stores the valuevrk gi representing the allocation and partitioning of rk that is the index of the ecu on which it is allocated and the index of the task also representing its priority in which it is partitioned.
nrmaxdenotes the maximum number of runnables that can be hosted by any ecu without violating the utilization constraints wcets or tbm riand periods of runnables are used for computing nrmax .
if runnable ri is allocated to ecu emand partitioned into the task l its encoding vrk gi is computed according to the following equation .
vrk gi m nrmax l for a data signal vsk gi depends on whether it is a global or local data signal.
the gene for a global signal holds information about the bus and the message in which it is partitioned.
for a local signal skthe value will not have any meaning.
the gene value for a data signal is computed in a similar way .
nsmaxis the maximum number of signals that can be transmitted over any bus without violating the utilization constraints wctts and periods of signals are used to compute nsmax .
vsk gi m nsmax l .
evolution the evolution of a population consists in the generation of new chromosomes new solutions using the crossover and mutation mechanisms followed by the selection of chromosomes with the highest tness values.
the crossover operator combines information from two parent chromosomes to generate new ones.
we use the ox3 crossover operator with a tournament selector with size equal to .
the tournament selector with size will rst create two sets with randomly chosen chromosomes.
the most t chromosome from each set will be taken and these two chromosomes will be used as parents for the crossover.
then the ox3 operator will randomly select the crossover points i.e.
indexes of genes that will constitute the boundaries of the crossover operation.
the values between these points are copied from the rst second parent to the second rst child in the same absolute position.
the remaining values are copied from the rst second parent to the rst second child.
the mutation operator randomly chooses a gene in a chromosome to change its value to a new value randomly selected among those that do not violate the constraints of a correct deployment see section .
.
.
fitness function the tness function de nes how much the solution optimizes the time budgeting optimization criterion.
chromosomes are ranked according to the result of the metric function.
the higher the value the higher the probability that the chromosome will be chosen as a parent for a crossover.
the tness function requires as an input the deployment speci cation i.e.
encoded in the chromosome and the time budgets assignment tba .
the time budgets assignment is obtained by using algorithm .
.
stop condition the stop condition determines when the ga will terminate.
in our case the algorithm stops when niterations of the ga internal loop deliver a maximum t result with the same tness value the best solution does not improve in n rounds .
.
time budgeting algorithm within the ga optimization cycle algorithm is executed for each chromosome to compute the corresponding optimum set of time budgets based on which value for the metric function ftb tb can be calculated.
the time budgeting algorithm has four inputs rb andmrb.
is the maximum error on the computed budgets that controls the terminating condition line .
the lower is the value of the more accurate are the time budgets and the larger is the runtime of the algorithm.
mrbis a set of upper bounds on the runnable budgets computed for a speci c deployment where mrb i is the maximum value forri.
the values in mrbare computed before running algorithm see .
.
algorithm tries to relax the time budgets for all the runnables in rbaccording to the metric using a binary search algorithm as in the sensitivity analysis test in .
the upper bound values are tried rst giving the maximum possible value of ftb tb lines .
if the corresponding con guration is schedulable function isschedulable simply checks the condition from eq.
it is returned as the optimum value line .
if not then the algorithm assigns to eachrjinrba budget value that is the medium value between the minimum tbm rjand the upper bound mrb i lines .
from this point on algorithm continues by iteratively reducing the range of the time budgets de ned as for runnable rj.
the algorithm works as a binary search.
in each iteration if the current budget values at the midpoint 239algorithm time budgeting algorithm require rb mrb for allrj2rbdo utbrj mrb j ltbrj tbm rj end for ifisschedulable mrb then for allrj2rbdo tba set rj mrb j end for returntba else for allrj2rbdo tbrj utbrj ltbrj end for end if while9ri2rb utb rj ltbrj do for allrj2rbdo tba set rj tbrj end for ifisschedulable tba then forrj2rbdoltbrj tbrj else forrj2rbdoutbrj tbrj end if tbrj utbrj utbrj ltbrj end while returntba between the the upper and lower bounds result in a schedulable solution the upper bound utbrjremains the same and the lower bound ltbrjis updated to be midpoint line and the range is reduced to be half of the size.
if the current settings result in an unschedulable solution it means that the time budget value is too large and the next iteration will search wiithin the lower half of the range line .
in budget values are computed for each runnable separately in a set of recurrent calls exploring all the possible options for the relaxation of each runnable budget at the price of higher complexity.
however for the metric this is not required.
given any optimal solution according to there exists another solution with the same value of that is computed by our bisection algorithm performing an equal relaxation of all time budgets i.e.
proportionally totbm riandtbm ri .
of course the solution computed by algorithm can have smaller budget values for those runnables that are not a ecting the value of .
.
calculating mrbusing milp finally the upper bounds mrbthat are required to reduce the initial interval of possible budget values in algorithm are computed using an milp mixed integer linear programming formulation.
the values in mrbare optimistic upper bounds and do not guarantee the system schedulability as the constraints used for their computation are a linear approximation representing only a necessary schedulability condition that does not consider interference.
however they are useful in constraining the search space for the bisection algorithm.
in the milp formulation the problem is represented with parameters decision variables and constraints over the parameters and decision variables.
moreover an objective function is de ned to characterize the optimal solution.
variables the only set of variables are mrb ri where ri2rb.
objective function the objective is to maximize the metric function in equation with mrb ri in place of tbri.constraints three types of constraints are considered utilization constraints a utilization bound applies to each ecu uei .
unless speci ed the default limit value is .
8ei2e x rj2rb e rj eimrb rj p rj uei x rj2rw e rj eicrj ei p rj computation time constraints are a linear underapproximation of the deadline constraints ensuring that the sum of the execution times and budgets on each chain is lower than the deadline.
these constraints do not consider interference and therefore do not guarantee end to end deadlines.
i2 x rj2rb rj imrb rj d i x rj2rw rj icrj ei minimum and maximum value constraints 8ri2rbtbm ri mrb ri tbm ri .
staged approach the one step holistic approach is simple and e ective but does not scale to very large size problems.
hence an alternate solution was developed by dividing the four subproblems in two stages.
the rst stage solves the rst three sub problems on deployment placement partitioning and scheduling .
the second stage tries to optimize the time budgeting only.
the two stages are computed sequentially inside a loop until there is no further improvement as shown in figure .
the computation time savings derive from the execution of algorithm once for each iteration instead of once for each chromosome.
the staged algorithm implements an iterative improvement strategy that is in essence a local search.
starting from an initial solution the current best solution is tentatively improved in the iterations of an inner cycle that includes the two optimization stages.
if at any iteration the two stages fail to produce a better result the algorithm terminates and returns the best solution found until that point.
the algorithm starts with the initialization of the variables storing the population of chromosomes and the current best metric values the rst two blocks from figure .
the second stage second block in the gure initializes the values of time budgets with their minimum values i.e.8ri2rb tbri tbm ri section .
.
the rationale for this choice is that we do not want the algorithm a local search to end prematurely and we try to ease schedulability and provide for maximum allocation freedom as much as possible in the rst step.
in the experiments section we discuss the impact of di erent values for the initial time budgets.
next the deployment optimization is performed considering the current values of the time budgets the rst time the loop is entered these are the initial budgets .
during the deployment optimization stage budgets are xed the metric function ftb tb has a constant value and cannot be used to evaluate the quality and drive the selection of the deployment solutions.
hence the tness function considered in this step is based on the end to end response times.
the 240functionfslack tb de ned in equation expresses the minimum slack time the di erence between the deadline and response time of each transaction.
now the goal is to maximize the minimum slack.
fslack tb min i2 maximizing the minimum slack means maximizing the minimum distance between the response time and deadline of any transaction which is an indication of an opportunity for having larger budgets and hence a better deployment.
the function fslack tb is computed based on the schedulability analysis formulas for computing the response times of runnables and messages see section .
.
at each iteration of the main loop a new deployment solution is computed and then evaluated.
if the value of fslack tb does not improve on the current best solution i.e.
the minimum slack is lower the loop terminates and the best solution computed up to this point is returned.
otherwise algorithm is executed to compute a new optimum set of time budgets for the current deployment .
then the tness value ftb tb is computed for the new set of time budgets and the new tness value is compared with the current best.
if the new deployment budgets improve on the current best solution they are considered for the next iteration and the new budget drive the next deployment optimization step.
otherwise the algorithm terminates and returns the best current deployment and time budget solution.
the procedure is summarized in figure .
besides the di erent optimization metric used during the deployment another signi cant di erence with the one step deployment algorithm described in section is the stop condition.
the loop terminates not only if no improvement is found after ninternal ga iterations but also when the tness of the best chromosome from the new population is not better lower or equal than the current best tness value currentslackfitness globalslackfitness .
finally the set de nes the initial population for the ga algorithm.
at each iteration round preserves the population selected in the previous run of the deployment algorithm.
when the deployment is run for the rst time and the set is empty the deployment procedure initializes with a random initial set of chromosomes which is consistent with the constraints that apply to the system con guration.
.
experimental ev aluation to evaluate the algorithms a series of experiments have been performed on a collection of automotive case studies.
first a set of case studies is used to compare the one step approach with the staged approach in terms of the quality of the results and the required execution time.
next we discuss the robustness of the staged approach by evaluating the in uence on the nal results when replacing the metric in equation with a di erent function.
then we present experiments to see if and by how much di erent initial assignments of time budget values a ect the nal result.
finally we compare with the work which is closest to ours done in the all times project .
all tests were run on a machine with 8gb of memory and a single processor running at .4ghz.
also all the tests assume the maximum error factor and the stop condition for the ga regardless of initial population size is that n consecutive iterations compute the same value.
tba initialize time b udgets perform deployment currentslackfitness currentslackfitness f tba currentslackfitness globalslackfitness m calculate m wi th milp tba timebudgetinga lgorithm currenttbfitness f t ba globalslackfitness f tba globaltbfitness currenttbfitness globalslackfitness currentslackfitness slack no slacktbyes globaltbfitness curr enttbfitness update tbacurrenttbfitness globaltbfitness yesno return tbarb r bmain loop figure iterative improvement loop for the staged approach .
an automotive case study we rst apply our technique to an automotive case study constructed by merging two subsystems consisting of a ccs cruise control system and abs anti lock braking system .
figure shows the input functional architecture together with the hardware topology.
the functional model contains twelve runnables in four transactions with their deadlines and trigger periods.
for ve runnables i.e.
input acquisition input interpretation basic function diagnosis and diagnosis the wcet information is not available and time budgets must be assigned they belong to the setrb .
the other seven runnables are assumed as reused from legacy libraries and belong to the set rw.
the hardware topology contains four ecus each connected to the single can bus.
the wcets of the runnables in rw are shown on figure and in table .
table also shows the minimum and maximum budget values for the runnables inrb.
table results for time budgets assignments and initial constraints runnable wcettbmtbmtb ecu input acquisition .
input interpretation .
basic function .
diagnosis .
diagnosis .
limp home .
speed setpoint .
application condition .
controller .
data processing anti lock anti lock 24110ms limp home diagnosisswc5 swc6 2 d 10 2 input acquisitionapplicationswc1 swc2 swc3 swc4 function controller11 d 40speed inputconditionbasic interpretationsetpoint40ms d 60 3 data processing anti lock 1swc7 swc8 d 100 swc9 swc104 diagnosis anti lock can busecu1 ecu2 ecu3 ecu4c .
c .
c .
c .
c c 2c 1560ms 100ms 4figure input software and hardware architecture of combined ccs and abs sub systems input acquisitioninput interpretation speed setpointapplication conditionbasic function diagnosis 2controller anti lock data processingdiagnosis anti lock 2limp home 1 2 1 2 1 1 2can busecu1 ecu2 ecu3 ecu4m1 m2 m3 figure deployment con guration for ccs and abs the execution of the one step optimization algorithm results in the deployment con guration shown in figure .
for simplicity the software components are omitted in the gure.
the index of a task also represents its priority the lower the value the higher the priority .
the task assignments and the computed time budget values are displayed together with the budgets constraints in table .
.
one step vs. staged approach this subsection presents results of the comparison between the one step holistic algorithm and the staged iterative approach.
we examine and compare the quality of the solutions obtained with the two approaches i.e.
the nal tness values the maximized ftb tb and the runtimes that are required by the two algorithms.
for this purpose the automotive case study has been extended with lower and higher complexity examples that have been generated starting from the runnable case study index in our list presented in and extended to lower and higher sizes as described in .
table shows a summary of the fteen system con gurations by growing complexity.
the table contains in the rst column an index identify ing the test case in the second column the total number of runnables in the third column the number of runnables for which budgets must be assigned and nally the number of ecus in the hardware architecture.
in all these examples we assume a single can bus connecting all ecus.
the original automotive case study is in the fourth row with twelve runnables as shown in the second column and of them inrb.
finally as a further assumption each software component has only one runnable entity.
this means that for each runnable its placement is independent of any other runnable s placement as autosar requires that all runnables in the same component must be placed to the same ecu .
table properties of the testing input architectures test nb runnablesjrbjecus .
.
quality evaluation figure shows the nal tness value of the best solution obtained by the one step approach compared with the one of the staged approach.
the size of the initial population of the ga considered for these tests is .
the tness value of the solutions computed by the two approaches for tests to is exactly the same and also the same value was computed for test .
for tests to and to the staged approach provided results slightly better than the one step algorithm in detail .
.
.
and .
.
.
better respectively .
the problem of interest is too complex to be e ciently solved in one step.
finally the one step approach could not compute the nal solution for case after more than hours of processing time.
during this time the ga internal loop performed iterations.
the best result obtained after this time was .
worse than the nal result computed by the staged approach after .
hours .
we also tested the staged approach on a case test with runnables runnables inrband ecus.
the best result tness value of .
was reached after .
hours.
the processing time required by the one step algorithm prevented a realistic comparison in this case.
.
.
runtime evaluation not only the staged approach manages to get equal or better quality solutions than the one step approach but computes them in a much shorter time.
the graph in figure shows a comparison of the execution times required by the fitness value test nb number of runn ables one step staged approachfigure results for one step and staged approach ga initial population figure runtimes of one step and staged approach ga initial population two algorithms for each experimental case.
the runtime of the one step and staged approaches increases not only with the problem size but also with the size of the ga initial population.
augmenting the size of the ga population is desirable as in many cases this leads to a better value for the nal solution.
in our experiments the nal tness value was mostly independent from the size of the initial population if it has more than initial chromosomes.
the runtimes in the gures are shown for an initial population of chromosomes.
as shown by the graphs the two algorithms have an execution time that still grows exponentially with the size of the problem.
however the staged approach can solve problem con gurations of a size comparable with the typical problems of the industry approximately hours for runnables .
.
robustness of the staged approach this subsection evaluates the sensitivity of the staged approach with respect to the metric used in equation to select placement solutions.
as an alternative to maximizing the minimum laxity metric in we used a metric function that minimizes the sum of the latencies of a subset of the transactions which is another indication of an opportunity for assigning larger budgets .
higher value of indicates better minimization of latencies.
hence our goal is to maximize fe2e tb .
nonetheless please note that figure comparison of two di erent metrics for staged approach figure comparison of nb of iterations of two di erent metrics for staged approach ultimately what matters is the result of metric in .
fe2e tb j j x lr l d l as shown in figure the original metric provides better optimization results on the tests from to in the average by .
.
the reason for this is intuitive.
metric may lead to situations in which for some transactions the response time is signi cantly reduced whereas for others it is close to the deadline.
this last set of transactions is a bottleneck for the relaxation of time budget values that follows next.
this is not the case for the metric which minimizes the response times with respect to the deadlines and maximizes the minimum value does not operate on a sum of values .
concerning the runtime there is no signi cant di erence between the two metrics.
the slight di erences in runtimes are mostly caused by the di erence in the number of iterations of the main loop in the staged approach.
however the number of iterations see figure is mostly similar and so are the runtimes.
the only exception is test where the use of metric resulted in iterations and a runtime of .
hours which is .
higher than the case of a slack metric but the nal result is slightly better.
.
influence of initial time budgets we tried additional test cases to con rm the choice of starting the iterative improvement algorithm with an initial setting of time budgets equal to the minimum allowed value for each runnable in rb.
as previously stated since the algorithm is a local search and terminates when no further improvements are possible a selection of initial values that prevents schedulability would likely cause a premature termination.
to verify we tried initial budget assignments at and of the range between the minimum and maximum values tbm rj tbm rj .
in all our experiments there was no sensible di erence in the quality of the nal result.
however for the highest values of the initial budgets a increase over the minimum value the algorithm ended prematurely for all cases from to .
in these cases the rst deployment step from the iterative algorithm was not able to nd any feasible solution.
.
comparison with all times approach in this section we compare our approach with the work on time budgeting coming from the all times project .
.
.
budgeting algorithms we studied the performance of our time budgeting algorithm algorithm with respect to the algorithm used in .
authors of claim that during each manual recon guration of deployment they use the sensitivity analysis to nd the relaxation of time budget values.
the sensitivity analysis they refer to comes from .
this analysis is applicable if there is only one runnable in rb.
the extended version of this algorithm that can budget multiple runnables is de ned in .
ultimately this is the algorithm that we implemented.
we ported it in the one step and staged approach for deployment instead of the algorithm to see if it can be applied in the automated process of budgets and deployment speci cation.
table presents the runtimes for the properties of the tests please refer to the table which clearly shows that usage of algorithm leads to shorter runtimes in the context of both one step and staged approaches.
this di erence is more signi cant for the one step approach because the calls to the budgeting algorithm occur much more often.
in fact starting from test nb usage of algorithm from in the context of the one step approach was too time consuming i.e.
after hours the algorithm did not nish executing.
the reason is that sensitivity analysis from was designed to construct the map of all budget combinations for which the system remains schedulable the schedulability region .
our algorithm is adapted to the metric of interest which allows to select one single con guration of time budgets which equally distributes budget constraints among the suppliers based on the prede ned values of tbm riandtbm ri.
for all the tests for which algorithms terminated we obtained the same tness value which supports the usage of the algorithm in the automated process of time budgeting and deployment.
.
.
improvements due to deployment interleaving of deployment with time budgeting has positive impact on the relaxation of budget values.
the approach from assumes that the deployment is known a priori.
on the other hand our techniques either one steptable runtimes seconds of one step and staged approach ga initial population when using di erent budgeting algorithms test nbonestepstagedone step with staged with .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
or staged interleave the deployment with budgets speci cation.
this additional design freedom allows to further improve on time budget values.
to show the gain we rst x the deployment for tests to using our deployment technique the runnables from rbwere assigned wcets equal totbm ri .
then we run the budgeting algorithm from and obtained the following values for our metric in equation .
.
.
.
.
.
.
by further manipulation of deployment interleaved with budgets assignment we managed to get results .
.
.
.
better for tests to respectively.
.
conclusions and future work in this paper we present two algorithms that apply to an important problem in modern automotive design ows based on the autosar modeling paradigm for integrated architectures.
the objective is to consider end to end deadlines in time critical functionality distributed over several components and to de ne the assignment of time budgets to component functions developed by suppliers while at the same time optimizing the ecu and task placement and priority assignment to the tasks.
because of the intrinsic complexity of the problem the proposed algorithms apply randomized optimization ga techniques.
further to reduce complexity we compare a one step intuitive solution to the algorithm with an iterative approach.
the iterative two stage approach not only computes results faster but also and somewhat surprisingly with equal or better quality.
the runtime of the algorithm is already compatible with problems of industrial size but we plan to further extend it by a careful evaluation of methods to adaptively choose the size of the initial population and possibly to reduce the execution time of the inner loop in the initial stages of the algorithm.
we also intend to extend our approach to account for architectures which are a mixture of both event triggered and time triggered components and allow for non linear transactions.
.