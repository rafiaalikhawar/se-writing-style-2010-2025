beyond boolean product line model checking dealing with feature attributes and multi features maxime cordy pierre yves schobbens patrick heymans university of namur belgium.
fmcr pys pheg info.fundp.ac.beaxel legay irisa inria rennes france.
university of li ege belgium.
axel.legay inria.fr abstract model checking techniques for software product lines spl are actively researched.
a major limitation they currently have is the inability to deal efficiently with non boolean features and multi features.
an example of a non boolean feature is a numeric attribute such as maximum number of users which can take different numeric values across the range of spl products.
multi features are features that can appear several times in the same product such as processing units which number is variable from one product to another and which can be configured independently.
both constructs are extensively used in practice but currently not supported by existing spl model checking techniques.
to overcome this limitation we formally define a language that integrates these constructs with spl behavioural specifications.
we generalize spl model checking algorithms correspondingly and evaluate their applicability.
our results show that the algorithms remain efficient despite the generalization.
index terms software product lines numeric features feature cardinalities model checking semantics tools i. i ntroduction software product line spl engineering is an increasingly widespread software development paradigm in which similar software products are designed and developed as a family to make economies of scale .
a key challenge in spl engineering is the management of the differences between the products aka variability .
features are first class abstractions to model and reason on variability.
they specify characteristics that may be present or absent in a product.
relations between features like parent child implication and exclusion are usually captured in a feature model fm .
since they were first introduced by kang et al.
in fms became more sophisticated.
for detailed surveys of fm languages see e.g.
.
in this paper we use tvl one of the latest incarnations of fms due to some of its advantages high expressiveness formal semantics and tool support.
a tvl excerpt is given in figure .
tvl and the example are properly introduced in section ii.
many spls are complex critical systems and variability is known to be the source of additional complexity.
therefore efficient quality assurance is paramount.
model checking is an established automated technique for verifying system behaviour.
as for single systems model checking techniques for spls are actively researched .
our past work was concerned with one of the major challenges in spl model fnrs research fellowchecking as the number of features grows the number of products increases exponentially.
we thus proposed various techniques for efficient spl model checking.
we introduced featured transition systems fts a mathematical formalism to model the behaviour of spl products in a concise manner .
we also designed efficient algorithms that identify which products exhibit undesired behaviour.
however fts are a fundamental formalism not meant to be used directly by engineers.
we thus proposed high level specification languages to be used on top of fts notably fpromela an splspecific dialect of promela .
given the large number of different products in an spl it is unrealistic to describe their behaviour separately.
instead our languages associate optional behaviour with features that must not be present to enable it.
a fundamental limitation of existing spl model checking approaches including ours is that they do not deal with numeric features nor features appearing several times in a product viz.multi features1.
numeric as opposed to purely boolean features occur in fms in the form of attributes associated with features.
an example could be maximum number of users which can take different numeric values across the range of products.
the multi feature construct could be used to represent e.g.
processing units which number is variable from one product to another and which can be configured independently.
a recent survey dubbed by our own experience showed that engineers commonly need these constructs .
to transfer of our model checking techniques to industry we thus have to support them.
despite evidence of their usefulness in practice no spl modelling tool currently supports multi features and spl model checking tools support neither numeric nor multi features.
in this paper we propose a combined formalism that integrates tvl with fpromela to model the behaviour of spls with numeric attributes and multi features.
with the addition of attributes optional behaviour can be made dependent not only on the presence or absence of features but also on the satisfaction of arithmetic constraints over attributes.
this implies a generalization of the underlying formalism viz.fts and its associated model checking algorithms.
we implemented the complete method on top of snip an fts based model checker .
the addition of arithmetic constraint solving 1sometimes misleadingly referred to as clones in the literature .
.
c ieee icse san francisco ca usa472 naturally lead us to use satisfiability modulo theory smt solvers.
still those are more computationally expensive than solutions for purely boolean satisfiability.
our experiments show that while multi feature support does not constitute a threat to performance the use of smt solvers to support attributes drastically increases verification time.
we thus also propose an alternative solution where attributes are converted into sets of boolean variables.
this latter approach turns out to be more efficient.
structure of the paper.
section ii recalls the necessary background.
in section iii we expose the challenges related to multi features and define an extension of tvl that supports them through an array based semantics.
in section iv we define multi features and attributes in fpromela.
the implementation and evaluation are described in section v. related work is discussed in section vi.
ii.
b ackground the necessary concepts and background are now recalled most of them based on our running example which is first introduced.
a. running example cfdp is a highly configurable deep space file transfer protocol .
in the past our team helped spacebel a belgian company to develop an implementation of cfdp as an spl .
the original cfdp fm has features.
here we consider a small subset of the protocol i.e.
the ack modes it offers.
the corresponding sub fm has features and yields different valid products.
we had to limit ourselves to this subset because in addition to the variability we had to model the behaviour of the protocol s features which is far more complex.
we did that based on the protocol specification and experimented with various spl behavioural modelling languages.
this turned out to be a difficult and time consuming activity.
the resulting models describe a communication scenario where an entity e.g.
a spacecraft has to transfer a message to another one.
depending on the features of the protocol s instance in each entity properties like successful transmission may or may not be satisfied during the transaction.
the final model has states.
b. tvl figure shows an excerpt of the tvl model of cfdp.
the equivalent graphical representation appears on its right.
in both representations the fm s fundamental structure remains a tree that reflects the parent child hierarchy between the features.
at the top of the tree lies the root feature cfdp .
the root is always part of a product regardless of its other features.
a feature may have child features for instance cfdp has three entity message andchannel .group cardinalities define how many children a feature may have in any given product.
this construct is common in fm languages including tvl.
here it specifies that cfdp must have exactly three children whereas entity must have one or two.
cfdpentity messageint sizechannelsnd minreliablercv minint timeout root cfdp group entity group snd min rcv min int timeout message int size channel group reliable group cardinalitiesfeatures cardinalitiesattributesfig.
a subset of the cfdp feature model shown in tvl and in a feature diagram.
group cardinalities are not to be confused with feature cardinalities which specify how many instances of a feature may exist in any given product.
when no feature cardinality is given as is the case for all features in the model except entity the feature is implicitly assumed to occur at most once in each product.
but whenever there is a need to allow a feature to have multiple instances an explicit cardinality is added to the feature itself as opposed to the group we call such a feature a multi feature .
in the excerpt the only multi feature is entity .
it has a feature cardinality of exactly hence two instances of this feature exist in each product.
in our scenario each instance corresponds to one of the two communicating spacecrafts.
defining entity as a multi feature allows the two spacecrafts to bear a different configuration.
if entity was a normal feature the spacecrafts should necessarily be identical.
in reality it is more likely that they are not.
each instance of entity must have at least one of the following child features sndmin sending capabilities andrcvmin receiving capabilities .
under sndmin and rcvmin lie additional features which have been omitted in the figure.
features rcvmin andmessage both have an integer attribute .
the attribute timeout determines the number of communication flaws that are allowed before aborting a communication while size models the number of data packets that must be sent for the transmission to end.
feature channel has an optional child feature reliable which specifies whether or not the communication channel is reliable.
in addition to the specification of the tree structure tvl allows the definition of additional constraints i.e.
boolean formulae over both the features and their attributes omitted in the figure .
the semantics of an fm is usually defined as the set of valid products i.e.products whose features satisfy all the constraints defined by the fm .
c. featured transition systems fts fts is the formalism at the core of our model checking approach.
its main advantage over competing approaches is that it uses an explicit notion of feature which brings473performance improvements and allows one to relate errors and undesired behaviours to the exact set of products where they occur.
fts are directed graphs whose transitions are annotated with feature expressions i.e.boolean formulae defined over the set of features.
for instance the feature expression message channel represents the set of products that have the feature message and the feature channel reliable models the set of products that do not have the feature reliable .
a product is thus able to execute a transition iff its set of features satisfies the associated feature expression.
a model checking algorithm takes that information into account while looking for error states.
it can thus keep track of which products are able to execute the currently analysed behaviour.
feature expressions constitute an intuitive and flexible way to represent variability in behavioural models.
in their current form fts do not support expressions over multi features and attributes.
formally they are defined as follows.
definition an fts is a tuple s act trans i ap l d wheresis a set of states actis a set of actions trans is a set of transitions iis a set of initial states ap is a set of atomic propositions llabels each state with the propositions it satisfies dis an fm and associates each transition to a feature expression.
d. spl behavioural specification in fpromela there are two kinds of approaches to implement or model spls .
compositional methods capture the effects of features in isolated modules.
a desired product is then obtained by composing the right set of modules.
on the contrary annotative approaches directly adorn code models with constraints over the features e.g.
feature expressions.
these annotations express that parts of the code model are exclusive to the set of products satisfying the formulae.
fpromela falls into the latter category.
it is an executable language based on spin s input syntax .
in an fpromela model the behaviour of each process is described in aproctype structure.
within a process executable statements are expressed using constructs inspired by imperative programming.
each of these can be annotated with feature expressions such that only the products satisfying a formula are able to execute the associated statement.
let us consider the excerpt shown in figure .
features are declared as boolean fields of a user defined structure called features .
in this model two processes of type cfdp entity are specified.
at some point the specification of a cfdp entity splits into two parts one for the products satisfying the feature expressionsndmin and one for the others.
the semantics of an fpromela model is an fts.
each process is first translated into an fts.
a state corresponds to a variable valuation and a node of execution.
transitions between states are determined according to the executable statements.
feature expressions labelling transitions are directly derived from the fpromela model.
once all the processes have been translated the final fts is obtained by computing their parallel composition .... typedef features ... bool snd min features cfdp active proctype cfdp entity ... int i ... if cfdp.snd min ... else ... fi ... fig.
partial cfdp model.
a b c r?
a fm example abcrababcra?
b group cardinalities abcrababcrabb?
c group cardinalities abbracabbrabc?
d feature cardinalities fig.
ambiguities introduced by feature cardinalities.
an fpromela model may include behaviour that is executable by no valid product.
let us suppose that during an execution the model goes through a transition annotated by featuresndmin then through one annotated by its negation.
the resulting execution path is inconsistent because it requires both the presence and the absence of the feature.
to avoid exploring this path we use sat solving methods which detect non satisfiable formulae.
similarly an execution path may require an invalid combination of features.
it is consequently not a behaviour of the spl since it cannot occur in any valid product.
such paths are avoided by checking the feature expression associated with the path of execution against the fm .
iii.
a rray based semantics for multi features the syntax and the semantics of attributes in tvl are already defined but the language does not support multifeatures.
to overcome this we extended the syntax as follows unless there is exactly one instance the cardinalities are474written between brackets next to the name of the feature see figure .
additional constraints over multi features are described further in this section.
for clarity we name tvl our new version of tvl.
before we give it a formal semantics we have to deal with a number of issues.
a. challenges in the definition of feature cardinalities as explained by michel et al.
feature cardinalities introduce semantic ambiguities.
when a non terminal feature has a maximum cardinality greater than one two ambiguities exist regarding its group cardinalities.
for instance consider the fm in figure 3a and the two instances shown in figure 3b.
according to the feature diagram shown in the former figure featureahas two instances and a group cardinality of only one or two child features of amay exist .
however it is unclear whether the group cardinalities apply locally under each instance ofaorglobally forallinstances of a. in other words either each instance can have one or two child features left diagram in figure 3b or there must be one or two child features ofaaltogether right diagram .
since our approach is centred on multi features we consider the local interpretation like michel et al.
.
the second ambiguity lies in the scope of group cardinalities see figure 3c.
in the left diagram cardinalities restrict the number of instances ofa s child features.
on the contrary in the right diagram the two instances of bunder the leftmost instance of aare counted once in this case cardinalities constrain the number of distinct child features.
like michel et al.
we believe that the original intent of group cardinalities is to restrict the number of features in a product we thus consider the second option.
multiple interpretations are also possible for feature cardinalities.
let us consider figure 3d.
as for group cardinalities either feature cardinalities apply globally and count the total number of instances of a feature left diagram or they apply locally and count the number of instances of a feature under a specific instance of its parent feature right diagram .
as before we adopt the most local option i.e.the latter.
another issue concerns the identification of a feature by means of its name.
in fms without multi features the relative name of a feature works as a unique reference to that feature.
this is not the case for multi features.
let us consider again the tvl model of cfdp figure .
the relative name sndmin can refer to a child feature of either the first instance ofentity or the second one.
we have to identify this instance using an absolute name called fully qualified .
in tvl however no construct exists for referring to a precise instance.
moreover the semantics proposed by michel et al.
defines the children of a feature as a multiset of instances .
one cannot refer to a precise element of a multiset in natural language.
our spl behaviour specification language requires this capability the definition of michel et al.
is thus inappropriate for our purpose.
we propose to represent the children of a feature by a set of arrays of instances.
in a given array all the instances are from the same feature.
each of them is identified by an index the first index being zero.
for example the sndmin child feature of the second instance of entity is identified by the fully qualified name cfdp entity sndmin .
when the maximum number of instances of a given feature is the index can be omitted cfdp entity sndmin is thus equivalent to the above name.
an attribute of a given instance must be referred to using its fully qualified name as well e.g.
cfdp message size .
since we introduce multi features in the syntax of tvl we must provide means to specify constraints over them their attributes and their number.
fully qualified names are already suitable to refer to precise instances or attributes.
however it is currently impossible to reason over a whole array.
for example one cannot express that the number of instances of a feature must not exceed the value of another feature s attribute or that every instance of a feature must satisfy a given constraint .
to address this limitation we define the operator card which given a fully qualified multi feature name returns its number of instances.
e.g.
card cfdp.entity always returns .
we also define two new types of constraints forall m f gandexists m f g. intuitively they specify that for each resp.
at least one instance of a multifeature m the sub tree of this instance satisfies the constraint .
for example the constraint forall cfdp entity fsnd min rcv mingis satisfied if and only if every instance of entity has at least one child.
as we will see a notion of context is required for defining the semantics of such formulae.
the last challenge is related to constraints over attributes.
if a feature is not part of a product