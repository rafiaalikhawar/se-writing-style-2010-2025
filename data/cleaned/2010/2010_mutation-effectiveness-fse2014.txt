are mutants a valid substitute for real faults in software testing?
ren just darioush jalali laura inozemtseva michael d. ernst reid holmes and gordon fraser university of washington seattle wa usa rjust darioush mernst cs.washington.edu university of waterloo waterloo on canada lminozem rtholmes uwaterloo.ca university of sheffield sheffield uk gordon.fraser sheffield.ac.uk abstract a good test suite is one that detects real faults.
because the set of faults in a program is usually unknowable this definition is not useful to practitioners who are creating test suites nor to researchers who are creating and evaluating tools that generate test suites.
in place of real faults testing research often uses mutants which are artificial faults each one a simple syntactic variation that are systematically seeded throughout the program under test.
mutation analysis is appealing because large numbers of mutants can be automatically generated and used to compensate for low quantities or the absence of known real faults.
unfortunately there is little experimental evidence to support the use of mutants as a replacement for real faults.
this paper investigates whether mutants are indeed a valid substitute for real faults i.e.
whether a test suite s ability to detect mutants is correlated with its ability to detect real faults that developers have fixed.
unlike prior studies these investigations also explicitly consider the conflating effects of code coverage on the mutant detection rate.
our experiments used real faults in open source applications that comprise a total of lines of code.
furthermore our experiments used both developer written and automaticallygenerated test suites.
the results show a statistically significant correlation between mutant detection and real fault detection independently of code coverage.
the results also give concrete suggestions on how to improve mutation analysis and reveal some inherent limitations.
categories and subject descriptors d. .
testing and debugging general terms experimentation measurement keywords test effectiveness real faults mutation analysis code coverage permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction both industrial software developers and software engineering researchers are interested in measuring test suite effectiveness.
while developers want to know whether their test suites have a good chance of detecting faults researchers want to be able to compare different testing or debugging techniques.
ideally one would directly measure the number of faults a test suite can detect in a program.
unfortunately the faults in a program are unknown a priori so a proxy measurement must be used instead.
a well established proxy measurement for test suite effectiveness in testing research is the mutation score which measures a test suite s ability to distinguish a program under test the original version from many small syntactic variations called mutants .
specifically the mutation score is the percentage of mutants that a test suite can distinguish from the original version.
mutants are created by systematically injecting small artificial faults into the program under test using well defined mutation operators .
examples of such mutation operators are replacing arithmetic or relational operators modifying branch conditions or deleting statements cf.
.
mutation analysis is often used in software testing and debugging research.
more concretely it is commonly used in the following use cases e.g.
test suite evaluation the most common use of mutation analysis is to evaluate and compare generated test suites.
generally a test suite that has a higher mutation score is assumed to detect more real faults than a test suite that has a lower mutation score.
test suite selection suppose two unrelated test suites t1andt2 exist that have the same mutation score and jt1j jt2j.
in the context of test suite selection t1is a preferable test suite as it has fewer tests than t2but the same mutation score.
test suite minimization a mutation based test suite minimization approach reduces a test suite ttotnftgfor every test t2t for which removing tdoes not decrease the mutation score of t. test suite generation a mutation based test generation or augmentation approach aims at generating a test suite with a high mutation score.
in this context a test generation approach augments a test suite twith a test tonly if tincreases the mutation score of t. fault localization a fault localization technique that precisely identifies the root cause of an artificial fault i.e.
the mutated code location is assumed to also be effective for real faults.
these uses of mutation analysis rely on the assumption that mutants are a valid substitute for real faults.
unfortunately there is little experimental evidence supporting this assumption as discussed in greater detail in section .
to the best of our knowledge only three previous studies have explored the relationship between mutants andpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
654real faults .
our work differs from these previous studies in four main aspects.
our study considers subject programs that are orders of magnitude larger.
our study considers real faults rather than hand seeded faults.
our study uses developer written and automatically generated test suites.
our study considers the conflating effects of code coverage when studying the correlation between mutant detection and real fault detection.
a higher mutant detection and real fault detection rate could both be caused by higher code coverage thus it is important to control this variable when measuring the correlation.
specifically this paper extends previous work and explores the relationship between mutants and real faults using large java programs real faults and mutants.
it aims to confirm or refute the hypothesis that mutants are a valid substitute for real faults in software testing by answering the following questions research question .are real faults coupled to mutants generated by commonly used mutation operators?
the existence of the coupling effect is a fundamental assumption underlying mutation analysis.
a complex fault is coupled to a set of simple faults if a test that detects all the simple faults also detects the complex fault.
prior research empirically showed the existence of the coupling effect between simple and complex mutants but it is unclear whether real faults are coupled to simple mutants derived from commonly used mutation operators .
therefore this paper investigates whether this coupling effect exists.
in addition it studies the numbers of mutants coupled to each of the real faults as well as their underlying mutation operators.
research question .what types of real faults are not coupled to mutants?
the coupling effect may not hold for every real fault.
therefore this paper investigates what types of real faults are not coupled to any of the generated mutants.
additionally this paper sheds light on whether the absence of the coupling effect indicates a weakness of the set of commonly applied mutation operators or an inherent limitation of mutation analysis.
research question .is mutant detection correlated with real fault detection?
since mutation analysis is commonly used to evaluate and compare generated test suites this paper also addresses the question of whether a test suite s ability to detect mutants is correlated with its ability to detect real faults.
in summary the contributions of this paper are as follows a new set of developer fixed and manually verified real faults and corresponding test suites from programs.
the largest study to date of whether mutants are a valid substitute for real faults using real faults mutants and developer written and automatically generated tests.
an investigation of the coupling effect between real faults and the mutants that are generated by commonly used mutation operators.
the results show the existence of a coupling effect for of real faults.
concrete suggestions for improving mutation analysis of real faults require a new or stronger mutation operator and identification of its inherent limitations of real faults are not coupled to mutants .
an analysis of whether mutant detection is correlated with real fault detection.
the results show a statistically significant correlation that is stronger than the correlation between statement coverage and real fault detection.table investigated subject programs.
program size kloc test suite size test kloc and the number of junit tests tests are reported for the most recent version.
loc refers to non comment non blank lines of code and was measured with sloccount .
program kloc test kloc tests chart jfreechart closure closure compiler math commons math time joda time lang commons lang total the remainder of this paper is structured as follows.
section describes our methodology and the experiments we performed to answer our research questions.
section presents and discusses the results.
section reviews related work and section concludes.
.
methodology our goal was to test the assumption that mutants are a valid substitute for real faults by conducting a study with real faults using both developer written and automatically generated test suites.
to accomplish this we performed the following high level steps .located and isolated real faults that have been previously found and fixed by analyzing the subject programs version control and bug tracking systems section .
.
.obtained developer written test suites for both the faulty and the fixed program version for each real fault section .
.
.automatically generated test suites for the fixed program version for each real fault section .
.
.generated mutants and performed mutation analysis for all fixed program versions section .
.
.conducted experiments using the real faults mutants and the test suites to answer our research questions section .
.
.
subject programs table lists the subject programs we used in our experiments.
these programs satisfy the following desiderata .each program has a version control and bug tracking system enabling us to locate and isolate real faults.
.each program is released with a comprehensive test suite enabling us to experiment with developer written test suites in addition to automatically generated ones.
.
locating and isolating real faults we obtained real faults from each subject program s version control system by identifying commits that corrected a failure in the program s source code.
ideally we would have obtained for each real fault two source code versions vbugandvfixwhich differ by only the bug fix.
unfortunately developers do not always minimize their commits.
therefore we had to locate and isolate the fix for the real fault in a bug fixing commit.
we first examined the version control and bug tracking system of each program for indications of a bug fix section .
.
.
we refer to a revision that indicates a bug fix as a candidate revision .
for each candidate revision we tried to reproduce the fault with an existing test section .
.
.
finally we reviewed each reproducible fault to ensure that it is isolated i.e.
the bug fixing commit does not include irrelevant code changes section .
.
.
we discarded any fault that could not be reproduced and isolated.
table summarizes the results of each step in which we discarded candidate revision pairs.655table number of candidate revisions compilable revisions and reproducible and isolated faults for each subject program.
candidate revisionscompilable revisionsreproducible faultsisolated faults chart closure math time lang total .
.
candidate revisions for bug fixing commits we developed a script to determine revisions that a developer marked as a bug fix.
this script mines the version control system for explicit mentions of a bug fix such as a bug identifier from the subject program s bug tracking system.
letrevfixbe a revision marked as a bug fix.
we assume that the previous revision in the version control system revbug was faulty later steps validate this assumption .
overall we identified candidate revision pairs hrevbug revfixi.
.
.
discarding non reproducible faults a candidate revision pair obtained in the previous step is not suitable for our experiments if we cannot reproduce the real fault.
letvbe the source code version of a revision rev and let tbe the corresponding test suite.
the fault of a candidate revision pair hrevbug revfixiis reproducible if a test exists in tfixthat passes on vfixbut fails on vbugdue to the existence of the fault.
in some cases test suite tfixdoes not run on vbug.
if necessary we fixed build system related configuration issues and trivial errors such as imports of non existent classes.
however we did not attempt to fix compilation errors requiring non trivial changes which would necessitate deeper knowledge about the program.
out of revision pairs remained after discarding candidate revision pairs with unresolvable compilation errors.
after fixing trivial compilation errors we discarded version pairs for which the fault was not reproducible.
a fault might not be reproducible for three reasons.
the source code diff is empty the difference between revbugandrevfixwas only to tests configuration or documentation.
no test in tfixpasses on vfixbut fails on vbug.
none of the tests in tfixthat fail on vbugexposes the real fault.
we manually inspected each test of tfixthat failed on vbugwhile passing on vfixto determine whether its failure was caused by the real fault.
examples of failing tests that do not expose a real fault include dependent tests or non deterministic tests.
the overall number of reproducible candidate revision pairs was .
.
.
discarding non isolated faults since developers do not always minimize their commits the source code of vbugandvfixmight differ by both features and the bug fix.
we ensured that all bug fixes were isolated for the purposes of our study.
isolation is important because unrelated changes could affect the outcome of generated tests or could affect the coverage and mutation score.
other benefits of isolation include improved backward compatibility of tests and the ability to focus our experiments on a smaller amount of modified code.
for each of the reproducible candidate revision pairs we manually reviewed the bug fix the source code diff between vbug andvfix to verify that it was isolated and related to the real fault.
we divided a non isolated bug fix into two diffs one that represents the bug fix and one that represents features and refactorings.
we discarded a candidate revision pair if we could not isolate the bugvbug vfix v1features refactoringsv2bug fix source code diff figure obtaining source code versions v1andv2.
v1andv2differ by only a bug fix.
vbugandvfixare the source code versions of two consecutive revisions in a subject program s version control system.
tbug t1 bug ... ... ... tk bugpass onv1 fail onv1tfix t1 fix ... tn fix tn fix... tn m fixpass onv2 fail onv1 fail onv2ti fail t1 fix ... tn fix ti fixtipass t1 fix ... tn fix tj bug tj bugis previous version of ti fix empty if ti fix was introduced in tfix figure relationship between the i th obtained test suite pair htipass ti failiand the developer written test suites tbugandtfix.
tbugandtfixare derived from a subject program s version control system.
ti fix is the i th triggering test in tfix and tj bugis the previous version of that test.
fix part of the diff.
the result of this step was two source code versions v1andv2such that v1andv2differ by exactly a bug fix no features were added and no refactorings were applied.
to ensure consistency the review process was performed twice by different authors with a third author resolving disagreements.
different authors reviewed different diffs to avoid introducing a systematic bias.
figure visualizes the relationship between the source code versions v1andv2 and how they are obtained from the source code versions of a candidate revision pair.
v2is equal to the version vfix and the difference between v1andv2is the bug fix.
note that v1is obtained by re introducing the real fault into v2 that is applying the inverse bug fixing diff.
overall we obtained version pairs hv1 v2ifor which we could isolate the bug fix.
.
obtaining developer written test suites section .
described how we obtained suitable version pairs hv1 v2i.
this section describes how we obtained two related test suites tpassandtfailmade up of developer written tests.
tpassand tfaildiffer by exactly one test tpasspasses on v1 and tfailfails on v1because of the real fault.
since tpassandtfaildiffer by exactly one test related to the real fault the pairshtpass tfailienable us to study the coupling effect between real faults and mutants and whether the effect exists independently of code coverage.
these test suite pairs also reflect common and recommended practice.
the developer s starting point is the faulty source code version v1and a corresponding test suite tpass which passes on v1.
upon discovering a previously unknown fault in v1 a developer augments test suite tpassto expose this fault.
the resulting test suite tfailfails on v1but passes on the fixed source code version v2.tpassmight be augmented by modifying an existing test e.g.
adding stronger assertions or by adding a new test.
statement coverage mutation scorechart closure lang math time figure statement coverage ratios and mutation scores of the test suites tpassfor each subject program.
we cannot directly use the existing developer written test suites tbugandtfixastpassandtfail because not all tests pass on each committed version and because the developer may have committed changes to the tests that are irrelevant to the fault.
therefore we created the test suites tpassandtfailbased on tbugandtfix as we now describe.
recall that for each pair hv1 v2i one or more tests expose the real fault in v1while passing on v2 we refer to such a test as atriggering test t. let mbe the number of triggering tests for a version pair then tidenotes the i th triggering test i m .
figure visualizes how we obtained for each real fault mpairs of test suiteshtipass ti failiwith the following properties tipasspasses on v1andv2.
ti failfails on v1but passes on v2.
tipassandti faildiffer by exactly one modified or added test.
in order to fairly compare the effectiveness of tpassandtfail they must not contain irrelevant differences.
therefore tpassis derived from tfix.
if tpasswere derived from tbuginstead two possible problems could arise.
first v1might include features compared to vbug as described in section .
and tfixmight include corresponding feature tests.
second tests unrelated to the real fault might have been added changed or removed in tfix.
in summary we applied the following steps to obtain all pairs htpass tfailiusing the developer written test suites tbugandtfix .manually fixed all classpath and configuration related test failures in tbugandtfixto ensure that all failures indicate genuine faults.
.excluded all tests from tbugthat fail on v1 and excluded all tests from tfixthat fail on v2.
.
determined all triggering tests ti fixintfix.
.created one test suite pair htipass ti failifor each ti fix2tfix as visualized in figure .
overall we obtained test suite pairs htpass tfailiin this step.
figure summarizes the statement coverage ratios and mutation scores for all test suites tpassmeasured for classes modified by the bug fix.
the high degree of statement coverage achieved by tpass allowed us to obtain test suite pairs for which coverage did not increase and test suite pairs for which it did.
in of the cases tfixcontained exactly one triggering test developers usually augment a test suite by adding or strengthening one test to expose the fault.
for the remaining cases each triggering test exposes the real fault differently.
for example a developer might add two tests for a boundary condition bug fix one test to check the maximum and one test to check the minimum value.table characteristics of generated test suites.
test suites gives the total number of test suites that passed on v2and the percentage of test suites that detected a real fault tfail .
the kloc and tests columns report the mean and standard deviation of lines of code and number of junit tests for all test suites.
detected faults shows how many distinct real faults the test suites detected out of the number of program versions for which at least one suitable test suite could be generated.
test suites kloc tests detected total tfailfaults evosuite .
branch .
weak .
strong .
randoop .
nonnull .
null .
jcrasher .
total .
.
automatically generating test suites we used three test generation tools for our study evosuite randoop and jcrasher .
we attempted to use dsdcrasher instead of jcrasher but found that it relies on the static analysis tool esc java2.
this tool does not work with java .
and higher making it impossible to use dsdcrasher for this study.
unlike randoop and jcrasher evosuite aims to satisfy one of three possible criteria branch coverage weak mutation testing or strong mutation testing.
we generated tests for each of the criteria.
we also selected two different configurations for randoop one that allows null values as inputs randoop null and one that does not randoop nonnull .
for each fixed program version v2 we generated test suites with evosuite for each of the selected criteria test suites for each configuration of randoop and test suites with jcrasher.
each test generation tool was guided to create tests only for classes modified by the bug fix.
each of the test generation tools might produce tests that do not compile or do not run without errors.
additionally tests might sporadically fail due to the use of non deterministic apis such as time of day or random number generators.
a test suite that sporadically fails is not suitable for our study.
we automatically repaired uncompilable and failing test suites using the following workflow .
removed all tests that cause compilation errors.
.
removed all tests that fail during execution on v2.
.iteratively removed all non deterministic tests we assumed that a test suite does not include any further non deterministic tests once it passed times in a row.
the final output of this process was generated test suites that pass onv2.
repairing a test suite resulted in approximately of cases in an empty test suite when all tests failed and had to be removed.
therefore for all tools used to generate tests the number of suitable test suites which pass on v2 is smaller than the total number of generated test suites.
table summarizes the characteristics of all generated test suites that pass on v2.
note that unlike evosuite and randoop jcrasher does not capture program behavior for regression testing but rather aims at crashing a program with an unexpected exception explaining the low real fault detection rate.
we executed each generated test suite tonv1.
if it passed tpass it did not detect the real fault.
if it failed tfail we verified that the failing tests are valid triggering tests i.e.
they do not fail due to build system or configuration issues.
overall the test generation tools created test suites that detect of the real faults.657chart closure lang math time coverage mutation not detected detected not detected detected not detected detected not detected detected not detected detected evosuite branch evosuite weakmutation evosuite strongmutation randoop nonnull randoop null jcrasherfigure statement coverage ratios and mutation scores of the generated test suites for each subject program.
the vertical axis shows the statement coverage ratio coverage and the mutation score mutation .
the horizontal axis shows the real fault detection rate.
figure gives the statement coverage ratios and mutation scores for all generated test suites grouped by subject program test generation tool configuration and real fault detection rate.
.
mutation analysis we used the major mutation framework to create the mutant versions and to perform the mutation analysis.
major provides the following set of mutation operators replace constants replace operators modify branch conditions and delete statements .
this set suggested in the literature on mutation analysis is commonly used and includes the mutation operators used by previous studies .
major only mutated classes of the source code version v2that were modified by the bug fix.
this reduces the number of mutants irrelevant to the fault differences in the mutation score would be washed out otherwise.
for each of the developer written and automatically generated test suites major computed mutation coverage and mutation score.
a test is said to cover a mutant if it reaches and executes the mutated code.
a test detects a mutant if the test outcome indicates a fault a test assertion fails or the test causes an exception in the mutant.
we did not eliminate equivalent mutants which means that the reported mutation scores might be underestimated.
this is however not a concern for our study because we do not interpret absolute mutation scores.
moreover the set of equivalent mutants is identical for any two test suites used in a comparison.
.
experiments as described in section the goal of our study was to answer three research questions .are real faults coupled to mutants generated by commonly used mutation operators?
.
what types of real faults are not coupled to mutants?
.
is mutant detection correlated with real fault detection?
after explaining why and how we controlled for code coverage this section explains how we answered these three questions.
.
.
controlling for code coverage structural code coverage is a widely used measure of test suite effectiveness.
differences in coverage often dominate other aspects of test suite effectiveness and a test suite that achieves higher coverage usually detects more mutants and faults for that reason alone .
more specifically if test suite txcovers more code than ty then tx is likely to have a higher overall mutation score even if tydoes a better job in testing a smaller portion of the program.
furthermore no developer would use a complex time consumingtest suite metric such as the mutation score unless simpler ones such as structural code coverage ratios had exhausted their usefulness.
to account for these facts we performed our experiments in two ways.
first we ignored code coverage and simply determined the mutation score for each test suite using all mutants.
second we controlled for coverage and determined the mutation score using only mutants in code covered by both test suites.
for the related test suite pairs htpass tfaili tpassandtfailmay have the same code coverage tpassandtfailcover the same code if the triggering test in tfaildoes not increase code coverage.
for the automatically generated test suites it is highly unlikely that tpassand tfailhave the same coverage because they were independently generated.
therefore we had to control for coverage when using the automatically generated test suites.
we did this by only considering the intersection of mutants covered by both test suites.
this means that a pair of generated test suites was discarded if the intersection was the empty set.
we include the first questionable methodology for comparison with prior research that does not control for coverage.
the second methodology controls for coverage.
it better answers whether use of mutation analysis is profitable under the assumption that a developer is already using the industry standard coverage metric.
our experiments use cobertura to compute statement coverage over the classes modified by the bug fix.
.
.
are real faults coupled to mutants generated by commonly used mutation operators?
the test suites tpassandtfailmodel how a developer usually augments a test suite.
tfailis a better suite it detects a fault that tpassdoes not.
if mutants are a valid substitute for real faults then any test suite tfailthat has a higher real fault detection rate than tpassshould have a higher mutation score as well.
in other words each real fault should be coupled to at least one mutant.
for each test suite pairhtpass tfaili we studied the following questions does tfailhave a higher mutation score than tpass?
does tfailhave a higher statement coverage than tpass?
is the difference between tpassandtfaila new test?
based on the observations we performed three analyses.
we used the chi square test to determine whether there is a significant association between the measured variables mutation score increased statement coverage increased and test added .
we determined the number of real faults coupled to at least one of the generated mutants.
we measured the sensitivity of the mutation score with respect to the detection of a single real fault the increase in the number of detected mutants between tpassandtfail.
we also determined the mutation operators that generated the mutants additionally detected by tfail.
section .
discusses the results.
.
.
what types of real faults are not coupled to mutants?
some of the real faults are not coupled to any of the generated mutants i.e.
the set of mutants detected by tpassis equal to the set of mutants detected by tfail.
we manually investigated each such fault.
this qualitative study reveals how the set of commonly used mutation operators should be improved.
moreover this study shows what types of real faults are not coupled to any mutants and therefore reveals general limitations of mutation analysis.
section .
discusses the results.
.
.
is mutant detection correlated with real fault detection?
we conducted two experiments to investigate whether a test suite s mutation score is correlated with its real fault detection rate.
calculating the correlation requires larger numbers of test suites per fault and thus we used the automatically generated test suites.
we analyzed the entire pool of test suites derived from all test generation tools to investigate whether the mutation score is generally a good metric to compare the effectiveness of arbitrary test suites.
the experiments consider real faults for which we could generate at least one test suite that detects the real fault and at least one test suite that does not.
we determined the strength of the correlation between mutation score and real fault detection.
since real fault detection is a dichotomous variable we computed the point biserial and rank biserial correlation coefficients.
in addition we investigated whether the correlation is significantly stronger than the correlation between statement coverage and real fault detection.
while we cannot directly calculate the correlation between mutation score and real fault detection independently of code coverage we can still determine whether there is a statistically significant difference in the mutation score between tpassand tfailwhen coverage is fixed.
calculating the correlation coefficient independently of code coverage would require fixed coverage over all test suites.
in contrast testing whether the mutation score differs significantly requires only fixed coverage between pairs of test suites.
for each real fault we compared the mutation scores of tpass and tfail.
since the differences in mutation score were not normally distributed evaluated by the kolmogorov smirnov test a non parametric statistical test was required.
using the wilcoxon signed rank test we tested whether the mutation scores of tfailare significantly higher than the mutation scores of tpass independently of code coverage.
additionally we measured the a12effect sizes for the mutation score differences.
section .
discusses the results.
.
results section described our methodology and analyses.
this section answers the posed research questions.
recall that we used real faults test suite pairs htpass tfailimade up of developer written tests and automatically generated test suites which may tfail or may not tpass detect a real fault.
.
are real faults coupled to mutants generated by commonly used mutation operators?
considering all test suite pairs htpass tfaili the mutation score oftfailincreased compared to tpassfor out of pairs .
statement coverage increased for only out of pairs .
the mutation score of tfailincreased for out of pairs for which statement coverage did not increase.
the mutation score of tfailincreased for out of pairs for which0123456789 number of additionally detected mutantspercentage of testscoverage unchanged coverage increased figure effect of triggering tests on mutant detection.
the bars represent triggering tests.
triggering tests did not increase statement coverage unchanged and each one detects new mutants on average.
triggering tests increased statement coverage and each one detects new mutants on average.
statement coverage increased.
the chi square test showed a significant association between mutation score increased andstatement coverage increased c2 n p hence we considered the influence of statement coverage throughout our analyses.
in contrast there was no significant association between mutation score increased andtest added .
in addition to determining whether the mutation score increased we also measured the sensitivity of the mutation score with respect to the detection of a single real fault i.e.
the number of mutants additionally detected by the triggering test.
figure visualizes the number of additionally detected mutants when coverage did not increase unchanged and when it did.
for triggering tests that did not increase statement coverage black bars two characteristics can be observed.
first of these triggering tests did not detect any additional mutants.
second of these triggering tests detected only additional mutants suggesting that the number of mutants that are coupled to a real fault is small when accounting for the conflating effects of code coverage.
figure also illustrates these conflating effects of code coverage on the mutation score of triggering tests that increased statement coverage gray bars detected or more additional mutants.
in contrast this ratio was only for triggering tests that did not increase statement coverage.
we also investigated the underlying mutation operators of the mutants that are coupled to real faults when statement coverage did not increase.
we found that real faults were more often coupled to mutants generated by the conditional operator replacement relational operator replacement and statement deletion mutation operators.
a possible explanation is that some of these mutants cannot be detected by tests that only satisfy statement coverage.
conditional and relational operator replacement mutants are frequently generated within conditional statements and numerous statement deletion mutants only omit side effects detecting those mutants requires more thorough testing.
none of these three mutation operators is known to generate a disproportionate number of equivalent mutants hence they should always be employed during mutation analysis.
of real faults are coupled to the mutants generated by commonly used mutation operators.
when controlling for code coverage on average mutants are coupled to a single real fault and the conditional operator replacement relational operator replacement and statement deletion mutants are more often coupled to real faults than other mutants.659table number of real faults not coupled to mutants generated by commonly used mutation operators.
numbers categorized by reason weak implementation of a mutation operator missing mutation operator or no appropriate mutation operator exists.
weak missing no suchtotaloperator operator operator chart closure math time lang total .
what types of real faults are not coupled to mutants?
for out of real faults none of the triggering tests detected any additional mutants.
we manually reviewed each such fault to investigate whether this indicates a general limitation of mutation analysis.
table summarizes the results which fell into three categories cases where a mutation operator should be strengthened cases where a new mutation operator should be introduced and cases where no obvious mutation operator can generate mutants that are coupled to the real fault.
in the latter case results derived from mutation analysis do not generalize to those real faults.
real faults requiring stronger mutation operators statement deletion the statement deletion operator is usually not implemented for statements that manipulate the control flow.
we surmise that this is due to technical challenges in the context of java removing return or break continue statements changes the control flow and may lead to uninitialized variables or unreachable code errors.
figure 6a gives an example.
argument swapping arguments to a method call that have the same type can be swapped without causing typechecking errors.
argument swapping represents a special case of swapping identifiers which is not a commonly used mutation operator .
figure 6b shows an example.
argument omission method overloading is error prone when two methods differ in one extra argument a developer might inadvertently call the method that requires fewer arguments.
figure 6c gives an example.
generating mutants for this type of fault requires a generalization of a suggested classbased mutation operator which addresses method overloading to a certain extent .
similar library method called existing mutation operators replace one method call by another only for calls to getter and setter methods.
it would be both unfeasible and largely unproductive to replace every method call with every possible alternative that type checks.
nonetheless the method call replacement operator should be extended to substitute calls to methods with related semantics in particular library method calls for string operations.
figure 6d shows an example in which the fault is caused by using the wrong one of two similar library methods indexof instead of lastindexof .
real faults requiring new mutation operators omit chaining method call a developer might forget to call a method whose return type is equal to or a subtype of its argument type.
figure 6e gives an example in which a string needs to be escaped.
a new mutation operator could return false case char ch str.charat a lang fix partial newpartial new partial ichronology newtypes newvalues partial newpartial new partial newtypes newvalues ichronology b time fix return solve min max return solve f min max c math fix int indexofdot namespace.indexof .
int indexofdot namespace.
lastindexof .
d closure fix return ... tooltiptext ... return ... imagemaputilities .htmlescape tooltiptext ... e chart fix return chromosomes.iterator return getchromosomes .iterator f math fix fastmath.pow fastmath.pi dim fastmath.pow fastmath.pi .
dim g math fix figure snippets of real faults that require stronger or new mutation operators.
replace such a method call with its argument provided that the mutated code type checks.
direct access of field when a class includes non trivial getter or setter methods for a field e.g.
further side effects or post processing an object that accesses the field directly might cause an error.
figure 6f shows an example in which post processing of the field chromosomes is required before the method iterator should be invoked.
a new mutation operator could replace calls to non trivial getter and setter methods with a direct access to the field.
type conversions wrong assumptions about implicit type conversions and missing casts in arithmetic expressions can cause unexpected behavior.
figure 6g shows an example where the division should be performed on floating point numbers rather than integers the replacement of the division by multiplication is unrelated to the real fault .
a new mutation operator could replace a floating point constant by an exact integer equivalent e.g.
replace .0by2 remove explicit casts or manipulate operator precedence.
real faults not coupled to mutants algorithm modification or simplification most of the real faults not coupled to mutants were due to incorrect algorithms.
the bug fix was to re implement or modify the algorithm.
code deletion faults caused by extra code that has to be deleted are not coupled to mutants.
a bug fix that only removes special handling code also falls into this category figure 7a gives an example.
similar method called another common mistake is calling a wrong but related method within the program which might either return wrong data or omit side effects.
figure 7b shows an example of calling a wrong method.
note that this type of fault can be represented by mutants for well known library methods.
however without deeper knowledge about the relation between methods in a program replacing every identifier and method call with all alternatives would result in an unmanageable number of mutants.
context sensitivity mutation analysis is context insensitive while bugs can be context sensitive.
suppose the access of a field that might be null is extracted to a utility method that includes a null check.
a developer might forget to replace an instance of the field access with a call to this utility method.
this rather subtle fault cannot be represented with mutants since it would require inlining the utility method without the null check for every call.
figure 7c gives an example of this type of fault.
the fault is that this.startdata might be null this condition is checked in getcategorycount .
however other tests directly or indirectly detect all mutants ingetcategorycount hence a test that exposes the fault does not detect any additional mutants.
violation of pre post conditions or invariants some real faults were caused by the misuse of libraries.
for example the java library makes assumptions about the hashcode and equals methods of objects that are used as keys to a hashmap .
yet a violation of this assumption cannot be generally simulated with mutants.
figure 7d gives an example of such a fault.
numerical analysis errors real faults caused by overflows underflows and improper handling of nan values are difficult to simulate with mutants and hence also represent a general limitation.
figure 7e shows an example of a nontrivial case of this type of fault.
specific literal replacements literal replacement is a commonly used mutation operator that replaces a literal with a well defined default e.g.
an integer with or a string with the empty string .
however the real fault might only be exposed with a specific replacement.
for example a map might contain a wrong value that is only accessible with a specific key.
the literal replacement operator cannot generally simulate such a specific replacement.
figure 7f demonstrates an example that involves unicode characters.
of real faults are not coupled to the mutants generated by commonly used mutation operators.
the set of commonly used mutation operators should be enhanced.
however of real faults mostly involving algorithmic changes or code deletion are not coupled to any mutants.
.
is mutant detection correlated with real fault detection?
section .
provided evidence that mutants and real faults are coupled but the question remains whether a test suite s mutation score is correlated with its real fault detection rate and whether mutation score is a good predictor of fault finding effectiveness.
figure summarizes the point biserial and rank biserial correlation coefficients between the mutation score and real fault detection rate for each subject program.
both correlation coefficients lead to the same conclusion the correlation is positive usually strong or moderate indicating that mutation score is indeed correlated with real fault detection.
unsurprisingly real faults that are not coupled to mutants show a negligible or even negative correlation.
for reference figure also includes the results for statement coverage.if childtype.isdict ... else if n.getjstype !
null parent.isassign return ... a closure fix return getpct comparable ?
v return getcumpct comparable ?
v b math fix if categorykeys .length !
this.startdata .
length if categorykeys .length !
getcategorycount c chart fix lookupmap new hashmap charsequence charsequence lookupmap new hashmap string charsequence d lang fixa athe result of comparing two charsequence objects is undefined the bug fix uses string to alleviate this issue.
if u v if u v e math fix u00cb ecirc u00ca ecirc u00cb euml f lang fix figure snippets of real faults not coupled to mutants.
.
.
.
.
.
chart closure lang math timemutation score vs. real fault detection rate statement coverage vs. real fault detection rate a point biserial correlation coefficients.
.
.
.
.
.
chart closure lang math timemutation score vs. real fault detection rate statement coverage vs. real fault detection rate b rank biserial correlation coefficients.
figure correlation coefficients for each subject program.
the differences between the correlation coefficients of mutation score and statement coverage are significant wilcoxon signed rank test for all subject programs p except time p .
the correlation between mutation score and real fault detection rate is conflated with the influence of statement coverage but the wilcoxon signed rank test showed that the correlation coefficient between mutation score and real fault detection rate is significantly higher than the correlation coefficient between statement coverage and real fault detection rate for all subject programs except time.
further investigating the influence of statement coverage table summarizes the comparison of the mutation scores between all test661table comparison of mutation scores between tpassand tfail.
significant gives the number of real faults for which tfailhas a significantly higher mutation score wilcoxon signed rank test significance level .
program coverage controlled coverage ignored significant avg.
a12 significant avg.
a12 chart .
.
closure .
.
math .
.
time .
.
lang .
.
.
.
.
.
.
chart closure lang math timecoverage controlled ignored figure a12effect sizes for mutation score differences between tpassand tfailfor each subject program.
suites tpassand tfailfor each real fault when coverage is controlled or ignored not controlled .
in addition to the number of real faults for which the mutation score of tfailis significantly higher the table shows the average a12effect size.
figure summarizes the a12effect sizes.
in our scenario the value of a12is an estimation of the probability that a test suite with a higher real fault detection rate has a higher mutation score as well where a value a12 1means that the mutation score increased for all observations.
an effect size of a12 71is typically interpreted as large.
as expected the effect size is greater if statement coverage is ignored not controlled but the average effect size remains large for all subject programs except for closure when coverage is controlled.
mutant detection is positively correlated with real fault detection independently of code coverage.
this correlation is stronger than the correlation between statement coverage and real fault detection.
.
threats to validity our evaluation uses only subject programs all written in java.
other programs might have different characteristics.
moreover all subject programs are well tested see figure .
this may limit the applicability of the results to programs that are not well tested e.g.
programs under development .
however we do not feel this is a major threat since mutation analysis is typically only used as an advanced metric.
for example if a test suite covers only of the source code developers are likely to focus on improving code coverage before they focus on improving the mutation score.
another threat to validity is the possibility of a bias in our fault sample.
we located the real faults by automatically linking bug identifiers from the bug tracking system to the version control revisions that resolved them.
previous work suggests that this approach does not produce an unbiased sample of real faults .
in particular the authors found that not all faults are mentioned in the bug tracking system and that not all bug fixing commits can be identified automatically.
in addition they found that process metrics such as the experience of the developer affect the likelihood that a link will be created between the issue and the commit that fixes it.
however thistable comparison of studies that explored the relationship between mutants and real faults.
loc gives the total number of lines of code of the studied programs that contained real faults.
test suites gives the type of used test suites gen generated dev developer written .
mutation operators refers to rc replace constants ri replace identifiers ro replace operators nbc negate branch conditions ds delete statements mbc modify branch conditions note that mbc subsumes nbc .
real faultsloctests suitesmutation operatorsmutants evaluatedcoverage controlled gen rc ri ro no gen rc ro nbc ds no gen rc ri ro nbc ds no our study357 000gen devrc ro mbc ds yes threat is unlikely to impact our results for the following two reasons.
first while we may suffer false negatives i.e.
missed faults our dataset is unlikely to be skewed towards certain types of faults such as off by one errors.
bachmann et al.
did not find a relationship between the type of a fault and the likelihood that the fault is linked to a commit .
second recent evidence suggests that the size of bug datasets influences the accuracy of research studies more than the bias of bug datasets .
the severity of the bias threat is therefore reduced by the fact that we used a large number of real faults in our study.
we focused on identifying faults that have an unquestionably undesirable effect and that can be triggered with an automated test.
it is possible that our results the correlation between the mutant detection and real fault detection do not generalize to faults that do not match these criteria.
however we argue that reproducibility of faults is desirable and characteristic of common practice.
a final threat is that we did not use class level mutation operators such as those in kim and offutt s studies .
we did not consider them in our study for two reasons.
first class level mutation operators are neither implemented in modern java mutation tools such as major javalanche and pit nor are they commonly used in experiments involving mutants.
we therefore argue that using the set of traditional mutation operators improves comparability and also generalizability the set of traditional mutation operators is applicable to many programming languages.
in addition our qualitative study addresses this threat and shows whether and how mutation analysis could benefit from adding improved or specialized versions of class level mutation operators.
.
related work this section discusses previous studies that explored the relationship between mutants and real faults.
it also discusses commonly used artifacts that provide faulty program versions and research areas that rely on the existence of a correlation between the mutation score and real fault detection rate.
.
studies that explored the relationship between mutants and real faults we are only aware of three previous studies that investigated the relationship between mutants and real faults which are summarized in table .
duran and th venod fosse performed the first such study.
they found that when their subject program was exercised with generated test suites the errors incorrect internal state and failures incorrect output produced by mutants were similar to those produced by real faults.
however this study was limited in scope as it662considered a single line c program and evaluated only of the generated mutants.
finally this study only used generated test suites and did not control for code coverage.
andrews et al.
were the next to explore the relationship between mutants hand seeded faults and real faults.
they found that hand seeded faults are not a good substitute for real faults but that mutants are.
in particular they found that there is no practically significant difference between the mutation score and the real fault detection rate.
however this study was also limited in scope since only one of the eight studied programs space contained real faults.
space is written in c and contains lines of code.
additionally the study considered only of the generated mutants used automatically generated test cases and did not control for code coverage.
namin and kakarla later replicated the work of andrews et al.
used a different mutation testing tool proteum and came to a different conclusion they found that the correlation between the mutation score and the real fault detection rate for space was weak.
they also extended the work to five java classes from the standard library ranging from to lines of code.
faults were hand seeded by graduate students and the authors found that the correlation was considerably stronger.
to the best of our knowledge our study is the first to undertake experimental evaluation of the relationship between mutants and real faults at such a scale in terms of number of real faults number of mutants subject program size subject program diversity and the use of developer written and automatically generated test suites.
in addition our study is the first to consider the conflating effects of code coverage on the mutation score and the first to explore real faults in object oriented programs.
.
commonly used artifacts many research papers use programs from the siemens benchmark suite or the software artifact infrastructure repository sir in their evaluation.
more precisely google scholar lists approximately papers that used programs from the siemens benchmark suite and sir s usage information website lists more than papers that reference sir.
the siemens benchmark suite consists of c programs varying between and lines of code and all faults were manually seeded.
the authors described their manually seeded faults as follows the faults are mostly changes to single lines of code but a few involve multiple changes.
many of the faults take the form of simple mutations or missing code.
thus our results likely hold for these faults which are essentially mutants.
sir provides subjects written in java c c and c .
according to the sir meta data of these subjects come with real faults.
the median size of those subjects is lines of code and of them are written in java.
sir was not suitable for our study due to the small program sizes and the absence of comprehensive developer written test suites.
therefore we developed a fault database that provides real faults for large open source programs which feature comprehensive test suites .
.
software testing research using mutants the assumption that mutant detection is well correlated with real fault detection underpins many studies and techniques in several areas in software testing research.
mutation analysis is an integral part of mutation based test generation approaches which automatically generate tests that can distinguish mutant versions of a program from the original version e.g.
.
however studies in this area have not evaluated whether the generated test suites can detect real faults.test suite minimization and prioritization approaches are often evaluated with mutants to ensure that they do not decrease or they minimally decrease the mutation score of the test suite e.g.
.
prior studies however left open the question whether and how well those approaches maintain real fault effectiveness.
to evaluate an algorithm for fault localization or automatic program repair one must know where the faults in the program are.
mutants are valuable for this reason and commonly used e.g.
.
yet it is unclear whether those algorithms evaluated on mutants perform equally well on real faults.
our qualitative and quantitative studies show to what extent research using mutants generalizes to real faults.
our studies also reveal inherent limitations of mutation analysis that should be kept in mind when drawing conclusions based on mutants.
.
conclusion mutants are intended to be used as practical replacements for real faults in software testing research.
this is valid only if a test suite s mutation score is correlated with its real fault detection rate.
our study empirically confirms that such a correlation generally exists by examining real faults on large open source programs using developer written and automatically generated tests.
furthermore our study shows that the set of commonly used mutation operators should be enhanced and it also reveals some inherent limitations of mutation analysis.
investigating the coupling effect between real faults and the mutants generated by commonly used mutation operators our results show that the coupling effect exists for of the real faults but the number of mutants coupled to a single real fault is small when code coverage is controlled.
moreover conditional operator replacement relational operator replacement and statement deletion mutants are more often coupled to real faults than other mutants.
by analyzing the of real faults that were not coupled to the generated mutants we identified ways to improve mutation analysis by strengthening or introducing new mutation operators.
we also discovered that of faults are not coupled to any mutants which reveals a fundamental limitation of mutation analysis.
furthermore our experiments found a statistically significant correlation between mutant detection and real fault detection.
this correlation exists even if code coverage is controlled and this correlation is stronger than the correlation between statement coverage and real fault detection.
the results presented in this paper have practical implications for several areas in software testing.
first the results show that test suites that detect more mutants have a higher real fault detection rate independently of code coverage.
this suggests that mutants can be used as a substitute for real faults when comparing generated test suites.
second the results also suggest that a test suite s mutation score is a better predictor of its real fault detection rate than code coverage.
thus the mutation based approach to automatically generating test suites is promising.
third test suite selection minimization and prioritization techniques evaluated on mutants might lead to a reduced real fault detection rate of the test suite even if the mutation score does not decrease.
.