dc2 a framework for scalable scope bounded software verification franjo ivan ci c1 gogul balakrishnan1 aarti gupta1 sriram sankaranarayanan2 naoto maeda3 hiroki tokuoka3 takashi imoto3 yoshiaki miyazaki3 1nec laboratories america princeton usa.2university of colorado boulder usa 3nec corporation kawasaki japan ivancic bgogul agupta nec labs.com srirams colorado.edu n maeda bp tokuoka ay t imoto ak y miyazaki bq .jp .nec.com abstract software model checking and static analysis have matured over the last decade enabling their use in automate d software verification.
however lack of scalability makes t hese tools hard to apply.
furthermore approximations in the mod els of program and environment lead to a profusion of false alarm s. this paper proposes dc2 a verification framework using scop ebounding to bridge these gaps.
dc2 splits the analysis probl em into manageable parts relying on a combination of three automated techniques a techniques to infer useful specificat ions for functions in the form of pre and post conditions b stub inference techniques that infer abstractions to replace function calls beyond the verification scope and c automatic refine ment of pre and post conditions from false alarms identified by a user.
dc2 enables iterative reasoning over the calling environme nt to help in finding non trivial bugs and fewer false alarms.
we present an experimental evaluation that demonstrates the e ffectiveness of dc2 on several open source and industrial softw are projects.
i. i ntroduction software model checking is a promising technique for finding subtle bugs in software .
the primary utility of model checkers lies in their ability to present a witness to help explain a bug to a developer.
however the lack of scalability due to fundamental hardness and the reportin g of false alarms due to modeling abstractions form a major hindrance to the adoption of software model checking in industry.
a practically viable software model checker must exhibit many key desirable qualities scalability handle mloc and beyond for c c performance complete verification within the allotted time and finally accuracy yield accurate bug reports with a low rate of false alarms so that human effort is not wasted in examining them.
the capabilities of model checkers have made spectacular advan ces over the last two decades especially with the advent of modern sat smt solvers.
however in spite of these advances when used out of the box even the most advanced software model checking engine cannot handle large projects that are frequently encountered in industry.
in this paper we prese nt dc2 a verification methodology that enables scalable softw are model checking.
dc2 which stands for depth cutoff with design constraints uses scope bounding along with automatic specification inference andenvironment refinement techniques.
scope bounding limits the size of the generated model byexcluding functions that are deeply nested in the call graph thereby enhancing scalability.
environment constraints restrict the environment global variables unknown calling contex t and other external influences at function interfaces.
function stubs capture the effect of calls to library functions missing source code or functions deemed outside the scope by dc2.
the environment constraints and function stubs for availab le code are inferred automatically using a light weight and scalable whole program analysis called s pectackle .
spectackle can infer constraints from pointer array indirections and user defined assertions.
furthermore it pr opagates hoists these constraints across program location s within a function body and across function calls.
as a resul t constraints originating from deeply nested function call s can be automatically hoisted many levels higher in the call graph to provide constraints at key interface functions.
scalabi lity is ensured in s pectackle by focusing on specific syntactic specification templates and using a hand crafted interprocedural static analysis for these templates.
note that our main requirement for s pectackle is scalability rather than precision.
in this respect it is different from other recen t work on automatic generation of preconditions sin ce our inferred preconditions are used only to bootstrap the application of a bit precise and path sensitive model chec ker in the next phase.
the specifications generated by s pectackle may be incomplete.
furthermore since aliasing is not treated sound ly by s pectackle they may also be unsound.
therefore a model checker even with a precise program model can produce false alarms due to lack of a precise environment.
to deal with such false alarms we use an approach we call ceger counterexample guided environment refinement .
it is inspired by cegar where counterexamples are used to guide refinement of an abstract model.
in ceger if the user deems a reported witness as a false alarm the model checker is used to generate a refinement of the environment constraint computed using a data sliced weakest precondi tion backwards over the witness trace.
the refined environment constraints are used in subsequent runs of the verification t ool to eliminate the previously found false alarms.
the applica tion of ceger is quite useful in practice since it helps iterative978 .
c ieee ase lawrence ks usa133reasoning over the calling environment and guides the analy sis towards non trivial bugs and fewer false alarms.
we have implemented dc2 as part of v arvel a software verification tool developed by nec.
we present an experimental evaluation of dc2 on several open source and industry software projects.
our results show that use of dc2 leads to much fewer failures enabling the application of softwar e verification techniques on large projects.
contributions.
in this paper our main contribution is the dc2 verification framework that combines scope bounding with automatic inference and refinement of the environment to enhance applicability of software model checkers on larg e projects.
we present light weight specification inference techniques to automatically infer environment constraints and function stubs.
we present a counterexample guided environment refinement approach ceger to further refine the environment constraints triggered by a user classifying a reported warning as a false alarm.
the ceger approach can potentially leverage work done in examining a set of false alarms for eliminating others in future runs.
we present an experimental evaluation of dc2 on large open source and industry software using an implementation in v arvel a tool developed by nec and utilized within a perpetual verification environment.
overview.
the rest of the paper is organized as follows.
first we provide some background on v arvel and its program modeling in section ii.
we describe scope bounding in section iii and the global analysis for automatic specification inference in section iv.
section v presents our counterexample guided refinement procedure for environme nt constraints.
in section vi we report the experimental resu lts on application of dc2.
section vii discusses some related work.
section viii concludes the paper.
ii.
b ackground varvel and memory modeling varvel is a software verification tool based on an earlier research prototype called f s oft .
v arvel uses a combination of abstract interpretation and model checking to fi nd common errors in c c programs including pointer usage errors buffer overruns c string errors api usage violation s and violations of user defined assertions.
at its core v arvel utilizes a bit precise sat based bounded model checker bmc which operates on a model automatically extracted from a given program.
the formulas generated by bmc are solved by a sat solver to generate witnesses that correspond to property violations.
v arvel has been engineered to handle numerous low level aspects of c programs including pointer arithmetic dynamic memory allocation function pointers and bitwise operations.
scalability in v arvel is enhanced by staging various analyses such that cheaper methods are used first.
it uses abstract interpretation on numerical domains of incre asing precision e.g.
intervals octagons to statically p rove properties.
once a property is proved it is removed fromfurther consideration.
in addition program slicing is use d to remove portions of the program that are irrelevant to the unresolved properties.
in practice roughly of the automatically instrumented checks in a program are rapidly proved using static analysis before the bounded model chec ker is deployed on the rest.
thus the number of properties to check as well as the model size is reduced across the differe nt stages.
however it still remains prohibitively expensive to perfo rm whole program model checking for large programs.
therefore varvel treats every function appearing in a given program as a possible entry function.
although this helps to handle some functions challenges remain for functions with large call graphs where the extracted models may become too large.
furthermore when a function other than main or an interface function is treated as an entry point for verification the i nput parameters and global variables are assumed to hold arbitra ry values.
in reality however these parameters are constrai ned based on values set by its callers.
therefore the model chec ker may report a witness where it assigns a value to an input that cannot be realized in an actual execution thereby resultin g in a false alarm.
the aim of dc2 is to enable effective deployment of v arvel on large systems for finding more bugs and reducing false alarms with minimal user interaction .
varvel supports different memory models and checkers that use the same underlying analyses.
here we focus primar ily on three of these namely a a fine grained array bounds model to check for overflows b a light weight validity model that handles bugs due to malloc failures double free and free of statically allocated memory and c a light weight mode l for detecting memory leaks.
a. array bounds checking the array bounds model tracks pointer addresses allocate d bounds for each pointer and the position of the null termin ator sentinel for strings.
this model is along the lines of the cssv model with some key differences to reduce model complexity and make it easier to analyze.
the bound represents the range of legal values for pointer p such thatpmay be dereferenced in our model without causing an out of bounds violation .
ifp thenp underflows iffp i ptrlo p .
similarly p overflows iffp i ptrhi p .
by convention a pointerpis regarded invalid uninitialized null freed etc.
whenever ptrhi p ptrlo p .
addresses associated with a pointer do not correspond to the physical layout of memory in a program providing an address to a pointer allows us to model pointer arithmetic and aliasing in an easier fashio n. fig.
illustrates the modeling attributes.
for statically allocated arrays the bounds and addresses are set to fixed values at the start.
dynamically allocated pointers are not provided with a priori fixed addresses.
inst ead malloc calls are instrumented to assign a new address and bound at every invocation of malloc .
tracking string lengths.
a majority of the buffer overflows in c result from the unsafe use of the standard library134char s malloc if !s exit strcpy s ase2011 char t s mm 5m st ptrlo s ptrlo t strlen t strlen s 7ptrhi s ptrhi t fig.
.
the memory model for the array bounds model after succ essfully executing the four statements on the left hand sid e the successful allocation returns a pointer to some new address m and the lower bound addresses ptrlo s ptrlo t m. the higher bound addresses are ptrhi s ptrhi t m .
finally the string lengths are determined using the size ab straction namely strlen s andstrlen t .
functions.
we extend our memory model to check for such buffer overflows along the lines of cssv .
corresponding to each character pointer p we associate a variable strlen p to track the position of the first nullterminator character starting from p. the updates to strlen p are derived along the same lines as those for the pointer bounds with the exception of assignments involving pointer indirections where updates to a string pointer are propaga ted to potentially overlapping strings as well.
b. pointer validity checking the pointer validity checker handles those aspects of buff er overflow checking that do not require tracking of bounds ptrhi andptrlo for pointers.
the validity checker instruments each pointer using a seven valued monitor ptrval p to denote the state of a pointer at runtime a null a null pointer b invalid a non null invalid pointer whose dereference may cause a segmentation violation c static global variables arrays and static variables d stack local variables alloca calls local arrays formal arguments e heap dynamically allocated memory on the heap f code code section e.g.
string constants and g environment input pointer parameters.
unlike the overflow checker the validity checker does not track addresses of pointers and ignores address arithmetic .
a pointer expression p iisassumed to have the same validity status as its base pointer p. at a dereference p our modeling adds an assertion check that is violated if ptrval p isnullor invalid .
in case of an assignment to p we may also report a bug if ptrval p code .
calls tofree set the validity monitor of the argument and its aliases to invalid .
finally leaving a functional scope changes pointers that are set to stack toinvalid .
c. memory leak checking we also provide a stand alone model for detecting memory leaks.
in comparison to a standard approach of combining memory leak detection with memory safety checkers our model is very light weight.
further we reduce the model siz e based on the observation that to find memory leaks pointer aliasing relationships need to be tracked only between poin ters and allocation sites.
that is rather than having to track quadratically many aliasing predicates between all pointe rs we simplify the model to track only linearly many aliasing predicates.
we omit further details for sake of brevity.iii.
s cope bounding the basic idea behind scope bounding in dc2 is to cut off function calls beyond a desired call depth in the call graph o f a given entry function.
here call depth is defined as the leng th of the shortest path from the entry function in the call graph .
after the cut off the function call is replaced by a stub that abstracts its effect in terms of preconditions post condi tions and modified variables.
dc2 is supported by a three pronged inference methodology a infer constraints in the form of preconditions for each function so that the calling environment at the entry function can be captured.
b infer stubs in the form of pre conditions post conditi ons and summaries for functions that are cut off.
c support refinement of the inferred pre conditions and po stconditions upon demand.
in our framework the inference of pre post conditions and stubs is supported by a simple whole program analysis called spectackle .
the refinement process called ceger employs an analysis around a counterexample generated by a model checker and identified as a false alarm by the user.
the algorithm for function call rewriting in dc2 is shown in fig.
.
entry and gare the constraints and stub gis the stub inferred by s pectackle .
this scope bounding instrumentation is done as a preprocessing step and is independen t of the verification performed later.
the depth cutoff scheme is illustrated in fig.
.
note that for the entry function of the analysis the precondition inferred by s pectackle is assumed whereas it is asserted for other called functions.
the function his deemed outside the scope.
therefore a stub replacement h stub is automatically created and the inferred preconditions post conditions and stubs are used in plac e of h. the inference of preconditions post conditions and stu b functions to support dc2 are described in the next section while the refinement process is described in section v. iv.
s pecification inference scope bounding largely alleviates the issue of scalability enabling verification to cover large parts of the code by usin g depth cutoff on each entry function.
however cutting off de ep function calls or replacing them by over approximate stubs adversely impacts accuracy leading to false bugs.
further we may miss bugs that occur outside the scope.
to cope with these issues dc2 utilizes a light weight global analysis c alled spectackle .
it has two main roles to generate and hoist preconditions for functions and to generate stub s135function depthcutoff entry depth mapdepthmap func mapsto integer.
insertassume entry at the start of entry .
for all functionsfin callgraph do depthmap f length of the shortest path in call graph from entry tof.
for allfsuch thatdepthmap f depth do for all call sitescin function fdo letgbe the function called at c ifdepthmap g depth then insertassert g beforec.
cut off function call c. replacecwith call to stub g .
fig.
.
function call rewriting in dc2.
fun.
f .. assume pref call g1 ... call g2 fun.
g1 .. assert preg1 ... call h call h stub fun.
g2 .. assert preg2 ...fun.
h .. ... fun.
h stub .. assert preh inferred stub assume posth fig.
.
a schematic illustration of depth cutoff in dc2 on a ca ll graph.
that capture important side effects of functions.
both the se are tailored specifically to the checkers in v arvel .
a. preconditions spectackle visits functions in a reverse topological order with respect to the call graph of the program.
for each function it hoists error conditions within the body to the s tart of the function.
hoisting is done by back propagating the conditions across the statements.
in addition s pectackle also hoists preconditions of the callees to the start of the c aller.
hoisted conditions are used for two purposes in the scope bounding algorithm to constrain the inputs of an intern al functionfwhen it is used as an entry function for verification and to assert the correctness of inputs to a callee g1of f. note in particular that an assertion check assert g will trigger a violation during model checking and generate a witness if the hoisted condition for gis not correct.
in other words we do not require s pectackle to generate correct preconditions.
instead we attempt to automatical ly generate likely preconditions.
the witnesses generated by varvel can be additionally used for manual refinement of the preconditions as described in sect.
v.in the following we briefly describe the preconditions that spectackle generates for a given function.
pointer validity for every pointer pthat is dereferenced spectackle hoists the condition p !
null to the beginning of the function provided pis not checked for null along all paths that lead to the dereference.
if the resultin g condition involves a formal parameter or a global variable it will be retained as a precondition for the function.
array bound for every variable ithat is used as an index expression for accessing a static array of size n it backpropagates the condition i n to the start of the function.
if the resulting condition depends only on the inp uts to the function it will be used as a precondition that constr ains the range of the respective inputs.
allocated heap size if a dereferenced expression is an input variable itself or is aliased with an input s pectackle tries to capture the constraints on the size of heap area pointed t o by the expression by analyzing pointer arithmetic operatio ns.
for example consider the following function void f t t1 int k t t2 t2 t1 k t2 from the expression t2and the pointer arithmetic operationt2 t1 k spectackle generates the following precondition for f t1 k .
field relation inference spectackle captures specific patterns of field usage.
for instance we often see struct definitions that have two fields one pointing to the heap and the other indicating the length of the heap as below struct s char buf size t buflen spectackle automatically extracts such relations and globally constrains the type of inputs.
assertion hoisting spectackle hoists assertions in the program to the beginning of functions.
currently s pectackle can hoist simple linear equality or inequality expressio ns with some simplification for the hoisted assertions.
as a heuristic we drop non linear assertions and assertions in volving complex conditional expressions.
other properties spectackle includes support for inferring null terminator preconditions for strings.
it can als o be easily extended to infer other properties such as type state s. b. hoisting of annotations spectackle is designed to be fast and scalable even for large software.
therefore we avoid computing weakest preconditions since it is typically expensive for the whole program.
this section briefly discusses how annotations are hoisted to the beginning of functions and across calls using purely syntactic domain operations.
let lbe a precondition annotation generated at a program pointlinside a function f. our goal is to compute an appropriate precondition corresponding to the entry point of function f. to hoist an annotation lat location l spectackle initalizeslwith land every other location with the condition false .
is computed by means of a backwards data flow136analysis that captures the effect of various assignments an d conditional branches between program point land the entry point off.
the backwards transfer function is the weakest liberal precondition operator.
preconditions across assignment s tatements are treated by substitution of the right hand side in p lace of the lhs expression.
the pre operator is also defined to propagate a constraint backwards across a branch condition c. computing this operation involves the syntactic search fo r a conjunct in that contradicts the branch condition c. if such a conjunct is obtained the precondition is set to false .
if on the other hand contains a conjunct that is identical to c syntactically the result of the precondition is given by true.
failing this the precondition is set to instead of the more general constraint c .
this is done in part to keep the syntactic form of the preconditions simple so that t he dataflow analysis can be performed efficiently.
on the other hand in some cases the resulting precondition tends to be stronger resulting in a false alarm that may need refinement using ceger.
formally pre c false if syntactically contradicts c true if is identical to c otherwise a join operator unionsq is used to merge two preconditions and obtained from the two parts of a branch.
the join operator works by matching its operands syntactically.
if o ne of the operand syntactically matches false the result is taken to be the other operand.
if can be obtained by conjoining some assertion primeto then the join chooses the weaker assertion .
finally if the operands do not fall into any of the categories above the result of the join is the trivial annot ation true.
formally unionsq if is syntactically false prime if is syntactically false prime true otherwise when the analysis converges the assertion labeling the ent ry point of the function denotes the entry precondition .
if is an assertion other than true orfalse it can be propagated to the callers of the function.
if false then a warning is issued to the user.
example .
consider function f1shown in fig.
a .
the pointer dereference q in line of f1gives rise to two annotations 3and 3. consider the assertion 3 q negationslash null .
because 3is identical to branch condition c q!
null at line the precondition pre 3 c istrue.
note that the assertion 4labelling line is initially false .
therefore joining the contribution across the two branches at line yields 2 true.
as a result the annotation q negationslash null does not yield a precondition for f1.
on the other hand hoisting the annotation 3 q produces the precondition p pre p void f1 int p int q p if q !
null 3 q negationslash null 3 q q ... pre r negationslash null void f2 int p int r int q 2 r negationslash null true if r 3 p negationslash null q p else 4 r negationslash null q r 5 q negationslash null q a b fig.
.
hoisting annotations across statements and branche s. .
in a case like this we generate the following precondition if p p .
example .
consider function f2shown in fig.
b .
the pointer dereference qat line gives rise to the annotation 5. similarly the pointer dereference rat line gives rise to the annotation 2. annotation 5can be hoisted across the assignments in lines and yielding 3 p negationslash null and 4 r negationslash null respectively.
the join operation at the branch in line yields the assertion true.
as a result annotation 5 does not contribute to the precondition for f2.
on the other hand when the annotation 2at line is hoisted to the start off2 we generate the preconditon r negationslash null forf2.
squaresolid in practice a sound and complete precondition is not strictly necessary.
if the precondition is overly restrict ive it would lead to a violation at some call site.
similarly if the precondition is overly relaxed it would cause false alarms due to an under specified environment.
in practice o ur implementation of s pectackle sacrifices soundness in its handling of pointer indirections.
nevertheless the numbe r of unsound preconditions generated is very few in practice an d such instances are detected through witnesses generated by our model checker.
c. stub generation recall that scope bounding in dc2 removes functions that are nested deeply in the callgraph.
another practical issue is that verifiers for large projects especially commercial sy stems often need to work with incomplete code bases because the source code for many third party libraries or modules is unavailable.
for verification purposes it would be useful t o have a summary of the behavior of cut off functions for whic h source code is available as well as missing functions for which source code is unavailable .
we use s pectackle to automatically generate stubs in both situations.
spectackle uses the following analyses to generate stubs that model the side effects of cut off functions mod ref analysis a conservative update to all variables accessible in a cut off function may generate too many false137alarms.
thus s pectackle conducts a light weight mod ref modification and reference analysis to find variables that may be modified.
then it generates a stub that updates only those variables that are modified within the function and its trans itive callees.
key effects extraction library function calls are important for verification.
for instance if a function calls free orexit internally this is captured in the stub.
the stubs for missing functions are generated according to default environment assumptions described in the next section including suitable preconditions for appropria te initializations and postconditions.
in general the default s tubs generated by s pectackle are not sound.
they are designed to avoid false alarms that arise frequently in practice whi le still exposing problematic situations.
in addition v arvel provides a mechanism for the user to provide or refine existing stubs through use of stub apis.
this is described in the next section.
example .
we applied s pectackle on an h. video decoder software project comprising about 25kloc.
s pectackle ran in a matter of seconds and generated preconditions for all the functions.
overall a majority of the generated preconditions corresponded to direct poin ter dereferences of the form pwithout any indexing.
a significant number corresponded to preconditions generated due to indexing of statically allocated arrays with known si zes while the rest corresponded to indexing of pointers of unkno wn sizes.
applying v arvel on the h. project without the inferred preconditions yielded 658witnesses almost all of them being false alarms.
however the number of witnesses was drastica lly reduced to when we used v arvel with the preconditions generated by s pectackle .
of these 30witnesses 10were plausible buffer overflows.
squaresolid v. e nvironment constraints and refinement the preconditions and stubs described in sect.
iv are collectively referred to as the environment .
we use an approach we call ceger counterexample guided environment refinement for refining the environment.
the basic idea behind ceger is to first apply the model checker using thedefault stubs and preconditions e.g.
those generated by spectackle .
afterwards the user examines the witnesses reported and decides which are false alarms.
the environmen t is refined iteratively to avoid the false alarms encountered in the previous iterations.
we start by describing the defau lt environment assumptions.
a. default environment assumptions spectackle makes some default assumptions about functions when generating the preconditions and function stubs .
these assumptions are inspired by common use scenarios.
tab.
i shows some of the default assumptions about values of input arguments bounds of pointers aliasing and functio ns whose code is not included in the analysis.table i automatic default environment assumptions feature default assumption int char arg.
nondet.
value pointer aliasing no aliasing of input argument pointers pointer address nondet.
null orp .
pointer bounds nondet.
invalid or string length nondet.
invalid ornullterm func.
missing src.
ptr.
args are set to nondet.
globals are not changed p null lo hi plo0 hi p lo0 hi p p freed a b fig.
.
possible pointer configurations of an input string p a part of default assumptions and b not permitted by the default assumptio ns.
input pointers are nondeterministically set to be null or to a valid pointer address and bounds.
if pis chosen to be valid then pis set to a unique non null address forms a valid range and p .
the allocated length of pis set to be positive but nondeterministic.
finally strings are assum ed to be null terminated.
note that these assumptions do not lead to a strictly sound treatment of the environment.
for example it is possible to call a function pthat has a valid base but points outside its allocated region at the call sit e. however interfaces in c are seldom designed to handle such cases.
fig.
highlights some cases allowed by the default assumptions for a string input pointer p and some other cases that are not allowed.
stub api.
to aid the user in supplying and refining the environment using c c v arvel supports a special stub api that provides access to auxiliary instrumented variables introduced in the verification models.
these incl ude variables such as ptrhi p ptrlo p strlen p ptrval p and so on.
the apis also support assertions assumptions preconditions and assignments involving instrumented var iables to set up an initial environment .
these allow the use r to directly control the model and verification in v arvel .
indeed the preconditions and stubs automatically generat ed by s pectackle utilize the same apis providing a common interface for modeling the environment.
in addition v arvel comes equipped with about pre defined stubs for standard libraries e.g.
strings along with embedded assertions f or different checkers.
tab.
ii shows some of the stub apis.
the assert function is part of the c library.
it is treated as a check.
the assume function blocks the execution unless the assumed expressio n138table ii stub api to specify environment precond expr c expr.
expr is a precondition.
assert expr expr is asserted.
assume expr expr is assumed.
nondet e1 e2 a nondet.
integer in .
setstrlen p e insert the assignment strlen p e. setvalidity p e assignment ptrval p e. is valid.
the precondition function precond has two different meanings depending on where it is encountered.
it is used as an assumption when it is encountered at the entry function of the analysis.
if encountered in a non entry function it i s treated as a check.
this corresponds to the natural semantic s of a precondition in annotation checking.
b. counterexample guided environment refinement the ceger framework uses a software model checker in two ways the model checker provides a concrete witness trace showing the control flow and the data values at each program point in the execution leading up to the error.
this trace aids the user considerably in determining whether the witness is a false alarm.
the model checker suggests an environment constraint to rule out a false alarm by propagating weakest preconditions backwards along the trace starting from the violation and ending at the function interface.
in our experience users find it considerably easier to improve upon e.g.
generalize a suggested constraint rather than derive a suitable constraint from scratch.
we consider refinement of the preconditions for each function.
let fbe the existing environment precondition corresponding to a function fin the code.
for each witness w let wbe the weakest precondition computed at the function interface starting from the assertion violation.
when a wit ness wis marked as a false alarm by the user there are two possible diagnoses in the witness starting from function f we observe an assertion violation in the code that is dependent on the input environment.
in this case fis weak.
we term such witnesses as type witnesses.
in the witness starting from another function g the precondition f treated as an assertion is violated when callingf.
in this case either fis strong or gis weak.
we term such witnesses as type witnesses.
to eliminate a type witnessw we refine the precondition ffor the entry function fby conjoining it with w prime f f w. this suffices to eliminate wfrom future iterations of the verifier.
in many cases this also rules out other relat ed witnesses to the same assertion from alternative program pa ths.
however note that prime fis presented to the user as a suggestion.
in many cases the user may be able to rule out additional fals e witnesses by weakening prime ffurther.
to handle a type witness we re run the analysis starting from function gand including the code for function f buttable iii descriptions of benchmarks .
name version loc analyzed functions thttpd .25b .7k genericnqs .
.
pre1 .1k libupnp .
.
.9k product p1 .5k product p2 .6k table iv results of dc2 experiments .
success ratio reports the percentage of functions successfully verified within the given timeouts.
likely bugs reports the number of bugs that were communicated to develop ers with numbers in parenthesis representing the number of interpro cedural bugs.
success ratio likely bugs w o dc2 w dc2 w o dc2 w dc2 thttpd genericnqs libupnp product p1 product p2 excluding the assertion from the precondition for f. if the analysis succeeds in producing a violation inside function f that is deemed to be false by the user then gis weak.
therefore f s precondition is used to refine gas a type1witness.
if the analysis fails the user may choose to treat the original witness was a type witness to refine g or relax the precondition of fsuch that prime f s where sis the concrete state in the witness causing the violation of f. such a relaxation will also eliminate the witness wfrom future iterations of the verifier.
note that since the possibility of a witness being false is arbitrated by the user mistakes by the user can lead to misse d bugs.
in particular the user may introduce a fallacious env ironment assumption such as f false proving all properties trivially.
the static analysis can detect such cases and war n the user.
although ceger is not completely automatic it is nevertheless quite effective in our experience at enabling users to discover real bugs on large code bases.
vi.
e xperiments this section describes experiments conducted on open source and proprietary software projects.
first we highli ght the usage of dc2 on several benchmarks and show the effectiveness of scope bounded model checking to find interestin g interprocedural bugs.
then we present some experiments on counterexample guided environment refinement.
a. dc2 experiments we applied v arvel to five benchmarks including two industry programs from nec with and without dc2.
the description of the benchmarks is shown in tab.iii.
due to tim e limitations especially for investigating results we dec ided to employ only a part of each benchmark for the experiments.
the column loc shows the sizes of modules analyzed by varvel .
product p1is a developer tool whose original loc is 100kand product p2is a business application software whose original loc is k. for the experiments the dc2 depth was set to i.e.
each scope consisted of two levels of function calls in the139urlconfig.c l1 err code config description doc doc ipaddr port root path l2if err code !
upnp e success gotoerror handler l3 err code calc alias alias root path new alias urlconfig.c intconfig description doc ixml document doc const char ip str char root path str ... l4 err code ixmlnode appendchild rootnode ixml node element l5if err code !
ixml success gotoerror handler l6 textnode ixmldocument createtextnode doc char url str.buf l7if textnode null gotoerror handler ... root path str is updated here.
error handler l8if err code !
upnp e success ixmlelement free newelem ent ... l9returnerr code fig.
.
a subtle inter procedural bug in libupnp .
.
.
call graph and we did not change any preconditions or stubs generated automatically by s pectackle .
the analysis was performed with a time bound of 800s and the results are shown in tab.
iv.
as expected we observed that the success ratio percentage of functions successfully verified withi n an allotted time improved with dc2 for all benchmarks.
clearl y scope bounding enabled application of v arvel on even those functions with large call graphs.
further the number of detected bugs also increased with dc2.
interestingly many of the bugs found without dc2 were intraprocedural.
on the other hand v arvel was able to find deep interprocedural bugs with dc2.
one such previously unknown bug in libupnp is shown in fig.
.
it was only found when we utilized dc2.
the variable root path is supposed to be initialized by config description doc atl1.
if the initialization fails it is designed to jump to an error handler at l2.
however v arvel found a case where the initialization fails and the returned error code is upnp e success .
the witness generated by varvel indicates that if ixml success is assigned to err code atl4andixmldocument createtextnode returnsnull then the execution will proceed to the error handler without changing err code .ixml success andupnp e success have the same value of .
thus uninitialized root path will be passed as a parameter to thecalc alias function l3 which checks that the corresponding parameter is not null .
note this bug is produced even without analyzing ixmlnode appendchild and ixmldocument createtextnode which are out of scope of the verification run.
b. ceger experiments in this section we only present v arvel experiments that do not utilize s pectackle .
this allows us to highlight the advantage of ceger independently of dc2.
however this also means that these experiments do not take full advantage of dc2 and thus result in an increased rate of false alarms.table v data from initial run of the zitser et al .
benchmarks .legend ai abstract interpretation mc m odel checking prf.
proofs wit.
w itnesses t o timeout.
code size kloc analysis result properties total avg max total ai prf.
mc prf.
wit.
t o .
.
table vi analysis of witnesses from zitser et al .
benchmarks status wit wit plausible bugs missing function getopt optarg .
.
.
missing function dn skipname missing functions setpwent getpwent modeling limitation array string elements zitser benchmark suite.
we ran v arvel on some public benchmarks put forth by zitser et al.
to evaluate the performance of academic and commercial static analysis tools .
the benchmark suite consists of 25programs which form a part of a larger open source application with known overflow bugs involving arrays and strings.
we allowed each instance to run for 1800s.
the programs themselves range in size from 5kloc after preprocessing forward slicing and instrumentation .
table v shows the results of running the analysis on these examples.
note that we are able to prove a majority of the properties statically.
the model checker produces 90concrete violations.
each violation was manually examined by one of the authors.
of the 90witnesses found 7were found to be real violations based on the witness.
the remaining 83were classified into 4categories.
table vi shows an analysis of these violations wit .
note that missing preconditions are not a problem for these benchmark s since they contain drivers that initialize the environment .
indeed a large number of false positives arose due to missin g functions that did not have any stubs.
overall about one man hour was spent in analyzing all the witnesses in the first run.140table vii result data for two industrial case studies using ceger func witnesses pre stub bugs kloc tions r1 r2 conds pv ab p3 p4 our subsequent iteration included stubs for the missing functions.
the stubs were created by consulting the descrip tion of function behavior specified by the manuals.
table vi shows the results of the second iteration wit .
this iteration results in a total of 13witnesses of which 10were found to be plausible.
industrial benchmarks.
next we applied v arvel on a small embedded software application in industrial use wi th 6kloc.
the application lacks a single main function.
therefore we ran the analysis on each entry function in the source.
no partitioning was required for this applicati on.
we first used the pointer validity checker.
the check ran in 60minutes and produced 15witnesses in all.
one of the authors analyzed all 15witnesses in 30minutes.
it yielded one plausible bug where the result of a malloc was dereferenced without a check.
we formulated preconditions based on the other witnesses.
these preconditions covered both pointer and array overflow checks.
overall the entire analysis involve d 3rounds of the validity checker and 4rounds of the array overflow checker requiring 200minutes to run.
the resulting witnesses revealed 7bugs overall.
we helped in conducting case studies on two larger embedded software projects p3and p4.
the study involved the use of v arvel by two engineers who received tool training and documentation but were not verification exper ts.
each study was time limited 6person days for p3and person days for p4.
table vii summarizes the results.
each analysis carried out two iterations with the pointer validi ty checker followed by two iterations using the more complex array bounds checker.
the first iteration used the default environment assumptions.
subsequently the witnesses wer e all examined and preconditions and stubs were written for t he next iteration.
table vii shows the number of witnesses in th e first round using default environment assumptions r1 and the number of witnesses after ceger r2 .
it also classifies the environment assumptions into preconditions and missin g stubs written by the engineers.
these preconditions and stu bs are shared by multiple entry functions.
finally we report o n the number of real bugs for pointer validity pv and array overflows ab only about a quarter of ab witnesses were examined by the engineers .
vii.
r elated work varvel uses abstract interpretation and bit precise bounded model checking for analysis.
approaches based on abstract interpretation have been used in tools such as polyspace astr e c global surveyor .
these tools focus on checking embedded applications with special featu res such as simple aliasing no dynamic allocation simple cont rol flow and no recursion.
however our approach is designed tobe more general purpose.
the cbmc tool due to clarke et al.
also uses bit precise bounded model checking but d oes not use abstract interpretation and has limited scalabilit y. the coverity verifier has been successfully applied to large industrial as well as open source projects but an experimen tal comparison is outside the scope of this paper.
abstraction refinement.
cegar counterexample guided abstraction refinement was proposed and successfully used in many efforts .
in particular it has been used wi th predicate abstraction and refinement in the slam project with continuing improvements in industry applications .
our ceger approach is very much inspired by cegar.
whereas other cegar efforts use spurious counterexamples to refine the abstract model of the program we use them only to refine the calling environment of the function being verifi ed or to model missing functions.
ceger is not completely automated and relies upon the user to determine whether the reported witness is a false alarm.
scope bounding.
several approaches utilize scope bounding to achieve better scalability in verification .
taghdiri and jackson proposed a cegar like refinementbased method to find bugs in java programs .
it iterativel y expands the scope of called functions by utilizing informat ion from counterexamples and continues until it finds a proof or a witness that does not rely on any unconstrained value.
babi c and hu proposed structural abstraction that gradually relaxes the boundary of verification by inserting function s ummaries on demand for a given property.
in contrast dc2 works for all properties within a statically determined scope.
i nstead of expanding the scope iteratively it refines the precondit ions and stubs for cut off functions based on witness traces.
automatic environment generation.
recently numerous formalisms have focused on automatically generating model s of the environment based on automatic sound abstraction specification mining automata learning and so on.
o ur environment generation is based on a light weight whole pro gram analysis where we are occasionally unsound.
the main motivation is to suppress false alarms and to capture condit ions spanning deeply nested function calls to find interprocedu ral bugs.
automatic contract inference.
techniques for synthesizing contracts automatically from pointer indirections and ass ertions in the code have also been proposed by moy and marche and by cousot et al.
.
our approach for precondition synthesis is similar in spirit but differs ra dically on the choice of abstract domains a our approach is mostly syntactic in nature based on matching expressions in the co de and b our handling of pointer indirection is simple albei t unsound in theory.
however the preconditions inferred seem t o be accurate in practice.
furthermore a wrong precondition can be detected by v arvel as a type or a type witness.
our simpler approach can infer preconditions for large project s with 500kloc and beyond in a matter of minutes.
this design choice works well in combination with precise modeling in ou r model checker.141annotation checking.
our work also relates to annotation checking tools that utilize function interface specificati ons e.g.
esc java and more recently vcc .
although these efforts can handle complex specifications they require sig nificant manual effort to write them and support for automatic annotation inference or refinement is largely absent.
tools such as salinfer provide some automated annotation inferen ce for runtime errors.
in contrast to standard annotation chec king note that dc2 handles multiple levels of function calls in the analysis thereby utilizing more precise interprocedu ral contexts for finding bugs.
viii.
c onclusions we presented the dc2 framework for program analysis supported by automated specification inference.
our experimen tal results for dc2 in v arvel support our experience that a software model checker can accommodate the requirements from industry by carefully designing and engineering its applic ation.
we are investigating other directions to improve dc2 such a s adaptively tuning scope bounding based on program metrics and prior verification runs.
ix.
a cknowledgments we would like to acknowledge the assistance and support of shinichi iwasaki san and fusako mitsuhashi san from nec corporation and mustafa hussain and naveen sharma from nec hcl systems technologies during the development of varvel .