an empirical analysis of the co evolution of schema and code in database applications dong qiu bixin li southeast university china dongqiu bx.li seu.edu.cnzhendong su university of california davis usa su cs.ucdavis.edu abstract modern database applications are among the most widely used and complex software systems.
they constantly evolve responding to changes to data database schemas and code.
it is challenging to manage these changes and ensure that everything co evolves consistently.
for example when a database schema is modified all the code that interacts with the database must be changed accordingly.
although database evolution and software evolution have been extensively studied in isolation the co evolution of schema and code has largely been unexplored.
this paper presents the first comprehensive empirical analysis of the co evolution of database schemas and code in ten popular large open source database applications totaling over 160k revisions.
our major findings include database schemas evolve frequently during the application lifecycle exhibiting a variety of change types with similar distributions across the studied applications overall schema changes induce significant code level modifications while certain change types have more impact on code than others and co change analyses can be viable to automate or assist with database application evolution.
we have also observed that of the schema changes happened in of the tables while nearly of the tables did not change and referential integrity constraints and stored procedures are rarely used in our studied subjects.
we believe that our study reveals new insights into how database applications evolve and useful guidelines for designing assistive tools to aid their evolution.
categories and subject descriptors h. .
distribution maintenance and enhancement h. .
logical design schema and subschema general terms language measurement keywords co evolution database application empirical analysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
.
introduction a database application is a software system that collects manages and retrieves data which are typically stored in a database managed by a database management system dbms and organized w.r.t.
database schemas .
for example most online services are powered by database applications.
wikis social networking systems sns web based content management systems cms mailing systems enterprise resource planning systems erp are all database applications.
as figure illustrates a program needs to obey the structure of the data organization defined by a schema when it accesses the data.
namely a schema is a mediator that manages the interactions between code and data bridging their gap.
software systems are subject to continuous evolution due to modified system requirements database applications are no exception.
cleve et al.
observe that little work exists on understanding the evolution of database applications considering both data and code.
different from traditional applications the evolution of database applications is more complex.
for example consider a system that uses a table user to store both user authentication information and other personal data.
now the system requirements change and the system needs to store user authentication information and personal data separately.
thus the original table user must be split into two new tables say user login anduser details .
data and application code must be synchronized to be consistent with the new schemas .
first the original data organization should be migrated to the new one defined by user login anduser details .
second the original application code that accesses data in user must be modified to correctly access the newly organized data in user login anduser details .
figure illustrates these two types of co evolution in database applications data co evolve with schemas and code co evolves with schemas .
the first type of co evolution involves three main tasks i predicting and estimating the effects before the proposed schema changes are performed ii rewriting the existing dbmslevel queries to work on the new schemas and iii migrating data to the new schemas .
the second type involves two main tasks i evaluating the cost of reconciling the existing code w.r.t.
the new schemas before any schema changes and ii locating and modifying all impacted code regions after applying the schema changes.
the database community has addressed the first co evolution problem gracefully to support automatic data migration and dbmslevel query rewriting to operate on the new schemas .
however little work has considered the second co evolution problem.
its difficulties are twofold.
first query updates and data migration for the first problem are done by db administrators dba who have the domain knowledge.
in contrast the application developers who have different level of database knowledge may not precisely capture the whole evolution process of the database structure.
in6xumxgsy gzg 9inksg 6xumxgsy gzg 9inksg gzghgyk vvroigzout gzghgyk vvroigzout k ur k k ur k somxgzk giikyy giikyy iu k ur k iu k ur k figure the evolution of database applications.
particular they may not fully grasp what the dba intends through a schema change.
when the schema is modified if application developers do not understand why and how the schema changes they can have difficulties in correctly evolving the application code.
second schema changes query updates and data migration are straightforward as they are done at the same language level typically using data definition language ddl and data manipulation language dml .
in contrast database schema changes and application code changes are at different levels.
this is a much more challenging problem because how schema changes impact code is not as direct.
in this paper we focus on the second problem and perform a large scale empirical study on ten popular database applications to gain insights into how schemas and application code co evolve.
in particular we study the applications long time evolution histories from their respective repositories to understand whether database schemas evolve frequently and significantly how schemas evolve and how they impact application code.
furthermore we present guidelines for developing automated tool to aid schema and code co evolution based on our observations from the study.
to the best of our knowledge this is the first work that attempts to empirically understand how application programs co evolve with the schemas in large popular database applications.
the remainder of this paper is organized as follows.
section describes our methodology for the study including its context research questions and the process for extracting information needed for the study.
section presents our detailed results followed by section that further discusses the results.
next we discuss possible threats to validity section and survey related work section .
finally section concludes with a discussion of future work.
.
methodology this section presents basic information on the ten database applications used in our study the three research questions we consider and the process we use to perform the study.
.
context description we selected open source database applications from various domains including gallery management project management cms wiki shopping cart webmail system and erp.
they are popular both among developers and users.
for example both joomla!
and prestashop won the open source award1in .
table s first columns report each application s basic description and popularity.
for all ten applications subversion svn was selected as their default version control system because svn is one of the most popular version control systems in the open source commu1 table also summarizes the applications evolution histories extracted from their respective svn repositories.
the 4th 5th and 6th columns list for each project its development cycle the number of stable releases and revision range in the selected lifecycle that we consider.
most projects are still active and have frequent updates.
only dotproject is no longer updated.
for e107 andtypo3 we only selected one of their finished development trunks.
the 7th column shows each project s total number of revisions.
mediawiki s revisions form only a part of its revision range since its repository also hosts other projects thus we kept only those revisions for mediawiki .
the 8th and 9th columns show two ranges for each project respectively one for schema size the least and greatest and the other for application code size the smallest and largest .
the ranges were computed based on information from the 5th column.
we use the number of tables to measure schema size and lines of code loc to measure code size.
.
research questions at a high level our study aims to answer how database schemas and program co evolve in database applications.
to this end we designed three specific research questions for investigation rq1 how frequently and extensively do database schemas evolve?
this rq helps answer how often and how much schemas change across different versions to understand whether they intensively evolve during an application s development and maintenance process.
rq2 how do database schema evolve?
this rq helps analyze all possible schema changes in database applications to understand what schema change types usually occur in practice.
furthermore we are interested in the distribution of schema changes w.r.t.
schema change type to see whether some change types appear more frequently than others.
rq3 how much application code has co changed with a schema change?
this rq helps quantify schema changes real impact on application code.
using change history from the repository we associate changes in source lines with schema changes toestimate their impact on code.
we are also interested in whether certain schema change types tend to have more impact on code than others.
in addition based on the answers to the three above rqs if indeed schemas evolve frequently and extensively and schema changes can significantly impact code it should be important to develop tools to aid developers in evolving database applications.
from our results of empirical analysis can we provide some evidences or guidelines on helping people efficiently evolve database applications?
.
analysis process we now describe the steps we use to extract the necessary information from project repositories.
locate schema files the first step extracts the schema files.
we observe that most schema files have the .sql suffix although some projects e.g.e107 specify schema information using embedded sql statements in phpsource files.
to ascertain that we do not omit any schema files we manually trace the schema files even if their locations or names have been modified.
extract db revisions the second step identifies db revisions which are revisions commits that contain modifications to schema files.
in svn we can easily retrieve the paths of all changed files in any revision if a schema file is among the changed files of revision i we say iis a db revision.
extract valid db revisions once we have extracted the db revisions in each project we need to filter those containing onlytable the ten studied database applications and their evolution history.
project description d l m life cycle releasesrevision range revisions tables loc k changed loc m coppermine web gallery .
.
dotproject project mgmt.
.
.
e107 enterprise cms .
.
joomla!
cms .
.
mediawiki wiki .
.
prestashop online store .
.
roundcube webmail .
.
tikiwiki wiki cms .
.
typo3 enterprise cms .
.
weberp business mgmt.
.
.
unrelated schema changes we are not interested in i.e.
we need to select only the valid db revisions for further analysis.
we define a valid db revision as a db revision that does not only include the following types of schema changes syntax change .
there are two main kinds of syntax changes optional syntactic structure conversion andsyntax error fix .
most syntax descriptions in different implementations of ddl have several options which leads to the first kind of syntax changes.
this situation often occurs when multiple developers work on the same code but favor different syntax.
for syntax errors we have observed that redundant commas and quotation marks are most common syntax errors in ddls examining the revision histories of the ten projects.
figures 2a and 2b show concrete examples for the two cases.
comment change .
a comment change refers to a modification of a schema file s comments.
format change .
format changes have three main types i adjusting the position of a table in a schema file e.g.
ordering the tables alphabetically w.r.t.
table names ii adjusting the position of columns in a table e.g.
moving a newly added column from the very end to a different position perhaps for better understanding and iii traditional formatting e.g.
indentation adding or deleting blank lines and whitespace .
although a format change has no effect on the content of a schema file it can be detected by text differencing algorithms from the repository and the corresponding revision is considered a db revision.
data sensitive change .
a data sensitive change refers to a modification of the data stored in the database.
mostly dml is used for inserting deleting and updating data in a database.
some projects such as joomla!
put dml and ddl in the same file which leads to some db revisions contain only data sensitive changes.
since this work focuses on schema code co evolution we do not consider data sensitive changes.
dbms related change .
dbms related changes are mainly caused by version migration of dbms used in database applications.
figure 2c shows an example where the change was made to satisfy the upgrade of the mysql version.
system related change .
system related changes refer to modifications that are irrelevant for schema changes but caused by the implementation of database applications.
figure 2d shows an example where newly added comment wgdbprefix was for runtime replacement by system programs to avoid name conflicts if multiple versions of database coexisted.
rollback .
suppose a schema file evolves from revision i 1to i and later is recovered to revision i 1in revision j. if revision jis judged as a rollback of revision i we filter both iandjas unrelated db revisions.
identifying rollbacks needs both the schema change history and log information in the repository.
extract atomic changes after having identified the valid db revisions for each project we extract all schema changes by manually cf name cf value revision remove user id primary key user name revision tables.sql mediawiki wgdbprefix user id user name revision user id user name engine innodb revision a alternative syntactic structure conversion b syntax error fix c dbms related change d system related change figure examples of invalid db revisions.
comparing schema files of contiguous valid db versions.
that is we try to understand how schemas evolve semantically by examining the textual differences between two revisions and the relevant log messages.
although many tools such as mysqldiff used in support difference extraction between two schema versions they have the following disadvantages.
first only syntax level schema changes can be obtained semantic level information that how schema actually evolve is omitted in the automatic analysis process.
consider the example in figure .
mysqldiff running on revisions and of mediawiki outputs that column user right is deleted from table user and a new table user rights has been created.
the tool does not recognize the relationship between the deleted column user rights and the added table user rights .
a better interpretation of this evolution is that table user is split into two sub tables user anduser right .
this precise semantic information is quite important since it can guide us better understand the code level changes.
second these tools are incapable of extracting the differences if any schema file contains syntax errors or system related code also see our earlier discussions on syntax change andsystem related change since they need to execute the schema scripts in a database engine to create concrete tables and relations.
we noticed many syntax and system related changes in the ten projects making it impossible to generate precise schema changes for all revisions.
before extracting schema changes we need to provide a category of schema change types.
ambler et al.
summarized all possible schema changes during evolutionary database development.
they included six high level categories transformation structure refactoring referential integrity refactoring architecture refactor table low level categories of atomic change types for database schema evolution.
ref.
atomic change category ddl mysql implementation a1 add table transformation create table t name a2 add column transformation alter table t name addc name a3 add view transformation create view v name as... a4 drop table structure refactoring drop table t name a5 rename table structure refactoring alter table o t name rename n t name a6 drop column structure refactoring alter table t name drop column c name a7 rename column structure refactoring alter table t name change column o c name n c name a8 change column datatype structure refactoring alter table t name modify column c namec def a9 drop view structure refactoring drop view v name a10 add key structure refactoring alter table t name add key k name a11 drop key structure refactoring alter table t name drop key k name a12 add foreign key referential integrity refactoring alter table t name add foreign key fk name ... a13 drop foreign key referential integrity refactoring alter table t name drop foreign key fk name a14 add trigger referential integrity refactoring create trigger trig name ...on table t name ... a15 drop trigger referential integrity refactoring drop trigger trig name a16 add index architectural refactoring alter table t name add index idx name a17 drop index architectural refactoring alter table t name drop index idx name a18 add column default value data quality refactoring alter table t name modify column c name set default value a19 drop column default value data quality refactoring alter table t name modify column c name drop default a20 change column default value data quality refactoring alter table t name modify column c name set default value a21 make column not null data quality refactoring alter table t name modify column c name not null a22 drop column not null data quality refactoring alter table t name modify column c name null a23 add stored procedure method refactoring create procedure pro name ... a24 drop stored procedure method refactoring drop procedure pro name user id user name user rights user password create table user rights user id int unsigned not null user rights tinyblob not null default unique key user id user id pack keys revision tables.sql mediawiki figure an example to illustrate the weaknesses of automatic schema difference extraction tools.
ing data quality refactoring andmethod refactoring .
the first is a non refactoring transformation that changes the semantics of the schema while the other five are refactoring transformations.
to extract schema changes as accurately as possible we further divide the six high level categories into a more fine grained classification that contains atomic schema change types.
they are listed in table .
most of our atomic change types are adopted from ambler et al.
.
to be more complete we have also introduced additional ones such as a8 change column datatype a10 add key a11 drop key a14 add trigger a15 drop trigger a17 drop index a20 change column default value a23 add stored procedure and a24 drop stored procedure .
all possible composite schema change types such as split a table or move a column proposed by ambler et al.
can be represented as a sequence of atomic changes using the atomic ones.
another reason we selected these atomic change types is that each can be simply translated into ddl thus can be applied on schema files directly.
in the 4th column of table we show an example how atomic changes are represented by ddl based on the implementation of mysql .
co change analysis after having identified all possible atomic changes we analyze the real impact caused by these atomic schema changes by mining a project s version control history.
different from traditional change impact analysis which tries to identify the potential consequences of a change or estimate what needs to be modified to accomplish a change we want to calculate the impact that has been triggered by schema changes.
co change analysis has been effectively applied on traditional software artifactstable results of db revision and schema change extraction.
project total db rev.
valid db rev.
valid total atomic changes atomic valid coppermine .
.
dotproject .
.
e107 .
.
joomla!
.
.
mediawiki .
.
prestashop .
.
roundcube .
.
tikiwiki .
.
typo3 .
.
weberp .
.
total .
.
to estimate a change s impact area from co change histories of similar previous changes.
adopting the same methodology we use a database application s co change history to estimate the application code area affected by a schema change.
thus we approximate the set of schema driven changes with source code co changed with schema files in the same valid db revision.
svn can tell which files changed together in one revision so when a schema file changes we can easily get all files co changed with the schema file.
for every pair of adjacent revisions iandi 1where i 1is a valid db revision we compare them to identify addition deletion change of co changed source code.
this analysis is automatic we designed a simple difference extractor to calculate changed source lines excluding comments using static analysis.
we have also performed a manual in depth examination of randomly selected samples to guarantee the validation of our design choice.
.
detailed study results we first present results obtained from the first two steps of the analysis.
table reports the summary statistics of the extracted information.
the 2nd column lists the number of each application s db revisions while the 3rd column lists the number of valid db revisions for each project.
the 4th column shows that the ratio of valid over total revisions falls mostly in the range.
joomla!
has a much lower ratio because dmls are involved in the same schema file with ddls making data sensitive changes cover a large fraction of invalid revisions.
the 5th column lists the total number offigure the evolution trend of tables columns in the studied projects.
the x axis of each sub figure shows the progression of the corresponding project s schema evolution and the y axis displays the accumulative percentages of the numbers of tables columns w.r.t.
themaximum numbers of tables columns in the schema files.
table frequency of schema evolution w.r.t.
release and year.
project valid release atomic release valid year atomic year coppermine .
.
.
.
dotproject .
.
.
.
e107 .
.
.
.
joomla .
.
.
.
mediawiki .
.
.
.
prestashop .
.
.
.
roundcube .
.
.
.
tikiwiki .
.
.
.
typo3 .
.
.
.
weberp .
.
.
total .
.
.
.
atomic changes the 6th column lists the average number of atomic changes per valid revision which falls mostly in the range.
next we use our study results to address the three research questions section .
.
.
rq1 how frequently and extensively do schemas evolve?
first we measure how frequently schemas evolve by examining the occurrences of schema changes w.r.t.
each project s lifecycle.
in particular for each stable release year we calculate the average number of valid db revisions atomic schema changes.
table reports this information.
for each release there are around valid db revisions and atomic schema changes.
for each year there are around valid db revisions and atomic schema changes.
although the numbers in each column differ due to the projects varying levels of development activities and different definitions of stable releases they provide solid evidence that schemas evolve frequently.
second we measure how extensively schemas change by examining the trend on schema size changes.
to this end we collect the number of tables columns in each valid revision to see how much schemas evolve.
figure shows this trend information.
the results clearly show that schemas increase in size in most projects overtable growth and change rates of schema size.
projecttables columns ie ae de gr cr ie ae de gr cr coppermine dotproject e107 joomla!
mediawiki prestashop roundcube tikiwiki typo3 weberp time.
two projects e107 andjoomla!
exhibit frequent fluctuations.
to facilitate a more precise evaluation we use two metrics growth rate gr and change rate cr gr added elements ae deleted elements de initial elements ie cr added elements ae deleted elements de initial elements ie the different elements in equations and should be replaced respectively with tables and columns when calculating the grand crfor tables and columns separately.
the grandcrof schema size in each project are shown in table .
results schemas evolve frequently on average atomic schema changes occurred per release and atomic schema changes occurred per year across the ten projects.
the size of schemas in most projects grew significantly the grof tables in of the projects exceeded the crof tables in projects exceeded .
although the number of tables in some projects increased slowly or even decreased such as e107 they show frequent fluctuations.
we have observed very similar trend for columns as compared to tables .
seven projects schema sizes reached of their maximum values in about of the selected project lifecycle which indicates that more database related features were imported in the projects early development phases.figure distribution of atomic changes w.r.t.
the high level schema change categories.
in summary database schemas evolve significantly during the development lifecycle of database applications.
next we examine the co evolution of application code caused by schema changes.
.
rq2 how do database schemas evolve?
to answer rq2 we analyze which schema change category each atomic change belongs to.
figure shows the percentages for the six schema change categories transformations trans structure refactoring sr referential integrity refactoring rir architectural refactoring ar data quality refactoring dqr and method refactoring mr .
trans sranddqr occurred the most frequently.
these three categories cover more than of schema changes across all projects and over across projects.
ar occurred in projects and ririn only three which covered only a very small part.
arandrirwere not often used and mrdid not occur in any of the projects.
it is interesting to note that tikiwiki androundcube have much higher percentages of dqr compared to the other applications.
this was due to substantial changes happened in certain versions of these two applications.
for example revision of tikiwiki removed the default values for most of the columns affecting .
of all dqr schema changes.
to understand the concrete type of each atomic change we classified all collected schema changes w.r.t.
their low level change categories section .
table shows the distributions for all atomic changes.
we have highlighted in boldface the five most frequent low level categories in each project.
a1 add table a2 add column and a8 change column datatype were the most active atomic schema change types across the projects.
a4 drop table a6 drop column a7 rename column a18 add column default value and a19 drop column default value occurred in all projects but relatively infrequently in several projects.
although a10 add key a11 drop key a16 add index a17 drop index a20 change column default value and a22 make column not null appeared in all projects they were infrequent in many projects.
a5 rename table and a21 make column not null happened only occasionally in most of the projects.
in particular a12 add foreign key and a13 drop foreign key rarely appeared and only showed up in projects.
this is because foreign key constraints were rarely used in schema definitions for performance concerns.
the remaining six atomic change types a3 add view a9 drop view a14 add trigger a15 drop trigger a23 add stored procedure and a24 drop stored procedure never occurred in any of the projects there were no view related trigger related and procedure related definitions in the schema files.
it is interesting to figure distribution of addition deletion change on schema.
observe that prestashop has much higher percentage of a8 change column datatype .
this was because revision changed the column datatype from integer toint to save storage space covering .
of all schema changes.
we are also interested in the frequencies of addition deletion andchange operations on schema content.
figure depicts the distribution.
it shows that addition was the most frequent schema operation in of the projects.
it accounted for about of the operations in all projects and over in five projects.
moreover addition andchange accounted for around of the operations while deletion operations occurred less frequently across most projects.
results three high level schema change categories trans sr anddqr covered most schema changes aroccurred relatively infrequently in some of the projects.
at the low level add table add column andchange column datatype were the most frequent atomic change types.
the data also confirms that referential integrity constraints such as foreign key and trigger and procedures such as stored procedure are indeed rarely used in practice.
addition andchange accounted for most of the schema evolution.
.
rq3 how much application code has cochanged with a schema change?
without a careful and laborious manual analysis it is difficult to calculate the precise impact caused by a schema change.
neither is it feasible to perform the manual analysis at scale.
thus we designed our study to estimate impact using the related information from project repositories.
co change analysis has been effectively used on traditional software artifacts through large scale experiments .
to confirm the validity of this approach for our setting we examined two questions via a careful non trivial manual study how many valid db revisions contain the co change information of schema and code?
and how much code level change is truly caused by schema changes?
the first question is to understand whether and how often schema and code changes are committed together and whether co change history information is useful.
the second question helps further explore the accuracy of co change information as a means for estimating the code level impact of a schema change.
to answer the questions we selected uniformly at random of the valid db revisions from the total valid db revisions and manually analyzed the co changed information.
here we use lines of changed source code to represent the application change.
first we need to analyze and understand how co change information is present in the evolution history.
suppose ris the set of all valid db revisions ris the current one under analysis and cr represents all changes committed in this revision.
schema changestable distribution of atomic schema changes w.r.t.
the low level categories of schema change types.
category ref.
coppermine dotproject e107 joomla!
mediawiki prestashop roundcube tikiwiki typo3 weberp transa1 .
.
.
.
.
.
.
.
.
.
a2 .
.
.
.
.
.
.
.
.
.
a3 .
.
.
.
.
.
.
.
.
.
sra4 .
.
.
.
.
.
.
.
.
.
a5 .
.
.
.
.
.
.
.
.
.
a6 .
.
.
.
.
.
.
.
.
.
a7 .
.
.
.
.
.
.
.
.
.
a8 .
.
.
.
.
.
.
.
.
.
a9 .
.
.
.
.
.
.
.
.
.
a10 .
.
.
.
.
.
.
.
.
.
a11 .
.
.
.
.
.
.
.
.
.
rira12 .
.
.
.
.
.
.
.
.
.
a13 .
.
.
.
.
.
.
.
.
.
a14 .
.
.
.
.
.
.
.
.
.
a15 .
.
.
.
.
.
.
.
.
.
ara16 .
.
.
.
.
.
.
.
.
.
a17 .
.
.
.
.
.
.
.
.
.
dqra18 .
.
.
.
.
.
.
.
.
.
a19 .
.
.
.
.
.
.
.
.
.
a20 .
.
.
.
.
.
.
.
.
.
a21 .
.
.
.
.
.
.
.
.
.
a22 .
.
.
.
.
.
.
.
.
.
mra23 .
.
.
.
.
.
.
.
.
.
a24 .
.
.
.
.
.
.
.
.
.
scrand code changes ccrcorrespond to co change information in revision rwherescr crandccr cr.
the actual code changercris the evolved code completely caused by scr.
we havescr6 ?where bothccrandrcrcan be empty.
there are four possible co change situations s1 ccr ?andrcr6 ?.
that is rcroccurs before after revision r i.e.
they were not committed in the same revision.
s2 ccr ?andrcr ?.
this shows that schema changes do not impact code.
in this case the co change information is still effective although no co changed code is provided.
s3 ccr6 ?andccr rcr6 ?.
in this case the co changed code was committed together in revision rand contained the actual code change.
if ccr rcr all of the co changed code was caused by schema changes.
otherwise the co change history included other changes and may lead to inaccurate information.
s4 ccr6 ?andccr rcr ?.
in this case although the code changes were committed together they were not related to the schema changes.
that is all information provided by the co change analysis is incorrect.
figure 7a shows the distributions of four possible co change situations.
regarding the first question s2 and s3 provide effective co change information.
figure 7a shows that around of all valid db revisions provided useful co change information.
in addition the data for s2 showed that about of valid db revisions did not need any code changes as they had no impact on code.
for the 2nd question we use precision defined below to estimate how much of the co change history contains useful information precision r jrcr ccrj jccrj it is obvious that for any revision rthat belongs to s1 and s4 the precision is .
that is about valid db revisions did not provide useful co change information.
for the other valid db revisions figure 7b shows their precision data.
our manual study shows that over of valid db revisions belonging to s2 and s3 have precisions over and over have precisions over .
in particular about have precision.
figure results on the two manual study questions.
our results confirm that as for traditional software artifacts using co change analysis to understand the impact of schema changes is indeed practical and effective.
hence we study this question through co changed source code lines within the same valid db revision.
we have designed and implemented a tool that automatically extracts the co changed source code lines w.r.t.
schema changes.
table lists respectively the minimal maximum average and median number of source code lines co changed with each atomic change and valid db revision.
for each atomic change around lines were changed on average when it was performed.
for each valid db revision which typically contains atomic changes around source lines were changed which were quite significant changes.
we observed earlier that a valid db revision usually involves multiple categories of schema changes.
the summary statistics may not be informative enough since the impact on applications caused by different categories of schema changes can be quite different.
to better understand the impact caused by schema changes we calculate the source code lines co changed with each category of schema changes separately.
however it is difficult to extract the amount of impact triggered by each category of schema changes without a manual analysis.
as a practical alternative we adopt multivariate linear models to estimate the co changed code linestable changed code size w.r.t.
valid revisions and atomic changes.
projectper valid db revision per atomic change min max k x x min max k x x coppermine .
.
dotproject .
.
e107 .
.
joomla!
.
.
mediawiki .
.
prestashop .
.
roundcube .
.
tikiwiki .
typo3 .
.
weberp .
.
table estimated changed code size w.r.t.
high level schema changes.
project trans sr rir ar dqr mr r2 coppermine na .
dotproject na .
e107 na .
joomla!
na .
mediawiki na .
prestashop na .
roundcube na .
tikiwiki na .
typo3 na .
weberp na .
with each schema change category.
suppose yrepresents the total number of co changed code lines in one valid db revision xi represents the number of schema changes of high level category i ican be trans sr rir ar dqr ormr irepresents the corresponding co changed code lines driven by schema change categoryi we have y x i ixi where i .
to guarantee all coefficients are positive we use non negative least squares to compute the coefficients.
we also provide the adjusted r squared to describe how well the calculated regression line fits the data set.
table shows the results.
clearly the estimated impact co changed source code lines caused by trans andsrsignificantly exceeds the average in most cases.
trans exhibits the greatest impact.
sralso has quite significant impact than the other four categories.
dqr andarhave some effects on application code in certain situations.
rirhas little or no impact on application code.
since mrdid not appear in the revision history of any of the projects we cannot estimate its impact.
results our detailed manual study on schema and code cochange history shows that more than of all valid db revisions contained effective co change information and among these over have precisions over .
thus our manual study confirms the validity and effectiveness of the co change analysis.
schema changes impact code greatly.
for an atomic schema change developers need to change about loc on average for a valid db revision developers need to change about loc.
among the six high level schema change categories trans andsr show more significant impact on application code that the others.
.
discussions our results for rq1 and rq2 show that schemas evolve frequently and extensively and involve many change types.
after deciding on a schema change developers need to evolve the code consistently with the schema change.
our results for rq3 further show that with respect to a valid db revision developers typically need to change around source lines a significant burden.
figure coverage of schema changes by tables.
the x axis represents the percentage of total tables in schema and the y axis the percentage of total schema changes.
in addition no tool currently exists that helps developers evolve database applications which may explain why schema changes are often avoided .
however when system requirements change schema changes can become inevitable.
to reduce manual efforts it is desirable to develop assistive tools to aid database application evolution.
we believe such tools should have the following functionalities before any potential schema change c they can help find c s impacted code regions.
this information can guide developers toward schema changes that minimize impact.
after choosing an evolution strategy and schema change they can help effectively locate all impacted code regions.
finally they should also be able to guide developers how to evolve the code such as recommending possible code changes.
in certain restricted situations they may even support automated program rewriting if the tools can capture sufficiently precise contextual information although infeasible in general .
to satisfy the above requirements we discuss two possible approaches.
the first is to use program analysis to perform change impact analysis.
for example using structural code information we may calculate dependencies also called logic coupling of the program.
maule et al.
have addressed this problem for objectoriented programs that use relational databases.
the technique may be adapted to realize the first two functionalities.
the second approach is to apply co change analysis by mining association rules from evolutionary version histories.
that is the information recorded during the development and maintenance of the applications may be used to calculate the evolutionary coupling which cannot be detected by program analysis .
the mined association rules can be used to suggest and predict likely further changes based on the already applied changes.
co change analysis may be more useful for the evolution of database applications.
first the co change history on schema and application code evolution in valid db revisions is informative.
we have observed that over of valid db revisions provide useful co changed source code lines that are related to the corresponding schema changes and over valid db revisions exhibit over precision.
second the predictive power of a co change analysis is closely related to the length of a project s revision history .
although valid db revisions are relatively few over complete project revisions they may be sufficient for evolving database applications.
schema changes are also centralized.
that is although schemasfigure distribution on the number of atomic schema changes across different tables.
the x axis lists the database applications and the y axis the number of atomic changes for each different table.
evolve significantly most schema changes concentrate in small parts of schemas most components in schema definitions are stable.
figure shows the coverage of schema changes by tables.
we see that around of the schema changes happened in of the tables most tables around are rarely changed during the development lifecycle.
the evolution histories of frequently changed tables are sufficient.
the most frequently modified tables in total have covered over of all the schema changes i.e.
the total number of atomic schema changes occurred .
figure shows the distribution.
for each frequently changed table its number of atomic schema changes is around .
for joomla!
andmediawiki the two most mature projects with long evolutionary histories their numbers are around .
this provides evidence that the co change analysis information can be useful in guiding code evolution.
third schemas and code in database applications correspond closely meaning that for each table defined in a schema it exists code for manipulating the table.
thus similar changes to the same table will likely have quite similar impact on the application code.
as an example consider figure which shows two similar schemalevel changes and their corresponding code level changes.
revision added the column ip auto to table ipblocks figure 10a and figure 10b shows some selected corresponding changes to the affected php file block.php from the column addition.
a similar revision added another column ip expiry to table ipblocks figure 10c and figure 10d illustrates the code level changes.
as we can see the code level modifications for the two schema changes are quite analogous and match closely.
this provides evidence that we may guide application code evolution by capturing and leveraging how schema and code co evolve from revision histories.
in summary it is desirable to build effective tool support to help evolve database applications and the combination of program analysisandco change analysis can be fruitfully exploited.
.
threats to v alidity construct validity the construct validity of our study rests on the measurements performed in particular related to the selection of valid db revisions from the project evolutionary histories identification of all atomic schema changes from the collected valid db revisions the co change analysis to estimate the impact on applications caused by schema changes and the calculation for code impact of different schema change categories.
regarding selecting valid db revisions there are three potential threats.
first for each repository of the studied projects we selected trunk the mainline of the development process to study.
however in some projects such as e107 truck contains multiplebranches of ongoing development lines e.g.
e107 versions .
and .
are developed simultaneously whose evolution histories are not consistent.
to reduce such noise we selected only one branch that contains the longest evolution history of schemas .
second based on our definition of a db revision we may omit tiny revisions where developers wrote external scripts to evolve the database and did not simultaneously update the schema files.
finally since we manually filtered meaningless db revisions based on our understanding this may have introduced certain unavoidable bias.
regarding identifying atomic schema changes to better understand how schemas evolve we attempted to recover the actual change trace of a schema using log information and our knowledge of database evolution to keep consistent with the original one.
unfortunately some incomplete logs and our limited understanding of some projects may lead to misunderstandings.
similarly the identification process may also involve our own human bias.
regarding the co change analysis between schema changes and application changes we used source code lines co changed with schema files in the same valid db revision to estimate the impact caused by schema changes.
from our manual validation there are still about of all valid db revisions that did not provide effective co change information and about of the cases with relatively low precisions based on our co change strategy.
however our approach is likely the best compromise since if more adjacent revisions were regarded as impact caused by schema changes additional noise namely irrelevant application changes would be included in the co change analysis which may greatly reduce precision.
more sophisticated impact analyses for database applications are available such as .
in addition we designed a difference extraction tool to automatically calculate the source lines co changed with schemas .
the implementation of our tool may contain errors.
we utilized end to end regression testing throughout our tool s development to mitigate such a threat as much as possible.
we thus are confident about our measurements.
regarding calculating code impact by different categories of schema changes we use multivariate analysis to estimate them based on the results of our co change analysis.
although it may not indicate the precise code changes triggered by some schema change type it provides high level evidence that some schema change types exhibit more impact than others.
external validity threats to external validity are concerned with whether the results are applicable in general.
we selected opensource database applications with different characteristics such as schema and application size and application domain.
we obtained general findings for all projects and specific findings for individual projects.
however most projects are web based applications and many are implemented in php .
it would be desirable to analyze more varieties of database applications such as scientific database applications developed in different programming languages to confirm our general conclusions.
.
related work the basic tasks in database application evolution as shown in figure involve schema evolution co evolution of schema and data and co evolution of schema and programs.
we structure the discussion of related work accordingly.
schema evolution there are several previous studies on schema evolution.
our work is different in several ways previous studies mainly focus on how schemas evolve while we not only include this aspect in our study but also and more importantly how code co evolves with schema changes we studied popular open source database applications from different revision block initfromrow row insert block.php mediawiki revision block initfromrow row insert block.php mediawiki tables.sql mediawiki tables.sql mediawiki a b c d figure example to illustrate similar code level changes from similar schema changes.
domains with varying sizes while previous work studied only a small number of projects and we studied the complete schema evolution history from their initial version to the current version while previous work mainly focused on a period of the evolution.
lin and neamtiu conducted a study of collateral evolution on two database applications firefox and monotone.
they considered the synchronization problem when the definition of a database schema changes how the schema migration code embedded in the application evolves to keep consistent with the new schema.
in addition they also studied the incompatibility problem of file formats between database and application code caused by modifications of the dbms specification on internal file formats.
curino et al.
presented an empirical study of schema evolution on wikipedia from april to november .
they analyzed basic information of schema evolution such as schema size growth and lifetime of tables and columns.
they also provided both the macro and micro classifications of schema change types and the distribution of schema changes based on the smo schema modification operator .
in addition they studied the effect of schema evolution on the front end application by calculating the success rate of queries used in the previous version.
the authors concluded that schema evolution may cause inconsistencies to the complete application.
in contrast our work tries to estimate the impact driven by schema changes at the code level from revision history and find possible solutions to assist code evolution.
wu and neamtiu studied the schema evolution history of applications that use embedded databases.
they designed a tool called scvd schema extraction and evolution analysis for embedded databases that can automatically extract the schemas embedded in source code and help people understand schema evolution.
they used the tool to analyze the schema evolution history of embedded databases on four c open source projects.
in our work we manually extracted all possible schema changes from schema evolution history to make the result more accurate.
sj berg also performed a schema evolution study on a health management system over .
years.
they found that most frequent changes are column additions deletions and table additions deletions.
in our work we also found additional interesting results for example schema change happened in around tables etc.
schema and data co evolution there is much work in the database community on this topic .
curino et al.
is a representative one.
the authors designed a schema evolution tool prism to assist db administrators in evaluating a schema change s effect at the schema level optimized translation of old queries to work on newschemas version and automatic data migration.
an updated version of prism prism was implemented to support integrity constraint evolution and automatic query and update rewriting through structural schema changes and integrity constraint .
schema and program co evolution little work exists that studied this topic.
change impact analysis is a good approach to support such kind of co evolution.
maule et al.
proposed a program analysis based approach to perform change impact analysis on object oriented applications caused by schema changes in relational databases.
they used a combination of program slicing and k cfa data flow analysis to extract all possible insertions updates queries and stored procedure executions in database applications and implemented a tool called suite .
karahasanovic mainly focused on object oriented databases.
in our work we discuss the possibility of using the information of co change analysis to guide developers to rewrite programs which might be another solution for this direction.
more importantly our focus in this work is on a large scale empirical analysis of such co evolutions to gain insights possibly for developing future assistive tools.
.
conclusion and future work in this paper we have presented the first large scale study of how code co evolves with schema changes in database applications using popular projects.
our study has exposed new interesting quantitatively information which can be used as guidelines to develop assistive tools to help programmers evolve database applications.
there are a number of interesting directions for future work.
first we plan to conduct a more comprehensive study with more applications and more varieties to increase the external validity of our findings.
second we are interested in investigating techniques to increase the accuracy of estimating the code level impact of schema changes e.g.co change analysis with granger causality .
finally using our study results we plan to develop tools to help developers evolve database applications.
.