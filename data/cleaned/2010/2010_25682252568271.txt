coverage is not strongly correlated with test suite effectiveness laura inozemtseva and reid holmes school of computer science university of waterloo waterloo on canada lminozem rtholmes uwaterloo.ca abstract the coverage of a test suite is often used as a proxy for its ability to detect faults.
however previous studies that investigated the correlation between code coverage and test suite effectiveness have failed to reach a consensus about the nature and strength of the relationship between these test suite characteristics.
moreover many of the studies were done with small or synthetic programs making it unclear whether their results generalize to larger programs and some of the studies did not account for the confounding influence of test suite size.
in addition most of the studies were done with adequate suites which are are rare in practice so the results may not generalize to typical test suites.
we have extended these studies by evaluating the relationship between test suite size coverage and effectiveness for large java programs.
our study is the largest to date in the literature we generated test suites forfive systems consisting of up to lines of source code.
we measured the statement coverage decision coverage and modified condition coverage of these suites and used mutation testing to evaluate their fault detection effectiveness.
we found that there is a low to moderate correlation between coverage and effectiveness when the number of test cases in the suite is controlled for.
in addition we found that stronger forms of coverage do not provide greater insight into the effectiveness of the suite.
our results suggest that coverage while useful for identifying under tested parts of a program should not be used as a quality target because it is not a good indicator of test suite effectiveness.
categories and subject descriptors d. .
testing and debugging d. .
metrics product metrics general terms measurement keywords coverage test suite effectiveness test suite quality permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on thefirst page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction testing is an important part of producing high quality software but its effectiveness depends on the quality of the test suite some suites are better at detecting faults than others.
naturally developers want their test suites to be good at exposing faults necessitating a method for measuring the fault detection effectiveness of a test suite.
testing textbooks often recommend coverage as one of the metrics that can be used for this purpose e.g.
.
this is intuitively appealing since it is clear that a test suite cannotfind bugs in code it never executes it is also supported by studies that have found a relationship between code coverage and fault detection effectiveness .
unfortunately these studies do not agree on the strength of the relationship between these test suite characteristics.
in addition three issues with the studies make it difficult to generalize their results.
first some of the studies did not control for the size of the suite.
since coverage is increased by adding code to existing test cases or by adding new test cases to the suite the coverage of a test suite is correlated with its size.
it is therefore not clear that coverage is related to effectiveness independently of the number of test cases in the suite.
second all but one of the studies used small or synthetic programs making it unclear that their results hold for the large programs typical of industry.
third many of the studies only compared adequate suites that is suites that fully satisfied a particular coverage criterion.
since adequate test suites are rare in practice the results of these studies may not generalize to more realistic test suites.
this paper presents a new study of the relationship between test suite size coverage and effectiveness.
we answer the following research questions for large java programs research question1.
is the effectiveness of a test suite correlated with the number of test cases in the suite?
research question2.
is the effectiveness of a test suite correlated with its statement coverage decision coverage and or modified condition coverage when the number of test cases in the suite is ignored?
research question3.
is the effectiveness of a test suite correlated with its statement coverage decision coverage and or modified condition coverage when the number of test cases in the suite is held constant?
the paper makes the following contributions a comprehensive survey of previous studies that investigated the relationship between coverage and effectiveness section and accompanying online material .permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm table summary of thefindings from previous studies.
citation languages largest program coverage types findings pascal sloc all use decision all use related to effectiveness independently of size decision is not relationship is highly nonlinear fortran pascal78 sloc all use mutation effectiveness improves with coverage but not until coverage reaches even then increase is small c sloc all use decision effectiveness is correlated with both all use and decision coverage increase is small until high levels of coverage are reached c sloc block effectiveness is more highly correlated with block coverage than with size c sloc all use decision effectiveness is correlated with both all use and decision coverage effectiveness increases more rapidly at high levels of coverage c sloc block c use decision p useeffectiveness is moderately correlated with all four coverage types magnitude of the correlation depends on the nature of the tests c sloc block c use decision p useeffectiveness is correlated with all four coverage types effectiveness rises steadily with coverage c c sloc block c use decision p useeffectiveness is correlated with all four coverage types but the correlations are not always strong c java72 sloc aimp dbb decision imp pcc statementeffectiveness correlated with coverage effectiveness correlated with size for large projects c sloc block c use decision p usenone of the four coverage types are related to effectiveness independently of size javao slocblock decision path statementeffectiveness correlated with coverage across many projects influence of project size unclear empirical evidence demonstrating that there is a low to moderate correlation between coverage and effectiveness when suite size is controlled for and that the type of coverage used has little effect on the strength of the relationship section .
a discussion of the implications of these results for developers researchers and standards bodies section .
.
related work most of the previous studies that investigated the link between test suite coverage and test suite effectiveness used the following general procedure .created faulty versions of one or more programs by manually seeding faults reintroducing previouslyfixed faults or using a mutation tool.
.created a large number of test suites by selecting from a pool of available test cases either randomly or according to some algorithm until the suite reached either a pre specified size or a pre specified coverage level.
.measured the coverage of each suite in one or more ways if suite size wasfixed measured the suite s size if its coverage wasfixed.
.determined the effectiveness of each suite as the fraction of faulty versions of the program that were detected by the suite.
table summarizes twelve studies that considered therelationship between the coverage and the effectiveness of a test suite ten of which used the general procedure just described.
eight of them found that at least one type of coverage has some correlation with effectiveness independently of size however not all studies found a strong correlation and most found that the relationship was highly non linear.
in addition some found that the relationship only appeared at very high levels of coverage.
for brevity the older studies from table are described more fully in accompanying materials1.
in the remainder of this section we discuss the three most recent studies.
at the time of writing no other study considered any subject program larger than sloc2.
however a recent study by gligoric et al.
and a subsequent master s thesis partially addressed this issue by studying two large java programs jfreechart and joda time and two large c programs sqlite and yaffs2 in addition to a number of small programs.
the authors created test suites by sampling from the pool of test cases for each program.
for the large programs these test cases were manually written by developers for the small programs these test cases were automatically generated using various tools.
suites were created coverage 2in this paper source lines of code sloc refers to executable lines of code while lines of code loc includes whitespace and comments.436in two ways.
first the authors specified a coverage level and selected tests until it was met next the authors specified a suite size and selected tests until it was met.
they measured a number of coverage types statement coverage decision coverage and more exotic measurements based on equivalent classes of covered statements dynamic basic block coverage program paths intra method and acyclic intra method path coverage and predicate states predicate complete coverage .
they evaluated the effectiveness of each suite using mutation testing.
they found that the kendall correlation see section .
between coverage and mutation score ranged from .
to .
for the various coverage types and suite types when the size of the suite was not considered.
when they tried to predict the mutation score using suite size alone they found high correlations between .
and .
for the four large programs with manually written test suites but fairly low correlations for the small programs with artificially generated test suites.
this suggests that the correlation between coverage and effectiveness in real systems is largely due to the correlation between coverage and size it also suggests that results from automatically generated and manually generated suites do not generalize to each other.
a study by gopinath et al.
accepted to the same conference as the current paper did not use the aforementioned general procedure.
the authors instead measured coverage and test suite effectiveness for a large number of open source java programs and computed a correlation across all programs.
specifically they measured statement block decision and path coverage and used mutation testing to measure effectiveness.
the authors measured these values for approximately developer generated test suites the number varies by measurement then generated a suite for each project with the randoop tool and repeated the measurements.
the authors found that coverage is correlated with effectiveness across projects for all coverage types and for both developer generated and automatically generated suites though the correlation was stronger for developerwritten suites.
the authors found that including test suite size in their regression model did not improve the results however since coverage was already included in the model it is not clear whether this is an accuratefinding or a result of multicollinearity3.
as the above discussion shows it is still not clear how test suite size coverage and effectiveness are related.
most studies conclude that effectiveness is related to coverage but there is little agreement about the strength and nature of the relationship.
.
methodology to answer our research questions we followed the general procedure outlined in section .
this required us to select .
a set of subject programs section .
.a method of generating faulty versions of the programs section .
.
a method of creating test suites section .
.
coverage metrics section .
and .
an effectiveness metric section .
.
we then measured the coverage and effectiveness of the suites to evaluate the relationship between these characteristics.
3the amount of variation explained by a variable will be less if it is correlated with a variable already included in the model than it would be otherwise.
.
terminology before describing the methodology in detail we precisely define three terms that will be used throughout the paper.
test case one test in a suite of tests.
a test case executes as a unit it is either executed or not executed.
in the junit testing framework each method that starts with the word test junit or that is annotated with test junit is a test case.
for this reason we will use the termstest methodandtest caseinterchangeably.
test suite a collection of test cases.
master suite the whole test suite that was written by the developers of a subject program.
for example the master suite for apache poi contains test cases test methods .
the test suites that we create and evaluate are strict subsets of the master suite.
.
subject programs we selectedfive subjects from a variety of application domains.
thefirst apache poi is an open source api for manipulating microsoft documents.
the second closure compiler is an open source javascript optimizing compiler.
the third hsqldb is an open source relational database management system.
the fourth jfreechart is an open source library for producing charts.
thefifth joda time is an open source replacement for the java dateandtimeclasses.
we used a number of criteria to select these projects.
first to help ensure the novelty and generalizability of our study we required that the projects be reasonably large on the order of sloc written in java and actively developed.
we also required that the projects have a fairly large number of test methods on the order of so that we would be able to generate reasonably sized random test suites.
finally we required that the projects use ant as a build system and junit as a test harness allowing us to automate data collection.
the salient characteristics of our programs are summarized in table .
program size was measured with sloccount .
rows seven through ten provide information related to mutation testing and will be explained in section .
.
.
generating faulty programs we used the open source tool pit to generate faulty versions of our programs.
to describe pit s operation we mustfirst give a brief description of mutation testing.
amutant is a new version of a program that is created by making a small syntactic change to the original program.
for example a mutant could be created by modifying a constant negating a branch condition or removing a method call.
the resulting mutant may produce the same output as the original program in which case it is called an equivalent mutant .
for example if the equality test in the code snippet in figure were changed to if index the new program would be an equivalent mutant.
mutation testing tools such as pit generate a large number of mutants and run the program s test suite on each one.
if the test suite fails when it is run on a given mutant we say that the suite killsthat mutant.
a test suite s mutant coverage is then the fraction of non equivalent mutants that it kills.
equivalent mutants are excluded because they cannot by definition be detected by a unit test.
if a mutant is not killed by a test suite manual inspec 437table salient characteristics of our subject programs.
property apache poi closure hsqldb jfreechart joda time total java sloc test sloc number of test methods statement coverage decision coverage mc coverage number of mutants number of detected mutants number of equivalent mutants equivalent mutants .
int index while true index if index break figure an example of how an equivalent mutant can be generated.
changing the operator to will result in a mutant that cannot be detected by an automated test case.
tion is required to determine if it is equivalent or if it was simply missed by the suite4.
this is a time consuming and error prone process so studies that compare subsets of a test suite to the master suite often use a different approach they assume that any mutant that cannot be detected by the master suite is equivalent.
while this technique tends to overestimate the number of equivalent mutants it is commonly applied because it allows the study of much larger programs.
although the mutants generated by pit simulate real faults it is not self evident that a suite s ability to kill mutants is a valid measurement of its ability to detect real faults.
however several previous and current studies support the use of this measurement .
previous work has also shown that if a test suite detects a large number of simple faults caused by a single incorrect line of source code it will detect a large number of harder multi line faults .
this implies that if a test suite can kill a large proportion of mutants it can also detect a large proportion of the more difficult faults in the software.
the literature thus suggests that the mutant detection rate of a suite is a fairly good measurement of its fault detection ability.
we will return to this issue in sections and .
we can now describe the remaining rows of table .
the seventh row shows how many mutants pit generated for each project.
the eighth row shows how many of those mutants could be detected by the suite.
the ninth row shows how many of those mutants could not be detected by the entire test suite and were therefore assumed to be equivalent i.e.
row is the sum of rows and .
the last row gives the equivalent mutants as a percentage of the total.
4manual inspection is required because automatically determining whether a mutant is equivalent is undecidable .
.
generating test suites for each subject program we used java s reflection api to identify all of the test methods in the program s master suite.
we then generated new test suites offixed size by randomly selecting a subset of these methods without replacement.
more concretely we created a junit suite by repeatedly using the testsuite.addtest test t method.
each suite was created as a junit suite so that the necessary set up and tear down code was run for each test method.
given this procedure for creating suites in this paper the size of our random suites should always be understood as the number of test methods they contain i.e.
the number of times addtest was called.
we made suites of each of the following sizes methods methods methods methods and so on up to the largest number following this pattern that was less than the total number of test methods.
this resulted in a total of test suites across thefive subject systems.
comparing a large number of suites from the same project allows us to control for size it also allows us to apply our results to the common research practice of comparing test suites generated for the same subject program using different test generation methodologies.
.
measuring coverage we used the open source tool codecover to measure three types of coverage statement decision and modified condition coverage.
statement coverage refers to the fraction of the executable statements in the program that are run by the test suite.
it is relatively easy to satisfy easy to understand and can be measured quickly making it popular with developers.
however it is one of the weaker forms of coverage since executing a line does not necessarily reveal an error in that line.
decision coverage refers to the fraction of decisions i.e.
branches in the program that are executed by its test suite.
decision coverage is somewhat harder to satisfy and measure than statement coverage.
modified condition coverage mcc is the most difficult of these three to satisfy.
for a test suite to be modified condition adequate i.e.
to have modified condition coverage the suite must include 2ntest cases for every decision withnconditions5in it .
this form of coverage is not commonly used in practice however it is very similar to mod5a condition is a boolean expression that cannot be decomposed into a simpler boolean expression.
decisions are composed of conditions and one or more boolean operators.438ified condition decision coverage mc dc which is widely used in the avionics industry.
specifically federal aviation administration standard do 178b states that the most critical software in the aircraft must be tested with a suite that is modified condition decision coverage adequate .
mc dc is therefore one of the most stringent forms of coverage that is widely and regularly used in practice.
measuring modified condition coverage provides insight into whether stronger coverage types such as mcc and mc dc provide practical benefits that outweigh the extra cost associated with writing enough tests to satisfy them.
we did not measure any type of dataflow coverage since very few tools for java can measure these types of coverage.
one exception is coverlipse which can measure all use coverage but can only be used as an eclipse plugin.
to the best of our knowledge there are no open source coverage tools for java that can measure other dataflow coverage criteria or that can be used from the command line.
since developers use the tools they have they are unlikely to use dataflow coverage metrics.
using the measurements that developers use whether due to tool availability or legal requirements means that our results will more accurately reflect current development practice.
however we plan to explore dataflow coverage in future work to determine if developers would benefit from using these coverage types instead.
.
measuring effectiveness we used two effectiveness measurements in this study theraw effectiveness measurementand thenormalized effectiveness measurement.
the raw kill score is the number of mutants a test suite detected divided by the total number of non equivalent mutants that were generated for the subject program under test.
the normalized effectiveness measurement is the number of mutants a test suite detected divided by the number of non equivalent mutants it covers.
a test suite covers a mutant if the mutant was made by altering a line of code that is executed by the test suite implying that the test suite can potentially detect the mutant.
we included the normalized effectiveness measurement in order to compare test suites on a more even footing.
suppose we are comparing suite a with coverage to suite b with coverage.
suite b will almost certainly have a higher raw effectiveness measurement since it covers more code and will therefore almost certainly kill more mutants.
however if suite a kills of the mutants that it covers while suite b kills only of the mutants that it covers suite a is in some sense a better suite.
the normalized effectiveness measurement captures this difference.
note that it is possible for the normalized effectiveness measurement to drop when a new test case is added to the suite if the test case covers a lot of code but kills few mutants.
it may be helpful to think of the normalized effectiveness measurement as a measure of depth how thoroughly does the test suite exercise the code that it runs?
the raw effectiveness measurement is a measure of breadth how much code does the suite exercise?
note that the number of non equivalent mutants covered by a suite is the maximum number of mutants the suite could possibly detect so the normalized effectiveness measurement ranges from to .
the raw effectiveness measurement in general does not reach since most suites kill a small percentage of the non equivalent mutants.
however note that the full test suite has both a normalized effectivenessmeasurement of and a raw effectiveness measurement of since we decided that any mutants it did not kill are equivalent.
.
results in this section we quantitatively answer the three research questions posed in section .
as section explained we collected the data to answer these questions by generating test suites offixed size via random sampling measuring their statement decision and mcc coverage with codecover and measuring their effectiveness with the mutation testing tool pit.
.
is size correlated with effectiveness?
research question asked if the effectiveness of a test suite is influenced by the number of test methods it contains.
this research question provides a sanity check that supports the use of the effectiveness metric.
figure shows some of the data we collected to answer this question.
in each subfigure thexaxis indicates suite size on a logarithmic scale while the yaxis shows the range of normalized effectiveness values we computed.
the red line on each plot wasfit to the data with r slmfunction6.
the adjustedr2value for each regression line is shown in the bottom right corner of each plot.
these values range from .
to .
implying that the correlation coefficientrranges from .
to .
.
this indicates that there is a moderate to very high correlation between normalized effectiveness and size for these projects7.
the results for the non normalized effectiveness measurement are similar with ther2values ranging from .
to .
implying a high to very high correlation between non normalized effectiveness and size.
thefigure for this measurement can be found online8.
answer1.
our results suggest that for large java programs there is a moderate to very high correlation between the effectiveness of a test suite and the number of test methods it contains.
.
is coverage correlated with effectiveness when size is ignored?
research question asked if the effectiveness of a test suite is correlated with the coverage of the suite when we ignore the influence of suite size.
tables and show the kendall correlation coefficients we computed to answer this question all coefficients are significant at the .
level9.
table 6size and the logarithm of size were used as the inputs.
7here we use the guildford scale for verbal description in which correlations with absolute value less than .
are described as low .
to .
as moderate .
to .
as high and over .
as very high .
coverage 9kendall s is similar to the more common pearson coefficient but does not assume that the variables are linearly related or that they are normally distributed.
rather it measures how well an arbitrary monotonic function couldfit the data.
a high correlation therefore means that we can predict the rank order of the suites effectiveness values given the rank order of their coverage values which in practice is nearly as useful as predicting an absolute effectiveness score.
we used it instead of the pearson coefficient to avoid introducing unnecessary assumptions about the distribution of the data.
r .
r .
r .
r .
r .89apache poi closure hsqldb jfreechart joda time0.
.
.
.
.
.
.
.
.
.
sizeeffectiveness figure normalized effectiveness scores plotted against size for all subjects.
each box represents the suites of a given size that were created from a given master suite.
gives the correlation between the different coverage types and the normalized effectiveness measurement.
table gives the correlation between the different coverage types and the non normalized effectiveness measurement.
for all projects but hsqldb we see a moderate to very high correlation between coverage and effectiveness when size is not taken into account.
hsqldb is an interesting exception when the effectiveness measurement is normalized by the number of covered mutants there is a lownegativecorrelation between coverage and effectiveness.
this means that the suites with higher coverage kill fewer mutants per unit of coverage in other words the suites with higher coverage contain test cases that run a lot of code but do not kill many mutants in that code.
of course since the suites kill more mutants in total as they grow there is a positive correlation between coverage and non normalized effectiveness for hsqldb.
answer2.
our results suggest that for many large java programs there is a moderate to high correlation between the effectiveness and the coverage of a test suite when the influence of suite size is ignored.
research question explores whether this correlation is caused by the larger size of the suites with higher coverage.
.
is coverage correlated with effectiveness when size is fixed?
research question asked if the effectiveness of a test suite is correlated with its coverage when the number of test cases in the suite is controlled for.
figure shows the data we collected to answer this question.
each panel showstable the kendall correlation between normalized effectiveness and different types of coverage when suite size is ignored.
all entries are significant at the .
level.
project statement decision mod.
cond.
apache poi .
.
.
closure .
.
.
hsqldb .
.
.
jfreechart .
.
.
joda time .
.
.
table the kendall correlation between nonnormalized effectiveness and different types of coverage when suite size is ignored.
all entries are significant at the .
level.
project statement decision mod.
cond.
apache poi .
.
.
closure .
.
.
hsqldb .
.
.
jfreechart .
.
.
joda time .
.
.
the results we obtained for one project and one suite size.
the project name is given at the top of each column while the suite size is given at the right of each row.
different coverage types are differentiated by colour.
the bottom row is a margin plot that shows the results for all sizes while the rightmost column is a margin plot that shows the results for440apache poiclosurehsqldbjfreechartjoda time all .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
all .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
coverageeffectiveness coverage type decision coverage modified condition coverage statement coveragen a n a n a n a figure normalized effectiveness scores left axis plotted against coverage bottom axis for all subjects.
rows show the results for one suite size columns show the results for one project.
n a indicates that the project did not have enough test cases tofill in that frame.
all projects.
thefigure shows the results for the normalized effectiveness measurement the non normalized effectiveness measurements tend to be small and difficult to see at this size.
thefigure for the non normalized effectiveness measurement can be found online with the other supplementary material.
we computed the kendall correlation coefficient between effectiveness and coverage for each project each suite size each coverage type and both effectiveness measures.
since this resulted in a great deal of data we summarize the results here the full dataset can be found on the same website as thefigures.
our results were mixed.
controlling for suite size always lowered the correlation between coverage and effectiveness.
however the magnitude of the change depended on the effectiveness measurement used.
in general the normalized effectiveness measurements had low correlations with cover age once size was controlled for while the non normalized effectiveness measurements had moderate correlations with coverage once size was controlled for.
that said the results varied by project.
joda time was at one extreme the correlation between coverage and effectiveness ranged from .
to .
when suite size was ignored but dropped to essentially zero when suite size was controlled for.
the same effect was seen for closure when the normalized effectiveness measurement was used.
apache poi fell at the other extreme.
for this project the correlation between coverage and the non normalized effectiveness measurement was .
when suite size was ignored but dropped to a range of .
to .
when suite size was controlled for.
while this is in some cases a large drop a correlation in this range can provide useful information about the quality of a test suite.441a very interesting result is that in general the coverage type used did not have a strong impact on the results.
this is true even though the effectiveness scores yvalues for each suite are the same for all three coverage types xvalues .
to clarify this consider figure .
thefigure shows two hypothetical graphs of effectiveness against coverage.
in the top graph coverage type is not strongly correlated with effectiveness.
in the bottom graph coverage type 2is strongly correlated with effectiveness even though they value of each point has not changed e.g.
the triangle is aty .
in both graphs .
we donotsee this difference between statement decision and mcc coverage suggesting that the different types of coverage are measuring the same thing.
we can confirm this intuition by measuring the correlation between different coverage types for each suite .
given these high correlations and given that the shape of the point clouds are similar for all three coverage measures see figure we can conclude that the coverage type used has little effect on the relationship between coverage and effectiveness in this study.
table the kendall and pearson correlations between different types of coverage for all suites from all projects.
coverage types tau pearson statement decision .
.
decision mcc .
.
statement mcc .
.
answer3.
our results suggest that for large java programs the correlation between coverage and effectiveness drops when suite size is controlled for.
after this drop the correlation typically ranges from low to moderate meaning it is not generally safe to assume that effectiveness is correlated with coverage.
the correlation is stronger when the non normalized effectiveness measurement is used.
additionally the type of coverage used had little influence on the strength of the relationship.
.
discussion the goal of this work was to determine if a test suite s coverage is correlated with its fault detection effectiveness when suite size is controlled for.
we found that there is typically a moderate to high correlation between coverage and effectiveness when suite size is ignored and that this drops to a low to moderate correlation when size is controlled.
this result suggests that coverage alone is not a good predictor of test suite effectiveness in many cases the apparent relationship is largely due to the fact that high coverage suites contain more test cases.
the results for joda time and closure in particular demonstrate that it is not safe in general to assume that coverage is correlated with effectiveness.
interestingly the suites for joda time and closure are the largest and most comprehensive of thefive suites we studied which might indicate that the correlation becomes weaker as the suite improves.
in addition we found that the type of coverage measured had little impact on the correlation between coverage and effectiveness.
this is reinforced by the shape of the point clouds in figure for any one project and suite size the .
.
.
.
.
.
.
.
coverage type 1effectiveness .
.
.
.
.
.
.
.
coverage type 2effectiveness figure hypothetical graphs of effectiveness against two coverage types for four test suites.
the top graph shows a coverage type that is not correlated with effectiveness the bottom graph shows a coverage type that is correlated with effectiveness.
clouds corresponding to the three coverage types are similar in shape and size.
this in combination with the high correlation between different coverage measurements suggests that stronger coverage types provide little extra information about the quality of the suite.
ourfindings have implications for developers researchers and standards bodies.
developers may wish to use this information to guide their use of coverage.
while coverage measures are useful for identifying under tested parts of a program and low coverage may indicate that a test suite is inadequate high coverage does not indicate that a test suite is effective.
this means that using afixed coverage value as a quality target is unlikely to produce an effective test suite.
while members of the testing community have previously made this point it has been difficult to evaluate their suggestions due to a lack of studies that considered systems of the scale that we investigated.
additionally it may be in the developer s best interest to use simpler coverage measures.
these measures provide a similar amount of information about the suite s effectiveness but introduce less measurement overhead.442researchers may wish to use this information to guide their tool building.
in particular test generation techniques often attempt to maximize the coverage of the resulting suite our results suggest that this may not be the best approach.
finally our results are pertinent to standards bodies that set requirements for software testing.
the faa standard do 178b mentioned earlier in this paper requires the use of mc dc adequate suites to ensure the quality of the resulting software however our results suggest that this requirement may increase expenses without necessarily increasing quality.
of course developers still want to measure the quality of their test suites meaning they need a metric thatdoes correlate with fault detection ability.
while this is still an open problem we currently feel that mutation score may be a good substitute for coverage in this context .
.
threats to validity in this section we discuss the threats to the construct validity internal validity and external validity of our study.
.
construct validity in our study we measured the size coverage and effectiveness of random test suites.
size and coverage are straightforward to measure but effectiveness is more nebulous as we are attempting to predict the fault detection ability of a suite that has never been used in practice.
as we described in section .
previous and current work suggests that a suite s ability to kill mutants is a fairly good measurement of its ability to detect real faults .
this suggests that in the absence of equivalent mutants this metric has high construct validity.
unfortunately our treatment of equivalent mutants introduces a threat to the validity of this measurement.
recall that we assumed that any mutant that could not be detected by the program s entire test suite is equivalent.
this means that we classified up to of the generated mutants as equivalent see thefinal row of table .
in theory these mutants are a random subset of the entire set of mutants so ignoring them should not affect our results.
however this may not be true.
for example if the developers frequently test for off by one errors mutants that simulate this error will be detected more often and will be less likely to be classified as equivalent.
.
internal validity our conclusions about the relationship between size coverage and effectiveness depend on our calculations of the kendall correlation coefficient.
this introduces a threat to the internal validity of the study.
kendall s original formula for assumes that there are no tied ranks in the data that is if the data were sorted no two rows could be exchanged without destroying the sorted order.
when ties do exist two issues arise.
first since the original formula does not handle ties a modified one must be used.
we used the version proposed by adler .
second ties make it difficult to compute the statistical significance of the correlation coefficient.
it it possible to show that in the absence of ties is normally distributed meaning we can use z scores to evaluate significance in the usual way.
however when ties are present the distribution of changes in a way that depends on the number and nature of the ties.
this can result in a non normal distribution .
to determine the impact of ties on our calculations we counted both the number of ties that occurred and the total number of comparisons doneto compute each .
we found that ties rarely occurred for the worst calculation .
of the comparisons resulted in a tie but for most calculations this percentage was smaller by several orders of magnitude.
since there were so few ties we have assumed that they had a negligible effect on the normal distribution.
another threat to internal validity stems from the possibility of duplicate test suites our results might be skewed if two or more suites contain the same subset of test methods.
fortunately we can evaluate this threat using the information we collected about ties since duplicate suites would naturally have identical coverage and effectiveness scores the number of tied comparisons provides an upper bound on how many identical suites were compared.
since the number of ties was so low the number of duplicate suites must be similarly low and so we have ignored the small skew they may have introduced to avoid increasing the memory requirements of our study unnecessarily.
since we have studied correlations we cannot make any claims about the direction of causality.
.
external validity there are six main threats to the external validity of our study.
first previous work suggests that the relationship between size coverage and effectiveness depends on the difficulty of detecting faults in the program .
furthermore some of the previous work was done with hand seeded faults which have been shown to be harder to detect than both mutants and real faults .
while this does not affect our results it does make it harder to compare them with those of earlier studies.
second some of the previous studies found that a relationship between coverage and effectiveness did not appear until very high coverage levels were reached .
since the coverage of our generated suites rarely reached very high values it is possible that we missed the existence of such a relationship.
that said it is not clear that such a relationship would be useful in practice.
it is very difficult to reach extremely high levels of coverage so a relationship that does not appear until coverage is reached is functionally equivalent to no relationship at all for most developers.
third in object oriented systems most faults are usually found in just a few of the system s components .
this means that the relationship between size coverage and effectiveness may vary by class within the system.
it is therefore possible that coverage is correlated with effectiveness in classes with specific characteristics such as high churn.
however our conclusions still hold for the common practice of measuring the coverage of a program s entire test suite.
fourth there may be other features of a program or a suite that affect the relationship between coverage and effectiveness.
for example previous work suggests that the size of a class can affect the validity of object oriented metrics .
while we controlled for the size of each test suite in this study we did not control for the size of the class that each test method came from.
fifth as discussed in section .
our subjects had to meet certain inclusion criteria.
this means that they are fairly similar so our results may not generalize to programs that do not meet these criteria.
we attempted to mitigate this threat by selecting programs from different application domains thereby ensuring a certain amount of variety in the subjects.
unfortunately it was difficult tofind acceptable443subjects in particular the requirement that the subjects have test cases proved to be very difficult to satisfy.
in practice it seems that most open source projects do not have comprehensive test suites.
this is supported by gopinath et al.
s study where only of the open source java projects they initially considered or had test suites at all much less comprehensive suites.
finally while our subjects were considerably larger than the programs used in previous studies they are still not large by industrial standards.
additionally all of the projects were open source so our results may not generalize to closed source systems.
.
future work our next step is to confirm ourfindings using real faults to eliminate this threat to validity.
we will also explore dataflow coverage to determine if these coverage types are correlated with effectiveness.
it may also be helpful to perform a longitudinal study that considers how the coverage and effectiveness of a program s test suite change over time.
by cross referencing coverage information with bug reports it might be possible to isolate those bugs that were covered by the test suite but were not immediately detected by it.
examining these bugs may provide insight into which bugs are the most difficult to detect and how we can improve our chances of detecting them.
.
conclusion in this paper we studied the relationship between the number of methods in a program s test suite the suite s statement decision and modified condition coverage and the suite s mutant effectiveness measurement both normalized and non normalized.
from thefive large java programs we studied we drew the following conclusions in general there is a low to moderate correlation between the coverage of a test suite and its effectiveness when its size is controlled for.
the strength of the relationship varies between software systems it is therefore not generally safe to assume that effectiveness is strongly correlated with coverage.
the type of coverage used had little impact on the strength of the correlation.
these results imply that high levels of coverage do not indicate that a test suite is effective.
consequently using a fixed coverage value as a quality target is unlikely to produce an effective test suite.
in addition complex coverage measurements may not provide enough additional information about the suite to justify the higher cost of measuring and satisfying them.
.