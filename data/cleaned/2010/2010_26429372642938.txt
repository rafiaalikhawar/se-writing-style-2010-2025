automated domain specific c verification with mbeddr zaur molotnikov fortiss institute guerickestra e munich germany molotnikov fortiss.orgmarkus v lter independent itemis oetztaler stra e stuttgart germany voelter acm.orgdaniel ratiu fortiss institute guerickestra e munich germany ratiu fortiss.org abstract when verifying c code two major problems must be addressed.
one is the specification of the verified systems properties the other one is the construction of the verification environment.
neither c itself nor existing c verification tools o er the means to e ciently specify application domain level properties and environments for verification.
these two shortcomings hamper the usability of c verification and limit its adoption in practice.
in this paper we introduce an approach that addresses both problems and results in user friendly and practically usable c verification.
the novelty of the approach is the combination of domainspecific language engineering and c verification.
we apply the approach in the domain of state based software using mbeddr and cbmc.
we validate the implementation with an example from the pacemaker challenge developing a functionally verified lightweight and deployable cardiac pulse generator.
the approach itself is domain independent.
categories and subject descriptors d. .
software program verification correctness proofs model checking d. .
programming environments integrated environments d. .
language classifications extensible languages specialized application languages keywords verification domain specific languages mbeddr cbmc .
introduction the c programming language is used in many di erent application domains.
on the one hand engineers benefit from its flexibility and the lightweight execution environment.
on the other hand the low abstraction level of c makes c code hard to verify against requirements specified in application domain terminology.
with existing c verification tools the verification has to be performed at the abstraction level of c itself which is tedious and error prone.
an example of an appermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
domain level requirement that must be fulfilled by software is given below it applies to the cardiac pacemaker used as an example throughout this paper the pacer is configured with two timeout parameters vrp and lri.
lri varies between and .
in increments of and vrp is at most of lri.
in a given period of time the tick the pacer either senses a signal representing a natural heartbeat or it does not.
before the vrp timeout such signals are to be ignored after vrp they must be registered.
if within the lri timeout no heartbeat was registered an artificial pacing must be performed.
requirements like this describe the properties the system should have.
to make them verifiable by tools they have to be expressed formally.
a not necessarily correct implementation of this pacing logic is given in listing .
this code could be verified using c verification tools such as cbmc satabs or cpachecker .
working at the abstraction level of c they can be used to for example check assertions or error label reachability.
this makes it impractical to directly represent the application domain level semantics implied by requirements such as those described above .
int t bool makepace event e switch e case sense case tick if t vrp if t lri return false t else return false t else return false t return true listing sample pacing logic implementation in c another problem of verification on the level of the implementation language is the lack of language abstractions for specifying environments .
the environment is the code or more generally a system with which the system under verification suv interacts in particular the environment may represent the relevant aspects of the real world in which the suv is designed to operate.
the environment must be modeled as well.
this model encodes assumptions under which the verification is performed.
such environments are usually nondeterministic e.g.
the heart may or may not beat at any given time and constrained i.e.
the behavior is somehow bounded usually as a consequence of characteristics of the real world for example there are physical limits as to how fast a human heart can beat .
a well defined environment can reduce the number of spurious counterexamples and speed up the verification as a consequence of state space reduction .
finally assuming the verification conditions and the environment have been specified the question remains of how to integrate them with the suv to perform the verification.
in other words verification schemas must be specified.
a verification schema can serve as a reusable automated verification method that can be used with multiple di erent suvs and their properties.
listing shows the system from listing implemented and verified using domain specific c extensions.
these extensions are developed with mbeddr an extensible version of c introduced in section .
.
the suv is expressed as a state machine which adds additional structure and domain level semantics to the c code while still containing c expressions and statements to cover the details.
mbeddr s state machines have states as well as internal variables jointly representing thetotal state of the state machine.
the environment heart is explicitly specified and contains nondeterministic code that interacts with the suv.
the suv parameters lriandvrpare nondeterministically assigned and constrained as specified in the requirements.
an inductive proof schema is used to verify whether a given suv satisfies a set of verification conditions starting from the initial set of total states i. the verification condition is specified using an after before exists temporal pattern which is much closer to the original prose requirement to pace at lri than the low level encoding in c. state machine pacer intick state init insense ontick wait c inconfig lri vrp onconfig init out mkpace lri lri int c lri vrp vrp vrp state wait onsense wait ontick pace state pace ontick wait c entry send mkpace onsense wait ontick wait c c environment heart nondet smtrigger sense assign lri lri lri assign vrp vrp .
vrp total state set ifor pacer sminstate wait c lri lri vrp vrp inductive for pacer ontick from i environment heart conditions after sminstate wait before sminstate pace exists c lri listing sample pacing logic in mbeddr we call the approach to use domain specific extensions of c tailored to verification purposes domain specific c verification dscv .
translation to verifiable c is used to perform the verification itself.
figure compares our approach to the state of the practice in c verifiers such as cbmc.
today a practicing developer has to manually bridge the abstraction gap between the application domain and the implementation by manually encoding the system and the to be verified properties in c with the exception of some property specific tools see section .
he also has to interpret the low level verification results in the context of the application domain.
dscv in contrast provides language extensions for these figure todays c verification in practice left vs. dscv tasks.
the suv is encoded as a domain specific model1 and the verification conditions as well as the environment are expressed relative to the abstractions in the model.
however since the model is implemented using c extensions and not with a separate modeling language the full expressiveness of c is available to the developer when needed.
the verification results obtained from the c level verification tool are lifted to the abstractions relevant to application domain closing the cycle.
dscv requires the following steps to obtain a verification tool tailored to a specific application domain .
create language extensions to model the system .
create extensions for verification conditions .
create extensions for the verification environment .
create a verification schema .
implement the interaction with the verifier the use of language workbenches discussed in section .
makes it straightforward to develop extensions for programming languages to support verification.
once built the verification extensions can be reused to support verification of similar systems.
new verification extensions can be built for fundamentally di erent systems in a modular way i.e.
without invasively modifying c or existing extensions.
contribution this paper makes three contributions the dscv approach that simplifies verification of programs by using domain specific language extensions.
it combines existing c verification approaches with language engineering techniques an instantiation of dscv for state based software in c relying on the cbmc verification tool and the extensible version of c provided by mbeddr a validation of dscv based on the implementation and verification of a cardiac pacemaker pulse generator from a user s perspective the benefit of dscv is that the expression validation and maintenance of the suv the verification conditions and the environment is simplified due to closer alignment with the application domain.
verification schemas support automated and reusable domain specific verification methods.
from the perspective of the verification developer our approach enables modular domainspecific verification in which new constructs for modeling 1in this paper the term model always refers to the suv expressed with application domain abstractions.
540suvs environments verification conditions and for verification schemas can be added in a modular way.
dscv leverages the advances in c level verification tools and brings them closer to the end users through language engineering.
previous work this work builds on our previous research on using language engineering techniques for improving the usability of c level verification .
this paper advances our research by introducing an end to end verification approach that combines high level properties advanced environments and verification schemas to accomplish the complete verification of an executable and deployable subsystem.
structure to implement dscv we rely on a number of technologies described in section .
our implementation is based on the jetbrains mps language workbench.
it provides stateof the art language engineering facilities and is discussed in section .
.
to supply a version of c that can be easily extended towards verification we use mbeddr.
a brief overview over mbeddr is provided in section .
.
we introduce cbmc and the connection between mbeddr and cbmc based verification in section .
.
in section we describe how we have implemented dscv for the domain of state based software.
this section is organized along the five steps required for implementing dscv mentioned above.
in section we discuss our dscv based contribution to the pacemaker challenge.
section contains a discussion of the resulting verification tool and compares dscv to other verification approaches.
section discusses related work in the verification domain.
we conclude the paper with a summary and a short outlook on our future work in section .
reproducing the results our work and results are reproducible since all components are open source software.
mps can be downloaded from jetbrains.2the mbeddr source code can be obtained from the public github repository.3the pacemaker example code is a part of mbeddr it is in the code applications pacemaker folder in the mbeddr sources.
cbmc can be obtained from the cbmc website.4we also provide an installer5that ties all the components together installing mps cbmc and building mbeddr from sources.
.
technological baseline .
language engineering with mps our work relies on language engineering which refers to defining extending and composing programming languages and their integrated development environments ides .
language workbenches are tools that support e cient language engineering.
our implementation relies on the jetbrains mps language workbench which unlike most other language workbenches uses projectional editing.
projectional editing the conventional approach for language implementation relies on defining a grammar and then deriving a parser which recognizes structure in the program text and materializes it into an abstract syntax tree ast .
an ide is essentially a text editor which runs the parser incrementally to maintain the ast.
the ide also provides services such as syntax highlighting navigation or code completion figure fragment of language structure definition and directly integrates the type checker and a compiler if any.
many of these services rely on the ast.
as discussed in most grammar based language engineering approaches and tools are limited in terms of modular extensibility or composability of grammars because depending on the grammar class grammars are not closed under composition.
while also points out that purely declarative syntax definitions can address this challenge to a degree there are still important cases where composability remains limited.
projectional editing is a di erent approach to defining extending and composing languages and ides.
a projectional editor does not rely on a parser.
instead as a user edits a program the ast is modified directly6.
projection rules create a representation of the ast with which the user interacts and which reflects the resulting changes figure steps and .
as the user edits the program program nodes are created as instances of language concepts.
concepts are the kinds of ast nodes similar to metaclasses in traditional modeling approaches.
in the editor a code completion menu lets users create instances based on a text string entered in the editor called the alias.
the valid aliases and thus the concepts available for instantiation are determined by the language definition.
importantly every next alias must be recognized as it is entered so there is never any parsing of a structured text sequence.
in contrast to parser based systems where disambiguation is performed by the parser after a potentially complete program has been entered in projectional editing disambiguation happens at the time when the user picks a concept from the code completion menu if two concepts define the same alias the user resolves the ambiguity.
in a projectional editor every program node has a unique identifier and also points to its defining concept.
so once a node is created there is never any ambiguity what it represents irrespective of its syntax.