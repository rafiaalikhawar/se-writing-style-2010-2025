the plastic surgery hypothesis earl t. barr yuriy brun prem devanbu?
mark harman federica sarro university college london university of massachusetts?university of california davis london uk amherst ma usa davis ca usa e.barr mark.harman f.sarro ucl.ac.uk brun cs.umass.edu ptdevanbu ucdavis.edu abstract recent work on genetic programming based approaches to automatic program patching have relied on the insight that the content of new code can often be assembled out of fragments of code that already exist in the code base.
this insight has been dubbed the plastic surgery hypothesis successful well known automatic repair tools such as genprog rest on this hypothesis but it has never been validated.
we formalize and validate the plastic surgery hypothesis and empirically measure the extent to which raw material for changes actually already exists in projects.
in this paper we mount a large scale study of several large java projects and examine a history of commits to determine the extent to which these commits are graftable i.e.
can be reconstituted from existing code and find an encouraging degree of graftability surprisingly independent of commit size and type of commit.
for example we find that changes are graftable from the exact version of the software being changed.
with a view to investigating the difficulty of finding these grafts we study the abundance of such grafts in three possible sources the immediately previous version prior history and other projects.
we also examine the contiguity or chunking of these grafts and the degree to which grafts can be found in the same file.
our results are quite promising and suggest an optimistic future for automatic program patching methods that search for raw material in already extant code in the project being patched.
categories and subject descriptors d. .
distribution maintenance and enhancement d. .
reusable software general terms experimentation languages measurement keywords software graftability code reuse empirical software engineering mining software repositories automated program repair .
introduction software has successfully relieved humans of many tedious tasks yet many software engineering tasks remain manual and require significant developer effort.
developers have long sought to autoauthor order is alphabetical.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright held by the owner author s .
publication rights licensed to acm.
acm .
.
.
.
development tasks.
in the advent of genprog and clearview demonstrated automated bug repair.
automatically fixing bugs requires searching a vast space of possible programs and a key insight that limits that search space is the assumption that fixes often already exist elsewhere in the codebase .
this insight arises from the idea that code is locally repetitive and that the same bug appears in multiple locations but when fixed is not likely to be fixed everywhere.
in fact program source code changes that occur during development can often be constructed from grafts snippets of code located elsewhere in the same program .
the act of grafting existing code to construct changes is known as plastic surgery .
reformulated as a hypothesis the insight follows the plastic surgery hypothesis changes to a codebase contain snippets that already exist in the codebase at the time of the change and these snippets can be efficiently found and exploited.
the early success in automating program repair has triggered a dramatic recent upsurge in research on automated repair refactoring and genetic improvement .
these approaches have implicitly assumed the correctness of the plastic surgery hypothesis since they rely in part on plastic surgery.
despite the fact that a growing body of work depends on it the plastic surgery hypothesis has not been validated experimentally.
the goal of this paper is to validate this hypothesis empirically on the large scale on real world software.
le goues et al.
and nguyen et al.
considered repetitiveness of changes abstracted to asts and mart nez et al.
considered changes that could be entirely constructed from existing snippets.
both restricted their search to changes neglecting primordial untouched code that was inherited unchanged from the first version to the last.
both report the portion of repetitiveness in their datasets but do not consider the cost of finding it.
in this work we consider both the changes and the primordial code and also explore aspects of the cost of searching in these spaces.
in short our result provides a solid footing to new and ongoing work on automating software development that depends on the plastic surgery hypothesis.
the plastic surgery hypothesis has two parts the claim that changes are repetitive relative to their parent the program to which they are applied and the claim that this repetitiveness is usefully exploitable.
to address each claim we focus our inquiry on two questions how much of each change to a codebase can be constructed from existing code snippets?
and what is the cost of finding these snippets?
to answer the first question we measure the graftability of each change.
the graftability of a change is the number of snippets in it that match a snippet in the search space we clarify the intuitive term snippets below .
we study over human implemented changes to a program.
if the graftability of these changes is high then this explains part of the success of automated repair refactoring and genetic improvement and it is an encouraging news for further research in these areas.
we consider only line granular snippets and search for exact matches ignoring whitespace.
we make this choice because developers tend to think in terms of lines and practically this choice reduces the size of the search space with which any tool seeking to help construct changes must contend.
our choice is informed by our practical experience with genprog which allows within line expression granular changes.
when we experimented with this setting on a large hundreds of fairly small buggy programs dataset the genetic programming search algorithm almost always bogged down within a few generations because of the search space explosion .
to answer the second question we consider three spaces in which we search for grafts the parent of a change the search space of the plastic surgery hypothesis a change s non parental ancestors and the most recent version of entirely different projects.
during search we consider all the lines in each version and not merely its changes as this allows us to search those lines that survive unchanged from the start of a version history to its end.
this matters when the start of a version history is not empty as is often the case since many projects are bootstrapped from prototypes adapted from existing projects migrated from one version control system to another or undergo extensive development outside of version control.
in particular our dataset covers an interval of each project s history that starts from a nonempty change and on average these core lines account for of all lines searched.
to quantify our answer to the second question we simply count the number of grafts found in the different search spaces over their size.
we take a pragmatic actionability oriented view of the plastic surgery hypothesis.
we argue that it is not merely about repetitiveness of changes relative to their parent.
this fact alone is not actionable if the cost of finding grafts were prohibitive.
the practical success of work on automated repair has demonstrated both the existence of grafts and the tractability of finding them.
thus the hypothesis is about richness of the first of these search spaces the parent of a change.
we therefore validate it by comparing cost of finding grafts in this search space against the cost of finding them in the other two.
over the first search space we find that on average changes are graftable and that of them can be graftable.
this suggests that a fair amount of the lines in code changes could be derived from code that already exists in the project.
when we compare this result to the other two search spaces we see that on average the non parental ancestors contribute only more grafts than the parents while other projects only provide on average.
moreover we found that graftability from parent is significantly higher than graftability from both non parental ancestors and other projects with a high effect size .
and .
respectively .
thus we can answer the first question which captures the claim that many donor sites exist at the time of the change in the plastic surgery hypothesis does hold section .
.
an initial answer to the second question is to count the lines searched for each of the search spaces and report the work done to find each donor as the ratio of number of donor sites found to the number of total lines searched i.e.
density .
we found that the density of the parent is significantly higher than those of both non parental ancestors and other projects with a high effect size.
here again we see that the plastic surgery hypothesis holds.
we found that the cost to search from parent is significantly lower than the cost to search in the other two search spaces section .
.
having validated the plastic surgery hypothesis we turn our attention to how to exploit it.
the success of automated bug fixing refactoring and genetic improvement demonstrates the utility ofincorporating the search of existing code into techniques seeking to automate software engineering tasks that is the consequences of plastic surgery hypothesis are indeed exploitable.
the grafts we have found are mostly single lines with the distribution following a power law.
thus grafts would not be considered clones because the traditional threshold for minimal clone size is lines .
these smaller repetitive snippets are micro clones .
syntactic repetitiveness below this threshold has simply been considered uninteresting because it lacks sufficient content.
of our grafts fall below this threshold and are therefore a micro clones.
the success of automated repair refactoring and genetic improvement are evidence that these micro clones of which our grafts form a subset are to the contrary useful.
we contend that micro clones are the atoms of code construction and therefore are fundamental to code synthesis.
indeed gabel and su demonstrated that line length micro clones from a large corpus can reconstruct entire programs .
regardless of the intrinsic interest or lack thereof of a particular graft to a human being such as a trivial assignment statement over the correct variable names grafts can usefully bootstrap the automation of software development.
to reduce the cost of searching for grafts we tried to correlate features of changes with graftability section .
.
if we found such a correlation we could exploit it to search more or less intensively.
to this end we studied if different categories of human written changes e.g.
bug fixes refactorings or new feature additions are more graftable than others.
we also asked if graftability depends on size section .
.
however we found no such correlations.
indeed concerning the category of change the success of automatic bug fixing refactoring and genetic improvement suggest that different kinds of changes exhibit the same graftability as we found.
as a community we have learned that several lines of code are required for a change to be unique and that a surprising number of changes are redundant in the sense that they repeat changes already made .
we also know that automated repair can be improved by including elements of human constructed bug fixes .
we know that source code is locally repetitive to a greater degree than natural language .
to this growing body of knowledge about the repetitiveness of code and its exploitation we add the validation of the plastic surgery hypothesis augmented with insights into the proximity of grafts to each other.
the primary contributions of this paper are a formal statement and validation of the plastic surgery hypothesis a large scale empirical study of the extent to which development changes can be constructed from code already available during development i.e.
their graftability and an analysis of the relationship between commit features i.e.
size and type and commit graftability an analysis of the locality of the distribution of grafts in codebase to which a commit applies.
these findings relating to the plastic surgery hypothesis bode well for the likelihood of continuing success of patching by grafting approaches including genprog they generally suggest that donor grafts to compose a patch can be feasibly found in temporal and spatial proximity to the patch site.
donor grafts can often be found in the current version of the program to be patched and it is rarely necessary to search earlier versions section .
.
the graftable portions of a patch can usually be composed out of lines from just one contiguous donor graft site and very often from no more than two section .
.
a significant portion of donor graft code can be found in the same file as the patch site section .
.the rest of this paper is structured as follows.
section formally defines the problem we tackle and section describes our experimental design and data.
section discusses our findings.
section places our work in the context of related research.
finally section summarizes our contributions.
.
problem formulation we are interested in the graftablity of changes to a codebase with respect to three search spaces its parents its non parental ancestors and other projects.
in this section we define graftability its granularity these three search spaces and the cost of finding grafts in each of them.
figure depicts how we measure the graftability of a change.
we are interested in the limits of graftability so we formulate the problem as a thought experiment in which we take the commit as a given and ask if we can find its pieces in various search spaces rather than trying to put pieces from a search space together then ask if they form a commit.
we also assume that we can find where a potential graft applies in a target host commit in constant time this assumption is reasonable in practice since commits are small with median range lines figure .
the change shown on the right of figure is the target host for the grafts.
it is cut up into the snippets s1 sn.
we search the donor codebase for grafts that exactly match these snippets.
the shaded snippets in the change are graftable the unshaded snippets are not.
we match snippets that are contiguous in both the host and the donor when possible as with s1 s2.
contiguity holds the promise of reducing the search space section .
.
our interest is redundancy in general not merely the existence of a snippet shared across donor and host we want to track the abundance of grafts in a donor search space as this bears directly on the richness of the search space which we measure using density as defined in definition .
below.
recall that a multiset generalizes a set to allow elements to repeat.
the number of repetitions of an element is its multiplicity .
for example in the multiset fa a a b x yg the multiplicity of ais3.
we use multisets therefore to track the abundance of a particular snippet.
we can view the file fas a concatenation of strings f abg over some alphabet s.snippets are the strings into which any file can be decomposed.
snippets define our unit of granularity they are the smallest units of interest to us.
the smallest a snippet can be is a symbol in s the largest is the file itself.
snippets allow us to treat a file as an ordered multiset of its snippets.
we require ordering to impose coordinates that we use to measure distances.
we define a snipper function sthat fragments a file into its snippets and rewrites the whitespace in each snippet to a welldefined normal form e.g.
a single blank .
for fdefined above s f fa b gg in other words scuts up its input into substrings from which its input can be reconstructed.
the details of how s accomplishes this task are unimportant so we treat sas a black box.
we are now ready to model version control systems including ones that facilitate branching and multi way merges.
a version v of a project is an ordered multiset of files.
dmodels a change or commit in a distributed version control system like gitorhg.
for us eachd vk!vis a function that rewrites a k tuple of versions to produce a new version.
when k dmerges the kparents to form the new version as when a branch is merged into the master branch in a distributed version control system like gitorhg.
our data is drawn from subversion repositories in which branching is rare and k so we drop kwhen writing d v .
in addition to files our snip function sapplies to versions so s v is the ordered multiset of the snippets in all the files in v salso applies to changes so s d is the set of snippets in d. each dis a sequence of snippets added codebase donors1s2s3s4s5s6s7s8s2s1s1s5s7 s3grafts commit hostcontiguous snippetsfigure graftability we break up a commit into the snippets s1 sn then search the donor for these snippets.
the codebase is our donor the target change is the host.
matches for the snippet in the codebase are grafts depicted as rectangles.
a single snippet may have alternate grafts as with s1 we try to match snippets that are contiguous in both the donor and the host as with s2 s3.
the graftability of the change is the proportion of its snippets we can cover from the donor codebase shown in grey.
deleted and modified where a modification is a paired addition and deletion as in myers and in unix diff .
when our snipping function scuts up a commit it retains only the snippets producing a multiset and does not track whether a snippet was added deleted or modified which produces two snippets.
aversion history is the function composition vn dn dn d0 v0 for clarity we write this function composition as an alternating sequence of versions viand changes di v0d0v1d1v2d2 dn 1vn the first version v0is special it can be empty.
when v0 e we have a project s very first commit.
typically v0 e jd0j jdij i because projects often start from a skeleton drawn from another project or inherit code from a prototype.
otherwise we do not have a project s first commit but are starting from somewhere within a project s history as is true in our data set.
v0 vnis the core of a project those lines that remain unchanged between the first and last commits of a version history including lines that may have been deleted then re added in some intermediate versions.
definition .
graftability .the graftability of the change d against the search space sis g d s js d s s j js d j where sis an ordered multiset of snippets and is multiset intersection multiplicity of whose elements is the minimum of its two operands.
the graftability of diagainst its parent is g di vi .
our notion of graftability measures the partial not just total constructibility of changes.
thus it generalizes previous measures which focus on graftability.
this previous focus was natural since such changes are entirely reconstructible.
nonetheless the existence of changes that are highly but not completely graftable falling into the interval suggests that the search for grafts is more generally worthwhile than focusing solely on graftable changes since any nontrivial grafts that are found may considerably constrain the search space even for novel lines.
while it remains to be shown even lower proportions of graftability may be useful since a single graft may in some cases be highly informative.
nonparental ancestral snippets.
the ancestors of the change djare all the changes diwhere i j. our search spaces consist of snippets so when searching a version history our interest is in identifying all the snippets from which a change in principle could be constructed.
one s parent is of course an ancestor but we already consider this search space indeed the plastic surgery hypothesis is couched in terms of a change s parent.
thus here we are interested only in the snippets that did not survive to a change s parent.
this consists of all the snippets in all the ancestors of dj that did not survive to the parent.
thus we define as dj i js di ns vj note that a snippet repeatedly added and deleted in a version history has high multiplicity in equation .
in practice jas dj j j s vj j because snippets rarely die although there are notable exceptions such apache s transition in its .
release to handling concurrency via its multiprocessing modules which abandoned many lines.
search spaces.
letcbe the set of all changes and pbe the set of projects.
the three search spaces we consider in this paper follow.
8di2c s s vi parent s as di i ancestral lines not in parent s p2ps vp head other projects in terms of a version history the existence component of the plastic surgery hypothesis states s di s vi .
search cost.
to compare the relative richness of these search spaces we compute their graft density the number of grafts found in them over their size averaged over all changes.
for the search space sand the change d let grafts s d fl2sj9k2s d s.t.l kg be the grafts found in sfor the snippets in d. this definition of grafts captures the multiplicity in sof a shared element with the consequence that grafts s d s s s d since the intersection on the right hand side computes a set where the multiplicity of each element is the minimum of its two operands.
definition .
search space graft density .thegraft density of a search space is then gd s jcj d2cjgrafts s d j jsj graft density is the search space analog of commit graftability.
it models the likelihood that a searcher guessing uniformly at random will find a graft for a line in a commit averaged over all commits.
in section .
we compute and compare the graft density of each of these three search spaces.
graftability and graft density are the measures we apply to commits and our three search spaces to study the degree to which the plastic surgery hypothesis applies in a large corpus of versioned repositories of project code.project description commits camel enterprise integration framework cxf services framework derby relational database felix osgi r4 implementation hadoopc common libraries for hadoop hbase distributed scalable data store hive data warehouse system for hadoop lucene text search engine library openejb enterprise java beans openjpa java persistence framework qpid enterprise messaging system wicket web application framework figure our experimental corpus projects from the apache project hadoopc is our abbreviation for hadoopcommon .
.
experimental design we describe our corpus and present aggregate statistics for its commits then discuss how we concretely realized our problem formulation for the experiments that follow.
.
corpus our corpus contains the software projects listed in figure .
all are java based and maintained by apache software foundation.
they range in size from to loc from to commits and come from a very diverse range of domains e.g.
service framework relational database distributed data storage messaging system and web applications.
we mined apache s git repository1to retrieve the change history of the projects from to .
since apache uses subversion and provides only git mirrors all the changes belong to a single branch.
using git allowed us to access to relevant attributes for each change such as date committer identity source files where the change applies and so on.
moreover since all the projects use the jira issue tracking system2 for each change we were also able to retrieve the kind of issue e.g.
bug fixing or enhancement commits its status e.g.
open closed and its resolution i.e.
fixed incomplete .
depending on how an organization uses jira a change could represent a software bug a project task a help desk ticket a leave request form etc.by default jira specifies the following five change types .bug a problem which impairs or prevents the functions of the product.
.improvement an enhancement to an existing feature.
.new feature a new feature of the product.
.task a task that needs to be done.
.custom issue a custom issue type as defined by the organization if required.
the first four types are self explanatory.
the last category groups issues not covered by the other four but needed by an organization using jira.
in our dataset the commits belonging to this set generally concern user wishes testing code and sub tasks.
each issue has a status label that indicates where the issue currently is in its lifecycle or workflow .open this issue is ready for the assignee to start work on it.
.
.type camel cxf derby felix hadoopc hbase hive lucene openejb openjpa qpid wicket bug improvement new feature task custom issue figure count of commit types in our corpus.
commit type median mean st. dev.
bug .
.
improvement .
.
new feature .
.
task .
.
custom issue .
.
figure commit size aggregate statistics.
.in progress this issue is being actively worked on at the moment by the assignee.
.resolved a resolution has been identified or implemented and this issue is awaiting verification by the reporter.
from here issues are either reopened or are closed.
.reopened this issue was once resolved or closed but is now being re examined.
.closed this issue is complete.
this means it has been identified implemented and verified by the reporter.
an issue can be resolved in many ways.
the jira default resolutions are listed below .fixed a fix for this issue has been implemented.
.won t fix this issue will not be fixed e.g.
it may no longer be relevant.
.duplicate this issue is a duplicate of an existing issue.
.incomplete there is not enough information to work on this issue.
.cannot reproduce this issue could not be reproduced at this time or not enough information was available to reproduce the issue.
if more information becomes available the issue can be reopened.
an issue is initially open and generally progresses to resolved then closed .
a more complicated life cycle includes an issue whose initial resolution was cannot reproduce then changed to reopened when the issue becomes reproducible.
such issues can subsequently transition to in progress and eventually to won t fix resolved orclosed .
figure shows the number of changes distinguished per type related to the projects contained in our corpus.
we considered only those changes that have been successfully closed i.e.
status closed and resolution fixed .
moreover we did not consider changes made to non source code files or containing only comments.
as result we analysed a total of commits.
figure shows the size of the different kinds of commits considered in this study.
note that we did not take into account deleted lines since they are obviously graftable from the parent.
we can observe that on average bug commits are smaller than all the other types of commits while improvement commits are the largest.
figure shows the size of each project s core the lines that survive untouched from the first version to the last in our versionhistories for each project.
the existence of nonempty first commits is one the reasons for the effectiveness of the plastic surgery hypothesis which searches these lines in contrast to approaches that focus solely on changes.
as figure shows the core varies from negligible to dominant at in the case of hive .
.
methodology we used git to clone and query the histories of the projects in our corpus and extracted the related jira information section .
into a database.
for each project in our corpus we issued git reset hard commit to retrieve a specific version.
this command sets the current branch head to commit modifying index and working tree to match those of commit .
to retrieve a specific change we issued git diff on a commit and its parent and extracted the commit lines i.e.
the lines to be grafted.
we used the jgit api3to automate both tasks.
to realize the snipping function we wrote a lexer that snips a file into a multiset of code lines then from each line removes the comments and semantically meaningless content such as whitespace and syntactic delimiters to normalize the lines.
we ran this lexer over each search space then loaded the resulting multiset into a hash table whose key is normalized source line to speed up the search for grafts and the value is a pair that stores the source line c and its multiplicity.
to compute graftability from definition .
of a commit we looked up each normalized commit line in the hash table of the commit s parent and divided the number of hits by the number of lines snippets in the commit.
.
results and discussion to open we validate the plastic surgery hypothesis the core result of this paper both its well known first claim the existence of grafts as well as its heretofore neglected second claim about that a change s parent is a rich search space for grafts.
we then consider features of grafts with the aim of discovering correlations that might help us better decide which software engineering task would benefit most from being augmented with searching an existing codebase.
we turn to the question of graft contiguity that is for a swath of adjacent lines in the host can we find an equal sized contiguous donor?
if we can it means we can reconstruct the human generated patches we are studying more easily with promising implications for automated construction.
we close by considering the distribution of grafts in the donor search space.
.
plastic surgery hypothesis for convenience we reproduce our central hypothesis research question changes to a codebase contain snippets that already exist in the codebase at the time of the change and these snippets can be efficiently found and exploited.
.project camel cxf derby felix hadoopc hbase hive lucene openejb openjpa qpid wicket average core .
.
.
.
.
.
figure the size of each project s core.
the core consists of those lines that are unchanged from the first version to the last in the studied portion of a project s version history.
.
.
.
.
.00graftabilitycount figure the number of the commits that are x graftable.
above by changes we mean all commits made and by codebase we mean the search spaces we defined in section a commit s parent vi its ancestral lines not in its parent as di equation in section and the latest versions in our corpus of the other projects.
this question explores the limits or conversely the potential of automatic programming how many changes are constituted of snippets that already exist in the code base or its history at the time when the commit is applied?
to answer this question we analysed the graftability of commits coming from a corpus of software projects section .
.
for the commit di we model its graftability as shown in definition .
in section .
nongraftability or novelty is1 graftability .
the results immediately prompt us to wonder how many commits are fully graftable and how many are entirely novel?
figure shows the distribution of graftability over the commits.
we can observe that a large fraction of the commits are more than graftable.
more notably of the commits can be completely reconstructed from grafts.
this result aligns with that of mart nez et al.
who found that of the change in their dataset could be entirely reconstructed .
only of our commits are utterly novel.
this data thus clearly suggests confirmation of the first snippets that already exist component of the plastic surgery hypothesis.
this finding relates to gabel and su who found very few unique non recurring snippets even of considerable length in a large line corpus of code however the mere existence of recurring snippets within this formidably large corpus offers scant hope of feasible graftability .
we however compute the graftability of commits not arbitrary snippets of the codebase.
gabel and su s was a scientific finding unconcerned with the feasibility of searching for grafts.
the efficiently found part of the plastic surgery hypothesis is about where to efficiently search it states the parent s entire codebase and perhaps just the file where the commit applies section .
of the commit is the best place to search both in terms of richness and cost in terms of the likelihood of finding a graft in a set of lines in the donor search space.
should we just search the parents and ancestors of the commit to be grafted?
or should we searchother projects in the same language?
to this end we address the following research questions rq1 a how do parents fare as possible sources of grafts when compared to nonparental ancestors and other projects?
rq1 b how do parents fare as efficient sources of grafts when compared to nonparental ancestors and other projects?
figure 7a and figure 7b show the boxplots of the graftability and density values obtained over the commits when varying the search space from the considered sources a commit s parent b its ancestral lines not those found in its parent and c the latest version of other projects as defined in section .
figure 7a bears upon the existence of grafts in the three locations.
graftability from parent is much higher than graftability from the nonparental ancestors and than graftability from other projects.
this is not that surprising and at least partially reflects differences in vocabulary variable names type names method names etc.
between projects.
similar inter project differences were reported in statistical models of code .
code bases tend to monotonically grow in size so most lines survive from their first introduction to the parent of a given commit.
thus the nonparental ancestors search space consists of deleted lines.
a consequence of the fact that we do not find many changes in the nonparental ancestral lines is that there are not many regretted deletions deletions that are later re added.
figure 7b bears upon the efficiency of finding grafts in different search spaces in terms of the the density measure defined in definition .
.
we ignore the density figure for non parental ancestors because as figure 7a indicates they tend to be of low value in graftability.
we can observe that density of parent is higher than density from other projects.
since the boxplots showed no evidence that our samples come from normally distributed populations we used the wilcoxon signedrank test to check for statistical significance.
in particular we tested the following null hypotheses h0a there is no significant difference between the graftability from parent and the graftability from nonparental ancestors.
h0b there is no significant difference between the graftability from parent and the graftability from other projects.
h0c there is no significant difference between the density in parent and the density from nonparental ancestors.
we set the confidence limit a at0 05and applied benjaminihochberg correction since multiple hypotheses were tested.
to assess whether the effect size is worthy of interest we employed a non parametric effect size measure namely the vargha and delaney s a12statistic .
according to vargha and delaney a small medium and a large difference between two populations is indicated by a12over .
.
and .
respectively.
the results revealed that there was significant statistical difference p between the graftability from parent and nonparental ancestors in favour of the parent codebase with high effect size a12 .
the wilcoxon test also revealed that there was statistical difference between the graftability achieved between parent and other projects codebases in favour of parent with high effect sizeparentnonparental ancestorsotherprojects0.
.
.
.
.
.
a graftability of a commit over commits .
parentotherprojects125102050100200 b density log scale of the search spaces over commits .
figure graftability of a commit a and cost to search for its grafts b as the search space changes from the commit s parent its ancestors excluding its parent and other projects.
p a12 .
the wilcoxon test between the density of the commit s parent and those of other projects revealed significant statistical difference p in favour of the commit s parent with high effect size a12 .we therefore reject the hypotheses that the search spaces are indistinguishable and affirm the plastic surgery hypothesis.
.
graftability by commit size next we consider the fact that commits vary considerably in size.
some are quite small in fact about half of all bug fixes are under lines of code.
some commits contain as many as lines of code.
the question naturally arises is automatic patching only likely to succeed on small patches?
one part of this is the existence question do grafts exists only for small patches?
.
this motivates our second research question research question how does graftability vary with commit size?
figure shows the relationship existing between commit graftability and commit size.
the plot is a binhex plot which is essentially a two dimensional histogram.
the x axis is the size of the commit and the y axis is the graftability value for commits of that size.
each hexagon is a bin which counts the number of size graftability value pairs that occur within the euclidean range bounded by that hexagram.
the color of the hexagram reflects the count of those pairs that fall within a given bin lighter colors reflecting a larger count.
the figure has some interesting patterns for low values of commit size which arise from discrete fractions with small denominators and their complements e.g.
.
but these are just a distraction.
the main trend visible in this plot is the absence of one surprisingly there appears to be no relationship between graftability and commit size one might rather expect that as commit size increases there are more snippets to search for and thus we might have more difficulty in finding them thus leading to lower graftability.
no such trend is visible.
to confirm this rather strange phenomenon we estimated a linear regression model to judge the effect of commit size on graftability.
this can be seen as model in figure .
the response variable was graftability and the predictor variable used in model was the commit size log scaled.
the coefficient is very significant p indicating very low probability of observing the data if the true regression coefficient were zero in other words we would be very unlikely observe the data if graftability of a commit had .
.
.
.
.
size of commit loc logscale graftability from parent 300600900countfigure does commit graftability vary with commits size?
no linear dependence on log commitsize .
this might seem rather surprising given that no such dependence is visible in figure .
the resolution to this puzzle is clear from the values of r2and sample size on the bottom rows of model just of the variance in graftability is explained by commit size!
in other words varying the commit size has an extremely weak effect on the variance in graftability however even this weak explanatory power is divined as statistically significant by the linear regression thanks to the large number of samples .
we conclude that commit size has a negligible effect on the variance in graftability.
.
graftability by commit type commits are made for different reasons.
as noted in section the commits in our jira data are tagged as one of bug improvement new feature task orcustom issue .
it seems reasonable to wonder whether different types of categories have different graftability.
if there were a strong difference this could tell us which software engineering tasks are most likely to benefit from techniques that0.
.
.
.
.
bugimprovement new feature taskcustom issuegraftability bugimprovement new feature taskcustom issuecommitsize log scale figure graftability obtained for five different kind of commits.
rely on the plastic surgery hypothesis.
for instance it seems likely that a new feature commit would be less graftable than one tagged bug since bugs often appear in multiple locations and may have already been fixed in some but not all of those locations.
the prior fixes would then be grafts available for fixing the bug of the missed locations.
compare this to new feature where especially if new feature is complex seems more likely to contain novel lines that do not already exist in the system.
this leads to the next question.
research question do different kinds of commits exhibit same graftability?
to answer this question we compared the graftabilty of different types of changes in our dataset bug improvement new feature task custom issue .
figure shows the boxplot upper plot of the graftability obtained for the five commit types.
the lower plot shows the commit sizes for the different kinds.
the lower plot is logscaled on the y axis.
it is noteworthy that the lower plot shows some differences in the sizes of different types despite the log scaling differences are less visible in the upper plot.
to confirm the visual impression that commit types do not affect graftability we added the type of commit as a factor variable to the regression model discussed earlier yielding model in figure .
in this model the effect of each kind of commit as a factor is compared to graftability of the bug commit type to check if such comparisons have any added explanatory power beyond that provided by commit size and also to see what that effect might be.
in the combined model variance inflation was well within acceptable limits.
this finding echoes that for commit size.
while improvement andtask commit types are statistically significantly less graftable than the bugcommit type the actual explained effect is very small.
ther2value essentially remains numerically essentially unchanged.
if we consider the commit type by itself as an explanatory factor variable we can only explain about 001of the variance in graftability model is omitted .
the high significance of this very small effect reported by the regression modeling exercise is simply a result of the large number of samples.
thus we come to the rather unex model model intercept ?
??
?
??
.
commit size log scale ?
??
?
??
.
improvement vs.bug ?
??
new feature vs.bug task vs.bug ?
??
custom issue vs.bug r20.
.
adj.
r20.
.
number of observations ?
?
?p figure size has little effect on graftability as demonstrated by two regression models with graftability as response although both models find commit size to be strongly statistically significant with p and the standard errors shown within parentheses are all small r2shows that these models account for only of the variance in graftability.
pected conclusion that a commit s type has no significant practical impact on finding a graft for that commit.
.
graft contiguity once a technique has found grafts it must arrange and order them to transplant them into a host change.
composing grafts at line granularity to re construct a change even when that change is graftabilty faces a combinatorial explosion of all the permutations of that graft.
novel nongraftable lines exacerbate the problem.
this graft composition search space would be more manageable if grafts were bigger.
intuitively code decomposes into semantic units that are sometimes bigger than the granularity at which one is searching for grafts.
if we could find these units we could use them to constrain the change re construction search space.
thus we ask how often can we find contiguous grafts of size greater than a single line in both the host and the donor.
when trying to constitute a commit using snippets that already exist in the code a natural intuition is that larger chunks will make constituting such a commit easier.
at the extremes searching individual lines in the code that make up a commit would certainly be harder than serendipitously finding all the lines in a commit altogether in one area of code.
we now attempt to formalize this intuition.
for this we refer the reader back to figure .
consider the snippet sequence s1 s8.
this sequence constitutes the commit.
in this we show how the snippet sequence s2 s3iscontiguous in both the donor and in the change host we seek to reconstitute.
if this were a common occurrence the heuristic of search of attempting to constitute commits in groups of lines would be quite effective.
when contiguous host snippets are constituted from single or very few donor snippets the search for donor snippets is simplified and accelerated.
this leads the following question research question to what extent are grafts contiguous?hostdonor25102050figure how big are contiguous grafts?
the figure reports the size log scale of both host and donor snippets.
a commit in its role as the target host determines the maximum size of the contiguous region.
contiguous regions of grafts in the donor larger than the largest contiguous region of snippet in the host must necessarily be broken up when transplanted.
it is very convenient when a contiguous graft in the donor matches a contiguous site in the host the more often this occurs the more likely we are to be able to bite off larger chunks of code from the donor and shoehorn them to reconstitute substantial pieces of the commit so we ask rq4 a how often do contiguous regions in the donor match contiguous regions in the host?
how big are they?
we found host snippets and donor snippets both consisting of two or more consecutive graftable lines.
so we can positively answer the question continuous graftable regions often appear in both hosts and donors.
figure shows the size of both host and donor snippets.
we can observe that the average size of a host snippet i.e.
.
lines is about twice the one of a donor snippet i.e.
.
lines this indicates that not all the snippets can be entirely grafted from a single donor and explains the fact that the donor snippets are more than the host snippets.
however in particular when these continuous regions are exactly matched in size we can simply pluck them out of the donor and paste them into the host essentially these are little pieces of micro clones that are reproduced in commits.
rq4 b what is the distribution of host and donor snippets of the same size?
examining the number of contiguous snippets in both host and donor that have the same size we found that a host snippet can be grafted from a single donor i.e.
fully matched snippets in cases while in the remaining cases more than one donor is needed.
figure shows the number of fully matched snippets grouped by size.
we can observe that the majority of these snippets has size while the has size and only .
has size then as we can observe from the figure the trend dramatically decreases.
rq4 c counting contiguous grafts in the donor as a single site how many distinct donor sites do we need in order to cover a transplant point in the host?
since of the donor s snippets does not fully match a host s snippet we are interested in how many donors are needed on average to graft a given host snippet and how difficult is to look for these donors see next section .
we found that donors are needed on average to graft a given host snippet.
the above results revealed that continuous graftable regions often 0204060fragment sizesqrt count figure how many host and donor snippets have the same size?
the figure shows the number square root scale of those host and donor snippets having the same size.
appear in both hosts and donors.
more than a half of host snippets can be grafted from a single donor.
in the remaining cases two donors are needed on average to graft a given host snippet.
.
graft clustering an important factor in the computational feasibility of automatic commit synthesis is the search space size.
if one had to search for suitable donors all the time over the entire possible space of donors e.g.
the entire previous version of the project it would be much less efficient than if one could just search near the locus of the commit such as in the same file the same directory etc.
this motivates the next question research question are the snippets needed to graft a host snippet in the same file?
fortunately we find that of the donor snippets can be found in the same donor file and in the same package.
this is an encouraging result suggesting that donor snippets are often found in the same file not requiring more extensive search.
.
threats to validity this section discusses the validity of our study based on three types of threats construct internal and external validity.
construct validity asks whether the measures taken and used in an experiment actually measure phenomenon under study.
internal validity concerns the soundness of the methodology employed to construct the experiment while external validity concerns the bias of choice of experimental subjects.
section .
describes how we automatically computed our measures.
to mitigate the threat of an implementation error we applied unit testing and one of the authors manually verified the accuracy of the measurements of commits selected uniformly.
to address internal validity we carefully verified that our data met all required assumptions before applying statistical tests and the regression model.
moreover our graftability results are low relative to the standard finding of redundancy in the clone literature.
this is probably due to our choice of considering exact matches over whitespace normalized but otherwise untouched and notably unobstructed source lines.
we adopted this choice because abstraction reduces the semantic content of lines such as that containedin identifiers which must then be restored.
thus we choose exact matching because of our belief that these lines would be strictly more useful for techniques relying on the plastic surgery hypothesis.
relaxed notions of matching are a distinct and interesting avenue of research that has witnessed positive results .
as for the external validity the projects in our corpus are all open source apache projects.
although they differ in domain and size section .
we cannot claim that our findings generalize to other software systems.
however we have formally stated the problem section and described our methodology section .
to facilitate the replication of our study.
.
related work it has been known for some time that the production code contains software clones .
these can be verbatim cut and paste copies of code so called type clones or might arise from a more elaborate cut modify and paste process so called type and type clones .
the presence of code clones has led to much work on techniques for investigating and evaluating this form of apparent redundancy .
more recently authors have sought to measure the degree of redundancy in code and the commits applied to it.
gabel and su sought to answer the question how unique and how repetitive is source code?
in an analysis of approximately 420m sloc from open source software projects.
they observed significant syntactic redundancy at levels of granularity from tokens.
for example at the level of granularity with tokens the projects were between and redundant.
this suggests that code contains a great deal of redundancy that could potentially be exploited by code improvement techniques.
however gabel and su did not consider code commits nor the cost of finding redundancy.
nguyen et al.
sought to answer the question how often do developers make the same changes commits they have made before?
studying 8m revisions to 841open source projects .
they defined a repeated change to be an ast extracted from a change that matches an ast from a previous change in some project s history including the same project.
over asts they found that changes are frequently repeated with the median line change having a chance of having been performed elsewhere.
the repetitiveness dropped exponentially as the granularity number of lines increased for line and greater granularity it was typically below .
this commit redundancy meant that future changes could be recommended with over accuracy.
mart nez et al.
also recently studied commit redundancy focusing their attention on commits they term temporally redundant or in our terminology graftable changes.
graftable lines are interesting because they are in principle entirely reconstructible.
our measure of graftability in definition .
additionally measures the degree to which a commit is graftable.
like nguyen et al.
and gabel and su they find a perhaps surprisingly high degree of redundancy in the code they studied.
our work has two primary methodological differences to this previous work on commit redundancy we consider the cost of finding a graft which the previous work does not and we are concerned with code commit graftability rather than just commitcommit redundancy a special case of graftability.
that is we consider the full code space in assessing graftability whereas previous work focussed on commits alone.
in terms of our formalism both nguyen et al.
and mart nez et al.
search the set of changes or deltas in contrast we focus on versions and therefore search the lines in v0 vn the project s core lines which can dominate a version history accounting up to of the lines in the finalversion as we show in section .
.
if we had a full commit history starting ab initio with the empty system then we could assume that commit commit and code commit approaches would study largely the same information.
however since version histories typically do not go back this far that assumption is invalid the current version of a system is not merely the product of the sequence of commits for which information is available.
assessing the degree of code commit graftability has implications for work on program improvement an area that is witnessing a significant upsurge in interest.
program improvement seeks to automate improving an existing code base with relatively small modifications.
examples include repairing the code base enhancing its properties or even migrating it to other systems .
all these program improvement approaches share the foundational assumption that many software systems contain the seeds of their own improvement.
they are united by the way they search for extract and recombine fragments of code to create desired new functionalities and behaviours.
in order to assess the potential of this search space we need to study not just commit commit redundancy but also code commit graftability.
by assessing code commit graftability we seek to shed light on the degree to which a commit made by a human could have been found by a machine and the cost of so our results on the degree and cost of graftability or within system code commits are relevant to program improvement work that searches for modifications in existing system or which finds patches from elsewhere in the system .
our results on graftability between systems are relevant to program improvement work that searches for transplants from one system to another .
overall our results provide further evidence to support claims that it is promising to mine human commits for patterns templates and code fragments that can be reused to improve systems.
this is a technique to which other authors have recently turned for automated program improvement and for semi automated improvement as decision support to software engineers with promising results.
.
contributions in this paper we validated the plastic surgery hypothesis with a large scale experiment over commits from java projects.
our core finding is that the parent rather than non parental ancestors or other projects of a commit is by far the most fecund source of grafts.
we also find encouraging evidence that many commits aregraftable they can be reconstituted.
we also find that grafts are often contiguous which suggests heuristics that attempt to graft commits out of multiple contiguous lines.
finally we find that fully of the elements of commits can be found within the same file.
these are encouraging results for automatic program repair techniques that exploit the plastic surgery hypothesis.
it is also true that there are fragments of commits that are not graftable.
the complement of graftability measures the novelty of changes.
as future work we intend to explore if the feature set of novel changes is more predictable than we have found grafts to be again with the aim of identifying which sorts of changes are most likely to profit from the plastic surgery hypothesis.
.