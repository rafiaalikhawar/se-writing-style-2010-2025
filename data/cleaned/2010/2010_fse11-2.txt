fault localization for data centric programs diptikalyan saha ibm research india diptsaha in.ibm.commangala gowri nanda ibm research india mgowri in.ibm.compankaj dhoolia ibm research india pdhoolia in.ibm.com v. krishna nandivada ibm research india nvkrishna in.ibm.comvibha sinha ibm research india vibha.sinha in.ibm.comsatish chandra ibm t. j. watson research ctr satishchandra us.ibm.com abstract in this paper we present an automated technique for localizing faults in data centric programs.
data centric programs primarily interact with databases to get collections of content process each entry in the collection s and output another collection or write it back to the database.
one or more entries in the output may be faulty.
in our approach we gather the execution trace of a faulty program.
we use a novel precise slicing algorithm to break the trace into multiple slices such that each slice maps to an entry in the output collection.
we then compute the semantic difference between the slices that correspond to correct entries and those that correspond to incorrect ones.
the diff helps to identify potentially faulty statements.
we have implemented our approach for abap programs.
abap is the language used to write custom code in sap systems.
it interacts heavily with databases using embedded sql like commands that work on collections of data.
on a suite of faulty abap programs our technique was able to identify the precise fault location in cases.
categories and subject descriptors f. .
program analysis d. .
debugging aids general terms algorithms languages keywords automated debugging data centric languages slicing semantic differencing .
introduction bug resolution is an important activity in any software maintenance project.
bug resolution for problems reported on applications already in use in production has two main implications.
first a client has discovered a bug in the field and so it needs to permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.be fixed urgently.
therefore it is important to have good tool support that can help the programmer debug the program as quickly as possible especially when the person who is debugging the code is not the programmer who originally wrote the code.
second the bug has surfaced despite the fact that the code has been tested and has probably been running in the field for some time.
that means it is likely to be an unanticipated corner case in otherwise correct code and automated tools can focus their effort on identifying such corner cases.
the techniques presented in this paper were developed to aid in faster resolution of programming errors reported for abap programs.
abap is a widely used propriety language used in saperp systems and is heavily data centric in the tradition of pl sql and cobol.
data centric programs process large collections of data that typically originate from a database.
abap contains both imperative and declarative syntax.
the declarative syntax is similar to sql and allows developer to do complex operations on collections of data.
henceforth we refer to this declarative sql like commands in abap as database statements.
figure shows a sample program written in abap and figure explains the syntax of each of the commands.
this program represents a business application that creates a report of orders placed by different customers.
figure a shows a sample input and output data combinations from the program.
each correct output row is followed by ap.
the output row that is considered incorrect is marked with a and is followed with the expected correct output.
the ordertab table contains the order details such as customer who placed the order cstid item ordered itemid its price price and year in which the order was placed 1select cstid itemid price year from ordertab into itab 2select cstid discount year from discounttab into stab 4sort itab cstid itemid 5del from itab where year currentyear .
6loop at itab into wa at new cstid amount endat amount amount wa.price read stab into fa where cstid wa.cstid if subrc amount amount fa.discount endif at end cstid write cstid amount endat endloop figure sample abap programcommand description select project selected columns from a persistent database table to an internal table in the program sort sorts the specified internal table on specified key s del deletes rows from a table that satisfies the condition loop iterates over an internal table reading one row at a time into a local record at new a predicate that is true for a given row and field name s at end when the row is the first last one in the table or when the field s value in the current row is different from the previous next row read selects a row from table based on the where clause.
if more than one row matches the last row is returned write prints the specified data wa.f field fof structure wa actual abap syntax wa f figure basic abap syntax a ordertab itab cstid itemid price year i1 .
i2 .
i3 .
output cstid amount .
.
x discounttab stab cstid discount year .
.
b 13line .
line .
figure a input and output for the abap program illustrated in figure .
b dynamic slices for each output row.
year.
the discounttab table contains the discount applicable per customer per year.
the output shows for each customer the total order amount.
at the code level the program first reads the input data from ordertab anddiscounttab into internal tables itab stab lines sorts table itab line and deletes records older than year2010 line .
the currentyear variable is a parameter to the program and has value .
the program then loops over the contents of itab line sums up the price line subtracts any a ordertab itab pre cstid itemid price year i1 .
i2 .
i3 .
itab post cstid itemid price year i2 .
i3 .
2011discounttab stab cstid discount year .
.
output cstid amt .
0x .
.
.
.0x b 2line .
line .
15slice c 13line .
line .
16key cstid key cstid keyslice figure a input and output for the abap program illustrated in figure .
b dynamic slices for each output entry.
c key based slices for each output row.
a ordertab itab cstid itemid price year i1 .
i3 .
output cstid amount .
.
xdiscounttab stab cstid discount year .
.
.
b 13line .
line .
16key cstid key cstid 6keyslice figure a input and output for abap program illustrated in figure .
b key based slice for each output row.
relevant discount line and prints out the total line .
one output entry is generated for each unique cstid present in the input ordertab .
there are several challenges involved in developing fault localization techniques for these types of programs.
the first challenge is that the analysis needs to handle both the imperative and declarative parts of the language.
what should be the correct representative semantics for the different sql like commands in an abap program?
another challenge is that the analysis needs to be data driven as the behavior of a command is very often dependent on the underlying data.
thus the same command at the same program point may run without any problems for most of the data and yet may throw an exception or generate incorrect output for some other data.
as we shall see later in the paper for the example shown in figure depending on the combinations of data available in the ordertab and discounttab tables three different bugs can manifest themselves in the output.
problem resolution methodology.
a large body of past work on fault localization relies on the usage of program slicing .
the basic idea in these techniques is that when a program computes a correct value for a variable xand an incorrect value for variable y the fault is likely to be in statements that are in the slice with respect to ybut not in the slice with respect to x .
similarly if a program computes correct value for a variable xin a particular test case and computes incorrect value in another test case then the potentially faulty statements would be in the difference between the slices of these two program executions .
our problem resolution methodology is motivated by these prior works and attempts to apply the same in the domain of data centric programs.
one of the key challenges in applying any of the slicing based fault localization techniques in real world debugging scenarios is the lack of significant number of test cases that show the correct behavior of the program.
these test cases are needed to collect the execution traces of correct examples that can be differentiated with the trace for the incorrect execution as reported in the bug description.
however in the context of data centric programs we can leverage the fact that a single run of the program yields an execution trace that can in turn be split into multiple independent slices each of which is responsible for a single record in the output.
this is because these programs typically loop over the input data records aggregate the input depending on certain key fields and generate an output record per key value.
in the case of the example discussed above the key field was cstid .
a defective program writes incorrect values for one or more key values.
further if a user specifies that certain output rows are incorrect and we assume that the rest of the output is correct we can associate a incorrect or a correct tag with each slice corresponding to each row of output.
we can then compute the difference between the correct and incorrect slices to discover the statements that are potential sources of bugs.
to identify the bug reported in figure a denoted by the output row postfixed with mark we first collect the dynamic trace by running it on the input that reveals the problem.
we split the trace into multiple slices by applying dynamic slicing starting at each instance of line write in the execution trace.
figure b shows the slices.
we then compute the difference between the slices to identify that line through are executed twice in the first slice versus once in the second slice.
the lines are highlighted as fault inducing statements.
this finding relates to the problem that the discount should have been given only once per customer.
in the corrected code done manually by the programmer lines through were moved inside the at end block after line .
key based slicing.
it may appear that we can always generate incorrect and correct slices and apply a differencing technique to this setting.
however this is not the case as the dynamic slice based on simple data and control dependence may not differentiate between a correct and an incorrect execution slice.
consider the bug reported for the same program using input data in figure a .
in this case the user was expecting to see the amount value as .
forcstid considering that we have the code as it is in figure .
however the code is deleting all order records that are older than years line .
this means the conditional in delete statement in line is incorrect or incomplete.
the slices for both the output rows are the same as shown in figure b and hence differencing will not be able to identify any faulty lines.
we resolve this by enhancing the existing dynamic slicing with the introduction of a key in the slicing predicate.
the intuition for this is as follows.
usually in a data centric program as part of the output record one or more input fields are written that together act as the identifier or key for the data and is unchanged from the input to output.
for our example this field is the cstid .
so besides using an execution of a particular statement as the predicate for our slice we also use the value of this key field as our slicing criterion.
figure c shows the key based slices.
line is only showing a side effect for records inordertab with cstid .
the values in the table itab before pre and after statement post are shown in figure a .
once we do a differencing on these key based slices our technique highlights line as the potential fault inducing code as it effects the incorrect slice and not the correct slice.
semantic differencing.
in some cases even key based slicing is not enough to differentiate between slices.
consider the input data in figure a for the same program.
here the key slices for both the output records are the same.
the actual difference is in the behavior of line in its two different executions.
the read statement in abap returns only a single matching record.
if there exist multiple records that match the selection criterion where clause then it returns the first one.
for cstid line would need to select from two records while for cstid there is only one matching record.
hence the behaviors of the read statement for these two keys are different.
our semantic differencing algorithm identifies such statements in the execution trace where different behavior of the command statement have been exercised in the correct and incorrect key slices and highlights them as potential faults.
for the example application the fix is to change the read stmt as read stab into fa where cstid wa.cstid and year wa.year such that appropriate year wise discount is availed.novelty and contributions.
key based slicing and semantic differencing are novel generalizations of previous work on fault localization based on comparing program executions.
prior work in this area mostly takes into account just whether a statement appears in one slice but not in another one but it does not take into account the manner in which it appears in a slice.
key based slicing also takes into account the relevance of execution of statements to specific keys that were used in creating those slices this is important in the context of data centric programs.
semantic differencing contributes yet another attribute of statement execution where the behavior of statement execution on specific input data is taken into account.
we believe that our work is among the first to successfully adapt and extend fault localization techniques to data centric programs that occur in an industrial setting.
we have built a tool that takes an execution trace of an abap program and an indication of the buggy part of output.
the tool then offers diagnosis of faults based on the techniques presented in this paper.
in most cases the diagnosis if found was a single statement for semantic differencing we were looking for only a single statement difference .
our experiments with the tool show that the above differencing techniques were able to accurately localize faults in out of abap programs provided to us by our colleagues in ibm global business services.
these abap programs were either old versions of some programs where there was a known defect that has since been fixed or were programs in which a realistic defect was seeded by them.
a baseline version of the tool that did not incorporate the generalizations of differencing mentioned above was effective only in out of the programs.
organization.
in the next section we give the details of our slicing algorithm.
in section we elaborate on the differencing algorithm.
in section we give the results of running our analysis on field bugs.
section describes the related work and we conclude in section with some additional discussion on future work.
.
dynamic slicing the efficacy of our differencing algorithm cf.
section depends on the accuracy of slicing.
in this section we present an algorithm that performs precise backward dynamic slicing on execution traces containing database commands.
each slice is computed starting from a statement occurrence lineseq that produces a row in the output and on a set of variables v occurring in the statement.
this constitutes the slicing criteria hlineseq vi.
we refer to the slices producing incorrect output as incorrect slices and to the slices producing correct output as correct slices.
the slices obtained in this way are analyzed with a differencing algorithm to reason about the possible faults present in incorrect slices.
traditional slicing algorithms are oblivious to the rows and fields of tabular data i.e.
table accesses are treated as table .
.
this results in overly conservative slices that are not effective in differencing data centric programs.
we obtain a row and field sensitive algorithm based on the existing techniques of handling non scalar data .
our algorithm is built on top of precise to the field row level dependency information which can be obtained from the semantics of the statement and the data present in the execution trace.
for example the effect of a delete statement on a table is modeled such that it is possible to know the shift of indices of all the rows.
the data effect of the delete statement will contain all those rows whose table index is changed by the delete statement.
in general for each compound statement its final effect is represented by a set of assignment statements and a set of def use pairs are identified from the assignment statements.
a execution trace list of linesequenceid iqstatement 1628write amount 1527at end cstid itab.length 1325amount amount fa.discount amount fa.discount itab.length 1224ifsubrc subrc amount fa.discount itab.length 1123read stab into fa amount stab .discount where cstid wa.cstid wa.cstid itab.length 1022amount amount wa.price amount wa.price itab.length stab .discount wa.cstid 820amount wa.price itab.length stab .discount wa.cstid 719at new cstid wa.price itab.length stab .discount wa.cstid itab .cstid itab .cstid 618loop at itab into wa.
itab .price stab .discount itab .cstid itab.length itab .cstid 54del from itab where .. itab .price stab .discount itab .cstid itab.length itab .cstid 22select .. from discounttab itab .price itab .cstid into stab discounttab .discount itab.length itab .cstid 11select .. from ordertab ordertab .price into itab discounttab .discount ordertab .cstid ordertab .cstid b update of data dependency set figure example slice computation the execution trace of the example in figure for input data specified in figure is presented in figure a .
figure b shows the update of the data dependency information after including each statement occurrence in the slice that is computed for the amount variable in the second row of the output generated at statement occurrence .
note that due to shift of indices and its effect on the length of the table the statement 54is included in the slice.
the delete statement actually does not affect the computation that is done for the second row of the output as the addition is not performed on elements which have year value .
thus inclusion of delete statement in this slice makes it imprecise.
whereas the slice computed with criteria h1615 famountgishould include the delete statement as the deleted rows affect the computation performed to compute the sum at .
.
key based slicing as discussed above the row and field sensitive slicing algorithm can result in imprecise slices.
an important question to answer is when does a statement occurrence become a part of the slice?
our dynamic slices represent the computations that affect specific rows in the output.
a statement occurrence is not considered to be a part of the slice if its absence has no effect on the computation of the variable values in the output row associated with the slice.
if a statement occurrence only affects the position of a row in the output and not the values we do not consider the statement to be part of the slice.
in our experience it was the content of the row and not the order in which they occurred in the output that was more commonly observed to be at fault.
to determine whether a statement occurrence is effecting thevariable values in the slicing criteria we need to check two conditions c1 if the statement occurrence is performing any operation that defines a variable in the dependency set c2 if the absence of the statement can change the dependency set in terms of addition or deletion of elements.
if either of the conditions c1 orc2is true the statement is added to the slice.
the statements that could change the dependency set by adding deleting elements are called db change statements.
the delete statement in our running example does not satisfy the condition c1for the slices corresponding to either row of the output.
the condition c2is satisfied for the first row of output in the presence of the delete statement the dependency set in the slice corresponding to cstid contains ordertab .price as shown in figure b whereas in the absence of delete statement that slice would have contained ordertab .price andordertab .price .
however the conditionc2is not satisfied for the delete statement in the slice corresponding to the second output corresponding to cstid as in the absence of the delete statement the dependency set would have still contained only ordertab .price .
the condition c1is straightforward to check and it is assumed that this check is precisely done as a part of field row sensitive algorithm for the non db change statements.
we now present a criteria to check the condition c2on the db change statements.
the purpose of this criteria is to remove a statement from the slice which otherwise would be included in the slice by a field rowsensitive algorithm which takes conservative decision for inclusion of such database statements in the slice.
the criteria has two parts key value condition and sequence condition.
the first condition can be motivated by revisiting the running example.
it is evident that the slices with respect to the criteria h1628 famountgiandh1615 famountgihave association with keyvalue pairshcstid 2iandhcstid 1irespectively.
with this association whether to include the statement occurrence 54can be easily checked by determining whether the deleted rows match the key value pairs.
in general we say a row rmatches a key value pair k v if the value of key kin row ris equal to v. a statement is not included in the slice if any change performed by the statement such as added or deleted rows does not match with the key value pairs.
however even if the change performed by a statement matches the key value pair condition the statement may not have any effect on the slice criteria and thus may not be included in the slice.
the sequence condition described next is a condition that applies in the common group by order by pattern in database processing.
consider an example pre state and post state of the delete statement .
itab pre itab post cstid itemid price year cstid itemid price year i1 .
i2 .
i1 .
i3 .
i2 .
i3 .
here the delete statement does not affect the slicing criteria h1628 famountgias only the position of output row has changed and not its values.
the deleted rows could possibly effect the aggregated computations only if in the pre state they were adjacent to the remaining undeleted rows.
sequence condition states that the table elements that are used to compute the values of the variables in the slicing criteria are accessed in sequence.
if the sequence condition is not met after key condition is met the statement is not included in the slice.
note that the example does satisfy the keyvalue condition so the sequence condition offers extra precision by eliding the delete statement from the slice.there are multiple ways to identify key fields for association.
the key fields may be specified by the user.
this is not an unrealistic assumption.
observations on actual bug reports indicate that the users find it more intuitive to describe the problem using the key fields associated with the row i.e.
they are more comfortable in specifying something like the unbilled amount for customer is wrong rather than the unbilled amount in the second row of the table is wrong fields in the internal table that are not modified before being written out into the output.
fields in the internal table that are used to select the rows to operate on in select delete modify etc.
.
to summarize we introduced the key value and the sequence conditions to more precisely evaluate condition c2for verifying the inclusion of compound statements that process table elements into a slice.
it is important to describe here that as we move backward in the slice the checking of one or both of these conditions may no longer remain applicable.
for instance say we encounter a statement such as sort which sorts the table elements based on the key values then as we move backward in the slice we expect the table elements to not be in sequence w.r.t.
the key values.
similarly we may encounter a statement such as append backward to which the key value may not exist in the table elements.
the details of our key based slicing algorithm are presented in figure .
lines represent a basic field and row sensitive dynamic slicing algorithm.
function get def use s returns a set of def use pairs representing def use relationship between each pair.
function field row sensitive inclusion check performs checks like nonempty intersection of dependence set and defs in duset to check data dependency and control dependency to include a statement occurrence in the slice.
once a statement is identified to be included in the slice the dependency set is updated by removing the def and including use of each def use pair in duset line .
above the check done by field row sensitive check we add the key value and sequence checking lines to determine whether a statement occurrence chosen by the basic field row sensitive algorithm will be part of the slice.
these checks are only done for db change statements.
function check kv assumption checks that all the non scalar elements in the dependency set satisfy the key value pairs function check seq assumption checks that all the elements in the dependency set are in sequence so that any statement occurrence which has a change outside this sequence will not have any effect for a particular key value.
note that to highlight the interesting part of the algorithm we do not present the slicing algorithm in terms of dynamic dependence graph used to express the data and control dependencies in the execution trace.
while it is possible to give a necessary and sufficient condition to check the condition c2 the evaluation of such condition is not scalable and thus not ideal for practical purpose.
in this paper we therefore restrict the presentation to the practical and scalable technique of key based slicing.
.
slice differencing in this section we present the fault localization algorithms.
we extend an existing approach to identify faults to find the difference1function keyslice iq v s 2input intiq sequenceid setv set of vars 3output lists list of statements 5set v 6inti iq 7key value pairskvp kvpairs computed or user provided 8whilei 9s stmt .get i 10duset get def use s statement specific if field row sensitive inclusion check s duset !key assumption valid check kv constraint kvp s !sequence valid check seq constraint kvp s 15slice .add s update dep set duset key assumption valid check kv assumption kvp if key assumption valid sequence valid check seq assumption kvp 20i 21return slice 23check kv constraint kvp s ifsis not a db change statement return true condition c if any change by ssatisfies kvp return true else return false 31check seq constraint kvp s 32c changes by sthat satisfies kvp if check sequence assumption c kvp return true else return false 38check kv assumption kvp for each structure variable v f iff2kvp keyset if value of v f !
kvp .getvalue f return false return true 45check seq assumption kvp for allitab for any key f2kvp keys i set of all is.t.itab f2 if elements of iare not in sequence return false return false figure key based slicing in behavior between slices that produce correct and incorrect output and localize the faults at difference points.
the novelty of our technique lies in the way we compute the differences between slices.
we apply two main differencing techniques.
the first technique is relatively simple where any control difference between two slices is determined cf.
section .
.
such difference analysis typically determines the difference in sequences of statement occurrences in correct and incorrect slices.
however it is possible that sequencebased differencing may not produce any difference as the same sequences of statements can be present in both the slices.
the second technique is particularly novel as it tries to find out the behavioral differences between two slices finding statements that are present in both correct and incorrect slices but shows difference in their semantic behaviors cf.
section .
.
note that these differencing techniques are useful to localize faults when certain rows not all in the generated output have incorrect results.
.
sequence based differencing the main aim of sequence based differencing is to identify statements that contribute towards computation of the incorrect result and do not contribute to the computation of at least one correct result.
to realize the presence of such statements we perform a two step process grouping correct and incorrect slices into equivalence classes and perform pair wise differencing between the representative elements of the correct and incorrect equivalence classes.
in data centric programs it is common to find the slices containing traces of same set of statements but differing in the number of iterations of the some loops.
thus while creating equivalence classes in correct and incorrect slices we combine two slices into the same class if they are exactly same or if they have different number of iterations of the same statements in a loop.
generating equivalence classes in correct and incorrect slices reduces the number of pair wise comparisons required to find differences between slices.
while sequence based differencing of two slices one from a correct equivalence class and another from an incorrect equivalence class any difference of statements executed in the sequences of statement occurrences is noted.
however due to common nature of loop iteration differences such as different number of loop iterations these differences are given lower priority among all sets of pair wise differences.
the actual algorithm of sequence based differencing in presence of loops is not presented here for brevity.
.
semantic differencing as discussed above an incorrect slice may not show any important difference compared to correct slices in sequence based differencing.
this is possible if a statement exhibits different behaviors in two slices due to the nature of input data to the statement.
we call such difference in behavior as semantic difference .
in this section we illustrate such differences and present algorithms to detect semantic differences.
to the best of our knowledge this is the first attempt to perform fault localization based on differences in the semantics as seen during the execution of program statements.
consider the example program presented in figure and the corresponding test case shown in figure a .
in this example corresponding to the cstid there are two rows in stab.
in the read statement at line when the selection condition is satisfied with multiple rows then first lowest index matching row is selected based on abap semantics.
in the example the first row is selected with discount .
which results in output .0instead of the correct output .0corresponding to cstid .
in this example same slices exist for the two output rows as shown in figure b .
so sequence based differencing does not find any difference between slices.
in semantic differencing we assume that there must exist a faulty statement in the program that appears both in the correct and incorrect slices such that it fortuitously exhibits the intended semantics in the correct slices but deviates from the intended semantics based on programmer intent in the incorrect slice.
remember that the fortuitous correct behavior in the correct slices is specific to the particular input data.
the important question is how do we tell if a statement has deviated from its intended semantics?
after all programmers do not provide assertions after each statement to verify if the effect of the statement just executed is as they expected.
we only know that the final effect i.e.
the intended output is present in the correct slices and the unintended output in the incorrect slice.
in this paper we use two kinds of heuristics to find the first statement in the incorrect slice which shows such a deviation.statement type target corner case difference read from itab into wa where c multiple unique rows are satisfied with c append insert lines of jtab from idx1 to idx2 to itab.the number of rows appended inserted is different from idx2 idx1 insert the inserted row makes certain set of rows with same keys non contiguous.
append insert the inserted appended row makes sorted data unsorted assignment move move corresponding transporting clauseoverflow overwriting same value loop at itab.
... endloop .
the statement within loop contains delete from itab.
at new end whether at new andat end both is true for a single row.
del adj from itab comparing f1..fn.
the table is not sorted with f1..fn delete from itab where c multiple single row selected by c. selection condition a b a b selection condition a b a b figure corner case differences corner case differencing.
the first method of semantic differencing is called corner case differencing .
the semantics of some of the statements are classified into two separate categories a normal case and one or more corner cases.
for example in a read statement the where condition could match multiple rows or just one row.
since the first matching row is returned by the read the matching of just one row among several candidates is a corner case.
a table of corner and non corner cases for several statements is given in figure .
given a trace we can tell if a statement executed in a corner case manner or in a normal case manner.
intuitively this technique exploits the fact that most errors typically seen in already tested code occur due to non handling of corner cases that are revealed in the incorrect slices and not revealed in the correct slice.
key based slicing determines whether there is anyeffect of a statement on a slice or not.
corner case differencing tries to find out semantic difference of a statement with respect to correct and incorrect slices where the statement has some effect in both the slices.
in the example given in figure and data in figure a we determine a corner case difference in the read statement that in the case of correct slice only single row satisfies the selection condition but in case of incorrect slice the selection condition is satisfied with two rows.
this difference is produced by looking at the semantics of read statement and particularly evaluating the cornercase aspect in two slices.
note that in this case the difference in behavior of the read statement is indeed this particular behavior found using behavioral differencing.
the presence of this behavior multiple satisfied selection in read is always a problem as programmer may intend to get the first matching row always and may not agree to specify an extra field in selection condition which increases the overhead of the operation.
the fact that this difference in behavior showed in correct and incorrect slices is the key observation.
several other checks are presented in figure .
mutability differencing.
our second method of differencing is called mutability differencing .
mutability differencing tries to make an intelligent guess on the correct form of the statement such that it produces different behavior than the observed behavior in thestatement mutation key constraint c in read select delete append insert modifyaddition of key constraint deletion of key constraint non key constraint c in read select delete loop append insert modifymodify c with post condition imposed by a correct and all incorrect slices.
list of fields in sort addition and deletion of fields based on key constraint and field names in delete adjacent statement on the same table at new f. at end f. on change f1..fn.addition and deletion of fields to f based on key constraint and based on fields used in sort statement on the same table move corresponding delete orinsert move of other fields by breaking move corresponding to a set of move statements figure mutation operators incorrect slice expecting that the produced behavior after mutation is potentially same as the correct behavior.
the important aspect of our technique is that we only consider mutation of the statements that do not change the behavior of the statement in the correct slice.
to diagnose the fault reported for figure a we can also use mutability differencing.
consider the read statement on line in figure .
we apply a mutation to the read statement at line in figure .
year wa.year is added to the selection condition in the where clause.
this is based on the observation that read statement with key option is typically used as joining condition between two tables.
there exist two common fields cstid andyear in the input tables ordertab discounttab .
any one of them or their combination could be used as the joining fields.
however in the buggy program only cstid is being used.
after adding the common field year in the joining condition the analysis finds that the behavior in the correct slices remained same as same row is selected as before but instead of selecting the record with values .
the statement has now selected .
in the faulty slice.
indeed the fix for this problem is the above change.
a customer should only be given the discount applicable to the year in which the order was placed.
note that in general it is possible to get such a mutation after trying several number of mutations and the applied mutation might not be the final fix but could help to indicate the kind of fix to be made.
in general the mutations we consider are based on identification of the key fields.
we identify the key fields looking at similarity of field names in two joining tables as above matching fields names in sort delete adjacent and at new statement matching field names sort and binary search specification in read statement.
a complete list of patterns for abap language is not presented here for brevity.
a list of mutation operators for different abap specific statements is presented in figure .
mutability differencing can be effective in cases where cornercase differencing is not.
in figure minimum value for f2is computed for each distinct f1value.
before this computation deletion occurred with a condition on f2values f2 .
in case a 1st and 4th rows are deleted by the delete statement.
in case a say we want the second output to be instead of and fix we need is f2 0in delete condition.
corner case differencing can find this error as for f1 the deletion of the row was done on the corner case of the condition f2 but for f1 the deletion was done on a non corner case.
consider case b where the first row reported is wrong as the expected output is .
here both the conditional evaluation for deletion went through a1delete itab where f 2loop into itab into wa at new f min maxint endat if wa .f2 min min wa.f2 at end of f write wa .f1 min endat 11endloopitab init output f1 f2 x fix at line where f2 .
case a f1 f2 x fix at line where f2 .
case b figure example mutability vs. corner case differencing non corner cases.
thus behavioral difference will not be able to perform any difference here.
mutability difference on the other hand can intelligently mutate looking at the post conditions that is required f26 f2 f2 .
however mutability differencing is not strictly more powerful than corner case differencing as will be shown later in zrotc experimental subject in figure .
.
extensions the other kinds of bugs seen in data centric programs are incorrect input data unwanted rows all incorrect rows and missing rows.
we briefly describe the approach we take for such description of bugs.
missing rows.
in this case the bug report contains the description of the missing rows in terms of their key value pairs.
note that it is not possible to determine the slices corresponding to the missing rows as we cannot form slicing criteria for missing variables.
however the intuition that we follow here is that if there is any row to be produced corresponding to the missing key value pairs their slices will be similar to the correct slices computed for some 1select from zitr into table it itr .
2loop at it itr into wa itr .
clear v exrate .
v exrate read exchange rate wa itr .waers if subrc .
if v exrate wa itr .exrate .
wa itr .dispamt wa itr .amount v exrate .
else .
wa itr .dispamt wa itr .amount wa itr .exrate .
endif .
write wa itr matnr wa itr dispamt .
else .
wa itr .dispamt wa itr .amount wa itr .exrate .
missing write here endif .
16endloop .
zitr matnr amount waers exrate usd eur uk 75output matnr dispamt missing row trace figure example missing rowexisting rows.
thus we analyze by stepping backward each correct slice to find the first statement occurrence s from end which has the missing key value pairs in its useset but not in its def set.
if sdoes not occur in a loop it is reported as a suspect as the selection operation in the statement has filtered out the missing key value pairs.
if sis in a loop we determine all peer occurrences ofsin different loop iterations such that each of them say s has the missing key value pairs in its useand defset.
the execution path starting from s has the potential to produce the missing rows.
sequence based difference of the execution path starting from s and the execution path starting from sis presented to the user.
to explain the case in loop we present the following example in figure along with the input data and trace.
the row corresponding to key value pair matnr is missing.
the two slices corresponding to the generated rows with respect to the key wa itr matnr at write instances 1116aref11 22gandf11 210g respectively.
both the statement occurrences 22and210at line contain the table it itr in the useset which has the missing keyvalue pair and do not contain the missing key value pair in their defsets.
their peer statement occurrence 218has the missing keyvalue pair in both the useanddefsets.
1322is the difference between execution traces starting from 218and either of 22and210.
this statement occurrence is presented to the user as fault suspect which helps user to localize the missing write statement.
incorrect input data.
along with the slice we also highlight the variables that are defined in each statement occurrence in the slice and belong to the dependency set.
this means for a select statement occurring in an incorrect slice we identify the parts of the data selected which flow to the incorrect output.
this information corresponding to the incorrect slices helps user to identify the incorrect input data.
unwanted rows.
in this case some but not all unwanted rows are found in the output.
the fault localization problem is posed as an application of differencing where incorrect slices are computed based on key fields in the unwanted rows and correct slices are computed based on key fields in the rest of the rows.
the key based slicing followed by sequence based differencing and if required semantic differencing is carried out to localize the fault.
incorrect fields in all rows.
in this case incorrect values in one or more fields for all rows in the output is reported as a bug.
incorrect slices are computed for each of the rows and instead of computing sequence based difference of them the common statements in all the incorrect slices are computed.
furthermore the mutation technique is applied to find a mutation of a statement in the common statements set such that the mutated behavior is different from all the existing behaviors of the statement in all incorrect slices.
for each statement in the common set corner case differencing is applied to find a corner case behavior of a statement which is present in all its occurrences in incorrect slices.
.
empirical evaluation we implemented our analysis algorithms for the abap language as a part of an analysis platform towards a joint program with ibm global business services.
we evaluate the effectiveness of our core contributions key based slicing semantic differencing and the analysis for missing rows in output.
in our evaluation the key value pairs are obtained from the bug description.
to perform semantic differencing we implemented the semantics of several database statements of abap in java and hence could execute each database statement by mutating its original form.
.
experimental setup we used a suite of abap samples along with the bugs which were given to us by abap practitioners.
of these were client programs sutax zqfpr zfr052 .
the other bugs were replicas of bugs reported in client situations.
as we did not have permission to use the client code the bug was replicated on copies of similar sap standard programs.
additionally we also got toy programs to test our algorithms.
the fault relevant source snippets for all the subjects have been provided in the report .
to indicate the complexity of the subjects lines of code and the size of execution loc exe are provided in figure .
in the same table we also report on the time it took to run the analysis does not include trace collection time for complete fault localization.
the time includes sequence based differencing of key based slices followed by semantic differencing if required or analysis for missing output.
all the experiments are performed on a .53ghz pc with 4gb ram running debian linux .
.
to conduct the experiments we followed the method as given below execution trace was collected via an automated script written using the sap gui client scripting facility.
the script simulates a step thru debugging execution of an abap program collecting use and def variable values.
fault observation was specified as a pair of precise slicing criteria and associated category e.g.
incorrect missing .
for problem categories incorrect and unwanted we first identify the correct and incorrect slice criteria from user input.
then we perform the sequence based differencing on both field row sensitive slices and key based slices.
if the sequence based differencing does not yield any difference we perform both the semantic differencing algorithms on key based slices.
for problems in missing category we perform the missing algorithm described in subsection .
.
the results were presented as a navigable dynamic slice mapped to the source for the ibm gbs team to verify.
the suspected faulty statement as identified by our algorithms was highlighted.
.
results in cases out of our analysis was able to localize to a single statement and it was manually verified that the line was the source of the fault.
for the subject named sutax we were not able to point out a single statement.
verification revealed that the program input was faulty and had to be fixed.
the smallest key based slice we reported was of size for order program and the input statement in the slice was related to the fault.
.
.
key based slicing in cases sequence based differencing yielded some difference.
in cases ro13 imat and iinv the difference between fieldrow sensitive slices identified the fault.
in cases mmat and order the key based slice was smaller than the field row sensitive slice.
the slice sizes are mentioned in the field row and key columns of figure .
a look at the relevant code snippets revealed that field row sensitive slices had over approximately included the delete statements.
in case of order this difference was vital in identifying the fault as delete statement was key to the bug.
in case of mmat marked in figure field row sensitive slice found a difference in the correct and incorrect slices but that was not the exact faulty line.
the sequence based differencing of keybased slices showed the faulty line.
.
.
semantic differencing in cases sequence based differencing either just on field row sensitive slices or key based slices was sufficient to identify thesubject loc exe data slice size sequence diff.
semantic diff.
missing time field row key field row key corner mutability in secs ro13 x x imat x x iinv x x mmat x x order x rls x x zrotc x zbmr x x zqfpr x zfr052 x babl x rv54 x sutax figure fault localization result rls 1a f1f2f3f4f5 2b f3f4f5f6f7 3c f1f2f3f4f5f6f7 4loop into a loop into b move corresponding a to c move corresponding b to c move a .f3to c .f3 write c endloop 11endloop .zrotc 1select from tab into table itab 2loop at ktab read itab into w itab with key a ktab .a w jtab .a w itab .a o v e r f l o w append w jtab to jtab 7endloop .
.
.
9write alv jtab .zbmr sort it ekpo by ebeln ebelp matnr werks .
.
.
loop at it ekbe into wa ekbe read table it ekpo into wa ekpo with key ebeln wa ekbe .ebeln matnr wa ekbe .matnr werks wa ekbe .werks binary search .
.
.
a b c figure code snippets.
a rls b zrotc c zbmr fault.
in cases where the sequence based differencing failed semantic differencing was able to identify the fault.
we now discuss in detail these interesting cases rls.
in the example code snippet shown in figure a the movecorresponding x to y statement moves the values from structure xtoyfor the common fields.
the lines show the fields for the structure.
the correct assignments that needed to be done here are c.f1 a.f1 c.f2 a.f2 c.f3 a.f3 c.f4 a.f4 c.f5 b.f5 c.f6 b.f6 c.f7 b.f7 .
the assignment a.f4 toc.f4 was missing in the move statement in line .
the error is only noticed when a.f4 is different from b.f4.
in an iteration which produced the correct output both a.f4 and b.f4 were same.
in an incorrect iteration b.f4 had a non zero value whereas a.f4 had a zero value.
both correct and incorrect slices had same sequence of statements having second move corresponding and not the first.
so sequence based differencing failed to discover any difference.
the corner case differencing tried two corner overflow and overwriting cf.
figure cases for the move corresponding statement.
and the overwriting corner case evaluation showed the following difference move corresponding at line overwrites c.f4 with its existing value in correct slice and with different value in the incorrect slice.
this is also located using a mutation where themove corresponding statement in the slice is mutated to a sequence of move statements and deleting the move corresponding to c.f4 b.f4 .
the assignment related to field f4is chosen for deletion as it is the common field between structure variables aand b that assigns values to structure variable c. zrotc.
in figure b line the overflow occurs in the assignment statement as size of w jtab a is smaller than that of w itab a .
the overflow is visible in incorrect slices as non zero digits were truncated due to overflow.
however in correct slicesonly zeros were truncated which did not produce any ill effect to the computed result.
this statement was there in both correct and incorrect slices and therefore sequence based differencing was not able to catch this semantic difference.
the corner case differencing was able to catch this behavior as this is one of the corner case that is determined in assignment statement figure .
note that the fix to this bug is not a change the assignment statement but requires a change in type in the declaration of the variables.
as mutation only considers mutating a statement this bug cannot be found using mutation.
zbmr.
the example shown in figure c has the same flavor as our running example in figure with data in figure .
in this case the bug was the under specification of the key constraint in the read statement.
this resulted in the wrong row selection by the read statement in the incorrect slice.
as explained in section both corner case differencing and mutability differencing were able to find the error.
note that in this case there was only one more common field ebelp between table it ekbe and it ekpo which was not present in the selection condition in the read statement.
thus mutability differencing considered only one mutation of the current statement.
the mutation space observed in our experiments was small as we use heuristics to restrict the mutation space.
.
.
missing rows in output.
we explain a case for missing output with the code snippet of program rv54 shown in figure .
the bug reported was that for some keys corresponding rows were missing from the output.
in the program there was a delete statement which was deleting the rows where the f new field is null.
some computations were performed on the rows to produce output.
we first obtained a keybased data slice which was of length for an existing row in the1 perform batch heading babl .
.
.
delete gt output where f new is initial perform aendbelege lesen .
.
output gt output figure code snippet for missing row in rv54 output.
then by performing a backward traversal in the slice we found the delete statement that was deleting rows with the same key value as that of the reported missing data.
as this statement was not in the loop this was highlighted in the slice as the reason for the missing rows in the output.
it was verified by the abap practitioners that it was indeed the faulty line.
the deletion should not have been to the gt output table.
.
related work static program slicing of abap programs.
dor et al.
used static slicing to analyze how a given abap code uses data stored in different database tables.
their system panayaai identifies all select statements in code and computes a forward static slice from these statements to infer how the data returned from the select is being consumed in the program.
they presented three algorithms improving from a flow field context insensitive algorithm to field sensitive and finally to a flow field sensitive algorithm.
in their more recent work litvak et al.
recognized the importance of field sensitive analysis in the erp systems domain and present an algorithm for efficient and precise computation of program dependences in the presence of large structure variables.
in this paper we presented a backward dynamic slicing algorithm which is field and row sensitive.
we also observed that row sensitivity plays an important role in reducing statement occurrences in dynamic slice.
dynamic program slicing.
there is significant work in the area of dynamic program slicing.
korel and laski had introduced the notion of a dynamic slice way back in .
agrawal and horgan significantly optimized the notion by dropping the executability constraints.
venkatesh worked on separating the semantics based definition of a program slice from the semantic justification of an algorithm.
kamkar et al.
worked on interprocedural dynamic slices.
zhang and gupta improvised the algorithms for dynamic slice computation in the presence of arrays structures and pointers for complex real world programs.
hainaut et al.
and cleve looked at applying dynamic analysis on data intensive systems which contain embedded and dynamic sql such as in jdbc .
the aim was to resolve the input queries being passed to a database as precisely as possible.
the authors showed how just a static scan of the code for sql statements does not suffice.
the collected trace was used for program comprehension and to infer implicit referential constraints between database tables.
we are similar to these papers as we also use dynamic analysis.
however our presented dynamic slicing techniques go a few steps further in presence of integrated data intensive operations we present row and field sensitive slicing and extend it with key based slicing.
differencing based fault localization.
fault localization by differencing two program runs has been widely applied.
the notion of spectrum abstract trace was introduced by reps et al.
for acyclic and intraprocedural path spectra.
harrold et al.
generalized the notion of spectrum and proposed spectra based on several program features branch complete path data dependence output and execution trace.
tarantula provides a visualization of various passing and failing test runs of a software system.
here the authors explored how visualizing the hit or miss count of various code statements in passing and failing runs can help users localize faults faster.
zeller applied systematic delta changes to program input to generate guided passing and failing execution that could be differenced to detect cause effect chains more precisely.
renieris and reiss introduced distance spectrum.
in a distance spectrum a distance measure between the passing and failing spectra gives a measure of dissimilarity.
in the context of software verification a number of techniques have been proposed to provide users with minimal information required to explain counter examples resulting from model checking.
some techniques localize the errors in programs by identifying the diverging point between a counter example and a positive example a positive example is a sequence of statements in programs that does not lead to a violation of the property of interest.
a similar approach is presented in where errors are localized to program statements absent in all positive examples and present in all counter examples leading to the same error condition.
in our approach we difference between dynamic slices i.e.
identify statements that have some effect in producing incorrect output but has different effect in producing correct output.
however we additionally also identify if each executed statement showed similar behavior in each run.
another novelty of our approach is that we split a single program execution into multiple slices that are further classified as correct or incorrect.
we are able to do so because of the nature of the programs we are analyzing.
each program in a single run produces some correct and some incorrect values.
mani et al.
applied a similar technique to retrieve passing and failing traces from a single execution to compute repair recommendations for model transforms.
they used tainting to resolve how input data moved within a program to generate the output.
however their approach would not be applicable in our case where we need to handle data flows between code and external database.
we used key based slicing to split a single execution run into multiple traces.
mutation analysis.
in the area of testing mutation technique is used to generate faulty programs from a correct program to study the path divergence of faulty programs from the correct programs.
debroy et al.
use mutation based approach to suggest repairs to localized faults.
the two classes of mutant operators used there are replacement of expression replacement of assignment operator by another operator from the same class and decision negation.
our mutation operators are specialized for database statements.
chandra et al.
determine alternate values of an expression to satisfy the goal of correcting the failing tests without breaking the correct traces.
in comparison we consider the syntactic mutations that change the outcome of a statement in the incorrect slices without changing its outcome in the correct slices.
the space of syntactic mutations is managed due to the domainspecific nature of abap programs.
.
conclusion fault localization using slicing and differencing have been identified as important techniques for performing fault localization in procedural programming languages.
in this paper we extend these techniques to data centric programming languages which use em bedded database specific statements to perform operations on inmemory and persistent data.
we present a new key based dynamic slicing algorithm and two differencing techniques that use the underlying program semantics to localize faults in the data centric programs.
we applied our techniques on real industrial programs and identified the underlying faults accurately in of them.
we notice that in data centric programming paradigm the processing of data is separated out across different systems and languages.
for example many applications use the java jdbc stored procedure framework to create a data centric application.
in future we aim to check the applicability of our techniques in such paradigms.
acknowledgment.
we thank anup ghosh sugata ghosal sourin ghosh dhiman ghosh anjan nandy asidhara lahiri and amitava parui for many fruitful discussions and help in implementations of the project.
we also thank julian dolby for sharing a version of the abap grammar.
we also like to thank anonymous referees for their helpful comments on the earlier version of the paper.
.