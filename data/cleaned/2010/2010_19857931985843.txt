aspect recommendation for evolving software tung thanh nguyen hung viet nguyen hoan anh nguyen tien n. nguyen electrical and computer engineering department iowa state university tung hungnv hoan tien iastate.edu abstract cross cutting concerns are unavoidable and create difficulties in the development and maintenance of large scale systems.
in this paper we present a novel approach that identifies certain groups of code units that potentially share some cross cutting concerns and recommends them for creating and updating aspects.
those code units called concern peers are detected based on their similar interactions similar calling relations in similar contexts either internally or externally .
the recommendation is applicable to both the aspectization of non aspect oriented programs i.e.
for aspect creation and the evolution of aspect oriented programs i.e.
for aspect updating .
the empirical evaluation on several real world software systems shows that our approach is scalable and provides useful recommendations.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms algorithms design reliability management keywords cross cutting concern aspect mining concern peer .
introduction generally a large software system can be modularized in only a main design i.e.
dominant decomposition at a time.
thus some functionality originally existing or being added as the system evolves may not align well with that modularization and needs to be scattered across many modules.
such functionality is called a cross cutting concern .
figure illustrates two functions deposit and withdraw of an online banking system that provides the accesses to its users bank accounts.
to maintain the database integrity in permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.public class bankaccount database db public void deposit double value db.lock resultset r db.execute ... db.unlock public void withdraw double value db.lock resultset r db.execute ... db.unlock figure locking as a cross cutting concern concurrent accesses a locking mechanism with two functions lockand unlock is used.
method calls to these two functions are added into the code of the database accessing functions creating a database locking cross cutting concern.
for clarification the code units sharing a cross cutting concern e.g.
the methods deposit and withdraw are called concern containers .
the code fragments realizing a crosscutting concern e.g.
two added function calls to lockand unlock in those methods are called concern implementors .
cross cutting concerns create problems for software development and maintenance .
for example when a crosscutting concern is added or modified all scattered code units relevant to the concern must be detected and updated consistently.
fortunately aspect oriented programming aop provides a solution for such problems.
with aop the concern implementors of a cross cutting concern can be factored out into an aspect and woven back to the corresponding concern containers at suitable time.
for example a locking aspect would be defined such that two function calls to lock unlock would be executed before after the statements performing the database accesses in two methods deposit and withdraw .
in aop terminology the code containing the calls tolockand unlock is called advices .
the concern containers such as deposit and withdraw after aspectization i.e.
factoring out concern implementors are called shadows .
however as software evolves the maintenance problems with cross cutting concerns still exist even in the aspectized programs or the programs developed with aop from the beginning.
for example in the above online banking system assume that after aspectization a new function transfer is added and also has locking i.e.
it is a locking concern container.
if developers do not know about the existence of the defined locking aspect or its relation to the new function transfer they might not add transfer as a relevant shadow thus might miss locking in transfer or create a redundant locking cross cutting concern for that function.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
recognizing that aspectization is an evolutionary process in this paper we address the problem with a new direction investigating the concern containers in both aspectoriented ao and non ao evolving programs.
our approach aims at recommending relevant and useful groups of concern containers for both tasks creating corresponding aspects and updating them as software evolves.
since it is unrealistic to identify all possible cross cutting concerns in a system we emphasize on the concern containers that share some common characteristics.
based on the research philosophy that similar code would have similar properties we develop our approach with the assumption that methods having similar interactions in a system i.e.
call or are called by similar methods in similar contexts tend to share some cross cutting concern s .
we call such methods as concern peers to emphasize their similarity and their correlation with cross cutting concerns.
the similarity of two interactions is defined based on the similarity of their callees or callers and contexts.
two methods having sufficiently similar interactions are considered as concern peers of each other i.e.
a pair of concern peers.
after all pairs of concern peers are detected and grouped each group is ranked based on the number of the relevant interactions of all of its members which represents the scatteredness of those members in the code.
the ranked groups are then recommended for aop.
the recommendation is useful in two cases when the code is not yet aspectized xscan recommends the topranked groups as concern containers of some cross cutting concerns and when new code is added into an evolving ao system or an aspectized one xscan updates concern peers s groups recommends newly added concern containers as potential shadows to existing aspects or other concern containers into potential new aspects.
we developed several techniques to identify rank and recommend concern peers for both aspect creation in aspectization and aspect updating in aop during software evolution.
those techniques are realized in a prototype tool xscan .
we conducted an empirical experiment to evaluate the scalability correctness and usefulness of our approach.
the results show that xscan can recommend concern containers for actual concerns aspects in the large scale subject systems both ao and non ao with coverage and precision up to and f score mostly in the range of .
the key contributions of this paper include .
new concepts formulations and algorithms to identify rank and recommend concern peers as concern containers.
an aspect updating algorithm is presented.
the recommendation is useful for both ao and non ao evolving programs .
a scalable and accurate prototype tool for automated aspect mining and updating that relies on concern peers .
an empirical evaluation on several real world systems showing the scalability correctness and usefulness of xscan.
section describes some observations from the real world systems on the existence of concern peers and the evolutionary nature of the aspects.
sections and present our approach.
evaluation is in section .
related work is in section .
conclusions appear last.
.
motivating examples this section discusses some motivating examples on the similarity of interactions in the concern containers shadows and the evolutionary nature of the aspects.
we examinedpublic class sendtobackcommand extends abstractcommand public void execute super .execute setundoactivity createundoactivity getundoactivity .setaffectedfigures view .selectionzordered figureenumeration fe getundoactivity .getaffectedfigures while fe.hasnextfigure view .drawing .sendtoback fe.nextfigure ... public class bringtofrontcommand extends abstractcommand public void execute super .execute setundoactivity createundoactivity getundoactivity .setaffectedfigures view .selection figureenumeration fe getundoactivity .getaffectedfigures while fe.hasnextfigure view .drawing .bringtofront fe.nextfigure ... figure similar interactions in jhotdraw three open source systems.
two systems are jhotdraw and ajhotdraw.
jhotdraw is an api framework for graphic editing which has been frequently used as a testbed for aspect mining research .
ajhotdraw is an aspectized version of jhotdraw developed by delft university.
the third system is healthwatcher a health care management system.
unlike ajhotdraw which is aspectized from a non ao system healthwatcher is initially developed with aop paradigm and has a consistent evolution.
we analyzed all implemented aspects in ajhotdraw and healthwatcher and all cross cutting concerns in jhotdraw reported in previous research .
we used ajdt and pointcutdoctor which provide eclipse based tool support for aspectj and pointcut shadow analysis to parse ajhotdraw and healthwatcher code and then collected their aspects and corresponding shadows.
for jhotdraw we utilized its public documentation and examined the previously reported cross cutting concerns and their respective concern containers .
for each concern container and shadow we analyzed its interactions via calling relations with the help of eclipse and a control flow graph tool.
.
analysis of concern containers example .
jhotdraw has a cross cutting concern undo associating a group of nine concern containers each of which is a method named execute of nine different classes inherited from class command .
figure shows two of them sendtobackcommand.execute and bringtofrontcommand.execute .
as shown two execute methods call other similar methods in similar orders.
their classes inherit from the same parent class thus they override the same parent method.
this is an example of concern containers having similar internal interactions i.e.
they call similar methods in similar contexts within their implementation code.
we could see that the two methods in fact also have similar functionality changing the order of a figure in a collection of figures on which the current view object is processing.
example .
healthwatcher hw v10 has an aspect named hwmanagedsynchronization with a group of three shadows insert ... from three classes employeerecord symptomrecord and diseaserecord .
that aspect synchronizes the methods of employee symptom and disease type records using concurrency managers .
figure shows how they are used called in the system.
interestingly they are called by similar362public class healthwatcherfacade implements ifacade public void insert employee employee throws objectalreadyinsertedexception objectnotvalidexception employeerecord.insert employee public void insert symptom symptom throws insertentryexception objectalreadyinsertedexception objectnotvalidexception symptomrecord.insert symptom public void insert diseasetype diseasetype throws insertentryexception objectalreadyinsertedexception objectnotvalidexception diseaserecord.insert diseasetype figure similar interactions in healthwatcher public class commandmenu extends jmenu implements actionlistener commandlistener public void actionperformed actionevent e ... command cmd command hm.get item if cmd !
null cmd.execute proxy call to any command .execute figure proxy external interactions in jhotdraw methods and are called only at that location in the entire source code.
this is due to the fact that their client class healthwatcherfacade is designed with facade design pattern to work as a common hub to provide accessibility to other functionality of the system.
this is an example of concern containers shadows having similar external interactions i.e.
they are called in similar methods with similar contexts in their client code.
as seen those three classes have similar roles in the system e.g.
providing insertion functionality to process three types of information that the system manages employee symptom and diseasetype .
many similar cases were found in which the shadows are not similar however they have similar external interactions.
this is reasonable because after common parts are factored out although the shadows might not be similar anymore they are externally used in a similar manner.
example .
the execute methods in example are not called directly in jhotdraw i.e.
they do not have explicit external interactions.
they are called via their ancestor method command.execute .
figure shows how they are called incommandmenu class which provides menu functionality.
since a method invocation to the ancestor method commnad.execute at run time could be a call to any overriding method of execute we call this interaction a proxy external interaction of such methods.
since the contexts and the callers are the same we also consider such methods having similar external interactions in this case although they are called via their proxy i.e.
an ancestor method .
discussion .
the concern containers shadows in all three examples share the common characteristics that they have similar interactions in terms of calling relations.
such similarity could be seen in their implementation code and or in their client code.
such similarity might come from the fact that in a system there tends to exist multiple objects havingsimilar roles i.e.
providing similar behavior functionality and or being similarly processed .
because functionality and processing in object oriented programs are mainly expressed via objects and interactions between them such objects will have similar interactions.
thus we hypothesize that the methods of objects with similar interactions wouldoften share one or more cross cutting concerns .
we use the term concern peers to denote such methods.
analyzing all aspects in ajhotdraw and healthwatcher we found that this phenomenon is rather prevalent.
in ajhotdraw out of shadows exhibit the similarity in internal and or external interactions.
those shadows belong to out of total existing aspects in the whole system.
the corresponding numbers in healthwatcher are out of shadows and out of aspects.
each of the remaining aspects advises for a single shadow.
the examples and our observations also suggest that concern peers tend to have similar names similar implementation code or similar inheritance.
this is due to the following reasons.
as a convention in object oriented programming the objects with similar functions will often be abstracted into a parent class the specific behaviors are implemented in the children classes.
sometimes the methods classes might not be similarly implemented but they implement the same interface i.e.
promise the similar functions.
the other objects could interact in the same way with the objects in such classes via their promised methods.
the classes methods having similar functions and or being related via inheritance interface will often be named similarly by the developers to help themselves in better understanding the roles of such classes methods.
in other cases to implement the methods classes having similar functionality developers tend to copy and paste the implementation code thus creating similar code fragments.
therefore classes methods having similar interactions tend to have similar implementation code or have similar names or inherit implement from the same ancestor class interface .
.
analysis of aspect evolution we analyzed the version history of healthwatcher an ao program to observe how its aspects and corresponding shadows evolve.
here are some interesting examples.
example .
from v2 to v3 four new aspects are created to implement the state transitions for the state design pattern .
one aspect complaintstateaspect is created for four existing shadows complaint.
init .
each of three others is created for an existing method complaint.
init and a newly added method complaintstate.setstatus .
example .
from v8 to v9 six existing aspects are updated to include totally new shadows.
we observed that such updating is due to the addition of new functionality.
for example the system manages two new types of information symptoms and diseases thus the aspect managedsynchronization described in example is updated to advise two new shadows symptomrecord.insert and diseaserecord.insert .
examples and show that when an ao program evolves new aspects might be created for new concerns or existing aspects might be updated to advise newly added shadows that share corresponding concerns with existing shadows.
.
implications the aforementioned observations imply the necessity of tool support for developers not only in identifying mining the cross cutting concerns while aspectizing non ao programs but also in creating and updating the aspects while developing and maintaining evolving ao programs.
the examples in section .
suggest that cross cutting concerns might occur at code units having similar interactions in363terms of method calls in both non ao and ao programs.
therefore the desired recommendation tool could be based on concern peers.
that is one could identify concern peers based on the similarity of their interactions and recommend them as the candidates of concern containers to support creating and updating corresponding aspects.
the next sections present our approach to build such a tool.
.
formulation in object oriented programming oop a software system is modeled via objects and interactions between them.
generally the objects are abstracted into classes their behaviors are implemented as methods and the interactions between objects are expressed as calls invocations between such methods.
the interactions of an object otoward other objects are expressed in the implementation code of its methods which invoke the methods of other objects.
let us call them internal interactions .
in contrast the interactions of other objects toward oare expressed in its client code within other methods in which the methods of oare called by those of other objects.
let us call them external interactions .
in either case the interactions of the objects could be realized via method invocations and field accesses.
since ocould change its states in the execution of any method the calls before and after the call to a method o.x are also important.
we call them the context of the call to o.x .
in this paper a contextual calling relation is defined as a tuple x y a b in whichxis the caller method yis the callee and the contexts aandbare the sets of dependent methods that xcalls after and before calling y respectively.
we consider zis a dependent method call of yif they share both control and data dependencies .
for example in figure there is a contextual calling relation in which caller x bankaccount.deposit calleey database.execute and context information a database.unlock b database.lock .
definition interaction .
given a contextual calling relation x y a b p y a b is an internal interaction of x q x a b is an external interaction of y q x a b is a proxy external interaction of y1if y1overrides or implements y. item in definition is meant to address dynamic dispatching in object oriented programming.
that is if y1overrides or implements y a method call to ymight actually be a call toy1at run time.
thus an external interaction of y should be a proxy external interaction of y1.
in figure p database.execute database.unlock database.
lock is an internal interaction of bankaccount.deposit while q bankaccount.deposit database.unlock database.lock is an external interaction of database.execute .
if mydatabase is a class inheriting from database and has its method execute overriding database.execute thenqis a proxy external interaction of mydatabase.execute .
definition interaction sets .
each method xhas three sets of interactions internal interactions i x external interactions e x and proxy external interactions p x .
such sets could be empty.
internal interactions of a method xare expressed within the body of x. external and proxy interactions of xare often expressed in the bodies of others.
for example in figure bankaccount.deposit has internal interactions corresponding todatabase.lock database.unlock and database.execute .
each of those methods has external interactions corresponding todeposit and withdraw .mydatabase.execute has proxy external interactions because it overrides database.execute .
the following defines the interaction equivalence relation that we call concern peer relation for methods and the interaction similarity measures for any two methods two sets of methods two interactions or two sets of interactions.
for simplicity peer relation is denoted by and all similarity measures are denoted by sim.
the parameters will distinguish different types of sim.
definition concern peer methods and groups .
two methods are peers of each other if their interaction similarity measured by the corresponding function sim is sufficiently large i.e.
exceeds a pre defined threshold.
a group of methods is a peer group if each method is a peer to at least one other method in that group.
definition could be written as sim x y x y in which is a chosen threshold.
we consider peer relations to be reflexive i.e.
a method is a peer of itself and symmetric i.e.
if xis a peer of y thenyis also a peer of x .
however peer relation is not transitive i.e.
if xandy are peers and yandzare also peers xandzmight not be peers because they might have many different interactions although some interactions of xorzare similar to some interactions of y .
function simis defined as follows definition interaction similarity .
interaction similarity of two methods xandy denoted by sim x y is a weighted sum of the similarity values of their internal external and proxy interaction sets.
this definition could formally be written as sim x y sim i x i y sim e x e y sim p x p y with are chosen weighting parameters for different types of interactions.
if any interaction set is empty the corresponding similarity is undefined thus the corresponding weighting parameter and simwill be disregarded in that equation both in the numerator and denominator.
function simfor the similarity of such interaction sets is defined as definition similarity of two sets .
similarity between two sets of methods or interactions pandq denoted assim p q is the ratio between the size of their common part and the minimum of their sizes.
that is sim p q p q min p q we use the minimum of their sizes to emphasize more on the shared part p qof two sets.
for example if q containsp we could consider them to be equivalent in the interactions of p sinceqmight have some interactions that are irrelevant to the shared concern of two corresponding methods .
if one or two sets are empty the minimum size is zero and the similarity is undefined.
in such cases we disregard them in the equation.
one would expect the common part p qto be their ordinary intersection set p q. however such a set takes3641function detectpeermethod p 2c.add methodshavesimilarcode p add peer candidates with 3c.add methodshavesimilarname p similar code name 4c.add relativemethods p and inheritance repeat x y c.next repeatedly process candidates ifsim x y similar enough 8c.remove x y remove from candidates 9l.add x y add as peers 10x classof x y classof y check enclosing classes 11c.add methodshavesimilarname x y more candidates foreach u v c recalculate sim u v update similarity until nonew peer pairs isdetected 14g rankgroup l 15returng figure concern peer detection into account only the same identical methods or interactions between two sets.
to further consider the peer methods and interactions i.e.
the methods and interactions having peer relations we define the shared part p qas follows definition peer intersection .
peer intersection between two sets of methods interactions pandq denoted byp q is the largest set of matching pairs having peer relations in those two sets.
definition could be written as p q x y x p y q x y such that x y x prime y prime p q x x prime y y primeand p q max.
ifpandqare two sets of methods we use the peer relation in definition .
if p andqare two sets of interactions the peer relation of two interactions is defined as the following definition peer interactions .
two interactions p x a b andp prime x prime a prime b prime are peer interactions denoted asp p prime ifxandx primeare peers of each other and the peer similarity degree of aanda prime and that of bandb prime are sufficiently large i.e.
exceed a pre defined threshold.
definition could be written as x x prime sim a a prime sim b b prime x a b x prime a prime b prime .
if one or more sets are empty they and their corresponding condition s will be disregarded.
for example if ais empty the conditionsim a a prime will be disregarded i.e.
it will not be included in the evaluation of the expression.
.
algorithmic solution in this section we describe algorithms in xscan to detect peer methods group them and rank the groups and recommend peer groups for aspect creation and update.
.
concern peer detection and grouping .
.
algorithm design strategy to identify all possible pairs of peer methods one could use pairwise comparison between all methods using definitions and section .
however such pairwise comparison might be impossible because in a large system the number of methods might be huge e.g.
ten of thousands making pairwise comparison too expensive.
more seriously there is a possibility that the computation of peer methods would result in an infinite loop due to the recursive nature of peer similarity measure.
for example assume that we havetwo call relations xcallsy and x primecallsy prime .
when calculating interaction similarity of xandx prime we might need to check whetheryandy primeare peers to find the peer interactions as in definition since yandy primebelong to internal interactions ofxandx prime respectively.
then to check the peer relation of yandy prime we need to calculate the similarity of their external interactions as in definitions and thus might need to check the peer relation of xandx prime xandx primealso belong to an external interaction of yandy prime respectively .
to avoid that an approximate algorithm is developed for the identification of peer methods with the following ideas .
instead of pairwise comparison for all methods xscan uses some heuristics to find the pairs of methods that potentially have peer relations.
each pair is called a candidate .
two methods will be considered as a peer candidate if they satisfy at least one of the following conditions a they have some similar portions of code in their body such portions of code might be the implementation of a cross cutting concern and or contain many similar internal interactions of such two methods b they override or implement the same ancestor method thus they promise the same role or have similar functionality and they might be called via that common ancestor method i.e.
having similar proxy external interactions c they have similar names developers often have a naming scheme to memorize the functionality or roles of the entities thus similar names could suggest similar concerns .
.
instead of calculating similarity measure recursively xscan iteratively identifies peer pairs and calculates the interaction similarity of candidates using only the alreadyidentified peers.
when any candidates are identified as peer methods they will be used to update the interaction similarity of the remaining candidates.
.
after all possible pairs of peer methods are detected we could form a graph in which nodes represent peer methods and edges represent peer relations.
each connected component of that graph could be reported as a peer group.
.
.
detailed algorithm figure shows the algorithm to detect peer pairs and peer groups in a program p. the algorithm maintains two lists landc in which each item of lis a pair of identified peer methods while each item of cis a pair of methods as a peer candidate under processing.
the algorithm iteratively adds and updates the members of landc.
then the peer pairs ingwill be used to form the graph representing peer relations and its connected components will be reported as peer groups.
the algorithm has three key phases .
scan for candidates .
xscan scans and adds all pairs of methods with similar portions of code to the candidate list c line function methodshavesimilarcode .
it also adds into c the methods with similar names in the system line function methodshavesimilarname and the methods that override or implement the same ancestor method line function relativemethods .
in function methodshavesimilarcode xscan uses clever our clone detection tool to detect similar portions of code in a program .
clever represents a code fragment as a subtree in an abstract syntax tree ast extracts structural features from the nodes paths and labels in the subtree and computes the characteristic vector for the subtree with the occurrence counts of such features .
similarity between code fragments is measured based on the distance of365such vectors.
to find similar vectors clever hashes the vectors into buckets using locality sensitive hashing which ensures that similar vectors will have high probability to be hashed into the same bucket and dissimilar ones have low probability to be so.
pairwise comparison is applied only on individual buckets to find similar vectors.
in function methodshavesimilarname xscan compares the methods to find the ones with similar names.
first each name is separated into words.
for example doget is separated into doand get.
then the similarity of two names s ands prime as two sequences of words are calculated via their longest common subsequence so sim s s prime so avg s s prime .
to avoid pairwise comparison on all methods xscan indexes the method names based on their words and compares only the method names having at least one common word.
for example doget will be put into two buckets for the names having the words doand get.
thus doget and dopost will be put in the same bucket for the word doand compared for name similarity.
in future work methodshavesimilarname could utilize other lexical analysis techniques .
.
scan for peers .
peer candidates as pairs of methods incare stored as a descending sorted queue based on their current interaction similarity.
such interaction similarity is calculated via function simin definition using only the already identified peers in l. if two candidate methods have interaction similarity larger than the chosen threshold line xscan will remove them from cand add them to the list of already identified peer pairs l lines .
then it uses such newly identified peers to detect more candidates with similar names in the two enclosing classes lines and to re compute the interaction similarity of the remaining candidates line .
this evaluation process repeats until no more peers is identified.
.
detect and rank peer groups .
all detected peer pairs inlare used to form a graph representing peer relations in which each node is a peer method and each edge represents a peer pair in l. then xscan traverses the graph and reports its connected components as peer groups lines .
since a system might have a large number of peer groups to improve the quality of recommendation xscan uses a ranking scheme to determine the groups that potentially share cross cutting concerns.
intuitively cross cutting concern code tends to be scattered in the code base.
thus if some methods are called in many places they are likely to correlate to some cross cutting concerns.
in other words the more external including proxy external interactions a group of peer methods has the more likely those methods are concern containers implementors.
thus each peer groupx gis ranked by the total number of external proxy interactions of all members of x. this rank value for a group ais formally defined as r x summationtext x x e x p x .
.
aspect recommendation after detection and ranking the ranked groups are ready for recommendation.
xscan uses two different recommendation mechanisms for the two following usage cases.
.
.
aspectization of a non ao program when a non ao program pis provided first xscan uses eclipse to parse it and extract internal external and proxy interaction sets for each method.
to distinguish cross cutting concerns from common api functions xscan disregards the1function recommendupdate p1 a1 p2 a2 2m detectchange p1 p2 map and find changed methods 3n matchaspect a1 a2 m map and find changed aspects 4g2 detectpeermethod p2 foreach shadow group sina2 match peer groups to 6x match s g2 shadow groups and recommend ifx s negationslash recommend x s n m relevant methods foreach unmatched peer group ying2 recommend for recommendyfor new aspects creating new aspects figure aspect update recommendation standard libraries e.g.
jdk .
it also filters the getters setters and utility methods which have get set and util patterns in their names or are provided by the users.
note that the calls to those methods are still used in the computation of interactions for other methods but such methods are not reported as concern containers.
then it detects and ranks peer groups in pusing the algorithm in section .
.
finally it reports the ranked groups to users for considering as concern containers i.e.
recommends for aspect creation.
to help users recognize the shared concerns xscan provides the common callers callees of the methods in each recommended peer group.
it also reports those callers callees if they are peers of each other.
such callers callees provide the interaction contexts of peer methods for developers to create an aspect.
for example in figure for the peer group related to undo xscan reports that they all have a common interaction method createundoactivity even though those createundoactivity methods belong to different classes.
.
.
aspect update for an ao program when an ao program p1is changed into p2 xscan analyzes those two versions to provide two types of updating recommendations recommend to create new aspects for newly detected concern groups and recommend to add potentially missing shadows of existing aspects.
let us denote the set of aspects in p1bya1and that in p2bya2.
the aspect updating algorithm has four phases figure .
detect changed and unchanged methods between p1andp2.
first xscan detects from two versions p1 andp2the sets of unchanged modified deleted and added methods.
to achieve that xscan utilizes oat our prior origin analysis tool to map the classes and methods betweenp1andp2via an approximate tree edit algorithm.
.
detect newly added and existing aspects betweena1anda2.
xscan does this detection on the sets of aspects between two versions using name mapping.
that is aspects having the same names are mapped and considered as existing while unmapped aspects are considered as added deleted.
the newly added and existing aspects detected ina2will be used in the update recommendation.
.
redetect and rank peer groups in p2.
sincep2is an ao program xscan uses ajdt and pointcutdoctor to parse it and statically adds the method calls in each advice into the sets of interactions of the respective shadow methods.
this pre processing step helps in determining the existence of the cross cutting concerns which have been factored out from the concern containers using aop.
thus the collected sets of internal external and proxy external interactions of each method of p2might have some method calls chosen from its advices.
other steps for detecting group 366system loc methods ttotaltclonetpeer jhotdraw 60b1 72k 62s 30s 11s jedit .
.
175k 84s 45s 1s columba .
183k 132s 101s 2s jfreechart .
.
217k 96s 68s 9s tomcat .
.
324k 64s 32s 5s jarp .
.
19k 20s 19s 1s healthwatcher 10k 11s 10s 1s table xscan running time ing and ranking peer groups in p2are as similar as those for non ao programs described in section .
.
.
recommend detected peer groups .
xscan matches each shadow group sof an aspect in p2 collected in phase to a peer group xdetected in phase .
sis matched to x if the matching ratio x s avg x s between them is maximal.
then xscan recommends relevant peer methods in x s as new members of s. ifscorresponds to a newly added aspect all methods in x sare relevant for the recommendation.
otherwise only newly added or modified methods are considered.
since a method that is more similar to the shadows in sis more likely to be its new member each recommended peer method xis ranked based on its total interaction similarity to all methods in s i.e.
its rank is calculated as r x summationtext y ssim x y .
after this step for all detected peer groups having changed methods that are not mapped to any shadow group xscan ranks and recommends them for creating newaspects as the recommendation for the aspectization process discussed in section .
.
.
.
empirical evaluation this section discusses the empirical evaluation of xscan on real world subject systems.
all experiments were carried out on a windows vista computer with cpu intel core duo t6500 .
ghz and 4gb ram.
we set weighting parameters for internal external and proxy interactions in definition at .
.
.
a little higher weight for proxy interaction is used to detect better the crosscutting concerns relevant to the methods that interact with one another via proxy calls.
two thresholds for similarity of peer methods and contexts in definitions and are set loosely at .
because for aspect recommendation more reported concern related entities are desirable.
.
scalability in this experiment we evaluate the scalability of our approach measured via the running time of xscan.
sixteen subject systems were used in the experiment including ten versions of healthwatcher and six other systems see table with their sizes ranging from to klocs and their numbers of methods ranging from 1k to 16k.
for each system we measured the total processing time ttotal which includes the time for code parsing by eclipse and aspectj detecting code clones tclone and detecting and recommending peer groups tpeer.
the result shows that xscan is highly scalable.
it processes most systems in less than minutes.
most processing time is spent on parsing and detecting clones.
time for detecting recommending concern peers is reasonably small.
that shows the effectiveness of our algorithm design.xscan cbfa concern rank cov.
prec.
fscore cov.
prec.
fscore undo iterator persistence observer visitor table accuracy on jhotdraw s popular concerns .
accuracy in aspect mining as in previous aspect mining approaches we measure the correctness of xscan in aspect creation in the aspectization process via precision and coverage on each crosscutting concern .
precision is defined as the ratio of actual concern containers in the total recommended ones for that concern.
coverage is defined as the proportion of correctly recommended concern containers over the total number of actual concern containers for that concern.
the computation of coverage is based on individual concern rather than on all concerns in a system such as in recall because it is impractical to have an oracle on all possible concerns especially in large systems .
note that recall is the ratio of correctly detected concerns over the total possible concerns.
in aspect recommendation high coverage would be more favorable.
if a recommended concern container is wrong developers could remove it using domain knowledge.
in contrast if the tool misses true concern containers they might have to manually search through the codebase for such concern containers.
certainly the tool needs a high level of precision to reduce annoying recommendations.
thus we also usefscore a measurement that represents a harmonic average of coverage and precision fscore coverage precision .
higher fscore signifies better accuracy.
.
.
results on popular concerns in jhotdraw first we evaluated the correctness of xscan on several widely analyzed and reported cross cutting concerns in prior aspect mining research for the subject systems .
table shows the correctness of xscan on five well analyzed cross cutting concerns in jhotdraw .
as shown xscan can achieve a very high level of accuracy with fscore in the range of .
in out of concerns xscan has significantly higher fscore than cluster based fan in analysis approach cbfa which was shown to outperform other state of the art aspect mining approaches .
column rank shows the ranks of peer groups recommended for the corresponding concerns.
as seen our ranking mechanism of xscan is quite good because the peer groups recommended for those concerns have very high ranks.
visitor is lowly ranked because its member methods are not called as scattered in the code as the others.
for this case fan in and cbfa approaches also cannot rank this concern high because the total number of fan ins i.e.
the total number of calls to all members in that concern is small.
.
.
results on top concern groups to further evaluate xscan we analyzed the top groups recommended for jhotdraw.
we collected the methods belonging to each individual concern in jhotdraw via analyzing the corresponding aspects realized in ajhotdraw.
table shows the result for the top ten concern groups.
as seen xscan also achieves a high level of accuracy with367xscan cbfa concern cov.
prec.
fscore cov.
undo iterator mousehandler persistence observer consistentbehavior figureselectionobserver draw handleinvoke managehandles table top concern groups in jhotdraw system cov.
prec.
fscore jedit jhotdraw columba jfreechart tomcat jarp table accuracy on top concern groups fscore mostly above .
since cbfa s precision is not available from we compare xscan and cbfa via coverage.
xscan has higher coverage than cbfa in out of concerns reported by both tools.
we also evaluated top groups recommended for five other subject systems .
because some systems have not been previously studied we examined the code and relevant documentation to gain the knowledge about them for the manual analysis of cross cutting concerns.
we used the same criteria as zhang et al.
to identify concern containers implementors.
that is for each recommended peer group we collected the methods supporting the same similar purpose or functionality and find in the whole system other methods with the same purpose functionality.
table shows top result for tomcat with fscore mostly in the range of .
due to the space limit we could not show the result for all systems.
thus we summarize the average coverage and precision on each of other systems in table which are calculated for all top concerns rather than for individual concerns.
as shown for top recommended groups xscan has very high accuracy with fscore mostly in the range of .
.
.
interesting cases manually examining the reports we found several interesting cases.
firstly in jhotdraw xscan identified three new concerns that are not reported by existing approaches consistentbehavior a concern to activate deactivate the drawing views figureselectionobserver a concern to observe the selection of figures and handle invoke a concern to invoke actions when the handle of a figure is selected .
secondly xscan is able to detect concern containers that cbfa can not.
for example in jhotdraw xscan is able to detect the methods addand remove belonging to the same concern figureselectionobserver due to their interaction similarity.
because cbfa is based on the similarity of fan ins and names to cluster candidate concern containers it could not group the methods having very dissimilar names e.g.
add remove into the same concern.concern cov.
prec.
fscore lifecycle.stop lifecycle.start valve.invoke task.execute persistence lifecyclelistener membershiplistener channelinterceptor senderror jkhandler.invoke table top concern groups in tomcat version aspects added updated v1 v2 v2 v3 v3 v4 v7 v8 v8 v9 v9 v10 table aspect evolution on healthwatcher thirdly xscan is also able to distinguish methods having the same names and fan ins yet belonging to different concerns.
for example in tomcat based on the interaction similarity xscan can distinguish two separate groups of callback methods valve .invoke and jkhandler .invoke into two concerns.
another example is in columba in which the callback methods for different button objects in different concerns purposes must have the same name of actionperformed the callback mechanism requires so .
in these cases cbfa would incorrectly group all of such methods into a concern because they have the same name.
.
accuracy in aspect updating .
.
manual analysis of aspect evolution we manually analyzed existing aspects and the corresponding shadows of healthwatcher hw with versions and considered them as the oracle for the evaluation on aspect updating.
as seen in table we found two kinds of changes to aspects from one version to the next version new aspects are added or currently existing aspects are updated either by the changes in its advice code or the changes in the set of its shadows .
in both cases the affected shadows might have newly added code only existing code only or both added and existing code.
for example from v1 to v2 hw has two added aspects for newly added code while four other aspects are updated for existing shadows.
.
.
results on update recommendation we ran xscan on consecutive versions of healthwatcher to evaluate its update recommendation.
for each version if applicable xscan recommended two types of action updating an existing aspect u with new shadows and or adding a new aspect a .
recommendation for the type u is given as ranked lists of relevant methods thus a method is considered as correctly recommended ifit was added at the version of recommendation or at a later version .
evaluation criteria for the type a are the same as in a non ao program.
table shows the result.
for a created aspect type a column shdrepresents the number of its actual shadows and368aspect change t shd rec cov.
hwclientdistribution v1 v2 u hwdistributionexc... v1 v2 u hwpersistenceexc... v1 v2 u hwtransactionexc... v1 v2 u servletcommanding v1 v2 a complaintstateaspect v2 v3 a hwmanagedsynchronization v8 v9 u hwclientdistribution v8 v9 u hwupdateobserverexc... v8 v9 u updatestateobserver v8 v9 u observerprotocol v8 v9 u hwdatacollection v8 v9 u hwtransactionmanagement v8 v9 u hwtimestamp v9 v10 u table accuracy on update recommendation column recis the number of recommended peer methods for that aspect.
for an updated aspect type u column shd is the number of actual updated shadows from the previous version and column recis the number of top ranked peer methods in the recommended list corresponding to the maximum coverage for that aspect.
for example in the first row aspect hwclientdistribution was actually updated to advise additional shadows which all belong to the top peer methods in the ranked list recommended by xscan.
that is the coverage is with only incorrect ones.
as shown xscan always achieves coverage for all updated aspects with a reasonable cutpoint for top ranking.
thus in most cases the number of methods that need to be examined to get all actual shadows is acceptable.
the worst case is for aspect observerprotocol one needs to examine up to methods for actual shadows.
some aspects in table are not recommended because they contain single shadows.
.
.
interesting cases there are some cases in which xscan correctly recommends the shadows before they are actually added into the corresponding aspects.
for example aspect hwtimestamp was created at v1 and advised two methods insert and update of class complaintrepositoryrdb .
the method search of this class also existed at v1.
however it was not added as a shadow of hwtimestamp until v10.
xscan detects the peer relation of methods insert update and search right at v1.
thus xscan could provide an early and useful update and help to avoid missing shadows.
in some other cases xscan did not need to provide recommendation for creating aspects because those aspects advise only unchanged shadows which have been recommended at a prior version.
for example aspect complaintstateaspect is created at v3 see example but three of its five shadows have been reported as a peer group since v1.
similarly at v4 three aspects hwupdateobserverexceptionhandler updatestateobserver and observerprotocol are created to advise a group of three methods.
however those three methods belong to a peer group which has been recommended at v2.
moreover at v8 two aspects hw distribution were refactored two new aspects rmi were added as their children aspects and one pointcut was moved from the parent aspect to the children ones.
via ajdt pointcutdoctor xscan finds no changes in the corresponding shadows thus provides no suggestion.
those cases show that in practice xscan could provideearly and useful recommendations for creating new aspects thus help avoid missing implementations of concerns.
there are two cases that xscan missed providing recommendation for creating new aspects.
at v2 aspect exceptionhandlingprecedence is created to guarantee that exception handling happens around the command pattern .
xscan was able to detect two smaller concern groups for exceptionhandler and command however found no matched peer group forexceptionhandlingprecedence since it is related to methods in two groups with interaction similarity less than the chosen threshold.
similarly at v3 three new aspects are created each for a pair of methods see example .
the interaction similarity between each pair is also not sufficiently large.
our aspect updating technique is evaluated in one subject system.
thus this threat to validity could affect its generalization.
we plan to evaluate it in other ao systems.
.
related work aspect mining.
several approaches have been proposed for mining cross cutting concerns.
closely related work to xscan is fan in analysis .
its underlying philosophy is that a method that is called many times is likely to be a cross cutting concern.
however fan in analysis provides only sets of methods with high fan ins.
sometimes those methods might be unrelated.
xscan focuses on internal external interactions including method calls and their contexts and groups related methods by their similar interactions.
other related work is cluster based fan in cbfa analysis which combines fan in approach with name based clustering to group methods with similar names into a concern.
as shown in section name based clustering would miss the methods that share the same cross cutting concern but have very dissimilar names.
cbfa would incorrectly group unrelated methods with the same required name for example in the callback functions in graphical user interface libraries e.g.
actionperformed .
cbfa counts only the number of fan ins.
xscan looks into interaction similarity with contextual information as well thus overcomes those problems.
more importantly fan in and cbfa approaches do not support aspect updating.
those approaches do not focus on similar interactions of concern containers.
for the shadows of an aspect e.g.
after advice code is factored out of a concern container xscan still can recognize at least the external interactions among shadows thus can use interaction similarity for aspect updating.
clone detection is also used as a technique to determine similar code that could be factored out into aspects.
bruntink et al.
confirm that crosscutting functionality is often implemented by similar code fragments.
shepherd et al.
use both program dependence graph based and ast based clone detection for aspect mining.
xscan focuses not only on internal interactions as in those approaches but also on external interactions .
as shown earlier several concern peers interact similarly with other parts of the system despite the differences in their internal code.
other aspect mining methods utilize lexical andtext based analysis .
those methods face the same problem as the name based method in cbfa because they lack the deep analysis on program semantics such as interaction analysis in xscan.
specifically tourwe and mens use formal concept analysis and similar identifier analysis to mine structurally related classes methods in an aspect.
aspect browser identifies concerns with lexical pattern match 369ing for querying the code.
aspect mining tool combines textual approach with structural search for type usages.
prism supports mining of activity oriented aspects by lexical and type based patterns.
action oriented relations between identifiers are captured with queries over a program model in .
the idea of concern peers is inspired from code peers for preventing recurring bugs .
feat a feature exploration and analysis tool starts with a concern seed and allows developers to query several relations among classes methods.
relevant entities form a concern graph.
concern graphs do not take into account peer interactions among methods as in xscan.
as shown earlier several methods in the same aspect contain the calls topeermethods but not exactly to the same methods.
other aspect mining approaches rely on mining version repositories.
breu and zimmermann introduce an aspect mining approach by analyzing how fan ins change over time.
via mining version history adams et al.
analyze how code changes together to identify cross cutting concerns.
some aspect mining approaches are dynamic or hybrid .
krinke uses cfgs to find recurring execution patterns.
dynamit analyzes execution traces to find patterns of calls.
dynamo utilizes concept analysis to find relations between traces and executed code units.
concern management.
there exist several approaches on aspect tracking and management.
dagenais et al.
propose an approach to trace concerns in evolving software via inferring structural patterns .
in contrast xscan maintains the concern peer relations among code units and uses them to suggest the update for aspects as software changes.
an empirical study on tracing concerns was reported in .
.
conclusions this paper investigates the common characteristics of crosscutting concerns and finds that most of the concern containers are concern peers i.e.
methods having similar roles with similar interactions to others in a system.
we developed several techniques to identify rank and recommend concern peers as concern containers both in the aspectization process with aspect mining support and in the evolution of ao programs with aspect updating support.
our evaluation showed that our approach achieves high level of accuracy in recommendation of both aspect creating and updating.
acknowledgment.
this project is funded by nsf ccf1018600 award.
it was also funded in part by vietnam education foundation for the first and second authors.
.