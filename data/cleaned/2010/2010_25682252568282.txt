alternate refactoring paths reveal usability problems mohsen vakilian and ralph e. johnson university of illinois at urbana champaign usa mvakili2 rjohnson illinois.edu abstract modern integrated development environments ides support many refactorings.
yet programmers greatly underuse automated refactorings.
recent studies have applied traditional usability testing methodologies such as surveys lab studies and interviews to nd the usability problems of refactoring tools.
however these methodologies can identify only certain kinds of usability problems.
the critical incident technique cit is a general methodology that uncovers usability problems by analyzing troubling user interactions.
we adapt cit to refactoring tools and show that alternate refactoring paths are indicators of the usability problems of refactoring tools.
we de ne an alternate refactoring path as a sequence of user interactions that contains cancellations reported messages or repeated invocations of the refactoring tool.
we evaluated our method on a large corpus of refactoring usage data which we collected during a eld study on programmers over three months.
this method revealed usability problems of which were previously unknown.
we reported these problems and proposed design improvements to eclipse developers.
the developers acknowledged all of the problems and have already xed four of them.
this result suggests that analyzing alternate paths is e ective at discovering the usability problems of interactive program transformation ipt tools.
categories and subject descriptors d. .
programming environments d. .
distribution maintenance and enhancement h. .
information interfaces and presentation user interfaces general terms design experimentation human factors measurement keywords refactoring usability evaluation critical incident empirical permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction refactoring is changing code without altering its observable behavior .
major integrated development environments ides including eclipse intellij netbeans visual studio and xcode provide tool support to make software refactoring more e cient and reliable.
nonetheless developers greatly underuse automated refactorings mostly due to usability problems .
iso de nes usabilityas extent to which a product can be used by speci ed users to achieve speci ed goals with e ectiveness e ciency and satisfaction in a speci ed context of use .
anything that damages the usability of a product is a usability problem .
researchers have evaluated refactoring tools with usability testing methodologies such as lab studies and interviews .
these methodologies nd real usability problems by recruiting only a small number of participants.
however these methodologies are known to be suitable for identifying only certain usability problems e.g.
those that can be exposed during a short lab study or the ones that a programmer can remember during an interview.
this is because such methodologies can evaluate the tool only for a short period of time limited kinds of tasks and a small number of participants.
humans learn from their past mistakes.
certain events severely a ect our lives e.g.
accidents and injuries.
re ecting on such events we try to improve our future strategies.
if refactoring tools were human beings how would they have learned from their past experiences?
the critical incident technique cit is a general methodology for revealing problems by analyzing critical incidents .
a critical incident is a breakdown of a user s interaction with the system that seriously a ects the user s task.
the human computer interaction hci community has found that cit is an e ective complementary methodology for discovering usability problems .
however the notion of critical incidents is not well understood or studied for interactive program transformation ipt tools e.g.
refactoring tools.
this leaves three research questions open what are the critical incidents for ipt tools?
are these incidents indicators of the usability problems of ipt tools?
how can evaluators infer usability problems from critical incidents?
our work bridges the gap between two lines of research program transformation and cit by adapting cit to refactoring tools.
we show that alternate refactoring paths are indicators of usability problems.
an alternate refactoring path is a sequence of user interactions with the refactoring tool that di ers from the primary path .
the primary path permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
1class c static void m a this selection results in an invocation of move static members.1class c static void m b this selection results in an invocation of move compilation unit.
figure the eclipse refactoring tool detects the type of the move refactoring based on the code selection.
the only di erence between these selections is the two leading spaces on line of figure 1b.
although the code selections shown in this gure are very similar they result in invocations of di erent refactorings move static members and move compilation unit.
also known as the happy path is an ideal sequence of interactions that leads to a successful application of the automated refactoring.
refactoring tool users take alternate paths for various reasons e.g.
making an invalid selection invoking the wrong automated refactoring or violating a precondition check.
we hypothesize that events such as cancellations repeated invocations and reported messages of a refactoring tool which correspond to alternate paths are likely to indicate usability problems.
to test this hypothesis we conducted a eld study with programmers who used eclipse for a total of programming hours over the course of three months.
by analyzing alternate refactoring paths in this data set we found usability problems of which were previously unknown.
we both reported the problems and proposed design improvements to the developers of eclipse.
consequently the developers acknowledged all the problems we reported and have already xed four of them.
these results suggest that analyzing alternate refactoring paths is e ective at identifying the usability problems of refactoring tools.
the analysis of alternate refactoring paths revealed a variety of usability problems section .
for example figure shows how a minor change to a code selection results in the invocation of an unexpected move refactoring.
reporting this problem to the eclipse developers led to the discovery of broader consequences of the problem section .
.
.
there are several advantages to our adaptation of cit for nding the usability problems of ipt tools.
first our automatic data collection method can scale to many participants and collect data for a long time.
this makes it possible to nd usability problems from many user interaction paths.
second our automatic data collectors are unobtrusive.
this allows the evaluators to nd usability problems without interfering with programmers work.
third the large set of collected data can be mined to measure the frequency of usability problems empirically.
finally analyzing the alternate paths reveals not only usability problems but also design improvements.
in summary this work contributes to the eld of refactoring in several ways we adapt section and evaluate section cit for nding the usability problems of refactoring tools.
this adaptation can be used to nd the usability problems of other refactoring or ipt tools.
we nd real usability problems section of a refactoring tool and propose design improvements to address them.
these problems are encountered by programmers in the eld and con rmed by the developers of the refactoring tool.
we provide empirical evidence for the frequency of the usability problems revealed by our method.
.
related work we discuss two main lines of research related to our work.
.
usability studies on refactoring tools any useful software continuously evolves.
refactoring tools aim to reduce the cost and risk of evolving software.
nonetheless recent studies show that usability problems deter programmers from using automated refactorings .
these studies have uncovered some of the usability problems of refactoring tools by a combination of quantitative and qualitative data analyses.
our work di ers from these studies in two ways.
first we derive a systematic usability evaluation method for refactoring tools.
second our evaluation method relies mostly on automatically collected usage data rather than qualitative data.
researchers have proposed alternative designs to improve the usability of refactoring tools .
these proposals seek to address speci c usability problems such as developers unawareness of automated refactorings poor methods of invoking automated refactorings and low predictability of automated refactorings .
while this line of work has generated promising ideas for improving the usability of refactoring tools they lack a general mechanism for nding usability problems encountered by programmers in the eld.
.
the critical incident technique .
.
the origins of cit the critical incident technique cit is a general technique developed in its current form by flanagan and published in psychological bulletin in .
the technique is believed to have been founded even earlier by galton circa .
flanagan de ned cit as a set of procedures for collecting and analyzing human behaviors that have critical signi cance positive or negative .
typically the respondents are asked to describe their signi cant experiences.
variations of this method have been widely used in human factors .
despite all the variations of cit a common de nition of the critical incident still holds.
a critical incident is an event during a task that is a signi cant indicator of some aspect of the objective of the study.
flanagan describes cit as an outgrowth of the studies conducted as part of the aviation psychology program of the united states army air forces in world war ii.
one of the early studies in this program that employed cit was analyzing the reasons of disorientation while ying.
in this study the pilots were asked to think of occasions during their ight that they experienced disorientation i.e.
they1107felt uncertain about their spatial position.
then they were asked to describe what they saw heard or felt that caused that experience.
this study resulted in a number of recommendations for changing the cockpit design and training pilots to avoid disorientation.
.
.
cit in human computer interaction del galdo et al.
adapted cit to hci in .
they conducted a study to evaluate the documentation of a conferencing system.
the participants were asked to perform a task using the system.
they were also asked to report any incident success or failure that they encountered while using the documentation.
the experimenters observed the participants during the study.
this variation of cit in which the participants report the incidents as they are encountered is called the user reported critical incident technique ucit .
del galdo et al.
made recommendations for improving the documentation based on the reported incidents.
hartson et al.
adapted ucit to remote usability evaluation where the users and evaluators are in di erent physical locations .
in this variant of cit the experimenters train the users to identify and report critical incidents.
the users report the critical incidents as they are encountered during the task.
later the evaluators analyze the reports and the accompanied contextual information e.g.
video recordings of the incidents.
hartson et al.
showed the e ectiveness of cit through several studies on web applications.
they also reported a problem with ucit users tend to delay reporting the incidents.
while hartson et al.
used cit to enable remote usability evaluation their studies were mostly in the lab.
akers et al.
devised a variant of cit for evaluating the usability of applications like google sketchup and adobe photoshop .
they conducted a lab study in which they instructed the participants to perform prede ned tasks.
the system automatically recorded operations such as undo and erase along with screen capture video.
to obtain more contextual information about these events the participants were paired up to discuss their captured video episodes centered around the recorded events.
they found that the participants sometimes failed to report problems because they forgot or blamed themselves rather than the application.
an interesting di erence in the results of our studies is that we did not nd undo a good indicator of the usability problems of refactoring tools section .
yoon et al.
studied developers backtracking strategies e.g.
removing inserted code or restoring removed code .
this study can be viewed as an application of cit with implications for better tool support for backtracking strategies .
studies have con rmed the e ectiveness of remote usability evaluation in di erent settings .
nevertheless practitioners do not practice it much although when they do they appreciate its value .
while similar to this line of research we propose a variant of cit there are several major di erences.
first we focus on ipt tools for which the notion of critical incident is not well understood.
second we seek to avoid interference with programmers work ow.
thus we capture more detailed information automatically to reduce the involvement of the users in identifying the usability problems.
finally we evaluate our method by analyzing the authentic data collectedtable number of years of programming experience of the participants as reported by the who completed the demographic survey.
years participants from programmers performing real tasks in their normal working environments.
.
methodology the critical incident technique cit consists of two major phases data collection and data analysis.
the rest of this section describes how we adapted each of these phases for identifying the usability problems of ipt tools.
.
data collection evaluators can collect the critical incidents through surveys interviews observing the participants or asking the participants to report the incidents during the task.
these data collection techniques are not scalable to many users are based on arti cial tasks or interfere with users work.
so we made our data collection automatic to collect a large set of data that covers many usage scenarios of the refactoring tool in a form that is amenable to automatic data analysis .
we made the data collection unobtrusive to avoid altering programmers behavior.
finally instead of collecting the data from prede ned tasks performed at the lab we decided to collect the data from real tasks that are more representative of how the refactoring tool is used in practice.
we conducted a eld study on programmers for three months collecting usage data for a total of programming hours.
.
.
participants we recruited participants from the industry n and academia n .
we advertised the study to the open source community via mailing lists irc and e mail.
in addition we invited researchers from six research labs at the computer science department of the university of illinois at urbana champaign.
we did not remunerate the participants.
instead we explained to them the potential contributions of our study.
we asked the participants to ll out a demographic survey.
based on the survey results participants had at least ve years of programming experience .
moreover the participants indicated that they worked on a variety of domains such as banking database management systems business process management and marketing.
.
.
automatic data collector we developed codingspectator an unobtrusive tool for collecting the usage data of the eclipse refactoring tool.
the only interaction that the participants had with codingspectator was to install it like any eclipse plug in and enter their username and password when prompted to submit their data to our central repository.
we chose to make the data collection process unobtrusive to study software evolution practices in the wild .
codingspectator captures more data about the usage of the refactoring tool than what eclipse already does.
it1108captures invocations of automated refactorings of the supported by eclipse.
the eclipse refactoring history captures the following information about only the automated refactorings that are performed timestamp the invocation time of the automated refactoring kind the kind of the automated refactoring e.g.
rename local variable extract method selection o sets the start and length of the code selection used to invoke the refactoring con guration options information about how the programmer con gured the automated refactoring e.g.
the name and accessibility of the new method created by extract method eclipse records data only about the primary paths that users take while using the refactoring tool.
in other words it only records the eventually performed automated refactorings.
however troubling interactions may make the user take alternate refactoring paths by canceling orun a refactoring that has reported a message or is hard to use.
since our goal was to adapt and evaluate cit for refactoring tools we made codingspectator augment the eclipse refactoring history in two ways.
first codingspectator records canceled undone and redone automated refactorings in addition to the performed ones along with any messages reported by the refactoring tool.
second it captures contextual information about refactoring activities that an evaluator can use to derive usability problems.
the contextual information consists of the following navigation history a description of how and when the user navigated through the refactoring wizard invocation method whether the user has invoked the refactoring tool through the wizard selection the piece of code selected to invoke the refactoring and a larger slice of code surrounding the selection1 messages all problems that the refactoring tool has reported to the programmer section .
.
since eclipse does not provide a reusable api to capture the above information we instrumented the eclipse source code.
during the installation process codingspectator replaces several existing eclipse plug ins such as ltk and jdt by our instrumented versions of these plug ins.
.
.
refactoring messages arefactoring precondition is a property that the refactoring tool checks at various stages e.g.
selection invocation con guration and commit to guarantee that the change will preserve the behavior of the program.
if a precondition fails the refactoring reports a message whose type depends on the severity of the problem and the stage of refactoring.
we refer to such a message as a refactoring message or just a message in this paper.
the eclipse refactoring tool may report any of about messages of four types to its user 1we made codingspectator capture this information because the selection o sets captured by eclipse do not always re ect exactly the ones used by the programmer due to some normalization that eclipse applies on the selections.unavailable the refactoring tool refuses to open the refactoring wizard due to the failure of a precondition.
warning this kind of message attempts to predict compilation problems and can often be ignored safely.
error the eclipse documentation recommends not to continue an automated refactoring that has reported a message of this kind because it is very likely to break the code.
fatal error the refactoring tool refuses to perform the change on the code.
the refactoring tool may report an unavailable message only before the refactoring wizard is open while it may report the other types of messages only during the later stages of refactoring.
.
data analysis the data analysis phase of cit consists of two major phases identifying critical incidents and inferring usability problems.
we automated the identi cation of critical incidents and their accompanying contextual information.
however inferring the usability problems from critical incidents is a manual process that an evaluator can do.
the rest of this section describes how we adapted these two phases of cit to ipt tools.
.
.
identifying critical incidents collecting the critical incidents.
we rst collected a setiof critical incidents i.e.
refactoring invocations that reported a message section .
.
as well as canceled undone and redone refactorings.
then we add to iany refactoring that occurred within ve minutes of a critical incident in i. finding the most frequent refactoring messages.
we computed the frequency of each refactoring message by counting the number of times it occurred in i. we consider the frequency of a refactoring message a measure of the criticality of the message as an incident.
we have released the data about the frequencies of the refactoring messages at .
the number of all messages that the eclipse refactoring tool may report is large n .
it is tedious to investigate all possible messages for usability problems.
besides it is often impossible to infer a usability problem from a message without having other contextual information about the refactoring invocation.
codingspectator s data indicates that the eclipse refactoring tool reported only di erent kinds of messages to the participants during the study.
therefore we focus on these messages that the refactoring tool reported in practice.
in addition we analyze the most frequent messages in the contexts that they appeared.
the contextual information captured by codingspectator allows us to identify the conditions under which the message is reported and how the programmers react to the message.
extracting refactoring batches.
the refactoring batch of a critical incident is a subset of icontaining the events that are semantically related to the critical incident.
examples of semantically related events are cancellations and invocations of the same refactoring or refactorings on related program entities.
a refactoring batch provides the context necessary for inferring usability problems from a critical incident.
we1109extracted the refactoring batches of the most frequent refactoring messages.
to extract the refactoring batch of a critical incident we manually inspected the events in ithat occurred within minutes of the critical incident and extracted those that were semantically related to the critical incident.
we found that a window of minutes was large enough to cover all events that were semantically related to a critical incident.
for each event in the refactoring batch of a critical incident we took a note of how the event was related to the critical incident.
we referred to these notes while inferring usability problems from refactoring batches.
.
.
inferring usability problems analyzing the refactoring batches.
we manually inspected refactoring batches of the most frequent refactoring messages to infer usability problems.
we used the contextual information in each refactoring batch e.g.
code snippet selection and invocation method to reproduce the behavior of the refactoring tool.
for each refactoring batch we examined programmers reactions to the reported messages.
if programmers dismissed the message we checked if the message was poor e.g.
vague di cult to understand or uninformative.
we evaluated the e ectiveness of the message ourselves based on general usability guidelines and we did not contact the participants.
if the programmer canceled the refactoring we checked if the refactoring was later repeated.
if the refactoring was repeated we checked for the possible changes to the con gurations of the refactoring or any manual changes made to the code since the previous invocation.
such changes often revealed why the refactoring failed in the rst attempt and how the refactoring tool could be improved to avoid the failure.
if the refactoring was repeated multiple times unsuccessfully we considered it a stronger indication of a usability problem.
con rming the usability problems.
finally we reported the usability problems that we inferred to eclipse developers to con rm that they are indeed considered usability problems from the eclipse developers points of view.
we included in our reports some empirical data about each usability problem e.g.
the number of refactoring batches with the same usability problem the number of times programmers canceled or performed a refactoring as well as a summary of the strategies that the programmers employed to remedy the usability problem.
we also made our reports actionable by making concrete suggestions on how to resolve the usability problems.
.
usability problems we were able to infer usability problems by analyzing alternate refactoring paths.
this shows that alternate refactoring paths are indicators of usability problems.
this section presents some of the usability problems that we identi ed.
for each usability problem we present its frequency in our data set how we identi ed the usability problem and what suggestion we made to eclipse developers to resolve the usability problem.
codingspectator recorded detailed information for of of the refactorings that were performed and recorded by eclipse.
table illustrates the frequencies of automated refactoring events.
table introduces several symbols that we use in the rest of the paper.
table liststable the frequency of each kind of automated refactoring and refactoring message in the codingspectator data set.
event performed canceled undone redone warning error fatal error unavailable occ.
table meanings of the symbols used to describe an alternate refactoring path quantitatively.
occ.
can be greater than per.
can.
because a refactoring with an unavailable message is not counted as either performed or canceled.
symbol meaning occ.
the number of occurrences of the alternate path.
par.the number of participants a ected by the alternate path bat.the number of refactoring batches containing the alternate path per.the number of instances of the alternate path that the participants performed can.the number of instances of the alternate path that the participants canceled rankthe index of a message in an array of all messages sorted by occ.
descendingly the most frequent messages that the eclipse refactoring tool reported to our participants.
due to privacy and con dentiality constraints of the eld study we cannot present the participants code.
instead we demonstrate the usability problems using simpli ed versions of the participants pieces of code.
.
vague messages we analyzed the refactoring batches of the two most frequent messages of the eclipse refactoring tool rank one and two in table .
when we reproduced these messages we noticed that they are vague.
that is they do not clearly explain the problem leaving the programmer confused about the risks of performing the refactoring and the actions required to mitigate the risks.
for example for the most frequent message rank one in table neither the message nor any other information on the refactoring wizard indicates what part of the code modi cation may not be accurate.
this warning is too broad to be of any actionable use.
perhaps this is why the participants continued of of the refactorings despite reporting this warning .
we reported several instances of this usability problem to the eclipse developers .
.
overly strong preconditions precondition checking of refactoring tools is a delicate process.
on one hand the preconditions should be strong enough to prevent the refactoring from breaking the code or altering its behavior in unintended ways.
on the other hand the preconditions should not be overly strong and reject safe refactorings.
our prior study showed that programmers prefer exible refactorings often ignore precondition failures 1110table a list of the most frequent messages reported by the eclipse refactoring tool.
column refactorings lists the refactorings that reported each message.
refer to table for meanings of the other column headers.
rankmessage type refactorings occ.
par.
per.
can.
all 1code modi cation may not be accurate as a ected resource has compile errorswarningrename compilation unit type enum constant field method package113 2found potential matches.
please review changes on the preview page.errorchange method signature move44 3type contains a main method some applications such as scripts may not work after refactoring.warningrename compilation unit type package41 4this refactoring cannot be performed correctly due to syntax errors in the compilation unit.
to perform this operation you will need to x the errors.fatal error rename field method 5ambiguous return value selected block contains more than one assignment to local variables.unavailable extract method 6this name is discouraged.
according to convention names of local variables should start with a lowercase letter.warningchange method signature extract local variable rename local variable15 7selected statements contain a return statement but not all possible execution ows end in a return.
semantics may not be preserved if you proceederror extract method and manually x the problems afterwards .
the following discusses two usability problems related to overly strong preconditions that we identi ed.
realizing the disadvantages of overly strong preconditions others have proposed a bounded exhaustive testing approach .
our approach of nding overly strong preconditions by analyzing critical incidents complements theirs in two ways.
first we nd overly strong preconditions that programmers have encountered in real world while their approach nds overly strong preconditions in a large number of automatically generated programs.
second their approach does not currently support refactorings below the method level e.g.
extract method.
.
.
ambiguous return value the extract method refactoring reported the unavailable message in figure to our participants occ.
par.
.
we rst reproduced the message using the information captured in its refactoring batches to understand the conditions under which the refactoring tool reports this message.
these batches contained an invocation of extract method with a code selection similar to the one shown in figure .
by studying the message itself and reproducing the repeated refactorings in the refactoring batches of the message we found why the refactoring tool refuses to continue the selected code assigns to two local variables aand b that are used outside the selection line .
since a java method can return at most one value the refactoring tool cannot infer the return value of the extracted method aorb .
we identi ed two usability problems by analyzing the refactoring batches of this unavailable message.
first while trying to reproduce the message we found that the message is not descriptive enough.
the message indicates that the refactoring tool is unable to proceed because the selected piece of code assigns two local variables.
however this is not a su cient condition.
the refactoring tool refuses to continue only when more than one local variables are both assigned in the selected piece of code and used outside the figure the eclipse extract method refactoring reports the message ambiguous return value for the code selection shown in figure .
1class c int m int a b a b return a b figure the eclipse extract method refactoring reports the message ambiguous return value figure for the code selection shown in this gure.
selection.
we suggested that the eclipse developers make the message more descriptive.
the eclipse developers xed this problem .
second this precondition check of eclipse is overly strong.
refusing to continue the refactoring caused additional overhead to our participants as shown by their e orts to repeat the refactoring in the refactoring batches.
we examined the cancellations and repeated invocations in refactoring batches to understand how programmers handled this message.
we found that programmers used three solutions.
they either narrowed the selection widened it or converted the local variables to elds and repeated the refactoring.
based on1111this observation we suggest that the refactoring tool be more exible and let the programmer continue the refactoring in the following ways.
one option is to warn the programmers about the use of the local variables outside the selection but still allow them to continue the refactoring and make the new method have no return value.
alternatively the tool could suggest that it automatically converts the local variables to elds and proceed.
we reported this overly strong precondition to eclipse developers.
they acknowledged the value of exibility saying i have had instances when i have had to perform a refactoring manually because eclipse would not proceed because of an error.
on such occasions i do wish for things to be a bit more exible.
.
.
missing return theerror message with rank seven in table was the second most frequent message of extract method.
seven of the refactoring batches that contained this message contained at least one cancellation and one repeated invocation.
in one refactoring batch the participant invoked the refactoring four times each time changing a con guration option selection or code.
these alternate paths indicate the di culty of using the tool and the possibility of usability problems.
by reproducing the message we found the underlying reason of the message.
eclipse cannot extract a set of statements that has some control ow paths ending in return and some others not figure 4a .
we examined the code selections in the refactoring batches of this message to see if this precondition check can be relaxed for certain common code selections.
as a result we found that the refactoring could have been more exible and infer the missing return statements figure 4b in seven of the batches that contained this message.
the intellij refactoring can infer the missing return statement in some cases.
we suggested this enhancement to eclipse developers and they acknowledged its bene ts .
.
name conflicts refactorings such as rename and extract local variable which change the name of an existing program element or introduce a new named program element may cause name con icts.
table lists the most frequent refactoring messages that eclipse reported to the participants due to name con icts occ.
par.
bat.
per.
can.
.
our analysis of the refactoring batches showed that the participants either continued the refactoring despite the message and resolved the name con ict manually or canceled the refactoring and invoked it again to enter a di erent name.
having the programmers navigate back to the con guration page or repeat the invocation of the refactoring with a di erent name to refactor safely is an additional overhead which we consider a usability problem.we reported this source of additional overhead to eclipse developers and suggested that the refactoring tool informs programmers about potential name con icts earlier .
.
unintuitive configuration options the goal of the move instance method refactoring is to move the declaration of an instance method from its enclosing class to another class.
figure shows the e ect of applying move instance method on an example piece of code.1class c boolean b boolean m if b return true else system.out.
println else return false a the selection contains a return statement but not all possible execution ows end in a return .1class c boolean b boolean m if n return true return false boolean n if b return true else system.out.
println else return false b it is possible to automatically infer the missing return statement in some cases.
figure the extract method refactoring of eclipse results in a compilation problem if it reports the error message selected statements contain a return statement but not all possible execution ows end in a return.
.
.
.
.
six of the participants invoked the move instance method refactoring for a total of times as parts of ten batches.
however none of the invocations were applied.
either the programmer canceled the refactoring times or the refactoring tool refused to continue and reported an unavailable message times .
two refactoring batches indicated that the participants invoked the refactoring tool three times but did not succeed to perform the move instance method refactoring.
these critical incidents led us to identify two usability problems.
first the con guration dialog provides options that programmers cannot easily interpret.
the dialog asks for a pair of name and type figure while the programmer would like to select the destination class.
a refactoring batch indicated that a participant spent seconds on the conguration dialog of move instance method which is higher than the average time our participants spent on this dialog .
seconds .
we asked the participant why he spent this time on the con guration dialog and eventually canceled the refactoring.
the participant said that he expected the refactoring tool to ask him about the destination class not a pair of name and type .
he canceled the refactoring because he could not interpret the required options.
however selecting a destination class is not su cient in general because the refactoring tool has to update the call sites as well.
the refactoring asks the programmer to select a variable to determine the new receivers of the call sites.
for the example shown in figure the refactoring tool changes the callc.m e1 e2 line figure 5a to e1.m c e2 line figure 5b .
nonetheless since the con guration dialog does not communicate the necessity of these options well the programmer gets confused.1112table the most frequent refactoring messages that were due to name con icts.
column refactorings lists the refactorings that reported each message.
refer to table for meanings of the other column headers.
rankmessage type refactorings occ.
par.
per.
can.
8duplicate local variable errorextract local variable rename local variable14 14a variable with name is already de ned in the visible scopewarning extract local variable package already exists in this project in folder warning rename package type named already exists in package error rename compilation unit type compilation unit already exists fatal error rename compilation unit type 1class c d d1 d d2 void m e e1 e e2 d1.m void m2 e e1 new e e e2 new e c c new c c.m e1 e2 16class d void m 21class e a original code1class c d d1 d d2 void m2 e e1 new e e e2 new e c c new c e1.m c e2 12class d void m 17class e void m c c e e2 c.d1.m b refactored code figure the programmer selects instance method m line to move it from class ctoe.
second the con guration dialog requires more options than what is necessary for moving certain kinds of methods.
we found that fewer simpler options were su cient to support a common class of attempted refactorings captured in refactoring batches.
we say an instance method is e ectively static if it can be made static without introducing any compilation problems.
for example in figure method c.m2 lines figure 5a is e ectively static .
however method c.m e e lines figure 5a is not because it depends on the instance eld c.d1.
in ve batches the participants tried to move e ectively static methods.
if the method is e ectively static it would be su cient for the dialog to ask the destination class from the programmer.
however the eclipse refactoring tool always requires the programmer to select a eld or parameter as the new target of the method.
this design is restrictive because it does not allow the programmer to move an e ectively static method to a class other than those reachable from a eld or parameter.
we reported both of the above usability problems to eclipse developers .
the developers acknowledged these problems and made an improvement accordingly.
to address the figure the con guration options of the move instance method refactoring for the code example shown in figure .
the refactoring requires the new target of the method as a pair of name and type .
however this requirement is neither easy to interpret by programmers nor necessary.
rst usability problem we suggested that the con guration dialog asks the destination class and new receiver separately and clarify why it requires a new receiver.
we provided the developers with prototypes of alternative designs of the con guration dialog.
to resolve the second usability problem we suggested that the refactoring tool automatically detects e ectively static methods and allows the programmer to move them to any writable class without requiring a new receiver.
.
invalid code selections programmers have to select pieces of code to invoke most automated refactorings.
however selecting a valid piece of code can be error prone especially when the selection is long.
table lists the most frequent refactoring messages reported because of invalid code selections.
in total refactoring messages were reported due to invalid code selections.
we identi ed several usability problems related to invalid selections.
.
.
trailing semicolon the inclusion or exclusion of a semicolon can make a selection invalid for extract method.
figure illustrates a selection that causes extract method to report the unavailable message with rank in table .
the extract method refactoring expects the trailing semicolon to be included in1113table the most frequent refactoring messages due to invalid code selections.
column refactorings lists the refactorings that reported each message.
refer to table for meanings of the other column headers.
rankmessage type refactorings occ.
par.
per.
can.
19the end of the selection contains characters that do not belong to a statementunavailable extract method an expression must be selected to activate this refactoring.
unavailableextract local variable constant5 cannot extract the left hand side of an assignment.
unavailable extract method 1class c void m int i i figure excluding a semicolon can make a selection invalid for extract method.
the selection because it expects a set of statements not expressions as its input.
the participants that received this message occ.
par.
bat.
eventually extended the selection to include the trailing semicolon and performed the refactoring successfully.
nonetheless in two batches the participants repeated the refactoring with the incorrect selection until they noticed the trailing semicolon.
these repeated invocations indicate the subtlety of this message.
we examined the refactoring batches of this message to see if the refactoring tool could be improved to avoid the alternate refactoring paths.
we found that if the refactoring tool had automatically expanded such selections to include the trailing semicolon the cancellations and repeated invocations of all refactoring batches of the message would have been avoided.
we reported a usability problem to eclipse developers suggesting that the refactoring tool automatically expands such selections.
eclipse developers xed this problem.
by analyzing alternate refactoring paths we found a similar problem caused by including a trailing semicolon in the selection.
this usability problem was already reported and xed by the eclipse developers .
.
.
equivalent selections we inferred a usability problem of the move refactoring by analyzing the refactoring batches containing the following fatal error message occ.
par.
bat.
per.
can.
a file or folder cannot be moved to its own parent.
the move compilation unit refactoring reports the above message when a compilation unit is about to be moved to its enclosing package the default destination.
the con guration options that codingspectator captured for these refactorings indicated that in three of the batches the participants selected elds or methods and invoked the move refactoring but the tool incorrectly interpreted the refactoring as move compilation unit.
we reproduced the attempted refactorings on pieces of code similar to the ones recorded by codingspectator .
surprisingly we found that slight changes to the code selection result in the invocation of an unexpected kind of move refactoring.figure shows two very similar code selections that are interpreted di erently by the move refactoring.
the selection in figure 1a results in an invocation of move static members while the selection in figure 1b results in an invocation of move compilation unit.
this is because the former selection tightly covers a method while the latter covers slightly more than a method leading spaces on line figure 1b .
the refactoring tool interprets a selection that covers more than a method as a selection of the enclosing compilation unit.
this high sensitivity to code selections is a usability problem.
reviewing our report of this usability problem led the eclipse developers to discover more problems.
the root cause of the problem is that the move refactoring only considers the start o set of the selection.
this observation uncovered another problem if a programmer selects two methods the move refactoring will ignore the second one.
.
lessons learned although we applied cit to nd the usability problems of an ipt tool we learned some lessons along the way that are generalizable to other programming tools.
reported messages.
we found that the reported refactoring messages were more likely to indicate usability problems than other events.
nevertheless we identi ed at least one usability problem by just examining canceled refactorings.
repeated invocations of an automated refactoring helped us infer how the participant overcame a usability problem.
unlike an adaptation of cit to applications like adobe photoshop we did not nd any usability problems by just studying undone and redone refactorings.
nonetheless undone and redone refactorings in a refactoring batch provided stronger evidence for the usability problems revealed by other events e.g.
reported messages.
there are several possible explanations for why undo is an indicator of usability problems for an application like adobe photoshop but not a refactoring tool.
first the role of the undo operation may be di erent in the two applications.
programmers seem to use undo as a natural means of exploring a solution space.
second inferring usability problems from an undone automated refactoring may require more contextual information thatcodingspectator does not capture.
reproducibility.
we found that reproducing the critical incidents was required in most cases to infer the usability problems.
this suggests that the reproducibility of critical incidents is an important criteria in adapting cit to ipt tools and other domains.
the data collector has to capture enough details about the incidents so that the evaluator can later reproduce the critical incidents and examine them.
user reports.
we contacted a participant to infer one usability problem section .
.
we were able to refresh1114the participant s memory by showing him codingspectator s data of his refactoring.
the lesson here is that it is sometimes necessary to get the participant s report of the critical incident e.g.
what they were trying to achieve what prevented them from achieving their goal and how they overcame the problem.
when employing cit in a remote usability evaluation there are two general ways of getting the participants reports of the critical incidents either ask the participants to report the incidents as they occur during the task or prompt them by presenting enough data about their actions not too long after performing the task.
design improvements.
although our goal was to infer usability problems from alternate paths we learned that alternate paths can also suggest design improvements.
we analyzed the repeated refactorings to see how the programmers overcame a usability problem manually.
for some usability problems sections .
.
and .
.
we suggested design improvements that automated these manual strategies.
.
limitations although we successfully identi ed usability problems we do not have an estimate of what fraction of the usability problems we identi ed.
future work may answer this question by comparing the results of our method by conventional usability evaluation methods.
eclipse developers acknowledged all of the usability problems that we reported.
nonetheless developers judgments may not be perfect.
although the contextual information that codingspectator collects allows us to identify usability problems our identi cation process was mostly manual and tedious.
future research could explore automated techniques to reduce the burden on the evaluator.
we used heuristics such as the number of occurrences of the events and a ected participants to prioritize our evaluation e orts.
another possibility is to ask the users report the critical incidents that they encounter.
the study of the pros and cons of such an approach is left to future work.
we adapted and evaluated cit for the eclipse refactoring tool.
since we were able to extend some of the results to other refactoring tools we expect our results to generalize.
nonetheless we did not thoroughly investigate the generalizability of our method to other ipt tools.
codingspectator captures snippets of code close to the program elements under refactoring.
we found that this information was crucial for deriving usability problems.
nonetheless recording such sensitive pieces of information raises privacy and con dentiality issues.
we faced di culty in recruiting participants because of these issues.
there are several challenges in scaling our method to a large number of programmers.
one challenge is to make the data collection transparent.
another challenge is to design an incentive mechanism for programmers to share their data.
.
future work this work opens up future research in several directions.
one direction is to adapt other variants of cit e.g.
ucit to ipt tools.
this would provide insight about the quantity and quality of user reports and their e ect on the number and severity of inferred usability problems.
another future line of research is to extend our method to other ipt tools e.g.
code generators bug xers and other refactoring tools.finally our vision is that programming environments adopt data collection frameworks like codingspectator to make remote asynchronous usability evaluation possible at a large scale.
this large scale will raise new research challenges such as privacy assurance and automatic clustering of similar critical incidents.
.
conclusions interactive program transformation ipt tools such as refactoring tools aim to make the evolution of software more economical and reliable.
despite the automation of many recurring or sophisticated changes refactoring tools are heavily underused .
recent studies suggest that usability problems are major obstacles to a widespread use of refactoring tools .
we advocate continuous collection of usage data to analyze the interactions of programmers with a refactoring tool.
this technique is used in other application domains e.g.
web applications.
the challenge is to nd usability problems from a large corpus of usage data which is like nding a needle in a haystack.
we adapted the critical incident technique cit to refactoring tools.
we examined alternate refactoring paths to nd the usability problems of refactoring tools.
alternate refactoring paths are paths of user interactions that di er from the primary orhappy path of using an automated refactoring.
an alternate refactoring path contains events such as cancellations repeated invocations and error messages.
we mined alternate refactoring paths in a large real world refactoring usage data set and analyzed a subset of it to identify usability problems.
as a result we found usability problems all of which have been acknowledged by the eclipse developers and four have already been xed.
this result shows that alternate refactoring paths reveal usability problems.
.