ai a lightweight system for tolerating concurrency bugs mingxing zhang1y ongwei wu1shan lu2 shanxiang qi3 y jinglei ren1weimin zheng1 1tsinghua national laboratory for information science and technology tsinghua university china 2university of wisconsin madison usa3university of illinois at urbana champaign usa abstract concurrency bugs are notoriously difficult to eradicate during software testing because of their non deterministic nature.
moreover fixing concurrency bugs is time consuming and error prone.
thus tolerating concurrency bugs during production runs is an attractive complementary approach to bug detection and testing.
unfortunately existing bug tolerating tools are usually either constrained in types of bugs they can handle or requiring roll back mechanism which can hitherto not be fully achieved efficiently without hardware supports.
this paper presents a novel program invariant called anticipating invariant a i which can help anticipate bugs before any irreversible changes are made.
benefiting from this ability of anticipating bugs beforehand our software only system is able to forestall the failures with a simple thread stalling technique which does not rely on execution roll back and hence has good performance experiments with real world concurrency bugs demonstrate that a iis capable of detecting and tolerating most types of concurrency bugs including both atomicity and order violations.
two new bugs have been detected and confirmed by the corresponding developers.
performance evaluation with representative parallel programs shows that a iincurs negligible overhead for many nontrivial desktop and server applications.
categories and subject descriptors d. .
software program verification reliability d. .
testing and debugging diagnostics general terms reliability keywords concurrency bugs software reliability bug tolerating shan is now with university of chicago.
yshanxiang is now with google inc. mountain view.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction .
motivation unlike sequential bugs the manifestation of concurrency bugs depends not only on inputs but also on thread interleavings and other timing related events.
thus it is hard to expose all the concurrency bugs during in house testing and it is also difficult to fix concurrency bugs quickly and correctly .
consequently tools that can not only detect concurrency bugs during in house testing but also tolerate them during production runs are highly desired.
an ideal production run bug tolerating tool should satisfy requirements from two aspects bug tolerating coverage .
the tool should be able to handle a wide variety of concurrency bugs that are hidden in deployed applications including both atomicity violations and order violations1 and run time performance .
the tool should only incur small overhead on commodity machines.
existing techniques that tolerate concurrency bugs can be categorized into three types depending on when bug tolerating takes effect figure .
but none of them can satisfy the above two requirements simultaneously.
failure more failures turning point ...... hot patch always on ...... figure categorization of bug tolerating tools.
the arrow in the figure represents the time line during production runs.
always on approach .
this approach constrains program execution all the time to prevent potential manifestations of some concurrency bugs.
for example atomtracker and atomaid group instructions into chunks and execute every chunk atomically.
this approach constrains interleavings even during correct runs and relies on transactional memory or other custom hardware to achieve good performance.
in addition it often only probabilistically tolerates concurrency bugs with a specific root cause pattern e.g.
atomicity violations and unable to handle bugs with other types of root causes e.g.
order violations .
failure recovery approach .
this approach rolls back program execution to a recent checkpoint when failures or errors occur and relies on re execution for automated recovery.
unfortunately low overhead checkpoint and roll back cannot be achieved 1these are the two most common types of concurrency bugs in real world based on a previous empirical study .on existing machines without significantly sacrificing the bug tolerating coverage .
post mortem approach .
this approach aims to prevent future manifestations of a concurrency bug after triaging earlier manifestations of the bug.
it can ease the pain of lengthy patch releasing period but cannot prevent failures caused by unknown bugs i.e.
losing coverage .
.
our new approach this paper proposes a new approach to tolerating concurrency bugs in production runs.
different from all the previous techniques this new approach achieves both the coverage and the performance requirement by anticipating the manifestation of concurrency bugs at run time and preventing bug manifestation through temporarily stalling the execution of one thread which incurs much smaller overhead than checkpointing and rollback.
the key observation behind our approach is that there exists a turning point tduring the manifestation of a concurrency bug beforet the manifestation is non deterministic after t the manifestation becomes deterministic.
thus if a concurrency bug can be anticipated before its turning point its manifestation can be prevented by temporarily stalling a thread which incurs little overhead.
anticipating bugs right before the turning point is critical to bug tolerating.
anticipating too early will inevitably encounter many false positives causing unnecessary thread stalling and performance losses.
anticipating too late will miss the chance of lightweight bug toleration only heavy weight checkpoint rollback can restore correct states after the turning points.
anticipating bugs right before the turning point is also challenging.
previous concurrency bug detection tools did not consider bug anticipation and would indeed detect many bugs after the turning points which we will discuss in more details in section .
.
below we simply demonstrate how two straw man ideas do not work for bug anticipation.
b a correct run incorrect runread xth read write x read x write xth read read xth read write xread x write xth read correct run incorrect runth read write x read xth read th read write xread xth read the turning point of the bug s manifestation.
figure illustrations of bugs turning points.
straw man detecting a bug before the execution of buggy writes.
intuitively one might think that it should be early enough to prevent a bug if no buggy write has happened.
unfortunately this is not true.
figure a shows a typical atomicity violation pattern where the expected atomicity of write after read is violated.
many real world concurrency bugs follow this pattern .
here the turning point is actually right before the second read instruction as circled in figure a .
once that read happens although no bugrelated write has executed the atomicity violation is inevitable.
straw man detecting a bug before the execution of the secondbuggy thread.
suppose a bug involves two threads.
even if only one thread s buggy code region has executed it could still be too late.
figure b illustrates a typical order violation pattern where a read in thread unexpectedly executes before a write in thread .
many real world concurrency bugs follow this pattern and lead to problems like un initialized reads .
the turning point in this example is right before the read in thread as circled in figure b .
once that read is executed although the buggy code region in thread has not executed yet the order violation is inevitable.
.
contributions this paper makes the following contributions.
i a new approach to tolerating production run concurrency bugs.
this new approach complements existing bug tolerating approaches by anticipating concurrency bugs right before their turning points and leveraging lightweight thread stalling instead of heavyweight checkpoint rollback to get around the bugs manifestation.
ii a novel invariant named anticipating invariant a i that is suitable for effective and efficient concurrency bug toleration.
roughly speaking for an instruction ithat accesses variable v aicaptures which instructions are allowed to access vright beforeifrom a different thread.
what distinguishes a ifrom previously proposed interleaving invariants is that a i can help achieve both the coverage goal and the performance goal of concurrency bug toleration.
in terms of coverage it reflects programmers intentions about the correct order of concurrent memory accesses and its violation can be used to detect both atomicity and order violations.
in terms of performance the violation of a ioccurs at exactly the turning point of most concurrency bugs not too early and not too late.
more details are presented in section .
iii a low overhead software only bug tolerating system2 designed and implemented based on a i. our system includes several steps it first automatically learns a iduring in house testing it then monitors violations to a iduring production runs finally it automatically and temporarily stalls a thread right before an a i violation to prevent the manifestation of concurrency bugs.
to the best of our knowledge this is the first attempt to efficiently tolerate previously unknown atomicity and order violations at run time without rollbacks.
our system also includes optional bias instrumentation scheme and apis to allow easy performance tuning for memory access intensive applications.
more details are presented in section .
iv an evaluation based on representatives real world concurrency bugs.
the evaluation shows that our system can tolerate all of the concurrency bugs which is more than each of the existing techniques that we have evaluated.
our system also incurs low overhead smaller than overhead for many non trivial desktop and server applications.
furthermore our system detected two previously unknown concurrency bugs from widely used opensource software.
.
anticipating inv ariant program invariants are predicates that should always be true at certain points of the execution they reflect programmers intentions.
many recent works pay close attention to learn likely invariants from testing runs and use them to detect or tolerate software bugs .
these invariants are supposed to be held in all the correct runs.
if one of them is violated at run time a bug probably has manifested.
although these invariants all differ vastly in their 2we have made the source code of our tool publicly available at related documentations and demos are also presented there.details many of them are constrained in types of bugs they can handle.
more importantly they are designed for detecting bugs instead of anticipating bugs which makes them unsuitable for lightweight bug tolerating.
in this section we first introduce the anticipating invariant a i .
then we present some case studies to demonstrate a i s ability of anticipating concurrency bugs right before the turning points.
finally we discuss why and how a iis different from prior works.
.
definition through investigating many real world bugs we find that the manifestations of most concurrency bugs involve an instruction i1 preceded by an unexpected instruction i2from a different thread where i1andi2access the same variable.
in addition postponing the execution of i2can often prevent the bug i.e.
the execution of i2is the turning point .
for example most order violations occur when an instruction i1from thread unexpectedly executes after instruction i2from thread causing i2to be preceded by a different instruction that accesses the same variable as i2.
postponing i2can effectively make i1execute before i2.
as another example most atomicity violations occur when instruction i2from thread unexpectedly interleaves instruction i1andi3from thread causing i2to be unexpectedly preceded by i1.
similar to the order violations postponing i2can effectively prevent this kind of atomicity violations.
following this observation we propose the anticipating invariant which can satisfy both of the two requirements listed in section .
.
specifically in the rest of this paper we will use syto indicate a static instruction in the source code a line of code that can be differentiated by its program counter and ixsyto represent that the dynamic instruction ixobserved at run time is derived from static instruction sy.
here the dynamic instruction means an execution instance of a static instruction thus a static instruction in loops or recursions can have many dynamic instructions that are derived from it.
we also define a remote predecessor expressed asrpre ix for every dynamic instruction ixin the execution traces.
rpre ix is a static instruction which has at least one dynamic instruction derived from it that accesses the same memory address as ix comes from another thread besides ix s thread and3 accesses the same address immediately before ix.
we consideri2from thread to be immediately before i1from thread if and only if except instructions from thread there is no instruction that accesses the same address of i1between the execution of i2andi1.
and rpre ix nilif there is no such dynamic instruction.
for example figure shows an interleaving and each instruction s corresponding remote predecessor.
although i4executes between i2andi6 rpre i6 s2 because i4is executed by the same thread as i6.
testxrunthreadx1 i3s3 readxx i4s4 readxy i6s6 readxy i7s7 readxxthreadx2 i1s1 writexx i2s2 writexy i5s5 readxxrpre i1 x xrpre i2 x xnil rpre i3 x xs1 rpre i4 x xs2 rpre i5 x xs3 rpre i6 x xs2 rpre i7 x xs5 ixsyxmeansxthatxdynamicx instructionxixxisxderived fromxstaticxinstructionxsy.
remotexpredecessor figure demonstration of remote predecessors.
to be more explicit the remote predecessor has the following characteristics it is defined for every dynamic instruction.
thus if one static instruction is executed more than once in an execution there will be multiple dynamic instructions and different remote predecessors that are needed to be calculated nilis specially defined to describe the state that the instruction can be executed before any instructions from other threads that access the same address.
as we will discuss later in section .
nilis very useful for anticipating bugs in practice whether the instruction is a read or a write operation does not matter in calculating remote predecessors.
test runthread i2s2 read x i4s2 read xthread i1s1 write x i3s3 read x i5s3 read xrpre i1 nil bset s1 nil rpre i2 s1 rpre i4 s3 bset s2 rpre i2 rpre i4 s1 s3 rpre i3 rpre i5 s2 bset s3 rpre i3 rpre i5 s2 remote predecessor figure demonstration of belonging sets.
figure shows another interleaving in which all the memory operations access the same address.
note that i1 s remote predecessor is nil because no instruction has accessed the variable x before it.
and as there are two dynamic instructions derived from the same static instruction s2in this test run their remote predecessors are s1ands3respectively.
after investigating many concurrency bugs we observe that in all the correct runs the remote predecessor of the same static instruction s dynamic instructions has fixed candidates.
and once a dynamic instruction s remote predecessor does not belong to this set it implies the occurrence of a concurrency bug.
hence we calculate a belonging set expressed as bset sy for every static instruction which is the union of all the remote predecessors of its dynamic instructions that have been seen in verified interleavings.
and we define the anticipating invariant to be rpre ixsy 2bset sy ixsyis derived from s y as an illustration bset ofs2in figure is calculated as bset s2 rpre i2 rpre i4 fs1 s3g.
.
case studies .
.
atomicity violation incorrect interleaving correct interleaving i s1 and s2 are assumed to be executed atomically.
wrong interleaving will lead to crash.void innobase mysql print th .. bool do command ... ... ... if thdt proc info putc f thdt proc info fputs thdt proc info3 f ... ... s1 s2s3thread thread ha innodb.cc sql parse.cc i figure a real world atomicity violation in mysql.
figure shows a real world atomicity violation from the mysql database server while figure is the corresponding simplified code of this bug.
two interleavings that can be found in correct test runs and one found in incorrect runs are given in figure .i3s2pinpcorrectprunp2pispenclosedpwithpdottedplinex becausepthatpitpwillpbepbypassedpbypanpif conditionp inpthispinterleaving.remoteppredecessorbsetzs1tp prpre1zi1tp rpre2zi2tp p nilxps3 pppppppprprezpmeanspthepremoteppredecessorpp bsetzs2tp prpre1zi2tp p nil ppppppppppppppppppppppppppppppppppobtainedpfromprunpz.
bsetzs3tp prpre1zi3tp rpre2zi1tp p nilxps2 rpre1zi1tp prpre1zi2tp pnil rpre1zi3tp ps2correctprunp1threadp2 i3s3 writepxthreadp1 i1s1 readpx i2s2 readpx correctprunp2threadp2 i1s3 writepxthreadp1 i2s1 readpx i3s2 readpx rpre2zi1tp pnil rpre2zi2tp ps3incorrectprunthreadp2 i2s3 writepxthreadp1 i1s1 readpx i3s2 readpx rpreinzi2tp ps1 ppppppppppppppppppppbsetzs3t ppppppppppppppppppppppppppfigure the simplified code of figure .
after observing the correct test runs we can calculate that bset s3 isfnil s 2g.
then in the incorrect case when i2s3in thread wants to be executed before i3s2in thread after i1s1has already been executed its remote predecessor will be s1.
since s162bset s3 a violation is reported.
note that this bug can be anticipated before s3 s execution at which point the run time environment still can prevent the bug from happening by temporarily stalling the execution of thread .
there is no need to roll back any executed instruction here.
another example of the atomicity violations is shown in figure a .
in the incorrect run a ican anticipate the bug before read thread because read thread 1does not belong to its bset .
previous works have proposed different types of invariants to detect atomicity violations ultimately .
however they cannot predict many atomicity violations before their turning points.
we will discuss this in more details in section .
.
.
.
order violation b bset s1b m mrpre i1 m m nil bset s2b m mrpre i2 m m s1b rprein i1 m mnilmmmmbbset s2b i1s1b writemxthreadm1b threadm2b i2s2b writemx correctmruni2s1b writemxthreadm1b threadm2b i1s2b writemx incorrectmrun a bset s1a m mrpre i1 m m nil bset s2a m mrpre i2 m m s1a rprein i1 m mnilmmmmbbset s2a i1s1a readmxthreadm1a threadm2a i2s2a writemx correctmruni2s1a readmxthreadm1a threadm2a i1s2a writemx incorrectmrun remotempredecessor figure interleavings of two typical order violations.
figure shows two representative interleavings obtained from a r w order violation and a w w order violation respectively.
the remote predecessor of i1s2ain subfigure a and i1s2bin subfigure b are both nilin the incorrect run.
in this case a violation will be reported because neither bset s2a norbset s2b contains nil.
similar to atomicity violations the bug is detected right before its turning point and hence can be avoided without using roll back.unlike the anticipating invariant previous works ability of anticipating order violations will be influenced by other conditions like whether there is another leading instruction accessing the same address.
a formal discussion will be given later in section .
.
.
rationales it s true that most of the invariant based techniques share the same formation of learning some invariants from testing runs and checking guarding them later.
but a ican be distinguished from the others by its ability of avoiding roll back which shifts the invariant designer s perspective from how to detect the bug ultimately to how to anticipate the bug right before its turning point .
owing to this unique perspective many special decisions are made many previous works record some states in a former instruction and check them at later instructions.
then they learn invariants about how these states will be preserved or altered.
but when the invariant is violated at the later instruction one can do nothing but roll back to tolerate the bug.
instead a idoes not wait for the last instruction in a buggy region to detect the invariant violation.
it constrains the instant state of each instruction not a continued state of an instruction region aidoes not differentiate read and write instructions and it explicitly defines nilto represent the initial state.
this helps to avoid the first and the second misconceptions listed in section .
respectively.
aitries to make minimal assumptions about where a bug may hide.
for example instructions involved in an anticipating invariant do not need to constitute the unserializable interleaving like a vio the read write dependence like dui or the memory dependent like pset etc.
thus as shown in section .
a ican detect more bugs than each of the previous works can do.
.
implementation in order to utilize the anticipating invariant for tolerating concurrency bugs we implement a software only system by using the llvm compiler framework .
in this section we first give an overview of our system.
then we describe how to automatically extract a iand use it to tolerate concurrency bugs.
finally we discuss the usages of custom instrumentation strategies and the provided apis.
.
overview in our implementation we built a system mainly consisting of three llvm passes namely aiprepare aitrace and aitolerate.
each of them will perform a corresponding transformation to the input source code.
specifically the input of aiprepare pass is the original source code.
it will assign an universally unique access id to each load store instruction in the llvm ir by adding a metadata node .
the marked code is stored in bitcode format for further usages.
if the user also designs a custom instrumentation strategy with our api a corresponding white list file will also be generated elaborated in section .
.
then the aitrace pass reads the marked code and adds a logging function before each memory access which will output a triplet of access id thread id and the accessed memory address to the trace file.
this instrumented code is used in the in house testing phase to gather enough traces for computing bsets.
finally the aitolerate pass uses all the data generated before white list and traces to transform the marked code to an a i guarded version of code.
the generated code is compiled to executable objects and used in production runs.originalt sourcet codeaiprepare passloadttwidt1 storetwidt2... ...... log t... loadttwidt1 log t... storetwidt2... ...... in house testingaitrace passaitolerate passaccess tracesguard t... loadttwidt1 guard t... storetwidt2... ...... whitetlistt tmarkedtsourcetcodetestingtphase productiontphasefigure overview of the whole system.
.
training tolerating in order to infer a iautomatically without any programmers annotation we rely on correct runs observed during the in house testing phase.
as pointed out by prior work programmers can assert whether a test run is correct or not by verifying the outputs.
generally the programmers should both run the application under different inputs to cover all the feasible paths and run multiple times with every input to explore different interleavings.
a systematic concurrency testing framework such as chess or ctrigger can also be used to systematically explore different interleavings for each input.
as described above the trace files consist of triplets of access id y thread id tid accessed memory address addr .
each of these triplets represents a dynamic instruction defined in section .
.
by scanning the trace files chronologically we can calculate the remote predecessor of each dynamic instruction as stated before.
in the meantime the belonging sets are updated as below bset y bset y rpre triplet x if triplet x y after scanning all the traces the aitolerate pass will encode the synthesized bsets the union of the results of each trace file into the application by adding an initialization function to the program s llvm global ctors array which is the list of constructor functions.
it will also add a guarding function before every shared memory accesses3to perform bug tolerating.
specifically the guarding functions will maintain a data structurerecorder to record the last two instructions that access memory mand are from different threads.
this is enough for calculating the remote predecessors because rpre of the current operation is the last access before updating if the access is from a different thread or it must be the second last one.
then after obtaining rpre the guarding function will check whether the corresponding anticipating invariant is held.
an anticipating invariant violation is reported if it does not i.e.
rpre ix 62bset sy although ixis derived from sy.
as analyzed in section .
thanks to ai s capability of anticipating bugs before their occurrence we can tolerate this violation by stalling the violating thread until the violation gets resolved.
the violated a iwill be checked again and again in order to determine whether the accesses from other threads have resolved it.
if the check passes the stalled thread will resume its execution.
although it is rare not all anticipating invariant violations can be tolerated by just perturbing the thread schedule.
it is possible that the only correct interleaving for an input is untested.
if such fake violation i.e.
false positive is not properly treated it may cause an indefinite stall.
thus in order to ensure forward progress 3a shared variable will be accessed by at least one static instructionsthat satisfies the property bset s fnilg6 .
thus we can identify shared memory accesses during the training while inferring a i.we set the maximum stall time to a threshold.
once the threshold is reached the system will log the violation and resume the stalled thread s execution.
the log is sent back to developers to determine whether this violation is a bug.
if it is not we can update the relevant a ito green light this new interleaving in future runs.
our algorithm ensures that stalling does not occur during the tested interleavings incorrectkinterleaving correctkinterleaving global optkshouldkbekinitializedkbeforekbeingkread.
wrongkorderkwillkleadktokcrash.wrintksmallserver ... k kkwebhttrack main chart adrk1kp kkkkkkkkkkkk tcreatedkbykwebhttrack maint kk...kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkvoidkback launch cmd voidtkpp kkhts cancel file push global opt2... kkkkkkkkkkkk... kk...kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkglobal opt hts create opt kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk... kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk htsserver.c htsweb.cthreadk1 threadk2 figure a real world w r order violation in httrack which cannot be detected by pset.
bsetxs1cx x nil bsetxs2cx x s1 xs3 bsetxs3cx x nil xs2 bsetxs4cx x s2 thexfirstxs4xxi3s4cxinxincorrectxrunxisxenclosed withxdottedxline xbecausexitxwillxbexstalled beforexitsxexecutionxuntilxthexsecondxone.remotexpredecessorxxxxxxxxxxrpreinxi3s4cx xnilxxxxxxbsetxs4c xxxxxxxxxxrpreinxi5s4c xs2 bsetxs4c threadx1 i1s1 writexx i3s3 readxx i4s4 readxx i5s3 readxxthreadx2 i2s2 writexx correctxrunx1threadx1 i1s1 writexx i2s3 readxx i4s4 readxx i5s3 readxxthreadx2 i3s2 writexx correctxrunx2threadx1 i1s1 writexx i2s3 readxx i3s4 readxx i5s4 readxx i6s3 readxxthreadx2 i4s2 writexx incorrectxrunstall figure the simplified code of figure .
figure shows the simplified version of figure a real world w r order violation in httrack.
the order assumed by developers is that s4should always be executed after s2.
as pointed out by shi et al.
since s2may inject between s1ands3 s execution in some cases like correct run pset cannot detect this bug.
but the remote predecessor of s4is always s2in both two correct test runs.
thus bset s4 fs2g which makes s4impossible to be executed before s2in production runs.
more details about this violation in the incorrect run can be found in figure .
in summary the pseudocode of guarding function is given in algorithm .
it should be noted that since we implement a iwithtable evaluated real world bugs.
category pattern number of bugs bugs atomicity violationr rjw 5mysql mysql mysql mozilla mozilla w rjw pigz 9ef658babdy mysql w wjr 5mysql mysql mozilla mozilla mozilla r wjr w 7mysql mysql apache apache mozilla mozilla mozilla r r wjr r w apache apache cherokee order violationw r 10axel 313564y httrack transmission transmission zsnes mozilla mysql bug from paper bugaboo fft lu barnes bug from paper loom r w pbzip2 bug from yu s homepage w w 2mysql mozilla bug from paper lu2008 algorithm pseudocode of the guarding function.
global variable recorder the map that maps a memory address mto the last two instructions that operate address m and are from different threads bset the map that maps an instruction ito its belonging set function guard dynamic instruction ins memory address m iter id getaccessid ins tid getcurrentthreadid while iter threshold do rpre getrpre ins ifrpre62bset then report an violation stall this thread for a while else break iter iter ifiter threshold then report an unresolved violation updaterecorder recorder id tid per variable synchronization the horizontal scalability of the original program will likely not to be constrained by a i. .
custom instrumentation strategy since only shared variable accesses have to be instrumented and there is not need to roll back a iincurs low overhead for many nontrivial desktop and server programs and is promising for production deployment.
but for some applications such as the highperformance computing hpc programs that have intensive heap accesses the default instrumentation scheme may still incur very high overhead.
to alleviate this problem a ialso provides users the ability to design custom instrumentation strategies that can decrease the overhead with little damage to ai s ability of detecting and tolerating bugs.
for example lu et.
al.
shows that a quarter of concurrency bugs in filesystem arise on failure paths.
a custom strategy that preferentially covers these regions will definitely be very useful.
moreover we propose an optional bias instrumentation scheme which is effective for the aforementioned hpc programs.
the scheme is based on a key observation that in a well tested pro gram bugs usually occur in cold less executed regions.
thus if an access is deemed to be very hot we chose to not instrument it.
we expect this scheme to miss few harmful bugs in practice because if a bug is lurking in these instructions it will probably be found by the in house testing or is benign .
similar approaches have been used in several sampling based race detecting methods and achieve a good result in google s practice .
as for implementation we first group all the static instructions into maximal number of groups that if instruction saandsbbelong to different groups they will never access the same address.
this can be achieved by using a greedy algorithm that merges two instructions that have accessed a same address into the same group with a disjoint set .
then we compute an ins proportion ip for each group which is the proportion of dynamic instructions generated by members of this group to all the shared memory accesses by counting the trace files .
finally if a specific flag is set when applying the aitolerate pass those groups whose ipis larger than a threshold is used in our experiments will not be instrumented.
other metrics such as ipof each instruction can also be used to identify the hot instructions.
additionally there is another usage of custom instrumentation strategies.
once a bug is detected or reported by others the users can choose to only instrument the bug related instructions to prevent all the future failures.
this can help to ease the pain caused by lengthy patch releasing period just like aviso and loom .
generally speaking the users can implement their own instrumentation strategies very conveniently by directly modifying the generated bsets.
but we also provide several apis to further facilitate this procedure.
by default the aitolerate pass will instrument all the shared variable accesses but if a specific flag is set it will only instrument the instructions declared by the following annotations the ai ins this func andai ins this bb macros are used to tell a ithat all the shared memory accesses belong to this function or basic block should be instrumented and the ai ins this addr void addr function is given to state that a ishould instrument all the accesses to addr which is implemented by using a dynamic analysis technique.
specifically when applying the aitrace pass this function will be replaced by a function that outputs the actual value of addr to the trace file.
then combining this information with the former mentioned triplets all the related instructions that have been observed during the test ing phase can be identified.
the users only need to posit these annotations in the proper positions of the code and set the corresponding flags.
then the whole procedure such as the recomputation of bsets because the omitted instructions should not affect recorder and selective instrumentation will all be automatically handled.
.
experimental ev aluation .
test platform applications and bugs we analyzed a i s capability of detecting and tolerating concurrency bugs by using representative real world bugs from multi threaded applications.
these applications include three widely used servers apache httpd cherokee and mysql seven desktop client applications mozilla axel pigz httrack transmission pbzip2 zsnes and the splash benchmarks .
as shown in table we group the found bugs into eight patterns for atomicity violations symbols on each side of the vertical line represent the assumed atomicity region in that thread.
thus a r r jw atomicity violation is a bug in which two consecutive read operations in one thread are assumed to be executed atomically but in fact they can be interleaved by a write operation from another thread.
and a r r wjr r w atomicity violation occurs when two threads concurrently execute an atomic region of two read operations followed by a write operation without acquiring a lock for order violations the symbols represent the assumed order.
for example in a w r order violation the programmer intends that a write operation should always be executed before another read operation but this intention is not guaranteed.
according to their particular conditions we identify these bugs by a bug report id in the software s bug database a forum post id a paper web page that describes them or a commit id that fixes them.
moreover two of these bugs were never reported before but detected by our system.
we also evaluated the overhead of our software implementation with several real world applications and the kernel programs from splash .
all these experiments were conducted on a core intel xeon machine .67ghz 24gb of memory running ubuntu12.
.
amd64 and using the llvm .
compiler4.
.
detecting and anticipating capability in order to evaluate whether each kind of bug can be detected or tolerated without using roll back by a iand several other existing invariants a vio dui cci and pset we execute the corresponding buggy programs5under the bug triggering input for 000times and check whether the bug is detected or tolerated random sleeps are added to increase the bug manifestation probability following the methodology used by previous works .
table gives our results in which xrepresents that all the manifestations from this kind of bug are detected tolerated in our experiments xrmeans that the bugs can only be detected tolerated on particular interleavings and the rest blank cells represent the corresponding invariant is not violated in all executions even when the bug is triggered.
overall a ican detect all the patterns of bugs we have found which is more than each prior invariant.
moreover it has a superior 4since the compilation of mysql requires the fno implicittemplates flag which is not supported in clang .
we use llvmg from llvm .
in that case.
5among all the bugs we used of them mainly from mozilla are bug kernels which contain all bug related code snippets extracted from the original buggy programs.
we use the original programs for the experiments of the remaining bugs.anticipating ability and thus can tolerate more bugs without using roll back.
in the rest of this section we will compare a iwith the prior invariants one by one.
.
.
avio a vio invariant is consisting of two static instructions from one thread that should not be interleaved by an unserializable memory operation from a different thread.
in which an interleaving is unserializable if the remote operation cannot be reordered out of the atomicity region without changing the result two read operations or operations that access different locations can exchange their place without changing the result but if they access the same variable and at least one of them is write they cannot do this .
it is an effective invariant for detecting atomicity violations.
w cr candcwkcarecassumedctocbecexecutedcatomicallyf wrongcinterleavingcwillcleadctoccrashfnsfiletransportfcpp incorrectcinterleaving correctcinterleavingcinsfiletransport processs c ccccccccccccccccccccccccccccccccccccccccccccccccnhandleevents c ccccfffcccccccccccccccccccccccccccccccccccccccccfff ccccmstatusc ccccccccmoutputstream writefroms cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccifsmstatusc cns ok cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccreturn ccccifsmstatusc cstream would block c ccccccccmstatusc cns ok ccccccccreturn cccc ccccfffccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccfff cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc threadc threadckk k r wkw r i figure an atomicity violation bug in mozilla which will not raise an a vio invariant violation.
however as a representative of those tools that focus on detecting atomicity violations a vio cannot handle order violations at all a vio can only detect a subset of atomicity violations because it only checks whether two consecutive memory accesses are unserializably interleaved.
as an illustration figure shows a w wjr atomicity violation given by yu et al.
that will be ignored by a vio.
in this bug r2 s interleaving between w1 r1or r1 w2are both serializable since a vio invariant is checked when the second instruction is about to be executed it can hardly anticipate the bugs hence is not able to be used for preventing them without using roll back.
.
.
dui as stated by shi et al.
dui is a set of definition use invariants which can be used to detect a large variety of software bugs including concurrency bugs both order and atomicity violations and sequential bugs.
specifically dui lr describes the property that a local read should always read a value defined by a local or remote writer dui follower checks whether two consecutive reads from one thread must read the same value and dui dset defines a definition set for every read instruction which encloses all the write instructions that the read instruction can read from.
however since dui concentrates on definition use data flows which can only be undermined by unexpected write operations before reads it cannot detect r w jr w atomicity violations e.g.
figure a .
in that kind of bugs the write operation is following the read operation not antedating it.
and it also cannot handle ww order violations as shown in figure because it is the order within write operations not the order between read and write that matters.
as for r w jr w atomicity violations although duitable evaluation results on different invariants bug detecting and tolerating without using roll back capability.
due to space constraints we aggregate the evaluation results of the bugs into patterns.
all results of aiin this table are obtained through experiments.
and the results for other detectors are obtained based on our understanding of their algorithms.
category pattern a i a vio dui cci pset detect tolerate detect tolerate detect tolerate detect tolerate detect tolerate atomicity violationr rjw x x x x x x x w rjw x x x x x x x w wjr x x x r x x x x x r wjr w x x x r xr x r r wjr r w x x x r xr x x order violationw r x x x rxr xrxr xrxr r w x x x x x x w w x x x x x x incorrect interleaving correct interleavingint readwriteproc ... ... callback function of pbreadasync p pbreadasync io pending true void donewaiting ... while io pending ... ... ... io pending false ... thread thread w1 w2 w1 is assumed to be executed before w2.
wrong order will lead to hang.macio.c macthr.cr figure a real world w w order violation in mozilla nspr that cannot be detected by dui.
can detect the most probable incorrect run shown in figure b by its dui follower it will miss the other probable incorrect interleaving figure c .
moreover like a vio dui lr and dui follower are checked at the last instruction of the buggy regions thus they cannot be used to anticipate bugs.
and dui dset can only predict w w jr atomicity violations and a subset of w r order violation if there exists another leading write operation that is executed before the buggy region.
correctbrunthreadb1 i1s1 readbx i2s2 readbx i3s3 writebxthreadb2 i4s1 readbx i5s2 readbx i6s3 writebx a remotebpredecessorincorrectbrunb1threadb1 i1s1 readbx i5s2 readbx i6s3 writebxthreadb2 i2s1 readbx i3s2 readbx i4s3 writebx b incorrectbrunb2threadb1 i1s1 readbx i2s2 readbx i5s3 writebxthreadb2 i3s1 readbx i4s2 readbx i6s3 writebx c figure the simplified code of a r r w jr r w atomicity violation .
.
cci cci which tracks properties like whether the last access was from the same thread and whether a variable has changed between two consecutive accesses from one thread can detect both atomicity and order violations.
but limitation still remains.
since cci does not record the ex ... write1 x write2 xthread thread ... read x correct run... write1 x write2 xthread thread ... read x incorrect runfigure a w r order violation that cci will ignore.
act program counters it is relatively simpler than our anticipating invariant.
as a double edged sword this simplification both promotes its efficiency and restricts its capability.
for example figure gives a complex version of the w r order violation shown in figure b .
in which the programmer s accurate intention is that the read operation in thread should be executed after the second write operation in thread .
but cci cannot tell different write operations apart and will ignore this kind of bugs.
cci may also miss the bug shown in figure a because it cannot differentiate it from a common benign race where a single read operation interleaves the r w atomicity region.
in contrast a ican correctly distinguish them by checking program counters.
then once again cci is similar to a vio dui lr and duifollower in the respect that it is about whether some properties will be preserved until a later instruction.
this kind of invariants is unsuitable for anticipating bugs.
.
.
pset different from the above invariants pset was proposed to prevent undetected concurrency bugs from happening at the production phase which is the same as our anticipating invariant.
during the production runs pset will ensure that a memory operation mcan only immediately depend on an instruction pthat belongs to a specific set named pset which is established during the testing phase.
here immediately depend on means that p andmshould access the same memory location and at least one of them is a write operation there is no instruction from either remote or local thread that accesses the same memory location between pandm.
although similar to our belonging set in the format pset is still an invariant about data dependencies like dui dset thus it constrains that at least one of pandmshould be write.
as a result it can only detect the bug after its turning point in many cases which makes the heavy weight roll back mechanism indispensable.
take the r w atomicity bug shown in figure a as an example sincepset assumes that two consecutive read instructions do not construct any depend on relationship it can only detect the bug at write thread which is too late to prevent the bug without rollback.
according to their experiments only out of bugs they have tested can be resolved by pset without using roll back which are consistent with our evaluation results.
in contrast a idoes not differentiate read and write instructions.
and it explicitly defines the state nilto represent the initial state which is critical in anticipating w r order violations.
therefore as shown in table a ican prevent all the bugs we have found by merely temporarily stalling the thread.
additionally shi et al.
pointed out that pset cannot detect the bug if it is similar to the w r order violation httrack figure because the influence of a remote operation will be blocked by local operations in pset caused by the second condition of pset .
this is not the case in a i. .
.
discussion the bugs we used have covered out of order and atomicity violation patterns concluded by park et al.
which demonstrates a good representativeness.
and the neglected one w1 w2 w1 is semantically akin to our w w jr atomicity violation since we can predict the bug before w2 s execution in a i right before its turning point .
but a i s ability of detecting and tolerating bugs can still be enhanced by integrating with other techniques.
for example a ican be easily extended to handle multi variable bugs by leveraging the coloring technique proposed by colorsafe .
since colorsafe is able to assign the same color to related variables the only modification needed in a iis replacing the memory address with the color assigned to it.
the bugs can be detected and tolerated without using roll back if the corresponding related variables are correctly colored.
and a icannot detect a synthetic bug described in bugaboo in which two threads repeated accesses to a shared variable must be interleaved.
but no code constraint enforces the interleaving.
this is caused by that fact that without recording any context information a icannot tell different dynamic instructions apart if they are derived from the same static instruction.
however programmers usually pay more attentions on these kinds of complicate synchronizations as a matter of fact we do not find any real world example belongs to this type and ai can integrate with bugaboo easily by adding context information to rpre.
.
new bugs although axel download accelerator and pigz compressing tool yin table are both widely used we detected two new bugs in them.
since they are both dangerous bugs that may lead to infinite loop andassertion failed respectively both of them were confirmed by the developers and fixed in the nightly build.
figure shows the detected order violation in axel in which thelast transfer should be updated before it is read in thread .
if this order is flipped thread will be unnecessarily canceled although it has already downloaded the current chunk.
moreover if this order is always flipped there will be an infinite loop.
this bug has been confirmed by the developer and fixed in the developing version by using unblocked asynchronous i o model instead of the previous block one.
we have also detected an atomicity violation in pigz.
it is a data race in pigz.c where an instruction reads a shared variable pool!made infree pool after releasing the corresponding mutex lock pool!have .
this bug has also been confirmed by the developer and fixed in the developing version .
.
performance w r axel.c last transfer should be updated by w before being read by r. wrong order will lead to unnecessary thread canceling.incorrect interleaving correct interleavingthread thread void setup thread void c void axel do ... ... ... if conn exec conn if gettime conn last transfer gettime .last transfer axel conf reconnect delay ... pthread cancel ... ... ... ... figure a detected order violation in axel.
table gives the evaluation result of the performance for our current a iimplementation6.
since we want our benchmark suit to cover different types of multi threaded applications we select two representatives from each categoy desktop applications server applications and the scientific computing kernels .
these applications are chosed because they are also the choices of many previous bug detection papers .
we compute the overhead by counting the total time or wall clock field of output for the kernel programs and desktop applications and the throughput output by testing benchmarks httperf super smack for server applications.
table run time overheads.
in this table the bias column and the default column give the overhead with and without bias instrumentation respectively.
applications overhead default bias desktop applicationpbzip2 pigz server applicationapache mysql splash benchmarksfft lu the applications shown in table can be roughly split into three categories.
the first category includes desktop applications like pbzip2 and pigz which do not have many instructions that access shared variables.
hence only a little run time overhead is imposed.
the second category includes those server applications.
although they may have relatively more heap accesses the overheads are still low because it is usually other factors such as the i o latencies that obstructs these applications performance.
applications from the splash benchmark suites belong to the third category they have extremely intensive heap accesses and loops.
in this case a proper custom instrumentation scheme is critical for low overhead.
as shown in the table our general bias instrumentation scheme with threshold can reduce the overhead to about .
and it will not ignore the bug listed in table .
as an illustration in fft two groups of instruction are omitted by the bias instrumentation.
each of them contains only 19instructions but has an ipof37 .
since they are the updating operations to the result array it is hard 6since the overhead for desktop and server applications are low enough even when instrumenting all the shared memory accesses their overheads after applying bias instrumentation are omitted.to imagine that the program can pass a comprehensive stress testing with a bug hiding in them.
we also expect that the programmers can use the apis provided by us to design even more effective custom instrumenting strategies that further lower the overhead for these cpu intensive programs.
overall since only shared variable accesses have to be instrumented and there is not need to roll back a iis much faster than those existing software only concurrency bug tolerating tools which usually impose an impractical overhead.
for example even in terms of i o intensive applications the software implementation of pset incurs more than overhead which is caused by its heavyweight software roll back implementation .
and thanks to the use of static instrumentation a iis also much more lightweight than those dynamic instrumentation based bug detection tools such as a vio s software implementation and dui which incur and5 overhead respectively.
contrary to our method conair takes a different approach to achieve low run time overhead.
it only aims to tolerate bugs that can be recovered by rolling back an idempotent region in one thread which can be reexecuted for any number of times without changing the program s semantics.
this policy allows conair to eschew the time consuming memory state checkpoint in general roll back.
nevertheless it also restricts conair s ability.
first conair cannot handle concurrency bugs that have i o operations.
a study shows that about of concurrency bugs belong to this kind.
second an idempotent region should not contain any shared variable write.
thus conair is not able to tolerate w r j w atomicity violations and some of r r w jr r w atomicity violations.
third even some local variable writes are not idempotent which constrains an idempotent region s length.
but in conair the idempotent region should both cover the whole errorpropagation region to tolerate a bug since conair can only affirm a bug after it has incurred some kinds of program failures.
frost is a novel technique to tolerate races.
it is efficient in terms of overhead .
but it gains this efficiency on the cost of high cpu utilization because it needs to run three independent instances of the program simultaneously.
and it can only process data races.
.
sufficient training similar to all the other invariant based techniques a ineeds sufficient tested execution traces to achieve a good coverage.
there may be false negatives i.e.
fail to predict some bugs if some shared memory accesses are not identified during training and there may be false positives i.e.
unnecessary stallings if some important correct interleavings are not covered during training.
in general this requires that the programmers should both run the application under different inputs and configurations to cover all the feasible paths and run multiple times with every input to explore different interleavings.
and since the logging function added by the aitrace pass and the guarding function added by the aitolerate pass impose a different overhead there may exist some interleavings that are less likely to happen in the testing phase.
thus we also provide a tool to automatically relax the bsets i.e.
reduce the false positives .
it simply run the a i guarded application and verifies the output.
if the outcome is correct the tool will relax the bsets with the generated violation report.
the programmers can also use a systematic concurrency testing framework such as ctrigger to systematically explore different interleavings for different inputs.
in our evaluation the numbers of execution needed for sufficient training i.e.
all the bugs are detected tolerated and no more false positive or unnecessary stalling arises are about 200for pbzip2 pigz fft lu about for mysql and about for apache.
even for apache the training can be completed within half a day.
comparing to the release cycle of large software usually several months and the fixing period of every bug more than a month on average we think the cost is acceptable.
moreover although the possibility of false positives cannot be eradicated it will only incur a stalling timeout in our work.
and the corresponding invariants can be updated immediately in order to green light all the future runs.
these stallings will never affect the program s correctness.
since the threads are randomly scheduled a correctly synchronized program will not depend on time delays.
.
related work the most closely related work of a iis pset that also proposes an invariant based technique to tolerate both atomicity and order violations at run time.
however as shown in section .
.
pset s ability of tolerating bugs relies heavily on roll back which makes it hard to be applied in production environments.
although one can substitute roll back with the idempotent reexecution technique introduced by conair to reduce the overhead there will be a consequent decrease in comprehensiveness as a side effect.
as we have discussed in section .
conair is incapable of tolerating many kinds of bugs.
and the other concurrency bug tolerating methods like frost lifetx and atomaid are all constrained in type of bugs that they can handle such as data races or atomicity violations.
in contrast a ican tolerate both atomicity and order violations without roll back and incurs moderate overhead.
as a complementary approach to concurrency bug detecting and tolerating several methods have recently been proposed to expose concurrency bugs during software testing .
these interleaving testing papers use different heuristics to insert delays and enhance the chance of bugs exposedness.
for example racefuzzer and ctrigger try to exercise a suspicious buggy interleaving in a real execution to verify whether it is really a bug or merely a false positive.
there also exist approaches such as pct that randomly insert delays or assign priority of threads to improve stress testing.
apart from them a itargets on bug avoidance which is not part of these works.
and these works can be used to complement a iby producing new thread interleavings for training.
.
conclusion this paper presents anticipating invariant whose violations can anticipate bugs right before their turning points.
based on it we implement a software only tool that can tolerate both atomicity and order violations with a lightweight stalling strategy instead of rollback mechanism or chunk based execution used in prior works.
our experiment results with real world bugs of different types have shown that a iis capable of detecting and tolerating all the eight patterns of bugs we have found.
in addition a ionly incurs negligible overhead for many nontrivial desktop and server applications.
and its slowdown on computation intensive programs can be reduced to about after using the bias instrumentation.
.