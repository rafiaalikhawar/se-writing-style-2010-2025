graph based analysis and prediction for software evolution pamela bhattacharya marios iliofotou iulian neamtiu michalis faloutsos department of computer science and engineering university of california riverside ca usa fpamelab marios neamtiu michalis g cs.ucr.edu abstract we exploit recent advances in analysis of graph topology to better understand software evolution and to construct predictors that facilitate software development and maintenance.
managing an evolving collaborative software system is a complex and expensive process which still cannot ensure software reliability.
emerging techniques in graph mining have revolutionized the modeling of many complex systems and processes.
we show how we can use a graph based characterization of a software system to capture its evolution and facilitate development by helping us estimate bug severity prioritize refactoring efforts and predict defect prone releases.
our work consists of three main thrusts.
first we construct graphs that capture software structure at two different levels a the product i.e.
source code and module level and b the process i.e.
developer collaboration level.
we identify a set of graph metrics that capture interesting properties of these graphs.
second we study the evolution of eleven open source programs including firefox eclipse mysql over the lifespan of the programs typically a decade or more.
third we show how our graph metrics can be used to construct predictors for bug severity high maintenance software parts and failureprone releases.
our work strongly suggests that using graph topology analysis concepts can open many actionable avenues in software engineering research and practice.
keywords graph science software evolution software quality defect prediction productivity metrics empirical studies i. i ntroduction improving software maintenance and development is an involved and costly task with direct financial impact.
according to gartner global software expenditures for amounted to billion with large vendors such as microsoft and ibm reporting multi billion dollar costs for software development each year .
a large part of development costs an estimated to percent of total costs is due to software evolution .
despite these high costs software is notoriously unreliable and software bugs can wreak havoc on software producers and consumers alike a nist survey estimates the annual cost of software bugs to be about .
billion .
at the same time understanding and constructing rigorous software evolution models remains a significant research challenge .
recently graph based analysis of complex systems has experienced a resurgence under the name of network science or mining of graph topology .
there is a good reason for this topology analysis of graphs has revolutionized the modeling and analysis of complex systems in many dis ciplines and practical problems.
for example graph based methods have opened new capabilities in classifying network traffic modeling the topology of networks and the web and understanding biological systems .
what these approaches have in common is the creation of graph based models to represent communication patterns topology or relationships.
given a graph model one can unleash a variety of techniques to discover patterns and communities detect abnormalities and outliers or predict trends.
the overarching goal of this work is to find whether graph based methods facilitate software engineering tasks.
specifically we use two fundamental questions to drive our work a how can we improve maintenance by identifying which components to debug test or refactor first?
and b can we predict the defect count of an upcoming software release?
note that our intention is not to find the best possible method for each question but to examine if a graph based method can help through the use of an appropriatelyconstructed graph model of the software system.
while we use these two indicative questions here we believe there could be other questions that can be addressed with graphbased approaches.
our thesis is that graph based approaches can help to better understand software evolution and to construct predictors that facilitate development and maintenance.
to substantiate we show how we can create graph based models that capture important properties of an evolving software system.
we analyze eleven open source software programs including firefox eclipse mysql samba over their documented lifespans typically a decade or more.
our results show that our graph metrics can detect significant structural changes and can help us estimate bug severity prioritize debugging efforts and predict defect prone releases.
our contributions can be grouped in three thrusts.
a. topological analysis of software based graphs can reveal properties about software process.
we propose the use of graphs to model software at two different levels and for each level we propose two different granularities.
at the software product level we model the software structure at the granularity of functions function level interaction and modules module level interaction .at the software process level we model the interactions between developers when fixing bugs and adding new features.
we use two construction methods the bugbased developer collaboration which captures how a bugfix is passed among developers and commit based developer collaboration which represents how many developers collaborated in events other than bug fixes by analyzing the commit logs.
b. graph metrics capture significant events in the software lifecycle.
we study the evolution of the graph models of these programs over one to two decades.
we find that these graphs exhibit some significant structural differences and some fundamental similarities.
specifically some graph metrics vary significantly among different programs while other metrics captures persistent behaviors and reveal major evolutionary events across all the examined programs.
for example our graph metrics have revealed major changes in software architecture in mid stream releases not ending in .
openssh .
vlc .
.
and firefox .
show big changes in graph metrics which upon inspection indicate architectural changes that trump changes observed in .
versions of those programs.
similarly our edit distance metric has detected a major change in samba s code structure in release .
.
jan due to major bug fixes and feature additions the change is not apparent when examining other metrics such as eloc.
c. our graph metrics can be used to predict bug severity maintenance effort and defect prone releases.
the cornerstone of our work is that our graph metrics and models can be used to suggest infer and predict important software engineering aspects.
apart from helping researchers construct predictors and evolution models our findings can help practitioners in tasks such as identifying the most important functions or modules prioritizing bug fixes estimating maintenance effort .
we show how noderank a graph metric akin to pagerank can predict bug severity.
.
we show how the modularity ratio metric can predict which modules will incur high maintenance effort.
.
we demonstrate that by analyzing the edit distance in the developer collaboration graphs we can predict failureprone releases.
while these predictors might seem intuitive we are the first to quantify the magnitude and lag of the predictors.
ii.
g raph construction we describe the methodology for graph construction data collection and computing graph metric values.
an overview of our system is presented in figure .
we construct graphs from two main sources the source code repository and the bug tracking system.1from the code repository we 1the graph datasets are available online at neamtiu graph data icse12 versionn version2 version1 main sta c func on call graph source code repository module collabora on graph developer collabora on graph bug tracking system commit logs patches code owners collabora4on on bug fixes ... source code bug reports figure .
system overview.
extract commit logs historic source code versions patches and source code based developer interaction.
from the bug tracker we extract bug histories and bug fixing based developer interaction.
all these artifacts are related and the relationships are captured using graph edges.
thus a series of graphs emerges.
the key observation of our approach is that information derived from these graphs can be used to understand how software evolves and how to construct effective predictors for software engineering metrics such as bug severity and maintenance effort.
a. source code based graphs we use the source code to construct graphs at two abstraction levels function call graph and module module collaboration graph .
to construct these graphs we extended codeviz a static analysis tool to extract function call information and global variable usage.
call graph the function call graph captures the static caller callee relationship.
if function a calls function b the function call graph contains two nodes a and b and a directed edge from node a to node b. our data set contains several applications written in a combination of c and c for virtual c methods we add edges to soundly account for dynamic dispatch.
function call graphs are essential in program understanding and have been shown effective for recovering software architecture for large programs .
module collaboration graph this graph captures communication between modules and is coarser grained than the function call graph.
we construct the module collaboration graph as follows if a function in module a calls a function in module b the graph contains a directed edge from a to b. similarly if a function in module a accesses a variable defined in module b we add an edge from a to b. module collaboration graphs help us understand how software components communicate.
b. developer collaboration graphs we build developer collaboration graphs to analyze how developers communicate as software evolves.
we build two kinds of graphs as described below application time re lan size kloc use span lea guage first last ses release release firefox c c blender c c vlc c c mysql c c samba c bind c sendmail c openssh c sqlite c vsftpd c eclipse java table i applications evolution span number of releases programming language size of first and last releases .
bug based developer collaboration to build the bugdeveloper collaboration graphs we use the bug tossing graphs we constructed in previous work .
when a bug is assigned to developer d1and he she is unable to resolve it the bug is reassigned to developer d2and we add a directed edge from d1tod2in our graph.
commit based developer collaboration the second kind of developer collaboration graph which we term effortdeveloper collaboration graphs traces how developers have collaborated in events other than bug fixes by analyzing commit logs.
we add an undirected edge between developers d1andd2if they have worked on the same file.
c. applications we base our study on eleven popular open source applications written mainly in c or combinations of c and c .
we select applications that have a long release history b significant size in lines of code and modules c a large set of developers who maintain them d a large user base who report bugs and submit patches.
the above criteria are necessary for making meaningful statistical behavioral and evolutionary observations.
table i lists the wide range of applications involved in our study along with some key properties.
firefox is the popular web browser from the mozilla suite.
blender is a 3d content creation suite.
vlc is a cross platform multimedia framework player and server.
mysql is a relational dbms.
samba is a tool suite that facilitates windows unix interoperability.
sendmail is the leading email transfer agent today.
bind is the leading dns server on the internet.
openssh is the standard open source suite implementing secure shell protocols.
sqlite is a popular library implementation of an sql database engine.
vsftpd is the ftp server in major unix distributions.
eclipse is a popular ide.
the second column shows the time span we consider for each application the third column contains the number of official releases within that time span we analyzed all these releases.
column shows the main language s the application was written in some of the applications havesmall parts written in other languages e.g.
javascript.
columns and show application size in effective loc for the first and last releases.
the last column shows the studies and hypotheses we use each program for means we have used that application in the evolution study section iv the numbers indicate whether we have used that application when testing hypotheses h1 h2 or h3 sections v vi and vii respectively .
the long time spans we consider samba has grown by a factor of 200x over years allow us to analyze evolution rigorously obtain statistically significant results and observe a variety of change patterns in the graphs.
for each application we have used its website to obtain the source code of official releases.
we used applications version control systems for extracting file change histories and patches.
finally we extracted bug information from application specific bug tracking systems.
iii.
m etrics we introduce the graph metrics and the software engineering concepts which we will use in our work.
a. graph metrics for each metric we indicate if it is calculated on a directed and undirected graph.
our graphs are initially directed but can be trivially transformed into undirected graphs by ignoring the directivity of the edges.
average degree directed graph in a graph g v e vdenotes the set of nodes and edenotes the set of edges.
the average degree is defined as k 2jej jvj clustering coefficient undirected graph the clustering coefficient c u of a node ucaptures the local connectivity or the probability that two neighbors of uare also connected.
it is defined as the ratio of the number of existing edges between all neighbors of uover the maximum possible number of such edges.
let jfejkgjbe the number of edges between u s neighbors and kube the number of u s neighbors.
then we have c u 2jfejkgj ku ku the metric is meaningful for nodes with at least two neighbors.
a graph s average clustering coefficient is the average clustering coefficient over all the nodes.
noderank directed graph we define a measure called noderank that assigns a numerical weight to each node in a graph to measure the relative importance of that node in the software this rank is similar to pagerank which represents the stationary distribution of the graph interpreted as a markov chain.
there are several ways for defining and calculating the pagerank.
here we use the following recursive calculation.
for a node u letnr u be itsnoderank and let the set inucontains all the nodes v that have an outgoing edge to u. we assign equal noderrankvalues to all nodes initially.
in every iteration the new nr u is the sum over all v2inu nr u x v2inunr v outdegree v we stop the iteration when the noderank values converge.
note that to enable convergence at the end of every iteration we normalize all values so that their sum is equal to one.
intuitively the higher the noderank of a vertex u the more important uis for the program because many other modules or functions depend on it i.e.
call it .
similarly in the developer collaboration graph a developer dwith a high nr d signifies a reputable developer.
graph diameter undirected graph is the longest shortest path between any two vertices in the graph.
assortativity undirected graph the assortativity coefficient is a correlation coefficient between the degrees of nodes on two ends of an edge it quantifies the preference of a network s nodes to connect with nodes that are similar or different as follows.
a positive assortativity coefficient indicates that nodes tend to link to other nodes with the same or similar degree.
assortativity has been extensively used in other network science studies.
for instance in social networks highly connected nodes tend to be connected with other high degree nodes .
on the other hand biological networks typically show disassortativity as high degree nodes tend to attach to low degree nodes .
edit distance directed graph the metrics we described so far characterize a single program release.
to find out how program structure changes over time we introduce a metric that captures the number of changes in vertices and edges between two graphs in our case between successive releases.
the edit distance ed g1 g2 between two graphs g1 v1 e1 andg2 v2 e2 is defined as ed g1 g2 jv1j jv2j jv1 v2j je1j je2j je1 e2j.
intuitively if g1andg2model software structures for releases and then high values of ed g1 g2 indicate large scale structural changes between releases.
modularity ratio directed graph standard software engineering practice suggests that software design exhibiting high cohesion and low coupling provides a host of benefits as it makes software easy to understand easy to test and easy to evolve .
therefore we define the modularity ratio of a module aas the ratio between its cohesion and its coupling values modularityratio a cohesion a coupling a where cohesion a is the total number of intra module calls or variable