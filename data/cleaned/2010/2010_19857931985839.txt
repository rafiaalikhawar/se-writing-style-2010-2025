verifyingmulti threadedsoftwareusingsmt based context boundedmodelchecking lucas cordeiro university of southampton lcc08r ecs.soton.ac.ukbernd fischer university of southampton b.fischer ecs.soton.ac.uk abstract we describe and evaluate three approaches to model check multi threaded software with shared variables and locks using bounded model checking based on satisfiability modulo theories smt and our modelling of the synchronization primitives of the pthread library.
in the lazy approach we generate all possible interleavings and call the smt solver on each of them individually until we either find a bug or have systematically explored all interleavings.
in the schedule recording approach we encode all possible interleavings into one single formula and then exploit the high speed of the smt solvers.
in the underapproximation and widening approach we reduce the state space by abstracting the number of interleavings from the proofs of unsatisfiability generated by the smt solvers.
in all three approaches we bound the number of context switches allowed among threads in order to reduce the number of interleavings explored.
we implemented these approaches in esbmc our smt based bounded model checker for ansi c programs.
our experiments show that esbmc can analyze larger problems and substantially reduce the verification time compared to stateof the art techniques that use iterative context bounding algorithms or counter example guided abstraction refinement.
categoriesandsubjectdescriptors d. .
model checking f. .
specifying and verifying and reasoning about programs mechanical verification generalterms computer aided verification keywords formal software verification sat modulo theories symbolic and explicit model checking multi threaded systems permissiontomakedigitalorhardcopiesofallorpartofthisw orkfor personalorclassroomuseisgrantedwithoutfeeprovidedth atcopiesare notmadeordistributedforprofitorcommercialadvantageandth atcopies bearthisnoticeandthefullcitationonthefirstpage.tocop yotherwise to republish topostonserversortoredistributetolists re quirespriorspecific permissionand orafee.
icse may21 waikiki honolulu hi usa copyright2011acm978 ... .
.
.
introduction bounded model checking bmc has already been successfully applied to verify software and to discover subtle errors in real systems .
in an attempt to cope with growing system complexity boolean satisfiability sat solvers are increasingly replaced by satisfiability modulo theories smt solvers to prove the generated verification conditions vcs .
there have also been attempts to extend bmc to the verification of multi threaded software .
the main challenge here is the state space explosion as the number of possible interleavings grows exponentially with the number of threads and program statements.
however most concurrency bugs in real applications have been found to be shallow so that only a few context switches are required to expose them .
we can thus use a contextbounded analysis that limits the number of context switches it explores.
also sat and smt solvers produce unsatisfiable cores that allow us to remove possible undesired models of the system in order to satisfy a given property .
grumberg et al.
showed that the unsatisfiable cores can also be used to control the number of allowed interleavings of the given set of threads.
they proposed a sat based bmc method to model check a multi threaded system using a series of under approximated models.
however their method does not use smt solvers and does not combine contextbounded analysis with symbolic algorithms which limits its usefulness for verifying multi threaded software.
in our prior work we extended the encodings from previous smt based bmc to provide more accurate support for variables of finite bit width bit vector operations arrays structures unions and pointers and implemented these in the esbmc tool which is built on top of the cbmc model checker .
here we continue this work and develop and evaluate three related approaches for model checking multi threaded ansi c software.
in contrast to previous fully symbolic approaches e.g.
we combine symbolic model checking with explicit state space exploration.
in particular we explicitly explore the possible interleavings up to the given context bound while we treat each interleaving itself symbolically.
this approach is similar to the recent esst approach by cimatti et al.
but we handle ansi c instead of systemc use bmc instead of predicate abstraction and place no restrictions on the scheduler.
our approaches all implicitly use the reachability tree rt derived from the system but differ in the way they exploit it.
in the lazyapproach we traverse the rt depth first and simply call the single threaded bmc procedure on the interleaving whenever we reach an rt leaf node.
we stop thepermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
rt traversal either when we find a bug or have systematically explored all interleavings.
in the scheduling recording approach we use the rt to encode all the possible execution paths into one single formula which is then fed into the smt solver.
in a third approach we extend the underapproximation and widening uw algorithm with the purpose of addressing the verification of real world c code using different background theories and smt solvers.
we make two major novel contributions.
first we exploit smt to improve bmc of multi threaded software.
we describe a comprehensive smt based bmc procedure to support the checking of multi threaded c programs that use the synchronization primitives of the posix pthread library .
second we describe and evaluate three related approaches to smt based bmc.
this work also marks the first application of the uw algorithm in combination with context bounded model checking to verify non trivial multithreaded c software.
experiments obtained with the extended esbmc show that our approaches can analyze larger problems and substantially reduce the verification time over state of the art techniques that use iterative context bounding algorithms and others that implement counter example guided abstraction refinement cegar techniques.
.
preliminaries in the widely adopted interleaving paradigm for multithreaded programs the notion of concurrency is represented by that of interleaving i.e.
the non deterministic choice between activities of the simultaneously acting threads .
an interleaving thus represents a possible execution of the program where all of the concurrent events are arranged in a linear order.
any change of the active thread in an interleaving is a context switch.
the interleaving paradigm relies on a scheduler which selects the concurrently executing threads according to a given strategy.
this abstracts from the speed of the participating threads and thus models any possible realization by a single core machine or by several cores with arbitrary speeds.
however in order to fully verify a multi threaded program against a given specification all possible interleavings must be considered.
this results in a large state space that must be explored by a model checker.
.
gotoprograms we consider multi threaded ansi c programs in asynchronous mode and assume that all threads in the program only communicate through shared global variables.
esbmc handles full ansi c but for presentation we use a minimal language similar to the internal goto language of the cbmc model checker .
it is expressive enough to model multi threaded programs fml var true false fml fml ... exp exp ... exp var const var exp exp ... cmd skip var exp var assume fml assert fml gotol if fml goto l begin atomic endatomic begin thread id endthread var start thread id join thread var prog cmd ... cmd a goto program is a numbered list of commands.
commands include assignments nondeterministic assignments var blocking statements assume to cut off sub sequent executions paths and assertion statements assert to indicate user specified properties.
all control structures are represented by explicit conditional jumps to a statementl ... n .
a threadtis a sublist of commands between begin thread andendthread .
threads are created via asynchronous procedure calls start thread which return an integer that can be used as thread identifier for synchronization join thread hence dynamic thread creation is allowed.
atomic statements atomicbegin andatomicend indicate that a code segment cannot be preempted by another thread.
figure shows an example of a multi threaded c program and its representation.
.
formalmodelofmulti threadedsoftware the multi threaded software to be analyzed is modelled as a tuplem a bracketle ts s t v a bracketri ht where sis a finite set of states with initial states s0 s t t0 t1 ... t nis the set of threads where nrepresents the total number of threads v vglobal uniontextvjwherevglobal is the set of global variables and vjis the set of local variables of tj.
we assume that each variable ranges over a finite domain.
a states sconsists of the values of the global and local variables including a local program counter for each thread.
each thread jis a tupletj rj lj where rj s sis the transition relation of thread tj lj angbracketleftbig lj i angbracketrightbig is the sequence of thread locations lj iat time stepi.
the execution of the instructions of each thread tjis modelled by means of transition relations and we use the notation rj i s s to denote that s is a successor of sobtained by executing at time step ian instruction of thread tj.
finally a particular program location denoted by lj 0is designated as the entry point of thread tj.
.
context boundedmodelcheckingofmulti threadedsoftware .
exploringthereachabilitytree in order to describe reachable states of a multi threaded goto program we use a reachability tree rt that is obtained by unfolding the set of running threads.
for a multithreaded program with nactive threads each node in the rt is a tuple ai ci si a bracketle tlj i gj i a bracketri htn j ifor a given time stepi where airepresents the currently active thread cirepresents the context switch number sirepresents the current state lj irepresents the current location of thread j gj irepresents the control flow guards accumulated in threadjalong the path from lj 0tolj i. since threads only communicate via global variables we only need to consider context switches at visible instructions i.e.
synchronization points and statements containing global variables.
as in we do not model context switches inside individual visible statements.
this is safe as long as the statements only read or write a single global variable but in3321 include pthread .
h 2int x 3void t1 void arg x i f x x return null 8void t2 void arg bool y x y x i f y x return null 15int main void pthread t id1 id2 pthread create id1 null t1 null pthread create id2 null t2 null p t h r e a d j o i n id1 null p t h r e a d j o i n id2 null assert x return a int x begin thread t1 x x i f!
x then goto l6 x x l6 end thread begin thread t2 bool y x x y x i f!
y then goto l13 x x l13 end thread id1 s t a r t t h r e a d t1 id2 s t a r t t h r e a d t2 join thread id1 join thread id2 assert x return b l3 x x l4 if !
x l5 x x 1l2 start thread l6 end threadfalse truel9 x x l11 if !y l12 x x 1l7 start thread l13 end threadfalse truel8 bool y l10 y x c figure a a multi threaded c program with an assertion viola tion.
b the c program of a converted into goto form.
c control flow graph of two threads of the goto program in b .
general it is an under approximation.
however we have not encountered any problems in the benchmarks we have used.
additionally we do not model context switches between a visible control flow test and the next visible statement since the test cannot influence the state.
we can simulate the effect of a context switch right after a visible test by hoisting the test out of the conditional and assigning its result to a new auxiliary variable as shown in thread t2in figure a .
esbmc can be configured to automatically insert such auxiliary variables.
we also assume sequential consistency as is common in model checking multi threaded systems.
in order to expand the rt and explore all possible interleavings we symbolically execute each instruction of the multi threaded goto program.
this takes as input the program and the current rt node and generates its children according to the set of rules described below.
we assume that we expand an rt node at time step iand that the guard gai iof the thread taiis enabled in state si i.e.
that the corresponding formula is satisfiable so that the thread can potentially execute the instruction iat location lai i. note that our current implementation does not check the satisfiability of the accumulated guards and simply assumes that all running threads are enabled unless they have explicitly been blocked.
implementing this could further reduce the size of the rt to be explored.
r1 ifiis an assignment x e then we symbolically execute i which generates a new state si .
we then add as child to a new node ai ci si a bracketle tlj i gj i a bracketri ht i where the active thread remains unchanged.
we increment the location of the active thread only i.e.
lai i lai i and leave all other locations and all guards unchanged however note that the evaluation of the guards can change under the new statesi and hence threads may become enabled.
we have fully expanded if lai iis within an atomic block or icontains no global variable since we allow context switches only at visible instructions or we have reached the upper bound of context switches to be explored i.e.
ci c .
if is not yet fully expanded we then also explore all context switches up to the given context bound c. for each thread j e atio slash aiwheregj iis enabled in si we thus create a new child node j j ci si a bracketle tlj i gj i a bracketri ht i .
in jwe then continue the rt exploration with thread jexecuting in the state produced by the current thread ai.
r2 ifiis askip statement or an unconditional goto statement with target l then we simply increment resp.
set the location of the current thread and continue with it.
we explore no context switches i.e.
we only add a single child node ai ci si a bracketle tlj i gj i a bracketri ht i wherelj i lj i resp.
lj i l ifj aiandlj i lj iotherwise.
r3 if iis a conditional goto statement with test cand targetl then we create two child nodes and for both possible outcomes of the test.
for we assume that cis true and proceed with the target instruction of the jump similar to unconditional jumps.
however we also add cto the guards of all other threads since it may contain global variables and may thus enable or disable other transitions.
hence we construct ai ci si a bracketle tlj i c gj i a bracketri ht i where lj i lifj aiandlj i lj iotherwise .
for we add cto the guards and continue with the next instruction in the current thread i.e.
ai ci si a bracketle tlj i c gj i a bracketri ht i wherelj i lj i ifj aiandlj i lj iotherwise .
we prune one of the nodes if the condition is determined in the current state i.e.
either evalutes to true or to false .
note that we are not exploring any possible context switches even ifiis visible since the condition cannot change the global state.
r4 ifiis an assume orassert statement with argument c then we proceed similar to the way described in r1.
we continue with the unchanged state sibut addcto all guards as described in r3.
if iis an assume andc gj ievaluates tofalse we prune the execution paths and if iis an assert we generate a vc to check the validity of c.333r5 ifiis astart thread instruction we just add the indicated thread to the set of active threads i.e.
we add a node ai ci si a bracketle tlj i gj i a bracketri htn j i whereln i 1is the initial location of the indicated thread and gn i gai i i.e.
the thread starts with the guards of the currently active thread.
r6 ifiis ajointhread instruction with argument id then we add a child node ai ci si a bracketle tlj i gj i a bracketri ht i where lj i lai i only if the joining thread idhas exited.
we model this by an additional variable exit jthat is set to false when begin thread id is called.
when endthread is reached we setexit jtotrue to indicate that thread idhas exited.
the remaining instructions begin atomic endatomic beginthread and endthread are just scoping constructs and do not contribute to the expansion of the rt.
as example we consider the c program with two threads and the corresponding goto program as shown in figure a and b .
this example is modified slightly from where it is used to check by increasing the number of increments the scalability of different context bounded analysis algorithms.
both threads increment a global variable x and then depending on the value of x decrement it again.
t2uses a local variable yto store the value of xand uses this in the test cf.
lines .
this simulates a possible context switch between the evaluation of the guard and the execution of the next statement.
figure c shows the cfg representation of the two threads t1andt2.
note that this example contains an assertion violation in line where the invariant x does not hold under specific thread interleavings.
figure shows a fragment of the reachability tree for threadst1andt2.
we build this by first executing the gotoprogram of figure b sequentially i.e.
in the same order that the threads are created.
in this case we first execute the statements of t1 i.e.
lines followed by the statements oft2 i.e.
lines .
the initial node of the rt fragment is 0 t0 s0 a bracketle t l16 true l2 true l7 true a bracketri ht i.e.
the main thread t0is active at line the program is before the first context switch the state s0hasx andyundefined and both threads t1andt2have just been started i.e.
are at their initial location with guards true.
to expand the rt we check which threads are enabled from 0. sincet1and t2are both enabled and since our approach always expands the enabled thread with the smallest index we expand the transitions of t1.
the transition relation r1 s0 s1 oft1that represents the assignment x x is defined as follows r1 s0 s1 l1 l3 x1 x0 v v x v1 v0 the first term corresponds to the unconditional edge from line to see figure c .
the second term defines the new value of the shared variable x. the third term ensures that the values of v but notx do not change in the transition froms0tos1.
to create node 1 we apply rule r1 which gives us 1 t1 s1 a bracketle t l16 true l3 true l7 true a bracketri ht .
we then check again which threads are enabled and expand t1as the enabled thread with the smallest index.
the transition relation that represents the branch at program location l4 is defined by a case split on the value of xin states1.
r1 s1 s2 l1 braceleftbigg l6 x1 l5 otherwise v v v2 v1 the transition does not affect the global state as the con dition x1 holds so we only increment the program location but do not create a new node in the rt described in rule r3 .
therefore to expand the next node from 1 we check again which threads are enabled and since t1has executed all its statements we then expand the first instruction of threadt2.
the transition relation r2 s2 s3 oft2is similar tor1 s0 s1 .
we thus apply rules r1 and r2 to derive 2 t2 s2 a bracketle t l16 true l6 true l9 true a bracketri ht .
3and 4 are derived in the same way.
after creating 4 botht1and t2do not have enabled transitions and we backtrack to explore pending transitions from previous nodes in this case we have already explored 3and 2and continue the rt exploration at 1. .
lazyapproach the idea of the lazy approach to verify multi threaded software is to traverse the rt depth first and to call the single threaded bmc procedure on each interleaving whenever we reach an rt leaf node.
we stop the rt traversal either when we find a bug or have systematically explored all interleavings.
figure details how the lazy approach works.
formally given an rt 1 ... n that represents the program unfolding for a context bound cand a bound k and a property we derive a vc kfor a given interleaving or computation path 1 ... k such that kis satisfiable if and only if has a counterexample of depth kthat is exhibited by .
the vc kis a quantifier free formula in a decidable subset of first order logic which is checked for satisfiability by an smt solver.
the model checking problem associated with smt based bmc of a given is formulated by constructing the logical formula k constraints bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright i s0 r s0 s1 ... r sk sk property bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright k here krepresents a safety property in stepk iis the set of initial states and r si si is the transition relation at time steps iandi as described by the states in the nodes of .
in order to check if the logical formula is satisfiable or unsatisfiable the smt solver constrains some symbols by a given background theory e.g.
the theory of arithmetics restricts the interpretation of symbols such as and .
if is satisfiable then is violated and the smt solver provides a satisfying assignment from which we can extract the values of the program variables to construct a counterexample i.e.
a sequence of states s0 s1 ... s kwiths0 s0 andr si si for i k .
if is unsatisfiable we can conclude that no error state is reachable in length kalong .
step initialize the stack with the initial node 0and the initial path 0 a bracketle t 0 a bracketri ht.
step if the stack is empty terminate with no error .
step pop the current node and current path off the stack and compute the set of successors of using rules r1 r6.
step if is empty derive the vc kfor using formula and call the smt solver on it.
if kis satisfiable terminate with error otherwise goto step .
step if is not empty then for each node add to and push node and extended path on the stack.
goto step .
figure algorithm of the lazy approach.
on the face of it the lazy approach seems to be naive 334 0 t0 x y l16 true l2 true l7 true 1 t1 x y l16 true l3 true l7 true 2 t2 x y false l16 true l6 true l9 true 3 t2 x y true l16 true l6 true l10 true 4 t2 x y true l16 true l6 true l12 false 5 t2 x y false l16 true l3 true l9 true 6 t1 x y false l16 true l5 false l9 true 7 t2 x y false l16 true l5 false l10 true 8 t2 x y true l16 true l3 true l10 true 9 t1 x y true l16 true l5 false l10 true 10 t2 x y true l16 true l5 false l12 false 12 t2 x y false l16 true l2 true l9 true 13 t1 x y false l16 true l3 true l9 true 14 t1 x y false l16 true l5 false l9 true 15 t2 x y false l16 true l5 false l10 true 16 t2 x y true l16 true l3 true l10 true 17 t1 x y true l16 true l5 false l10 true 18 t2 x y true l16 true l5 false l12 false 20 t2 x y false l16 true l2 true l10 true 21 t1 x y false l16 true l3 true l13 true 22 t1 x y false l16 true l5 false l13 true 11 t2 x y true l16 true l5 true l12 false 19 t2 x y true l16 true l3 true l12 false figure fragment of the reachability tree of the multi thre aded goto program of figure b .
nodes with dashed line represent program locations that violate the asserti on statement in line of figure b .
despite the context bounding the rt and thus the number of interleavings can grow very quickly and we need to invoke the smt solver several times to check the satisfiability of formula which might slow down the verification process.
however there are several observations that make this approach worthwhile.
first if the program contains any errors at all they will often be exhibited in a substantial fraction of the interleavings cf.
for experience on real applications so that in practice we only need to explore a small part of the search space until we find the first error.
in our running example the invariant x does not hold for the two nodes 10and 18and if we traverse the rt depth first and left to right the error already shows up in the third interleaving.
second we do not need to actually build the entire rt instead we only keep in memory nodes on computation paths that are still unexplored and expand them one path at a time.
we then construct the vc for the chosen computation path and feed it into the smt solver to check for satisfiability.
third and most important we can leverage the optimizations from the cbmc front end e.g.
constant propagation and folding to exploit which transitions are enabled in a given state to drive the exploration of the interleavings and to reduce both the number of interleavings to be explored and the size of the formulas sent to the smt solver.
for example if we continue to explore thread t1from node 1 the front end exploits the fact that x to infer that the guard in line holds.
t1thus continues in line and terminates so that the exploration continues with a context switch to thread t2 as shown in node 2. in summary the lazy approach guides the symbolic execution between the threads and systematically explore all the possible interleavings in a lazy way.
this approach can find bugs fast but as the front end invokes the smt solver once for each possible computation path it can suffer performance degradation in particular for correct programs where we explore all possible interleavings.
.
schedulerecordingapproach state of the art smt solvers are built on top of efficientsat solvers to speed up the performance on large problems by exploiting the support for conflict clauses and nonchronological backtracking.
in the schedule recording approach we leverage this and avoid invoking the smt solver repeatedly.
we build the rt as before to systematically explore the interleavings but we now add schedule guards to record in which order the scheduler has executed the program.
figure shows how schedule guards are added to the program during the exploration of the left hand side of the rt in figure .
we then encode all interleavings into a single formula which is finally passed to the smt solver.
l2 t1 l7 t2 l3 t1 ts1 x x l9 t2 ts2 x x l10 t2 ts3 y x l12 t2 ts4 x x 1l9 t2 ts2 x x l5 t1 ts3 x x l10 t2 ts4 y x 1l10 t2 ts3 y x l5 t1 ts4 x x l12 t2 ts5 x x 1l12 t2 ts4 x x figure schedule recording applied to the lefthand side of the rt in figure .
since control flow tests cannot influence the state we only need to add guards to effective statements i.e.
assignments and assertions.
similarly we only need to record effective context switches ecs i.e.
context switches to an effective statement.
each effective program statement is then prefixed by a schedule guard tsi jwheretsiis the thread selection variable for the i th ecs and jis the thread identifier.
its335intuitive interpretation is that the statement can only be executed if thread jis scheduled to run after the i th ecs.
for example the schedule guard ts1 atl3encodes that x x can only be executed if t1runs after the first ecs.
the schedule guards are added when program statements are executed symbolically and become part of the produced vcs.
they can be derived from the rt nodes i.e.
for node iwe construct the guard tsci ai.
the thread selection variables are free variables that the smt solver will instantiate with concrete values.
the instantiation of all thread selection variables corresponds to the choice of a specific interleaving.
in our example if the smt solver chooses ts1 ts2 ts3 andts4 then the model checker simulates the effect of executing the program statements at l3 l9 l10 andl12 in that order .
note that the ordering of statements within a thread is of course still ensured by the program order semantics so that program statement at l10will not be executed before program statement at l9.
we further define a schedule sch to determine which interleavings are considered and encode the guards in as k constraints bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright i s0 r s0 s1 ... r sk sk property bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright k scheduler bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright sch s0 ... sch sk heresch si represents a constraint on the schedule guard of statesi.
if we do not add any constraints then we formulate logicalandtextk i 0sch si true and all possible interleavings are considered.
however if we want to apply aggressive reductions for example by exploiting the proofs of unsatisfiability as described in the next subsection we can add constraints tosch to force the removal of interleavings that do not contribute to checking a given property.
although we can bound the number of preemptions and exploit which transitions are enabled in a given state when we build formula the number of threads and context switches can still grow very large quickly and easily blow up the solver.
.
uwapproach the core idea of the under approximation and widening uw approach is to check models with an increasing set of allowed interleavings .
we start from an underapproximation describing a single interleaving and widen the model by adding more interleavings incrementally based on the proof objects generated from an smt solver .
we define as an underapproximated model of i.e.
sch s0 ... sch sk where we introduce constraints on the schedule guards.
we can see that if is unsatisfiable then is also unsatisfiable however it is possible that is satisfiable while is not due to the constraints on the schedule.
thus can be thought of as an underapproximation of and each satisfying assignment of is also a satisfying assignment to .
the main steps of the uw algorithm are shown in figure .
the additional literals clijintroduce constraints on the schedule guards e.g.
clij tsi j which allow us to guide the widening process according to the variables that participate in the proof of unsatisfiability produced by the smt solver.
this means that the schedule is now updated based on the information extracted from the proof which aims to remove interleavings that are not relevant for checking a given property .
note that the way that we en step add control literals clij whereiis the ecs number andjis the thread identifier to the vc k. step add negated control literals clijto the schedule sch except those enabling the first interleaving.
step check satisfiability of k if kis satisfiable then terminate with error .
step check whether the proof objects generated by the smt solver contains any control literals if not terminate with no error .
step remove literals that are contained in the proof objects from the schedule sch and go to step .
figure algorithm of the uw approach.
code the underapproximation differs from .
the authors in encode an underapproximation using m ncontrol literals where mis the number of control points that guard each program statement and nis the number of processes.
in our encoding we use e ncontrol literals where eis the number of ecs with e m andnis the number of threads.
if we were to include a control literal for each statement as in then our solution might not scale in practice to large multi threaded software systems.
.
modellingsynchronization primitivesinpthread this section presents our modelling of the synchronization primitives of the pthread library .
we assume that the library function implementations are correct and focus our effort on verifying only the client programs that use them.
we thus provide an instrumented model of the pthread functions and use this to model check the client code.
.
modellingmutexlockingoperations the pthread library supports two functions to implement mutual exclusion between threads pthreadmutexlockand pthreadmutexunlock .
both functions take as argument a data structure called mutex that has two states locked and unlocked .
pthreadmutexlock locks the mutex if it is unlocked otherwise it blocks the current thread until the mutex is unlocked and can successfully be locked again.
pthreadmutexunlock simply unlocks a locked mutex.
computation paths are blocked on a mutex when a thread tries to lock a mutex that has already been locked by another thread.
as an example consider the threads taandtb which both lock and unlock the same mutex m as shown in figure .
the paths a0 a1 b0 b1andb0 b1 a0 a1 are non blocking or wait free while the other two paths are blocked.
a0a1 b0 b1b0 a0b0 a0 a1b1 a1 b1start thread a0 lock m a1 unlock m end threadstart thread b0 lock m b1 unlock m end thread figure computation paths blocking on a mutex.
a strategy to model mutex operations based on the notion of wait free paths was proposed in .
instead of blocking the computation paths starting with a0 b0andb0 a0 336they are simply ignored by modelling pthreadmutexlockas atomic assume m m where the statement assume m cuts off subsequent paths if the mutex is already locked.
pthreadmutexunlock is then modelled as atomic assert m m which simply checks if the mutex is already locked.
if so the lock is released otherwise a thread tries to unlock a mutex that has not been locked previously and we have detected an error.
this is sufficient to find bugs related to data races and lock acquisition ordering but not to detect local and global deadlocks .
we thus model pthreadmutexlock in such a way that we can detect global and local deadlock caused by the wrong use of the mutexes pthreadmutexunlock remains unchanged.
for this we first need to look in more detail at the different possible states that our model allows for a thread i join state the thread is waiting for another thread to terminate ii lock state the thread is waiting for a mutex to be unlocked iii wait state the thread is waiting for a signal or broadcast to wake up iv exit state the thread has already exited v free state the thread is not in any of the above four states and is free to execute its instructions.
a thread is blocked if it is in one of the join lockorwait states and is supposed to be running if it is not inexitstate.
global deadlock occurs when all threads wait for a mutex and a local deadlock occurs when some of the threads form a waiting cycle.
in both cases we can detect the deadlock if there is no running thread in the free state i.e.
the number of blocked threads is equal to the number of running threads.
figure presents our modelling to detect global and local deadlock with mutexes which maintains counts on both blocked and running threads with global variables.
1int pthread mutex lock pthread mutex t m 2extern uint t r d s i nr u n c l o c k atomic unlocked m u t e x l o c k f i e l d m i f unlocked m u t e x l o c k f i e l d m else cl o c k c l o c k atomic i f m u t e x l o c k f i e l d m cl o c k c l o c k i f !
unlocked deadlock mutex c lock t r d s i nr u n assert deadlock mutex assume !
deadlock mutex return figure modelling mutex lock operation.
mutexlockfield retrieves the state of the mutex.
we also use the variable clockto count the number of threads that are in the lock state due to mutex m andtrdsinrunto count the number of threads that are currently running.
initially the mutex is unlocked and we only lock it after the first call to pthreadmutexlock.
in subsequent calls we increase the value of the variable clock allow context switches check if the mutex mwas unlocked and then assertclock trds inrun.
if the assertion fails a deadlock was detected a thread is blocked by a lock operation on a mutex and the required mutex never gets unlocked by the thread that owns it either because the locking thread has exited or because it has been blocked by another operation.if the assertion holds we then eliminate this execution as described above.
.
modellingconditionalwaiting we model functions pthread cond wait pthread cond signal andpthread cond broadcast from the pthread library that implement conditional waiting.
all functions take as argument a condition variable cthat has also two states locked and unlocked pthread cond wait also takes a mutex argument.
our modelling of the conditional waiting operation again employs the notion of wait free execution paths.
pthreadcondwait is used to block the thread on a condition variable the blocked thread is woken up only if another thread calls signal or broadcast.
if several threads are blocked on a condition variable then pthreadcondsignal non deterministically unblocks at least one of them while pthreadcondbroadcast unblocks all threads blocked on the specified condition variable.
figure shows our modelling for the wait operation.
we use the variable cwait to count the number of threads that are in the wait state due to condition c. whenever a thread callspthreadcondwait we atomically lock the condition variablec assert that the mutex mis currently locked release the mutex so that other threads that access it can make progress and then increment the number of threads in wait state i.e.
threads that are waiting for a signal or broadcast to wake up .
we then allow context switches before we check whether the number of threads in wait state is less than the total number of the threads that are currently running with the assertion cwait trds inrun.
if the assertion holds or the variable cis locked we simply eliminate this execution as described above.
1int pthread cond wait pthread cond t c pthread mutex t m 3extern uint t r d s i nr u n c wait atomic c o n d l o c k f i e l d c assert m u t e x l o c k f i e l d m m u t e x l o c k f i e l d m cwait c wait atomic deadlock wait c wait t r d s i nr u n assert deadlock wait assume !
deadlock wait c o n d l o c k f i e l d c cwait c wait m u t e x l o c k f i e l d m return figure modelling conditional waiting operation.
to model signal operations we simply release the condition variable i.e.
c .
to model broadcast operations we create a global variable called broadcastid which records the number of broadcast operations that have executed and which gets incremented inside pthreadcondbroadcast .
in the wait operation the thread records the current value of broadcastidbefore it is forced to make context switches to other threads.
when the context is switched back to the current thread an assertion checks if a broadcast operation has occurred by checking whether the current value of broadcastidis greater than the recorded value.
the deadlock is detected if there is no path with broadcast operations.
.
experimentalevaluation we have implemented the lazy schedule recording and uw approaches described in section in our esbmc tool that supports the smt logics qf aufbv and qf auflira as specified in the smt lib .
in our experiments we have used esbmc v1.
.
together with z3 v2.
which was the most efficient smt solver in our previous experiments .
esbmc and the benchmarks are available at .
all experiments were conducted on an otherwise idle intel pentium dual cpu with gb of ram running windows and linux os respectively.
for all benchmarks the time limit has been set to seconds to check all properties at once.
all times given are wall clock time in seconds as measured through a single execution.
in our experiments we chose chess v0.
.
.
and satabs v2.
as two of the most widely used verification tools.
.
comparisontochess chess is a concurrency testing tool for c programs.
it implements iterative context bounding and explores the various thread schedules deterministically .
chess requires idempotent unit tests that it repeatedly executes in a loop exploring a different interleaving on each iteration.
in this respect it is similar to our lazy approach however chess is a purely dynamic test based tool and originally employed a stateless search technique but its latest version v0.
.
.
performs state hashing based on a happensbefore graph to avoid exploring the same state repeatedly.
table shows the detailed results of the comparison between esbmc and chess on a 2ghz machine.
reorder twostage and wrong lock are different versions of a reader writer program .
the numbers x y indicate that we have xinstance s of thread tsetandyinstance s of threadtreader .
according to increasing the number of instances of a given thread while keeping constant the number of instances of the other thread substantially increases the semantic hardness of the error discovery.
note that all these benchmarks only check for a single violated property.
micro is a synthetic micro benchmark which checks a single valid property.
it is used to check the scalability of multi threaded software verification tools.
the number in brackets indicates the total number of visible statements on each thread.
in the table lis the size of the code in lines andtthe total number of threads.
bis the number of bmc unrolling steps for each loop while cis the context switch bound.
except for reorder 6bad cis set to the minimum number of context switches required to expose the error.
time is the time in seconds until the error is found timeouts are denoted by to.
for esbmc iis the total number of generated interleavings while fiis the total number of failed interleavings.
the column itergives the number of iterations required to prove or disprove the property in the uw approach.
for chess tests reports the approximate number of tests executed which is not related to the number of interleavings.
both tools identify the property violation resp.
confirm that it holds in all cases where they do not run out of time or memory.
as we can see in table chess is effective for programs where there are a small number of threads but it does not scale that well and consistently runs out of time when we increase the number of threads.
in general chess times out when the number of threads increases beyond six.
the rela tively poor scalability of chess has already been observed by .
in contrast our lazy algorithm is able to find bugs quickly even when we increase the number of threads and the context bound and consistently outperforms chess as well as the schedule recording and uw approaches.
however note that it runs out of memory for test cases and when we increase the number of context switches to and respectively.
.
comparisontosatabs satabs is an ansi c model checker which supports the verification of multi threaded software with shared variables using the cegar technique.
we compare our approaches against satabs v2.
based on cadence smv using a number of multi threaded programs taken from standard benchmark suites.
table shows the results achieved on a 3ghz machine.
programs that end on bad contain an error i.e.
at least one of the properties is satisfiable while those that end on ok are correct.
here p gives the number of properties to be verified for each program which includes array bounds pointer safety division by zero deadlock and order violations checks.
a context bound of means that we did not specify a bound.
a result indicates that the tool failed with an error such as internal and refinement rf failure memory overflow mo time out to or failed to detect errors in the program.
a indicates that the tool detected the error or proved all vcs.
programs are concurrent implementations of stack queue and circular buffer data structures programs and are extracted from an embedded application .
programs are from the inspect benchmark and use mutex and condition synchronization primitives from the pthread library.
programs are from the vv lab benchmarks and contain common concurrency bugs such as data races atomicity and order violations.
programs are embedded applications that run on a dual core processor they are implemented in a commercial set top box product from nxp semiconductors .
program is the same synthetic micro benchmark described in section .
but here we increase further the number of context switches to check the scalability of our approaches.
as we can see in table satabs produces refinement failures rf for most programs.
these programs contain linear arithmetic operations with arrays and the predicate abstraction technique implemented in satabs seems to suffer from a lack of precision when dealing with arrays.
however the ability of a verification tool to check such programs is particularly important as many real world multi threaded programs belong to this class.
satabs also times out for large programs or for programs with many threads cf.
programs and .
additionally satabs gives false positives on programs which contain known bugs related to data races atomicity and order violations.
note that satabs uses predicate abstraction and refinement and in some sense tries to solve a harder problem than bmc.
however the results in table indicate that this problem may still be too hard for multi threaded applications as satabs is unable to prove the required properties.
we can also see in table that if the program contains errors at all these errors indeed generally occur in most interleavings explored consequently the lazy approach is very fast for these cases.
the notable exception is wronglock bad where less than .
of the interleavings expose the error338chess lazy schedule uw test program l t bc time tests time fi i time time iter 1reorder 3bad 2reorder 4bad 3reorder 5bad 56to 4reorder 6bad 67to 5reorder 6bad 68to 6reorder 6bad 69to mo mo 7twostage 3bad 8twostage 4bad 9twostage 5bad 54to 10twostage 6bad 64to 11wronglock 4bad 12wronglock 5bad 13wronglock 6bad 68to 14wronglock 7bad 78to mo mo 15micro 2ok 16micro 2ok to mo mo 17micro 3ok 12to 18micro 3ok to mo mo table results of the comparison between esbmc v1.
.
and c hess v0.
.
.
.
satabs lazy schedule uw test program l t p b c time result time result fi i time result time result iter 1circular buffer ok mo mo 2circular buffer bad 3queue ok rf 4queue bad 5stack ok 6stack bad rf 7fsbench ok 8fsbench bad 9indexer ok to 10stateful20 ok 11sync02 ok rf 12sync02 bad rf 13aget .
bad 14bzip2smp ok to mo mo 15reorder 10bad mo mo 16twostage 100bad 17wronglock 8bad mo mo 18exstbhdmi ok to 19exstbled ok rf 20exstbthumbs bad 21micro 10ok to mo mo table results of the comparison between satabs v2.
and esb mc v1.
.
.
and satabs is substantially faster than esbmc but fails to find the error however even here the lazy approach outperforms both the schedule recording and uw approaches.
similarly the lazy approach is capable of handling safe programs in which the number of threads and context switches grows quickly which makes the formula harder and often blows up the smt solver.
the uw approach is typically slower than schedule recording.
we suspect that the proof generation of the smt solver which is required to produce the unsatisfiable cores causes memory overhead and corresponding slowdowns this was also reported previously .
.
relatedwork smt based bmc is gaining popularity in the formal verification community .
however most work focuses on sequential software uses only restricted sets of theories e.g.
integer and real arithmetic that do not precisely reflect the ansi c semantics or does not address important lan guage constructs .
cimatti et al.
describe an approach to verify systemc that similarly combines explicit state space exploration i.e.
the explicit exploration of the different possible interleavings with symbolic model checking i.e.
the symbolic representation and updates of the state .
however we use bmc instead of predicate abstraction and we implement a realistic scheduler i.e.
our scheduler may preempt a thread at any visible instruction in its execution whereas encodes the semantics of the non preempting systemc scheduler.
we also exploit the smt techniques on large problems by encoding all possible interleavings into a single formula.
qadeer and rehof present a pragmatic method to discover bugs in concurrent software in which the program analysis is restricted to executions with a bounded number of context switches .
however they do not apply it to realistic concurrent software benchmarks and the integration of the context bounded algorithm into the explicit state model339checker zing is left for future work.
rabinovitz and grumberg describe an extension of cbmc to concurrent c programs which translates each c thread individually into ssa form and adds constraints for a bounded number of context switches as in .
this approach however is limited to two threads and requires the user to run cbmc twice in order to detect different types of bugs regular and concurrency bugs .
it is also only evaluated on a concurrent bubblesort but not on a set of realistic applications.
ganai and gupta describe a lazy method for modelling multi threaded concurrent systems using shared variables but this again is restricted to two threads.
gupta et al.
extend by supporting more than two threads and by combining dynamic partial order reduction with symbolic state space exploration.
the benchmarks that have been reported are a parameterized version of the dining philosophers model which are untypical multi threaded c programs.
grumberg et al.
propose an algorithmic method based on sat and bmc to model check a multi process system based on a series of under approximated models .
this approach however does not integrate context bounded analysis and it does not address the problem of model checking multi threaded c software.
.
conclusionsandfuturework we have presented the lazy schedule recording and uw algorithms to model check multi threaded ansi c software with shared variable communication between the threads.
we have also presented our modelling of the synchronization primitives of the pthread library that allows us to detect not only atomicity and order violations but also local and global deadlock that previous attempts are unable to find .
surprisingly our approach to check constraints lazily is extremely fast for programs that contain errors and to a lesser extent even for safe programs in which the number of threads and context switches grows quickly.
the experimental results also show that the lazy approach generally outperforms not only the schedule recording and uw approaches but also chess and satabs tools on several non trivial benchmarks.
as far as we are aware there is no other work that considers a comprehensive smtbased bmc procedure to verify multi threaded ansi c software by combining symbolic model checking with explicit state space exploration.
in future we plan to explore the use of craig interpolants to prove non interference of context switches and to develop an efficient method on top of esbmc to localize faults in multi threaded programs.
.