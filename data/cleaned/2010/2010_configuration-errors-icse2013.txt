automated diagnosis of software configuration errors sai zhang michael d. ernst computer science engineering university of washington usa fszhang mernstg cs.washington.edu abstract the behavior of a software system often depends on how that system is configured.
small configuration errors can lead to hard to diagnose undesired behaviors.
we present a technique and its tool implementation called confdiagnoser to identify the root cause of a configuration error a single configuration option that can be changed to produce desired behavior.
our technique uses static analysis dynamic profiling and statistical analysis to link the undesired behavior to specific configuration options.
it differs from existing approaches in two key aspects it does not require users to provide a testing oracle to check whether the software functions correctly and thus is fully automated and it can diagnose both crashing and noncrashing errors.
we evaluated confdiagnoser on non crashing configuration errors and crashing configuration errors from configurable software systems written in java.
on average the root cause was confdiagnoser s fifth ranked suggestion in out of errors the root cause was one of the top suggestions and more than half of the time the root cause was the first suggestion.
i. i ntroduction many software applications support configuration options that allow users to customize their behavior.
this flexibility has a cost when something goes wrong diagnosing a configuration error can be both time consuming and frustrating.
technical support contributes of the total cost of ownership of today s software and troubleshooting misconfigurations is a large part of technical support .
software misconfigurations may lead to incorrect output i.e.
non crashing errors or to unexpected termination i.e.
crashing errors .
even when an application outputs an error message it is often cryptic or misleading .
users may not even think of configuration as a cause of their problem.
a. motivating example we next describe a real scenario in which we used confdiagnoser to solve a configuration problem.
we received a bug report against the randoop automated test generation tool from a testing expert who had been using randoop for quite a while.
the bug report indicated that randoop terminated normally but failed to generate tests for the nanoxml program.
although the reported problem is deterministic and fully reproducible it is a silent non crashing failure and is challenging to diagnose.
differing from a crashing error randoop did not exhibit a crashing point dump a stack trace output an error message or indicate suspicious program variables that maysuspicious configuration option maxsize it affects the behavior of predicate newsequence.size geninputsabstract.maxsize line class randoop.forwardgenerator this predicate evaluates to true .
of the time in normal runs observations .
of the time in the undesired run observations fig.
.
the top ranked configuration option in confdiagnoser s error report for the motivating example in section i a. have incorrect values.
lacking such information makes many techniques such as dynamic slicing dynamic information flow tracking and failure trace analysis inapplicable.
in addition for this scenario the person who reported the bug had already minimized the bug report if any part of the configuration or input is removed randoop either crashes or no longer exhibits this error.
this further makes search based fault isolation techniques such as delta debugging ineffective.
in fact this bug report does not reveal a real bug in the randoop code.
its root cause is that the user failed to set one configuration option.
despite the simplicity of the solution to the best of our knowledge no previous configuration error diagnosis technique can be directly applied.
our technique and its tool implementation confdiagnoser can diagnose and correct this problem.
we first reproduced the error in a confdiagnoser instrumented randoop version then confdiagnoser diagnosed the error s root cause by analyzing the recorded execution profile.
confdiagnoser produced a report figure in the form of an ordered list of suspicious configuration options that should be inspected.
the error report in figure suggests that a configuration option named maxsize is the most likely one.
the report also provides relevant information to explain why a program predicate affected by maxsize behaves dramatically differently between the recorded undesired execution and the correct executions found in confdiagnoser s database.
figure shows the relevant code snippet in randoop.
when randoop generates a new test line in the form of a methodcall sequence randoop compares its length with maxsize default value .
if the generated sequence s length exceeds this pre defined limit randoop discards it to avoid length explosion in further test generation.
although maxsize s default value was carefully chosen by the randoop developers and works well for many programs including those used to testin class randoop.main.geninputsabstract the maxsize configuration option.
default value .
.
public static int maxsize readfromcommandline in class randoop.forwardgenerator .
public executablesequence step .
executablesequence eseq createnewuniquesequence .
abstractgenerator.currseq eseq.sequence .
eseq.execute executionvisitor .
processsequence eseq .
if eseq.sequence.hasactiveflags .
componentmanager.addgeneratedsequence eseq.sequence .
.
return eseq .
.
private executablesequence createnewuniquesequence .
sequence newsequence ... create a sequence .
if newsequence.size geninputsabstract.maxsize .
return null .
.
if this.allsequences.contains newsequence .
return null .
.
return new executablesequence newsequence .
fig.
.
simplified code excerpt from randoop corresponding to the configuration problem reported in figure .
randoop during its development the generated sequences for nanoxml are much longer than usual and using maxsize s default value results in .
of the generated sequences being discarded including sequences that the user wishes to retain .
confdiagnoser captures such abnormal behavior from randoop s silent failure pinpoints the maxsize option and suggests the user to change its value.
the problem is resolved if the user changes maxsize to a larger value for example .
b. diagnosing configuration errors correcting a configuration error can be divided into two separate tasks identifying which specific configuration option is responsible for the unexpected behavior and determining a better value for the configuration option.
this paper addresses the former task finding the root cause of a configuration error.
our technique is designed to be used by system administrators and end users when they encounter an error that they do not know how to fix.
it uses three steps to link the undesired behavior to specific root cause configuration options configuration propagation analysis .
for each configuration option confdiagnoser uses a lightweight dependence analysis called thin slicing to statically identify the predicates it affects in the source code.
configuration behavior profiling .
confdiagnoser selectively instruments the program to diagnose so that it records the run time behaviors of affected predicates in an execution profile.
when the user encounters a suspected configuration error the user reproduces the error using the instrumented version of the program.
configuration deviation analysis .
confdiagnoser selects from a pre built database correct execution profiles that are as similar as possible to the undesired one.
then it identifies the predicates whose dynamic behaviors deviate the most between correct and undesired executions.
the behavioral differences in the recorded predicates provide evidence for what predicates in a program might be be having abnormally and why.
for each deviated predicate confdiagnoser further identifies its affecting configuration options as the likely root causes.
finally it outputs a ranked list of suspicious configuration options and explanations.
an important component in confdiagnoser is the pre built database which contains profiles from known correct executions.
we envision that the software developers build this database at release time.
the database can be further enriched by software users as more correct executions are accumulated.
in our experiments section iv we built a database of execution profiles by running examples from software user manuals faqs discussion mailing list forum posts and published papers.
we found that even such a small database worked remarkably well for error diagnosis.
compared to previous approaches confdiagnoser has several notable features it is fully automated .
confdiagnoser does not require a user to specify when why orhow the program fails.
this is different than many well known automated debugging techniques such as delta debugging information flow analysis and dynamic slicing .
our technique also provides an explanation of why a configuration option is suspicious.
it can diagnose both non crashing and crashing errors .
most previous techniques focus exclusively on configuration errors that cause a crash an error message or a stack trace.
by contrast confdiagnoser diagnoses configuration problems that manifest themselves as either visible or silent failures.
it requires no os level support.
our technique requires no alterations to the jvm or standard library.
this distinguishes our work from competing techniques such as os level configuration error troubleshooting .
c. evaluation we evaluated confdiagnoser on real configuration errors crashing errors and non crashing errors from projects.
on average confdiagnoser s 5th report was the root cause in out of cases the root cause was confdiagnoser s top reports and in over half of all cases the root cause was confdiagnoser s first report.
assuming the database of correct execution profiles already exists confdiagnoser takes less than minutes on average to diagnose one error.
confdiagnoser s accuracy and speed make it an attractive alternative to manual debugging.
we compared confdiagnoser to a previous technique called confanalyzer which uses dynamic information flow analysis to reason about the root cause of a configuration error.
confdiagnoser produced better results for non crashing errors and similar results for crashing errors.
we also compared confdiagnoser to two techniques leveraging existing fault localization techniques to diagnose configuration errors.
confdiagnoser substantially outperformed both of them.
finally we evaluated two internal design choices of confdiagnoser.
first we show that using thin slicing to configuration options program propagation analysis instrument run deviation analysis execution profile affected predicates instrumented program input error report configuration a bad run profile database good runs profile database good runs fig.
.
the workflow of our configuration error diagnosis technique.
propagation analysis is described in section ii b. the instrument and run components correspond to the configuration behavior profiling step in section ii c. deviation analysis is described in section ii d. compute the affected predicates yielded more accurate diagnosis than using full slicing .
second we show that varying the execution profile selection strategy can result in substantially different results.
the similarity based selection strategy used in confdiagnoser outperformed the other two strategies.
d. contributions this paper makes the following contributions technique.
we present a technique to diagnose software configuration errors.
our technique uses static analysis dynamic profiling and statistical analysis to link the undesired behavior to specific configuration options section ii .
implementation.
we implemented our technique in a tool called confdiagnoser for java software section iii .
it is available at evaluation.
we applied confdiagnoser to diagnose configuration errors in configurable java software projects.
the results show the usefulness of the proposed technique section iv .
ii.
t echnique we model a configuration as a set of key value pairs where the keys are strings and the values have arbitrary type.
this abstraction is offered by the posix system environment the java properties api and the windows registry.
a. overview figure sketches the high level workflow of our technique.
our technique takes as input a java program and its configuration options.
it first performs a propagation analysis to identify the affected predicates for each configuration option section ii b .
after that our technique selectively instruments the program at the affected predicates.
to diagnose an error a user runs the instrumented program with the error revealing input and configuration to obtain an execution profile sectionii c .
then our technique analyzes the obtained execution profile to identify the behaviorally deviated predicates and their root causes and reports these to the user section ii d .
b. configuration propagation analysis for each configuration option configuration propagation analysis statically determines its affected predicates .
in our context a predicate is a boolean expression in a conditional or loop statement whose evaluation result determines whether to execute the following statement or not.
a predicate s run time outcome affects the program control flow.
confdiagnoser focuses on identifying and monitoring configurationoption affected control flow rather than the values for two reasons.
first control flow often propagates the majority of configuration related effects and determines a program s execution path while the value of a specific expression may be largely input dependent.
second it simplifies reporting because the outcome of a program predicate can only be either true or false.
nevertheless a program predicate is not the only abstraction our technique can use.
our experiments section iv empirically demonstrate that choosing other abstractions such as monitoring statement level coverage or method level invariants yields less accurate results.
to identify the predicates affected by a configuration option a straightforward way is to use program slicing to compute a forward slice from the initialization statement of a configuration option.
unfortunately traditional full slicing is impractical because it includes too much of the program.
this is due to conservatism for example in handling pointers and to following both data and control dependences.
figure illustrates this problem.
traditional slicing concludes that the predicates in lines and are affected by the configuration option maxsize .
however the predicates in lines and though possibly affected by maxsize are actually irrelevant to maxsize s value.
that is the value of maxsize controls the length of a generated sequence rather than deciding whether a sequence has an active flag line or a sequence has been executed before line .
to address this limitation our technique uses thin slicing which includes only statements that are directly affected by a configuration option.
different from traditional slicing thin slicing focuses on data flow from the seed here a seed is the initialization statement of a configuration option ignoring control flow dependencies as well as uses of base pointers.
thin slicing is attractive because it this property separates pointer computations from the flow of configuration option values and naturally connects a configuration option with its directly affected statements.
for example in the code excerpt of figure a forward thin slice computed for maxsize only includes the predicate in line .
section iv empirically demonstrates that thin slicing is a better choice than traditional full slicing for our purposes.
c. configuration behavior profiling this step instruments the tested program offline by inserting code to record how often each predicate evaluates to true at run time.executing the instrumented program produces an execution profile which consists of a set of predicate profiles .
each predicate profile is a tuple consisting of a configuration option one of its affected predicates the predicate s execution count and how many times it evaluated to true.
for example suppose the predicate on line has been executed times of which times it evaluated to true.
confdiagnoser creates the following predicate profile hmaxsize newsequence.size maxsize 30i.
such predicate profiles are by no means complete in recording the whole execution.
however they capture sufficient information to reason about the causal effects of configurations and how a configuration option relates to software s behavior as shown by our experiments section iv .
collecting these profiles imposes only moderate performance impact.
d. configuration deviation analysis confdiagnoser starts error diagnosis after obtaining the execution profile from an undesired execution.
it selects similar profiles from known correct executions section ii d1 compares each selected profile with the undesired one to identify the most behaviorally deviated predicates section ii d2 and then determines the likely root cause options section ii d3 .
selecting similar execution profiles for comparison confdiagnoser s database contains profiles from known correct executions.
these execution profiles can be dramatically different from another.
to avoid reporting irrelevant differences when determining how and why the observed execution profile behaves differently from the correct ones confdiagnoser first compares the undesired profile with the correct profiles then selects a set of similar ones as the basis of diagnosis.
confdiagnoser first converts each execution profile einto an dimensional vector ve hre1 re2 r eni wherenis the number of predicates affected by configuration options and eachreiis a ratio representing how often the i th predicate profile evaluated to true at run time.
if a predicate has never been executed in an execution confdiagnoser uses as its ratio.
confdiagnoser computes the similarity of two execution profileseandfby computing the cosine similarity from information retrieval of veandvf.
similarity e f cossim ve vf pn i 1rei rfiqpn i 1r2 ei qpn i 1r2 fi this similarity metric compares two execution profiles based on control flow taken approximated by how often each predicate evaluated to true .
its value ranges from meaning completely different predicate behavior to meaning the same predicate behavior and in between values indicating intermediate similarity.
a crashing error sometimes happens soon after the program is launched so the resulting execution profile is much smaller than most correct execution profiles.
to avoid comparing un executed predicates when diagnosing a crashing error confdiagnoser reduces each correct execution profile by only retaining the predicates executed by the crashing profile and then uses the reduced profile for comparison.given an undesired execution profile confdiagnoser selects all execution profiles or the reduced profiles for a crashing error from the database with a similarity value above a threshold default value .
as used in our experiments .
identifying deviated predicates our automated error diagnosis approach compares an undesired execution profile with a set of similar andcorrect execution profiles.
the behavioral differences in the recorded predicates provide evidence for what parts of a program might be incorrect and why.
confdiagnoser characterizes the dynamic behavior of a predicate by how often it was evaluated i.e.
the number of observed executions and how often it evaluated to true i.e.
the true ratio .
the true ratio is more important but it is less dependable the fewer times the predicate has been evaluated.
we define the following metric which combines sensitivity informally the need for multiple observations and specificity informally the true ratio in a standard way by computing their harmonic mean.
e p trueratio e p totalexecnum e p in e p trueratio e p is the ratio of executions of the predicatepthat evaluated to true in e and totalexecnum e p is the the total number of executions of predicate pine.
to smooth corner cases if a predicate pis not executed in e i.e.
totalexecnum e p then e p returns and if a predicate p s true ratio is i.e.
trueratio e p then e p returns totalexecnum e p .
the following deviation metric compares a predicate p across two execution profiles eandf.
a larger deviation value indicates that the behavior is more different.
deviation p e f j e p f p j often trueratio e p totalexecnum e p and then the value of deviation p e f depends primarily on p s true ratio difference between execution profiles eandf.
confdiagnoser computes the deviation value for each predicatepappearing in two execution profiles eandf and ranks them in decreasing order.
the two execution profiles eandf are for the same program so they have exactly the same set of predicates affected by configuration options.
linking predicates to root causes confdiagnoser links the behaviorally deviated predicates to their root cause configuration options by using the results of thin slicing computed by the configuration propagation analysis step in section ii b .
confdiagnoser identifies the affecting configuration options for each deviated predicate and treats the configuration option affecting a higher ranked deviated predicate as the more likely root cause.
if a predicate is affected by multiple configuration options confdiagnoser prefers options whose initialization statements are closer to the deviated predicate in terms of breath first search distance in the dependence graph of thin slicing .
this heuristic is based on the intuition that statements closer to the predicate seem more likely to be relevant to its behavior.
when multiple correct execution profiles are selected for comparison confdiagnoser first produces a ranked list of rootcause configuration options for each comparison pair and then outputs a final list by using majority voting over all ranking lists.
in the final ranking list one configuration option ranks higher than another if it ranks higher in more than half of the ranking lists.
our implementation breaks possible cycles by arbitrarily ranking the involved options but this did not occur in our experiments.
in the final output report e.g.
figure confdiagnoser generates a brief explanation for each behaviorally deviated predicate by showing the difference between the predicate s true ratio during correct executions from the database and during the undesired execution.
e. discussion this paper focuses specifically on configuration errors assuming the application code is correct but the software is inappropriately configured so that it does not behave as desired.
we next discuss some design issues in confdiagnoser.
differences between program inputs and configuration options.
we took the list of configuration options for each subject program from its manual.
typically the manual calls an input a configuration option when it controls a program s control flow rather than producing result data.
a configuration option is often supplied via a command line flag or configuration file.
why not use profiles from unit test executions?
confdiagnoser s database stores correct profiles from complete executions that start at the main method.
confdiagnoser does not use profiles from unit test executions which check the correctness of a single program component and produce an incomplete execution profile that is not representative of the whole program workflow.
why not store profiles from failing executions in the database?
we envision the profile database is built by developers at release time.
it is more natural and easier for a developer to provide correct execution profiles instead of anticipating and enumerating the possible errors a user may encounter.
what if a similar execution profile is not available?
confdiagnoser s effectiveness largely depends on the availability of similar execution profiles from the database.
for a given undesired execution profile lacking a similar profile in confdiagnoser s database may lead confdiagnoser to produce less useful results.
it also indicates inadequacy of the tests from which the database was constructed.
future work should remedy this problem.
one possible approach is to synthesize a new execution either by generating a new input for the program or by mutating an existing execution .
iii.
i mplementation we implemented a tool called confdiagnoser on top of the wala framework .
our tool analyzes java bytecode.
it statically computes the affected predicates for each configuration option assigns a unique id for each affected predicate and then performs offline instrumentation.
the runtime behavior of all affected predicates is recorded in a file.
for a java program confdiagnoser does not analyze the standard jdk library and all the dependent libraries.
we believeprogram version loc config options profiles randoop .
.
weka decision trees .
.
jchord .
synoptic trunk soot .
.
fig.
.
subject programs.
column loc is the number of lines of code as counted by cloc .
column config options is the number of configuration options.
column profiles is the number of execution profiles in the pre built database.
this approximation is reasonable since a configuration option set on client software usually does not affect the behaviors of its dependent libraries.
iv.
e valuation our evaluation answers the following research questions how effective is confdiagnoser in error diagnosis?
confdiagnoser s effectiveness can be reflected by the absolute ranking of the actual root cause in confdiagnoser s output section iv c1 .
the time cost of error diagnosis section iv c2 .
comparison with a previous configuration error diagnosis technique section iv c3 .
comparison with two fault localization techniques section iv c4 .
what are the effects of using full slicing rather than thin slicing to identify the affected predicates?
what are the effects of varying comparison execution profiles?
these are two internal design choices section iv c5 .
a. subject programs we evaluated confdiagnoser on java programs shown in figure .
randoop is an automated test generator for java programs.
weka is a toolkit that implements machine learning algorithms.
our evaluation uses only its decision tree module.
jchord is a program analysis platform that enables users to design implement and evaluate static and dynamic program analyses for java.
synoptic mines a finite state machine model representation of a system from logs.
soot is a java optimization framework for analyzing and transforming java bytecode.
configuration errors we collected configuration errors listed in figure .
this paper evaluates all the configuration errors we found we did not select only errors on which confdiagnoser works well.
the misconfigured values include enumerated types numerical ranges regular expressions and strings.
the non crashing errors are collected from actual bug reports mailing list posts and our own experience.
the crashing errors taken from were previously used to evaluate the confanalyzer tool.
all configuration errors are minimal if any part of the configuration or input is removed the software either crashes or no longer exhibits the undesired behavior.
b. evaluation procedure for each subject program we constructed a profile database by running existing correct examples from its user manual faqs discussion mailing list forum posts and publishederror id.
root cause options program confdiagnoser confanalyzer coverage invariant confdiagnoser program configuration option output analysis analysis w full slicing rank profiles rank rank rank rank rank non crashing errors .
randoop maxsize n x n .
weka m numfolds n x .
jchord chord.datarace.exclude.eqth n x .
synoptic partitionregexp n x n .
soot keep line number n x n n average .
.
.
.
.
.
.
.
.
crashing errors .
jchord chord.main.class .
jchord chord.main.class .
jchord chord.run.analyses .
jchord chord.ctxt.kind .
jchord chord.print.rels .
jchord chord.print.classes .
jchord chord.scope.kind n .
jchord chord.reflect.kind .
jchord chord.class.path n average .
.
.
.
.
.
fig.
.
experimental results in diagnosing software configuration errors.
column root cause configuration option shows the actual root cause configuration option.
column options shows the number of configuration options taken from figure .
column program output shows the rank of the root cause as indicated by the program s output such as an error message.
column confdiagnoser shows the results of using our technique.
column profiles shows the number of similar execution profiles selected from the pre built database for comparison and the number of executions in the database.
for each technique column rank shows the absolute rank of the actual root cause in its output lower is better .
x means the technique is not applicable i.e.
requiring a crashing point and n means the technique does not identify the actual root cause.
when computing the average rank each x or n is treated as half of the number of configuration options because a user would need to examine on average half of the options to find the root cause.
column confanalyzer shows the results of using a previous technique section iv c the data in this column is taken from .
columns coverage analysis and invariant analysis show the results of using two fault localization techniques as described in section iv c .
column confdiagnoser w full slicing shows the results of using full slicing to compute the affected predicates section iv c5 .
error id program description non crashing errors randoop no tests generated weka low accuracy of the decision tree jchord no datarace reported for a racy program synoptic generate an incorrect model soot source code line number is missing crashing errors jchord no main class is specified jchord no main method in the specified class jchord running a nonexistent analysis jchord invalid context sensitive analysis name jchord printing nonexistent relations jchord disassembling nonexistent classes jchord invalid scope kind jchord invalid reflection kind jchord wrong classpath fig.
.
the configuration errors used in the evaluation.
papers .
we spent hours per program on average and obtained execution profiles.
the average size of the profile database is 35mb and the largest one randoop s database is 72mb.
we made a simple syntactic change to jchord which affected lines of code.
this change does not modify jchord s semantics rather it just encapsulates scattered configuration option initialization statements as static class fields which simplifies specifying the seed statement in performing slicing.
when diagnosing a configuration error we first reproduced the error on a confdiagnoser instrumented program to obtain the execution profile.
then we ran confdiagnoser on theobtained execution profile to identify its root causes.
our experiments were run on a .67ghz intel core pc with 4gb physical memory 2gb was allocated for the jvm running windows .
c. results accuracy in diagnosing configuration errors as shown in figure confdiagnoser is highly effective in pinpointing the root cause of misconfigurations.
for all non crashing errors and of the crashing errors it lists the actual root cause as one of the top options.
a non crashing configuration errors.
confdiagnoser is particularly effective in diagnosing non crashing configuration errors which are not supported by most other tools.
the average rank of the root cause in confdiagnoser s output is .
.
the primary reason is confdiagnoser s ability to identify the behaviorally deviated predicates through execution profile comparison.
the top ranked deviated predicates often provide useful clues about what parts of a program might be abnormal and why.
we use the non crashing error in weka as an example to illustrate this point.
weka s decision tree implementation is highly tuned achieving accuracy on its included examples.
however its accuracy drops to on a different dataset we experimented on.
we used confdiagnoser to diagnose this problem by first building a database by running weka on its examples and then obtaining the undesired execution profile by running it on our dataset.
as a result confdiagnoser outputs the following report only the top option is shown suspicious configuration option m numfolds it affects the behavior of predicate numfold numinstances numfolds line class weka.core.instances this predicate evaluates to true of the time in normal runs observations of the time in the undesired run observations the above report reveals an important fact about the low accuracy.
the predicate numfold numinstances numfolds controls the depth of a decision tree.
its true ratio is substantially higher in the undesired execution than in normal executions.
a higher true ratio leads to a deeper tree that is more likely to overfit the training data and yield low accuracy on the testing data.
to resolve this problem we changed m numfolds value from to to reduce the tree depth and gained a performance increase.
b crashing configuration errors.
crashing errors are often easy for a user to diagnose.
this is because a crashing error often produces a stack trace or error message with valuable diagnosis clues.
in fact for the crashing errors selected by the confanalyzer authors the user is always led to the root cause by the program output without the need for further analysis.
for error jchord throws a noclassdeffounderror when loading a user specified class.
this error reminds the user that a non existent class might be provided.
for error jchord outputs an error message of could not find main class or main method in that class that explicitly informs the user that the configuration option to specify a main class might be wrong.
for errors jchord outputs the relevant configuration option in its error message.
for error jchord throws a classnotfoundexception for the main class that reminds the user to check the classpath setting.
confdiagnoser is more effective in diagnosing non crashing errors average rank .
than crashing errors average rank .
.
most of the crashing errors occur soon after the program is launched so confdiagnoser lacks enough predicate behavior observations.
many predicates are only executed once so their deviation scores section ii d2 turn out to be the same and the bfs distance based heuristic to resolve ties section ii d3 only works half the time.
performance of confdiagnoser we measured confdiagnoser s performance in two ways the time cost in diagnosing an error and the overhead introduced in reproducing an error in a confdiagnoser instrumented program.
as shown in figure the performance of confdiagnoser is reasonable.
on average it uses less than minutes to diagnose each configuration error including the time to compute thin slices and the time to recommend suspicious configuration options .
computing thin slices for all configuration options is expensive.
however this step is one time effort per program and the computed slices can be cached to share across diagnoses.
the performance overhead to reproduce the buggy behavior varies among applications.
the current tool implementation imposes a substantial slowdown when reproducing errors and in a confdiagnoser instrumented version.
this iserror id.
run time confdiagnoser time seconds program slowdown thin slicing error diagnosis non crashing errors .
randoop .
.
weka .
.
jchord .
.
synoptic .
.
soot .
mean .
crashing errors .
jchord .
.
jchord .
.
jchord .
.
jchord .
.
jchord .
.
jchord .
.
jchord .
.
jchord .
.
jchord .
mean .
fig.
.
confdiagnoser s performance.
the run time slowdown column shows the cost of reproducing the error in an instrumented version of the subject program and the mean is the geometric mean.
the confdiagnoser time has been divided into two parts computing thin slices and diagnosing an error and the mean is the arithmetic mean.
due to confdiagnoser s naive inefficient instrumentation code which we have made no effort to optimize.
even so an error can be reproduced in less than minutes on average with a worst case of minutes.
comparison with a previous technique we compared confdiagnoser with confanalyzer a dynamic information flow based technique .
we chose confanalyzer because it is the most recent technique and also one of the most precise configuration error diagnosis techniques in the literature.
confanalyzer tracks the flow of labeled objects through the program dynamically and treats a configuration option as a root cause if its value may flow to a crashing point.
confanalyzer works well for most of the crashing errors all of which are from the confanalyzer paper though as described above these are easy to diagnose even without tool support.
however confanalyzer cannot diagnose non crashing errors.
the experimental results of confanalyzer are shown in figure column confanalyzer .
for the crashing errors confdiagnoser produced better results for of them the same results for another and worse results for the remaining .
confanalyzer performs best on the easiest crashing errors those having short execution paths when an error exhibits almost immediately after the software is launched.
in such cases only a small number of configuration options are initialized and few of them can flow to the crashing point.
confdiagnoser fails to produce a good diagnosis for these errors because it can not identify the statistically behaviorally deviated predicates based on the limited observation of program behaviors.
confanalyzer outputs less accurate or no results for errors where the root cause option value flows into containers or system calls e.g.
error in figure .
confdiagnoser can reason to some extent about the consequence of such a misconfiguration based on the observed predicate behaviors.
comparison with two fault localization techniques another possible way to diagnose a configuration error is to leverage existing fault localization techniques by treating the undesired execution as a failing run and all correct executions in the database as passing runs.
we next compare confdiagnoser with two state of the art techniques statement level coverage analysis .
this technique treats statements covered by the undesired execution profile as potentially buggy and statements covered the correct execution profiles as correct.
then it leverages a well known fault localization technique tarantula to rank the likelihood of each statement being buggy and queries the results of thin slicing to identify its affecting configuration options as the root causes.
the results are essentially the same for a variant of coverage analysis using thin slicing to compute all affected statements and only monitoring the coverage of such affected statements.
method level invariant analysis .
this technique stores invariants detected by daikon from correct executions in the database.
it treats a method as having suspicious behavior if its observed invariants from the undesired execution are different from the invariants stored in the database .
this technique ranks a method s suspiciousness by the number of different invariants and queries the results of thin slicing to identify its affecting configuration options as the root causes.
in coverage analysis the statement level granularity is too fine grained .
many statements have exactly the same coverage in the failing passing executions and thus have the same suspiciousness score as computed by tarantula .
furthermore tarantula only records whether a statement has been executed or not but does not record how a statement is executed e.g.
how often a predicate evaluates to true .
the combination of these two factors causes the low accuracy.
in invariant analysis the method level granularity is too coarse grained .
invariant detection techniques like daikon only check program states at method entries and exits to infer likely pre and post conditions and thus are less sensitive to control flow details within a method e.g.
a predicate s true ratio .
in our study invariant analysis failed to diagnose errors.
for synoptic it failed to infer invariants.
for soot and randoop it reported the same invariants over undesired and correct executions for the method containing behaviorallydeviated predicates.
this experiment suggests that we cannot treat configuration options as just another regular program input and then directly apply existing fault localization techniques to find the error causes.
the primary reason is that unlike a program input a configuration option is often used to control a program s control rather than produce result data.
thus focusing on the behaviors of relevant predicates as our tool does may be a good choice.
evaluation of two design choices in confdiagnoser we investigate the effects of using traditional full slicing rather than thin slicing in the configuration propagation analysis steperror id.
rank of the actual root cause program all profiles random selection similarity based non crashing errors .
randoop .
weka .
jchord .
synoptic .
soot average .
.
.
crashing errors .
jchord .
jchord .
jchord .
jchord .
jchord .
jchord .
jchord .
jchord .
jchord average .
.
.
fig.
.
comparison with different execution profile selection strategies section iv c .
the last column similarity based is the selection strategy used in confdiagnoser and the data in that column is taken from figure .
section ii b to compute the affected predicates.
figure column full slicing shows the results.
varying the comparison execution profiles from the pre built database.
in particular we compare the similarity based selection strategy used in confdiagnoser section ii d1 with two alternatives selecting all available profiles in the database and randomly selecting the same number of profiles as confdiagnoser uses from the database.
figure shows the results.
for random selection we performed the experiment times and report the average.
as shown in figure column full slicing confdiagnoser achieves substantially less accurate results when using full slicing.
the primary reason is that full slicing includes too many irrelevant statements that are only indirectly affected by a configuration option value but not pertinent to the task of error diagnosis.
in many cases monitoring the control flow of such indirectly affected predicates and then linking their behaviors to configuration options leads to low accuracy.
furthermore performing full slicing is much more expensive than thin slicing in our experiments the full slicing algorithm ran out of memory on soot.
as shown in figure varying the selection strategy for correct traces can affect the results depending on the application being analyzed.
using all available execution profiles or randomly selecting execution profiles is less effective because they make confdiagnoser report many irrelevant differences between an undesired execution and a dramatically different execution.
when diagnosing a crashing error confdiagnoser is less sensitive to the comparison execution profiles.
this is because crashing profiles are often much smaller executing fewer predicates before reaching the crashing points and confdiagnoser reduces each correct execution profile before diagnosis section ii d1 .
thus many irrelevant differences have already been removed.because the trace selection strategy improved the accuracy of confdiagnoser we tried applying it to coverage analysis and invariant analysis as well.
that is we supplied those analyses not with the full database of good runs but with the runs most similar to the bad run.
this approach degraded the accuracy of the other tools beyond the results shown in figure even though it helped confdiagnoser.
the reason is that the suspiciousness of a statement or method is inversely proportional to the number of correct execution profiles that cover it.
when using fewer correct execution profiles more statements or methods have the same suspiciousness scores.
d. experimental discussion limitations.
the experiments indicate several limitations of our technique.
first we only focus on named configuration options with a common key value semantic and our implementation and experiments are restricted to java.
second we evaluated confdiagnoser on configuration errors involving just one mis configured option.
third our implementation currently does not support debugging non deterministic errors.
for non deterministic errors confdiagnoser could potentially leverage a deterministic replay system that can capture an undesired non deterministic execution and faithfully reproduce it for later analysis.
fourth confdiagnoser s effectiveness largely depends on the availability of a similar but correct execution profile.
using an arbitrary execution profile as we demonstrated in section iv c by random selection may significantly affect the results.
threats to validity.
there are three major threats to validity in our evaluation.
first the programs and the configuration errors may not be representative.
thus we can not claim the results can be generalized to an arbitrary program.
for example we did not evaluate confdiagnoser to diagnose misconfigurations that cause poor performance.
second in this paper we focus specifically on configuration errors assuming the application code is correct.
furthermore in our experiments all errors have been minimized as end users often do when reporting an error .
confdiagnoser might produce different error diagnosis results on buggy application code with non minimized inputs.
a user who did not know whether a program was misbehaving due to a bug in the code or an incorrect configuration option would need to apply multiple debugging techniques.
we have not yet formulated guidance regarding when the user should give up on confdiagnoser and assume the error is not related to a configuration option.
third we only compared two dependence analyses thin slicing and full slicing three abstraction granularities at the predicate level statement level and method level and three other tools confanalyzer coverage analysis and invariant analysis in our evaluation.
using other dependence analyses abstraction levels or tools might achieve different results.
experimental conclusions.
we have three chief findings confdiagnoser is effective in diagnosing both crashing and non crashing configuration errors with a small profile database.
confdiagnoser produces more accurate diagnosis than approaches leveraging existing fault localization techniques .
thin slicing and selection of similar comparison traces permit confdiagnoser to produce more accurate diagnosis than other approaches.
v. r elated work this section discusses closely related work on software configuration error diagnosis automated debugging and configuration aware software analysis techniques.
software configuration error diagnosis.
software configuration error diagnosis is recognized as an important research problem .
chronus relies on a user provided testing oracle to check the behavior of the system and uses virtual machine checkpoint and binary search to find the point in time where the program behavior switched from correct to incorrect.
autobash fixes a misconfiguration by using os level speculative execution to try possible configurations examine their effects and roll them back when necessary.
peerpressure uses statistical methods to compare configuration states in the windows registry on different machines.
when a registry entry value on a machine exhibiting erroneous behavior differs from the value usually chosen by other machines peerpressure flags the value as a potential error.
more recently confaid uses dynamic taint analysis to diagnose configuration problems by monitoring causality within the program binary as it executes.
confanalyzer uses dynamic information flow analysis to precompute possible configuration error diagnoses for every possible crashing point in a program.
our technique is significantly different from the other approaches.
first most previous approaches focus exclusively on configuration errors that lead to a crash or assertion failure .
by contrast our technique can diagnose both crashing andnon crashing errors.
second several approaches assume the existence of a testing oracle that can check whether the software functions correctly.
however such oracles are often absent in practice or may not apply to the specific configuration problem.
a typical software user should not be expected to invest the substantial time and effort to create an oracle.
by contrast our technique eliminates this assumption.
third approaches like peerpressure benefit from the known schema of the windows registry but cannot detect configuration errors that lie outside the registry.
our technique of analyzing the affected predicate behavior is more general.
automated debugging techniques.
program slicing and taint analysis are two well known techniques to determine which statements and inputs could affect a particular variable.
despite their effectiveness in diagnosing a crashing configuration error by performing backward reachability analysis from the crashing point these two techniques cannot be directly applied to diagnose a non crashing error.
delta debugging is a general algorithm to isolate software error causes.
it reduces differences between a working state and a broken state to isolate a set of failure inducing changes.
when using delta debugging the user must provide a single nearby working state and a testing oracle to checkwhether an intermediate program state behaves correctly both of which are difficult tasks.
furthermore as a minimization technique delta debugging is not applicable to data i.e.
configuration option values that are missing nor ones that are incorrect.
by contrast confdiagnoser eliminates these assumptions by comparing the undesired execution profile with correct execution profiles and then identifying the root cause configuration options to account for the behavioral difference.
statistical algorithms have been applied to the automated debugging domain.
the cbi project analyzes executions collected from deployed software to isolate software failure causes.
significantly different than confdiagnoser cbi correlates a predicate s evaluation result either true or false rather than its true ratio and execution frequency with the observed behaviors.
in addition cbi identifies likely buggy statements as its final output while confdiagnoser identifies the behaviorallydeviated program predicates and links the undesired behavior to specific configuration options.
configuration aware software analysis and testing.
empirical studies show that configuration errors are pervasive costly and time consuming to diagnose .
to alleviate this problem researchers have designed various software analysis techniques to understand and test the behavior of a configurable software system .
compared to confdiagnoser those techniques can be used to find new errors in a configurable software system earlier but cannot identify the root cause of a revealed configuration error.
by contrast our technique is designed to diagnose an exhibited error.
vi.
c onclusion and future work this paper presented a practical technique and its tool implementation called confdiagnoser for diagnosing configuration errors.
our experimental results show that confdiagnoser is effective in diagnosing both crashing and non crashing configuration errors and it does so with a small profile database.
the source code of confdiagnoser is publicly available at future work should address the following topics user study.
we plan a user study to evaluate confdiagnoser s usefulness to system administrators and end users.
a challenge will be finding study participants who are familiar with our subject programs.
fixing configuration errors.
after a configuration error is localized fixing it is often non trivial.
thus we plan to apply automated error patching and software self adaptation techniques to fix configuration errors.
improving configuration error reporting.
a high quality error report allows software developers to understand and correct the problems they receive.
unfortunately the quality of error reports often decreases as software becomes more complex and configurable.
we plan to develop new error reporting mechanisms to make configuration errors more diagnosable.