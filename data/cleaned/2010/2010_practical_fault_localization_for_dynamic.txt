practical fault localization for dynamic web applications shay artzi julian dolby frank tip marco pistoia ibm t.j. watson research center p .o.
box y orktown heights ny usa artzi dolby ftip pistoia us.ibm.com abstract we leverage combined concrete and symbolic execution and several fault localization techniques to create a uniquely powerful tool for localizing faults in php applications.
the tool automatically generates tests that expose failures and then automatically localizes the faults responsible for those failures thus overcoming the limitation of previous fault localization techniques that a test suite be available upfront.
the fault localization techniques we employ combine variations on the tarantula algorithm with a technique based on maintaining a mapping between statements and the fragments of output they produce.
we implemented these techniques in a tool called apollo and evaluated them by localizing randomly selected faults that were exposed by automatically generated tests in four php applications.
our findings indicate that using our best technique .
of the faults under consideration are localized to within of all executed statements which constitutes an almost five fold improvement over the tarantula algorithm.
categories and subject descriptors d. .
software program verification d. .
testing and debugging general terms reliability verification .
introduction web applications are typically written in a combination of several programming languages such as javascript on the client side and php with embedded sql commands on the server side.
such applications generate structured output in the form of dynamically generated html pages that may refer to additional scripts to be executed.
as with any program programmers make mistakes and introduce faults resulting in web application crashes and malformed dynamically generated html pages.
while malformed html errors may seem trivial and indeed many of them are at worst minor annoyances they have on occasion been known to enable serious permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.attacks such as denial of service1.
we present the first fully automatic tool that finds and localizes malformed html errors in web applications that execute php code on the server side.
in previous work we adapted the well established technique of combined concrete and symbolic execution to web applications written in php.
with this approach an application is first executed on an empty input and a path condition is recorded that reflects the application s control flow predicates that have been executed that depend on input.
then by changing one of the predicates in the path condition and solving the resulting condition new inputs can be obtained and executing the program on these inputs will result in additional control flow paths being exercised.
in each execution faults that are observed during the execution are recorded.
this process is repeated until either su fficient coverage of the statements in the application has been achieved a sufficient number of faults has been detected or the time budget is exhausted.
our previous work addresses a number of issues specific to the domain of php applications that generate html output.
in particular i it integrates an html validator to check for errors that manifest themselves by the generation of malformed html ii it automatically simulates interactive user input and iii it keeps track of the interactive session state that is shared between multiple php scripts.
we implemented these techniques in a tool called apollo .
in previous experiments on open source php applications apollo found a total of faults .
a problem not addressed by our previous work is that it fails to pinpoint the specific web application instructions that cause execution errors or the generation of malformed html code.
without that information correcting these types of issues can be very di fficult.
this paper addresses the problem of determining where in the source code changes need to be made in order to fix the detected failures.
this task is commonly referred to as fault localization and has been studied extensively in the literature .
our use of combined concrete and symbolic execution to obtain passing and failing runs overcomes the limitation of many existing fault localization techniques that a test suite with passing and failing runs be available upfront.
the fault localization techniques explored in this paper combine variations on the tarantula algorithm by jones et al.
with the use of an output mapping.
the first main ingredient of our combined approach is the tarantulaalgorithm by jones et al.
which predicts statements that are likely to be responsible for failures.
it does so by computing for each statement the percentages of passing and failing tests that execute that statement.
from this a suspiciousness rating is computed for each executed statement.
programmers are encouraged to examine the statements in order of decreasing suspicious1for example .ness.
this has proved to be quite e ffective in experiments with the siemens suite consisting of versions of small c programs into which artificial faults have been seeded .
a variation on the basic tarantula approach that we consider is an enhanced domain for conditional statements which enables us to more accurately pinpoint errors due to missing branches in conditional statements.
the second main ingredient of our approach is the use of an output mapping from statements in the program to the fragments of output they produce.
this mapping when combined with the report of the html validator which indicates the parts of the program output that are incorrect provides an additional source of information about possible fault locations and is used to fine tune the suspiciousness ratings provided by tarantula .
we implemented several fault localization techniques that combine variations on tarantula with the use of the output mapping inapollo making apollo a fully automated tool for failure detection and fault localization for web applications written in php.
we then investigated apollo s ability to localize randomly selected faults that were exposed by automatically generated tests in open source php applications.
using the basic tarantula technique the programmer had to examine an average of .
of an application s executed statements to find each of the faults when exploring the executed statements in order of decreasing suspiciousness.
using our best technique which augments the domain of tarantula for conditional statements and uses the output mapping to fine tune tarantula s suspiciousness ratings the programmer needs to explore only .
of the executed statements on average.
more significantly using our best technique .
of the faults under consideration are localized to within of all executed statements which constitutes an almost five fold improvement over the .
for the basic tarantula algorithm.
to summarize the contributions of this paper are as follows .
we present an approach for fault localization that uses combined concrete and symbolic execution to generate a suite of passing and failing tests.
this overcomes the limitation of previous methods by not requiring the upfront availability of a test suite.
.
we demonstrate that automated techniques for fault localization which were previously only evaluated on programs with artificially seeded faults is e ffective at localizing real faults in open source php applications.
.
we present fault localization techniques that combine variations on the tarantula algorithm with the use of an output mapping from statements to the fragments of program output that they produce.
.
we implemented these techniques in apollo an automated tool for detecting failures and localizing faults in php.
.
we used apollo to localize randomly selected faults in php applications and compared the e ffectiveness of the fault localization techniques.
our findings show that using our best technique .
of the faults are localized to within of all executed statements which constitutes an almost five fold improvement over the tarantula algorithm.
.
php web applications php is a widely used scripting language for implementing web applications in part due to its rich library support for network interaction http processing and database access.
a typical php web application is a client server program in which data and control flow interactively between a server which runs php scripts and a client which is a web browser.
the php scripts generate html code which gets pushed to the client.
such code oftenincludes forms that invoke other php scripts and pass them a combination of user input and constant values taken from the generated html.
.
the php scripting language php is object oriented in the sense that it has classes interfaces and dynamically dispatched methods with syntax and semantics similar to those of java.
php also has features of scripting languages such as dynamic typing and an eval construct that interprets and executes a string value that was computed at run time as a code fragment.
for example the following code fragment code x x eval code echo x prints the value3.
other examples of the dynamic nature of php are the presence of the isset function which checks whether a variable has been defined and the fact that statements defining classes and functions may occur anywhere.
the code in figure illustrates the flavor of a php web application and the difficulty in localizing faults.
as can be seen the code is an ad hoc mixture of php statements and html fragments.
the php code is delimited by ?php and?
tokens.
the use of html in the middle of php indicates that html is generated as if it occurred in aprint statement.
therequire statements resemble the c include directive by causing the inclusion of code from another source file.
however while include in c is a preprocessor directive that assumes a constant argument require in php is an ordinary statement in which the filename is computed at run time for example the arguments of the require statements in line of the php script of figure c and in line of the php script of figure d .
are dynamically computed at run time based on the output of thedirname function which returns the directory component of a filename.
similarly switch labels in php need not be constant but unlike in other languages can be dynamically determined at run time.
this degree of flexibility is prized by php developers for enabling rapid application prototyping and development.
however the flexibility can make the overall structure of program hard to discern and render programs prone to code quality problems that are difficult to localize.
.
failures in php programs our technique targets two types of failures that may occur during the execution of php web applications and that can be automatically detected execution failures.
these are caused by missing included files incorrect sql queries and uncaught exceptions.
such failures are easily identified since the php interpreter generates an error message and halts execution.
less serious execution failures such as those caused by the use of deprecated language constructs produce obtrusive error messages but do not halt execution.
html failures.
these involve situations in which generated html code is not syntactically correct causing them to be rendered incorrectly in certain browsers.
this may not only lead to portability problems but also decrease performance since the resulting pages may render slower when browsers attempt to compensate for the malformed html code.
.
fault localization detecting failures only demonstrates that a fault exists the next step is to find the location of the fault that causes each failure.
there are at least two pieces of information that might help html head title login title head body form method post name login action login.php 5user name input type text name user br 6password input type password name pw br input type submit value submit name submit form body html ?php usertag user pwtag pw typetag type topictag topic authtag auth 7function check password user pw authentication code... ?
a index.php b constants.php html head title topic selection page title head body ?php 5session start 6require dirname file .
includes constants.php user request pw request session false 10if check password user pw ?
form action view.php 13topic input type text name topic br input type submit value submit name submit form body ?php session user session pw session true 21if user admin session admin else session regularuser ?
html html head title topic view title head ?php 5session start 6require dirname file .
includes constants.php 7print body n 8if session type session topic request 11if type admin 12print h1 administrative else 14print h1 normal 16print view of topic .
request .
h1 n 17if type admin 18print h2 administrative details n code to print administrative details... else 21print h2 details h2 n code to print normal details... 25print body n ?
html c login.php d view.php figure sample php web application .
for html failures html validators provide the problematic locations in the html code.
malformed html fragments can then be correlated with the portions of the php scripts that produced them.
.
for both kinds of failures one could look at runs that do not exhibit the error and record what set of statements such runs execute.
comparing that set of statements with the set of statements executed by the failing runs can then provide clues that can help localizing the fault.
the extensive literature on faultlocalization algorithms that exploit such information is discussed in section .
.
motivating example figure shows an example of a php application that is designed to illustrate the particular complexities of finding and localizing faults in php web applications.
the top level index.php script in figure a contains static html code.
the login.php script in figure c attempts to authenticate the user.
the view.php script in figure d is for data display.
the two php scripts login.php andview.php rely on a sharedconstants.php include file shown in figure b this file defines some standard constants and an authentication function.
these fragments are part of the client server work flow in a web application the user first sees the index.php page of figure a and enters the required credentials.
the user input credentials are processed by thelogin.php script in figure c .
this script generates a response page that allows the user to enter further input causing further processing by the view.php script in figure d .
note that the user name and password that are entered by the user during the execution of login.php are stored in special locations session and session respectively.
moreover if the user is the administrator this fact is recorded in session .
this illustrates how php handles session state which is data that persists from one page to another to keep track of the interactions with the application by a particular user.
thus the updates to session in figure c will be seen by the code in figure d when the user follows the link to view.php in the html page that is returned by login.php .
theview.php script uses this session information in line to verify the username and password provided by the user.
our sample program contains an error in the html code it produces theh2tag opened in line of figure d is never closed.
while this fault itself is trivial localizing its cause is not.
an ordinary tester would likely start executing this application by entering credentials into the script in figure c .
the tester must then discover that setting user to the valueadmin results in the selection of a different branch that records the user type typetag asadmin in the session state as shown in lines of login.php .
after that the tester would have to enter a topic in the form generated by thelogin.php script and would then proceed to execute the code in figure d with the appropriate session state which will finally generate the html code exhibiting the fault as shown in figure a .
thus finding the fault requires careful selection of inputs to a series of interactive scripts and tracking updates to the session state during the execution of those scripts.
the next step is to determine the cause of the malformed html.
consider the two sources of information suggested in section .
.
our validator produces the output shown in figure c for this fault indicating that lines and in the malformed html of1 html head topic view head body h1 administrative view of topic a h1 ... h2 administrative details ... body html html line php lines in d a html output b output mapping error at line character end tag for h2 omitted possible causes include a missing end tag improper nesting of elements or use of an element where it is not allowed line character start tag was here c output of wdg validator figure a html produced by the script of figure d b output mapping constructed during execution c part of output of wdg validator on the html of figure a figure a are associated with the html failure.
these lines correspond to theh2heading and the following body tags respectively.
by correlating this information with the output mapping shown in figure b we can determine that lines and inview.php produced these lines of output.
.
the second source of information is obtained by comparing the statements executed in passing and failing runs.
the html failure only occurs when the value of type isadmin .
thus the difference between passing and failing runs consists of all code that is guarded by the two conditionals in lines and inview.php .
we can conclude that the statements in lines and are suspect.
neither of these estimates is precise because the fault is clearly the omission of the printing of an h2tag in line .
we can however combine the results of the validator and the sets of statements executed in passing and failing runs.
specifically we could observe that the printing of body in line inview.php occurs in both passing and failing executions and is therefore unlikely to be the location of the fault.
furthermore we can observe that lines and each of which is only executed in one of the executions are not associated with the failure according to the information we received from the oracle.
therefore we can conclude that the fault is most closely associated with line in view.php .
another thing to observe about the php web application in figure is that thelogin.php script in figure c has an ifstatement in line for which there is no matching else branch.
this implies that thebody tag is closed in line only if the authentication check of line succeeds if that check fails the body tag will never be closed giving rise to a malformed html page.
this problem may not be discovered during testing since it manifests itself only if invalid authentication credentials are provided.
furthermore since the code that should close the body tag is missing there is no line that is only executed by a failing run and the tarantula fault localization technique will fail to pinpoint the exact program point responsible for the malformed html code.
this paper introduces a novel condition modeling technique to address such errors by omission .
in section .
we will discuss condition modeling and its applicability to the example of figure .
note that due to the necessarily small size of this example the html errors it contains are localized and could likely be found with grep or a similar tool however in more complex applications we encounter html errors that combine html generated by multiple statements that are not all in one place.
.
combined concrete and symbolic execution our technique for finding failures in php applications is a variation on combined concrete and symbolic execution a well established test generation technique.
the basic ideabehind this technique is to execute an application on some initial e.g.
empty or randomly chosen input and then on additional inputs obtained by solving constraints derived from exercised control flow paths.
failures that occur during these executions are reported to the user.
in a previous paper we described how this technique can be adapted to the domain of dynamic web applications written in php.
our apollo tool takes into account language constructs that are specific to php uses an oracle to validate the output and supports database interaction.
in we extended the work to address interactive user input described in section php applications typically generate html pages that contain user interface features such as buttons that when selected by the user result in the execution of additional php scripts.
modeling such user input is important because coverage of the application will typically remain very low otherwise.
apollo tracks the state of the environment and automatically discovers additional scripts that the user may invoke based on an analysis of available user options.
this is important because a script is much more likely to perform complex behavior when executed in the correct context environment .
for example if a web application does not record in the environment that a user is logged in most scripts will present only vanilla information and terminate quickly e.g.
when the condition in line of figure d is false .
the inputs to apollo s algorithm are a program pcomposed of any number of executable components php scripts the initial state of the environment before executing any component e.g database a set of executable components reachable from the initial statec and an output oracle o. the output of the algorithm is a set of bug reports bfor the programp according too.
each bug report contains the identification information of the failure message and generating program part and the set of tests exposing the failure.
the algorithm uses a queue of tests2.
each test is comprised of three components i the program component to execute ii a path constraint which is a conjunction of conditions on the program s input parameters and iii the environment state before the execution.
the queue is initialized with one test for each of the components executable from the initial state and the empty path constraint.
the algorithm then processes each element of this queue as follows .
using a constraint solver to find a concrete input that satisfies a path constraint from the selected test.
.
restoring the environment state then executing the program component on the input and checking for failures.
detected failures are merged into the corresponding bug reports.
the program is also executed symbolically on the same input.
the result of symbolic execution is a path constraint logicalandtextn i 1ci which 2the criteria of selecting tests from the queue prefers tests that will cover additional code.
more details can be found in .is satisfied if the given path is executed here the path constraint reflects the path that was just executed .
.
creating new test inputs by solving modified versions of the path constraint as follows for each prefix of the path constraint the algorithm negates the last conjunct.
a solution if it exists to such an alternative path constraint corresponds to an input that will execute the program along a prefix of the original execution path and then take the opposite branch.
.
analyzing the output to find new transitions referenced scripts and parameter values from the new environment state.
each transition is expressed as a pair of path constraints and an executable component.
.
adding new tests for each transition not explored before.
for instance an execution of login.phpthat did not define user would generate a path constraint noting that user is not set i.e.
!isset user .
a subsequent execution could be constructed by negating this constraint to isset user .
an execution satisfying this new constraint will define user to some value.
.
fault localization in this section we first review the tarantula fault localization technique.
we then present an alternative technique that is based on the output mapping and positional information obtained from an oracle.
next a technique is presented that combines the former with the latter.
finally we discuss how the use of an extended domain for conditional expressions can help improve tarantula s effectiveness.
.
tarantula jones et al.
presented tarantula a fault localization technique that associates with each statement a suspiciousness ratingthat indicates the likelihood for that statement to contribute to a failure.
the suspiciousness rating star l for a statement that occurs at line3lis a number between and defined as follows star l failed l totalfailed passed l totalpassed failed l totalfailed where passed l is the number of passing executions that execute statement l failed l is the number of failing executions that execute statement l totalpassed is the total number of passing test cases and totalfailed is the total number of failing test cases.
after suspiciousness ratings have been computed each of the executed statements is assigned a rank in the order of decreasing suspiciousness.
ranks need not be unique the rank of the statement l reflects the maximum number of statements that would have to be examined if statements are examined in order of decreasing suspiciousness and if lwere the last statement of that particular suspiciousness level chosen for examination.
jones and harrold conducted a detailed empirical evaluation in which they apply tarantula to faulty versions of the siemens suite and compare its e ffectiveness to that of several other fault localization techniques see section .
the siemens suite consists of several versions of small c programs into which faults have been seeded artificially.
since the location of those faults is given one can evaluate the e ffectiveness of a fault localization technique by measuring its ability to identify those faults.
in the fault localization literature this is customarily done by reporting the percentage of the program that needs to be examined by the programmer assuming that statements are inspected in decreasing order of suspiciousness .
3we use line numbers to identify statements which enables us to present different fault localization techniques in a uniform manner.more specifically jones and harrold compute for each failingtest run a score in the range of that indicates the percentage of the application s executable statements that the programmer need not examine in order to find the fault.
this score is computed by determining a set of examined statements that initially contains only the statement s at rank .
then iteratively statements at the next higher rank are added to this set until at least one of the faulty statements is included.
the score is now computed by dividing the number of statements in the set by the total number of executed statements.
using this approach jones and harrold found that .
of the failing test runs were scored in the range meaning that for this percentage of the failing tests the programmer needs to examine less than of the program s executed statements to find the fault.
they also report that for an additional .
of the failing tests the programmer needs to inspect less than of the executed statements.
.
fault localization using output mapping an oracle that determines whether or not a failure occurs can often provide precise information about the parts of the output that are associated with that failure.
for instance given an html page an html validator will typically report the locations in the corresponding html code where the code is syntactically incorrect.
such information can be used as a heuristic to localize faults in the program provided that it is possible to determine which portions of the program produced the faulty portions of the output.
the basic idea is that the code that produced the erroneous output is a good place to start looking for the causative fault.
this is formalized as follows.
assume we have the following two functions o f returns output line numbers reported by the oracle ofor failure f and p o returns the set of program parts of the source program responsible for output line o given these two functions we define a suspiciousness rating smap l of the statement at line lfor failure fas follows smap l braceleftbigg if l uniontext o o f p o otherwise note that this is a binary rating program parts are either highly suspicious or not suspicious at all.
this output mapping depends on an oracle that can provide a good mapping of an error to the location that generated it the html validator is a good example of such an oracle but in general not all errors will have such an oracle available.
thus we combine this approach with others to handle the full range of errors.
.
tarantula with output mapping thetarantula algorithm presented in section .
localizes failures based on how often statements are executed in failing and passing executions.
however in the web application domain a significant number of lines are executed in both cases or only in failing executions.
the fault localization technique presented in section .
can be used to enhance the tarantula results by giving a higher rank to statements that are blamed by both tarantula and the mapping technique.
more formally we define a new suspiciousness rating scomb l for the statement at line las follows scomb l braceleftbigg .
if smap l star l .
star s otherwise informally we give the suspiciousness rating .
to any statement that is identified as highly suspicious by the oracle and for whichline s executed by star l smap l scomb l both .
.
.
failing only .
.
.
passing only .
.
.
both .
.
.
failing only .
.
.
passing only .
.
.
both .
.
.
figure suspiciousness ratings for lines in the php script of figure d according to three techniques.
the columns of the table show for each line l when it is executed in the passing run in the failing run or in both runs and the suspiciousness ratings star l smap l and scomb l .
tarantula indicates that the given line is positively correlated with the fault indicated by a tarantula suspiciousness rating greater than .
.
example.
as described in section .
the test input generation algorithm produces two runs of the script in figure d one that exposes an html error and one that does not.
figure shows the suspiciousness ratings star l smap l and scomb l that are computed for each linelin the php script in figure d according to the three fault localization techniques under consideration.
to understand how the tarantula ratings are computed consider statements that are only executed in the passing run.
such statements obtain a suspiciousness rating of .
.
by similar reasoning statements that are only executed in the failing run obtain a suspiciousness rating of .
and statements that are executed in both the passing and the failing run obtain a suspiciousness rating of .
.
the suspiciousness ratings computed by the mapping based technique can be understood by examining the output of the validator in figure c along with the html in figure a and the mapping from lines of html to the lines of php that produced them in figure b .
the validator says the error is in line or of the output and those were produced by lines and in the script of figure d .
consequently the suspiciousness ratings for lines and are .
and all other lines are rated .
by the mappingbased technique.
the suspiciousness ratings for the combined technique follow directly from its definition in section .
.
as can be seen from the table the tarantula technique identifies lines and as the most suspicious ones and the output mapping based technique identifies lines and as such.
in other words each of these fault localization techniques when used in isolation reports one non faulty statement as being highly suspicious.
however the combined technique correctly identifies only line as the faulty statement.
.
tarantula with condition modeling as we observed in section .
the tarantula algorithm works by associating a suspiciousness rating with each statement present in the program under analysis.
sometimes however it is the absence of a statement that causes a failure.
for example a switch statement in which thedefault case is omitted can cause a failure if the missingdefault case was supposed to close certain html tags.
similarly anifstatement for which the matching else branch is missing can cause the resulting html code to be malformed if theboolean predicate in theifstatement isfalse as we noticed in section .
when discussing the ifstatement in line of the login.php script.
the tarantula fault localization technique as previously applied to statements cannot rank a missing statementsince that will never be executed.
we enhance tarantula s effectiveness by employing a new condition modeling technique.
this new technique uses an augmented domain for modeling conditional statements instead of assigning a suspiciousness rating and rank to a conditional statement itself it assigns a rating and rank to pairs of the form statement index of firsttrue case .
the number of pairs associated with a switch statement is equal to the number of cases in the statement plus .
for example if a switch statement shas threecase predicates then the pairs considered by the condition modeling technique are as follows .
s modeling the fact that all case predicates evaluate to false causing thedefault branch if it exists to be executed .
s modeling the fact that both the first and second case predicates evaluate to false and the third one to true .
s modeling the fact that the first case predicate evaluates tofalse and the second one to true .
s modeling the fact that the first case predicate evaluates totrue ifsis anifstatement there are two pairs associated with s .
s modeling the fact that the predicate evaluates to false .
s modeling the fact that the predicate evaluates to true after computing suspiciousness ratings for all pairs s the conditional statement sis assigned the maximum of these ratings from which its rank is computed in the normal manner.
this technique allows us to rank a switch statement with a missing default case and anifstatement with a missing else branch as explained in the following example.
example.
in thelogin.php script of figure c if sis theifstatement in line then s is going to be assigned rank because when its predicate istrue sis never going to participate in a faulty execution.
on the other hand s is assigned rank because executing swith its predicate set to false leads to a faulty execution as discussed in section .
.
our enhancement of tarantula with condition modeling will assign to sthe higher of the two ranks .
this is in contrast to the rank .
that the statement based tarantula algorithm would have assigned to s. .
implementation in apollo we implemented a shadow interpreter based on the zend php interpreter .
.24that simultaneously performs concrete program execution using concrete values and a symbolic execution that uses symbolic values that are associated with variables.
we implemented the following extensions to the shadow interpreter to support fault localization statement coverage.
all fault localization techniques based ontarantula use the percentage of failing and passing tests executing a given statement to calculate the statement s suspiciousness score.
our shadow interpreter records the set of executed statements for each execution by hooking into the zend execute andcompile file methods.
html validator.
apollo has been configured to use one of the following html validators as an oracle for checking html output the web design group wdg html validator5and the cse html validator v9.
.
version files php loc downloads faqforge .
.
webchess .
.
schoolmate .
.
timeclock .
.
table characteristics of subject programs.
the files column lists the number of .php and.inc files in the program.
the php loc column lists the number of lines that contain executable php code.
the downloads column lists the number of downloads from .
output mapping.
the output mapping technique described in section .
localizes a fault found in the output to the statements producing the erroneous output part.
our shadow interpreter creates the mapping by recording the line number of the originating php statement whenever output is written out using theecho andprint statements.
the producing statement is found in the map using the positional information reported by an oracle checking the output for faults.
condition modeling.
our shadow interpreter records the results of all comparisons in the executed php script for the conditional modeling technique as described in section .
.
for each comparison it records a pair consisting of the statement s line number and the relevant boolean result.
the only exception is the execution of a switch statement.
for this the shadow interpreter stores the set of results for all executed case blocks together with the switch line number.
.
ev aluation this evaluation aims to answer two questions q1.
how effective is the tarantula fault localization technique in the domain of php web applications?
q2.
how effective is tarantula when combined with the use of an output mapping and or when modeling the outcome of conditional expressions as presented in section ?
.
subject programs for the evaluation we selected open source php programs7 faqforge is a tool for creating and managing documents.
webchess is an online chess game.
schoolmate is a php mysql solution for administering elementary middle and high schools.
timeclock is a web based timeclock system.
figure presents some characteristics of these programs.
.
methodology in order to answer our research questions a set of localized faults and a test suite exposing them is needed for each subject program.
since neither a test suite nor a set of known faults exists for our subject programs we use apollo s combined concrete and symbolic execution technique that was presented in section to generate a test suite and to detect failures.
for this initial experiment we gave the test generator a time budget of minutes and during this time hundreds of tests were generated and many failures were found for each subject program.
in order to investigate the e ffectiveness of an automatic fault localization technique such as tarantula it is necessary to know where faults are located.
unlike previous research on automated fault localization techniques where the location of tests failures localized faults html exec.
total html exec.
total faqforge webchess schoolmate timeclock total table characteristics of the test suites failures and localized faults in the subject programs.
the columns of the table indicate i the subject program ii the number of tests in the test suite generated for that program iii the number of failures exposed by the test suite three columns html failures execution errors total and iv the number of faults manually localized for that program three columns html faults execution faults total .
faults was known e.g.
because faults were seeded we did not know where the faults were located and therefore needed to localize them manually.
manually localizing and fixing faults is a very time consuming task so we limited ourselves to faults in each of the subject programs.
in webchess only faults were found to cause the failures so we use a total of faults as the basis for the experiments discussed in this section.
for each fault we devised a patch and ensured that applying this patch fixed the problem by running the tests again and making sure that the associated failures8did not recur.
table summarizes the details of the generated test suites and the localized faults used in the remainder of this section.
we used the following fault localization techniques to assign suspiciousness ratings to all executed statements tthetarantula algorithm that was presented in section .
othe technique of section .
based on using an output mapping in combination with positional information obtained from an oracle html validator .
t othe combined technique described in section .
that combines tarantula with the use of the output mapping.
tc the variation on tarantula presented in section .
in which conditional expressions are modeled as condition value pairs.
tc othe variation on tarantula presented in section .
combined with the use of the output mapping.
tcoroa combined fault localization technique that uses tcfor execution errors and ofor html failures.
we computed suspiciousness ratings separately for each localized fault by applying each of these fault localization techniques to a test suite that comprised the set of failing tests associated with the fault under consideration and the set of all passing tests.
similar to previous fault localization studies we measured the effectiveness of a fault localization algorithm as the minimal number of statements that needs to be inspected until the first faulty line is detected assuming that statements are examined in order of decreasing suspiciousness.
.
results table shows experimental results for each of the six techniques t o t o tc tc oandtcoro discussed above.
the table shows for each subject program and for the subject programs in aggregate a group of six rows of data one for each technique.
each row shows from left to right the average number percentage of statements that needs to be explored to find each fault followed by columns of data that show how many of the faults were localized by exploring up to of all statements up to of all 8in general a single fault may be responsible for multiple failures.program technique statements faqforget .
.
.
.
.
.
.
.
.
.
.
.
.
o .
.
.
.
.
.
.
.
.
.
.
.
.
t o .
.
.
.
.
.
.
.
.
.
.
.
.
tc .
.
.
.
.
.
.
.
.
.
.
.
.
tcoro .
.
.
.
.
.
.
.
.
.
.
.
.
tc o .
.
.
.
.
.
.
.
.
.
.
.
.
webchesst .
.
.
.
.
.
.
.
.
.
.
.
.
o .
.
.
.
.
.
.
.
.
.
.
.
.
t o .
.
.
.
.
.
.
.
.
.
.
.
.
tc .
.
.
.
.
.
.
.
.
.
.
.
.
tcoro .
.
.
.
.
.
.
.
.
.
.
.
.
tc o .
.
.
.
.
.
.
.
.
.
.
.
.
schoolmatet .
.
.
.
.
.
.
.
.
.
.
.
.
o .
.
.
.
.
.
.
.
.
.
.
.
.
t o .
.
.
.
.
.
.
.
.
.
.
.
.
tc .
.
.
.
.
.
.
.
.
.
.
.
.
tcoro .
.
.
.
.
.
.
.
.
.
.
.
.
tc o .
.
.
.
.
.
.
.
.
.
.
.
.
timeclockt .
.
.
.
.
.
.
.
.
.
.
.
.
o .
.
.
.
.
.
.
.
.
.
.
.
.
t o .
.
.
.
.
.
.
.
.
.
.
.
.
tc .
.
.
.
.
.
.
.
.
.
.
.
.
tcoro .
.
.
.
.
.
.
.
.
.
.
.
.
tc o .
.
.
.
.
.
.
.
.
.
.
.
.
aggregatedt .
.
.
.
.
.
.
.
.
.
.
.
.
o .
.
.
.
.
.
.
.
.
.
.
.
.
t o .
.
.
.
.
.
.
.
.
.
.
.
.
tc .
.
.
.
.
.
.
.
.
.
.
.
.
tcoro .
.
.
.
.
.
.
.
.
.
.
.
.
tc o .
.
.
.
.
.
.
.
.
.
.
.
.
table results of fault localization using the di fferent fault localization techniques.
the columns of the table indicate i the subject program ii the fault localization technique used iii the average number of statements to inspect and average percentage of statements to inspect iv xiv indicate the percentage of faults in each range of percentage of statements to inspect.
statements up to of all statements and so on.
consider for example the case where the t otechnique is used to localize faults infaqforge .
if a programmer inspects the statements reported by this technique in decreasing order of suspiciousness then on average he will need to inspect .
statements until he has found the first faulty statement and this corresponds to .
of the executed statements.
furthermore we can see that for of the faults in faqforge less than of the executed statements needs to be inspected for an additional of the faults between and of the executed statements needs to be inspected and that the remaining of the faults requires inspecting between of of the executed statements.
in order to ease the discussion of the relative e ffectiveness of the techniques we will say that a fault is well localized by a faultlocalization technique if inspecting the statements in decreasing order of suspiciousness according to that technique implies that all faulty statements are found after inspecting fewer than of all executed statements.
using this terminology we can see that using the basic tarantula algorithm only .
of all faults are well localized on average see the first row of data in the set of rows labeled aggregated .
using the oracle based technique o .
of all faults are well localized on average over all subjects.
combining tarantula with the oracle t o yields a technique that outperforms either of its constituents with .
of all faults being well localized on average.
adapting tarantula to operate on statements and condition value pairs tc is slightly helpful by well localizing .
of all faults versus the previously mentioned .
for the statement based tarantula algorithm.
the most effective fault localization technique is obtained by using the variant of tarantula that operates on statements and condition value pairs in combination with the oracle tc o .using this technique .
of all faults are well localized on average over all subjects.
for the combined technique that uses the tctechnique for execution errors and the otechnique for html failures .
of all faults are well localized.
.
discussion while we have discussed only aggregated data so far the results appear to be consistent across the four subject applications.
it is interesting to note that the e ffectiveness of the more precise modeling of conditionals depends on whether the subject program contains any faults that consist of missing branches in conditions.
for one subject webchess this accounts for a .
improvement in well localized faults over the basic tarantula algorithm whereas for another timeclock it makes no difference at all.
in summary we found that thetc oyields an almost five fold increase in the percentage of well localized bugs when compared with the basic tarantula algorithm.
most of this increment is due to the use of the output mapping in combination with positional information obtained from the oracle.
this is undoubtedly due to the fact that many of the localized faults manifest themselves via malformed html output.
our treatment of conditional expressions accounts for a much smaller part of the gains in precision but is still helpful in cases where the fault consists of a missing branch in a conditional statement.
it is interesting to note that since the oracle provides a binary suspiciousness rating it tends to either be very helpful or not helpful at all.
this argues strongly for a fault localization method that combines a statistical method such as tarantula with one based on an output mapping.
one could consider using di fferent techniques for different kinds of faults e.g.
use tarantula for execution errors and the oracle based technique for html errors .
however the example that we discussed previously in section .
shows thatthe two techniques can reinforce each other in useful ways.
this is confirmed by our experimental results the combined technique tcorois significantly less e ffective .
of all statements being well localized than the combined technique tc o .
.
figure shows a graph depicting the aggregated data of table .
thex axis represents the percentage of statements that need to be examined in decreasing order of suspiciousness until the first fault has been found and the y axis the number of faults localized.
a line is drawn for each of the six fault localization techniques under consideration.
from these lines it is clear that the tc otechnique outperforms all other techniques.
in particular note that for any percentage nbetween and tc olocalizes more faults than any of the other algorithms when up to n of all statements are examined in decreasing order of suspiciousness.
figure effectiveness comparison of di fferent faultlocalization techniques.
x axis percentage of statements that need to be inspected.
y axis percentage of faults.
.
threats to validity there are several objections a critical reviewer might raise to the evaluation presented in this section.
first one might argue that the benchmarks are not representative of real world php programs.
while this may be the case we selected open source php applications that are widely used as is evidenced by the number of downloads reported in figure .
the same subject programs were also used as subject programs by minamide .
second it could be the case that the faults we exposed and localized are not representative.
we do not consider this to be a serious risk because we were previously unfamiliar with the faults in these subject programs and all of them were exposed by automatic and systematic means.
a potentially more serious issue is that any given fault may be fixedin multiple different ways.
the fixes we devised were mostly oneline code changes for which we attempted to produce the simplest possible solution.
a possible experiment which we plan to pursue as future work is to submit patches with our fixes to the developers of the subject programs and observe if they are accepted.
the most serious criticism to our evaluation in our own opinion is the assumption that programmers would inspect the statements strictly in decreasing order of suspiciousness.
in practice it is very likely that programmers who try to follow this discipline would automatically look at adjacent statements so the assumption is probably not completely realistic.
our rebuttal to this argument is that we evaluate all techniques in exactly the same way and that this approach to measuring the effectiveness of fault localization methods has been used in previous research in the area e.g.
.
.
related work this section reviews the literature on fault localization focusing on tarantula and other approaches.
.
tarantula in this paper we apply the tarantula technique which was previously discussed in section in a new domain web applications written in php .
previous evaluations of the tarantula algorithm have primarily focused on the siemens suite a collection of small c programs into which artificial faults have been seeded and for which a large number of test cases is available.
by contrast we study real faults in open source php web applications.
moreover unlike previous work on tarantula we do not assume the availability of a test suite but rely on combined concrete and symbolic execution to generate a large number of passing and failing test cases instead.
santelices et al.
investigate the tradeo ffs of applying the tarantula algorithm to different types of program entities statements branches and def use pairs.
the results for the branchbased and def use based variants are mapped to statements so that their effectiveness can be compared.
the outcome of this comparison is that the branch based algorithm is more precise than the statement based one and that def used based variant is more precise still.
santelices et al.
also present algorithms that combine the variants by computing an overall suspiciousness rating for each statement that is derived from the underlying suspiciousness ratings and report that one of these combined algorithms is even more precise than the def use based algorithm.
in this paper we also explore special treatment of branches but unlike santelices et al.
we do not compute a separate suspiciousness rating based on branch information but instead extend the statement based approach by treating each control flow predicate as several distinct statements one for each branch.
.
other approaches for fault localization early work on fault localization relied on the use of program slicing .
lyle and weiser introduce program dicing a method for combining the information of di fferent program slices.
the basic idea is that when a program computes a correct value for variable xand an incorrect value for variable y the fault is likely to be found in statements that are in the slice w.r.t.
y but not in the slice w.r.t.
x. variations on this idea technique were later explored by pan and spafford and by agrawal et al.
.
in the spirit of this early work renieris and reiss use setunion andset intersection methods for fault localization that they compare with their nearest neighbor fault localization technique discussed below .
the set union technique computes the union of all statements executed by passing test cases and subtracts thesefrom the set of statements executed by a failing test case.
the resulting set contains the suspicious statements that the programmer should explore first.
in the event that this report does not contain the faulty statement renieris and reiss propose a ranking technique in which additional statements are considered based on their distance to previously reported statements along edges in the system dependence graph sdg .
the set intersection technique identifies statements that are executed by all passing test cases but not by the failing test case and attempts to address errors of omission where the failing test case neglects to execute a statement.
the nearest neighbors fault localization technique by renieris and reiss assumes the existence of a failing test case and many passing test cases.
the technique selects the passing test case whose execution spectrum most closely resembles that of the failing test case according to one of two distance criteria9 and reports the set of statements that are executed by the failing test case but not by the selected passing test case.
in the event that the report does not contain the faulty statement renieris and reiss use the sdg based ranking technique mentioned above to identify additional statements that should be explored next.
nearest neighbor was evaluated on the siemens suite and was found to be superior to the set union andset intersection techniques.
recent papers by jones and harrold and by abreu et al.
empirically evaluate various fault localization techniques including many of the ones discussed above using the siemens suite.
dallmeier et al.
present a technique in which di fferences between method call sequences that occur in passing and failing executions are used to identify suspicious statements.
they evaluate the technique on buggy versions of the nanoxml java application.
cleve and zeller zhang et al.
and je ffrey et al.
present fault localization techniques that attempt to localize faults by modifying the program state at selected points in a failing run and observing whether or not the failure reoccurs.
other fault localization techniques analyze statistical correlations between control flow predicates or path profiles and failures time spectra and correlations between changes made by programmers and test failures .
in recent work by zhang et al.
suspiciousness scores are associated with basic blocks and control flow edges and computed by solving e.g.
using gaussian elimination a set of equations that reflect control flow between basic blocks.
.
conclusions and future work we have leveraged combined concrete and symbolic execution and several fault localization techniques to create a uniquely powerful tool that automatically detects failures and localizes faults in php web applications.
the fault localization techniques that we evaluated combine variations on the tarantula algorithm with a technique based on maintaining a mapping between executed statements and the fragments of output they produce.
we implemented these techniques in a tool called apollo and evaluated them by localizing randomly selected faults that were exposed by automatically generated tests in four php applications.
our findings indicate that using our best technique .
of the faults under consideration are localized to within of all executed statements which constitutes an almost five fold improvement over the tarantulaalgorithm.
for future work we plan to investigate if the e ffectiveness of our techniques can be enhanced by generating additional tests whose 9one similarity measure defines the distance between two test cases as the cardinality of the symmetric set di fference between the statements that they cover.
the other measure considers the differences in the relative execution frequencies.execution characteristics are similar to those of failing tests.
we also plan to explore the e ffectiveness of variations on the ochiai fault localization technique and to submit the patches we devised to remedy the localized faults to the developers of our test subjects.
.