slicing and replaying code change history katsuhisa maruyama1 eijiro kitsu2 takayuki omori1 shinpei hayashi3 1department of computer science ritsumeikan university japan 2graduate school of science and engineering ritsumeikan university japan 3department of computer science tokyo institute of technology japan maru cs.ritsumei.ac.jp kitsu takayuki fse.cs.ritsumei.ac.jp hayashi se.cs.titech.ac.jp abstract change aware development environments have recently become feasible and reasonable.
these environments can automatically recordfine grained code changes on a program and allow programmers toreplay the recorded changes in chronological order.
however they do not always need to replay all the code changes to investigate how a particular entity of the program has been changed.
there fore they often skip several code changes of no interest.
this skip ping action is an obstacle that makes many programmers hesitate inusing existing replaying tools.
this paper proposes a slicing mechanism that can extract only code changes necessary to construct a particular class member of a java program from the whole historyof past code changes.
in this mechanism fine grained code changesare represented by edit operations recorded on source code of a pro gram.
the paper also presents a running tool that implements theproposed slicing and replays its resulting slices.
with this tool programmers can avoid replaying edit operations nonessential to the construction of class members they want to understand.
categories and subject descriptors d. .
integrated environments d. .
version control d. .
program editors general terms algorithms human factors keywords software maintenance and evolution program comprehension program slicing code change integrated development environments .
introduction in software maintenance many programmers mainly maintainers must often understand existing source code that someone elsehas written or modified before .
to make such understanding easier change based support has recently become popular .
in permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for profit or c ommercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redist ribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
.general programmers do not only concentrate on examining source code but would look at its time series data such as a chronologicalsequence of its snapshots.
this enables them to obtain knowledgeof how the source code has been ever changed.
for example spy ware syde and operationrecorder are embedded intomodern integrated development environments ides and capture all fine grained code changes performed on the editors provided by their respective ides.
in addition these recording tools col laborate with tools visualizing filtering and or replaying recordedcode changes.
using these tools helps programmers keep track of fine grained code changes individually stored in the repository.
in particular a replaying tool can reenact past programming scenes in front of programmers faces.
this makes them to image what other pro grammers have gone through in the past.
moreover the historyof past code changes provides hints at programmers understand ing how to revert undesired code changes based on their decisions made in the past.
for example a controlled experiment conducted by hattori et al.
demonstrated that chronologically replaying offine grained code changes outperforms existing commit based ver sioning systems on helping programmers find answers to questionsrelated to software evolution.
although chronologically replaying of fine grained code changes of a program is useful for understanding its evolution we emphasize the possibility of improvement in assistance for replaying.
ingeneral replaying is a time consuming task.
if huge amount ofcode changes were recorded it takes a long time to replay everychange.
in most cases programmers do not need to investigate thewhole evolution of source code.
they incrementally obtain knowledge on past code changes by partially replaying the code changes depending on their interests.
to encourage programmers to exploitexisting replaying tools automatic extraction of code changes tobe replayed is required.
this helps them efficiently understand theevolution of a particular part of source code.
here careful read ers might think that edit operations not related to a program entity of interest can be filtered out by checking its name.
unfortunately simple filtering provided by the conventional tools does not addressfine grained tracking of code changes resulting from the renaming splitting or merging of program entitie s e.g.
methods of a java program or the moving or copying of part of their bodies through a cut paste or copy paste action.
this paper proposes a mechanism that automatically extracts a collection of fine grained code changes all of which may be relatedto a particular program entity from the recorded change history.this mechanism is inspired by the concept of program slicing .program slicing is used to extract from code of a program a set of statements that may affect the calculation of the value of a variable of interest at a specified program point.
here the princi permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september essen germany copyright acm ... .
pal concern is simplification when slicing to assist program comprehension although much of application of slicing has been provided.
our idea exploits this simplification power of slicing inreplaying past code changes.
in the mechanism fine grained code changes are represented by edit operations on source code of a java program.
moreover a spe cial graph called an edit operation graph opg hereafter is introduced.
it links class members methods and fields within snapshots of program code via edit operations performed on their re spective snapshots.
by traversing vertices and edges of an opg themechanism can extract only edit operations necessary to construct create remove and modify a class member of interest from thehistory consisting of all recorded edit operations.
such extraction process and a collection of the extracted edit operations are called anoperation history slicing and an operation history slice respectively.
this paper also presents a running tool operationslicereplayer which implements operation history slicing and replays its resulting slices.
the important feature of the proposed slicing is that the contents restored by replaying only edit operations included in an operation slice for a target class member on an arbitrary snapshot of sourcecode are likely to be always the same as the original contents of thetarget class member.
due to this feature if a programmer wants tounderstand a particular class member in his her task only edit oper ations included in its operation history slice would be replayed.
in other words programmers can avoid any nonessential action skipping edit operations of class members they have no interest in.
con sequently operationslicereplayer has the potential to make their program understanding tasks more efficient.
.
operation history slicing it is obviously assumed that all edit operations with respect to manual and automatic code changes performed on the editor are completely collected.
we adopt operationrecorder as a recording tool which can automatically record edit operations that affectsource code in eclipse s java editor.
the operations include man ual typing insertion deletion and replacement of a text editingvia a clipboard copy cut and paste of a text undo redo actions and code changes by automatic transformation code completion quick fix formatting and refactoring .
this section first describes a graph that represents relationships among class members of source code and recorded edit operations and then defines operation history slicing using this graph.
.
edit operation graph to collect all edit operations constructing a particular class member of source code without omission it is necessary to formulate therelationships between edit operations and code fragments affectedby them.
an edit operation graph opg is a multipartite graph that indicates which edit operation affects the code fragment s within a target class member.
in this paper s 0indicates the initial snapshot of the contents of the source code that an edit operation was never performed on.
thesubscript number is incremented by one once each edit operation isapplied.
here p idenotes the i th edit operation and siindicates the snapshot of the source code generated immediately after piwas applied to its precedent snapshot si .
in other words sican be obtained after all edit operations between p1andpiare chronologically applied to s0.
moreover a snapshot consisting of only code fragments with no syntax error is called a parseable one.
1the current version of operationrecorder excludes recording of actions related to file renaming and removing.letm si be a set of all class members methods and fields within a parseable snapshot si.
if the contents of siis not parseable m si is empty m si .vis a set that collects both all vertices for class members within every snapshot and all vertices forevery edit operation.
vis defined as follows v v.m m m s i i z v.p p pi i z .
theiis the index number represents a subscript of a snapshot or an edit operation.
the zis the index number represents a subscript of the latest snapshot szand one of the latest edit operation pz.t h e v.m denotes a vertex corresponding to the class member m a n d thev.pdenotes a vertex corresponding to the edit operation p. next consider edges which link between two vertices included in v. we first define two adjacent snapshots siandsj i j both of which are parseable.
there is no parseable snapshot skthat satisfies i k j since siandsjare adjacent.
to be precise there is no snapshot skbetween siandsjunder j i 1or every snapshot skthat satisfies i k j is not parseable.
edges of an opg are divided into the following four types.
a let pk i k j be one of edit operations that change si intosj.i fpkis an edit operation and its inserted or deleted text contains any code fragment included in a class member mwithin si pkcan be considered to affect mbackwards.
ifpkis a copy operation and its copied text is partially extracted from m pkcan be also considered to affect m. in these cases v.m v a n d v.pk v are linked by a backward change edgev.m bv.pkin the opg g. b consider pkunder the same situation as the aforementioned a .
if the inserted or deleted text of an edit operation pk contains any code fragment included in a class member m within sj pkcan be considered to affect mforwards.
in this case v.pk v a n d v.m v a r el i n k e db ya forwardchange edgev.pk fv.m in the opg g. c consider a situation that the contents of a class member m within siremains in a class member m primewithin sjwithout any change.
if mhas no forward change edge m primehas no backward change edge and the full names of mandm primeare the same v.m v a n d v.m prime v a r el i n k e db ya nochange unchanged edge v.m nv.m primein the opg g. the full name is a unique identifiable name constructed byconcatenating the fully qualified name of a class a specialcharacter and the signature of a method or the name of a field.
for example fqn sig a n d fqn vn a r et h ef u l l names for a method with the signature sig a n dafi e l dw i t h the variable name vn of a class fqn respectively.
d let pxbe a cut or copy operation that inserts any text into a clipboard from a snapshot sx a n dpybe a paste operation that inserts the text stored in the clipboard into a snapshots y.sx 1andsymay be adjacent or may not.
if the deleted or copied text of pxis equal to the inserted text of py a n d neither cut nor copy operation was performed between px andpy v.pi v a n d v.pj v are linked by a ccpchange cut copy paste edge v.pi cv.pjin the opg g. eis a set of all edges that satisfy one of the above four types of edges b f n o r c .
an opg is a directed graph consisting of a set of vertices v and a set of directed edges e which is represented by g v e .
figure depicts part of an opg representing the construction of a sample java program with lines of code.
the opg contains all247figure part of an operation history graph opg .
the whole opg consists of vertices and edges.
edit operations performed during the construction and all class members appearing in its snapshots.
each triangle indicates a vertex corresponding to an edit operation.
for example p30 p31 p45 p46 a n d p47are normal edit operations.
moreover p28is a copy operation and p29is a paste operation.
each oval indicates a vertex corresponding to a class member.
a dotted rectangle indicates asnapshot that a class member belongs to.
arrows marked with thelabels b f n a n d cindicate the four types of edges a backwardchange edge a forward change edge a no change edge and a ccpchange edge respectively.
to detect backward change and forward change edges between an edit operation and a class member of an opg their offset val ues are compared.
the offset value is stored into information oneach edit operation which locates the starting point of its inserted deleted or copied text.
in this detection several offset values would be adjusted according as the length of the inserted or deleted text oftheir neighboring edit operations.
for example for the opg shownin figure s 44ands47are adjacent parseable snapshots i.e.
s45 ands46are not parseable .
thus the offset values of p45 p46 andp47between s44ands47are candidates to be adjusted.
in fact the offset value of p46was adjusted.
after the detection of all backward change and forward change edges no change and ccp change edges will be detected.
these edges can be easily detected.for example p 28andp29can be linked via a ccp change edge.
.
operation history slice by traversing vertices and edges of an opg the proposed mechanism can extract edit operations necessary to construct a classmember of interest from the history consisting of all edit opera tions.
here g sis an opg for source code s.l e tr gs v. m be a set of vertices of gsthat reach a vertex v.m corresponding to a class member mwithin a snapshot of s. r gs v. m u v gs u v.m .
v gs is a set of all vertices of gs.
the relation means the reflexive and transitive closure of the relation which indicates one of the four types of edges b f n o r c o fgs.
here there exists sometime an edit operation having no forwardchange edge in the opg.
for example this occurs when an editoperation deletes or cuts the whole contents of a method or a field.since such edit operation will be properly replayed r prime gs v. m was newly derived from r gs v. m .r prime gs v. m r gs v. m w v gs u bw u r gs v. m .
a reachable set of edit operations op gs v. m is defined as follows op gs v. m u vp gs u r prime gs v. m .
vp gs is a set of vertices with respect to all edit operations.
next consider a sequence of edit operations to be replayed.
let q s be a sequence that lists all edit operations for s. q s angbracketleftp1 ... p z angbracketright.
for every recorded edit operation p1is the first earliest one andpzare the last latest one.
the above sequence is drawn up in their chronological order.
in other words the time when piwas performed is earlier than or equal to the time when pj i j was done.2in case that there exists only one edit operation for s q s angbracketleftp1 angbracketright.
an operation slice sq s m is a minimal sub sequence of q s that satisfies the following condition v.pk op gs v. m pk sq s m sp s m subsetsqequalq s op gs v. m sq s m .
q1 subsetsqequalq2means that q1is a sub sequence of q2.
op gs v. m indicates the number of elements included in op gs v. m and sq s m indicates the number of elements included in sq s m .
these numbers are always equal.
the mis a slicing criterion that denotes a class member of interest within a snapshot s. the snapshot s65 the final code for the opg shown in figure has eight class members three fields and five methods .
for a method setx within s65 its operation history slice is as follows sq g setx s65 angbracketleft13 angbracketright.
the slice contains edit operations.
thus its ratio to the total number of the recorded edit operations is .
.
figure shows the screenshot of the operationslicereplayer perspective in eclipse.
operationslicereplayer chronologically restores 2if two edit operations are performed at the same time their chronological order is not uniquely determined.
although this hap pens operationrecorder suitably orders and records them.248figure operationslicereplayer perspective in eclipse.
the contents of a source file of interest and presents an animated movie tracking its changes on the left view of the perspective.
when a programmer wants to see the growth of a particular classmember he she can activate a slicing menu presenting all classmembers existing in currently restored source code.
if it is notparseable operationslicereplayer tries to find an immediately precedent parseable snapshot and presents its class members.
recorded edit operations are listed on the right view.
in this view edit operations included in the operation history slice are displayed in theblack and ones not included in the slice are displayed in the grey.he she can replay one by one plus rewind and fast forward thewhole history of the recorded edit operations and also skip unnecessary edit operations by pushing each of the replay buttons.
.
related work obviously our goal is in agreement with that of the study by hattori et al.
and the concept of operation history slicing canbe applied to their replaying tool.
regarding the change relation and its graph representation a few challenges are closely related to our study.
alam et al.
pro posed the concept of a time dependence relation between two struc tural changes on source code which indicates that one change to asource code entity follows depends on another change.
in addi tion a change impact graph cig or a genealogy of changes is based on the concept almost the same as the time dependence.
they all represent information on the temporal dependence be tween code changes.
from this point of view our opg can beconsidered a variant of the aforementioned graphs.
a big differ ence is what is the unit of code change.
the opg represents a dependence relation between finer grained and more accurate code changes which is built by using the offset level mapping instead ofthe entity level mapping.
history slicing is the closest study.
it extracts a set of lines of code of interest from its whole history.
the concept of the his tory slicing and that of our operation history slicing are the same but their mechanisms are vastly different.
our operation history slicing uses the opg built by offset level mapping instead of thehistory graph built by line level mapping.
as a result the historyslice is simply a set of lines of code whereas the operation historyslice is a set of edit operations each of which contains informationon past code addition and or deletion.
in other words our slice is applied to code as an edit script and then can be replayed.
.
conclusion replaying past edit operations for source code is useful for understanding its growth but is often a time consuming task.
this paper has presented a mechanism of operation history slicing that can automatically eliminate nonessential skipping of edit operations forclass members of no interest.
we have still no firm evidence forthe benefits of its use during program comprehension.
to checkwhether operation history slicing can reduce program comprehen sion effort we must make a large number of comparative experiments with and without introducing this slice.
the development of operationslicereplayer is continuing.
two immediate issues mainly remain in its enhancement.
it currentlytreats inner classes as a part of class members methods to be ex act including these classes.
to se parate such classes from their respective outer class members nesting offset ranges of class members and classes enclosed by them is considered.
moreover operationslicereplayer should support renaming of classes.
the current implementation cannot detect non change edges in this situation.
.