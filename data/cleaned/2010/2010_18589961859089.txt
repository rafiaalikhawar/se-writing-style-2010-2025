detection of recurring software vulnerabilities nam h. pham nampham iastate.edutung thanh nguyen tung iastate.edu hoan anh nguyen hoan iastate.edutien n. nguyen tien iastate.edu electrical and computer engineering department iowa state university usa abstract software security vulnerabilities are discovered on an almost daily basis and have caused substantial damage.
aiming at supporting early detection and resolution for them we have conducted an empirical study on thousands of vulnerabilities and found that many of them are recurring due to software reuse.
based on the knowledge gained from the study we developed securesync an automatic tool to detect recurring software vulnerabilities on the systems that reuse source code or libraries.
the core of securesync includes two techniques to represent and compute the similarity of vulnerable code across different systems.
the evaluation for vulnerabilities on releases of open source software systems shows that securesync is able to detect recurring vulnerabilities with high accuracy and to identify releases having potentially vulnerable code that are not reported or fixed yet even in mature systems.
a couple of cases were actually confirmed by their developers.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms algorithms design reliability .
introduction new software security vulnerabilities are discovered on an almost daily basis and have caused substantial financial damage.
thus it is vital to be able to detect and resolve them as early as possible.
one of early detection approaches is to consult with the prior known vulnerabilities and corresponding fixes.
in current practice known software security vulnerabilities and or fixes are often reported in public databases e.g.
national vulnerability database nvd common vulnerabilities and exposures database cve or on public websites of specific software applications.
with the hypothesis that recurring software vulnerabilities are due to software reuse we conducted an empirical study on several permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.databases for security vulnerabilities including nvd cve and others.
we found several recurring and similar software security vulnerabilities occurring in different software systems.
most of recurring vulnerabilities occur in the systems that reuse source code e.g.
having the same code base deriving from the same source or being developed on top of a common framework .
that is a system has some vulnerable code fragments.
then such code fragments are reused in other systems e.g.
by copy and paste by branching duplicating the code base and then developing new versions or new systems .
patches in one of such systems were late propagated into other systems.
due to the reuse of source code the recurring vulnerable code fragments are identical or highly similar in code structure and in the names of function calls variables constants literals or operators.
let us call them type .
another type of recurring vulnerabilities occurs across different systems that share apis type .
for example such systems use the same function from a library and have the same errors in api usages e.g.
missing or wrongly checking the input output of the function missing or incorrectly placing function calls etc.
the corresponding vulnerable code fragments on such systems tend to misuse the same apis in a similar manner e.g.
using the incorrect orders missing step s in function calls missing the same checking statements incorrectly using the same comparison expression etc.
there are also some systems having recurring or similar vulnerabilities due to the reuse at a higher level of abstraction.
for example such systems share the same algorithms protocols specifications standards and then have the same bugs or programming faults.
we call such recurring vulnerabilities type .
the examples and detailed results of all types will be discussed in section .
this finding suggests that one could effectively detect and resolve some unreported vulnerabilities in one software system by consulting the prior known and reported vulnerabilities in the other systems that reuse share source code libraries or specifications.
to help developers with this task we developed securesync a supporting tool that is able to automatically detect recurring software vulnerabilities in different systems that share source code or libraries which are the most frequent types of recurring vulnerabilities.
detecting recurring vulnerabilities in systems reusing at higher levels of abstraction will be investigated in future work.
securesync is designed to work with a semi automatically built knowledge base of the prior known reported vulnerabilities including the corresponding systems libraries and vulnerable and corresponding patched code.
it is able to support detecting and resolving vulnerabilities in two following scenarios .
given a vulnerability report in a system awith corresponding vulnerable and patched code securesync analyzes the patch and stores the information in its knowledge base.
then via google code search it searches for all other systems bthat share source code and libraries with a checks if bhas the similarly vulnerable code and reports such locations if any .
.
given a system xfor analysis securesync will check whether xreuses some code fragments or libraries with another system y in its knowledge base.
then if the shared code in xis sufficiently similar to the vulnerable code in y securesync will report it to be likely vulnerable and point out the vulnerable location s .
in those scenarios to help developers check and fix the reported vulnerable code securesync also provides suggestions such as adding missed function calls adding checking of input output before or after a call replacing the operators in an expression etc.
the key technical goals of securesync are how to represent vulnerable and patched code and how to detect code fragments that are similar to vulnerable ones.
we have developed two core techniques for those problems to address two kinds of recurring vulnerabilities.
for recurring vulnerabilities of type reusing source code securesync represents vulnerable code fragments as abstract syntax tree ast like structures with the labels of nodes representing both node types and node attributes.
for example if a node represents a function call its label will include the node type function call the function name and the parameter list.
the similarity of code fragments is measured by the similarity of structures of such labeled trees.
our prior technique exas is used to approximate structure information of labeled trees and graphs by vectors and to measure the similarity of such trees via vector distance.
for recurring vulnerabilities of type systems sharing libraries the traditional code clone detection techniques do not work in these cases because the similarity measurement must involve program semantics such as api usages and relevant semantic information.
securesync represents vulnerable code fragments as graphs with the nodes representing function calls condition checking blocks as control nodes in statements such as if while or for and operations such as !
or .
labels of nodes include their types and names.
the edges represent the relations between nodes e.g.
control data dependencies and orders of function calls.
the similarity of such graphs is measured based on their largest common subgraphs.
to improve performance securesync uses locality sensitive hashing lsh to perform fast searching for similar trees only trees having the same hash code are compared to each other.
it also uses set based filtering to find the candidates of type only the graphs containing the nodes having the same labels with the nodes of the graphs in its knowledge base are kept as candidates for comparison.
we conducted an evaluation on and vulnerabilities of type and type with the totals of and releases respectively in open source software systems.
the result shows that securesync is highly accurate.
it is able to correctly locate most of vulnerable code in the systems that share source code or libraries with the systems in its knowledge base.
interestingly it detects releases having potentially vulnerable code locations i.e.
fragments having vulnerabilities that to the best of our knowledge have not been detected reported or patched yet even in mature systems.
based on the recommendations from our tool we produced the patches for such vulnerabilities and reported to the developers of those systems.
some of such vulnerabilities and patches were actually confirmed.
the contribution of this paper includes .
an empirical study that confirms the existence of recurring similar software vulnerabilities and our aforementioned software reuse hypothesis and provides us insights on their characteristics .
two representations and algorithms to detect recurring vulnerabilities on systems sharing source code and or api libraries .
securesync an automatic prototype tool that detects recurring vulnerabilities and recommends the resolution for them and4.
an empirical evaluation of our tool on real world datasets of vulnerabilities and systems that shows its accuracy and usefulness.
section reports our empirical study on recurring vulnerabilities.
sections and present the overview of our approach and detailed techniques.
the empirical evaluation is in section .
related work is discussed in section and conclusions appear last.
.
empirical study .
hypotheses and process hypotheses .
in this study our research is based on the philosophy thatsimilar code tends to have similar properties .
in the context of this paper the similar properties are bugs programming flaws or vulnerabilities.
due to software reuse in reality there exist many systems that have similar code and or share libraries components.
for example they could be developed from a common framework share some code fragments due to the copy and paste programming practice use the same apis libraries or implement the same algorithms or specifications etc.
therefore we make hypotheses that h1 there exist software vulnerabilities recurring in different systems and h2 one of the causes of such existence is software reuse.
in this study we use the following important terms.
terminology .
asystem is a software product program module or library under investigation e.g.
firefox thunderbird etc .
a release refers to a specific release version of a software system e.g.
firefox .
.
thunderbird .
.
.
a vulnerability is an exploitable software fault occurring on specific release s of a system.
for example cve reported a vulnerability on firefox .
.
to .
.
.
a recurring vulnerability is a vulnerability that occurs and should be fixed patched on at least two different releases of the same or different systems .
this term also refers to a group of vulnerabilities having the same causes on different systems releases.
examples of recurring vulnerabilities are in section .
.
analysis process .
to confirm those two hypotheses we considered around vulnerability reports in several security databases national vulnerability database nvd open source computer emergency response team advisories ocert mozilla foundation security advisories mfsa and apache security team asf .
generally each report describes a vulnerability thus a recurring vulnerability would be described in multiple reports.
since it is impossible to manually analyze all those reports we used a textual analysis technique to cluster them into different groups having similar textual contents and manually read such groups.
fortunately some of such groups really report recurring vulnerabilities.
sometimes one report such as in ocert describes more than one recurring vulnerabilities.
to verify such recurring vulnerabilities and gain more knowledge about them e.g.
causes and patches we also collected and analyzed all available source code bug reports discussions relevant to them.
let us discuss representative examples and then present detailed results.
.
representative examples example .
in cve it is reported that a vulnerability allows remote attackers to bypass the protection mechanism for codebase principals and execute arbitrary script via the mozbinding css property in a signed jar file .
importantly this vulnerability recurs in different software systems all versions of firefox .x before .
.
firefox .x before .
.
.
and seamonkey .x before .
.
have this vulnerability.
figure shows the vulnerable code fragments extracted from firefox .
.
and seamonkey .
.
.
figure shows the corresponding patched code in firefox .
.
.
as we could see the vul448a vulnerable code in firefox .
.
prbool nsxblbinding allowscripts ... jscontext cx jscontext context getnativecontext nscomptr nsidocument ourdocument mprototypebinding xbldocumentinfo getdocument getter addrefs ourdocument vulnerable code allows remote attackers to bypass the protection mechanism for codebase principals and execute arbitrary script via the moz binding css property in a signed jar file prbool canexecute nsresult rv mgr canexecutescripts cx ourdocument nodeprincipal canexecute return ns succeeded rv canexecute b vulnerable code in seamonkey .
.
prbool nsxblbinding allowscripts ... jscontext cx jscontext context getnativecontext nscomptr nsidocument ourdocument mprototypebinding xbldocumentinfo getdocument getter addrefs ourdocument nsiprincipal principal ourdocument getprincipal if !principal return pr false similarly vulnerable code prbool canexecute nsresult rv mgr canexecutescripts cx principal canexecute return ns succeeded rv canexecute figure recurring vulnerability in firefox and seamonkey due to reusing vulnerable source code nerable code was patched by adding more checking mechanisms via two functions gethascertificate and subsumes .
the vulnerable code in seamonkey is identically patched however due to the space limit it is not shown here .
analyzing deeper we figure out that the vulnerability is recurring due to the reuse of source code .
in figure the vulnerable code fragments are highly similar.
that is because firefox and seamonkey are developed from the common framework mozilla they largely share source code including the vulnerable code in those fragments.
this example is a representative example of the recurring vulnerabilities that we classify as type denoted by rv1 .
the vulnerabilities of this type are recurring due to the reuse of source code.
that is a code fragment in one system has some undetected flaws and is reused in another system.
then when the flaws are exploited as a vulnerability the vulnerability is recurring in both systems.
generally the reuse could be made via copy and paste practice or via branching the whole code base to create a new version of a system.
in other cases systems could be derived from the same codebase framework but are later independently developed as a new product.
as we could see due to reuse the vulnerable code tends to be highly similar in texts e.g.
names of called functions variables names values of literals etc and in structure e.g.
the structure of statements branches expressions etc .
due to this nature those similar features could be used to identify them.
a special case of type is related to different releases of a system e.g.
firefox .x and .x in this example .
generally such versions releases are developed from the same codebase e.g.
later versions are copied from earlier versions thus likely have the same vulnerable code.
when vulnerable code is fixed in the later versions it should also be fixed in the earlier versions.
this special kind of patching is referred to as backporting .
example .
openssl an open source implementation of ssl and tls protocols provides a library named evp as a high level interface to its cryptographic functions.
as described in evp documentation evp has a protocol for signature verification which could be used in the following procedure.
first evp verifyinit is called to initialize a verification context object.
then evp verifyupdate is used to hash the data for verification into that verification context.
finally that data is verified against corresponding public key s via evp verifyfinal .evp verifyfinal would return one of three values if the data is verified to be correct if it is incorrect and if there is any failure in the verification process .
however the return value of is overlooked by several developers.
they thought that evp verifyfinal would return only twovalues and for correct and incorrect verification.
therefore in several systems the flaw statement if !evp verifyfinal ... is used to check for some error s in verification.
thus when evp verifyfinal returns i.e.
a failure occurs in the verification process the control expression is false as in the case when is returned.
that is the program would behave as if the verification is correct i.e.
it is vulnerable to this exploitation.patched code in firefox .
.
prbool nsxblbinding allowscripts .... jscontext cx jscontext context getnativecontext nscomptr nsidocument ourdocument mprototypebinding xbldocumentinfo getdocument getter addrefs ourdocument patched code prbool canexecute nsresult rv mgr canexecutescripts cx ourdocument nodeprincipal canexecute if ns failed rv !canexecute return pr false prbool havecert doc nodeprincipal gethascertificate havecert if !havecert return pr true prbool subsumes rv ourdocument nodeprincipal subsumes doc nodeprincipal subsumes return ns succeeded rv subsumes figure patched code of vulnerability in figure from cve and cve this programming flaw appeared in two systems ntp and gale using evp and really caused a recurring vulnerability that allows remote attackers to bypass validation of the certificate chain via a malformed ssl tls signature for dsa and ecdsa keys .
figure shows the corresponding vulnerable code that we found from ntp .
.
and gale .
.
despite detailed differences both of them use the signature verification protocol provided by evp and incorrectly process the return value of evp verifyfinal by the aforementioned ifstatement.
we classify this example into type i.e.
api shared reused recurring vulnerability denoted by rv2 .
the vulnerabilities of this type occur in the systems that share apis libraries.
generally apis should be used following a usage protocol specified by api designers.
for example the api functions must be called in the correct orders the input output provided to returned from an api function call must be properly checked.
however developers could wrongly use such apis i.e.
do not follow the intended protocols or specifications.
they could call the functions in an incorrect order miss an essential call pass an unchecked wrong typed input parameter or incorrectly handle the return value.
since they reuse the same library in different systems they could make such similar erroneous usages thus create similar faulty code and make their programs vulnerable to the same or similar vulnerabilities.
generally each rv2 is related to a misused api function or protocol.
example .
besides those two types the other identified recurring vulnerabilities are classified as type denoted by rv3.
here is an example of this type.
according to cve and cve2006 two systems openssl .
.
and sun solaris when using an rsa key with exponent removes pkcs padding before generating a hash which allows remote attackers to forge a pkcs v1.
signature that is signed by that rsa key and prevents libike from correctly verifying x. and other certificates that use pkcs .
those two systems realize the same rsa encryption algorithm even though with different implementations.
unfortu449vulnerable code in ntp .
.
static int crypto verify ... evp verifyinit ctx peer digest evp verifyupdate ctx u char ep tstamp vallen vulnerable code evp verifyfinal returns correct incorrect and failure.
this expression is false for both and thus verification failure is mishandled as correct verification if !evp verifyfinal ctx u char ep pkt siglen pkey return xevnt sig ...vulnerable code in gale .
intgale crypto verify raw ... ... evp verifyinit context evp md5 evp verifyupdate context data.p data.l for i is valid i key count i ... similarly vulnerable code if !evp verifyfinal context sigs .p sigs .l key crypto i error is valid goto cleanup cleanup evp pkey free key figure recurring vulnerability in ntp and gale due to similar misuse of api nately the developers of both systems make the same mistake in their corresponding implementations of that algorithm i.e.
removes pkcs padding before generating a hash thus make both systems vulnerable to the same exploitation.
generally recurring vulnerabilities of type occur in the systems with the reuse of artifacts at a higher level of abstraction.
for example they could implement the same algorithms specifications or same designs to satisfy the same requirements.
then if their developers made the same implementation mistakes or the shared algorithms specifications had some flaws the corresponding systems would have the same or similar vulnerabilities.
however unlike type and type vulnerable code of type is harder to be recognized localized or matched in those systems due to the wide varieties of implementation choices and differences among systems in design architecture programming language etc.
.
results and implications table summarizes the result of our study.
column report shows the total number of reports we collected and column group shows the total number of groups of reports about recurring vulnerabilities we manually analyzed in each database.
column rvis the number of identified recurring vulnerabilities.
the last three columns display the numbers for each type.
the result confirms our hypotheses h1 and h2.
that is there exist many recurring vulnerabilities in different systems see column rv and those vulnerabilities recur due to the reuse of source code rv1 apis libraries rv2 and other artifacts at higher levels of abstraction e.g.
algorithms specifications rv3 .
note that each group in ocert contains only one report however each report in ocert generally describes several vulnerabilities and many of them are recurring.
thus the number in column rv is larger than that in column group.
the result also shows that the numbers of rv1s source codereused recurring vulnerabilities and rv2s api shared are considerable.
all vulnerabilities reported on mozilla and apache are rv1 because mozilla and apache are two frameworks on which the systems in analysis are developed.
thus such systems share a large amount of code including vulnerable code fragments.
recurring vulnerabilities of type rv3s are less than rv1s and rv2s partly because the chance that developers make the same mistakes in implementing an algorithm might be less than the chance that they create a flaw in shared code or misuse libraries in similar ways.
implications .
the study confirms our hypotheses on recurring software vulnerabilities.
those vulnerabilities are classified in three types based on the artifacts that their systems reuse.
this finding suggests that one could use the knowledge of prior known vulnerabilities in reported systems to detect and resolve not yet reported vulnerabilities recurring in other systems releases that reuse the related source code libraries algorithms etc.
the study also provides some insights about the characteristics of vulnerable code of types and .
type vulnerable code is database report group rv rv1 rv2 rv3 nvd ocert mfsa asf total table recurring software vulnerabilities generally similar in texts and structure while type vulnerable code tends to have similar method calls and similar input checking and output handling before and after such calls.
those insights are used in our detection and resolution of recurring vulnerabilities.
.
approach overview we have developed securesync an automatic tool to support the detection and resolution recommendation for rv1s and rv2s.
the tool builds a knowledge base of the prior known reported vulnerabilities and locates in a given system the vulnerable code fragments that are similar to the ones in its knowledge base.
.
problem formulation to build securesync there are core issues how to represent and measure the similarity of rv1s and rv2s and how to localize the recurring ones in different systems.
securesync represents vulnerabilities via the features extracted from their vulnerable and patched code and calculates the similarity of those vulnerabilities via such features.
feature extraction and similarity measure functions are defined differently for the detection of rv1s and rv2s due to the differences in their characteristics.
the problem of detecting recurring vulnerabilities is formulated as follows.
definition f eature and similarity .two functions f andsim are called the feature extraction and similarity measure functions for the code fragments.
f a is called the feature set of a fragment a.sim a b is the similarity measurement of two fragments aandb.
definition r ecurring vulnerable code .given a vulnerable code fragment aand its corresponding patched code a .
if a code fragment bis sufficiently similar to aand less similar to a i.e.sim b a andsim b a sim b a thenbis considered as a recurring vulnerable code fragment of a. is a chosen threshold.
aanda could be similar because a is modified from a. thus bcould be similar to both aanda .
the second condition requires bto be more similar to vulnerable code than to patched code.
definition d etecting recurring vulnerability .
given a knowledge base as a set of vulnerable and patched code function detect p k detect recurring vulnerability 2c candidates p k produce candidates foreach fragment b2c check against knowledge base for recurring if9 a a 2k sim b a sim b a sim b a reportandrecommend b figure detection of recurring vulnerabilities fragments k a1 a a2 a an a n and a program as a set of code fragments p b1 b2 b m .
find fragment s bi s that are recurring vulnerable code of some fragment aj.
.
algorithmic solution and techniques the general process for detection of rv1s and rv2s is illustrated in figure .
first securesync produces candidate fragments from the program punder investigation line .
then each candidate is compared against vulnerable and patched code of the vulnerabilities in the knowledge base kto find the recurring ones lines .
detected vulnerabilities are reported to the users with the recommendation.
this algorithm requires the following techniques.
feature extraction and similarity measure .
for rv1s the tool uses a tree based representation called extended ast xast that incorporates textual and structural features of code fragments.
the similarity of fragments is computed based on the similarity of such trees via exas an approach for structural approximation and similarity measure of trees and graphs .
for type securesync uses a novel graph based representation called xgrum.
each code fragment is represented as a graph in which nodes represent function calls variables operators and branching points of control statements e.g.
if while and edges represent control data dependencies between nodes.
with this securesync could represent the api usage information relevant to the orders of function calls the checking of inputs or handling of outputs of function calls.
then the similarity of code fragments is measured by the similarity of those xgrums based on their aligned nodes see section .
building knowledge base of reported vulnerabilities .
we build the knowledge base for securesync using a semi automated method.
first we access to vulnerability databases and manually analyze each report to choose vulnerabilities.
then using code search we find the corresponding vulnerable and patched code for the chosen vulnerabilities.
we use securesync to automatically produce corresponding xasts and xgrums from those collected code fragments as their features.
note that this knowledge building process could be fully automated if the vulnerability databases provide the information on the vulnerable and corresponding patched code.
producing candidate code fragments .
after having functions for feature extraction similarity measure and the knowledge base securesync produces code fragments from the program under investigation to find recurring vulnerable code using definition .
to improve the detection performance securesync uses a text based filtering technique to keep for further processing only the files having some tokens i.e.
words identical or similar to the names of the functions in vulnerable code in the knowledge base.
recommending patches .
for type with the nature of source code reuse the patch in the knowledge base might be applicable to the detected vulnerable code with little modification.
thus securesync does recommendation by pointing out the vulnerable statements and the sample patch taken from its knowledge base.
for type with the nature of api usage via its graph alignment algorithm securesync suggests the addition of missed function calls or the checking of inputs outputs before after the calls etc.
canexecutescripts nodeprincipal nsiscriptsecuritymanager jscontextassign nsresult nscomptr nsidocument prbool nsresult rv mgr canexecutescripts cx ourdocument nodeprincipal canexecute canexecutescripts nsiprincipal nsiscriptsecuritymanager jscontextassign nsresult prbool nsresult rv mgr canexecutescripts cx principal canexecute a. xast tree in firefox b. xast tree in seamonkey figure xast from code in figure .
type vulnerability detection to detect type recurring vulnerabilities securesync represents code fragments including vulnerable and patched code in its knowledge base via an ast like structure which we call extended ast xast .
an xast is an augmented ast in which a node representing a function call a variable a literal or an operator has its label containing the node s type the signature the data type the value or the token of the corresponding program entity.
this labeling provides more semantic information for the tree e.g.
two nodes of the same type of function call with different labels would represent different calls .
figure illustrates two xasts of similar vulnerable statements in figure .
two trees have mostly similar structures and nodes labels e.g.
the nodes representing the function calls canexecutescripts the variables of data type nsresult etc.
for simplicity the node types or parameter lists are not drawn .
.
feature extraction and similarity measure securesync extracts from a code fragment aa feature set f a which is defined as a set of xasts each represents a statement in a. for instance vulnerable code fragments in figure have feature sets of and xasts respectively.
the similarity of two fragments is measured via the similarity of corresponding feature sets.
securesync uses exas to approximate the xast structures and measure their similarity.
using exas each xast or a set of xasts tis represented by a characteristic vector of occurrencecounts of its structural features ex t .
for a tree a structural feature is a sequence of labels of the nodes along a limited length path.
for example both trees in figure have a feature and a feature .
the similarity of fragments is measured based on the manhattan distance of corresponding exas vectors of their feature sets sim a b jex f a ex f b j jex f a j jex f b j .
this formula normalizes vector distance with the vectors sizes.
thus with the same threshold for similarity larger trees which have larger vectors are allowed to have more different vectors.
.
candidate searching a vulnerable code fragment of type generally scatters in several non consecutive statements see figure .
thus traditional 451code clone detection techniques could not handle well such similar non consecutive fragments.
to address that and to find the candidates of such vulnerable code fragments securesync compares every statement of pto vulnerable code statements in its knowledge base and merges such statements into larger fragments.
to improve searching securesync uses two levels of filtering.
text based filtering .
text based filtering aims at filtering out the source files that do not have any code textually similar to vulnerable code in the knowledge base.
for each file securesync does lexical analysis and keeps only the files that contain the tokens and words e.g.
identifiers literals identical or similar to the names in the vulnerable code e.g.
function variable names literals .
this text based filtering is highly effective.
for example in our evaluation after filtering a program with more than source files securesync keeps only about files.
structure based filtering .
structure based filtering aims at keeping only the statements that potentially have similar xast structures to the vulnerable ones in knowledge base.
to do this securesync uses locality sensitive hashing lsh .
lsh scheme provides the hash codes for the vectors such that the more similar the two vectors are the higher probability they would have the same hash code .
securesync first parses each source file kept from the previous step into an xast.
then for each sub tree representing a statement sin the file it extracts an exas feature vector ex s .
to check whether statement sis similar to a statement t in the knowledge base securesync compares lsh codes of ex s with those of ex t .
ifex s andex t have some common lsh code they are likely to be similar vectors thus sandttend to have similar xast structures.
for faster processing every statementtof the vulnerable code in knowledge base is pre hashed into a hashing table.
thus if a statement sdoes not share any hash code in that hash table it will be disregarded.
candidate producing and comparing .
after the previous step securesync has a set of candidate statements that potentially have similar xast structures with some statement s in vulnerable code in its knowledge base.
securesync now merges consecutive candidate statements into larger code fragments generally within a method.
then candidate code fragments will be compared to vulnerable and patched code fragments in the knowledge base using definition and formula .
.
based on the lsh table securesync compares each candidate bwith only the code fragment s ain the knowledge base that contain s the statements ts correspondingly having some common lsh codes with the statements ss inb.
.
detection of renaming when reusing source code developers could make modifications to the identifiers names of the code entities.
for example the function ap proxy send dir filter in apache .
.x was renamed to proxy send dir filter in apache .
.x.
because the features of xasts rely on names such renaming could affect the comparison of code fragments in different systems versions.
this problem is addressed by an origin analysis process that provides the name mapping between two versions of a system or two code sharing systems.
using such mapping when producing the features of xasts for candidate code fragments securesync uses the mapped names instead of the names in the candidate code thus avoids the renaming problem.
to map the names from such two versions currently securesync uses an origin analysis technique in our prior work operv .
operv models a software system by a project tree i.e.
a tree based structure of program elements.
it does origin analysis using a tree alignment algorithm that compares two project trees based on the similarity of the sub trees and provides the mapping of the nodes.
.
type vulnerability detection .
representation type vulnerabilities are caused by the misuse or mishandling of apis.
therefore we emphasize on api usages to detect such recurring vulnerabilities.
if a candidate code fragment bhas similar api usages to a vulnerable code fragment a bis likely to have a recurring vulnerability with a. in securesync an api usage is represented as a graph based model in which nodes represent the usages of api function calls data structures and control structures and edges represent the relations or control data dependencies between them.
our graph based representation for api usages called extended graph based usagemodel xgrum is as follows definition xgrum .
each extended graph based usage model is a directed labeled acyclic graph in which .
each action node represents a function or method call .
each data node represents a variable .
each control node represents the branching point of a control structure e.g.
if for while switch .
each operator node represents an operator e.g.
not and or .
an edge connecting two nodes xandyrepresents the control and data dependencies between xandy and .
the label of an action data control and operator node is the name data type or token of the corresponding function variable control structure or operator along with the node type.
the rationale behind this representation is as follows.
the usage of an api function or data structure is represented as an action or data node.
the order of two api function calls e.g.
xmust be called before y is represented by an edge connecting the action nodes corresponding to the calls to xand to y. the checking of input or output of api functions is modeled via the control and operator nodes surrounding the action nodes of those function calls and via the edges between such control operator and action nodes.
figure partially shows xgrums of two vulnerable code fragments in figure and one patched code fragment.
due to the space limit only the nodes edges related to api usages and the vulnerabilities are drawn .
the xgrums have the action nodes representing function calls evp verifyfinal evp verifyinit data node evp md ctx control nodes if for and operator nodes not leq.
an edge from evp verifyupdate toevp verifyfinal represents both their control dependency i.e.
evp verifyupdate is used before evp verifyfinal and the data dependency those two nodes share data via data node evp md ctx .
the edge between evp md ctx and evp verifyfinal shows that the corresponding variable is used as an input for evp verifyfinal as well as an output since the variable is a reference .
the edge from action node evp verifyfinal to control node ifshows the control dependency evp verifyfinal is called before the branching point of that ifstatement.
that is the condition checking with that ifstatement occurs after the call.
especially operator node notrepresents the operator in the control expression !evp verifyfinal ... .
it has control dependencies with two nodes evp verifyfinal and if.
in figure 6c the control expression is modified into evp verifyfinal ... .
thus that operator node not is replaced by the operator leqand the data node integer is added for the literal value zero.
a literal is modeled as a special data node and its label is formed by the data type and value.
securesync models only the literals of supported primitive data types e.g.
integer float string and special values e.g.
null empty string .
prior work showed that bugs often occur at the condition checking points of such special values.
currently securesync uses intra procedural data analysis to find the data dependencies between graph nodes.
for example the data depen452evp verifyinit evp verifyupdate evp verifyfinal return if leqevp md ctx integer evp verifyinit evp verifyupdate evp verifyfinal crypto i error if not evp md ctx evp pkey free evp md5 evp verifyinit evp verifyupdate evp verifyfinal return if not evp md ctx fora.
vulnerable api usage in gale b. vulnerable api usage in ntp c. patched api usage in ntp evp pkey figure xgrums from vulnerable and patched code in figure dency between evp verifyinit evp verifyupdate and evp verifyfinal are found via their connections to the data node evp md ctx .
.
feature extraction and similarity measure each vulnerable code fragment ais represented by an xgrum g. extracted features of arepresent the nodes of gthat are relevant to misused apis.
note that not all nodes in gis relevant to the misused api functions.
for example in example only evp verifyfinal is misused evp verifyinit and evp verifyupdate are correctly used.
thus the feature of the vulnerability should emphasize on the action node evp verifyfinal operator node not control node if and data node evp md ctx and of course on the edges i.e.
the control and data dependencies between such nodes.
for rv2s features are extracted from the comparison between two xgrums representing the vulnerable and patched code respectively.
securesync finds the nodes related to misused apis based on the idea that if program entities are related to the bug they should be changed affected by the fix.
since securesync represents program entities and dependencies via labels and edges changed affected entities are represented by the nodes having different labels or neighborhoods or being added deleted.
that is the unchanged nodes between two xgrums of vulnerable and patched code are considered to represent the entities irrelevant to api misuse.
thus the sub graphs containing changed nodes in those two xgrums are considered as the features of the corresponding vulnerability.
to find the changed and unchanged nodes securesync uses the following approximate graph alignment algorithm.
.
.
graph alignment algorithm this algorithm aligns i.e.
maps the nodes between two xgrums gandg based on their labels and neighborhoods then the aligned nodes could be considered as unchanged nodes and not affected by the patch.
the detailed algorithm is shown in figure .
for each nodeuinto a graph securesync extracts an exas vector n u to represent the neighborhood of u. the similarity of two nodes u2gandv2g sim u v is calculated based on the vector distance of n u andn v as in formula .
if they have the same label see lines otherwise they have zero similarity.
then the maximum weighted matching with such similarity as weights is computed line .
only matched nodes with sufficiently high similarity are kept lines and returned as aligned nodes line .
.
.
feature extraction and similarity measure using that algorithm securesync extracts features as follows.
it first parses the vulnerable and corresponding patched code fragments aanda into two xgrums gandg .
then it runs the graph alignment algorithm to find the aligned nodes and considered them as unchanged.
unaligned nodes are considered as changed function align g g align and compare two usage models forallu2g v2g calculate similarity of all nodes.
iflabel u label v sim u v jn u n v j jn u j jn v j 5m maximumweightedmatching u u sim matching foreach u v 2m ifsim u v thenm remove u v remove too low matches 8return m figure graph alignment algorithm and the subgraphs formed by such nodes in gandg are put into the feature sets f a andf a for the current vulnerability.
let us examine the code in figure .
figure 6b and figure 6c display the xgrums gandg of vulnerable code and patched code fragments in ntp.
the neighborhood structures of two nodes labeled evp verifyinit in two graphs are identical thus they are identical.
the similarity of two nodes labeled evp verifyfinal is less similar because they have different neighborhood structures one has a neighbor node not one has leq .
therefore after maximum matching those two evp verifyinit nodes are aligned.
however the nodes evp verifyfinal and other nodes representing operators not leqand literal integer are considered as changed nodes.
then each feature set f a andf a contains the corresponding subgraph with those changed nodes in gray color in figures 6b and 6c.
similarity measure .
given a code fragment bwith the corresponding xgrum h. securesync measures the similarity of b against ain the database based on the usages of api functions that are mis used in aand re used in b. to find such api usages securesync aligns handf a which contains the changed nodes representing the entities related to the misused api functions in a. this alignment also uses the aforementioned graph alignment algorithm with a smaller similarity threshold because the difference between bandamight be larger than that of a anda.
assume that the sets of aligned nodes are m a andm b .
securesync builds two xgrums u a andu b containing the nodes in m a andm b as well as their dependent nodes and edges in gandh respectively.
since m a andm b contain the nodes related to api functions that are mis used in aand are re used in b u a andu b will represent the corresponding api usages in aand in b. then the similarity between aandb is measured based on the similarity between u a andu b sim a b jex u a ex u b j jex u a j jex u b j .
this formula is in fact similar to formula .
.
the only different is that ex u a andex u b are exas vectors of two 453xgrums not xasts.
in figures 6a and 6b m a andm b will contain the action node evp verifyfinal operator node notand control node if.
then u a andu b will be formed from them and their data control dependent nodes such as evp verifyinit evp verifyupdate and evp md ctx .
in figure 6a nodes evp pkey free for evp pkey and crypto i error are also included in u a .
their similarity calculated based on formula .
is .
.
candidate searching similarly to the detection of rv1s securesync uses origin analysis to find renamed api functions between systems and versions.
then it also uses text based filtering to keep only source files and xgrums that contain tokens and names similar to misused api functions stored as the features in its database.
after such filtering securesync has a set of xgrums that potentially contain similarly misused api functions with some xgrums in the vulnerable code in its database.
then the candidate xgrums of code fragments are compared to xgrums of vulnerable and patched code fragments in the database using definition and formula .
.
matched candidates are recommended for patching.
.
evaluation this section presents our evaluation of securesync on real world software systems and vulnerabilities.
the evaluation is separated into two experiments for the detection of rv1s and rv2s.
each experiment has three steps selecting of vulnerabilities and systems for building knowledge base investigating and running and analyzing results.
let us describe the details of each experiment.
.
rv1 detection evaluation selecting .
we chose mozilla based open source systems firefox thunderbird and seamonkey for the evaluation of rv1 because they are actively developed and maintained and have available source code security reports forums and discussions.
first we contacted and obtained the release history of those systems from mozilla security team.
for each system we chose a range of releases that are currently maintained and supported on security updates with the total of releases for systems.
the numbers of releases of each system is shown in column release of table .
we aimed to evaluate how securesync uses the knowledge base of vulnerabilities built from the reports in some releases of firefox to detect the recurring ones in thunderbird and seamonkey and also in different firefox s release branches in which those vulnerabilities are not reported yet.
thus we selected vulnerabilities reported in the chosen releases of firefox with publicly available vulnerable code and corresponding patched code to build the knowledge base for securesync.
in the case that a vulnerability occurred and was patched in several releases of firefox i.e.
there were several pairs of vulnerable and patched code fragments we chose only one pair to build its features in the database.
running .
with the knowledge base of those vulnerabilities we ran securesync on chosen releases.
for each release securesync reported the locations of vulnerable code if any .
we analyzed those results and considered a vulnerability vto be correctly detected in a release rif either vis officially reported about r or the code locations of rreported by securesync have the same or highly similar programming flaws to the vulnerable code of v. we also sent the reports from securesync to mozilla security team for their confirmation.
we did not count the cases when a vulnerability is reported on the release or branch from which the vulnerable and patched code are used in the database since a vulnerability is considered recurring if it occurs on different release branches.systems release db ss x x x miss reportreport in db new in dbthunderbird122133 seamonkey firefox total table rv1 detection evaluation prbool nsxblbinding allowscripts ... jscontext cx jscontext context getnativecontext nscomptr nsidocument ourdocument mprototypebinding xbldocumentinfo getdocument getter addrefs ourdocument nsiprincipal principal ourdocument getprincipal if !principal return pr false prbool canexecute nsresult rv mgr canexecutescripts cx principal canexecute return ns succeeded rv canexecute ... figure vulnerable code in thunderbird .
.
analyzing .
table shows the analysis result.
vulnerabilities had been officially reported by mfsa and verified by us as truly recurring on thunderbird see column db report .
however securesync reports rv1s column ss report .
the manual analysis confirms that of them see xin db were in fact officially reported i.e.
coverage of and that rv1s are notyet reported andnewly discovered ones see xnew .
thus cases are incorrectly reported column x and are missed miss in db giving the precision of .
the results on seamonkey are even better coverage of and precision of .
the detection of rv1 on different branches of firefox is also quite good coverage of and precision of .
the result shows that securesync is able to detect rv1s with high accuracy.
most importantly it is able to correctly detect the total of not yet reported vulnerabilities in subject systems.
figure shows a vulnerable code fragment in thunderbird .
.
as an example of such not yet reported and patched vulnerabilities.
note that this one is the same vulnerability presented in example .
however it was reported in cve for only firefox and seamonkey and now it is revealed by securesync on thunderbird.
based on the recommendation from our tool we had produced a patch and sent it to mozilla security team.
they had kindly confirmed this programming flaw and our provided patch.
.
rv2 detection evaluation selecting .
out of rv2s identified in our empirical study some have no publicly available source code e.g.
commercial software and some have no available patches.
we found available vulnerable and corresponding patched code for only rv2s and used all of them to build the knowledge base for securesync in this experiment.
for each of those rv2s if it is related to an api function m we used google code search to find all systems using mand randomly chose releases of each system from the result returned by google google could return several systems using m and several releases for each system .
some of those releases have been officially reported to have the rv2s in knowledge base and some have not.
however we did not select the releases containing the vulnerable and patched code that we already used for building the knowledge base.
thus in total we selected rv2s different systems with releases for this experiment.
running and analyzing .
the execution and analysis is similar to the experiment for rv1s.
table shows the analysis result.
for example there is an rv2 related to the misuse of two functions 454api function related system db ss x x x miss to vulnerabilityreleasereportreport in db new in dbseteuid setuid42 ftpd gmalloc objectstream evp verifyfinal dsa verify libcurl rsa public decrypt readsetofcurves dsa do verify ecdsa verify ecdsa do verify total table rv2 detection evaluation seteuid and setuid .
we found releases of different systems using those two functions.
out of are officially reported in cve and cve column db report .
in the experiment securesync reports out of releases as vulnerable.
manually checking confirms to be correct and are incorrect giving precision of .
among correctly reported vulnerabilities are officially reported and others are not yet reported .
securesync missed only one officially reported case.
similarly for the rv2 related to api ftpd it correctly detected unreported releases and wrongly reported on releases.
for other rv2s it generally detects correctly in almost all releases.
manual analyzing of all the cases that securesync missed we found that they are due to the data analysis.
currently the implementation of data analysis in securesync is restricted to intraprocedural.
therefore it misses the cases when checking handling of inputs outputs for api function calls is processed in different methods.
for the cases that securesync incorrectly detected we found the problem is mostly due to the chosen threshold.
in this experiment we chose .
when for the rv2 related to ftpd the number of wrongly detected cases reduces from to however the number of correctly detected cases also reduces from to .
however the results still show that securesync is useful and could be improved with more powerful data analysis.
interesting examples .
here are some interesting cases on which securesync correctly detected not yet reported rv2s.
figure illustrates a code fragment in arronwork having the same vulnerability related to the incorrect usage of evp verifyfinal function as described in section and to the best of our knowledge it has not been reported anywhere.
the code in arronwork has different details from the code in ntp which we chose in building knowledge base .
for example there are different variables and function calls and evp verifyupdate is called three times instead of one.
however it uses the same evp protocol and has the same flaw.
using the recommendation from securesync to change the operator and expression related to the function call to evp verifyfinal we derived a patch for it and reported this case to arronwork s developers.
here is another interesting example.
cve reported multiple integer overflows in glib gbase64.c in glib before .
allow context dependent attackers to execute arbitrary code via a long string that is converted either from or to a base64 representation .
the vulnerable and patched code is in figure the new and removed code are marked with symbols and respectively.
this vulnerability is related to the misuse of function g malloc for memory allocation with a parameter that is unchecked against the amount of available memory len g maxsize and against an integer overflow in the expression len .
using this patch securesync is able to detect a similar flaw in seahorse system in which two functions base64 encoder and de static int ssl3 get key exchange s ... if pkey type evp pkey dsa lets do dss evp verifyinit md ctx evp dss1 evp verifyupdate md ctx s s3 client random ssl3 random size evp verifyupdate md ctx s s3 server random ssl3 random size evp verifyupdate md ctx param param len if !evp verifyfinal md ctx p int n pkey bad signature al ssl3 ad illegal parameter sslerr ssl f ssl3 get key exchange ssl r bad signature goto f err figure vulnerable code in arronwork .
gchar g base64 encode const guchar data gsize len gchar out gint state save outlen g return val if fail data !
null null g return val if fail len null g malloc len if len g maxsize g error input too large for base64 encoding ... out g malloc len outlen g base64 encode step data len false out state save outlen g base64 encode close false out outlen state save out return gchar out figure vulnerable and patched code in glib .
.
coder incorrectly use g malloc and g malloc0 see figure .
the interesting point is that the api function names in two systems are just similar but not identical e.g.
g malloc0 and g malloc g base64 and seahorse base64 .
thus the origin analysis information securesync uses is helpful for this correct detection.
using the alignment between g malloc and g malloc0 when comparing the graphs of two methods in figure with that of the method in figure securesync correctly suggests the fixing by adding the ifstatement before the calls to g malloc and g malloc0 functions respectively.
.
related work our research is closely related to static approaches to detect similarandrecurring bugs.
static approaches could be categorized into two types rule pattern based andpeer based .
the strategy in pattern based approaches is first to detect correct code patterns via mining frequent code usages via mining rules from existing code or predefined rules .
the anomaly usages deviated from such patterns are considered as potential bugs.
in contrast a peer based approach attempts to match the code fragment under investigation against its databases of cases and provides a fix recommendation if a match occurs.
peer based approach is chosen for securesync because a vulnerability must be detected early even though it does not necessarily repeat frequently yet.
it is desirable that a vulnerability is detected even if it matches with one case in the past.
securesync efficiently stores only features for each case.
several bug finding approaches are based on mining of code patterns .
sun et al.
present a template andrulebased approach to automatically propagate bug fixes.
their approach supports some pre defined templates rules e.g.
orders of pairs of method calls condition checking around the calls and requires a fix to be extracted expressed as rules in order to propagate it.
other tools also detect pre defined common bug patterns using syntactic pattern matching .
in contrast to those pattern based approaches securesync is based on our general graph based repre455guchar seahorse base64 decode const gchar text gsize out len guchar ret gint inlen state save inlen strlen text ret g malloc0 inlen out len seahorse base64 decode step text inlen ret state save return ret gchar seahorse base64 encode const guchar data gsize len gchar out gint state outlen save out g malloc len outlen seahorse base64 encode step data len false out state save outlen seahorse base64 encode close false out outlen state save out return gchar out figure vulnerable code in seahorse .
.
sentation for api related code and its feature extraction that could support any vulnerable and corresponding patched code.
jadet and grouminer perform mining object usage patterns and detect violations as potential bugs.
several approaches mine usage patterns in term of the orders of pairs of method calls or association rules .
error handling bugs are detected via mining sequence association rules .
chang et al.
find patterns on condition nodes on program dependence graphs and detect bugs involving neglected conditions.
hipikat extracts lexical information while building the project s memories and recommends relevant artifacts.
song et al.
detect association rules between types of bugs from the project s history for bug prediction.
however those approaches focus only on specific sets of patterns and bugs object usages error handling condition checking .
bugmem uses a textual difference approach to identify changed texts and detects similar bugs.
securesync captures better the contexts of api usages with its graph representation thus it could detect any types of more general api related recurring vulnerabilities than specific sets of bug patterns.
fixwizard is a peer based approach for detecting recurring bugs.
it relies on code peers i.e.
methods classes with similar interactions in the same system thus cannot work across systems.
patch miner finds all code snapshots with similar snippets i.e.
cloned code to the fragment that was fixed.
cp miner mines frequent subsequences of tokens to detect bugs caused by inconsistent editing to cloned code.
jiang et al.
detect clone related bugs via formulating context based inconsistencies.
existing supports for consistent editing of cloned code are limited to interactive synchronization in editors such as clonetracker .
compared to clone related bug detection approaches our detection for code reused vulnerabilities could also handle non continuous clones see figure .
importantly our graph based representation and feature extraction are more specialized toward finding fragments with similar api usages and more flexible to support the detection of api related bugs across systems .
the preliminary study on recurring vulnerabilities was reported in our prior work .
several approaches have been proposed to help localize buggy code using project s change history complexity metrics etc.
vulnerability prediction approaches that rely on projects components and history include .
in software security other researchers study the characteristics of vulnerabilities .
however none of existing software security approaches has studied the relation of recurring vulnerabilities and software reuse.
.
conclusions this paper reports an empirical study on recurring software vulnerabilities.
the study shows that there exist many vulnerabilitiesrecurring in different systems due to the reuse of source code apis and artifacts at higher levels of abstraction e.g.
specifications .
we also introduce an automatic tool to detect such recurring vulnerabilities on different systems.
the core of securesync includes two techniques for modeling and matching vulnerable code across different systems.
the evaluation on real world software vulnerabilities shows that securesync is able to detect recurring vulnerabilities with high accuracy and to identify several vulnerable code locations that are not yet reported or fixed even in mature systems.
.