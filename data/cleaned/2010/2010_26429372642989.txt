improving the accuracy of oracle verdicts through automated model steering gregory gay sanjai rayadurgam mats p .e.
heimdahl department of computer science engineering university of minnesota usa greg greggay.com cs.umn.edu abstract the oracle a judge of the correctness of the system under test sut is a major component of the testing process.
specifying test oracles is challenging for some domains such as real time embedded systems where small changes in timing or sensory input may cause large behavioral differences.
models of such systems often built for analysis and simulation are appealing for reuse as oracles.
these models however typically represent an idealized system abstracting away certain issues such as non deterministic timing behavior and sensor noise.
thus even with the same inputs the model s behavior may fail to match an acceptable behavior of the sut leading to many false positives reported by the oracle.
we propose an automated steering framework that can adjust the behavior of the model to better match the behavior of the sut to reduce the rate of false positives.
this model steering is limited by a set of constraints defining acceptable differences in behavior and is based on a search process attempting to minimize a dissimilarity metric.
this framework allows non deterministic but bounded behavior differences while preventing future mismatches by guiding the oracle within limits to match the execution of the sut.
results show that steering significantly increases sut oracle conformance with minimal masking of real faults and thus has significant potential for reducing false positives and consequently development costs.
categories and subject descriptors d. .
testing and debugging general terms verification keywords software testing test oracles model based testing this work has been partially supported by nsf grants cns0931931 and cns .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september v ster s sweden.
copyright acm ... .
.
introduction when running a suite of tests the test oracle is the judge that determines the correctness of the execution of a given system under test sut .
despite increased attention in recent years the test oracle problem a set of challenges related to the construction of efficient and robust oracles remains a major problem in many domains.
one such domain is that of real time process control systems embedded systems that interact with physical processes such as implanted medical devices or power management systems.
systems in this domain are particularly challenging since their behavior depends not only on the values of inputs and outputs but also on their time of occurrence .
in addition minor behavioral distinctions may have significant consequences .
when executing the software on an embedded hardware platform several sources of non determinism such as input processing delays execution time fluctuation and hardware inaccuracy can result in the sut non deterministically exhibiting varying but acceptable behaviors for the same test case.
behavioral models typically expressed as state transition systems represent the system requirements by prescribing the behavior the system state to be exhibited in response to given input.
common modeling tools in this category are stateflow statemate and rhapsody .
models built using these tools are used for many purposes in industrial software development and thus their reuse as a test oracle is highly desirable.
these models however provide an abstract view of the system that typically simplifies the actual conditions in the execution environment.
for example communication delays processing delays and sensor and actuator inaccuracies may be omitted.
therefore on a real hardware platform the sut may exhibit behavior that is acceptable with respect to the system requirements but differs from what the model prescribes for a given input the system under test is close enough to the behavior described by the model.
over time these differences can build to the point where the execution paths of the model and the sut diverge enough to flag the test as a failure even if the system is still operating within the boundaries set by the requirements.
in a rigorous testing effort this may lead to tens of thousands of false reports of test failures that have to be inspected and dismissed a costly process.
one solution would be to filter the test results on a step by step basis checking the state of the sut against a set of constraints and overriding the oracle verdict as needed.
however filter based approaches are inflexible.
while a filter may be able to handle isolated non conformance between the sut and the oracle model it will likely fail to account for behavioral divergence that builds over time growing with each round of input.
instead we take inspiration for addressing this model sut mismatch problem from program steering the process of adjusting the execution of live programs in order to improve performance stability or correctness .
we hypothesize that behavioral models can be adapted for use as oracles for real time systems through the use of steering actions that override the current execution of the model .
by comparing the state of the model based oracle mbo with that of the sut following an output event we can guide the model to match the state of the sut as long as a set of constraints defining acceptable deviation are met.
unlike a filter steering is adaptable adjusting the live execution of the model within the space of legal behaviors to match the execution of the sut.
the result of steering is a widening of the behaviors accepted by the oracle thus compensating for allowable non determinism without unacceptably impairing the ability of the model based oracle to correctly judge the behavior of the sut.
we present an automated framework for comparing and steering the model based oracle with respect to the sut building on ideas first proposed in .
we detail the implementation of the framework and assess its capabilities on a model for the control software of an patient controlled analgesia pump a medical infusion pump a real world systems with complex time based behaviors.
case study results indicate that steering improves the accuracy of the final oracle verdicts outperforming both default testing practice and step wise filtering.
oracle steering successfully accounts for within tolerance behavioral differences between the model based oracle and the sut eliminating a large number of spurious failure verdicts with minimal masking of real faults.
by pointing the developer towards behavior differences more likely to be indicative of real faults this approach has the potential to lower testing costs and reduce development effort.
.
background there are two key artifacts necessary to test software the test data inputs given to the system under test and the test oracle a judge on the resulting execution .
a test oracle can be defined as a predicate on a sequence of stimuli to and reactions from the sut that judges the resulting behavior according to some specification of correctness .
the most common form of test oracle is a specified oracle one that judges behavioral aspects of the system under test with respect to some formal specification .
commonly such an oracle checks the behavior of the system against a set of concrete expected values or behavioral constraints such as assertions contracts or invariants .
however specified oracles can be derived from many other sources of information we are particularly interested in using behavioral models such as those often built for purposes of simulation analysis and testing .
a common practice during the development and testing of software is to build models of the intended behavior of the final system.
although such models are useful at all stages of the development process particularly during requirements analysis they are particularly useful for addressing two problems in testing models allow analysis and testing activities to begin before the actual implementation is constructed and models are suited to the application of verification and automated test generation techniques that allow us to cover a larger class of scenarios than we can cover manually .
as such models are often executable thus in addition to serving as the basis of test generation models can be used as a source of expected behavior that is used as a test oracle.
executable behavioral models can be divided into declarative models created in formal specification languages and constructivemodels built with state transition languages such as simulink and stateflow statemate finite state machines or other automata structures .
presently we focus our work on constructive statemodel sutinput device output device environment environment input1 analog input2 t input1 input2 t doutput mode time t d d2 input device input1 analog input2 t input1 input2 toutput device output mode time t figure illustration of abstraction induced behavioral differences between the model and the system under test.
transition systems since these are frequently used to model realtime control systems software that monitors and interacts with a physical environment .
non determinism is a major concern in embedded real time systems.
the task of monitoring the environment and pushing signals through multiple layers of sensors software and actuators can introduce points of failure delay and unpredictability.
input and observed output values may be skewed by noise in the physical hardware timing constraints may not be met with precision or inputs may arrive faster than the system can process them.
often the system behavior may be acceptable even if the system behavior is not exactly what was captured in the model a model that by its very nature incorporates a simplified view of the problem domain.
a common abstraction when modeling is to omit any details that distract from the core system behavior in order to ensure that analysis of the models is feasible and useful.
yet these omitted details may manifest themselves as differences between the behavior defined in the model and the behavior observed in the implementation.
to give an example of how these differences manifest themselves consider the model and a corresponding system depicted in figure .
a common abstraction when designing a model is to assume that all actions take place instantly ignoring the reality ofcomputation time.
both the model and the actual implementation receive the same stimuli from the physical environment both process that input through the system and then both issue output back to the environment.
in the model all actions are considered to have taken place at time step t. however in the system computations take time to be completed and the processing of environmental stimulus through hardware layers and software subsystems adds an additional delay to the time at which the system receives that input.
by the time that the system finishes responding to the stimulus at time t delay periods it is unlikely that the output fed to the environment matches the output that the model issued in this case not only do the output timestamps not match but the sut made a mode selection that is entirely different from that of the model .
in systems such as pacemakers or infusion pumps time is a crucially important piece of data and delays can lead to a behavior that is very different from the one produced by a model that abstracts such delays.
furthermore such delays are commonly non deterministic.
repeated application of the same stimulus may not result in the same output if processing time varies.
this raises the question why use models as oracles?
alternative approaches could be to turn to an oracle based on explicit behavioral constraints assertions or invariants or to build declar528ative behavioral models in a formal notation such as modelica.
these solutions however have their limitations.
assertion based approaches only ensure that a limited set of properties hold at particular points in the program .
further such oracles may not be able to account for the same range of testing scenarios as a model that prescribes behavior for all inputs.
declarative models that express the computation as a theory in a formal logic allow for more sophisticated forms of verification and can better account for time constrained behaviors .
however miller et al.
have found that developers are more comfortable building constructive models than formal declarative models .
constructive models are visually appealing easy to analyze without specialized knowledge and suitable for analyzing failure conditions and events in an isolated manner .
the complexity of declarative models and the knowledge needed to design and interpret such models make widespread industrial adoption of the paradigm unlikely.
while there are challenges in using constructive model based oracles it is a widely held view that such models are indispensable in other areas of development and testing such as requirements analysis or automated test generation .
from this standpoint the motivational case for models as oracles is clear if these models are already being built their reuse as test oracles could save significant amounts of time and money and allow developers to automate the execution and analysis of a large volume of test cases.
practitioners are well versed in these models and so these are likely to be less error prone compared to building a new unfamiliar type of oracle.
therefore we seek a way to use constructive model based oracles that can handle the non determinism introduced during system execution on the target hardware.
.
oracle steering in a typical model based testing framework the test suite is executed against both the sut and the model based oracle and the values of certain variables are recorded to a trace file after each execution step.
the oracle s comparison procedure examines those traces and issues a verdict for each test fail if test reveals discrepancies pass otherwise .
when testing a real time system we would expect non determinism to lead to behavioral differences between the sut and the model based oracle during test execution.
the actual behaviors witnessed in the sut may not be incorrect they may still meet the system requirements they just do not match what the model produced.
we would like the oracle to distinguish between correct but non conforming behaviors introduced by nondeterminism and behaviors that are indicative of a fault.
one approach to address this would be to augment the comparison procedure with a filtering mechanism to detect and discard acceptable differences on a per step basis.
for example to address the simple computation time abstraction in figure a filter could simply allow any timestamp within a certain range.
however the issue with filtering on a per step basis is that the effect of nondeterminism may linger on for several steps leading to irreconcilable differences between the sut and the model based oracle.
filters may not be effective at handling growing behavioral divergence.
if the time of input or output impacts behavior such as in the case of a pacemaker a system where even a single delayed input may impact all future commanded paces a filter is unlikely to make an accurate judgement after the first few comparisons.
to address this problem we take inspiration from program steering the process of adjusting the execution of live programs in order to improve performance stability or behavioral correctness .
instead of steering the behavior of the sut however we steer the oracle to see if the model is capable of matching the sut s behavior.
when the two behaviors differ we backtrack and apply a output mode2 time t ...output mode1 time t ...input1 input2 t original transition taken backtrack consider possible transitions output mode3 time t d d2 ...chose steering target and transition to it.
figure illustration of steering process.
steering action e.g.
adjust timer values apply different inputs or delay or withhold an input that changes the state of the modelbased oracle to a state more similar to the sut as judged by a dissimilarity metric .
oracle steering unlike filters is adaptable.
such actions provide flexibility to handle non determinism while still retaining the power of the oracle as an arbiter.
of course improper steering can bias the behavior of the model based oracle masking both acceptable deviations and actual indications of failures.
nevertheless we believe that by using a series of constraints it is possible to sufficiently bound steering so that the ability to detect faults is still retained.
first a set of tolerance constraints governing the allowable changes to certain variables input internal or output in the model that can be affected by steering.
these constraints define bounds on the non determinism or behavioral deviation that can be accounted for with steering.
for example a pacemaker takes as input timestamped sensed cardiac events and responds by setting the time of the next commanded pace the pulse delivered to the heart .
then if there are no additional sensed events within that time frame the pacemaker will issue an electrical pulse to the appropriate chamber of the heart.
if the model acts on the input after a slight delay and the model acts instantly we might allow steering to adjust the time stamp on an input by up to four milliseconds.
however we might forbid steering from changing the pacemaker s response to that input i.e.
if the pacemaker responds with a status event acknowledged and acted on we might not allow the response to be changed to premature sensed event .
if a pace command occurs at a different time in the system than it does in the model we might within a similar time window allow steering to attempt to adjust the time that the pace command occurs.
second a dissimilarity function dis model state sut state that compares the state of the model to the observable state of the sut.
we seek a minimization of dis snew m ssut dis sm ssut .
that is within the bounds on the search space set by the tolerance constraints we seek the candidate solution with the lowest dissimilarity score to the state of the sut.
there are many different functions that can be used to calculate dissimilarity.
cha provides a good primer on the calculation of dissimilarity .
third a further set of general policy decisions on when to steer.
for example one might decide not to steer unless dis snew m ssut that is one might decide not to steer at all unless there ex5291.
for test in tests .
for step in test .
initialverdict dis sm ssut .
if initialverdict .
oldstate sm .
targetstate searchfornewstate model s m ssut constraints dis .
while dis targetstate s sut dis oldstate s sut .
oldstate targetstate .
targetstate searchfornewstate model s m ssut constraints dis .
transitionmodel model targetstate figure steps in the steering process ists a steering action that results in a model state identical to that observed in the sut.
in other words the new state of the model based oracle following the application of a steering action must be a state that is possible to reach within a limited number of transitions from the current state of the model must fall within the boundaries set by the tolerance constraints and must minimize the dissimilarity function.
we can illustrate steering using the system depicted in figure .
this system takes as input some environmental factor and a time stamp on when the reading was taken.
it then outputs a mode choice and a time stamp on when the mode choice is issued.
the model has abstracted computation time and as a result the model issues a mode choice and time stamp that differs from the sut the sut is subjected to the time delay of the initial input to pass from the environment to the software and the time to perform computations .
although there is clearly non conformance between the model based oracle and the sut the sut may still be operating within the bounds of the system requirements.
thus as depicted in figure we can attempt to steer the model based oracle.
as outlined in figure after obtaining our initial verdict by calculating the dissimilarity function i.e.
the euclidean distance between the state of the sut and the state of the model based oracle the steering procedure would backtrack to the state of the model before receiving the input input input tand evaluate the set of possible transitions from that state through the use of a search algorithm.
the set of candidate solutions is limited by the set of tolerance constraints for example we might allow input input 1new input the value input 1new may fall up to seconds after the original value of input .
then the search selects from the remaining candidates through the use of the dissimilarity function.
finally the candidate solution that results in the lowest observed value of dis snew m ssut is chosen as the new state of the model based oracle.
execution then resumes from the chosen state.
we have implemented the basic steering approach outlined in figure .
our search process is based on smt based bounded model checking which is a natural choice for this problem.
we have a series of constraints that govern steering actions and seek to locate a model state reachable in a limited number of transitions that satisfies those constraints and minimizes a dissimilarity metric.
specifically we make use of the kind model checker and the z3 constraint solver .
a solution to the constraint dis snew m ssut dis sm ssut would give us a model state that is more similar to the behavior of the sut than the original transition taken by the modelbased oracle but carries no guarantee that the satisfying state minimizes the dissimilarity metric.
thus we first check the constraint dis snew m ssut then if an exact match cannot be found and if the steering policy allows inexact matches we apply the modelchecker with this constraint in order to get an initial threshold then iteratively reapply the model checker with new thresholds until we can no longer find a better solution.
the best solution found then becomes the new state of the model based oracle.
.
selecting constraints the efficacy of the steering process depends heavily on the tolerance constraints and policies employed.
if the constraints are too strict steering will be ineffective leaving as many false failure verdicts as not steering at all.
on the other hand if the constraints are too loose steering runs the risk of covering up real faults in the system.
therefore it is crucially important that the constraints to be employed are carefully considered.
often constraints can be inferred from the system requirements and specifications.
for example when designing an embedded system it is common for the requirements documents to specify a desired accuracy range on physical sensors.
if the potential exists for a model system mismatch to occur due to a mistake in reading input from a sensor than it would make sense to take that range as a tolerance constraint on that sensor input and allow the steering algorithm to try values within that range of the canonical test input.
we recommend that users err toward strict constraints.
while it is undesirable to spend time investigating failures that turn out to be acceptable that outcome is preferable to masking real faults.
steering will not fully account for a model that produces incorrect behavior so steering should start with a mature verified model.
to give an example consider a pacemaker.
the pacemaker might take as input a set of prescription values event indicators from sensors in the patient s heart and timer values.
we would recommend that steering be prohibited from altering the prescription values at all as manipulation of those values might cover faults that could threaten the life of a patient.
however as electrical noise or computation delays might lead to issues steering should be allowed to alter the values of the other inputs within certain limits .
the system requirements might offer guidance on those limits for instance specifiying a time range from when a pace command is supposed to be issued to when it must have been issued to be acceptable.
this boundary can be used as to constrain the manipulation of timer variables.
furthermore given the critical nature of a pacemaker a tester might also want to employ a policy where steering can only intervene if a solution can be found that identically matches the state of the sut.
unlike approaches that build nondeterminism into the model steering decouples the specification of nondeterminism from the model.
this decoupling allows testers more freedom to experiment with different sets of constraints and policies.
if the initial set of constraints leaves false failure verdicts or if testers lack confidence in their chosen constraints alternative options can easily be explored by swapping in a new constraint file and executing the test suite again.
using the dissimilarity function to rate the set of final test verdicts testers can evaluate the severity and number of failure verdicts remaining after steering with each set of constraints and gain confidence in their approach.
.
automated testing framework in a typical testing scenario that makes use of model based oracles a test suite is executed against both the system under test and the behavioral model.
the values of the input output and select internal variables are recorded to a trace file at certain intervals such as after each discrete cycle of input and output.
some comparison mechanism examines those trace files and issues a verdict for each test case generally a failure if any discrepancies are detected and apass if a test executes without revealing any differences between 530implementation model issues input to output trace writes output to comparator test suite steerer issues output to issues output to informs of scores.
informs of current state issues state transition result log writes results to steering constraints limits steering actions polls for new scores.
issues input to figure an automated testing framework employing steering.
the model and sut .
as illustrated in figure such a framework can be modified to incorporate automated oracle steering.
no matter the size of the model steering will add additional overhead to the time required to execute tests.
in practice depending on the strictness of the constraints employed and the complexity of the model execution with steering can take anywhere between a few additional seconds of execution to a few additional minutes.
therefore we recommend that testing take place offline rather than attempting to run the model and system in lockstep.
a framework would follow these steps .
execute each test against the system under test logging the values of select variables at each test step.
.
execute each test against the model based oracle and for each step of the test a feed input to the oracle model.
b compare the model output to the sut output.
c if the output does not match the steering algorithm will interface with the model backtracking execution and attempting to steer the model s execution within the specified constraints perhaps consulting dissimilarity metrics used by the comparison module d compare the new output of the model to the sut output and log the new dissimilarity score.
.
issue a final verdict for the test.
.
related work several authors have examined the use of behavioral models as test generation targers for real time systems .
if such models are used to generate tests they can implicitly serve as a test oracle.
for example larsen et al.
model a system as a non deterministic timed automata that is constrained by an environment model.
the combined model serves as an oracle during test execution.
arcuri et al.
also examine the impact of the environment when testing process control systems .
their framework which only models the environment that the system interacts with and eschews the system itself allows limited non determinism in the time that an action can take place as well as certain forms of hardware related non determinism through tester provided probabilities of hardware failure .
savor and seviora proposed a framework where the behavior of the sut is compared to expected behaviors produced by a finite state machine derived from the systemrequirements .
their framework can handle non determinism in process communication by appending signals with an interval on the time of occurence.
this interval is used to construct alternative legal event orderings.
briones and brinksma treat quiescence the lack of system output as a special form of system output and thus offer a behavioral model that is able to capture a range of non deterministic response times from the system under test .
while the above approaches consider forms of non determinism there are a few key differences with our proposed approach since it decouples the model from the rules governing steering.
this decoupling makes non determinism implicit and the approach more generally applicable.
explicitly specified non deterministic behavior would limit the scope of non determinism handled by the oracle to what has been planned for by the developer and subsequently modeled.
it is difficult to anticipate the non determinism resulting from deploying software on a hardware platform and thus such models will likely undergo several revisions during development.
steering instead relies on a set of rule based constraints that may be easier to revise over time.
additionally by not relying on a specific model format steering can be made to work with models created for a variety of purposes.
oracle steering is conceptually similar to dynamic program steering the automatic guidance of program execution .
much of the research in dynamic program steering is concerned with automatic adaptation to maintain consistent performance or a certain reliability level when faced with depleted computational resources .
however kannan et al.
have proposed a framework to assure the correctness of software execution at runtime through corrective steering actions .
their framework serves as a supervisor on program execution checking observed behavior at runtime against a set of assertions and adjusting the behavior of the program whenever an assertion is violated.
this is done under the assumption that the sut is mostly correct and that only minimal control should be exercised.
although their system bears similarities to what we are proposing our goals are very different rather than adjusting the behavior of the live system we apply steering to the test oracle in order to better identify fault indicitive behaviors.
more relevant to our work is microsoft research s spec explorer test generation framework.
their framework explores the possible runs of the executable model by applying steering actions to the model and guiding it through various execution scenarios with the goal of systematically generating test suites.
it can then use the model as an oracle for the generated test by checking whether the sut produces the same behaviors steering through different execution scenarios for test generation as opposed to adjudging system execution.
although spec explorer also steers the actions of a behavioral model their application and goals greatly differ from ours.
they use steering to create tests and do not apply it when checking conformance.
therefore their framework cannot be used to address the instances of non conformance related to non deterministic execution of interest in this report.
.
case study we aim to gain an understanding of the capabilities of oracle steering and the impact it has on the testing process both positive and negative.
thus we pose the following research questions .
to what degree does steering lessen behavioral differences that are legal under the system requirements?
.
to what degree does steering mask behavioral differences that fail to conform to the requirements?
.
are there situations where a filtering mechanism is more appropriate than actively steering the oracle and vice versa?
.
experimental setup overview we have based our model based oracle on the management subsystem of a generic patient controlled analgesia gpca infusion pump .
this subsystem takes in a prescription for a drug as well as several sensor values and determines the appropriate dosage of the drug to be administered to a patient each second over a given period of time.
this case example developed in the simulink and stateflow notations and translated into the lustre synchronous programming language is a complex real time system of the type common in the medical device domain.
details on the size of the simulink model and the number of lines of code in the translated lustre code are provided in table .
table case example information states transitions lustre loc infusion to evaluate oracle steering we performed the following .generated system implementations we approximated the behavioral differences expected from systems running on real embedded hardware by creating alternate versions of the model with non deterministic timing elements.
we also generated mutated versions of both the oracle and each sut with seeded faults section .
.
.generated tests we randomly generated tests for each case example each test steps in length section .
.
.set steering constraints we constrained the variables that could be adjusted through steering and the values that those variables could take on and established dissimilarity metrics to be minimized section .
.
.assessed impact of steering for each combination of sut test and dissimilarity metric we attempted to steer the oracle to match the behavior of the sut.
we compare the test results before and after steering and evaluate the precison and recall of our steering framework contrasted against the general practice of not steering and a step by step filtering mechanism section .
.
.
system and test generation to produce implementations of the example system we created alternative versions of the model introducing realistic nondeterministic timing changes to the systems.
we built a version of the system where the exit of the patient requested dosage period may be delayed by a short period of time and a version of the system where the exit of an intermittent increased dosage period known as a square bolus dose may be delayed.
these changes are intended to mimic situations where due to hardwareintroduced computation delays the system remains in a particular dosage mode for longer than expected.
for the original model and the system under test variants we have also generated mutants faulty implementations by introducing a single fault into each model.
this ultimately results in a total of sut versions two versions with non deterministic timing behavior fifty versions with faults and one hundred versions with both non deterministic timing and seeded faults fifty per timing variation .
the mutation testing operators used in this experiment include changing an arithmetic operator changing a relational operator changing a boolean operator introducing the boolean operator using the stored value of a variable from the previous computational cycle changing a constant expression by adding or subtracting from int and real constants or by negating boolean constants and substituting a variable occurring in an equation with another variable of the same type.
the mutation operators used are discussed at length in a previous report on empirical software testing research and are similar to those used by andrews et.al where the authors found that generated mutants are a reasonable substitute for actual failures in testing experiments .
using a random testing algorithm we generated tests each thirty test steps long.
each test represents thirty seconds of system activity a length appropriate to capture a relevant range of time sensitive behaviors but still short enough to yield a reasonable experiment cost.
these tests were then executed against each model in order to collect traces.
in the models with timing fluctuations we controlled those fluctuations through the use of an additional input variable.
the value for that variable was generated non deterministically but we used the same value across all systems with the same timing fluctuation.
as a result we know whether a resulting behavioral mismatch is due to a seeded timing fluctuation or a seeded fault in the system.
using this knowledge we labeled each test that fails pre steering as failing due to an acceptable timing deviation an unacceptable timing deviation or a seeded fault.
.
steering constraints for this particular case study we have specified the tolerance constraints on steering in terms of limits on the adjustment of the input variables of the system our model based oracle steering framework allows constraints to be placed on internal or output variables as well .
the chosen tolerance constraints include five of the input variables relate to timers within the system the duration of the patient requested bolus dose period the duration of the intermittent square bolus dosage period the lockout period between patient requested bolus dosages the interval between intermittent square bolus dosages and the total duration of the infusion period.
for each of those we placed an allowance of currv al newv al currv al .
e.g.
following steering a dosage duration is allowed to fall within a three second period between one second shorter and two seconds longer than the original prescribed duration.
the remaining input variables are not allowed to be steered.
these constraints reflect what we consider a realistic application of steering we expect issues related to non deterministic timing and thus allow a small acceptable window around the behaviors that are related to timing.
in this study we do not expect any sensor inaccuracy so we do not allow freedom in adjusting sensor based inputs.
similarly as these are medical devices that could harm a patient if misused we do not allow any changes to the inputs related to prescription values.
in this experiment we have made use of two different dissimilarity metrics when comparing a candidate state of the model based oracle to the state of the sut.
the first is the manhattan or city block distance.
given vectors representing the state of the sut and the model based oracle where each member of the vector represents the value of a variable the dissimilarity between the two vectors can be measured as the sum of the absolute numerical distance between the state of the sut and the model based oracle dis sm ssut nx i 1jsm i ssut ij the second is the squared euclidean distance.
given vectors representing the state the dissimilarity between the vectors can be 532measured as the straight line numerical distance between the two vectors.
the squared variant was chosen because it places greater weight on states that are further apart in terms of variable values.
dis sm ssut nx i sm i ssut i a constant difference of is used for differences between boolean variables or values of an enumerated variable.
all numerical values are normalized to a scale using predetermined constants for the minimum and maximum values of each variable.
we must choose a set of variables to compare when calculating a dissimilarity score or oracle verdict .
as we cannot assume that the internal variables of the sut and the model are the same we calculate similarity using the five output variables of the infusion pump the commanded flow rate the current system mode the duration of active infusion a log message indicator and a flag indicating that a new infusion has been requested.
.
evaluation using the generated artifacts without steering we monitored the outputs during each test compared the results to the values of the same variables in the model based oracle to calculate the dissimilarity score and issued an initial verdict.
then if the verdict was a failure dis s m ssut we steered the model based oracle and recorded a new verdict post steering.
as mentioned above the variables used in establishing a verdict are the five output variables of the system.
in section we stated that an alternative approach to steering would be to simply apply a filter on a step by step basis.
we have implemented such a filter for the purposes of establishing a baseline to which we can compare the performance of steering.
this filter compares the values of the output variables of the sut to the values of those variables in the model based oracle and if they do not match checks those values against a set of constraints.
if the output despite non conformance to the model based oracle meets these constraints the filter will still issue a pass verdict for the test.
the filter will allow a test to pass if despite nonconformance values of the output variables in the sut satisfy the following constraints the current mode of the sut is either patient dosage mode or intermittent dosage mode and has not remained in that mode for longer than prescribed duration 2seconds.
if the above is true the commanded flow rate should match the prescribed value for the appropriate mode.
all other output variables should match their corresponding variables in the oracle as we expect a non deterministic duration for the patient dosage and intermittent dosage modes corresponding to the seeded issues in the sut variants this filter should be able to correctly classify many of the same tests that we expect steering to handle.
we compare the performance of the steering approach to both the filter and the default practice of accepting the initial test verdict.
we can assess the impact of steering or filtering using the verdicts made before and after steering by calculating the number of true positives steps where an approach does not mask incorrect behavior the number of false positives steps where an approach fails to account for an acceptable behavioral difference and the number of false negatives steps where an approach does mask an incorrect behavior.table verdicts t true f false p positive n negative .
initial verdict pass post steering fail post steering pass tn fp fail due to timing within tolerance tn fp fail due to timing not in tolerance fn tp fail due to fault fn tp table initial test results when performing no steering or filtering.
raw number of test results followed by percent of total.
verdict number of tests pass .
fail due to timing within tolerance .
fail due to timing not in tolerance .
fail due to fault .
the testing outcomes in terms of true false positives negatives are listed in table .
using these measures we calculate the precision the ratio of true positives to all positive verdicts and recall the ratio of true positives to true positives and false negatives precision tp tp fp recall tp tp fn we also calculate the f measure the harmonic mean of precision and recall in order to judge the accuracy of oracle verdicts f measure precision recall precision recall .
results and discussion when running all tests over the various implementations containing either timing deviations or seeded faults as discussed in section .
using a standard test oracle comparing the outputs from the sut with the outputs predicted by the model based oracle test runs runs indicated that the system under test passed the test the sut and model based oracle agreed on the outputs and runs indicated that the test failed the sut and model based oracle had mismatched outputs .
in an industry application of a model based oracle the failed test would have to be examined to determine if the failure was due to an actual fault in the implementation an unacceptable timing deviation from the expected timing behavior or an acceptable timing deviation that although it did not match the behavior predicted by the model based oracle was within acceptable tolerances a costly process.
given our experimental setup however we can classify the failed tests as to the cause of the failure failure due to timing within tolerances failure due to timing not in tolerance and failure due to a fault in the sut.
this breakdown is provided in table .
as can be seen tests failed even though the timing deviation was within what would be acceptable these can be viewed as false positives and a filtering or steering approach that would have passed these test runs would provide cost savings.
on the other hand the steering or filtering should not pass any of the tests where timing behavior falls outside of tolerance or the tests that indicated real faults.
results obtained from the case study showing the effect of steering on oracle verdicts are summarized in tables and respectively for the two different distance metrics studied.
the numbers 533table distribution of results for steering squared euclidean dissimilarity .
raw number of test results followed by percent of total.
initial verdict pass post steering fail post steering pass .
.
fail due to timing within tolerance .
.
fail due to timing not in tolerance .
.
fail due to fault .
.
table distribution of results for steering manhattan dissimilarity .
raw number of test results followed by percent of total.
initial verdict pass post steering fail post steering pass .
.
fail due to timing within tolerance .
.
fail due to timing not in tolerance .
.
fail due to fault .
.
table distribution of results for step wise filtering.
raw number of test results followed by percent of total.
initial verdict pass post filtering fail post filtering pass .
.
fail due to timing within tolerance .
.
fail due to timing not in tolerance .
.
fail due to fault .
.
table precision recall and f measure values.
technique precision recall f measure no steering .
.
.
filtering .
.
.
steering euclidean .
.
.
steering manhattan .
.
.
are presented as laid out in table .
testing outcomes are first categorized according to the initial verdicts as determined by the model based oracle before steering a fail verdict is further delineated according to its reason a mismatch that is attributable to either an allowable timing fluctuation or an unacceptable timing fluctuation or a fault.
for each category the post steering verdict is presented as both a raw number of test outcomes and as a percentage of total test outcomes.
table shows the corresponding data for the step by step filtering approach.
data from these tables lead to the precision recall and f measure values shown in table for the default testing scenario accepting the initial oracle verdict steering utilizing two different dissimilarity metrics and filtering.
.
allowing tolerable non conformance according to table .
of the tests tests initially fail due to timing related non conformance.
of those tests .
of the total fall within the tolerances set in the requirements.
steering should result in a pass verdict for all those tests.
as the tables show for both dissimilarity metrics steering is able to account for almost all of the situations where non deterministic timing affects conformance while both the model based oracle and the implementation remain within the bounds set in the system specification.
for example in table we see that steering usingthe square euclidian distance would have correctly passed tests where the timing deviation was acceptable tests that without steering failed.
therefore we see a sharp increase in precision over the default situation where no steering is employed from .
when not steering to .
for the squared euclidean metric and to .
for the manhattan metric see table .
where previously developers would have had to manually inspect the more than of all the tests the sum of all fail table to determine the causes for their failures system faults or otherwise they could now narrow their focus to the roughly that still result in failure post steering.
particularly given the large number of tests in this study this reduction represents a significant savings in time and effort removing between and tests that the developer would have needed to inspect manually.
still there were a small number of tests that steering should have been able to account for for the squared euclidean metric and for the manhattan metric .
the reason for the failure of steering to account for allowable differences can be attributed to a combination of three factors the tolerance constraints employed the dissimilarity metric employed and design differences between the sut and the model based oracle.
first it may be that the tolerance constraints were too strict to allow for situations that should have been considered legal.
constraints should be relatively strict after all we are overriding the nominal behavior of the oracle while simultaneously wishing to retain the oracle s power to identify faults.
yet the constraints we apply should be carefully designed to allow steering to handle these allowed non conformance events.
in this case the chosen constraints may have prevented steering from acting.
second the dissimilarity metric does appear to play a small role in the effectiveness of steering.
the squared euclidean metric resulted in higher precision than the manhattan metric .
vs .
indicating that the former was better able to account for tolerable non conformance.
as there is no difference in recall between the two metrics it appears that for this case example the use of the manhattan metric results in a slightly more conservative steering process.
with the manhattan metric the steering approach is more likely to refuse to steer.
however given the similarity in the performance of the two metrics it appears that the set of constraints employed plays a more dominant role in determining the final outcome of steering.
the tolerance constraints applied reduce the space of candidate targets to which the oracle may be steered.
we then use the dissimilarity metric to choose a nearest target from that set of candidates.
thus the relationship between the constraints and the metric ultimately determines the power of the steering process.
however no matter how powerful steering is there may be situations where differences in the internal design of the systems render steering either ineffective or incorrect.
we base steering decisions on state based comparisons but those comparisons can only be made on the portion of the state variables common between the sut and oracle model.
for this experiment we only compared the output variables.
as a result there may be situations where we should have steered but could not as the state of the sut depended on internal factors not in common with the oracle.
in general as the oracle and sut are both ultimately based on the same set of requirements we believe that some kind of relationship can be established between the internal variables of both realizations.
however in some cases the model and sut may be too different to allow for steering in all allowable situations.
the inability of steering to account for tolerable differences for at least some tests in this case study can likely be attributed to the changes made to the sut versions of the models.
.
masking of faults as steering changes the behavior of the oracle and can result in a new test verdict the danger of steering is that it will mask actual faults in the system.
such a danger is concerning but with the proper choice of steering policies and constraints we hypothesize that such a risk can be reduced to an acceptable level.
in this case study steering changed a fault induced fail verdict to pass in forty three tests.
this is a relatively small number only .
of the tests.
although loss in recall is cause for concern when working with safety critical systems given the small number of incorrectly adjusted test verdicts we hypothesize that it is unlikely for an actual fault to be entirely masked by steering on every test in which the fault would otherwise lead to a failure.
just as the choice of tolerance constraints can explain cases where steering is unable to account for an allowable non conformance the choice of constraints has a large impact on the risk of faultmasking.
at any given execution step steering as we have defined here considers only those oracle post states as candidate targets that are reachable from the the given oracle pre state.
however this by itself is not sufficiently restrictive to rule out truly deviant behaviors.
therefore the constraints applied to reduce that search space must be strong enough to prevent steering from forcing the oracle into an otherwise impermissible state for that execution step.
it is therefore crucial that proper consideration goes into the choice of constraints.
in some cases the use of additional policies such as not steering the oracle model at all if it does not result in an exact match with the system can also lower the risk of tolerating behaviors that would otherwise indicate faults.
note that a seeded fault could cause a timing deviation or the same behavior that would result from a timing deviation .
in those cases the failure is still labeled as being induced by a fault for our experiment.
however if the fault induced deviation falls within the tolerances steering will be able to correct it.
in such cases it is unlikely that even a human oracle would label the outcome differently as they are working from the same tolerance limits.
if care is taken when deriving the tolerance constraints from the system requirements steering should not cover any behaviors that would not be permissable under those same requirements.
still as steering carries the risk of masking faults we recommend that it be applied as a focusing tool to point the developer toward test failures likely to indicate faults so that they do not spend as much time investigating non conformance reports that turn out to be allowable.
the final verdict on a test should come from a run of the oracle model with no steering but during development steering can be effective at streamlining the testing process by concentrating resources on those failures that are more likely to point to faults.
.
steering vs filtering in some cases allowable non conformance events could simply be dealt with by applying a filter that in the case of a failing test verdict checks the resulting state of the sut against a set of constraints and overrides the initial oracle verdict if those constraints are met.
the use of a filter is tempting if the filter is effective it is likely to be easier to build and faster to execute than a full steering process.
indeed the results in table appear promising.
the filter performs identically to steering for the initial failures that result from non deterministic timing differences.
it does not issue a pass verdict for timing issues outside of the tolerance limits and it does issue a pass for almost all of the tests where non conformance is within the tolerance bounds.
however when the results for tests that fail due to faults are considered a filter appears much less attractive.
the filter issues a passing verdict for tests that should have failed morethan steering.
this is because a filter is a blunt instrument.
it simply checks whether the state of the sut meets certain constraints when non conformance occurs.
this allowed the filter to account for the allowed non conforming behaviors but these same constraints also allowed a large selection of fault indicating tests to pass.
this makes the choice of constraints even more important for filtering than it is in steering.
the steering process by backtracking the state of the system is able to ensure that the resulting behavior of the sut is even possible that is if the new state is reachable from the previous state .
the filter does not check the possibility of reaching a state it just checks whether the new state is globally acceptable under the given constraints.
as a result steering is far more accurate.
a filter could of course incorporate a reachability analysis.
however as the complexity of the filter increases the reasons for filtering instead of steering disappear.
in fact the success of steering at accounting for allowable nonconformance is somewhat misleading for this case example.
both filtering and steering base their decisions on the output variables of the sut and oracle on the basis that the internal state variables may differ between the two.
for this case study all of the output variables reflect current conditions of the infusion pump how much drug volume to infuse now the current system mode and so forth.
internally these factors depend on both the current inputs and a number of cumulative factors such as the total volume infused and the remaining drug volume.
over the long term non conformance events between the sut and model will build eventually leading to wider divergence.
for example the sut or the model based oracle may eventually cut off infusion if the drug reservoir empties.
as the output variables reflect current conditions mounting internal differences may be missed and the filter may not be able to cope with large scale behavior differences that result from this steady divergence.
steering is able to prevent and account for these long term divergences by actually changing the state of the oracle throughout the execution of the test.
a filter simply overrides the oracle verdict.
it does not change the state of the oracle and as a result a filter cannot predict or handle behavioral divergences once they build beyond the set of constraints that the filter applies.
we can illustrate this effect by adding a single internal variable to the set of variables considered when making filtering or steering conditions a variable tracking the total drug volume infused.
adding this variable causes no change to the results of steering seen in tables and .
however the addition of this internal variable dramatically changes the results of filtering.
the new results can be seen in tables and .
table distribution of results for step wise filtering outputs volume infused oracle .
raw number of test results followed by percent of total.
initial verdict pass post filtering fail post filtering pass .
.
fail due to timing within tolerance .
.
fail due to timing not in tolerance .
.
fail due to fault .
.
because the total volume infused increases over the execution of the test it will reflect any divergence between the model based oracle and the sut.
as steering actually adjusts the execution of the model based oracle this volume counter also adjusts to reflect the changes induced by steering.
thus steering is able to account for the growing difference in the volume infused by the model based 535table precision recall and f measure values for filtering outputs volume infused oracle .
technique precision recall f measure filtering .
.
.
oracle and the volume infused by the sut.
however as the filter makes no such adjustment it is unable to handle the mounting difference in this variable or any other considered variable that reflects change over time .
the filter even if initially effective will fail to account for a large number of acceptable non conformance events ultimately resulting in a precision value barely more effective than not anything at all.
.
summary of results the precision recall and f measure a measure of accuracy for each method accepting the initial verdict steering using two different dissimilarity metrics and filtering are shown in table .
the default situation accepting the initial verdict results in the lowest precision value.
intuitively not anything to account for allowed non conformance will result in a large number of incorrect fail verdicts.
however the default practice does have the largest recall value.
again not adjusting your results will prevent incorrect masking of faults.
filtering on a step by step basis results in higher precision but due to the lack of reachability analysis and state adaptation both of which used by the steering approach the filter masks an unacceptably large number of faults.
steering performs similarly for both of the dissimilarity metrics used in this study.
it is able to adapt the oracle to handle almost every situation where non conforming behaviors are allowed by the system requirements while masking only a few faults in a small number of tests.
the squared euclidean metric results in a higher precision while both metrics obtain an equal recall value.
ultimately we find that steering employing the squared euclidean dissimilarity metric results in the highest accuracy for the final test results.
steering is able to automatically adjust the execution of the oracle to handle non deterministic but acceptable behavioral divergence without covering up most fault indicative behaviors.
we therefore recommend the use of steering as a tool for focusing and streamlining the testing process.
.
threats to v alidity external validity our study is limited to one case example.
we are actively working with domain experts to produce additional systems for future studies.
we believe this systems to be representative of the real time embedded systems that we are interested in and that our results will generalize to other systems in this domain.
we have used simulink and lustre as our modeling and implementation languages rather than more common languages such as c or c .
however systems written in lustre are similar in style to traditional imperative code produced by code generators used in embedded systems development.
a simple syntactic transformation is sufficient to translate lustre code to c code.
we have limited our study to fifty mutants for each version of the case example resulting in a total of mutants.
these values are chosen to yield a reasonable cost for the study particularly given the length of each test.
it is possible the number of mutants is too low.
nevertheless we have found results using less than mutants to be representative and pilot studies have shown that the results plateau when using more than mutants.
internal validity rather than develop full featured system implementations for our study we instead created alternative versionsof the model introducing various non deterministic behaviors and used these models and the versions with seeded faults as our systems under test.
we believe that these models are representative approximations of the behavioral differences we would see in systems running on embedded hardware.
in future work we plan to generate code from these models and execute the software on actual hardware platforms.
in our experiments we used a default testing scenario accepting the oracle verdict and stepwise filtering as baseline methods for comparison.
there may be other techniques particularly other filters that we could compare against.
still we believe that the filter chosen was an acceptable comparison point and was designed as such a filter would be in practice.
construct validity we measure the fault finding of oracles and test suites over seeded faults rather than real faults encountered during development of the software.
given that our approach to selecting oracle data is also based on the mutation testing it is possible that using real faults would lead to different results.
this is especially likely if the fault model used in mutation testing is significantly different than the faults we encounter in practice.
nevertheless as mentioned earlier andrews et al.
have shown that the use of seeded faults leads to conclusions similar to those obtained using real faults in similar fault finding experiments .
.
conclusion and future work specifying test oracles is still a major challenge for many domains particularly those such as real time embedded systems where issues related to timing sensor inaccuracy or the limited computation power of the embedded platform may result in nondeterministic behaviors for multiple applications of the same input.
behavioral models of systems often built for analysis and simulation are appealing for reuse as oracles.
however these models typically provide an idealized view of the system and may struggle to differentiate unexpected but still acceptable behavior from behaviors indicitive of a fault.
to address this challenge we have proposed an automated modelbased oracle steering framework that upon detecting a behavioral difference backtracks and transitions the model based oracle through a search process to a state that satisfies certain constraints and minimizes a dissimilarity metric.
this framework allows non deterministic but bounded behavior differences while preventing future mismatches by guiding the model based oracle within limits to match the execution of the sut.
experiments conducted over an infusion pump system have yielded promising results and indicate that steering significantly increases sut oracle conformance with minimal masking of real faults and thus has significant potential for reducing development costs.
the use of our steering framework can allow developers to focus on behavioral difference indicative of real faults rather than spending time examining test failure verdicts that can be blamed on a rigid oracle model.
there is still much room for future work.
we plan to expand on the selection of case examples in terms of both program size and scope of non determinism as well as examining the impact of different dissimilarity metrics tolerance constraints and steering policies on oracle verdict accuracy improvements to the speed and scalability of the steering framework including the use of alternative search algorithms the use of steering and dissimilarity metrics as methods of quantifying non conformance and their utility in fault identification and location.
.