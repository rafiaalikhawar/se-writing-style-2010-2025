mining succinct predicated bug signatures chengnian sun school of computing national university of singapore suncn comp.nus.edu.sgsiau cheng khoo school of computing national university of singapore khoosc comp.nus.edu.sg abstract a bug signature is a set of program elements highlighting the cause or effect of a bug and provides contextual information for debugging.
in order to mine a signature for a buggy program two sets of execution profiles of the program one capturing the correct execution and the other capturing the faulty are examined to identify the program elements contrasting faulty from correct.
signatures solely consisting of control flow transitions have been investigated via discriminative sequence and graph mining algorithms.
these signatures might be handicapped in cases where the effect of a bug is not manifested by any deviation in control flow transitions.
in this paper we introduce the notion of predicated bug signature that aims to enhance the predictive power of bug signatures by utilizing both data predicates and control flow information.
we introduce a novel discriminative itemset generator mining technique to generatesuccinct signatures which do not contain redundant or irrelevant program elements.
our case studies demonstrate that predicated signatures can hint at more scenarios of bugs where traditional control flow signatures fail.
categories and subject descriptors d. .
testing and debugging debugging aids diagnostics general terms experimentation reliability keywords bug signature statistical debugging feature selection .
introduction debugging is a process to eliminate program defects.
during a debugging session a developer needs first to identify the location of the bug then figure out its cause and finally fix it.
as widely known debugging is a painstaking activity in software development and maintenance phases especially when the symptom or the manifestation of a bug is not right next to where the bug is triggered.
for permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.instance a non crashing defect produces a wrong output at the end of the execution but the cause may be at the very beginning of the program.
such scenarios are likely to take developers much time to discover the cause from the symptom.
bug signature identification is an automatic technique to infer the cause or effect of a bug.
different from fault localization which outputs single suspicious program element each time for debugging a bug signature can capture the bug context comprising multiple elements.
two pioneering studies in bug signature discovery construct the profiles from running the buggy program against a test suite via different structures.
specifically hsu et al.
profile multiple traces of visited basic blocks from a buggy program and perform sequence mining to get common longest sequences in faulty executions as bug signatures.
hong et al.
curl the basic block sequences to form software behavior graphs and apply graph mining algorithm leap to get discriminative subgraphs as bug signatures.
the case studies in both papers have shown that bug signatures carry additional contextual information that further aids developer in comprehending the bugs.
on the other hand these techniques operate on profiles that contain only control flow information.
in addition the inferred bug signatures typically include redundant and or irrelevant information.
reflecting on the outcome of these work we hypothesize that .the effectiveness of bug signatures in detecting bugs can be significantly enhanced if they are inferred from profiles containing predicated data information.
.the quality of bug signatures can be significantly enhanced if it can be succinctly represented.
1ele find nth list f list int n if !f list return null ele f ele f list first bug f list first in the conditional 6should be f ele for int i f list first i n i f ele f ele next return f ele figure code snippet of schedule with a bug at line to illustrate this we consider a concrete example presented in figure .
this piece of code is extracted from a buggy program schedule in siemens benchmarks.given a linked list f list and an integer n this function returns the n th element in the list.
the bug is that at line f list first infor loop test should be f eleinstead.
thus if the list is not empty and f list length n f ele becomes null after n iterations then in n th iteration a dereferencing operation is performed on a null pointer leading to a segmentation fault.
figure shows the control flow graph of this example and the number prefixing each item in the graph identifies a unique basic block a branch or a predicate.
the bug can be tracked during program execution when f ele becomes null after statement i.e.
predicate and iis still less than nafter the subsequent assignment statement i.e.
predicate .
thus f11 16gis one good signature providing adequate contextual information for developers to fix this bug.
the conciseness of the predicated signature in this example becomes clear when we contrast it against the top ranked control flow signature returned from leap which is f1 13g.
while this signature includes the bug location f list first it also contains irrelevant statements.
first statement is the entry of this function unconditionally appearing in every execution with an invocation to find nth no matter whether the execution is correct or faulty.
second statement 13is an exit of this function and it should appear in only correct executions as faulty executions should crash at statement and cannot reach this statement.
figure control flow graph of figure in this paper we propose a novel approach to automatically inferring bug signatures with two distinguished qualities they contain both data and control predicates and they are succinct in capturing bugs cause and or effect.
our case studies reveal that .
data predicated bug signatures possess high bug predicative power.
by comparing with control flow based signatures produced by leap predicated bug signatures have much higher discriminative power to be elaborated in the ensuing sections and they can help in discovering a new class of bugs the manifestation of which do not cause any controlflow deviation in the execution profiles.
.our novel bug signature mining algorithm which is based on itemset generator mining approach can perform much more efficient than the state of the art signature mining algorithm aka.
leap .
.
background .
overall workflow figure depicts the general workflow of bug signature mining.
the initial inputs are a buggy program and a test suite.
the buggy program is instrumented to collect runtime information.
we run the instrumented version against the test suite to get a set of profiles.based on the testing oracle the collected profiles are classified into a correct and a faulty sets.
next the two sets are fed to our signature miner mps to get a top kranked bug signatures based on their defect predictive power.
figure overall workflow to bug signature identification we adopt the instrumentation scheme by liblit et al.. the following is a brief introduction.
more information can be found in branches .
at each conditional statement each trueorfalse branch is associated with a predicate to record whether this branch is taken at runtime.
returns .
at each invocation site to a scalar returning function six predicates are created to capture relation between the returned value rand the constant r r r r6 r 0andr .
scalar pairs .
for each assignment to a scalar variable x all same typed in scope variables and constant expressions are collected into a set v. for each v2v right after this assignment six predicates are created x v x v x v x6 v x v andx v. pointer nullness .
for each assignment to a pointer variable p a predicate p null is created after this assignment.
the first instrumentation described above predicates on conditionals captures control flow information whereas the latter three record data related information.
note that our technique is general and the signature mining algorithm is orthogonal to the instrumentation scheme.
more instrumentation types aliasing among objects def use pairs etc.
can be easily added without affecting the mining algorithm.
after running the instrumented program against the test suite we get a list of profiles each profile containing a set of predicates.
we only retain those predicates which are captured to be true at runtime and discard those that are unobserved or evaluated to false.
table shows profiles collected by running the buggy program in figure .
the column input lists the test cases.
each test case is a pair of which the first element is a list and the second is the parameter n. the list could be null empty i.e.
or non empty e.g.
containing one element and containing three elements .
the column label marks the status of profiles the plus orpositive meaning that the profile corresponds to a correct execution while the minus ornegative representing a faulty execution.
the column predicates shows all the predicates under observation in runtime.
a bullet in a cell i j means that the j th predicate is evaluated to true in the execution corresponding to the i th profile.
taking the profile t2as an example only two branches false and false are taken in runtime.
1to simplify the illustration of our approach we retain all branch predicates and remove all scalar pair predicates except and in figure .
in the real case studies our tool can precisely pinpoint f11 16gamong all predicates.table profiles collected from running the buggy program in figure id input labelpredicates true false true true false false f ele null?
i n?
t1 null t2 t3 t4 t5 table an example database constructed from table id transaction t1 f2g t2 f4 12g t3 f4 11g t4 f4 16g t5 f4 16g .
itemset generator we regard a profile as a set of items each of which is a predicate observed to be true at runtime.
with this itemset representation we can therefore formulate signature identification as an itemset pattern mining task.
furthermore as we aim to mine succinct signatures we are particularly interested in itemset generator a special pattern with minimality property.
in this subsection we provide an overview of the concepts and properties of itemset generators using the profiles depicted in table as the running example.
leti i1 i2 im be a set of distinct items c f g be the set of the positive and negative class labels and dbe a database consisting of ntransactionsf t1 c1 ti ci tn cn g where ti i andci2c.
in the context of debugging icorresponds to the set of predicates instrumented into the buggy program.
the class label identifies executions with correct output whereas identifies faulty executions.
each transaction is a profile consisting of predicates a subset of i. table shows an example dataset constructed from the profiles of table .iof this database isf2 16g.
every element identifies a predicate for example stands for branch predicate true and is data predicate f ele null .
we define two classification functions and for a set of transactions s s f t c 2sjc gands f t c 2sjc g for example d ord denotes all the positive or negative transactions indrespectively.
for an itemset or pattern p i we define tx 2i!2d returning all transactions in dcontaining pattern p. tx p f t c 2djp tg thesupport ofpis defined as the number of transactions containingp i.e.sup p jtx p j moreover sup p jtx p j andsup p jtx p j. the support of itemsets satisfies the following property stated in .
property apriori .given a pattern p i 8p0 i ifp0 p then tx p0 tx p and further sup p0 sup p andsup p0 sup p taking the database in table as an example given a pattern f4g and its supersetf4 7g tx f4g returns transactions ft2 t3 t4 t5g andtxf4 7greturns transactions ft3 t4 t5g hence sup f4 7g sup f4g .definition equivalence relation .given an itemset databaseddefined over a set of items i the function tx 2i!2dinduces an equivalence relation don2isuch that for all itemset patterns p1 p222i p1 dp2if and only if tx p1 tx p2 .
furthermore the equivalence class of a pattern pis defined asfp0 ijtx p0 tx p g. a b c figure three equivalence classes of table thus all patterns in an equivalence class are contained in the same set of transactions.
in an equivalence class all the minimal patterns are referred to as generators .
generators have the following property which has been proved in .
property generator .a pattern pis a generator if and only if for every proper subset p0 p sup p sup p0 .
figure displays three equivalence classes in the database of table .
each equivalence class is a lattice structure consisting of all patterns in the class.
a node in a lattice represents a unique pattern.
the links between nodes represent set relations superset andsubset .
the bottom nodes of a lattice are generators.
the footnote below each lattice lists the support and transaction information.
figure 4a is the equivalence class of transactions ft4 t5g andf16gis the generator as its subset has support sup greater than sup f16g .
the same reason applies to figure 4b and figure 4c.
.
leap signature miner in this paper we compare our technique with the state of the art signature miner leap proposed in hong et al.
first profile eachprogram execution as a trace of basic blocks then curl the basic block sequences to form software behavior graphs and apply graph mining algorithm leap to get discriminative subgraphs as bug signatures subgraphs which are frequently observed in faulty executions but rarely in correct ones.
the discriminativeness of signatures is measured by information gain which will be detailed in equation .
.
problem formulation .
bug signature an interesting observation is that in figure 4b the generator f11 16gappears only in all the faulty profiles.
this generator is the signature we are aiming to identify as it is highly correlated to faulty executions.
furthermore this generator carries as much predictive information as any supersets in the same equivalence class as they all account for the same set of execution profiles.
for example the supersets f4 16g f7 16gandf9 16g are all observed in the only faulty profile t5.
from the viewpoint of program semantics predicate false true or true is redundant as they are the necessary condition for execution to trigger the bug statement .
in other words given the signature f11 16g we can infer that predicates are also observed true in the same set of profiles as the signature.
in the following we formulate the concept of bug signatures based on generators.
definition bugsignature .given a labeled itemset database constructed from correct and faulty profiles of predicates a bug signature is the set of generators of an equivalence class induced by the corresponding function tx.
a bug signature is of the form fg1 gng where gi fpi1 pimigfor each iis a generator.
it can be perceived as a representative of an equivalence class.
its relationship with faulty executions is captured by the underlying txfunction.
the assumption we make of the bug signature is that the higher an equivalence class is positively correlated with faulty executions the more probable its bug signature is related to the cause and or effects of the bug.
for example the equivalence class in figure 4c provides a bug signature s1 ff7g f9ggcorrelated with transaction t3 t4andt5.
it means that if an execution has taken either the branch true or true it s probable that the execution is faulty.
another equivalence class in figure 4b provides a bug signature s2 ff11 16gg correlated only with the faulty transaction t5.
it means that if an execution evaluates both predicates f ele null and i n to true it s probable that the execution is faulty.
here we would expect that s2captures the cause and effects of bug with higher possibility than s1 since s2occurs only in all the faulty executions.
in other words due to its association with faulty and not correct executions s2is better than s1in discriminating faulty executions from correct ones.
in the following section we introduce a metric to measure the discriminative power of a signature.
.
discriminative significance the basic unit of our signatures is itemset generator so we start by discussing how discriminative significance of a pattern is computed.
a pattern is deemed discriminative if it can be used to distinguish one class of transactions from the other.
the significance of a discriminative pattern is typically measured by the notion of information gain ig .
letdbe a database of class labeled transactions.
given a pattern p its information gain is high if it appears frequently in one class of transactions whereas rarely in theother.
let p sup p n sup p then the information gain of pattern pcan be defined in equation ig p n h jd j jd j p n jdj h p n jdj p n jdj h jd j p jd j n where h a b a a b log2 a a b b a b log2 b a b in the context of bug detection however we are only interested in patterns which are highly correlated with negative transactions i.e.
faulty executions whereas the definition of igis symmetric to some extent as a pattern highly correlated with positive transactions also carries high information gain.
henceforth we leverage the notion of information gain to define the following discriminative significance measure ds p n ig p n ifn jd j p jd j otherwise based on definition all the itemset generators in an equivalence class constitute a bug signature.
as they have the same positive and negative supports their dsvalues are also the same.
thus we use thisdsvalue as the discriminative significance of a signature.
.
top k bug signatures it is a good practice to examine bug signatures in the descending order of discriminative significance.
therefore we define the bug signature identification as a top kdiscriminative pattern mining problem.
definition mining top kbugsignatures .given a labeled database dconstructed from faulty and correct profiles and an integer k identify ksignaturesfsigk i 1fromd such that maximizepk i 1ds jtx si j jtx si j where tx s tx g for any g2s.
the notations tx si andtx si denote the positive and negative transactions containing all generators in the signature sirespectively.
the following table shows top signatures for the profiles in table .
the second column lists the detail supports.
the last table signatures for profiles in table rank support signatures ds ff11 16gg .
ff11gg .
ff16gg .
ff7g f9gg .
ff4gg .
column shows the discriminative significance scores.
as discussed earlier the signature f ele null i n is the best for it has the highest discriminative significance score.
.
algorithms we first review the data structure to mine frequent itemset generators and then present our algorithm for discovering bug signatures via a novel discriminative generator mining algorithm.
.
gr tree to mine itemset generators li et al.
proposed a tree based representation of transactions to efficiently mine frequent itemset generators .
we briefly describe this data structure in the section.
given a database dbconsisting ofpositive andnegative transactions a gr tree is a compact representation of db denoted as a tuple gtreepre x db where pre x is an itemset prefixing all the items in the gr tree.
for the original databased pre x is .
figure shows the gr tree of database figure gr tree of the database of table with prefix dbin table gtree db.
each gr tree has a head table storing all items in descending order of their supports.
if two items have the same support then they are sorted randomly e.g.
items and .
a gr tree has the following two properties .it does not store items of very low negative support.
this holds because such items will not contribute to good and discriminative bug signatures.
.it does not store items which have full support ie.
which occur in all transactions in the database db .
this holds since such items cannot be a part of any generator as proven in .
specifically the second property enables compact representation of database and efficient discovery of generators.
each item in the table has a link to its corresponding nodes in the tree.
a path from root to a node m p n represents an itemset pattern comprising of the items in the path supported by p positive and nnegative transactions.
for example the path hroot i represents a pattern f4 16gappearing in no positive and negative transaction.
generators are developed by recursively adding a new item into the developing generator and creating a conditional database of transactions wrt.
this new item.
definition conditional database .given a gr tree gtreepx db leta1 anbe items in its head table.
then the conditional database of ai i n is denoted by cdjpx faig gtreepx db as the set of path segments exclusively between the root and aifor all paths containing ai.
a conditional database cdjpx faig gtreepx dbis a projection of the original database obtained by only selecting transactions containing the pattern px faig and removing aiand items below aiin the head table of the gr tree .
the table above shows the conditional database of gtree dbin figure with respect to item cdj f 16g gtree db.
in order to construct this conditional database from gtree db we first extract all path segments between root and nodes table the conditional database of figure w.r.t item id transaction t4 f4 14g t5 f4 11g .hroot i .hroot i as mentioned before each path segment is an itemset of which the support is that of the last item so the support of all items in the first path segment is and the support in the second segment is .
we then remove root and nodes from the segments and form the conditional database cdj f 16g gtree db.
then we can build its gr tree gtreej f 16g cd where cd cdj f 16g gtree dbshown in the figure below.
figure gr tree of the conditional database of table with prefix f16g note that items are removed from gr tree as they have full support in the conditional database cdj f 16g gtree db.
.
algorithm skeleton algorithm outlines our signature mining technique.
gscontains a list of tuples from which top ksignatures are selected.
each tuple is of the form p n gens where gens fgigm iis a set of generators each having support p n .
the top ksignatures are identified in two steps as shown in statements and of the algorithm algorithm minesignatures d k neg sup size limit input d an itemset database constructed from profiles input k the number of top discriminative signatures to mine input neg sup signatures should be in at least neg sup faulty profiles input size limit upper size limit of generators in signatures output rs a list containing top kdiscriminative signatures 1gs 2minerec gtree d k neg sup size limit gs 3rs clustergeneratorsintoequivalenceclass gs step .
we mine ksets of generators.
each set is associated with a distinct support p n and the generators in each set are of the same support p n .
also the ksets have the top k discriminative significance based on their ds p n .
this step is done by calling minerec at line .
minerec takes a gr tree as the first input for the original database dwe create its gr tree with empty prefix and pass gtree dtominerec .
the last argument gs stores the mined generators returned from minerec .
step .
we construct the top ksignatures by clustering generators into their equivalence classes.
upon reaching line gsstores a list of tuples p n gens each of which is a set of generators gens sharing the same positive and negative supports pandn.
however having the same supports is only a necessary condition for generators to be in the same equivalence class.
based on the definition ofbug signatures in definition they are not bug signatures yet.
so at line for each generator genings we scan the profile database dto compute tx gen and cluster all generators into their corresponding equivalence classes based on tx gen .
we store these equivalence classes to rsin descending order of discriminative significance.
as two generators occurring in a tuple in gsmay correspond to multiple equivalence classes rsmay have more than ksignatures and we proceed to only keep the top kones.
since developers are usually interested in a small set of bug signatures the overhead of the clustering is usually low.
the efficiency and effectiveness of algorithm can be directly controlled by two of its parameters neg supandsize limit .
the parameter neg sup sets the negative support threshold thus requiring mined signatures to be present in at least neg supfaulty profiles.
computationally this allows apriori property cf.
property to be exploited to avoid unnecessary computation time spent on constructing itemset patterns with too few negative supports.
the parameter size limit enables us to cap the size of generators in bug signatures.
as will be described in the next subsection this setting confines the maximum depth of search space exploration controlling the mining overhead.
this is also useful when we want the bug location to be approximated in trading off for efficiency.
take for instance the signatures shown in table if we set size limit to1 we obtain f ele null as top pointing to the general cause of the crashing failure.
however if we relaxsize limit we get f ele null and i n which is more specific.
.
mining discriminative generators algorithm minerec is inspired by the frequent generator mining algorithm described in with two major differences.
first whereas the original algorithm aims to mine all frequent generators above a given support threshold minerec focuses only on the top ksets of generators.
second minerec takes into account the discriminative power of the generator currently under investigation and aggressively prunes the search space in a branch and bound fashion.
minerec takes as input a gr tree tree.
recall that tree is rooted with a prefix pattern.
minerec outputs generators which are grown by combining items in tree with prefix .
it does so by performing depth first search over the pattern space.
specially as shown between lines and minerec first combines the prefix with each item in the head table of tree.
between lines and minerec constructs from each of the extended patterns a conditional database db0fromtree and then builds a smaller gr tree tree0fordb0.
lastly minerec calls itself recursively to discover qualified itemset patterns involving the respective extended pattern.
the branch and bound technique is employed in line to avoid making futile recursive invocation.
here minds gs denotes the minimum discriminative significance of the generators ings.
if it is found that the new gr tree tree0cannot output any generators with higher dsvalue tested by calling the functionupperbound tree0 than the minimum discriminative significance in gs and the size of gsis already k then minerec stops searching along this branch and starts working on the next available pattern.
there are three early exits of this algorithm.
at line the function returns if tree is empty as the current search path ends at tree.
at line if the size of generators mined between lines and equals to size limit then the function can safely stops as minerec outputs generators from small to big and any generators mined in the future along the current path must be of a bigger size than size limit .
the third exit is at line if tree is only a single path as all possiblealgorithm minerec tree k neg sup size limit gs input tree gtreepx dbwith prefix px constructed from db input k neg sup size limit the same as those in algorithm input gs a list to store mined top kdiscriminative generators output mined generators are stored in gs 1iftree is empty then return 2foreach itemiin the head table of tree do px0 px fig updateresult gs k sup px0 sup px0 px0 5ifjpxj size limit then return 6iftree is a single path then return 7foreach itemiin the head table of tree do px0 px fig letdb0denote the conditional database cdjpx0 tree remove any item afromdb0ifsup a neg sup lettree0denote the gr tree gtreepx0 db0ofdb0 ifjgsj k upperbound tree0 minds gs then continue branch and bound here!
minerec tree0 k neg sup size limit gs 15procedure updateresult gs k p n gen 16if9e e p n gens e2gsthen gs gsnfeg f p n gens fgeng g 18else gs gs f p n fgeng g ifjgsj k then choose e2gssuch that e p0 n0 gens0 minds gs ds p0 n0 gs gsnfeg generators derivable from tree have been mined between lines and .
.
.
computing upperbound tree for a pattern p it has been studied that the information gain of super patterns of pis bounded by a formula over the support of p .
assume that we know a set of transactions ux p tx p which contains all super patterns of interest p0 p referred to as unavoidable transactions.
ux p p0 ptx p0 the information gain for any super pattern of pis upper bounded by the following formula as in .
maxfig sup p jux p j ig jux p j sup p g in the context of bug detection we focus on patterns which appear more frequently in negative transactions than positive ones and therefore introduce a new upper bound for ds as shown in the following theorem2 theorem upper bound of ds .given a pattern p the discriminative significance of all its qualified super patterns is upper bounded by the following formula ub p ig jux p j sup p ifsup p jd j jux p j jd j otherwise given a gr tree tree the term qualified super patterns refers to all patterns that are derivable from tree.
furthermore the ds 2the proof is presented in section .upper bound of all these patterns i.e.
upperbound tree invoked at lines in algorithm can be computed as follows.
we iterate every path of tree from root to leaf nodes until we find a pathhroot a m n ln p q icontaining all items in the head table.
the transactions containing fa lngform the unavoidable transactions of the prefix px.
since we only need to know the numbers of positive and negative unavoidable transactions to compute ub px we can simply get them from the attached support information p q of the leaf node ln namely jux px j pandjux px j q at last we compute ub px as the dsupper bound of tree.
.
case studies we have implemented the proposed technique in a prototype named mps mining predicated bug signatures in c and have experimented it with faults in buggy programs i.e.
print tokens unix utilities and space interpreter on a pc with intel core quad cpu .0ghz and 8gb memory.
the print tokens is a subject in siemens benchmark which was developed to test the testing coverage strategies .
the programs grep gzip sedare unix utility programs of moderate size and the last subject space is an interpreter for an array definition language.
the sizes of the programs range from to .
table benchmark statistics subject loc test cases faults print tokens grep gzip sed space total each subject program has multiple versions and each version has a different bug.
table shows the detail of these programs including names in column subject size in column loc number of test cases in column test cases and number of faults per subject in column faults .
the cbi sampler3is used to instrument programs to collect data predicates.
we compare mps with leap in two modes inter procedural signature mining and intra procedural signature mining.
in the first mode a bug signature is identified over the whole program and the items in each generator in a signature can span across multiple functions.
in the latter mode the signature mining is performed repeatedly for each function and the top ksignatures are retained among all the signatures.
different from the first mode items in a generator in such a signature must reside within the same function.
thus in our case studies we have four signature mining algorithms i.e.
mps inter mps intra leap inter andleap intra and use them to identify the top bug signature.
for mps we set the parameters neg sup 54andsize limit .
our experiments show that mps outperforms leap in both modes in terms of its mining speed and the quality of signatures discovered.
our case studies are designed as follows we conduct an objective comparison between discriminative significance values of the top signatures produced by mps and leap thus measuring their ability in contrasting faulty executions from correct ones.
we measure the quality of mined bug signatures in assisting in locating 4to simplicity we use relative support instead of absolute support.bug in a program by computing the proximity of the signature to the actual bug.
we present the statistics of runtime.
the artifact including source code tools and supportive data used in our case studies has been successfully evaluated by the esec fse artifact evaluation committee and found to meet expectations.
it is available at suncn mps artifacts .
.
objective comparison with leap a signature with higher discriminative significance indicates a higher correlation with the faulty executions namely it appears in more faulty executions yet fewer correct executions.
as such the signature may carry more predictive power in highlighting the bug.
thus in this experiment we use information gain ig as an objective metric to evaluate the performance of mps and leap.
specifically we measure the absolute improvement of mps over leap in terms of ig scores of top signatures which is defined as igmps igleap .
ig is widely used in information theory and machine learning .
for example it is used to measure the change in information entropy from a prior state to a state that takes some information in general classification algorithm it is used to measure the effectiveness of features in classifying un labeled examples.
more importantly in fault localization research lucia et al.
have shown that ig is one of the best metrics in localizing bugs in .
alternatively we can also use discriminative significance ds instead of ig in our comparison.
regardless of which of these two is used the experiment outcomes are similar.
table improvement in information gain of mps mean median p mps inter v.s.leap inter .
.
mps inter v.s.leap intra .
.
mps intra v.s.leap inter .
.
mps inter v.s.leap intra .
.
table shows the improvement of mps over leap in different mode combinations.
the first column indicates the modes of mps and leap the second and the third columns list the mean and the median of the absolute improvement.
we also performed wilcoxon signed rank test for each combination which yielded p throughout.
thus the improvement is statistically significant.
the improvement is due to the following reasons.
first the pruning technique used in mps is based on the sound upper bound ofds cf.
theorem whereas the pruning heuristics of leap are unsafe.
second the predicates used in mps provide more information on program states for characterizing bugs especially useful for those which do not lead to any control flow deviation from correct executions.
.
proximity to actual bug in this section we measures the distance between the actual bug in the program and the signature mined.
it aims to determine how far should the programmer go beyond the signature to localize the bug.
the measurement method is similar to the computation of score described in .
specifically the distance measure is performed on the program dependence graph pdg of the faulty version of the program.
given the actual bug and a signature we identify all the corresponding nodes in the pdg signifying the actual bug and the signature.
let s denote the bug node by band the latter set of signature nodes by srespectively.
letk n e be the set of nodes that are reachable in pdg from nwithin the distance e. through this we determine the minimumtable proximity results subjectmedian mean leap mps leap mps inter intra inter impr.
intra impr.
inter intra inter impr.
intra impr.
print tokens .
.
.
.
.
.
.
.
.
.
.
.
grep .
.
.
.
.
.
.
.
.
.
.
.
gzip .
.
.
.
.
.
.
.
.
.
.
.
sed .
.
.
.
.
.
.
.
.
.
.
.
space .
.
.
.
.
.
.
.
.
.
distance d n between any node nin the signature s and the nodebfor the actual bug.
different from the approach in in which the distance is defined as the number of edges in the shortest directed path connecting a node ninsand the bug b we relax the directional constraint of path to undirected as the information carried in predicates enables programmers to reason bugs in an undirected way.
for example the following code snippet is extracted from print tokens and the bug is the misplacement of case .
mps outputs a signature containing a predicate cu state right after the statement cu state next st .
there is no directed dependency path from case to the predicate location.
however with this predicate we know that next st is also and this variable can directly lead the execution to reach the bug point.
thus the undirected path between cu state andcase via next st provides a good clue for debugging.
1next st ... 2switch next st ... case ... bug is case ... 7cu state next st a signature here cu state after getting the shortest distance we compute n n2sk n d n to represent the maximum number of nodes locations in the program a programmer has to examine starting from node nin the signature.
ifd n the actual bug falls in the signature and the number of nodes a programmer needs to examine is simply the size of the signature itself.
the fewer nodes a programmer must examine when locating a bug the better the quality of the signature.
this proximity is expressed as a fraction of the pdg x jnj jpdgj we used codesurfer to compute the pdg of the buggy program and computexfor each of the signatures.
table shows the proximity results for each program subject.
columns list the median and columns list the mean.
these two column sets have the same structure so we elaborate how to interpret the median columns.
columns and are the medians of the top signatures produced by leap inter andleap intra .
column is the median for mps inter and column is the relative improvement of mps inter over the best proximity value of leap inter andleap intra i.e.
mps inter max leap inter leap intra max leap inter leap intra columns and can be interpreted similarly only except they list the median of mps intra and its relative improvement over leap.1static int inchar if prog.cur bug should be if prog.cur prog.end ch prog.cur else if prog.file if !feof prog.file ch getc prog.file if ch n cur input.line return ch int main int argc char argv while opt getopt long ... !
eof switch opt case e compile string ... break case f compile file ... break figure a bug in sed overall the improvement ranges from .
to .
.
in particular the medians of leap inter andleap intra for the space subject are both zero since the number of profiles of space is large i.e.
each profile is also a big graph and sub graph isomorphism checking used in leap is np complete thus making leap inter not able to terminate.
in the case of leap intra due to the unsafe pruning heuristics in leap it usually produces no signatures for space .
we performed wilcoxon signed rank one tail test between mps and leap and validated that the improvement of mps is statistically significant with p .
moreover it is interesting to see that signatures produced by leap intra andleap inter are comparable in proximity so are mpsintra andmps inter .
as demonstrated in the following section intra procedural mining is significantly faster than inter procedural mining hence in practice mps intra can be used first to get quick diagnostic information.
if the information is not enough mps inter can be invoked to provide alternative signatures.
.
efficiency table displays the runtimes of the four miners.
the fourth column impr.
lists the relative performance improvement of mpsinter over leap inter and the last column impr.
lists the improvement ofmps intra over leap intra .
it shows clearly that except for gzip ininter procedural mode mps is much superior to both the leap variants in terms of speed furthermore mps intra is significantly faster than the other three by .
.
.
a debugging session for sed this section describes how we use mps to debug a fault in the sedprogram.
the bug is at line where the operator should be instead.
this bug causes the program to read the terminating null character of the input string an unexpected behavior.
thetable runtime statistics in seconds subject mps inter leap inter impr.
mps intra leap intra impr.
print tokens .
.
.
.
.
.
grep .
.
.
.
.
gzip .
.
.
.
.
.
sed .
.
.
.
.
.
space .
.
.
.
1bool two of three reports valid global 2int other rac global 3int alt sep test bool tcas equipped other capacity bool intent not known two of three reports valid other rac bug should be if enabled tcas equipped intent not known !tcas equipped alt sep void main int argc char argv two of three reports valid atoi argv other rac atoi argv figure a bug in version of tcas bug happens when users provide a sedcommand via the command option e and prog.cur prog.end .
the program is safe if the command is stored in a file specified with the command option f .
mps outputs a signature including two predicates for this bug ch at line and opt e at line these two precisely capture the context under which the bug manifests itself.
in contrast leap outputs a signature containing four branches in a function of which three conditions involve the character returned by inchar .
however all these branches are far from the bug location and not related to the bug.
worse still that inchar is intensively used in that function and it is difficult to figure out the difference between calls in the signature and the other calls.
in terms of discriminative significance the mps signature appears in correct and faulty executions with ds whereas the leap signature appears in correct and faulty executions withds .
.
a debugging session for tcas the following describes a debugging session we conducted with mps on the siemens benchmark.
in version of tcas program the function alt sep test has a bug at line where the operator should be shown in figure .
the bug manifests in the following two scenarios when the boolean variable intent not known is incorrectly assigned with value trueinstead of false two of three reports valid and other rac two of three reports valid and other rac6 mps outputs a signature containing two predicates other rac two of three reports valid after line alt sep tcas equipped after line the following is our process to diagnose the bug.
as alt sep has been assigned with at line tcas equipped must be asobserved from the second predicate of the signature .
in order for the execution to reach the statement at line the test at the if statement at lines and must be true.
since tcas equipped is known to be true we therefore infer that intent not known must be true.
at this point we can ask if it is reasonable to set alt sep to when the intent is not known .
if it is reasonable we can continue our investigation to check when intent not known is set to true.
based on the assignment to intent not known at line the fact that intent not known must be true and the first predicate in the signature we can infer that in faulty profiles two of three reports valid and other rac cannot be true at the same time and then question if it is reasonable to set intent not known totrue in this situation.
we thus arrive at the source of the bug.
on the other hand for this version leap outputs a large subgraph containing basic blocks in functions main alt sep test and another two many of which do not help but act as deterrence to the debugging process in our opinion.
lastly in terms of discriminative significance the signature obtained from leap is contained in correct and faulty profiles and its dsis .
whereas ours appears in correct and faulty profiles with ds .
.
threats to validity as an empirical study our experimental results are subject to two threats to validity.
first threats to construct validity concern whether the metrics used in the evaluation of mps are proper.
in this paper we use information gain and proximity to measure the performance of mps.
the first one has been shown to be a good metric for fault localization in and the second one is also widely used in debugging research projects.
both metrics are objective.
the first one characterizes the capability of signatures in contrasting faulty executions from correct ones.
the latter one mimics the developers behavior in debugging measuring not only the effort required to figure out the cause of the bug starting from the mined signatures.
with regard to the concern that our results might not generalize to broader population of programs we note that our algorithm assumes that the manifestation of a bug is highly correlated with a set of predicates the applicability of this assumption to buggy programs in general is commonly accepted by the research community.
as far as scalability is concerned the runtime performance of mps inter may degrade with large sets of profiles.
however mps intra is not affected much and can output signatures of comparable quality.
.
related work this section surveys and classifies research studies related to our work in three categories bug signature mining fault localization and discriminative pattern mining.
bug signature mining.
as pointed out by hsu et al and parnin et al.
in the absence of the context in which a bug occurs it is difficult for developers to conduct a debugging session.
hsu et al.
utilize bide sequence miner to discover longest common subsequences as bug signatures from a sequence database consisting of suspicious program statements in .
cheng et al.
curl sequences into software behavior graphs and employ leap todiscover discriminative subgraphs as bug signatures.
the experimental results have shown that their approach outperforms rapid .
extending leap to discover predicated bug signatures can however be non trivial.
it is unclear how predicates should be encoded into the graph models encoding predicates as edges creates multi edge graph the mining of which will require non trivial extension to leap encoding predicates as nodes may create conflict with the pruning heuristics deployed by leap.
fault localization.
in spectrum based fault localization program profiles or spectra obtained from faulty and correct executions are analyzed to locate bugs.
renieris and reiss compare a failed execution with the nearest correct execution to locate suspicious program elements .
liblit et al.
chao et al.
and zhang et al.
find predicates that are correlated with failures .
jones and harrold use tarantula and abreu utilize ochiai to rank suspicious program statements.
nainar et al.
identify compound boolean predicates of size for statistical debugging .
chilimbi et al.
use statistic metric to rank program paths which are correlated to bugs .
differently our approach targets at minimum bug signatures which is capable of capturing multiple profile elements for bug diagnosis.
it is also flexible in case the location of a bug is highly discriminative the location will be directly returned.
in comparison with we propose a systematic algorithm to mine succinct signatures of arbitrary size baah et al.
propose a probabilistic program dependence graph to software fault localization of which the probabilities are inferred based on observational studies and causal effect estimation .
gore et al.
recently study the reduction of confounding bias in predicate level statistical debugging .
our approach is orthogonal to these causal inference centric research and it will be interesting to integrate these techniques to tackle confounding bias at signature level.
rossler et al.
combines statistical debugging and test case generation to isolate failure causes .
as pointed out in their paper they only use single suspicious predicates in each function to guide the test generation as identifying multiple predicates takes longer time.
our mining technique e.g.
mps intra can complement theirs by overcoming this constraint.
discriminative pattern mining.
hong et al.
mine discriminative itemset patterns based on information gain in .
nijssen et al.
transform discriminative itemset mining into a constraint satisfaction problem .
lo et al.
mine discriminative sequential patterns for software behavior classification .
yan et al.
mine discriminative subgraph patterns via leap search .
sun et al.
mine contrasting patterns for software process evaluation .
in comparison our novel algorithm aims to mine discriminative itemset generators by contrasting faulty execution profiles from correct ones.
consequently we improve on scalability in signature mining through avoiding construction of connected subgraph and filter redundant information in signatures through mining of generators.
.
conclusion and future work understanding program bugs invariably involves reasoning through sequences of program states which are typically represented by both data predicates and conditions for directing control flow .
automatically identifying appropriate data predicates that represent either the cause or effect of a bug is a non trivial task.
specifically it can be challenging to extend the current control flow based signature generated by leap to include such predicates.
in this paper we propose a novel algorithm to automatically identify bug signatures consisting of data predicates and control flow information.
compared to leap our algorithm is sound as the technique employed to prune the search space is safe in information theoretic sense.
with the presence of data predicates the functional ity of our signatures is extended to enable developers to diagnose a class of bugs the manifestation of which does not trigger any deviation in control flow transitions from correct executions and thus cannot be detected by control flow based signatures.
although the information presented in the profiles has increased we manage to produce signatures of smaller sizes through the technique of itemset generator mining.
moving forward we will explore various opportunities for optimizing the mining algorithm.
we are in the progress of developing a debugging environment that assists programmers in inferring the cause of bugs from the data predicates present in signatures.
in future we plan to conduct human studies to investigate the effectiveness of our approach in debugging large real world programs.
we also plan to enhance the algorithm to assist in discovery of multiple bugs present in the execution profiles.
.
acknowledgment we are grateful to yan han pang theong siang oo kheng meng yeo and thao nguyen at national university of singapore for their assistance in conducting the case studies.
we thank the anonymous reviewers for their valuable comments and evaluation of the paper and the associated artifacts.
our appreciation also goes to hong cheng at chinese university of hong kong for providing the leap tool and ben liblit at university of wisconsin madison for making cbi instrumentor publicly available.
this work is supported by a research grant r .
.
supplementary information the following is the proof of theorem .
proof .letdbe an edge label transaction database pbe a pattern p sup p andn sup p .
the partial derivative of ig w r t the positive support p ig p jdjlog2p jdj p n p n jd j p the partial derivative of ig w r t the negative support n ig n jdjlog2n jdj p n p n jd j n letp0be a qualified super pattern of p p0 sup p0 n0 sup p0 thenjux p j p0 jux p j jd j p0 jd jbased on the definition of unavoidable transactions.
.ifn0 jd j jux p j jd j thenn0 jd j p0 jd j thus ds p0 n0 .
.ifn0 jd j jux p j jd j we discuss the following two cases.
first ifn0 jd j p0 jd j then ds p0 n0 .
second if n0 jd j p0 jd j then ig p 0and ig n 0thusigis monotonically decreasing to p and monotonically increasing to n. then ds p0 n0 ig p0 n0 ig jux p j n0 ig jux p j sup p .
so the upper bound of dsis correct.
.