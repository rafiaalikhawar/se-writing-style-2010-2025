reverb recommending code related web pages nicholas sawadsky gail c. murphy and rahul jiresal dept.
of computer science university of british columbia vancouver canada nsawadsky gmail.com fmurphy jiresalg cs.ubc.ca abstract the web is an important source of developmentrelated resources such as code examples tutorials and api documentation.
yet existing development environments are largely disconnected from these resources.
in this work we explore how to provide useful web page recommendations to developers by focusing on the problem of refinding web pages that a developer has previously used.
we present the results of a study about developer browsing activity in which we found that .
of developers visits to code related pages are revisits and that only a small fraction .
of these were initiated through a low cost mechanism such as a bookmark.
to assist with coderelated revisits we introduce reverb a tool which recommends previously visited web pages that pertain to the code visible in the developer s editor.
through a field study we found that on average reverb can recommend a useful web page in of revisitation cases.
i. i ntroduction software developers use information resources on the web to help perform many different programming tasks including learning new programming concepts reminding themselves of syntactic programming language details and clarifying error messages amongst others .
despite the prominence of web search and exploration in the workday of many software developers the tools of software development and web browsing remain disconnected from each other.
in practice retrieval of relevant web pages is an effortful process requiring a developer to choose a set of search keywords enter the keywords in their browser evaluate multiple pages returned from a search and rinse and repeat until appropriate resource s are found.
ideally the cost of finding appropriate web pages for a developer s task would be negligible.
if appropriate web pages could simply be fetched and be readily available based on the developer s current work a developer could remain focused on their task at hand.
the fishtail tool takes this approach fishtail extracts keywords from a developer s task context all programming constructs on which the developer worked as part of a task automatically queries the web with those keywords and then recommends a selection of pages from those returned from the search .
while this approach greatly reduces the cost of searching for relevant web pages fishtail is unable to recommend appropriate pages with high accuracy.
as a result the cost of perusing recommended pages for those appropriate for the current task remains high despite some automation in the creation and execution of a search.
one way to potentially improve the relevancy of web pages recommended is to limit page recommendations to those thata developer has previously found useful.
in essence predict likely revisitations of web pages.
although such an approach would not be as ideal as recommending appropriate web pages from the wild it may still provide value if developers commonly revisit pages studies on general web page revisitation i.e.
including commonly visited pages such as email and calendar have found revisitation rates of between and .
unfortunately no studies have looked at revisitation for code related pages.
to investigate code related revisitation rates we report in this paper on a study of eleven software developers in which we analyzed the developers web browsing history for a three month period.
ignoring revisits that occurred shorly after an initial visit i.e.
within minutes we found a mean code related revisitation rate of .
.
interestingly of participants had at least three one hour periods containing three or more code related revisits and had nine or more such periods.
as each of these revisits can require substantial work in re finding the web pages of interest from web searches we believe there is value in a tool that can predict revisits of code related pages.
in this paper we introduce such a tool called reverb that pro actively recommends web pages previously used by a developer as the developer works on source code in a development environment.
reverb detects code related web pages perused by the developer in a web browser indexes the keywords used on those pages and then recalls and displays pages that are similar to code under active development by the developer.
the recommendations made by reverb are ranked and presented based on similarity in the content of the code being worked on and the page and the frequency and recency frecency of access to the page by the developer.
to determine if reverb can provide benefit to software developers we conducted a field study during which nine participants used reverb in their own development tasks for a period of six java programming hours.
we found that reverb on average was able to predict a code related web page revisted by the developer in of the cases of revisitation.
for of the developers in our study the prediction rate was over .
we believe the performance of reverb shows the promise of using local code context to drive the pro active recommendation of code related web pages.
this paper makes three contributions it provides empirical data about how often software developers return to code related web pages and the methods they use to perform these revisits c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
it introduces a tool reverb to support developers in refinding code related web pages by proactively recommending pages from the developer s own browsing history that relate to the code under development and it presents the results of a field study of reverb that suggest that local code context is helpful in recommending useful web pages.
we begin with a review of related work on general web page revisitation and specific support for software developers using the web section ii .
we then describe the results of a study into how often code related web page revisits happen for software developers section iii and introduce the reverb tool that we have developed to support the proactive recommendations of code related pages section iv .
we follow the tool description with the results of a field study of the tool section v before concluding with a discussion of our approach section vi and a summary of the paper section vii .
ii.
r elated work a number of studies have considered general web page revisitation.
tauscher and greenberg tracked six weeks of web usage of participants to compute the likelihood called the recurrence rate that a given page visit was a revisit .
in their study they observed a recurrence rate of .
mckenzie and cockburn analyzed the history of web users finding a recurrence rate of .
this higher recurrence rate may have been due to a data preprocessing step in which urls were truncated thus ignoring query parameters and increasing the number of pages to be considered a revisit.
obendorf and colleagues conducted a long term study of browser users .
they reported a recurrence rate of .
based on distinct urls which included query parameters and post data.
adar and colleagues gathered anonymized browsing information from users of the windows live toolbar over a five week period.
.
instead of computing the recurrence rate adar and colleagues focused on identifying revisitation patterns associated with particular web pages.
the study of code related revisitation on which we report in this paper section iii is most similar in style to obendorf and colleagues.
in focusing on revisitation of one kind of page code related pages our study shares similarities with the work of adar and colleagues.
whereas our focus is on recommending pages to revisit based on a developer s current work adar and colleagues focused on understanding user behaviour from how pages are revisited.
prompted by the recurrence rates found in the empirical studies described above researchers have devised a number of techniques to assist users in refinding web pages.
most of these approaches enrich the existing functionality of the browser such as extending the functionality of the back button .
others have considered the recurrence of specific navigation trails in users browsing histories e.g.
.
for example a visit to a user s web based email client may frequently be followed by a visit to an online calendar.
a recent study found that augmenting a frequency and recency based rankingalgorithm with page transition probabilities computed from the user s browsing history increased the percentage of successful revisit predictions from .
to .
.
reverb also uses contextual information to predict pages that a user may wish to revisit instead of using the context of previous navigation reverb relates the content of the developer s code editor with similar web pages in the user s browsing history.
a variety of tools have been proposed to assist developers in their use of the web.
mica and assieme facilitate searching for code related resources on the web.
these tools allow a developer to enter a task oriented query e.g.
java create zipfile and then categorize the search results by the apis and types that they reference.
reverb differs in intent from these tools in eliminating the need for a search to be performed in at least some situations.
the codetrail tool watches the pages a developer browsers to automatically detects if a page has api documentation and links that documentation to the source code for easier access .
in addition codetrail can detect blocks of code on visited pages that match code in the developer s workspace and can automatically generate a bookmark in the workspace to capture the link.
similar to codetrail reverb surfaces web pages related to the developer s current work.
in contrast to codetrail reverb can surface useful web pages in more situations because it bases recommendations on automaticallygenerated queries rather than on temporal access and because it is not restricted to pages detected as describing an api.
hypersource maps web pages visited to corresponding source code edits and maintains these associations over time .
consequently hypersource provides a precise picture of code provenance which is not available with reverb.
in contrast reverb s associations are based on shared keywords rather than temporal locality allowing a web page last visited in an earlier project to be recommended based on newly added code.
finally blueprint embeds the web search interface in the development environment and integrates results from search atop the source code editor .
it does not provide results proactively like reverb but does use local context to augment the user entered query such as adding the name of the programming language.
iii.
h owmany visits are revisits ?
do software developers revisit code related web pages?
if revisits occur what is the recurrence rate?
what mechanisms do developers use to revisit pages?
these are the questions we needed to answer to understand if a tool that recommends previously visited web pages might have value for software developers.
for instance if revisits do not occur or are infrequent little value might be gained from tool support.
if revisits occur but are through developer created bookmarks the cost of refinding the web pages would be minimal and little value might be gained from a tool.
to answer these questions we conducted a study of software developer browsing behaviour.813a.
method we investigated the questions of interest by analyzing detailed browsing history databases maintained by the mozilla firefox1and google chrome2web browsers.
both browsers use the sqlite database engine3for managing browsing history.
each time the user visits a page an entry containing the timestamp and a location id is added to a table of page visits.
the full url of each page visit including query parameters and anchor if present is stored in a separate table of locations.
by analyzing browsing history we only needed to have participants access data that was already collected avoiding the risk of users changing their behaviour because they knew they were participating in a study.
we provided each participant in our study a tool that we had written which prompted the participant to choose a browsing history window of at least two months in which the participant was actively coding.
the tool extracted a list of web page visits within that window from the browser s history database.
redirects and google search page visits were filtered from the list.
the tool then attempted to download the content of each page in the list.
downloaded pages were filtered to remove script elements as these elements are not displayed to the user and can contain tokens which could make a page appear code related.
the text content of the page was then extracted and the page classified as code related or non code related using the heuristics described below.
to estimate the accuracy of this classification a random sample of pages classified as code related was presented to the participant and the participant was asked to flag any incorrectly classified pages.
a report was then uploaded to our server that contained the participant s anonymized browsing history the page classifications and the manual classifications performed by the participant.
the source code for the tool used by participants in this study is available on google project hosting.
several possibilities exist for determining if a web page is code related.
one could try to identify code based on the density of delimiter tokens or presence of keywords from common programming languages.
this approach would need to be customized for each language to be supported.
alternatively an approach based on latent semantic indexing lsi could be used.
however this approach requires the training of the indexer on a corpus of documents.
furthermore bacchelli and colleagues found that lsi performed well on recall but fared poorly in precision of its results .
we required an approach with high precision since we were using the classifier to determine the recurrence rate of code related pages.
to achieve high precision we chose an approach based on the camelcase naming conventions prevalent in current coding practice.
we constructed a regular expression to match words containing a medial capital letter capitals that are not the verified verified 3sqlite.org verified 4code.google.com p reverb bookmarks verified 12first letter in the word or underscores we refer to this as an identifier filter.
although the identifier filter was constructed to avoid matching ordinary capitalized words and acronyms the filter generated many false positives due to company and product names on web pages.
to avoid these false positives we extended the filter to match only patterns that resembled method declarations or invocations with parameters.
this pattern constrained of the identifier filter followed by an open bracket at most non close bracket characters and a second instance of the identifier filter.
restricting the filter to method declarations and invocations came at a further cost in recall.
to compensate we combined this with a pattern that looked for method declarations and invocations with no parameters.
experiments with our own browsing histories indicated that empty brackets were uncommon in non code related pages.
as a result this pattern could allow identifiers without camelcase or underscores.
at least two matches to the two patterns method declaration invocation with parameters and without had to be found for a web page to be classified as code related.
the full set of heuristics used in our classifier is available elsewhere .
b. participants and data we recruited participants for this study from within the ubc computer science department and from one software development company.
recruiting participants for this kind of study can be difficult given the reluctance of individuals to have their browsing history analyzed despite the fact that our study method uploaded only anonymized urls.
of the eleven participants in this study eight were graduate students and three were professional software developers.
seven participants used the google chrome web browser and four used mozilla firefox.
although java was the programming language used by the largest number of participants seven a range of other programming languages were represented c c javascript perl ruby php and python.
the average browsing history window used from these participants was days.
in total we analyzed days of browsing history.
c. results to answer the question of whether developers revisit coderelated web pages we compute the recurrence rate as defined in previous work r total urls visited different urls visited total urls visited this computation depends heavily on the definition of a url.
in our study a page was identified by a full url including query parameters and fragment.
for a visit to be classified as a revisit the full url had to be matched.
however if the url was reached through a form submission the post parameters were not considered part of the page identifier.
in addition because the firefox history database does not record814visits initiated through the browser s forward and back buttons these visits are not included in our calculations.
over the days of browsing history analyzed our participants visited a mean of web pages of which a mean of visits were code related.
the overall recurrence rate averaged across all participants was in line with the findings of earlier studies .
for just those pages flagged as code related the recurrence rate was .
when code revisits occur close in time to the original visit we think it is unlikely that tool support to help predict the revisit will be useful.
more likely a user will revisit the page based on a search results page that is still open in the browser via a back or forward button or some similar mechanism.
as a result we also analyzed the browsing history data to understand recurrence rates for revisits occurring more than minutes after a previous visit.
with this minute window the overall recurrence rate is .
.
and the coderelated recurrence rate is .
.
.
we were also interested in gaining insight into the frequency of code related page revisits.
using the minute window we measured the number of one hour periods in which at least three code related revisits were observed.
for five participants the count of these periods was three or greater.
for two participants the count was nine or greater.
because our classifier was optimized for precision over recall we can consider that the actual code related page revisits may be even higher.
overall then a reasonable number greater than of code related page visits are revisits.
these revisits happen for some participants at a rate of more than three per hour.
given that revisits are occurring we wanted to know which mechanisms developers were using to perform the revisits.
to determine this information we analyzed the browsing histories of the participants for code related revisits where more than minutes separated the visits to the pages.
because the chrome history database provides a more fine grained categorization of page transition types we were only able to analyze the seven participants using chrome.
figure shows the breakdown of mechanisms used for revisits by these participants.
notable in this chart is the small percentage of revisits .
performed using bookmarks.
the bookmark category represents visits initiated through a bookmark in the browser including frequently visited locations shown on chrome s new tab page.
this small value shows that developers are not taking specific actions to remember coderelated web pages.
more often in .
of the cases revisits fell into the typed category which captures visits initiated by typing into the address bar.
auto complete is thus an important tool for developer to refind code related web pages.
the dominant mechanism at .
for revisiting code related pages was through a link from another page.
unfortunately the anonymized history data we collected does not allow us to characterize the previous pages leading to these revisits.
in some cases these will be search results pages instances of researching in the terminology of obendorf et al.
.
in other cases these will be pages in a navigation trail the user follows link .
typed .
submit .
start page .
bookmark .
fwd back .
fig.
.
developer actions leading to code related revisits to refind the page re tracing .
in either case the developer is likely expending effort to peruse a search results page or to follow multiple links.
d. limitations the method we used to investigate code related revisits may miss revisits to code related pages.
by having participants identify which of randomly sampled pages marked as coderelated were indeed code related we aimed to ensure that we did not over estimate the code related recurrence rate by including false positives.
we chose this approach to minimize the effort our participants needed to expend on the study.
however it may have resulted in pages that were code related being marked as not i.e.
false negatives .
our method also relies on the database maintained by the browser to determine which pages are visited.
in some cases we may not know that a developer re consulted a page.
for instance if a page is in a browser tab and the tab is reactivated we do not see this reactivation in the browser s database.
we consider such cases low cost revists and missing this information does not unduly affect our results.
our participants represent a range of software development experience and settings but are not representative of the total software developer population.
the external validity of our results may thus be limited and the study should be extended to include a wider range of software developers.
in particular gaining a wider range of participants using a browser for which we can track how revisits occur such as google chrome would be beneficial to gain more insight into the costs associated with revisits.
despite these limitations this study provides the first insights into the behaviour of code related revisits undertaken by software developers.
iv.
r everb thetool finding a web page needed for particular software development situation such as a web tutorial about an api to understand how the api should be used or a project wiki page describing a feature being worked on is a chore that takes a developer away from their task at hand.
a developer typically has to use a search engine to find the appropriate815page but most search engines return a lot of results requiring the developer to scan through potentially multiple pages of results to find the one or two most relevant web pages for their task.
this once to initially find a page is one thing but having to do it over and over again to refind the page as you go back to work on similar code is tedious.
reverb makes it easy to re find these pages the developer has previously determined to be useful.
figure shows reverb in action.
the tab labelled webpagedownloader.java shows the code on which the developer is currently working.
reverb automatically detects and extracts code elements from the active viewport of the editor to form a query against the user s previous browsing history.
in figure the code elements used for querying by reverb are highlighted for clarity but reverb does not typically highlight these elements.
reverb uses these code elements to query the user s browsing history.
pages whose content has a high similarity to these code elements and that might have been visited by the developer when working with on this or other similar code are then ranked according to the frequency and recency with which a developer has visited the pages.
the tab labelled reverb in figure shows the display of results the results are grouped under the query which the page matched.
when an interaction with the code leads to the display of different code in the editor reverb refreshes the recommendations.
to function reverb must index the web pages visited by a developer monitor activity in the code editor form queries against the developer s browsing history and rank and group results for presentation to the developer.
we describe each step in turn.
a. indexing web pages reverb includes extensions for the google chrome and mozilla firefox browsers.
these extensions monitor page loads and transfer the content of each page to reverb s indexing service which runs locally on the developer s computer.
only pages that are displayed for at least five seconds are sent to the indexer to ensure the page is likely of interest to the developer to ensure that any dynamic content is loaded and to ensure that the browser extension does not impact page load time.
we chose to index all web pages visited by the developer to ensure all pages with code would be included in the index.
based on data we have analyzed the size of the index is unlikely to exceed 60mb in size with six months of browsing history.
reverb s indexing service uses a general purpose text indexing engine lucene5 and is thus code structure unaware.
we chose this approach over a program structure aware indexing approach as used in search engines like sourcerer because structural links in web pages are often not resolvable.
the lucene records created by the service contain two fields page title and page content.
preprocessing of the page prior to indexing is minimal script elements are removed and then the text content of the remaining html elements is 5lucene.apache.org core verified 12concatenated and indexed.
the indexing service also maintains a database of locations visited.
in addition to the last visit time and the number of visits this database also contains a frecency column which assigns a score to the web page based on frequency and recency of page visits section iv c .
an advantage of using lucene is that it supports near realtime retrieval of newly added content meaning a page may be recommended in the development environment almost immediately after a developer has visited it for the first time.
b. monitoring activity and forming queries reverb also involves an eclipse plugin that monitors mouse events in the java code editor.
whenever the developer clicks in the editor the plugin checks to see if the viewport has changed.
if it has the plugin retrieves the ast for the portion of the source code file that is visible and extracts the names of specific code elements.
reverb currently extracts the following elements type declarations type