exact and approximate probabilistic symbolic execution for nondeterministic programs kasper luckow aalborg university denmarkcorina s. p as areanu cmu nasa ames research center usamatthew b. dwyer university of nebraska usa antonio filieri university of stuttgart germanywillem visser university of stellenbosch south africa abstract probabilistic software analysis seeks to quantify the likelihood of reaching a target event under uncertain environments.
recent approaches compute probabilities of execution paths using symbolic execution but do not support nondeterminism.
nondeterminism arises naturally when no suitable probabilistic model can capture a program behavior e.g.
for multithreading or distributed systems.
in this work we propose a technique based on symbolic execution to synthesize schedulers that resolve nondeterminism to maximize the probability of reaching a target event.
to scale to large systems we also introduce approximate algorithms to search for good schedulers speeding up established random sampling and reinforcement learning results through the quanti cation of path probabilities based on symbolic execution.
we implemented the techniques in symbolic pathfinder and evaluated them on nondeterministic java programs.
we show that our algorithms signi cantly improve upon a stateof the art statistical model checking algorithm originally developed for markov decision processes.
categories and subject descriptors d. .
software program veri cation model checking reliability statistical methods .
introduction probabilistic software analysis aims to quantify the probability that a software system satis es a required property under given probabilistic usage pro les.
recent applications include cyber physical systems e.g.
check that the probability of an unmanned aerial vehicle turning too fast is less than by analyzing the vehicle s control software under suitable pro les built from the telemetry data of previpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
versions or similar systems.
such critical systems are usually checked through simulation only and probabilistic software analysis can complement that for increased assurance.
other applications include program understanding and debugging computing software reliability quantitative information ow analysis for security etc.
traditional formal approaches based on probabilistic model checking require a high level design or architectural model of the software.
however such models are di cult to maintain and may abstract important details that impact the chance of property satisfaction in the system.
our goal is to perform probabilistic analysis directly on implementations not on high level models.
recent promising approaches developed by us and others have proposed to use bounded symbolic execution to support probabilistic analysis on the source code.
the analyses in address programs with integer domains and linear constraints with also treating complex data structures as inputs while the analyses in address programs with linear and complex oating point computations respectively.
however none of these with the exception of discussed below treat the orthogonal but important issue of nondeterminism.
nondeterminism arises naturally when no suitable probabilistic model can capture a program behavior e.g.
for multithreaded distributed or component based systems.
in this paper we extend probabilistic symbolic execution of programs to deal with nondeterminism.
we aim to compute a scheduler that resolves the nondeterminism to maximize the probability of property satisfaction or conversely that maximizes the probability of non satisfaction.
inspection of the computed scheduler will then provide insights for the design of the analyzed system to debug or improve it.
in we proposed to compute probabilities along linear schedules i.e.
thread interleavings and report the best worst cases to the user.
in this paper we examine tree like schedulers that can provide more precise information about the best worst cases as compared to linear schedulers see example in the next section .
we rst describe a simple exact algorithm for computing a tree like scheduler that resolves the nondeterminism to maximize the probability of property satisfaction or failure .
the algorithm takes a bottom up approach to propagate computed values and resembles the value iteration for markov decision processes mdps but it works directly on the code not on mdp models and is tailored to ef575 ciently process the symbolic tree generated with a bounded symbolic execution of the program.
this algorithm forms the basis of an approximate algorithm for the synthesis of schedulers that we use for increased scalability.
the approximate algorithm uses monte carlo sampling over program paths as dictated by the conditional probabilities computed from the conditions in the code using symbolic execution .
one well known shortcoming of samplingbased techniques is that unlike an exact probabilistic analysis they cannot be directly applied to systems featuring nondeterminism since it is not clear how to take meaningful decisions for nondeterministic choices during the monte carlo sampling.
to address this problem our algorithm starts by assuming a uniform distribution over the nondeterministic choices i.e.
assumes all nondeterministic choices are equally likely and then iteratively uses reinforcement learning to provably improve the resolution of nondeterminism with respect to the target event.
a key insight for our randomized algorithm is that the search for the best scheduler can be accelerated by exploiting the full probabilistic quanti cation of sampled symbolic paths.
this also enables state pruning to reduce the sampling space and speed up the technique.
to study the e ectiveness of learning we have also implemented a baseline algorithm that simply uses a uniform distribution for the nondeterministic choices with no learning but which can also bene t from the state pruning.
both the learning based and the baseline approximate algorithms signi cantly improve upon a state of the art statistical model checking algorithm originally developed for mdps .
that algorithm also uses sampling and reinforcement learning but it needs to sample multiple possibly many times along the same path to obtain a good estimate of the quality function used for reinforcement .
in our case it is su cient to sample a path only once to gather the full count of all the inputs associated with that path.
despite the potentially high cost of computing the full count the bene t over pure statistical estimation which works with counts incremented once per sample leads to a signi cant improvement in performance for our algorithms.
furthermore our algorithms enable aggressive state pruning which is not possible with classical statistical approaches.
our approximate algorithms are true biased meaning that true results can always be trusted can be made arbitrarily correct theorem and in the limit converge to the results of the exact analysis theorem and proposition making them suitable for the analysis of critical software.
in contrast we show that the statistical approach from does not always converge see the example in the next section .
we make our presentation in terms of java bytecode analysis and the symbolic path nder spf symbolic execution tool .
however our algorithms are applicable in the context of other languages for which symbolic execution tools exists e.g.
klee for c .
the contributions of our work are an exact algorithm for probabilistic bounded symbolic execution of nondeterministic programs approximate algorithms that exploit accelerated sampling of symbolic paths reinforcement learning and state space pruning with theoretical guarantees the extension of spf to implement probabilistic symbolic execution of nondeterministic programs and evidence from applying the implementation to a collection of multithreaded java programs that our algorithms outperform existing methods.public static void testmethod1 int x if verify .
getboolean if verify .
getboolean if x println success else assert false else if x println success else assert false else if x println success else assert false a source snippet.
succ.
.6x fail .4x succ.
.3x fail .7x succ.
.55x fail .45x b tree.
figure example .
examples in this section we provide examples that illustrate our approach and facilitate comparison with .
example figure shows an example java program with nondeterministic code obtained by method verify.getboolean which nondeterministically returns true or false in spf.
assume that the input xranges over in practice the input domain can be much larger.
the corresponding symbolic execution tree is also sketched in the gure it encodes all the paths taken during the symbolic execution of the program.
shaded nodes represent nondeterministic choices white nodes represent probabilistic choices.
we also annotated tree edges with the conditions on the inputs to reach that edge i.e.
the path conditions computed with symbolic execution.
the probabilities are computed from the path conditions using a quanti cation procedure as described in section .
for example assuming a uniform usage pro le the probability of taking the then branch through the code corresponding to condition x is since there are inputs that satisfy the condition out of possible inputs.
similarly the probability of taking the elsebranch corresponding to condition x is etc.
our goal is to identify a scheduler that decides for each nondeterministic choice the best alternative to select to maximize the probability of success.
the execution tree can be seen as an mdp and analyzed by probabilistic model checking .
the result can also be computed with our exact algorithm yielding the scheduler that selects !
!
in the tree with the maximum success probability .
we have also analyzed the example using our approximate algorithms where we xed the number of samples to default greediness and history parameters .
see section .
for the approximate algorithms we pose a di erent veri cation query instead of asking for the maximum probability we ask if there exists a scheduler for which the probability of success is greater or equal to an hypothesis see section for the existential universal queries we can answer .
in our case the hypothesis is .
corresponding to the maximum probability for success.
the solution is found easily no learning 576public static void testmethod2 int x if x x if verify .
getboolean t1 if x println success else assert false else t2 if x println success else assert false a source snippet.
succ.
.4x x .
fail .1x x .
t1 succ.
.3x x .
fail .2x x .
t2x .
fail .5x x t1 succ.
.5x x t2x .
b tree.
figure example necessary .
pruning further accelerates the search for an optimal scheduler as it prevents resampling the same paths.
we analyzed the same example using the statistical model checking algorithm from .
for samples and same default parameters the algorithm rst computes a suboptimal scheduler !
with maximum probability of success and then it is not able to improve on it due to the poor information obtained from sampling.
furthermore even assuming perfect information from sampling e.g.
by increasing the number of samples to or by replacing the statistical assessment with an exact computation the algorithm is still not able to stabilize towards the best scheduler.
the reason is that the approach reaches a point where the quality measures for nodes and are the same .
and from that point on no progress can be made.
this example shows that the algorithm may fail to learn the scheduler in the limit even assuming perfect information from sampling thus contradicting the convergence results from .
these ndings were graciously con rmed by the authors of .
in contrast our algorithms are guaranteed to nd the correct answer in the worst case after all the paths have been explored at least once though in practice they may converge earlier.
example this example illustrates that tree like schedulers can obtain more precise information than linear schedulers .
figure shows another nondeterministic java program.
we have marked with t1andt2the tasks i.e.
the code fragments that can be performed nondeterministically by the program according to the choice prescribed by verify.getboolean .
assume again that the input variable xranges over .
the corresponding symbolic execution tree is also sketched in the gure.
we also annotated tree edges with path conditions and the corresponding conditional probabilities section .
each path through the tree leads to either success or failure with the corresponding path probabilities also depicted in the gure.
for example path !
!
leads to success with probability .
if we take the approach from we compute the probability of success along each linear schedule and then report the maximum.
for our simple example we only have two linear schedules corresponding to choosing to perform either taskt1or taskt2.
if the scheduler chooses t1 then the probability of success is .
for path !
!
while if the scheduler chooses t2 the probability of success is thesum of probabilities along paths !
!
and !
!
respectively yielding .
plus .
for a total of .
which can be deemed as the maximum value.
however consider now a tree like scheduler that in state decides to take t1while in state decides to take t2.
this yields probability of success .
path !
!
plus .
path !
!
yielding .
which is larger than the probabilities computed along linear schedules.
in the rest of the paper we will describe exact and approximate algorithms for computing tree like schedulers.
.
preliminaries in this section we give background information for symbolic execution and probabilistic analysis in the context of sequential programs.
we will extend these notions to programs with nondeterminism in section .
symbolic execution symbolic execution is a program analysis technique that executes programs on unspeci ed inputs by using symbolic inputs instead of concrete data.
the state of a symbolically executed program is dened by the symbolic values of the program variables a path condition pc and a program counter.
the path condition is a quanti er free boolean formula over the symbolic inputs it accumulates constraints that concrete on the inputs to follow that path.
the program counter de nes the next statement to be executed.
asymbolic execution tree characterizes the execution paths followed during symbolic execution.
the tree nodes represent program states and the arcs the transitions between states due to the execution of program instructions.
we built our approach upon the symbolic execution tool symbolic java pathfinder spf which has built in support for preconditions used for encoding usage pro les .
probabilistic analysis the goal of the analysis is to identify the symbolic constraints characterizing the inputs that make the execution satisfy a given property and then to quantify the probability of satisfying the constraints.
for simplicity we assume the satisfaction of the target property to be characterized by the occurrence of a target event e.g.
successful termination or failure but our work generalizes to bounded ltl properties .
to deal with programs with loops we perform a bounded symbolic execution of the program.
the result is a nite set of symbolic paths each with a path condition.
some of these paths lead to failure some of them to success termination without failure and some of them lead neither to success nor failure they were interrupted because of the bounded exploration the latter are called grey paths.
the path conditions are therefore classi ed in three sets pcs fpcs pcs pcs mg pcf fpcf pcf pcf pgand pcg fpcg pcg pcg qg.
the path conditions de ne disjoint input sets and they cover the whole input domain.
usage pro les the constraints generated with symbolic execution are analyzed to quantify the likelihood of an input to satisfy them where the inputs are distributed according to given usage pro les .
the usage pro le is a probabilistic characterization of the software interactions with the external world e.g.
the users or the physical execution environment.
it assigns to each valid combination of inputs its probability to occur during execution.
usage pro les can 577weakstrongprobability wind effect figure usage pro les for the daisy chain controller .
come from monitoring the usage of actual or similar systems or expert and domain knowledge physical phenomena .
in this paper we assume that the usage pro le is given and we direct the reader to the literature on usage and operational pro les for further details on their speci cation automatic inference and advanced applications e.g.
.
we can handle arbitrarily complex probability distributions for usage pro les by discretizing them up to the required accuracy.
the discretized distribution partitions the inputs in as many non empty sets as needed and assigns to each of them a probability p represented by a rational number with arbitrary precision.
in we provide an extensive treatment of usage pro les and show how they are used after the symbolic execution of the program is performed to compute the desired probabilities.
here we take a di erent but equivalent approach and encode the constraints that dene the usage pro le as preconditions for the analyzed code.
handling the usage pro les in this way is necessary to support the monte carlo simulation which requires a forward computation of the probability of each branch to drive the symbolic execution.
more general usage pro les given as e.g.
markov chains could be encoded similarly as stateful assumptions we leave this for future work.
figure illustrates two non uniform wind e ect usage proles.
we will show in section how we encode them for the probabilistic analysis of a daisy chain controller.
probability of target event the probability of success is then de ned as the probability of executing the program extended with the preconditions pwith an input satisfying any of the successful path conditions prs p p ipr pcs i .
an analogous de nition is provided for the probability of failure prf p and the probability of grey prg p .
note that prs p prf p prg p .
prg p can be used to de ne the con dence we can put on probability estimation under current exploration bound .
quanti cation procedure to compute the probabilities of path conditions we use a quanti cation procedure for the generated constraints.
in we used model counting techniques i.e.
latte to estimate algorithmically the exact number of points of a bounded possibly very large discrete domain that satisfy linear constraints.
the work in was extended to handle arbitrary complex oatingpoint constraints in using qcoral an approximate quanti cation procedure.
for simplicity we use latte but our work can also accommodate qcoral .
however the approximate nature of qcoral would complicate the presentation of the approximate treatment of nondeterminism we just note brie y that proposition would hold when using qcoral too .
for a nite possibly very large nonempty integer domaindand a given constraint c latte computes the num ber of elements of dthat satisfy c denoted as c .
pr c is then de ned as c d where d is the size of d .
the success probability or failure or grey probability can then be computed as prs p p ipr pcs i p i pcs i d .
probabilistic analysis for nondeterministic programs we consider now the problem of probabilistic analysis for nondeterministic programs.
without making any assumption on the way the nondeterministic choices are resolved i.e.
without assuming a priori a next choice distribution nor a speci c scheduling policy we want to identify the best possible choices from each state i.e.
the choices that lead to the highest probability of success conversely we may want to identify the worst possible choices which lead to the lowest probability of success.
symbolic execution first we extend the de nition of symbolic execution provided in section to account for nondeterministic choices.
we extend the symbolic execution tree with a new kind of node corresponding to nondeterministic choices in the program.
thus the symbolic execution tree of a nondeterministic program has three kinds of nodes or states i pc path condition choice ii nc nondeterministic choice iii other all the other nodes i.e.
assignments method invocations returns etc.
a pc choice is introduced whenever a conditional statement is executed in the program.
the evaluation of the statement on condition c introduces two new transitions.
the rst one leads to the execution of the then block in the code and the path condition is updated as pcthen c pc.
the second leads to the execution of the elseblock and the path condition is updated with pcelse c pc.
if the path condition for a branch is not satis able symbolic execution will not follow the branch.
a nc choice is introduced whenever nondeterminism is present in the analyzed application this may be due to handling of multithreading or to explicit nondeterministic instructions in the code e.g.
verify.getboolean .
a symbolic execution tree is then denoted as t hs s !
snc spci wheresis the set of nodes s0is the initial state !
s sis the transition relation snc sis the set of nc nodes and spc sis the set of pcnodes snc andspcare disjoint by construction .
let child s denote the children nodes of sand letparent s denote the parent ofs.
note that both nc and pc nodes can have more than one child while all the other nodes can have at most one.
branch probabilities for pc nodes for a pc node we de ne branch probabilities as the probability of taking the then or the elsebranch from the given pc node.
these branch probabilities can be computed using model counting as was done in .
let pcsbe the path condition at the current pc node s and letcbe the branching condition at that state.
we can then compute the branch probabilities as follows.
pthen pr cjpcs c pcs pcs pelse pr cjpcs c pcs pcs note that pcthen pcelse pcs thuspthen pelse .
578probabilistic analysis in our setting the symbolic execution trees computed with the probabilistic symbolic execution described above can be seen as a tree shaped mdp .
mdps are a popular choice to model discrete state transition systems that are both probabilistic and nondeterministic.
schedulers are functions used to resolve the nondeterminism in mdps.
an mdp in which nondeterminism has been resolved becomes a fully probabilistic system known as a markov chain.
in our case the nc nodes in the symbolic execution tree have only outgoing nondeterministic transitions while the pc nodes only have probabilistic transitions.
without going into much detail about mdps we can borrow from the literature on mdps and de ne a memoryless scheduler for a symbolic execution tree which resolves the nondeterminism in each nc node.
note that in general memoryless schedulers are insu cient for achieving the maximal probability for bounded properties schedulers that maintain historic information may be more powerful.
however similar to previous approaches we study here memoryless schedulers that are simpler and can be computed e ciently.
we will study history dependent schedulers in future work.
we rst de ne a probabilistic memoryless scheduler which provides a distribution over the set of children of that nc node we will use this later in our approximate algorithms .
letsncchildren denote all the children of nc nodes i.e.
sncchildren fs2sjparent s 2sncg.
de nition .
a memoryless scheduler for a symbolic execution tree tis a function sncchildren!
s.t.
8s2snc s02child s s0 .
a scheduler for which either s is or for all s2 sncchildren is called deterministic .
similar to we consider here only memoryless schedulers.
the goal is to identify the best possible deterministic scheduler that is the one that leads to the highest probability of success.
let us rst note that a nondeterministic programpand a deterministic scheduler induce what amounts to a sequential program p with all the nondeterminism resolved according to .
the symbolic execution tree of this program is the same as p s but with transition relation!
f n c jn2snc c 0g i.e.
we remove from!all transitions n c for which c .
for p one can then compute prs p as described in section .
for a nondeterministic program one can then de ne the maximum probability of success as prs p max prs p where is deterministic.
similar de nitions apply for prf p and prg p .
below we describe a procedure for computing prt p wheret2fs f gg the procedure forms the basis of the approximate algorithms described in the next section.
exact analysis the procedure is depicted in algorithm it takes as input a nondeterministic program pand a target eventt.
the procedure performs a bounded symbolic execution of the program in depth rst search order .
for each explored path it checks whether it reaches the target event in which case it computes the count associated with the path condition pc .
this count is then propagated up along the path to record how many inputs reach the target event.
for this purpose the procedure maintains a counts for each state s. for nc nodes s is updated with the maximum value among the children while for all the other nodess is the sum of the counters for their children.
algorithm exact analysis.
function exact programp target event t perform bounded se of p foreach s0s1 skdo if yielded event tthen s k pc fori k 0do ifsi2sncthen s i max s2child si s else s i s2child si s end if ifs iunchanged then break end if end for end if end for returnprt p s d end function algorithm optimal scheduler.
function optscheduler states ifshas no children then return end if ifsis pc then for8sc2child s do optscheduler sc end for else ifsis nc then s c arg max sc2child s s c mark s c optscheduler s c end if end function after exploring all paths the maximum probability for the target event prt p shorthand for prt s0 is given by s d wheres0is the root of the symbolic tree and dis the input domain.
the optimal scheduler is simply de ned by selecting for each nc node the child with the maximum value ofs .
see algorithm which recursively visits the children of a state s and marks the nodes belonging to the optimal scheduler.
in case of a tie for maximum value we pick the rst choice.
the intuition for the exact analysis is captured by the following proposition let prt s be the maximum probability that a path crossing state sleads to the target event.
proposition .
for every state s the maximum probability of reaching the target event is prt s s pcs .
proof.
by induction on the structure of the symbolic tree.
for leaves and nc nodes it is straightforward.
for pc nodes s prt s pthen prt sthen pelse prt selse .
from induction hypothesis this is equal to c pc pc s then c 579pc c pc pc s else c pc s then s else pc s pc .
it follows that the value returned at line of algorithm s d s pcs0 is indeed the probability of reaching the target event in the program.
the procedure terminates in k nsteps where kis the bound of symbolic execution and nis the number of symbolic paths.
discussion in practice we work with an abstraction of the symbolic execution tree that only keeps the nc and pc nodes and merges together all the other nodes.
a node in the tree is uniquely characterized by the sequence of choices that lead to that node.
we use this sequence as an e cient encoding of a state.
note also that the grey case can also be interpreted pessimistically oroptimistically meaning that grey will be regarded as failure or success respectively.
finally we mention that in practice we perform an optimized computation for the exact procedure.
instead of recomputing the maximum count for the target event s for statesby performing the max operation of the counts of the children i.e.
s maxsc2child s s c we perform an efcient algorithm that based on the current count for the target event c and a count update c updates the count for statesincrementally.
we presented the un optimized version here for clarity.
.
approximate analysis we describe here two approximate algorithms max and random which use randomized sampling of symbolic paths to compute approximate solutions to the scheduler synthesis problem.
random uses a uniform distribution for the nondeterministic choices while max uses reinforcement learning to iteratively improve resolutions of nondeterminism.
we start with a statement of the veri cation queries that can be answered with our algorithms.
we build upon and use the terminology from .
veri cation query instead of computing the maximum probability of reaching t t2fs f gg as in exact we pose the following query given tand a hypothesis we try to decide whether prt p op whereop2f g. such queries can be used both for veri cation and scheduler synthesis.
for example for veri cation assume we want to check that8 prs p .
this can be decided by the query9 prf p .
on the other hand for scheduler synthesis we check directly the existential query prs p .
in both cases if the existential formulation of the query is true a scheduler is produced.
throughout this section we assume for simplicity that grey paths are treated pessimistically.
approximate algorithms both max and random follow the overall algorithm depicted in algorithm with the difference that random does not perform scheduler improvement line .
at a high level the goal of each run of the algorithm lines is to compute information about the best choices with respect to the target event.
the algorithm maintains a probabilistic scheduler initialized with a uniform candidate line .
each run iterates over two procedures for loop at line with parameter l scheduler evaluation line which uses sampling to compute thecountss and scheduler improvement line which uses the computed information to improve on .
algorithm approximate analysis.
function approximate t restarts l optimizations n samples history parameter h greediness parameter operator op hypothesis target eventt fori t do 8s s 8s2snc8s02child s s0 jchild s j fori l do q schevaluation n t ifs d op then return true end if schimprovement h q end for end for return probably false end function algorithm scheduler evaluation.
function schevaluation scheduler n samples target eventt 8s2sncchildren q s s fori n do sample s0s1 sk if yielded event tthen s k pc fori k 0do ifsi2sncthen s i max s2child si s else s i s2child si s end if ifs iunchanged then break end if end for end if end for fors2sncchildren s.t.s was updated above do q s s pcs end for return q end function after each scheduler evaluation we check if the veri cation query is true line .
note that the scheduler evaluation has the side e ect that the values for each count s are updated.
note also that while the probabilistic scheduler is used to guide the sampling in scheduler evaluation it does not participate in the query checking.
if the query is true the answer is returned to the user the deterministic scheduler that con rms it is built similarly to the exact analysis.
our algorithm is a true biased monte carlo algorithm meaning that it is guaranteed to be correct when it con rms the hypothesis.
if it can not we restart the search for loop at line with parameter t if it fails again then 580the con dence about the unsatis ability of the hypothesis becomes higher.
scheduler evaluation scheduler evaluation algorithm performsnmonte carlo samplings of symbolic paths according to the branch probabilities for pc nodes and the probabilistic scheduler for the nc nodes.
from each sample it collects information s for each state s in a manner similar to the exact algorithm lines are identical to exact .
in addition s is used to compute the qualityqfor each choice child of an nc node that occurs due to nondeterminism line .
the quality is used for reinforcement i.e.
scheduler improvement and is ignored by random.
the quality is de ned as q s s pcs and is an estimate for the maximum probability of reaching tfrom states prt s see proposition .
in the absence of new information from sampling i.e.
if it happens to re sample the same paths the counts s remain unchanged and consequently also the values for q. note also that we do not reset the counts s at the beginning of each scheduler evaluation.
this explains why even random with no learning can be very e ective in nding an optimal scheduler because it keeps accumulating information about the counts the more it samples.
scheduler improvement scheduler improvement algorithm uses quality qto compute how likely it is for each choice to lead to success line it also updates by reinforcing the actions that are more promising lines .
the procedure is identical to the scheduler improvement in we show it here for completeness .
as in we use a greediness parameter that controls the probability we assign to the most promising choice.
combining the new greedy choices with the previous scheduler according to history parameter h ensures that no choice is ever blocked as long as the initial scheduler does not block any actions.
algorithm scheduler improvement .
function schimprovement scheduler history parameter h greediness parameter quality function q for8sof typencdo s arg maxs02child s fq s0 g 8s02child s p s0 ifs0 s g q s0 s002child s q s00 8s02child s s0 h s0 h p s0 end for return end function correctness and convergence as mentioned our approximate algorithms are true biased algorithms for which the following result holds see .
this general result refers to true biased p correct algorithms i.e.
algorithms for which the probability that it outputs a correct solution is at least p and it is only of theoretical importance as in practice it is di cult to quantify p. theorem bounding theorem .for a true biased pcorrect monte carlo algorithm with p to achieve a correctness level of it is su cient to run the algorithm a number of times t log2 log p .
random and max are true biased and p correct.we also state here the correctness of our approximate algorithms meaning that the probabilities computed with our approximate algorithms converge to the maximum one and the deterministic schedulers converge to the optimal one with respect to the target event.
theorem scheduler improvement .letcandc0be the counters computed in s for a statesin consecutive scheduler evaluation phases then c pcs c0 pcs prt s .
proof.s for leaves is constant and .
for a newly sampled path the counters s are updated with values .
since both max andpare used in computing s it can only increase when considering additional positive elements and since pcs for each state c pcs c0 pcs follows.
when all the execution paths have been sampled the values of s cannot be further increased and their value corresponds to prt s as a consequence of proposition .
we also need to make sure that random and max will not get stuck in a local optimum.
theorem asymptotic convergence .in the limit for largenorl the probability of sampling the optimal alternative converges to .
proof.
consider max.
for each nc node s the probabilityp s0 of taking a transition to s02child s is initialized to jchild s j .
when a successful path is sampled p s0 becomes q s0 s002child s q s00 where q s0 s0 pcs0 pcs0 d .
furthermorep s002child s q s00 jchild s j since8s00 q s00 .
it follows that p s0 d jchild s j in other words p s0 is guaranteed to be greater than a positive constant hdoes not change the lower bound .
hence by borel s law of large numbers it follows that when the number of samples tends to in nity each possible transition including the optimal one will almost surely be eventually sampled.
for random p s0 jchild s j and similar considerations apply.
pruning our techniques collect the full count pc for each explored symbolic path .
therefore subsequent explorations of those paths do not yield more information and we can remove those paths from being explored again to speed up the analyses and achieve memory savings.
after sampling a path we mark the leaf in the symbolic execution tree as explored and then go up in the tree along the path to mark as explored all the nodes for which all of their children have been marked explored .
sampling is then performed only from nodes that were not marked as explored .
when the root is marked explored we are guaranteed that the tree has been fully explored.
proposition termination of max and random with pruning .if pruning is applied the optimal alternative for each nondeterministic choice will be sampled within niterations where nis the total number of symbolic paths.
comparison with we provide here a brief comparison with the statistical algorithm for mdps from let us denote it as sum .
max uses as quality qtheexpected maximum probability of reaching the target from the current state irrespective of current which is only used to drive sampling .
in contrast sum 1uses as quality qtheexpected 581listing rare example.
void testmethod int x domain of x is if verify .
getboolean if x ... println success return else if verify .
getboolean if verify .
getboolean ... repeat times if x ... println success return assert false probability of reaching the target from current the state under the current probabilistic scheduler i.e.
the probabilities from contribute to q .
therefore max does not need to reset the computed s with each new and keeps improving while sum 1needs to reset its estimates before each scheduler evaluation.
max and random consider the full count of the sampled paths instead of counting sample by sample as done in sum .
furthermore sum 1needs to sample many times along the same paths to obtain good quality estimates this makes pruning inapplicable to sum .
finally sum 1needs a determinization step and another round of evaluation for the induced markov chain which are not needed in max and random because they directly estimate the maximum probabilities.
.
implementation and experiments we have implemented exact max and random with and without pruning together with the statistical procedure from denoted sum within a generic framework on top of spf.
the framework can be easily extended with other algorithms for approximate analysis we plan to make the tool available as open source.
notable in the tool is the implementation for monte carlo sampling.
each sample is performed by one symbolic execution run as guided by a jpf listener.
the listener monitors for choices made during execution.
whenever a path condition choice is encountered the decision of exploring the then or the else branch is determined by generating a random number x2 which is then compared with the computed conditional probabilities for the branches.
a similar approach is taken for non deterministic choices for random the likelihood of selecting the choices is uniformly distributed whereas for max the probabilities are set according to the learning.
case studies we evaluated our implementation on the following multithreaded java programs.
windy an example from the reinforcement learning literature a robot a ected by wind moves in a grid with start and target positions.
we use two versions simple grid and complex grid .
daisy chain controller an example from previous work two threads run the actuation procedures for the ap controllers of an aircraft it also includes a safety check.
a wind e ect hampers the operation by pushing on the ap s head or tail.
mer arbiter an example derived from a ight component for the mars exploration rover developed at nasa jpl it contains an arbiter and two user threads competing for shared resources.
parallel quick sort pqs three threads sort an array with six elements.
it uses complex facilities from java.util.concurrent e.g.
semaphore and threadpoolexecutor .
we analyzed two versions based on the granularity with which data is bundled up and passed to the threads complex and simple .airline reservation system controlled by ve threads with a bug based on data and thread choices.
rare this is a pathological case for approximate analysis see the code in listing .
we provide the source code at http people.cs.aau.dk luckow probabilistic .
the experiments were run on a machine with an intel xeon e5 .60ghz and 64gb of memory.
results table shows the results of a rst set of experiments where we compared all the techniques for a xed budget of scheduler samples.
the best results are marked with bold.
we have set the hypothesis according to the best probability obtained with exact.
we used default greediness and history h as these were the best values suggested in .
we set restarts t we used a uniform usage pro le and grey paths were treated pessimistically.
for each con guration we conducted ve trials and we picked the best result i.e.
the result with the lowest number of scheduler evaluations for verifying the hypothesis or if the hypothesis was not veri ed the result with the probability closest to .
the results indicate that sum 1performs poorly both in terms of analysis result and performance the former is a result of each sample not carrying the full count information as is the case for the other techniques.
performance is a consequence of the required determinization step.
while exact analysis is tractable for this set of examples the samplingbased techniques are consistently faster while still nding the optimal scheduler when the state space becomes su ciently large daisy depth and pqs simple .
for the smaller examples random is slightly better than max.
from our results it is di cult to conclude on good values of nandl.
analysis of the larger examples indicates that n l seem to both verify the hypothesis in less scheduler evaluations or yield a better result regardless of whether pruning is used or not.
the e ect of pruning is evident it is consistently better to use pruning for random and max.
for rare the maximum probability of reaching success is easily computed with exact but very di cult with max and random.
this is not surprising since it is known that purely statistical methods are typically ill suited for rare events .
our pruning techniques partially address the problem in worst case both max pand random pexplore all program paths but not more proposition and in general may nish much earlier.
for rare both max pand random p con rmed the hypothesis close to worst case with max p slightly better.
table shows the results for a second set of experiments where we run all the techniques to determine the budget required to verify a hypothesis with xed .
here we use larger examples for which the exact analysis is intractable and only show results for the best techniques namely max and random with pruning.
to determine the values we rst ran experiments with approx 40k samples and .
the best probability obtained was used as in the table.
both max and random enable increasing the bound of symbolic execution far beyond what can be analyzed with exact increasing the bound naturally reveals more information about the paths.
for example for daisy chain controller at depth limit we can nd a scheduler with a 582table exact vs. max random and sum p denotes pruning.
if was not veri ed values in parentheses after samples show number of scheduler evaluations to establish the best result.
percentage of experiments where hypothesis was veri ed is shown next to results.
exampleexact analysis result time of pathsapprox.
analysisn l result samplestime merprs prf 28random .
random p1 .
max .
maxp .
sum .
max .
maxp .
sum .
windy simpleprs prf 614random .
random p1 .
max .
maxp .
sum .
max .
maxp .
sum .
daisy depth 13prs prf 248random .
random p1 .
max .
max p .
sum .
max .
maxp .
sum .
daisy depth 18prs prf 244random .
random p1 .
max .
max p .
sum .
max .
maxp .
sum .
rareprs prf 504random .
random p1 .
max .
maxp .
sum .
max .
max p .
sum .
pqs simpleprs prf 536random .
random p1 .
max .
max p .
sum .
max .
maxp .
sum .
random .
random p10 .
max .
max p .
sum .
max .
maxp .
sum .
583table random vs. max w pruning exact runs out of memory.
example hypothesisapprox.samplestime analysis windy complexprs p 71maxp randomp daisy depth 20prs p 028723maxp randomp daisy depth 30prs p 029409maxp randomp pqs complexprs p 0maxp randomp airlineprs p 0maxp randomp better probability for success than what the exact analysis found at depth limit as shown in table .
these results furthermore demonstrate the bene ts of reinforcement learning as compared to random when the state space is large see all cases except windy complex .
our approximate algorithms are well suited for exploring systems with large state spaces but that are well structured i.e.
they may have multiple components running the same or similar algorithms and have few interactions points between components e.g.
mer daisy windy .
common examples include planning and scheduling for robots control software for aircrafts and many critical applications of interest.
however for unstructured systems e.g.
rare the approximate algorithms require scheduling decisions to be made on all states thus defeating their purpose.
this is con rmed by the related literature and more research is needed to address the issue.
non uniform usage pro les to see how our approach applies for non uniform usage pro les let us revisit the daisy chain controller and consider two di erent scenarios where the wind e ect is weak up w and strong ups respectively see figure .
in particular the weak and strong wind usage pro les are de ned as the case where respectively and of the input values yield wind .
we would expect that under the conditions of upw the ap controller is more likely to operate successfully because the ap is less likely to exceed the goal position.
we use a symbolic variable up constrained such that up for controlling the distribution of the input values for the wind variable.
listing upw if up assume wind else if up assume wind wind else if up assume wind wind else if up assume wind wind else assume wind rest of the codelisting ups if up assume wind else if up assume wind wind else if up assume wind wind else if up assume wind wind else assume wind rest of the codelisting and listing show how upwand upsare encoded as preconditions i.e.
assume statements in the code.
the assume statements are implemented using the built in debug.assume method from spf.
with the usage pro les we ran exact and obtained prs upw which is indeed better than prs ups .
.
related work in previous work we de ned the probabilistic symbolic analysis for java programs that forms the basis of our work here.
however in we only discuss exact algorithms and multithreading is treated by computing probabilities along linear schedules.
we study here more general treelike schedules.
in recent work we have investigated approximate procedures for the probabilistic analysis of oatingpoint programs and for the scalable probabilistic symbolic execution of sequential code .
however none of these approaches address sampling for nondeterministic programs and hence the challenge of computing near optimal schedulers.
other related work includes probabilistic abstract interpretation probabilistic static analysis and probabilistic model checking .
in particular the program analysis from is relevant here as it performs aggressive pruning but not for symbolic execution.
again none of these works address sampling in the presence of nondeterminism which is one of the main contributions here.
statistical veri cation techniques perform sampling over the analyzed state spaces but aside from the work in there are very few other approaches that study nondeterminism e.g.
.
in random sampling is exploited to search for a near optimal scheduler whose quality is again evaluated by a statistical approach.
however the iterated use of the conservative cherno hoe ding bound to determine the necessary number of samples might require an impractically large number of them.
the work in studies partial order reductions for mdps to reduce nondeterminism and thus it is orthogonal to ours.
our work is also generally related to planning for mdps .
in the future we plan to investigate whether our techniques are applicable to planning as well.
.
conclusions and future work we presented exact and approximate symbolic execution techniques for the probabilistic analysis of nondeterministic programs.
we implemented and evaluated them showing improvement over established techniques.
in the future we plan to investigate replacing the exact model counting with approximate quanti cation e.g.
qcoral for oating point constraints .
we would need to revise our theoretical results but we note that one of our main results proposition would trivially hold in that case too.
we further plan to study schedulers that use more information from the program execution history and or current path condition to compute more accurate information about the maximum probability.
the sampling process is highly parallelizable.
we implemented a parallel prototype and results show improvement in performance even though some overhead due to thread contention is inevitable e.g.
distributing the workload to two clients for example reduces the analysis runtime by .
more experimentation is planned for the future.
.