crossing the gap from imperative to functional programming through refactoring alex gyori university of illinois usa gyori illinois.edulyle franklin ball state university usa ljfranklin bsu.edudanny dig oregon state university usa digd eecs.oregonstate.edu jan lahoda oracle czech republic jan.lahoda oracle.com abstract java introduces two functional features lambda expressions and functional operations like maporfilter that apply a lambda expression over the elements of a collection .
refactoring existing code to use these new features enables explicit but unobtrusive parallelism and makes the code more succinct.
however refactoring is tedious it requires changing many lines of code.
it is also error prone the programmer must reason about the control dataow and side e ects.
fortunately refactorings can be automated.
we designed and implemented lambdaficator a tool which automates two refactorings.
the rst refactoring converts anonymous inner classes to lambda expressions.
the second refactoring converts forloops that iterate over collection s to functional operations that use lambda expressions.
using open source projects we have applied these two refactorings and times respectively.
the results show that lambdaficator is useful i it is widely applicable ii it reduces the code bloat iii it increases programmer productivity and iv it is accurate.
categories and subject descriptors d. .
software engineering distribution maintenance and enhancement d. .
coding tools and techniques general terms refactoring keywords java lambda expressions imperative programming functional programming .
introduction a lambda expression also called an anonymous function is a function without a name identi er.
for example int x int y x y is a lambda expression that takes two integer args and returns their sum.
lambda expressions can be conveniently passed as parameters or can be returned from functions and are the hallmark of functional languages.
some object oriented languages such as smalltalk scala permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.javascript and ruby supported lambda expressions from the rst release.
others like c v .
c v were retro tted with lambda expressions.
java to be released in is the latest mainstream language to retro t lambda expressions .
the driving motivation for retro tting lambdas in mainstream imperative languages is to make it easier to write parallel code.
the hardware industry has shifted to multicore processing on all fronts phones tablets laptops desktops etc.
the software industry trend is to hide the complexity of writing parallel code behind parallel libraries.
for example the c tpl and plinq libraries or the c tbb library rely heavily on lambda expressions to encapsulate functions that are passed to library apis to be executed in parallel.
enabled by lambda expressions the upcoming java collections provide internal iterators that take a lambda expression as an argument.
for example filter takes a predicate expression and removes elements of a collection based on the predicate mapmaps the elements of a collection into another collection foreach executes a block of code over each element etc.
the internal iterators enable library developers to optimize performance for example by providing parallel implementation short circuiting or lazy evaluation.
until now java did not support lambda expressions but instead emulated their behavior with anonymous inner classes from here on referred as aic .
an aic typically encodes just a function.
the java class library de nes several interfaces that have just one method.
these are called functional interfaces and are mostly instantiated as aic.
classic examples are runnable whose runmethod encapsulates work to be executed inside a thread and comparator whose compare method imposes a total order on a collection.
refactoring existing java code to use lambda expressions brings several bene ts.
first the refactoring makes the code more succinct and readable when introducing explicit but unobtrusive parallelism.
the parallel code below mycollection.parallelstream .map e e.length would have taken lines of code had we used the classic thread and runnable idioms see example in fig.
.
even when not using parallelism the programmer can write succinct expressions when using lambdas.
previously using the old aic the programmer had to write ve lines of code to encapsulate a single statement.
second the refactored code makes the intent of the loop more explicit.
suppose we wanted to iterate over a collection ofblocks and color all blue blocks in red.
compared to theold style of external iterators e.g.
with a forstatement the refactored loop is blocks.stream .filter b b.getcolor blue .foreach b b.setcolor red this style encourages chaining the operations in a pipeline fashion thus there is no need to store intermediate results in their own collections.
many programmers prefer this idiom as witnessed by its popularity in scala fluentiterable in guava google libraries or microsoft plinq library .
third elements may be computed lazily if we mapa collection of a million elements but only iterate over the results later the mapping will happen only when the results are needed.
to get all the bene ts of lambda expressions and internal iterators the java programmer must refactor i aic into lambda expressions and ii forloops into internal iterators.
however these refactorings are tedious .
java projects are riddled with many anonymous classes and external iterators.
for example antlrworks a medium sized open source project 97k non blank non comment source lines sloc contains aics and external iterators.
refactoring antlrworks by hand requires changing sloc for the rst refactoring and sloc for the second refactoring.
moreover these changes are non trivial.
when convertingaic to lambda expressions the programmer must rst account for the di erent scoping rules between aic and lambda expressions.
these di erences could introduce subtle bugs.
for example this orsuper are relative to the inner class where they are used whereas in lambda expressions they are relative to the enclosing class.
similarly local variables declared in the aic are allowed to shadow variables from the enclosing class whereas the same variables in the lambda expression will con ict with variables from the enclosing class.
second converting aic to lambda could make the resulting type ambiguous thus it requires inferring the type of the lambda.
when converting forloops to internal iterators there are several challenges.
first there are many ways to split loop statements into pipelined operations.
ideally the programmer would choose the most ne grained to enable precise control of parallelism and make the intent of statements more explicit.
second the programmer must reason about the control ow statements like break continue return and choose the appropriate operations.
third the programmer must account for di erent scoping rules between the original forand the lambdas a variable declared in a loop statement is available to subsequent loop statements whereas a variable declared in one lambda expression is now local to that lambda.
this requires identifying the variables that need to be passed through the pipeline.
fourth the programmer must verify there are no side e ects on local variables dened outside of the lambda.
fifth the programmer must reason about the nature e.g.
eager vs. lazy of operations in order to preserve the semantics of the original for.
to solve these challenges we designed implemented and evaluated lambdaficator the rst refactoring tool to automate the task of retro tting functional features into imperative code.
lambdaficator currently supports two refactorings.
the rst refactoring anonymoustolambda replaces aic with the equivalent lambda expression.
the second refactoring forlooptofunctional replaces forloops with their equivalent chained operations.
this paper makes the following contributions problem to the best of our knowledge this is the rst paper to describe the novel problem of converting imperative code to a functional avor using lambdas.
algorithms we designed the analysis and transformation algorithms to address the challenges for two refactorings that convert aic into lambda expressions and forloops into functional operations.
these algorithms account for di erent scoping rules between the old and the new languages constructs and convert imperative in place mutations into functional computations that produce new values.
implementation we are the rst to implement these refactorings and make them available as an extension to a widely used development environment.
we are shipping both refactoring with the o cial release of the netbeans ide.
evaluation we evaluated our implementations by running the two refactorings on open source projects totaling almost 1m sloc invoking anonymoustolambda times and forlooptofunctional times.
the results show that the refactorings are widely applicable the rst refactoring successfully converted of aic and the second refactoring converted of forloops.
second the refactorings are valuable the rst refactoring reduces the code size by sloc while the second refactoring infers operators and chains thus making the intent of the loop explicit.
third lambdaficator saves the programmer from manually changing sloc for the rst refactoring and sloc for the second refactoring.
fourth when executed in batch mode on the whole projects the anonymoustolambda refactoring has perfect accuracy.
for forlooptofunctional the tool infers the most ne grained operations more than of the time.
lambdaficator has been successfully evaluated by the esec fse artifact evaluation committee and found to exceed expectations.
lambdaficator along with experimental data and a demo is available at .
motiv ating examples we rst illustrate the motivation behind introducing lambda expressions for parallelism.
fig.
a shows a simple sequential loop from the antlrworks project.
the loop iterates over elementrule objects and resets each object.
the programmer decides to execute this loop in parallel.
fig b shows how the programmer would traditionally refactor the original loop.
she rst decides the amount of parallelism e.g.
parallel threads .
then she creates two loops the rst loop splits the work between the parallel threads by allocating a quarter of the iterations to each worker thread.
she encapsulates the parallel computation inside an anonymous instance of runnable .
then she starts the threads.
the second loop waits for all the worker threads to nish their work.
the programmer could have also expressed the parallel computation by subclassing thread but in this case the code bloat would be even more severe.
besides code bloat there are several other issues with this parallel implementation.
first the amount of parallelism is hardcoded so if she runs the code on a machine with hardware threads the code will utilize only .
second just because she split the iterations equally among the worker threads it does not mean that the running time of the worker threads is equal.
for example suppose that the rules visited by the rst worker thread have a much richer hier p r i v a t e void r e s e t r u l e s f f o r elementrule r p r o p e r t i e s .
getrules f r .
resethierarchy g g a a sequential loop p r i v a t e void r e s e t r u l e s f i n t n amount of p a r a l l e l i s m thread threads new thread f i n a l list elementrule r u l e s p r o p e r t i e s .
getrules i n t s i z e r u l e s .
s i z e f o r i n t i i n i f f i n a l i n t from i s i z e n f i n a l i n t to i s i z e n threads new thread new runnable f override public void run f f o r i n t j from j to j f r u l e s .
get j .
resethierarchy g g g threads .
s t a r t g f o r i n t i i n i f tryf threads .
j o i n gcatch interruptedexception ex f p r i nt e r r o r message g g g b parallel loop with runnable and thread old style p r i v a t e void r e s e t r u l e s f p r o p e r t i e s .
getrules .
par allelstr eam .
foreach elementrule r r .
resethierarchy g c parallel loop with functional operations new style figure comparison between methods of parallelization in java.
archy than all other rules so the rst worker thread will spend a much longer time computing.
because the work is not split evenly between the worker threads the computation would take longer.
this problem is referred in literature as dynamic load balancing .
by taking advantage of the parallel functional operators introduced in java the programmer can refactor the sequential loop using lambdaficator .
fig c shows the nal code which is much more succinct than the previous parallel code and also bene ts from automatic dynamic load balancing.
notice that parallelstream returns a parallel view of the collection thus foreach will execute in parallel.
next we illustrate the problems and challenges of anonymoustolambda andforlooptofunctional by showing examples of refactorings that lambdaficator performs.
fig.
a shows a common practice in any java gui adding a listener to a button.
in this example the developer used an aic avoiding the hassle of creating a separate class for a simple button action.
although an aic is an improvement over an external class the syntax is still unnecessarily verbose.
the programmer must specify the name of the interface the method signature and nally the body of the method.
lambda expressions are a more concise solution.
with lambda expressions the compiler can infer the type of the interface as well as the method signature.
the program button .
addactionlistener new actionlistener f public void actionperformed actionevent e f ui .
dazzle e .
g e t m o d i f i e r s g g a an anonymous inner class button .
addactionlistener actionevent e f ui .
dazzle e .
g e t m o d i f i e r s g b equivalent lambda expression figure example of anonymoustolambda refactoring taken from lambda design speci cation .
mer only has to specify the body of the method.
fig.
b shows a lambda equivalent to the aic in fig a .
while fig.
shows the most basic case lambdaficator must analyze the code deeper to handle several special cases.
fig.
adapted from the apache tomcat project shows an example where the basic conversion would introduce a compilation error.
the doaction method is overloaded and can accept two di erent interfaces both of which de ne a single method run .
a naive conversion results in an ambiguous type for the lambda expression at the call site on line due to the method overloading.
lambdaficator adds a type cast disambiguating the type of the lambda expression.
this example also illustrates that lambdaficator can make the resulting lambda expression even more concise.
if the body of the lambda expression contains a single return statement lambdaficator removes the return statement.
these special cases require additional analysis and would require special attention to refactor manually.
we discuss additional special cases in section .
next we illustrate three examples of the forlooptofunctional refactoring in fig.
.
the rst example shows a loop that iterates over grammarengine objects.
the loop checks whether importedengines contains an element with a given name.
the loop lters out objects with a null name and checks if the name equals the argument of the method for each non null name.
our refactored code makes the intent explicit it shows a non null lter and returns true if any element s name matches the grammarname .
this example illustrates how lambdaficator chains operations together while expressing the semantics of each portion of the loop explicitly.
to perform this refactoring manually a programmer would have to determine that the ifstatement followed by a continue behaves like a non null lter and the return true inside the ifstatement represents an anymatch .
the second example also illustrates chaining operations together this time to compute map reduce .
in this example the loop iterates over elementrule objects and sums up the number of errors for each object that has errors.
in order for the programmer to infer this chaining manually she has to notice that the compound assignment represents a mapreduce operation which may not be immediately obvious.
in this transformation we used method