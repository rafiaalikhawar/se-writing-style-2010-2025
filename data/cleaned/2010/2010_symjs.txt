symjs automatic symbolic testing of javascript web applications guodong li fujitsu labs of america sunnyvale ca usa gli fla.fujitsu.comesben andreasen dept.
of computer science aarhus university denmark esbena cs.au.dkindradeep ghosh fujitsu labs of america sunnyvale ca usa ighosh fla.fujitsu.com abstract we present symjs a comprehensive framework for automatic testing of client side javascript web applications.
the tool contains a symbolic execution engine for javascript and an automatic event explorer for web pages.
without any user intervention symjs can automatically discover and explore web events symbolically execute the associated javascript code re ne the execution based on dynamic feedbacks and produce test cases with high coverage.
the symbolic engine contains a symbolic virtual machine a string numeric solver and a symbolic executable dom model.
symjs s innovations include a novel symbolic virtual machine for javascript web symbolic dynamic feedback directed event space exploration and dynamic taint analysis for enhancing event sequence construction.
we illustrate the e ectiveness of symjs on standard javascript benchmarks and various real life web applications.
on average symjs achieves over line coverage for the benchmark programs signi cantly outperforming existing methods.
categories and subject descriptors d. .
software engineering testing and debugging general terms reliability experimentation keywords javascript web symbolic execution automatic software testing event sequence taint analysis .
introduction traditionally software quality has been assured through manual testing which is tedious di cult and often gives poor coverage especially when availing of random testing approaches.
this has led to much recent work in the area of formal validation and testing.
one such technique is symbolic execution which can be used to automatically generate test inputs with high structural coverage.
symbolic execution treats input variables to a program as unknown quantities or symbols .
it then creates com contributed to this work during a summer intership program at fujitsu labs of america permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.plex equations by executing all possible nite paths in the program with the symbolic variables.
these equations are then solved through an smt satis ability modulo theories solver to obtain test cases and error scenarios if any.
thus this technique can reason about all possible values at a symbolic input in an application.
though it is very powerful and can nd speci c input values to uncover corner case bugs it is computationally intensive.
symbolic execution poses speci c challenges to the domain of javascript based web applications which are quite di erent from traditional programs .
web applications are usually event driven user interactive and string intensive.
also unlike traditional programming languages javascript is a dynamic untyped and functional language.
some symbolic execution tools have been presented for c c java and low level code .
it has been reported that they can nd corner case bugs and produce test cases with very high coverage.
symjs targets javascript web applications which so far has received much less attention.
to make such a symbolic execution tool usable in practice the tool should be fully automatic highly e cient and able to handle general javascript web applications.
this not only requires an e cient and customizable engine with start of the art solving techniques addressing javascript language semantics but also a smart automatic driver builder that explores the user event sequence and input value space exhaustively during the dynamic execution and subsequent test generation phases.
though there are a few symbolic execution tools for javascript such as kudzu and jalangi such comprehensive testing capabilities as described above are lacking.
kudzu uses fuzzing and symbolic string reasoning to analyze security vulnerabilities in web applications.
jalangi instruments the source javascript code to collect path constraints and data for replaying.
while jalangi works for pure javascript programs and not general web applications kudzu focuses on only one speci c testing need nding security issues.
in this paper we show that the event driven nature of web applications poses a bigger challenge than javascript itself.
unfortunately neither kudzu nor jalangi pays much if any attention to this problem.
the following table shows how well random and symbolic testing work for pure javascript js programs and web applications.
for pure javascript benchmarks manipulating numbers random testing can easily achieve over line coverage the coverage drops to around for string intensive programs.
symjs employs symbolic execution with a powerful string solver to achieve more than averagecoverage.
covering the rest requires better drivers.
this becomes more prominent for web applications random testing achieves coverage primitive symbolic execution gets over while symbolic execution with optimizations can cover the corner cases that are very di cult to hit.
more details are presented in section .
random sym.
opt.
pure js num.
str.
js web in practice javascript programs are used primarily in the web context hence the main task is to develop a symbolic engine for web and automatically construct good drivers while curbing space explosion.
this requires novel methods to perform symbolic execution and construct event sequences.
speci cally we present how to implement a symbolic virtual machine supporting both symbolic and taint analysis perform feedback directed symbolic execution to explore the event state space and use taint analysis to optimize event sequence construction.
symjs uses a symbolic virtual machine to execute javascript code.
the source code is not instrumented but a symbolic virtual machine is implemented similar to and .
unlike kudzu which separates event exploration with symbolic execution symjs includes a powerful event explorer that builds and re nes the drivers automatically during symbolic execution.
the novel features and achievements of symjs are as follows the execution engine performs symbolic execution for javascript within a virtual machine.
it supports all language features and most built in libraries of javascript and various execution modes.
it incorporates crucial optimizations such as state merging for property accesses.
it is the rst to use a parametrized array string numeric solver with various optimizations and implement a symbolic dom model with model and executable classes.
section for many benchmark programs the execution engine is able to achieve line coverage with over on average.
this will be apparent in section .
.
the automatic event explorer relieves a user from the burden of building drivers and manually controlling the execution.
it uses dependency and feed backs to explore the event state space more e ciently.
section .
the symbolic engine supports taint analysis through dynamic symbolic execution which can be used to signi cantly enhance event sequence construction.
section .
for various web applications symjs is able to achieve over average coverage in reasonable time which is signi cantly better than some prior automatic web testing tools such as .
section .
.
motivation and overiew figure shows a simpli ed version of a shopping cart example where the web page contains three input text boxes for quantity customer name and credit card number and ve buttons for manipulating the cart add book add pencil clear cart set quantity and purchase.
event purchase invokes function check .
its rst branch checks whether the name input equals to fujitsu and the second one checks whether the name consists of a rst name and a last name.
the third branch uses a regular expression to ensure that the card number contains digits and items name book price name pencil price cart emptycart true totalprice quant function e x get a dom element return document.getelementbyid x function getitem name search item for item in items if items .name name return items function additem name add item with price emptycart false if cart cart quant else cart quant totalprice getitem name .price quant updatecart updateprice update display function updateprice if totalprice price totalprice cents else price totalprice dollars e price .innerhtml price price function purchase for button buy if totalprice return var name e name .value var visa e visa .value return check name visa function check name visa name name.trim var errors if name fujitsu return true p1 if name.split .length !
errors.push need last and first name p2 else if !visa.match d errors.push visa need digits p3 else if parseint visa !
errors.push visa even last digit p4 if errors.length return false p5 else return true p6 function clearcart for delete cart if emptycart return emptycart true cart updatecart totalprice updateprice figure motivating example demo cart .figure main components of symjs.
the fourth one checks the last digit.
the path conditions are shown below where p2 trim name fujitsu trim name .
split .length .
test cases can be produced by solving these path conditions e.g.a valid solution for p4 is name a b and visa .
symjs applies symbolic execution to explore all paths and uses an e cient string numeric solver to determine path feasibility and produce test cases.
p1 trim name fujitsu p2 trim name fujitsu trim name .split .len p3 p20 visa.match ndf16g p4 p20 visa.match ndf16g parseint visa p5 p2 p3 p4 function check will be executed only when totalprice6 .
directly clicking purchase after loading the page will not invoke check .
to execute this function we can construct and execute the following event sequence.
.
click add to cart on book invoke additem .
click purchase invoke purchase in this sequence function additem modi estotalprice to a value greater than .
then function purchase can pass the check ontotalprice and invoke check .
note that additem contains a branch with condition cart undef .
to visit the right side of this branch we can use another sequence .
in general many event sequences may be needed for exhaustive testing.
symjs constructs these sequences automatically based on dynamic analysis.
overview.
as shown in figure symjs consists of three main components front end parser middle end sequence manager and back end symbolic executor .
the front end obtains web pages e.g.
through http requests parses them and stores data in local format.
we add pre processing in the front end to collect information for the middle end.
currently the front end uses a frame less browser htmlunit1.
we extend htmlunit s dom and browser api model to support symbolic execution.
the middle end creates schedules and manages event sequences.
it symbolizes the inputs and executes a sequence event by event.
it monitors the execution and collects feedbacks information to construct and re ne event sequences.
it contains various sequence construction schemes one of which is our implementation of the main algorithm of a concrete testing tool artemis .
l1 l2 label uop not neg unary operation bop add mul rshift binary operation cop gt ge eq condition operation instr pushv add value into frame juopjbop unaryjbinary operation jcop comparison operation jgotol unconditional jump jifeqljifnel conditional jump jgetpropjsetprop getjset property jcalljret function calljreturn push value into the frame push v l pc j vk g !
l pc jv vk g unary operation uop l pc jv1 vk g !
l pc juop v1 vk g binary comparison operation opforop2fbop copg l pc jv1 v2 vk g !
l pc jv1opv2 vk g conditional jump ifeql0 l pc jv1 vk g !
f l0 pc v1 j vk gg f l pc v1 j vk g g property get getprop l pc js v1 vk g !s i2dom s l pc i v1 jshii vk g f l pc v i2dom s i6 v1 jundef vk gg optimized property get getprop l pc js v1 vk g !
l pc jvnew vk g wherevnew ite v1 i1 shi1i ite v1 i2 shi2i fori1 i2 dom s property set setprop l pc js v1 v2 vk g !s s02pts s i2dom s0 l pc i v1 j vk g f l pc v i2dom s i6 v1 j vk g g whereg1 g andg2 g figure syntax and operational semantics of core rhino bytecode excerpt .
the back end is the symbolic virtual machine for javascript which extends the rhino2javascript engine for symbolic execution.
it interprets each rhino icode symbolically forks states on feasible branches and manages the states.
it does not reuse any existing symbolic executor.
the back end and middle end share the state management component to control the state and sequence execution.
.
symbolic execution engine similar to the engine works on intermediate representations bytecode i.e.rhino icode rather than source programs.
this lessens the burden of handling complex source syntax and leads to a more robust tool implementation.
figure shows the bytecode s syntax and semantics.
an execution state consists of the current label l or instruction counter path condition pc framef and global scopeg.
a frame is a stack of values.
it also maintains a pointer to its parent frame pertaining to the function caller.
we use jv vkto denote a frame with vat the top and vrepresenting the rest values.
pushing a new value v1into this frame results in jv1 v vk and popping vre2 in .
a scope maps properties to values e.g.
constants or objects and may embed other scopes.
for a scope object s we uses to denote the value at address x ands the state mapping address xto valuev.
clearly a read after a write satis es the following property s ite x y v s itemeans if then else .
a javascript object may have a prototype chain for its parent objects.
a scope scan access the properties of its prototype scopes.
we use shxito denote reading property xfrom scope sdynamically and show below a formal de nition.
here dom s gives the domain i.e.property names ofs prototype s returnss s direct prototype.
similarly we introduce notation pts s for all the prototype objects ofs includings and dom s for the domain of pts s .
shxi s ifx2dom s s0hxiifs0 prototype s s0hxi6 undef undef otherwise figure shows the execution of some instructions over symbolic values.
other instructions such as object and property creation and deletion various function call types exception handling scopes and literals are not included.
we show how a state transits !
to a new state when executing an instruction.
for example instruction negincreases the label by pops value v1from the frame and puts v1 s negation back into the frame.
a comparison instruction is always followed by a conditional jump.
new states may also be spawned if the condition and its negation are satis able under the current path condition.
here we use set operations e.g.set union to depict state spawning.
when a property is read from a scope s if the property s id is symbolic then we match it with existing properties indom s and spawn a new state for each match i v1 more precisely the rst match in the order of sand thens s prototypes .
when no match exists the path condition is updated and undef is returned as the result.
we will discuss an optimization later.
for property set sand its prototypes are searched and the rst s0containing a matched property will be updated.
if no match is found then sis updated.
for illustration we show below the state transitions for statement cart quant in the motivating example.
suppose that variables name and quant have symbolic values nandqrespectively and in the global scopeg property cart maps to scope s which in turn maps book to q1 and pencil to q2 i.e.the quantities of pencil and book are q1andq2respectively.
l jn k g !
push cart l j cart n k g !
pushg l jg cart n k g !
getprop l js n k g0 !
getprop fstate l p1 n book jq1 k g0 state l n pencil jq2 k g0 state l n 2f pencil book g jundef k g0 g whereg0 g andp1 n book state !
pushq l p1 jq q1 k g0 !
add l p1 jq1 q k g0 !
pushn l p1 jn q1 q k g0 !
push cart l p1 j cart q1 q k g0 !
push g0 l p1 jg0 cart n q1 q k g0 !
getprop l p1 js n q1 q k g0 !
setprop l p1 j k g the property get instruction leads to three states.
in state the path condition speci es that the name matchesproperty book and value q1is fetched from the scope and pushed into the stack.
the subsequent computation adds qinto the book s quantity and updates scope swith the new quantity.
here type conversion will be applied to the operands according to the ecma standard.
the computations for the other two states are similar.
symjs applies crucial optimizations to mitigate state explosion especially for symbolic property gets and sets.
symjs uses iteexpressions to merge the states if possible.
in the above example the states produced by getprop can be combined to the following one.
our string solver is good at handling string numeric iteexpressions.
l true g0 whereq0 ite x book q1 ite x pencil q2 undef symjs provides two methods for spawning new states.
as in the rst method clones states for new execution paths.
the second one is easier to implement but has bigger overhead it restarts the execution from the beginning.
this is a fuzzing mode similar to but it is performed within a symbolic stack based virtual machine.
in the fuzzing mode a state contains a l r sequence recording the sides left or right taken for the feasible branches so far which is used to replay the execution during a restart.
for instance function check alone leads to the following states where tname is the short hand for trim name .
for each state the executor rst replays the execution by taking all the speci ed sides then continues the usual symbolic execution from there.
state pc l r seq 1p1 tname fujitsu l p1 p2 split tname len6 r l p1 p2 p3 visa.match ndf16g r r l p1 p2 p3 p4 visa r r r l p1 p2 p3 p4 r r r r l p1 p2 p3 p4 r r r r r these path conditions are solved to produce test cases.
the test cases can be replayed in the same engine.
for example the following statement introduces a symbolic string for variable s. when replaying symjs assigns the test value e.g.
fujitsu to s then the engine performs concrete execution over this value.
we use replaying to con rm test validity and coverage.
supporting random testing is trivial this function returns a random string then the engine performs concrete execution.
s symb.
value in sym.
exec.
and test value in replay.
var s symjs mk sym string s string numeric solver.
one key for practical symbolic execution is constraint solving since the solver may be invoked hundreds of thousands of times for a non trivial application.
it is the advances in constraint solving smt solving became over times faster in the last decade that make symbolic execution practical and more popular.
symbolic numeric constraints can be solved through smt solvers yices in our case .
however javascript features extensive string operations which are not supported by most modern smt solvers.
thus symjs introduces the pass solver to handle string constraints.
pass supports integers bit vector numbers oating point numbers and strings.
in particular it supports a majority of the javascript string operations including string comparisons string numeric conversions and regular expressions.pass is the rst to use parameterized arrays parrays as the main data structure to model strings and converts string constraints into quanti ed expressions that are solved through an e cient and sound quanti er elimination algorithm.
in particular similar to it can identify unsatisable cases quickly.
for example constraints s.contains ab s.match a can be disproved in the automaton domain.
consider the path condition of state shown above where name not equals to fujitsu and can be split into two parts and variable visa should have digits with the last digit modulo not equal to .
pass rst introduces parrays forname andvisa then creates an automaton from the regular expression ndf16gto constrain visa s value.
the automaton is encoded into parray formulas which enforces thatvisa s length is .
then the quanti er eliminator instantiates the parrays to obtain a solution e.g.visa and name a a .
multiple optimizations are adopted when we incorporate pass into symjs.
the engine utilizes dependency solving cache solving and expression simpli cation to reduce the burden on the solver.
they work for both numeric and string constraints.
for example in the check function when examining condition !visa.match ndf16g we do not need to consider the constraints associated with variable name .
we apply a dependency analysis for this.
caching can speed up the solving too e.g.implement incremental solving implicitly .
similar techniques have been used in klee and sage but for pure numeric constraints only.
the following shows the main steps in the optimized pass.
javascript library and symbolic dom.
javascript has a built in library for common data structures and operations.
symjs interprets them symbolically and optimizes the calls so as to reduce the overhead in symbolic execution.
some optimizations are similar to those described in .
the processed libraries include number string array global string math and regular expression.
htmlunit contains a quite comprehensive model for html dom and browser apis.
htmlunit models chrome firefox ie and some older browsers.
since the htmlunit model allows only concrete values symjs revises the entire model including hundreds of model and executable classes to support symbolic values.
.
automatic web event explorer the event explorer is essentially an automatic driver generator for web applications.
since these applications are event driven and expect user inputs an automatic tool is required to create scenarios that simulate user inputs and dispatch the events automatically.
the main challenge is to curb state explosion nevents may produce o nk event sequences of length k the situation becomes worse when each sequence incurs multiple paths w.r.t symbolic inputs.
this problem exists even for unit testing since an event may depend on other events.
for example an event may be created or enabled only after a sequence is executed.
figure main components in the event explorer.
executed states ex fg priority queue q f jevtis enabledg while q6 fgdo the following executes an iteration state seq b q.remove head new fg load page replay branch decisions recorded in b forall the remaining instruction instr2seqdo executeinstr fork new states if needed add new forked states into new update l rseq and ws info for update rs information for the current event end ex ex f g mark as executed q q new add all new forked states add sequences for new events foreach new discovered evt1do add b with priority into q end add new sequences for existing events foreach enabled event evtdo if b exthen priorityi sizeof seq b wrevt add state b into qwith priority i end end reorder existing sequences foreach b 2q evt s rs is changed do recalculate b s priority end end algorithm feedback directed event sequence construction during symbolic execution.
figure shows the main procedure.
at each iteration the rst state in the priority queue qis executed.
during the execution the information about how the events and the sequences read and write shared variables is recorded in the dependency analyzer.
the analyzer can be enhanced using taint analysis.
when the current state forks new states e.g.
at feasible branches these new states will be added intoq.
when nishes execution a test case is generated and the new sequence generator constructs new sequences based on dependency information collected so far.
.
dynamic symb.
sequence construction consider the demo cart example.
after the page is loaded ve events are enabled clear cart two add to cart set quantity purchase .
composing these events arbitrarily may lead to a large number of sequences.
we apply various analysis to identify duplicate sequences so as to reduce the sequence state space.
the rst one is write read wr analysis which relates events according to how they write and read shared variables.
for example the wr information of these events is as following due to space constraint we only show a portion of this information .
event read set write set clearcart femptycart ftruegg purchase ftotalprice f0gg ftotalprice f0g femptycart false add book cart.book fundef g cart.book .
.
.g totalprice .
.
.
g inadd book s write set variable totalprice has value which is di erent from that in purchase s read set.
hence we can construct a new sequence .
here denotes a sequence containing events evt1 evt2 .
.
.
.
in contrast we do not build sequence clearcart purchase since clearcart does not alter the value of any variable i.e.this sequence is the same as .
we construct sequences and collect wr information dynamically during symbolic execution.
algorithm describes the feed back directed event explorer.
the rst state of the queue is rst replayed to the last forked point according to its l rseq b then continues regular symbolic execution.
the l r sequence b see section records the branch sides taken so far by this sequence.
we do not present bif it is empty.
note that the path condition is not shown here since it will not be used explicitly.
new states forked by are recorded in newand will be added into the queue.
the wr information of both the current sequence seqand all executed events is updated during the execution.
when nishes execution if there are new discovered events then they will be appended to with priority indicating that these events haven t been executed .
then for each enabled event symjs uses the wr information to infer dependency and assign priorities.
the priority is the size of the shared variable set determined by wr.
finally for each each state b ifevt s rs information is updated then to reect the feed backs the scheduler recalculate this state s priority w.r.t.
the relation of seqandevt.
more formally notations rs and ws return s read set and write set respectively.
the rs and ws record the rst read value and last written value of each variable respectively.
in a sequence s ws each variable has a single value while in an event s rs a variable may have multiple values collected from di erent executions of this event.
event chain seq array of events sequence state seq l rseq sequence write set ws event read set rs when a sequence state seq b is nished we generate new sequences by appending the enabled events to .
if the analyzer determines that an event evtis related to then a new state b will be created.
consider the following example state containing sequence seqwrites variable awith symbolic value v eventsevt1and evt2readawith valuesf1gandf2 vgrespectively.
an event read may have multiple values corresponding to its di erent invocations.
here andevt1are related since evt1may read a di erent value from the one written by seq i.e.constraintv is satis able.
hence we generate a new state l r which inherits seq s l r sequence.
on the other hand andevt2are unrelated since vis already in evt2 s rs.
that is appending evt2toseqmay fail to explore new state space.
seq l r evt1 evt2 ws fa vgrs fa f1ggrs fa f2 vgg dynamic write read analysis.
we use wrevtto measure the dependency relation between sequence state and eventevtregarding shared variables.
dependency and dataow analysis prevails in traditional program analysis however the dynamic feature of javascript makes it more di cult to statically calculate dependency information.
hence we collect this information dynamically.
named wr wrevt fxjx2ws x2 rs evt g i.e.the variables written by and read by evt.
valued wr wrevt fxjx2ws x2 rs evt ws 2rs evt g i.e.a variablexis included if s write value to xis not in the read set of xin .
if the values are symbolic the solver is used to determine whether the values can be di erent.
this is the default analysis that symjs uses.
conditional valued wr the path condition is also recorded for a read or write and is used to determine inequality.
however our experience indicates that this does not outperform valued wr in practice.
an important point here is to identify shared variables at run time.
roughly we name a dom element with a unique id and a javascript shared object through traversing its prototype chains till the global e.g.
window scope.
a property or variable xis named s.x where sis the name of x s scope.
for example the fth element of an array object ain the top scope is named window.a.
.
we an skip the window when the context is clear.
this scheme is not accurate but it is su cient for wr analysis in practice.
example.
continue with the demo cart example.
the explorer rst adds initial states into the state queue then executes them one by one with the valued wr analyzer.
supposed that the current sequence is .
the analyzer assigns priority to sequence based on variable totalprice and to based onemptycart .
similarly has priority .
if the current sequence is then the priority of both and is meaning unrelated .
all these sequences are added into the queue.
we show below the wr information of two new sequences.
more sequences can be constructed until a pre de ned bound is reached.
sequence rs ws add book ftotalprice f0g femptycart false purchase name.value fsymv1g totalprice cart.book fundef g .
.
.
g item .
.
.
g add book femptycart ftrueg femptycart true clearcart totalprice f0g .
.
.g totalprice .
.
.
g the analyzer is able to avoid creating useless sequences such as and .
in other words symjs implicitly prunes duplicate sequences using the analysis.
this often leads to signi cant reduction of the explored state sequence space.
.
sequence construction via taint analysis the wr analysis maintains shared variables in wr sets.
however some variables may be irrelevant to the branches in subsequent computations.
if line branch coverage is themain goal then we can apply an optimization to rule out irrelevant variables from the wr sets and use coverage information to guide event sequence construction.
we apply a taint analysis to calculate how shared variables ow into unvisited branches.
for an event function f the analysis builds a map from f s branches to used variable sets.
for example in function clearcart the branch involves variableemptycart only i.e.emptycart is tainted w.r.t the branch.
to cover this branch we can consider only this variable in the wr sets.
we use symbolic execution with a shadow dataow calculation to obtain taint information.
that is dataow information is collected and updated during symbolic execution runs.
the executor introduces symbolic values for input variables propagates values to path conditions and checks termination at backward control ow points.
at each control ow point set vsymstores all the symbolic inputs known so far by all runs.
the calculation terminates when a x point ofvsymon all points is reached.
this mimics the traditional use def calculation for c or java except that our method is based on dynamic symbolic execution.
a traditional method to collect taint information is to start from all sinks and calculate the relevant variables by exploring the control ow backwards.
here we show a di erent approach.
for illustration consider the following function with a loop.
function f a b for a use a e a use a def e if a.d e a branch br use e a a.d a c ... use a c def a initially the vsymat each control ow point is empty.
since the loop header uses variable a we introduce a shadow symbolic value to aand storesainvsym.
in the rst iteration of the loop line uses a which is already in vsym.
then two execution states 1and see below where v0 fa c a dg are spawned at the if branch br with a dadded into vsym.
here property access access a dis resolved using the property get method presented in section .
only the variable or property of a primitive type will be made symbolic.
we dynamically instantiate the type of a shadow symbolic variable.
for variable a we use its original value when it turns out to be an object at line .
hence our analysis is not precise but it is su cient for our dataow calculation.
state selected steps with executed lines and associated vsym fag fa a dg v0 v0 v0 v0 fag fa a dg v0 the branch now uses fa a dg.
state 1executes line and uses variable c. herecis used the rst time thus a shadow symbolic value is assigned to c. state 2takesbr s right side and uses no variable.
their controlows converge at line .
suppose 1reaches this line rst.
it updates vsym s new value tofa c a dgfrom its old value i.e.empty set.
sincevsym s value is changed state 1continues the execution.
now supposed 2reaches line .
the old and new values of vsymare the same hence 2terminates.
next 1goes back to line another convergence point and the second iteration begins.
here vsymat line is updated to fa c a dgfromfag.
then the execution goes on as shownabove.
finally branch bruses variablefa c a dg indicating that variable bis not relevant to br.
the following shows more formally the calculation.
for a state we use a set def to record the locally de ned variables so that no symbolic values are introduced for them .
assume that l pc g .
at a branch br we fork states and record in use br the free symbolic variables in the path condition.
when a property get or set occurs defandvsymare updated.
convergence points are recorded in lconv e.g.
the target of a jump will be added intolconv.
an optimization is to consider only immediate post dominators.
when such a point is reached we check whether ifvsymis unchanged.
if yes then terminate .
instruction taint operation br ifeql0 use br fxjx2free vars pc g lconv fl0g gotol0lconv fl0g getprop def fs v 1g vsym fs v 1g ifs v 2def setprop def fs v 1g l2lconv terminate ifvsymold vsym vsymold vsym otherwise the following shows some taint operations for state .
at line lconv is updated tofl1gsince the loop jumps back tol1 and a shadow symbolic value for ais introduced.
nowvsymcontainsa i.e.the symbolic input known so far isa.
at line no new symbolic value is introduced since ais already in def.
the execution goes on till the second iteration begins.
the second loop iteration adds cinto use br .
when the iteration nishes this state terminates due tossymold vsym fa a d cg.
similarly other states terminate after the second iteration leading to a xed point where use br fa c a dgcontains all the variables relevant to the target br.
line instr.
vsymolddef vsym l1 getprop ifeqfg f ag f ag l2 get setpropfg f a eg f ag l3 getprop ifeqfg f a e a dg fa a dg l4 get setpropfg f a e a d cg fa a d cg l1 l12lconvfag f a e a d cg fa a d cg l1 l12lconvfa a d cg fa e a d cg fa a d cg it is trivial to use taint information to optimize sequence construction we simply exclude irrelevant variables in the wr sets when constructing new sequences.
symjs also considers only unvisited branches in the event.
as shown below the named wr relation between sequence state and event evtcan be extended using taint information.
the de nition of taint valued wr is analogous.
taint named wr taint wrevt fxjx2ws 9unvisitedbr2evt x2use br g i.e.
the variables written by and relevant to at least an unvisited branch inevt.
example.
continue with the demo cart example in section .
.
supposed that sequences and add book purchase have been executed hence the two sides of the branch totalprice have been covered.
consider sequence with the following ws.
variables price anditem do not appear in any program branch.
the taint analyzer ta makes use of this information and can fur ther rule out sequences pertaining to variable totalprice by analyzing the coverage.
sequence write set ws ftotalprice emptycart false price cents item .
.
.
g the following event purchase also reads variable totalprice .
pure wr analysis produces a new sequence add pencil purchase with priority which is useless since this new sequence behaves the same as in terms of branch coverage.
speci cally the two sides of totalprice have been covered and the uncovered branches in function check do not invovle totalprice .
in contrast the ta infers that no variables in s ws are relevant to the uncovered branches in purchase hence discards this new sequence.
event readset rs purchase ftotalprice f0 g name.value symv1 .
.
.
g we also apply a simple optimization that records the path conditionpcof an uncovered branch if pckeeps the same during taint calculation e.g.when the branch is not within a loop.
for example consider the branch in function updateprice .
obviously sequence covers the right side and sets totalprice .
to cover the left side the ta infers that is useless since path conditiontotalprice 100is falsi ed by totalprice .
many other similar sequences are excluded.
.
evaluation we evaluate both the execution engine and the event explorer.
all experiments are performed on a machine with intel r xeon r cpu .67ghz and 4gb memory.
.
evaluating pure javascript programs we evaluate the symjs executor on the sunspider .
.
benchmark suite and the v8 javascript benchmark suite v7 in the latest webkit version .
these benchmark programs use core javascript language only not the dom or other browser apis.
for each program we create a driver where the inputs are assigned symbolic numbers strings or untyped values.
we intentionally write simple drivers without investigating the programs.
table compares the results of random manual and symbolic testing.
the programs in the upper half of the table are from sunspider and the bottom ones are from v8.
for sunspider we analyze representative programs e.g.
access fannkuch from access programs.
we exclude libraries when counting the lines.
for instance after excluding prototype.js raytrace has source lines among which are executable.
while each program is not large it usually contains expensive computations e.g.containing embedded loops and involving extensive bit wise operations.
random testing can achieve reasonable coverage but may miss corner cases.
for example for 3d cube random testing achieves line and branch taken coverage with runs combined.
for random testing we use n max m runs where mis the number of tests produced in the symbolic case.
using the tests in the original benchmark suite results in and respectively.
as indicated by earley boyer and regexp random performs much worse when string inputs are involved.
in contrast symjs produces valid test cases in seconds for 3d cube .
among this execution time i.e.
061second is spent on solving.
the coverage is increased to line and branch taken .
although the engine explores paths all branches can be covered by only one test.
symjs is able to perform coverage preserving test reduction to exclude duplicate tests.
consider another example program string validate input that checks the name and zip code.
its tests can be safely reduced to .
we investigate why symjs does not achieve full coverage for some programs.
the reasons include the program contains expensive operations eo especially non linear operations the driver is too restrictive dr and state explosion se .
we mark the reasons for non fullycovered programs in table .
speci cally symjs s concretizing non linear operations may miss paths and expensive bit wise operations often lead to time out of the smt solver and therefore the termination of the path.
we sometimes need to restrict the drivers to avoid se and eo.
program early boyer parser takes paths to achieve branch coverage.
increasing the number of tests does not help because the new paths contain expensive bit wise operations that the solver fails to handle.
the coverage for raytrace is relatively low because the code related to the canvas object is unreachable in the pure javascript mode.
for many programs in the table constraint solving contributes to most of the total execution time.
on average the solver optimizations described in section can lead to improvement on solving time.
the improvement is marginal since pass has used various inner optimizations e.g.applying early termination and incremental solving as well as using the automaton model lazily.
since symjs has achieved very high coverage for standard benchmark programs which are typically small and the uncovered code is due mainly to the driver problem we do not perform coverage comparison of symjs with other javascript symbolic tools such as jalangi.
.
evaluating the tool on web applications table shows the results of running symjs on web applications some of which are used by artemis www.
brics.dk artemis .
these applications are o line with all client side source code stored in the local disk.
we compare random testing symbolic testing with or without wr analysis and the extension with taint analysis.
for each application we give its number of source lines excluding javascript libraries such as jquery the line and branch coverage the number of iterations i see algorithm the maximal sequence length l the total execution time along with the solving time percentage.
for example application demo cart contains executable lines.
note that some statements such as large array declaration and initialization are not counted.
with iterations random testing can achieve line and branch coverage with or without using wr analysis.
with naive symbolic execution we can get line and branch coverage with iterations executing more will not increase the coverage e.g.
many useless sequences are explored .
applying wr analysis reduces the iteration number to .
the entire execution takes seconds of which is spent on solving.
we use a second wait time for an event with timers.
the maximum sequence length is .
taint analysis takes second to run it can help to reduce the iteration number to .
for some programs taint time indicates the failure to get a valid xed point in min table evaluation results on sunspider .
.
upper and v8 bottom benchmark suite program lines random cov.
suite cov.
symbolic cov.
source exec.
line br line br tests line br cov.
exec.
t sol.
impr.
access fannkuch .
.
.
.
.6s dr eo 3d cube .
.
.
.
.1s eo dr math cordic .
.
.6s string validate input .
.
.
.
.3s splay .
.
.
.
.
.5s dr richards .
.
.
.
.
.6s dr regexp .
.3s earley boyer parser .
.
.
.
.9s dr se deltablue .
.
.
.
.
.9s dr raytrace .
.
.
.
.
.
65s dr eo average .
.
.
.
.
.
table evaluation results on o ine web applications.
program lines random symbolic max i source exec.
i wr wr wr taint cov.
l b cov.
l b i cov.
l b il time iltnt t. cov.
demo cart .
.
.
.
.9s .4s .
.
form validator .
.6s .3s simp calculator .
.
.6s .1s .
ball poll .
.
141s .
.
3d model .
.
.
1121s 69s .
shopping cart .
.
.
.
.4s .2s .
.
maze .
.
.
.
.8s .4s .
tetris .
.
45s .7s .
.
fractal viewer .
.
.
6142s 32s .
google pacman .
.
2268s .
average .
.
.
.
.
.
random symbolic wr taint wr 406080100demo cart 156080100ball poll 4060801003d model 406080100shopping cart 406080100maze 406080100tetris 206080100fractal viewer 20406080100google pacman figure coverage y axis as a function of the iterations x axis for some benchmarks.
utes which may be caused by path explosion or exceptions related to introduced symbolic values.
typically to iterations are required to achieve good coverage.
after that exploring the remaining states is mostly fruitless.
the sequence lengths are from to .
particularly applications require only singleton sequences i.e.
the events are symbolically unit tested.
table shows plot charts measuring the coverage over iterations.
in most cases we can get over using a few iterations and the coverage improvement becomes slowerwhen i becomes larger e.g.
for these applications the latter half of the iterations bring new coverage.
here complex event sequences may be needed to cover more and more state space reduction will be required to eliminate useless states so as to go deeper into the state space.
from these charts it is clear that the symbolic method can get higher coverage with fewer iterations than the random method.
the major advantage of symbolic taint is to reduce the iteration number substantially.
it can also hit corner cases that a pure symbolic method fails to nd.clearly it is important to use wr analysis to increase the coverage and taint analysis to reduce the number of sequences.
interestingly pure wr without taint analysis may perform worse.
table shows more information where various versions of demo cart are obtained by adding listing items.
consider demo cart2 the no wr named wr valued wr and taint methods need and iterations to achieve the same coverage.
for shopping cart rfs only the wr taint method can beat the no wr one.
here rfs restricting shared attributes is a technique that considers only a subset of attributes of a dom element when building wr sets e.g.
it excludes unimportant attributes such as window.height so as to increase the accuracy of a wr analysis.
we prede ne this subset through an empirical study.
this experience leads us to develop an automatic taint analyzer to identify these attributes.
when this option is turn o pure wr analysis may perform poorly since it considers too many irrelevant variables.
in contrast the taint analysis is insensitive to rsv and can always identify relevant variables.
hence in practice taint analysis is amust rather than an optional optimization.
table comparing various analysis w.r.t.
the iteration number to achieve the same target coverage.
program no wr wr taint named valued demo cart1 demo cart2 demo cart3 shopping cart rsv shopping cart1 rsv dynamic articles table compares symjs with artemis on some shared benchmarks.
we do not include other artemis benchmarks which htmlunit cannot parse properly e.g.php les or symjs cannot introduce symbolic inputs into.
in general symjs achieves better coverage with fewer iterations.
for example symjs uses iterations to obtain line coverage for program fractal view while artemis obtains at iteration and cannot improve the coverage further.
one reason is that symjs does not need to guess input values since symjs performs symbolic execution.
we could not compare symjs with kudzu as the end to end kudzu tool is not publicly available.
table comparing symjs with artemis in term of the best coverage achieved.
program artemis symjs cov.
iter.
cov.
iter.
3d model lib.
.
ball poll .
fractal viewer .
google pacman the coverage can be improved using various enhancements.
first of all some browser dependent code typically in the benchmarks can be covered by simulating other browsers.
second currently we introduce symbolic values for speci c elements such as text inputs and radio boxes.
we observed that the coverage could be increased with more symbolic inputs for some applications.
finally executing longer sequences may explore new state space.
for example the uncovered code of tetris is due mainly to the gameover function which will be invoked with a long sequence.on line applications.
we have run symjs on various on line web applications including google and yahoo online services and popular electronic commerce sites.
symjs communicates with the server to fetch the pages and explores them dynamically.
preliminary results show that symjs can obtain line coverage.
however exceptions may occur when symbolic data are sent to the server.
we leave better interactions with the server as future work.
.
discussions and conclusion additional related work.
feedback directed testing has been used for api calls in randoop and for javascript in artemis .
kudzu constructs event scenarios from random testing in a separate phase but does not utilize feed backs.
unlike these tools symjs performs feedbackdirected event construction during symbolic execution.
wr set based analysis has been used to reduce state space for whole c programs hence no drivers are needed .
this technique can be adopted to improve the symbolic execution of pure javascript programs.
the approach in builds event sequences for android applications.
it also uses wr set based dependency to connect events.
the sequences are constructed back ward from a model obtained by random exploration.
in contrast our method discovers the model during symbolic execution constructs sequences in a forward way and uses taint analysis to connect events we have shown that pure wr is insu cient .
in another domain symbolically executes classes through a read write analysis to track possible changes between methods.
regarding state explosion we may adopt advanced state merging techniques e.g.
and duplicate state elimination e.g.
.
for example uses dynamic slicing and symbolic reasoning to detect duplicate states.
coveragedirected search and reduction used in may be adopted to handle the concurrent nature of event execution.
in addition it is possible to apply symbolic encoding and loop abstraction as in to avoid explicitly enumerating all interactions between dependent units such as events.
taint analysis techniques use dynamic static analysis to nd violations in web applications.
our light weight method reuses symbolic execution to collect dataow information.
more sophisticated taint analysis may help reduce the state sequence space further.
conclusion.
we present symjs a symbolic framework for both pure javascript and client side web programs.
to the best of our knowledge this push button tool is the rst to implement a symbolic virtual machine for javascript and automatic driver construction with dynamic symbolic taint analysis.
the approximate development size of major components in symjs is lines of java code counting only our development with around and for the front end middle end and back end respectively.
compared to kudzu whose focus is on string reasoning and security checking and jalangi whose focus is on light weight source instrumentation symjs aims to provides an end to end fully automatic and comprehensive symbolic executor.
we have demonstrated how to build enhancements such as taint analysis in the framework.
in addition to performance improvement we plan to enhance the interactions between the tool and web servers.
we are also interested in detecting security vulnerabilities in websites.
.