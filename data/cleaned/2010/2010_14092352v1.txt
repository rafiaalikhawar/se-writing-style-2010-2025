addiff semantic differencing for activity diagrams shahar maoz jan oliver ringert bernhard rumpe software engineering rwth aachen university germany abstract activity diagrams ads have recently become widely used in the modeling of work ows business processes and webservices where they serve various purposes from documentation requirement de nitions and test case speci cations to simulation and code generation.
as models programs and systems evolve over time understanding changes and their impact is an important challenge which has attracted much research e orts in recent years.
in this paper we present addi a semantic di erencing operator for ads.
unlike most existing approaches to model comparison which compare the concrete or the abstract syntax of two given diagrams and output a list of syntactical changes or edit operations addi considers the semantics of the diagrams at hand and outputs a set of di witnesses each of which is an execution trace that is possible in the rst ad and is not possible in the second.
we motivate the use of addi formally de ne it and show two algorithms to compute it a concrete forward search algorithm and a symbolic xpoint algorithm implemented using bdds and integrated into the eclipse ide.
empirical results and examples demonstrate the feasibility and unique contribution ofaddi to the state of the art in version comparison and evolution analysis.
categories and subject descriptors d. .
design tools and techniques d. .
software program veri cation general terms documentation veri cation s. maoz acknowledges support from a postdoctoral minerva fellowship funded by the german federal ministry for education and research.
j.o.
ringert is supported by the dfg gk algosyn.keywords software evolution activity diagrams di erencing .
introduction activity diagrams ads have recently become widely used in the modeling of work ows business processes and webservices where they serve various purposes from documentation requirement de nitions and test case speci cations to simulation and code generation.
speci cally we are interested in a variant of the standard uml ads which is rich and expressive supporting guarded branches parallel interleaving process executions inputs assignments etc.
as models programs and systems evolve over time during the development lifecycle and beyond it e ective change management and controlled evolution are major challenges in software development and thus have attracted much research e orts in recent years see e.g.
.
fundamental building blocks for tracking the evolution of software artifacts are di operators one can use to compare two versions of a program or a model.
most existing approaches to di erencing concentrate on matching between model elements using di erent heuristics related to their names and structure and on nding and presenting di erences at a concrete or abstract syntactic level.
while showing some success most of these approaches are also limited.
models that are syntactically very similar may induce very di erent semantics in the sense of meaning and vice versa models that semantically describe the same system may have rather di erent syntactic representations.
thus a list of syntactic di erences although accurate correct and complete may not be able to reveal the real implications these di erences may have on the correctness and potential use of the models involved.
in other words such a list although easy to follow understand and manipulate e.g.
for merging may not be able to expose and represent the semantic di erences between two versions of a model in terms of the bugs that were xed or the features and new bugs.
.
.
that were added.
in this paper we present addi a semantic di operator for ads.
unlike existing di erencing approaches addi is a semantic di operator .
rather than comparing the concrete or the abstract syntax of two given diagrams and outputing a list of syntactical changes or edit operations addi considers the semantics of the diagrams at hand and outputs a set of di witnesses each of which is an execution trace that is possible in the rst ad and is not possible in the second.
these traces provide concrete proofs for the meaning s. maoz j. o. ringert b. rumpe addiff semantic differencing for activity diagrams in proc.
euro.
soft.
eng.
conf.
and sigsoft symp.
on the foundations of soft.
eng.
esec fse pp.
acm .
se rwth.de publicationsof the change that has been done between the two compared versions and for its e ect on the use of the models at hand.
we specify ads using a variant of standard uml ads which can also be given textually using a grammar de ned in monticore .
the syntax of an ad consists of action nodes pseudo nodes initial nal decision merge fork join transitions input variables and local variables.
transitions outgoing decision nodes are guarded with boolean expressions over the input and local variables.
input variables values are set by the environment.
action nodes are labeled with action names and may include assignments to local variables.
we de ne the operational semantics of an ad using a translation to a nite automaton with variables over nite domains.
this induces a trace based semantics i.e.
a set of action traces from an initial node to a nal node considering also the values of input variables.
branches outgoing fork nodes describe parallel executions they are used to succinctly specify concurrent interleaving traces.
an overview of the syntax and semantics of our ads is given in sect.
.
given two ads ad1andad2 addi ad1 ad is roughly de ned as the set of execution traces possible in the rst ad and not possible in the second.
as there may be exponentially many di traces we are speci cally interested in the shortest ones i.e.
ones that do not have a pre x which is a di erentiating trace.
in addition we restrict the operator to provide only a single shortest di trace for each possible assignment to input variables.
to compute addi we transform each of the ads into a module in smv the input language of the smv model checker .
we then present two algorithms a concrete forward search algorithm and a symbolic xpoint algorithm.
the second algorithm relies on the technologies of symbolic model checking in order to address the state explosion problem of the rst.
we present them both in order to allow their comparison.
the formal de nition of addi and the two algorithms are described in sect.
.
we have implemented the two algorithms for addi using binary decision diagrams bdds and integrated them into an eclipse plug in.
the plug in allows the engineer to compare two selected ads to check if they are equivalent and to textually and visually browse the di witnesses found if any.
we describe the plug in implementation in sect.
.
we have evaluated the plug in against all examples shown in this paper and many other ads.
the results of our evaluation including a performance comparison of the two algorithms appear in sect.
.
in addition to nding concrete di witnesses if any exist which demonstrate the meaning of the changes that were made between one version and another addi can be used to compare two ads and decide whether one ad semantics includes the other ad semantics the latter is a re nement of the former are they semantically equivalent or are they semantically incomparable each allows executions that the other does not allow .
when applied to the version history of a certain ad as can be retrieved from a version repository such an analysis provides a semantic insight into its evolution which is not available in existing syntactic approaches.
model and program di erencing in the context of software evolution has attracted much research e orts in recent years.
in contrast to our work however most studies in this internalhire.v1 register assign to projectadd to website manager interview!internal assign to projectget welcome pack authorize paymentmanager reportinternalhire.v2 register assign to projectadd to website manager interview!internal assign to projectget welcome pack authorize paymentmanager reportassign keysfigure versions and of the hire activity area present syntactic di erencing at either the concrete or the abstract syntax level.
we discuss related work in sect.
.
finally our work on semantic di erencing does not come to replace existing syntactic di erencing approaches.
rather it is aimed at augmenting and complementing existing approaches with capabilities that were not available before.
we discuss the combination of syntactic and semantic differencing as well as other future work directions in sect.
.
the next section presents motivating examples demonstrating the unique features of our work.
sect.
provides preliminary de nitions of the ad language syntax and semantics as used in our work.
sect.
introduces addi and the two algorithms to compute it.
sect.
presents the implementation sect.
presents an evaluation and a discussion sect.
considers related work and sect.
concludes.
.
examples we start o with motivating examples for semantic differencing of ads.
the examples are inspired by real world ads we have obtained from several sources see sect.
.
.
example i adhire v of fig.
describes a company s work ow when hiring a new employee.
roughly rst the employee is registered.
then if she is an internal employee she gets a welcome package she is assigned to a project and added to the company s computer system in two parallel activities branching o a fork node she is interviewed and gets a manager report and nally her payments are authorized.
otherwise note the decision node at the beginning of the ad if the new employee is external she is only assigned to a project before her payments are authorized.
after some time the company deployed a new security system and every employee had to receive a key card.
a revised work ow was created as shown in hire v of fig.
.
later a problem was found sometimes employees are assigned to a project but cannot enter the building since they do not have a key card yet.
this bug was xed in the next version hire v shown in fig.
.
finally the company has decided that external employees should report to managers too.
thus the merge between the two branches for internal and external new employees has moved up in between theinternalhire.v3 register assign to projectadd to website manager interview!internal assign to projectget welcome pack authorize paymentmanager reportassign keysinternalhire.v4 register assign to projectadd to website manager interview!internal assign to projectget welcome pack authorize paymentmanager reportassign keysfigure versions and of the hire activity interview and the report nodes.
the resulting 4th version of the work ow hire v is shown in fig.
given these four versions of the activity an evolution analysis is called for.
comparing hire v and hire v usingaddi reveals that they are semantically incomparable some executions of hire v are no longer possible in hire v and some executions of hire v were not possible in hire v .
moreover it reveals that handling of internal employees has changed but handling of external ones remained the same between the two versions.
comparing hire v and hire v reveals that the latter is a re nement of the former hire v has removed some traces of hire v and did not allow new traces.
in particular addi hire v hire v shows that the trace where a person is assigned to a project before she gets a key card was possible in hire v and is no longer possible in hire v i.e.
it demonstrates that the bug was xed.
finally comparing hire v and hire v using addi reveals that although hiring of external employees has changed between the two versions hiring of internal employees did not addi hire v hire v contains a single trace where the employee is external not internal.
that is despite the syntactic change of moving the merge node from after to before the report node which is also part of the trace of handling internal employees.
.
example ii adproj v of fig.
describes a company s work ow when receiving a new project.
roughly rst the project is registered.
then the required work is de ned the o ce work is done the clients work is done and a report is written.
if the project is of type small the activity continues to nal report and is completed.
if the project is of type large a second phase of the required work is de ned the o ce work is done the clients work is done and a report is written before continuing to the nal report and completion.
after some time the activity designer suggested a refactoring instead of the explicit duplication of the four work actions in the diagram a loop will be de ned.
the designer added a local variable c which is initialized when the project is registered and is incremented when writing the report.
proj.v1 register project define work office work clients work final reportoffice work clients workproj.v2 register project define work office work clients work final reportproj.v3 define work office workclients work final reportdefine work report reportreportreportc c c c type large c type smallregister project c c c c type smalltype large type small c type largefigure versions of the new project activity the guards of the decision node were changed accordingly.
the resulting ad is proj v shown in the same gure.
before committing the new activity to the models repository the designer used addi to compare proj v and proj v .
indeed she found that addi proj v proj v addi proj v proj v .
this proves that the refactoring did not change the semantics of the activity and the new version can be safely committed to the repository.
finally a consultant has examined the new project activity and suggested that in some cases clients work can be done before the o ce work.
following this recommendation the designer added fork and join nodes to the activity to de ne the o ce work action and the clients work action on separate branches of a fork.
the resulting ad is proj v shown in the same gure.
comparing proj v and proj v using addi revealed that the new version has introduced several new traces that were not possible before traces where clients work is done before o ce work in the rst or in the second iteration of the loop .
thus the comparison demonstrated that the required enhancement was added.
moreover the comparison showed that all traces of proj v are still possible in proj v because addi proj v proj v .
thus it proved that no behavior was lost.
the above examples are simple and thus immediately reveal the di erences when looking at them.
we use them in order to demonstrate our ideas.
however we have also done experiments with larger synthetic and real world ad s where di erences were manually much harder to nd.
see sect.
.
.
preliminaries we de ne the ad language syntax and semantics as used in our work.
.
ad language syntax an activity diagram is a structure ad ha vinp vloc an pn tiwhere ais a set of action names.
vinpis a possibly empty set of immutable input variables over nite domains.
vlocis a possibly empty set of local variables over nite domains.
anis a set of action nodes an1 an k. each action node anis labeled with an action name acname an ac2a and a possibly empty set of assignment expressions to the variables in vloc.
pnis a set of pseudo nodes consisting of initial nodes pninit nal nodes pnfin decision nodes pmdec merge nodes pnmer fork nodes pnfork and join nodes pnjoin.
tis a set of transitions of the form t hnsrc ntrg guardi where nsrc ntrg2 an pn and guard is a boolean expression over the variables in vinp vloc.
unless nsrcis a decision node guard true.
we do not formally capture here obvious well formedness rules and context conditions such as initial nodes have no incoming transitions nal nodes have no outgoing transitions fork nodes must be followed by join nodes to remove all concurrency when reaching a nal node actions should not repeat in di erent forked branches etc.
in addition we assume that the boolean expressions used as guards on transitions outgoing decision nodes are semantically exclusive that is no assignment to the diagram variables makes more than one of them true.
thus the input variables provide external non determinism while except for forked branches our ads are internally deterministic.
we consider two concrete syntax de nitions for ads a concrete visual syntax based on uml ads and a concrete textual syntax de ned using monticore .
we omit the concrete syntax de nitions from this paper.
the implementation we present in sect.
supports a subset of full uml ads it supports action nodes and pseudo nodes initial nal fork join decision and merge each ad has exactly one initial node but may have multiple nal nodes.
for simplicity reasons but without loss of generality in our implementation no two pseudo nodes can follow each other directly.
in addition local and input variables have to be declared as such in the rst action node all variables nite domains need to be given as smv types or enumerations and each local variable needs to be assigned a value in the rst action node.
we support boolean guards specied in the rich smv expression language .
assignments to local variables can be made from any action node using values from smv expressions.
.
ad language semantics we distinguish operational semantics and trace based semantics.
the operational semantics is based on the de nition of a state machine step taking the ad from one state to another where a state consists of a set of current action nodes and an assignment to all input and local variables.
the main idea of our operational semantics is to conceptually translate each ad2adinto a nite state machine fsm .
each state is a con guration containing the values of all local variables and input variables recall that variables range over nite domains the executed action and some extra variables with information on the control ow of the ad.
based on this state and evaluated guards possible transitions are computed that lead to the next state with anexecuted action possibly changed local variables values and a new con guration of the control ow tracking variables.
we formally de ne the operational semantics using a transformation of an ad to a module of smv the language of the smv model checker .
our translation is inspired by the work of but extends this previous translation with support for data.
the complete translation together with a detailed example appears in a separate document .
local variables assist the ad engineer together with guards to control the execution sequences of actions e.g.
by de ning loops or activating disabling branches of decision nodes.
input variables in contrast to local variables are initialized by the environment and do not change during the run of an ad.
the runs of two ads are compared with the same input i.e.
where common input variables of both ads have the same values.
we consider all possible input values of both ads when comparing them.
our semantics of ads is rather expressive it considers values of input variables to be set by the environment external non determinism .
however we only support internal non determinism through interleaved execution of forked branches and not through non deterministic decision nodes the current con guration and the next executed action determine the next con guration.
thus for each assignment to the input variables there could be many possible executions due to the interleaving semantics of fork nodes.
we de ne a trace based semantics that is induced by the operational semantics.
traces are sequences of states from the state space of the ad s fsm.
definition ad state .
a state of an ad adis an assignment to all variables de ned in the var section of its smv module.
this includes the last executed node acnode and its action name ac the values of variables v2ad vinp ad vlocand the values of control ow tracking variables.
ad states have a nite number of possible successor states that can be reached within one step.
by construction each such step executes an action or reaches a nal node.
we de ne the successors of an ad state sassuccessors s .
definition successor states .
for every ad state s successors s is the set of ad states reachable from sin one step of the smv module.
each run of an ad starts with an initial state in the initial node.
a sequence of successor states that describe a legal execution of the ad s fsm is a trace.
a trace from the initial to a nal node of the ad is an accepting trace.
definition ad traces .
a sequence of ad states tr s0 s1 s kof ad adwithsi 12successors si and s0 acnode2ad pninitis called a trace.
the set of all traces of an ad adis denoted by traces ad .
a trace is called an accepted trace if its last state s node is a nal node of the ad.
the set of all accepted traces of an ad adis denoted byacceptedtraces ad .
.
addiff .
definitions given two ad states s12ad1ands22ad2 we say that s1ands2arecorresponding i the action names and values of equally named input variables of the two states are the same.
formally definition corresponding states .
given two ads ad1andad2 and two states s12ad1ands22ad2 we say thats1ands2are corresponding denoted s1 s2 i the following conditions hold .s1 ac s2 ac .8v2vinp vinp s1 val v s2 val v .
the de nition of corresponding states punctually extends to traces in a natural way.
given two ads a trace of the rst ad is a di trace i there exists a trace of the second ad where all states except the last correspond to the states of the rst trace but the last state of the rst trace does not correspond to any possible successor state of the second trace.
formally definition diff trace .
given two ads ad1and ad2 a di trace is a sequence of states tr1 s0 s1 sk sk s.t.
.tr12traces ad1 .9tr2 s0 s1 sk 2s.t.tr22traces ad2 8i i k si si sk 2s.t.sk sk s0 s1 sk sk 22traces ad2 .
tr2is called a corresponding di trace of tr1.
we denote the set of all di traces of ad1vs.ad2by di traces ad1 ad .
note that di traces is not symmetric.
we are now ready to present the de nition of addi .
note that we are interested only in shortest di traces we restrict addi to di traces that do not have another di trace as pre x. moreover to make the set addi succinct for each initial state of ad1 if there is a di trace that starts at this initial state we want only one such trace to be in addi .
formally definition addiff .
addi ad1 ad is a subset of di traces ad1 ad s.t.
.8tr2addi ad1 ad tr0s.t.tr02addi ad1 ad tr0 tr .8s0 12ad1 initials if9tr2di traces ad1 ad s.t.trstarts at s0 thenjftr2addi ad1 ad jtrstarts at s0 1gj .
finally note that we do notrequire that di traces can be extended into accepting traces ones that end at a nal node see def.
.
for an alternative de nition see the discussion in sect.
.
.
computing addiff we present two di erent algorithms a concrete forwardsearch algorithm and a symbolic xpoint algorithm.
.
.
algorithm i we compute addi ad1 ad using a bfs like traversal of the state space of ad1that is used to guide a bfs like traversal of the state space of ad2.
roughly the algorithm uses a queue for corresponding states pairs that have been reached but whose successors have not yet been traversed the use of the queue guarantees that shortest paths will be found rst .
it also maintains a list of visited corresponding state pairs and a list of rejecting state pairs.
initially all corresponding initial states pairs are inserted in the queue and all initial states of ad1that do not have a correspondinginitial state in ad2are added to the list of rejecting statepairs.
then for each state pair taken out from the queue the algorithm checks that each successor state of the rst element in the state pair the state in ad1 has a corresponding successor state of the second element in the state pair the state in ad2 .
every corresponding pair found if not visited before is inserted to the queue.
if no corresponding successor is found we know we have found the end state of a shortest di trace we add it to the list of rejecting statepairs and we remove from the queue all the state pairs whose input variables values for ad1are the same as the ones for the state we have found.
when the queue is empty the list of visited state pairs is used to construct the traces leading back from the rejecting state pairs to the initial states.
a pseudo code for the algorithm is given in proc.
which uses proc.
and .
we describe these procedures below.
the algorithm uses a structure pair made of two pairs of states predecessor and current state in ad1 pre 1and cur and predecessor and current state in ad2 pre 2and cur .
two pairs are considered equal if their current states are equal ignoring predecessor states .
pair is used to keep track of pairs of visited states one state from each ad and of their predecessors as found during the traversal of the state space.
the predecessors are used in the reconstruction of the traces from the lists of rejecting and visited pairs.
proc.
de nes the required structures l. a queue of pairs a list of visited pairs a list of rejecting pairs and a list of list of pairs which will hold the computed di traces.
it iterates over all initial states of ad1 and for each of them looks for a corresponding initial state in ad2.
if a corresponding state is found the new pair is inserted to the queue and to the visited list l. .
if no corresponding state is found a pair where only the ad1current state is de ned is added to the list of rejecting state pairs l. .
after initialization the algorithm calls traverse proc.
to iterate on the queue until it is empty.
for each dequeued pair the procedure iterates over all the successors of its currentad1state.
for each successor it tries to nd a corresponding successor of the current ad2state.
if a corresponding state is found the new pair is inserted to the queue and to the visited list l. .
if no corresponding state is found a pair where only the ad1current state is de ned is added to the list of rejecting states l. .
in addition all state pairs whose current ad1state agrees with the current ad1state in the rejecting pair on input variables are removed from the queue l. .
this ensures that no further searching of di traces outgoing the same initial state will be done.
finally trace proc.
is used to reconstruct the traces leading from initial states to the rejecting states that have been found.
the procedure works backward it starts from the rejecting pairs and uses the predecessor states to build the required traces from the rejecting states back to the initial states using the pairs saved in the visited list.
it continues as long as their predecessor states are de ned i.e.
as long as it has not reached an initial state.
.
.
algorithm ii we compute addi ad1 ad using a symbolic least xpoint algorithm.
the algorithm relies on the technologies of symbolic model checking and is inspired by the classic xpoint algorithm to compute a maximal simulation relation and more speci cally by the synthesis algorithm of procedure concrete addi ad1 ad2 de ne queuepairs as queue of pair de ne visited rejects as list of pair de ne traces as list of lists of pair for all ini12ad1 initials do foundcorresponding false for all ini22ad2 initials do ifcorresponding ini1 ini then addpair ini ini toqueuepairs visited foundcorresponding true end if end for if not foundcorresponding then addpair ini torejects end if end for visited rejects traverse ad1 ad2 traces trace visited rejects return traces procedure traverse ad1 ad2 while queuepairs is not empty do p pairfrom queuepairs for all suc12p cur successors do foundcorresponding false for all suc22p cur successors do ifcorresponding suc1 suc then newpair pair p cur suc p cur suc ifnewpair 2visited then addnewpair toqueuepairs visited end if foundcorresponding true break end if end for if not foundcorresponding then addpair p cur suc p cur torejects remove all pairfrom queuepairs where p cur inputs pair cur inputs end if end for end while return visited rejects where intermediate values from the xpoint computation are used in the construction of a concrete winning strategy.
roughly our symbolic algorithm starts with a representation of all non corresponding states.
it then moves backward and adds to the current set of states states from which there exists a successor in ad1such that for all successors in ad2 the resulting successor pair is in the current set of states.
most importantly to help in the construction of di traces later at each step backward the algorithm remembers the newly computed set of added states.
the steps backward continue until reaching a least xpoint that is until no more states are added.
when the xpoint is reached the algorithm checks whether the last computed set the xpoint set includes initial states.
for each such initial state if any the algorithm uses the sets of states computed during the backward steps to move forward from the minimal position it can start from and construct shortest di traces.
we present our algorithm in general set notation with the set operations of union intersection and complementation.
in the pseudo code below sets with no subscript are sets of states over the union of all variables from ad1andad2.
fori2f1 2g sets with subscript iare sets of states overprocedure trace visited rejects for all rejectingpair2rejects do de ne tras list of pair curpair rejectingpair while curpair is not null do addcurpair totr ifcurpair pred 1is not null then curpair getv isited curpair pred curpair pred visited else break end if end while addtrtotraces end for return traces procedure symbolic addi ad1 ad2 de ne traces as list of lists of set de ne mem as array of set mem least xpoint with mem ad1 ad2 ifmem last initials6 then traces build traces from mem ad1 ad2 mem end if return traces the variables of adi.
the operator sjadiis used to restrict the variables of the set sto the variables of adi all other variables are existentially quanti ed out .
the operation choose one relates to choosing a single element from the relevant set a single concrete assignment to the variables .
the sets corr andinitials are the set of corresponding states and the set of joint initial states respectively.
when intersecting a set siover the variables of adiwith a set sover the union of all variables from both ads the result is a set over the union of variables where the variables of adiagree with their possible assignments in the set si.
in the implementation the sets are represented using bdds.
a pseudo code for the algorithm is given in proc.
which uses proc.
and .
note that in the nal iteration of the loop in proc.
reached with i the assignment to next 2is guaranteed to set next because the rst location in the memory array equals corr.
this guarantees that the last state in each di trace assigns no values to the variables of ad2 indeed the last ad1state in the trace should have no corresponding ad2state in the trace.
if the user is interested only in checking the existence of di erences but not in the set of all witnesses we can stop the steps backward as soon as the set of added states includes an initial state by checking whether p initials already after line in proc.
.
in some cases as our evaluation shows see sect.
this is indeed much faster than waiting for the xpoint to be reached and for all traces to be enumerated.
note that trace enumeration is not symbolic and thus may not scale well.
finally for both algorithms the concrete and the symbolic correctness and completeness are proved by induction on the length of the traces and rely on the fact that the ads are internally deterministic.
.
implementation and uses we have implemented addi and integrated it into a prototype eclipse plug in.
the input for the implementation areprocedure least xpoint with mem ad1 ad2 de ne mem as array of set de ne p z oldz asset de ne iasnumber z corr oldz i mem z while z6 oldzdo oldz z p f s1 s2 js12ad1 s22ad2 9suc12s1 successors s.t.8suc22s2 successors suc1 suc 2zg z z p i i mem z end while return mem procedure build traces from mem ad1 ad2 mem for all ini12 mem last initials jad1do de ne tras list of set nd minimal js.t.ini1 mem ini2 choose one from ini1 initials jad25 cs combinedstate ini1 ini addcstotr fori jdown to 1do next choose one from csjad1 successors mem jad1 next choose one from next corr mem jad2 csjad2 successors cs combinedstate next next addcstotr end for addtrtotraces end for return traces uml ads drawn and parsed using eclipse uml apis.
the plug in transforms the input ads into smv format.
it then computes addi via the apis of jtlv a framework for the development of veri cation algorithms using bdd based symbolic mechanisms.
the underlying bdd package used is cudd .
both algorithms are implemented and the engineer can choose which one to use.
the plug in together with all the example ads we used in the evaluation is available from .
.
browsing diff traces the plug in allows the engineer to compare two selected ads and to textually and visually browse the di traces found if any.
fig.
shows an example screenshot where the engineer has selected to compare diagrams hire v top and hire v middle presented in sect.
and is browsing one of the two di traces that were found.
note the numbered and highlighted action nodes which visually show the states along one of the di traces that the plug in has found the trace register get welcome pack assign to project is possible in hire v and is not possible in hire v .
a textual representation of the di trace is displayed on the lower pane.
this representation of a trace is a special case of a model based trace see .
it shows the details of each state in the current di trace in both ads consisting of the action name and all variable values.
this textual representation is important because it is more detailed and because it scales better than the visual representation when handling long traces.clicking check difference checks whether the semantics of the second ad includes the semantics of the rst.
clicking compute witnesses computes the di traces and shows a message telling the engineer how many traces were found if any.
the next and previous buttons browse for the next and previous di traces.
the switch direction button switches the order of comparison.
the concrete and symbolic buttons toggle between the two addi algorithms.
.
high level evolution analysis another application enabled by the plug in is high level evolution analysis.
the plug in supports a compare command given two ads ad1andad2 the command checks whether one ad is a re nement of the other are the two ads semantically equivalent or are they semantically incomparable each allows traces the other does not allow .
formally compare ad1 ad returns one of four answers ifaddi ad1 ad and addi ad2 ad ifaddi ad1 ad and addi ad2 ad ifaddi ad1 ad and addi ad2 ad ifaddi ad1 ad and addi ad2 ad given a reference to a series of historical versions of an ad as can be retrieved from the ad s entry in a revision repository e.g.
svn the plug in can use the compare command to compute a high level analysis of the evolution of the ad which new versions have introduced new behaviors relative to their predecessors which new versions have eliminated behaviors relative to their predecessors and which new versions included only syntactical changes that have not changed the semantics of the ad.
for example applying this evolution analysis to the ads presented in sect.
reveals hire v hire v hire v hire v hire v hire v proj v proj v and proj v proj v .
.
ev aluation and discussion .
evaluation we have tested our implementations of addi against synthetic ads and against real world ads selected and adapted from several sources selected ads from a library of more than business process models by ibm our selection is representative of the size and complexity statistics of the models in this library as described in several models with version history we have obtained from nokia corp. test management and from a third company which requested to remain unnamed .
the ibm models did not include version history information so we have manually added some mutations e.g.
action additions and removals change of branching conditions .
the models from nokia and the third company included version history.
all the models we have used are available in a dedicated evaluation project that is attached to the plug in so that all experiments we report on below can be reproduced.
the experiments were performed on a regular laptop computer intel dual core cpu .
ghz with gb ram running windows vista.
running times are reported in milliseconds.
.
.
quantitative evaluation table upper part shows results from executing addi over the examples presented in sect.
and selected realworld ads from the sources mentioned above.
for each two versions we report the number of nodes the size of thefigure the prototype plug in comparing two ads hire v 2and hire v .
the highlighted and numbered nodes show one of the two di traces found by addi for an internal employee the trace register get welcome pack and assign to project is possible in hire v 2and is not possible in hire v .
a detailed textual representation of this di trace is provided in the lower pane.
reachable state space the number of di traces found the length of the shortest and longest di traces found and the times it took the concrete and the symbolic algorithms to decide the existence of at least one di trace and to compute all di traces.
to examine scalability we used synthetic ads of comparable or much larger size in both number of action nodes and state space divided into two families of worst case ads a family of forking ads with concurrent section of length land growing width w and a family of linear ads with two linear fragments of length lseperated by a single decision over a domain of increasing size d. the lower part of table shows results from executing addi on these ads with versions created using synthetic mutations replacing deleting or moving of actions.
these results suggest the following observations.
first on small ads the two algorithms show similar performance results.
however as the ads grow the symbolic algorithm performs much better than the concrete one.
on the largest ads the concrete algorithm performance is not practical while the symbolic algorithm stays within less than seconds on all real world ads .
we believe this means addi can be used by engineers in practice.
second checking for the existence of a di erence is sometimes much faster than listing all di traces speci cally when there are many di traces or when the shortest one is much shorter than the longest one.
again as the ads grow the symbolic algorithm outperforms the concrete one.
that said we do have synthetic worst case examples where the symbolic algorithm is not better than the concrete one.
this happens e.g.
in the extreme case of a long linear ad with no branches or forks.
it also happens when the number of di traces is large and enumerating them takesmuch time.
moreover the speci c change done between the two ads may have signi cant e ect on both algorithms performance two very syntactically similar mutations e.g.
a rename in one branch or in another may induce dramatic changes in the number of di traces.
complete results of and models used in our experiments are available from .
.
.
qualitative evaluation as mentioned above we have obtained several real world ads with version history information from nokia corp. test management and from another company.
we used our plug in to compare di erent versions and analyze the evolution of these ads.
we have also used other publicly available di tools eclipse default di erencing mechanism and emfcompare in the analysis and compared them with addi .
screen captures from our analysis sessions are available from .
classical textual di erencing was as expected not helpful in comparing the ads as it merely compared their xmi representations.
emfcompare reported correct addition and removal of actions and transitions and presented them on the abstract syntax tree structures of the two ads.
still this was not so helpful in understanding the di erences between the ads because the comparison was done on the ast level and abstracted the control ow away and the results were shown on the ast and not on the ads themselves we saw the changes in the ast and had to manually search for their concrete manifestation on the ads.
moreover in many cases the list of additions and removals reported by emfcompare was too large to be useful e.g.
when comparing hire v and hire v presented earlier emfcompare reported additions and removals much more than one would intuitively expect for these twoad names nodes reachable state spaces wit.
shortest longest alg.
i decide all ms alg.
ii decide all ms hirev1 hirev2 hirev2 hirev3 hirev3 hirev4 projv1 projv2 projv2 projv3 ibm3561 ibm2905 ibm2568 ibm0863 ibm3735 ibm2557 nokiaav1 nokiaav2 nokiaav3 anonv1 anonv2 forking w1 l6 mutated forking w2 l6 mutated forking w3 l6 mutated forking w4 l6 mutated lbl l12 d16 mutated lbl l12 d32 mutated lbl l12 d64 mutated lbl l12 d128 mutated table results from computing addi for selected example real world and synthetic ads see sect.
.
.
.
for each two versions we report the number of nodes the reachable state space the number of di traces found the length of the shortest and longest di traces found and the times it took the concrete and the symbolic algorithms to decide the existence of at least one di trace and to compute all di traces.
ads addi reports a total of three di witnesses for this example two in one direction one in the other .
in contrast our plug in computed di traces and highlighted them visually on the ads themselves.
thus in addition to the semantic characteristics of the comparison which shows the actual meaning of the changes that were done we have also experienced the advantages of languagespeci c di erencing over language agnostic di erencing as well as the advantage of showing the di erences directly on the original diagrams rather than in a separate list.
the following lessons learned are noteworthy.
first in some cases the number of traces returned by addi was large and the usefulness of the results was limited.
to address this in the future we consider adding lters e.g.
to group together traces that agree on the list of actions and di er in the values of input variables and present only a representative trace from each group.
similarly we consider user interaction the engineer would choose a node of interest and the plug in would limit the results to di traces that include exclude this node.
second some of the ads we have analyzed included swim lanes which relate action nodes with roles.
it seems that swim lanes which are optional in the uml standard are rather popular so in the future it may be useful to add the role information to the semantics of ads and consider it in computing the di erences.
finally some of the ads we have investigated were only semi formal or included minor changes in action names which seem to indeed be renames rather than new actions with similar names.
addi considers such renames as new actions and we had to manually identify these cases and correct them.
to better address these cases in the future a matching heuristics needs to be employed based perhaps not only on syntactic structural similarity matching but also on natural language and domain speci c ontology.
.
discussion .
.
alternatives and extensions our current de nition of di traces does not require that they can be extended into accepting traces ones that end at a nal node see def.
.
we have chosen not to require this in order to support the comparison of incomplete and perhaps inconsistent ads ones where not all executions are eventually accepted.
such ads may exist mainly at the early stages of the version history of a model indeed in our evaluation we have seen such incomplete ads .
we could have given a more restrictive de nition that limits di traces to ones that can be extended to accepted traces.
adapting the algorithms we have presented to this restricted de nition is not di cult.
moreover we have chosen to compute only a single shortest representative of the di traces outgoing each initial ad state that is a single shortest di trace for each assignment to input variables of the rst ad .
we consider this to be a good choice as it keeps the addi results relatively succinct and thus easy to read and understand by engineers in most typical cases.
alternatively one may suggest to compute a larger set containing all di traces.
adapting the algorithms to this more permissive de nition is possible however as there may be exponentially many such traces performance may be a problem.
on the other hand and in contrast following the lesson learned in our evaluation we consider an alternative that would limit the number of di traces to present group them according to the list of actions they include and present a single representative trace of each group together with a predicate that describes the input variable values that are common to the traces in the group.
we believe this may be computed symbolically i.e.
while avoiding the enumeration of all traces in the computation.
we leave this for future work.finally our current work supports a subset of the uml ad language.
in particular we do not yet support structured activity nodes which allow hierarchical nesting of action nodes or reference from a node to another activity.
hierarchy is useful in medium and large scale designs so supporting it is important.
moreover a hierarchy induces an abstraction mechanism which a semantic comparison may take advantage of.
additional language features may be added.
we leave these for future work.
.
.
syntactic differencing and matching semantic di erencing in general and addi in particular do not come to replace existing syntactic di erencing approaches.
rather they are aimed at augmenting and complementing existing approaches with capabilities that were not available before.
thus combining addi with existing approaches to matching and syntactic di erencing see e.g.
is an important direction for future work.
for example we may extend the applicability of semantic differencing in comparing diagrams whose elements have been renamed or moved in the course of evolution by applying a syntactic matching before running the semantic di erencing.
the result of such an integrated solution would be a mapping plus a set of di traces.
as another example we may use information extracted from syntactic di erencing as a means to localize and improve the presentation and performance of the semantic di erencing computation.
.
related work we discuss related work on ad formal semantics and analyses and on model and program comparisons.
eshuis presents symbolic model checking of ads.
the work transforms ads into smv and uses the nusmv model checker to verify ltl properties.
the semantics given is partly inspired by the semantics of statemate .
our translation of ads into smv is somewhat similar to the two translations suggested in .
does not handle data while our work does.
the motivation of is model checking while our motivation is model comparison.
st orrle de nes a denotational semantics for uml ads as a mapping to procedural petri nets.
he also surveys and compares several previous studies that deal with a semantics for ads in terms of their semantic domain and expressiveness.
knieke and goltz present an executable semantics for uml ads with step semantics adapted from .
the works of support object nodes and several types of action nodes while our current work supports only basic action nodes.
our work can be extended to support object nodes and other types of action nodes.
our focus is not on the di erent possible variants of ads and their semantics but on the de nition and the computation of the semantic di operator we have presented and on its use in evolution related tasks.
model and program di erencing in the context of software evolution has attracted much research e orts in recent years see .
in contrast to our work almost all studies in this area however present syntactic di erencing at either the concrete or the abstract syntax level.
alanen and porres describe the di erence between two models as a sequence of elementary transformations such as element creation and deletion and link insertion and removal when applied to the rst model the sequence of transformations yields the second.
kuster et al.
investigate di erencing and merging in the context of processmodels focusing on identifying dependencies and con icts between change operations.
engel et al.
present the use of a model merging language to reconcile model di erences.
comparison is done by identifying new old mof ids and checking related attributes and