proactive detection of collaboration conflicts yuriy brun reid holmes michael d. ernst david notkin computer science engineering school of computer science university of washington university of waterloo seattle wa usa waterloo on canada brun mernst notkin cs.washington.edu rtholmes cs.uwaterloo.ca abstract collaborative development can be hampered when conflicts arise because developers have inconsistent copies of a shared project.
we present an approach to help developers identify and resolve conflicts early before those conflicts become severe and before relevant changes fade away in the developers memories.
this paper presents three results.
first a study of open source systems establishes that conflicts are frequent persistent and appear not only as overlapping textual edits but also as subsequent build and test failures.
the study spans nine open source systems totaling .
million lines of code our conflict data is derived from development versions of the systems.
second using previously unexploited information we precisely diagnose important classes of conflicts using the novel technique of speculative analysis over version control operations.
third we describe the design of crystal a publicly available tool that uses speculative analysis to make concrete advice unobtrusively available to developers helping them identify manage and prevent conflicts.
categories and subject descriptors d. .
coding tools and techniques d. .
programming environments d. .
metrics process metrics general terms design human factors experimentation keywords collaborative development collaboration conflicts developer awareness speculative analysis version control crystal .
introduction each member of a collaborative development project works on an individual copy of the project files source code build files etc.
.
each developer repeatedly makes changes to his or her local copy of the files shares those changes with the team and incorporates changes from teammates.
the loose synchronization of these activities permits rapid development progress but also allows two developers to make simultaneous conflicting changes.
such conflicts are costly they delay the project while the conflict is understood and resolved.
fear of conflicts is also costly.
a developer may permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.choose to postpone the incorporation of teammates work because of a concern that a conflict may be hard to resolve .
ironically this fear of potential conflicts can cause developer copies to diverge making realconflicts more likely.
conflicts can be textual orhigher order .
a textual conflict arises when two developers make inconsistent changes to the same part of the source code.
to prevent subsequent changes from overwriting previous ones a version control system vcs allows the first developer to publish changes but precludes the second developer from publishing until the conflict is resolved automatically by the vcs or manually by a developer .
higher order and likely more damaging conflicts arise when the vcs can integrate the developers textual changes but the changes are semantically incompatible and can cause compilation errors test failures or other problems.
such conflicts are problematic to detect and resolve in practice .
as with errors in programs it is generally easier and cheaper to identify and fix conflicts early before they propagate in the code and the relevant changes fade away in the memories of the developers.
currently this information is not readily available to developers .
our approach speculative analysis unobtrusively provides information about the presence or absence of conflicts in a continual and accurate way.
our intent is for this information to allow developers make better informed decisions about how and when to share changes while simultaneously reducing the need for human processing and reasoning.
we make the following contributions we analyze nine open source systems and show that in practice conflicts between developers copies of a project are the norm rather than the exception persist on average days and are often higher order.
using previously unexploited information we precisely diagnose important classes of conflicts and offer concrete advice about addressing them.
we do this by introducing a novel technique called speculative analysis that anticipates actions a developer may wish to perform and executes them in the background.
reporting the consequences of these likely version control operations can improve the way in which collaborative developers identify and manage conflicts.
we design and implement an open source publicly available tool called crystal1 that implements the analyses and unobtrusively presents advice to developers to aid them in identifying managing and preventing conflicts.
section provides a brief scenario of two collaborative developers sketching how their development activities would differ with 1crystal exceeded expectations of the esec fse artifact evaluation committee.figure a screenshot of the crystal tool as run by a developer named george.
the green arrow informs george that his changes can be published uploaded without conflict to the master repository.
the red merge symbol indicates that ringo s changes if combined with george s would cause a test t failure.
and without the use of a crystal like tool.
section presents vcs terminology.
section details our retrospective analysis of the frequency and persistence of conflicts in practice.
section describes the information that can help developers better manage their conflicts.
section introduces the design of crystal an unobtrusive tool that computes and reports this information to developers.
section surveys related work.
section discusses threats to validity.
finally section summarizes our results and contributions.
.
scenario consider a simple scenario with george and ringo adding features to a project.
as part of george s feature he makes changes to a library that ringo also uses.
when finished george and ringo each independently publish their changes to the master repository.
whenever the regression tests run after both have published george and ringo are notified about failing tests.
at that time they have to recollect their earlier changes and assumptions and their fixes might force them to rework other code they had written in the meanwhile.
one way to lessen these difficulties is to use an awareness tool which reports where in the code base teammates are working allowing a developer to be more attentive to conflicts that may arise in those locations see section for more details .
for example when george edits the library an awareness tool may tell ringo that someone else is editing code he depends on.
however if george s change to the library had not actually affected ringo the warning would have been a false positive.
furthermore george might have been exploring some ideas and changes without ever intended to share the intermediate changes with his team.
thus awareness tools have the potential to give early warnings but also the potential to give multiple types of false warnings.
by contrast consider what would have happened if george and ringo were using a speculative analysis tool such as our tool crystal that proactively informs developers of version control conflicts.
figure shows how crystal informs george that his library changes integration with ringo s changes causes ringo s test suite to fail.
the tool encourages george and ringo to address the impending conflict before their assumptions and understanding of the changes fade.
speculative analysis does not guess at possible conflicts.
instead it speculatively performs the work and executes the vcs operations in the background on clones of the program it actually merges george s and ringo s committed code builds it and runs its tests.
this allows speculative analysis to deliver precise information about conflicts those that can be merged safely are not reported as potential conflicts and textually clean merges that fail to build or test properly are reported as conflicts.
with respect to the issue of exploratory development and awareness tools our approach assumes that when a developer commits code to the vcs the de veloper decided to share that code with other developers.
overall our approach provides precise and pertinent information available as soon as conflicts occur in the vcs.
.
terminology our results are applicable in the context of both centralized version control systems cvcses such as cvs subversion and perforce and distributed version control systems dvcses such as git and mercurial.
this paper focuses on dvcses to simplify the presentation.
we first briefly present accepted dvcs terminology.
we then introduce additional new terminology to allow us to precisely characterize seven pertinent relationships between repositories.
.
version control terminology figure shows a common dvcs repository setup.
there is a single master repository and four developers george paul ringo and john.
each developer makes a local repository clone from the master.
each local repository contains a complete and independent history of the master repository at the time it was cloned.
in addition each repository has a working copy in which code is edited.
changing the working copy does not modify the local repository to modify the local repository the developer commits achangeset to the local repository s history.
teammates are not privy to these changesets until the developer pushes them to the master repository from the local repository.
after a push another developer can perform a pull from the master which updates that developer s local repository with the changesets.
to refresh a working copy after a pull the developer must apply the update operation.
it is common for developers in a dvcs to commit multiple times before publishing through a push.
it is uncommon for developers to pull without a corresponding update.
a merge conflict can arise due to a pull operation and the conflict must be resolved before proceeding.
the terms used above are common or have direct equivalents across dvcs systems.
the discussion in this paper makes a few simplifying assumptions for clarity one it assumes that developers push to and pull from only the master repository two it assumes that developers only make a commit when all their tests pass.
however our approach in general and the crystal tool in particular handle arbitrary pushes pulls and commits.
.
repository relationships we have identified seven relevant relationships that can hold between two repositories.
figure illustrates these relationships.
same the repositories have the same changesets.
for example george s repository is the s ame as the master repository because they both consist of changesets and .
ahead the repository has a superset of the other repository s changesets.
for example george s repository is a head of paul s. behind the inverse of a head for example george s repository is b ehind john s. the remaining four relationships represent repositories that share an initial sequence of changesets followed by distinct sequences of changesets.
textual pronounced textual conflict the distinct changesets necessitate human intervention as they cannot be automatically merged by the vcs.
for example if george s changeset and ringo s changeset modify overlapping lines of code they are in t extual .
103history 102history 100history100 commit100 101historyrepo repo repo repopull push working copy george s clone john s clonemaster paul s clone ringo s cloneupdate working copyworking copyworking copyrepohistoryfigure a dvcs with four clones of a master repository.
the box labeled history lists those changesets currently in the repository.
each repository may have a working copy.
the commit command creates a new changeset in its repository s history and the update command incorporates changesets into the working copy.
a developer can incorporate changesets from other repositories using the pull command and can share changesets using the push command.
build8 the repositories can be automatically merged by the vcs but the resulting merged code fails to build.
test8 the repositories can be automatically merged by the vcs and the resulting merged code builds but fails its test suite.
testx the repositories can be automatically merged by the vcs and the resulting merged code builds and passes its test suite.
analogously to t estx there there are relationships b uildx and t extual xwith the obvious meanings.
the table header of figure illustrates the interrelation among the relationships.
when build scripts and test suites are not available we will distinguish only five relationships s ame ahead behind textual x and textual .
higher order conflicts such as b uild8and t est8 are not considered by existing vcs systems.
although this paper discusses only these two higher order relationships others naturally arise for other analyses for example consider when a test suite passes but a performance analysis or code style checker does not.
.
conflicts in practice this section answers the following research questions.
how often do the t extual build8 test8 and t estxrelationships of section .
happen?
section .
focuses on the t extual8relationship and section .
addresses b uild8 test8 and t estx.
section .
asks how long do developers experience the conflict relationships such as t extual ?
section .
asks how damaging is it not to share changes with teammates if those changes would currently merge cleanly?
anecdotally conflicts are a serious problem.
for example in a private communication an industrial manager expressed the following concerns to us about his two offshore teams and their collaboration with his local team the remote guys tend not to commit frequently enough to get leverage out of our continuous integration builds even after prompting.
it is a real challenge to know how far out of sync are when their commits are not being merged in regularly.
.
.
.
i want to at least initiate a conversation with the relevant parties when the system says they have or aresystem kncsl devs changesets days description gallery3 web based photo album git version control system insoshi social networking platform jquery javascript library mangos online game server perl5 programming language rails web application framework samba file and print services v oldemort structured storage system total figure nine subject programs analyzed to address rq1 rq2 and rq3 in collaborative development environments.
kncsl stands for thousands of non comment source lines.
the version control history ends on feb .
just about to walk into a conflicting situation.
i also want the system to give them a certain level of trust of other developer s changes so that if won t cause a problem they should sync up.
there is little hard data on conflicts.
zimmermann s analysis of cvs repositories for four open source systems is the only work we could find that directly addresses this issue .
he reported that of all merges to had textual conflicts t extual while the remainder could be merged automatically t extual x .
answering rq1 and rq2 requires analyses that significantly augment these data and anecdotes.
as subject programs figure we chose git itself and the eight most active projects on github that satisfy the following three criteria at least developers at least changesets and not just a git copy of a cvc repository which would not contain sufficient information to answer our research questions .
.
textual conflicts rq1 how frequently do conflicts textual and higherorder arise across developers copies of a project?
the answer to rq1 is that conflicts are the norm for each subject system there were no times when all pairs of developers were in consistent relationships s ame ahead or b ehind with each other.
figure shows how often developers merged their changes.
this is analogous to zimmermann s result described above.
of all the merges one in six or had textual conflicts as determined by git s built in merging mechanism reflecting the t extual 8relationship.
this number may be smaller than zimmermann s due to better merging algorithms in dvcses.
the other of the merges had no textual conflicts meaning the relevant developers were in the t extual x including b uild8and t est8 relationship.
the importance of the frequency of the t extual 8relationship is clear an unrecognized t extual 8between the repositories of two developers may cause problems.
the importance of the frequency of the t extual xrelationship is also material a developer who is unsure whether others changes can be incorporated safely might avoid so allowing conflicts to persist and grow as suggested in the manager s quotation above .
figure considers every commit at which developers who did eventually merge their changes could have done so earlier.
on average of the potential merges would have resulted in a textual conflict.
in other words had the developers been using crys systemtextual textual x merges build8 buildx test8 testx git .
perl5 v oldemort gallery3 insoshi jquery mangos rails samba total figure historical merges.
frequencies with which developers experienced t extual build8 test8 and t estxrelationships when they integrated their code.
for three systems with nontrivial test suites in the repository we measured the frequencies of all four relationships for the other six which had no non trivial test suite that we could run we measured only t extual 8and textual x. tal it would have informed developers about t extual 8relationships that resulted from of the commits.
conversely the of clean merges indicate the likely benefit of notifying developers when a safe textual merge can be performed.
.
higher order conflicts in our subject programs of merge operations required human assistance to resolve a textual conflict figure .
this underestimates the human effort since textually safe merges are not always safe an automatically merged change may suffer a build or test failure for example.
we computed the relationships at the time of each of the merges that developers performed during the development of git perl5 and v oldemort.
we did not compute the information for the other six subject program because of the absence of a non trivial test suite that we could run.
figure show that during the development of git perl5 and v oldemort of merges completed cleanly of merges resulted in a textual conflict t extual of merges resulted in a build failure b uild8 and of merges resulted in a test failure test8 .
the textual conflicts reported by the version control system only represent of all conflicts.
stated another way of the merges that the version control system reported as being a clean merge actually were a build or test conflict.
few current awareness tools detect higher order conflicts see section .
rather they generally notify developers of all changes to the repository e.g.
fastdash or of concurrent changes to asts e.g.
syde .
in contrast we use the project s tool chain to dynamically and precisely detect b uild8relationships via the build system and t est8relationships via the test suite .
.
persistence of conflicts rq2 how long do conflicts persist?
rq2 asks how long developers experience the t extual 8relationship.
as we argue in section .
the longer a relationship persists the more opportunities it has to change into a more severe relationship.
to measure the lifespan of a conflict for each conflict that was eventually resolved we found the first changeset that introduced the conflict and the changeset that resolved it.
we omitted all conflicts between changesets that were never actually merged in the history system merges textual textual x git perl5 v oldemort gallery3 insoshi jquery mangos rails samba total figure potential early merges.
the frequency with which developers would be informed of t extual 8and t extual xrelationships if they had used crystal throughout their development of nine open source systems.
such as those on dead end branches.
due to the sheer volume of the data and computation necessary to process it we examined the development histories of only four of our subject programs gallery3 insoshi mangos and v oldemort.
on average the t extual 8relationship persisted for .
days and involved .
changesets .
per developer with median values of .
days and changesets before incorporating left side of figure .
a tool could have let developers know about these textual 8relationships immediately upon their creation.
in the worst case one t extual 8relationship in mangos persisted for days and included changesets by one of its developers.
if developers know that they can merge others changes safely they may do so quickly and thus prevent a future conflict.
the longer a t extual xrelationship persists the more opportunities it has to change into a conflict.
accordingly we asked how long do developers experience the t extual xrelationship?
we measured the lifespan of a t extual xrelationship for each conflictfree merge in the history again comparing the changeset that introduced the relationship to the one that resolved it .
on average the t extual xrelationship persisted for days and spanned changesets .
per developer with median values of .
days and changesets before incorporation right side of figure .
a tool could have helped developers learn immediately about the t extual xrelationship encouraging earlier smooth incorporation.
in the worst case in terms of time one t extualxrelationship in v oldemort persisted for days in terms of changesets one t extual xrelationship in gallery3 persisted for changesets without a merge while each of the possible merges along the way would have been textually clean and fully automated.
.
escalation of clean merges into conflicts rq3 do clean merges devolve into conflicting changes?
parallel work enables faster progress but also the creation of conflicts.
we and others argue that developers should perform safe merges as frequently as possible.
to determine how often in practice parallel editing escalates into a conflict we used a methodology similar to that of section .
.
every conflict relationship develops from a situation in which a second developer makes a change without having incorporated and understood a first developer s work.
we found that of all conflict relationships t extual build8 and t est8 developed from a t estxrelationship the other of conflict relationships developed from a b ehind relationship.
in other words in almost every case both developers had already committed but not shared textual 8relationships textual xrelationships system number length days length changesets number length days length changesets mean stddev median mean stddev median mean stddev median mean stddev median v oldemort .
.
.
.
.
.
.
.
.
.
gallery3 .
.
.
.
.
.
.
.
.
.
insoshi .
.
.
.
.
.
.
.
.
.
mangos .
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
binfreq min min min min 9h 9h 2d 12d 72d 421d min min min min 9h 9h 2d 12d 72d 421d 211941frequencybinfreq min min min min .4h .4h .5d .
.9d .
43d 236d min min min min .4h .4h .5d .
.9d .
43d 236d 8146111frequency binfreq min min min min 9h 9h 2d 12d 72d 421d min min min min 9h 9h 2d 12d 72d 421d 1frequencybinfreq min min min min .4h .4h .5d .
.9d .
43d 236d min min min min .4h .4h .5d .
.9d .
43d 236d 8146111frequency figure persistence of the t extual left and t extual x right relationships in historical data.
the distributions are shown in eightbucket geometric progression histograms.
changes before the conflict developed.
every t extual 8relationship could have been prevented by earlier incorporation of others changes.
some b uild8and t est8relationships could also be prevented and the others would at least be discovered locally and immediately and would never be committed to the version control system.
we also found that of t estxrelationships devolved into a conflict.
the remaining of t estxrelationships were merged successfully preventing a conflict from developing.
this suggests that what we call safe merges are actually at risk of devolving into conflicts that require human effort to resolve.
being aware of these merges early may prevent some such conflicts from arising.
while dvcses record sufficient information to let us reconstruct how often a conflict arose from a b ehind relationship they do not record information that would allow us to determine how often a b ehind relationship devolves into a conflict.
we suspect that behind relationships are also risky.
.
information about conflicts rq4 what information could developers use to reduce the frequency and duration of conflicts?
what kind of unexploited information is available from a vcs that is not yet leveraged to smooth collaboration?
what information could help the developer make better informed decisions such as whether to perform a particular vc operation to wait for a coworker to perform one or to communicate directly with a coworker?
we explored this space systematically by analyzing a hypothetical global view of all version control information in all repositories.
we then systematically analyzed this perspective by enumerating all possible version control situations that can arise during collaborative development determining based on the global perspective the best course of action for the team identifying what information that decision depended on and classifying the advice for the team.
we made the following assumptions in our exploration without loss of generality we considered all situations with three developers using the third developer to represent arbitrary other developers and repository hierarchies.
we limit our lookahead to two rounds of version control operations one developer performs one vc operation and then the other developer may or may not perform one.
this approach has allowed us to identify key common and important use cases.
section .
describes five pertinent local states of a developer.
we augment our classification of the relationships between developers repositories already described in section .
with two other categories of information the developer s possible actions section .
and guidance about those actions section .
.
finally we describe the information available about higher order conflicts specifically build and test conflicts section .
.
.
local states the five possible local states are uncommitted there are uncommitted changes in the working copy.
in conflict the local repository is in conflict with itself that is it has two heads that are not automatically mergeable.
this happens for example when pulled changesets conflict with local changesets.
build failure the repository s version of the code fails to build.
test failure the repository s version of the code builds but fails its test suite.
ok the repository s version of the code builds and passes its test suite.
these states are not mutually incompatible for example a user may have uncommitted changes be in conflict with itself and have different build compile status for each head and for the working copy.
furthermore these states obscure some information such as whether the working copy has been updated to all of the changesets in the local repository.
the list also omits some states such as when the local repository has two heads that can be merged automatically.
our approach and tools can handle such situations.
for simplicity of exposition however this paper classifies each developer s state as the first one in the list that holds.
this is all the information about state that is needed to provide the generally best advice to the team.
.
actions given two repositories aandb the relationship between aand bas well as the local states determine the possible actions that developers can perform.
same nothing to do.
ahead may push the new relationship will be s ame .
behind may pull the new relationship will be s ame .
textual may pull will result in the in conflict state.
may push bwill be in the in conflict state.
build8 may pull and merge will result in the build failure state.
may push bwill be in the build failure state.
test8 may pull and merge will result in the test failure state.
may push bwill be in the test failure state.
testx may pull and merge the new relationship will be ahead .
may push bwill be able to merge the changes cleanly.
the consequences of applying available actions can be tricky to understand and remember.
one example is when the available actions are the same but the consequences differ.
for example the developer can cleanly pull in both the b ehind and t estxrelationships.
however in the b ehind case the developer ends up in the same relationship while in the t estxcase the developer ends up in the a head relationship.
another example is when there are side effects of performing an operation intended to change the relationship between aandb such as incorporating b s changes into a may put aand another repository cinto a t extual 8relationship.
using global version control information to help developers track such situations can be beneficial.
the local state also partially determines which version control operations can be executed in different situations.
ifa s state is uncommitted then the update operation cannot be applied.
if a s state is not uncommitted then the commit operation is inapplicable.
ifa s state is in conflict then all operations except merge are discouraged.
dvcses permit most operations at any moment but discourage some of them most commonly by aborting the operation unless the user supplies an extra confirmation flag.
if a s state is not in conflict then the merge operation is inapplicable.
the build failure and test failure states do not limit the possible actions vcses are as yet unaware of such local states although fixing these problems should likely be a priority.
the ok state does not limit the possible actions.
.
guidance information about how each action may affect the developer s state and relationships can help developers make better informed decisions.
this section makes one common generally realistic assumption developers perform actions in a tree hierarchy pushing only to and pulling only from a parent.
this aligns with how developers predominantly interact with vcses .
further we consider only information relevant to two developers who share a common parent repository possibly that of one of the developers themselves because in all other cases the developers relationship is dependent on actions by others.
we classify the guidance information into five types.
one type of information concerns the relationship committer .
the other four concern the possible action when consequences capable and ease .
committer who made the relevant changes?
consider george and ringo again now working on a team with paul.
if george knows he is in the t extual 8relationship withringo george might decide to contact ringo to discuss the situation.
however ringo may not have made the conflicting changes instead paul may have made and pushed the changes to the master and ringo then pulled them from the master.
in this case george should likely discuss the conflict with paul rather than with ringo.
knowing the committer facilitates communication between relevant parties which in turn decreases the time required to fix conflicts .
when can an action that affects the relationship be performed now or must it wait until later?
ringo can be in the b ehind relationship with george but may be unable to incorporate his changes because george may not have yet pushed them to the master.
thus it may be helpful for ringo to know that although he will need to pull at some point he cannot get george s changes until george pushes.
as another example a developer may have to resolve an in conflict state before being allowed to push.
consequences will an action perhaps one on a different repository affect a relationship?
the situation with ringo b ehind george illustrates this kind of guidance as well.
is ringo b ehind george because george has not yet pushed his changes to the master or because george has pushed but ringo has not yet pulled from the master?
in the first case even if ringo pulls from the master his relationship with george will not change.
in the second case if ringo pulls he will become s ame with george.
capable who can perform an action that changes the relationship?
consider a situation in which george is in the t extual 8relationship with ringo.
if ringo has already pushed his changes to the master then george must be the one who resolves the conflict when he eventually pulls from the master.
conversely if george has already pushed his changes he cannot resolve the conflict any longer.
and if neither has pushed either of them might be the one to resolve the conflict.
ease has anyone made changes that ease resolving an existing conflict?
suppose george and ringo created conflicting changes and ringo has pushed his to the master.
if george were to pull from the master he would have to resolve the conflict.
what if ringo has made a set of follow up changes that he has not yet pushed?
if these changes resolve the conflict then it is likely better for george to wait for ringo to push his new changes.
ringo s pushing action would be the best way to resolve george s t extual 8with the master.
by performing actions developers can affect how long a conflict persists or even prevent it from ever occurring.
the guidance information can help developers decide which actions to perform.
knowing of a conflict relationship can encourage the developer to address it earlier while the changes are fresh in the relevant developers minds this may reduce the conflict s duration as well as the effort necessary to resolve it.
knowing about b ehind and t estx relationships can reassure developers that it is safe to incorporate others changes which in turn keeps the development states closer together.
in some cases this may also allow the developer to prevent some potential conflicts altogether which would also reduce conflict frequency.
at a minimum these relationships can prompt developers to communicate which can reduce conflicts in the developers mental models and work plans.
the committer guidance informs the developers of who else is relevant to a conflict reducing the time required to resolve it .
thewhen andcapable guidance can inform developers of the right time to perform an action eliminating the overhead of manually figuring out if an action can be performed now and possibly having toundo actions later.
the consequences guidance can allow the developers a peek into the future also limiting un and re of work.
finally the ease guidance can inform a developer if someone else may have an easier time resolving a conflict thus helping reduce the effort needed to resolve it.
.
examples of higher order conflicts early identification of higher order conflicts between developers reduces or at the least is highly unlikely to increase the time to resolve a conflict.
we describe a t est8and a b uild8example from v oldemort.
malformed non code resource on october a developer successfully merged two branches tips in git 50b74 and 00c35 .
branch 00c35 was edited times while the branch was alive and the last changeset on this branch occurred only eight minutes before the merge.
branch 50b74 had not been edited in the previous days.
although the patch between these two branches was very large lines git successfully merged these changesets.
test voldemort.store.http.httpstoretest testbadport did not fail either branch before the merge but did in the merged system.
thus some unintended behavioral interaction between the two branches changes broke this test.
in fact the merge invalidated one of the metadata files cluster.xml .
in this case if a tool had let the developers know that it was safe to merge earlier the problem could have been avoided completely by sequentializing the changes to cluster.xml and or by enabling earlier testing of the merged version.
missing type on november a developer successfully merged branches c77a4 and7f776 .
branch 7f776 was edited times while the branch was alive branch c77a4 was edited three times.
both branches had been modified within four days of the merge.
while the merge had no textual conflicts the code failed to build four compilation errors resulted from referencing a missing type protobuffadminclientrequestformat .
later the developer merged in another branch 68e3b which resolved the compilation problem.
in this case a tool could have speculatively told the developer about the compilation error that would arise as the result of the merge.
with this information the developer may have chosen to do the merges in an alternate order or manually to avoid the problem and ensure other developers were not adversely affected.
.
delivering version control advice given that version control conflicts are frequent and serious section and that a global view of the vcs could detect conflicts and reduce their frequency and severity section how can a tool effectively deliver that information and advice to developers?
the design of our tool crystal has several ways to convey the key information without overwhelming or distracting the developer the main window summarizes all projects and relationships allowing a developer to instantly scan it to identify situations that may require attention.
the main window is compact butnot needed if the developer prefer to receive limited but critical information.
the main nor any other window is ever opened asynchronously.
full detailed information about each relationship action and guidance is available but hidden until a developer shows specific interest in it.
crystal uses icons exploiting color and shape in stable locations in the main window rather than say a textual list that a developer would have to read and interpret a taskbar icon in the system tray to report the most severe state for all tracked repositories and mouse over tooltips that provide on demand all the information discussed in section .
figure a screenshot of george s view of crystal.
george is following two projects under development let it be and handle with care .
the former has four observed collaborators george paul ringo and john the latter has five george jeff roy bob tom.
crystal shows george s local state and his relationships with the master repository and the other collaborators as well as guidance based on that information.
crystal addresses scalability by allowing developers to select the repositories relationships of interest.
for example a developer may be interested in the relationships with those in the same collaborative team and the main development repositories of the other teams.
crystal can provide information about relationships even with developers who are not using it easing adoption by avoiding a requirement that the whole team uses the tool.
each developer can independently choose whether or not to run crystal.
advantages accrue when more members of a team use crystal but this is not necessary.
crystal allows developers to select a subset of the tests to execute to integrate more smoothly into large development projects with extensive test suites.
naturally for large projects with build scripts and test suites that take a long time to execute crystal will experience that latency.
however it would still identify relevant information sooner than other existing methods.
we have implemented our design in crystal a tool that performs speculative analysis of version control operations.
crystal currently works with the mercurial dvcs later versions of crystal will support additional vcses.
microsoft in cooperation with us is developing a version of crystal.
crystal is an opensource cross platform standalone tool and is available for download .
our initial qualitative evaluation of crystal is positive but future work should evaluate it via both qualitative and quantitative user studies.
.
crystal s ui figure shows a screenshot of crystal s main window.
the window displays a row of icons see figure for each of a developer s projects.
in this example there are two projects let it be and handle with care .
the former has four collaborators george the developer running crystal paul ringo and john.
the latter has five collaborators george jeff roy bob and tom.
on the leftmost side of the row underneath the project name crystal displays the local state.
this tells george in the native language of the underlying vcs whether he must commit changes hg commit in mercurial or resolve a conflict.
then crystal displays the relationship with the master and the collaborators repositories.
if george has the ability to affect a relationship now the icon isb t same ahead behind textual 8build8test8testx figure crystal associates an icon with each of the seven relationships.
the color of each relationship icon represents the severity of the relationship section .
relationships that require no merging are green that can be merged automatically are yellow and that require manual merging are red.
solid which combines the when andcapable guidance.
if george cannot affect the relationship the icon is hollow.
for example consider john who has made some changes in let it be but has not yet pushed them to the master george is b ehind john but the icon is hollow because george cannot affect this relationship until john pushes.
similarly george s relationship with ringo is a hollow t estxbecause george has the s ame relationship with the master ringo had not pulled the latest changes from the master and ringo has made some other changes which he has not pushed but which can merge without human intervention.
if the relationship is of the might variety george might or might not have to perform an operation to affect the relationship the icon is solid but slightly unsaturated see the relationship with bob in the handle with care project .
these features allow george to quickly scan the crystal window and identify the most urgent issues the solid red icons followed by other less severe icons.
george can also easily identify quickly whether there is something he can do now to improve his relationships in the example george can perform actions to improve his relationships in the handle with care project but not in let it be and whether there are unexpected conflicts george may wish to communicate with others about.
the most urgent relationship is displayed by crystal as its system tray icon which allows a developer to know at all times whether there is any action that requires attention without even having the crystal window open.
crystal also provides other guidance that is hidden unless a developer wants to see it.
holding the mouse pointer over an icon displays the action george can perform and the committer consequences and ease guidance when applicable.
for example when george holds the mouse over jeff s t extual 8icon it tells him that he can perform a pull and a resolve hg fetch in mercurial that performing this action will resolve george s t extual 8with jeff and that tom and george committed the conflicting changesets.
even though george asked for information about the relationship with jeff crystal was able to correctly point george to tom as the developer who was responsible for the conflicting changesets which jeff had pulled into his repository .
in other situations it is possible that george performing a pull and resolve operations with his parent would not resolve george s t extual 8with jeff e.g.
if jeff and tom had both created conflicting changesets but only tom had pushed his changesets to the master .
this is why the consequences guidance is important.
as a final note because no one else has merged these changesets george must resolve this conflict and there is no ease guidance for crystal to display.
.
initial experience crystal consists of ncsl of java and has been tested on windows mac os x and several linux distributions.
the developer using crystal must have read access to the collaborators repositories the crystal manual available at googlecode.com describes several simple ways to accomplish this.
we deployed the beta test version of the tool to a small numberof developers and have been using it ourselves and refining it since early july .
one co author uses crystal to monitor clones of projects belonging to eight actively working collaborators.
designing and deploying crystal along with frequent feedback from the handful of users has helped us to better understand the issues and to improve the tool s design.
crystal user feedback enhanced our understanding of the need for guidance as well as which information is most pertinent to make available to the developer.
for example showing hollow and solid icons arose from a user s need to differentiate between relationships he or she could and could not affect.
the feedback drove us to systematically explore the complete space as described in section .
here is one example piece of feedback from an external user via private communication keeping a group of developers informed about the state of a code repository is a problem i have tried solving myself.
my solution was an irc bot that announced commits to an irc channel where all of the developers on the project idled.
this approach has many obvious problems.
the crystal tool does not suffer from these problems.
crystal handles several projects and users effortlessly and presents the necessary information in a simple and understandable way but it is only a start at filling this important void the in the world of version control.
prior to developing crystal we surveyed dvcs users about their collaborative development habits.
their use of highly heterogeneous operating systems ides vcses and languages informed crystal s design.
even among this small group there were vast differences in committing pushing and pulling styles which further encouraged our research.
we anticipate that future user studies will identify additional strengths and weaknesses that will allow us to further improve crystal.
.
related work this section places our research in the context of related work in evaluating the costs of conflicts collaborative awareness mining software repositories and continuous development.
.
the cost of conflicts efficient coordination is important for effective software development.
the number of defects rises as the amount of parallel work increases but developers can more effectively manage risks to the consistency of their systems if they are aware of the consequences of their commits on other developers .
developers eschew parallel work to avoid having to resolve conflicts when committing changes or rush their work into the trunk to avoid being the developer who would have to resolve conflicts .
several observational and laboratory experiments empirically assess the benefits of collaborative awareness for configuration management .
augmenting these results we performed a retrospective analysis on real projects to estimate the potential benefit.
our analysis is consistent with their studies in confirming the potential for better coordination of individual and team repositories.
sarma provides a comprehensive classification of collaborative tools for software development in this classification crystal could be considered a seamless tool as it provides continuous awareness about development state and guidance about the consequences of potential future actions.
.
collaborative awareness the research most similar in intent to ours studies collaborative awareness increasing awareness of the activities among teammembers.
such awareness can be a distraction unless a conflict is imminent so awareness tools have adopted increasingly sophisticated methods for avoiding false positive warnings as we now describe.
palant r shows which developers are changing which artifacts by how much.
palant r has similar motivations to ours providing workspace awareness to users will enable them to detect potential conflicts earlier as they occur.
ideally developers can then proactively coordinate their actions to avoid those conflicts p. .
fastdash is similar it is an interactive visualization a spatial representation of which files each developer is editing that augments existing software development tools with a specific focus on helping developers understand what other team members are syde reduces false positives via a fine grained analysis of the abstract syntax trees asts modifications.
two potentially conflicting changes to the same file are flagged for a developer only when they also affect changes to the same parts of the underlying asts.
for example if two users have inserted deleted or changed the same method the changes will be flagged yellow if one of user had committed the changes would instead be flagged red indicating that there may be a merge conflict.
syde examines files every time they are saved.
the most detailed analysis is done by tools like collabvs and safe commit.
collabvs detects a potential conflict when a user starts editing a program element that has a dependency on another program element that has been edited but not checked in by another developer .
safe commit does the deepest program dependence analysis identifying changes that are guaranteed not to cause tests to fail.
this allows earlier publishing of some of a developer s changes on the theory that increasing the publishing frequency can decrease the amount of duplicate development and the likelihood of merge conflicts.
our approach suffers fewer false positives and fewer false negatives than previous awareness approaches for several reasons.
first our approach computes actual pending conflicts rather than estimating potential ones.
by speculatively exactly what a developer will actually do in the future run a version control operation then run the build script and finally run the test script our approach only reports problems that would actually happen while executing those steps.
a secondary benefit of using the underlying vcs directly is that users of crystal can benefit immediately from any improvements to the vcs merging algorithm.
second crystal does not report conflicts until they have been committed to some repository.
this reduces false positives resulting from exploratory edits such as for debugging developers typically commit code that is consistent and is a candidate for sharing.
this could delay delays crystal s reports until a commit occurs but commits tend to be frequent in a dvcs.
third unlike most of the previous work our approach aids developers in performing safe merges earlier in addition to early isolation of conflicts.
fourth also unlike most of the previous work we consider and support multiple levels of conflicts textual build and test.
.
mining software repositories ball et al.
extracted metrics such as coupling based on the probability that two classes are modified together and used the metrics to assess the relationship between implementation decisions and the evolution of the resulting system.
later efforts mine version histories to determine functions that must likely be modified as a group to identify common error patterns to predict component failures etc.
our effort contrasts with these efforts in at least two dimensions.first we are assessing a different property opportunities to incorporate changes with others on a team.
second the purpose of our mining was to determine whether building a tool like crystal would be worthwhile.
other mining efforts generally aim to improve a team s software development process such as by informing managers of a pattern so that they will allocate more quality assurance resources to more error prone components.
.
continuous development our approach can be characterized as continuous merging.
thus it is related to a number of other approaches to continuous computation in the context of software development.
a programming environment modeled on spreadsheets can continuously execute the program as it is being developed .
modern programming environments focus instead on providing continuous compilation the environment maintains the project in a compiled state as it is edited speeding software development in two ways.
first the developer receives rapid and usually unobtrusive feedback about compilation errors allowing for quick correction while that code is fresh in the developer s mind.
second the developer is freed from deciding when to compile meaning that the developer is not distracted by the compilation task and that when it is time to run or test the code no intervening compilation step is necessary.
continuous testing applies the same idea to testing it uses excess cycles on a developer s workstation to continuously run regression tests in the background.
it is intended to reduce the time and energy required to keep code well tested and prevent regression errors from persisting uncaught for long periods of time.
the vision is that after every keystroke the developer knows immediately without taking any extra action whether the change has broken the tests.
similar ideas are gaining traction in the development community.
recent work has investigated supporting real time integration to decrease developer s hesitation in committing changes using centralized version control .
like fastdash this approach aims to help developers avoid conflicts but in contrast to fastdash and similarly to crystal it computes rather than predicts the presence of merge conflicts.
these continuous approaches are reactive albeit very fast.
in contrast our notion of speculative vc relies instead on pre computing and perhaps presenting depending on the user interface and user preferences contingent information about vc operations before the programmer has even considered taking the associated speculative action.
.
threats to validity our research naturally leaves open a set of potential concerns which we present using the standard notions of threats to validity.
construct.
the version control histories tell us when a t extual 8or t extualxrelationship first arose and when the developers resolved it.
however the histories do not tell us when or how the developers found out about the relationship when the developers began trying to resolve the relationship and had the developers known about the relationship earlier would they have done anything differently?
in addition dvcs histories only contain information about incorporate operations from the t extual xand t extual 8states nothing is recorded when a developer pulls from the b ehind state or pushes from the a head state.internal.
our experiments section are in the context of dvcses which differ from cvcses .
the effect of the vcs on developer behavior is not established indeed various researchers hypothesize the full spectrum that a dvcs causes a developer to publish less often more often or the same amount as a cvcs.
if dvcses encourage more frequent branching and merging that would provide additional opportunities for crystal.
while our full retrospective analysis cannot be done on the histories of repositories built using existing cvcses we believe the data we find in dvcs projects is an approximation of what happens in development with cvcses the largely similar results to zimmermann justifies this belief.
external.
another threat is that our retrospective study focused on nine open source systems.
the systems we selected may not be characteristic of other systems.
anecdotally developers are all butuniversally worried about the problems that can arise from conflicts.
the professional web blogs q a sites etc.
is filled with examples of developers expressing this concern and suggesting ways to reduce it.
usability and developer style.
while crystal can answer important questions about the developers relationships in a collaborative environment and aid those developers in making better informed decisions crystal might also harm productivity by distracting developers or leading them to premature integration.
to mitigate the issues of distraction we have worked to reduce crystal s intrusiveness.
in particular humans tend to be reasonably good at selecting which information to ignore and we have designed crystal to be consistent with that ability.
some developers may prefer to use the full crystal view while others may prefer the system tray view most of the time.
and a developer who is heads down can simply quit crystal for a while just as many developers choose to at times ignore their email.
one challenge to crystal s adoption may be that developers may fail to see its utility.
one developer who attempted to use crystal reported that he simply was not interested in seeing conflicts with unpublished changes and that he rarely experienced conflicts with others in his development.
while he saw no harm to running crystal he anticipated it would provide him no benefit either.
crystal indeed may well not be appropriate for all classes of developers.
nonetheless the data in section show that conflicts are common not rare suggesting strongly that most developers may well benefit from crystal regardless of their intuitions.
we plan to test this hypothesis as part of a future user study.
furthermore conflicts are not the only reason to use crystal.
the developer who declined to use crystal ended up redundant work.
he noticed a problem and fixed it but another developer had already made the same fix and pushed it six days earlier.
the non crystal user had forgotten to pull changes before beginning to work on the problem.
crystal would have reminded the user that he could pull changes and had he followed crystal s advice he would have avoided the wasted effort of the duplicated bug fix.
.
conclusions speculative analysis over version control operations provides precise information about pending conflicts between collaborating team members.
these pending conflicts including textual build and test are guaranteed to occur unless a developer modifies a committed change .
learning about them earlier allows developers to make better informed decisions about how to proceed whether itbe to perform a safe merge to publish a safe change to quickly address a new conflict to interact with another developer etc.
our retrospective quantitative study of over development versions of nine open source systems spanning .
million distinct and a total of over billion over all versions ncsl confirms that conflicts are the norm rather than the exception that of all merges required human effort to resolve textual conflicts that of merges that were reported to contain no textual conflicts by the vcs in fact contained higher order conflicts and that conflicts persist on average for days with a median conflict persisting .
days .
although there is a significant amount of qualitative and anecdotal evidence consistent with our findings the only previous quantitative research we could find was zimmermann s .
we expand on his work in several dimensions including comparing actual merges from project histories to merges that could have taken place successfully earlier than they did and considering not only textual conflicts but also higherorder conflicts such as build and test conflicts.
our speculative analysis tool crystal provides concrete information and advice about pending conflicts while remaining largely unobtrusive.
our evaluation of crystal is preliminary and qualitative future work should evaluate it via both qualitative and quantitative user studies.
collaborative development is essential but troublesome.
making pertinent and precise information available to developers allowing them to identify and fix conflicts before they fester is one useful and practical step in reducing some of the costs and difficulties of collaborative software development.