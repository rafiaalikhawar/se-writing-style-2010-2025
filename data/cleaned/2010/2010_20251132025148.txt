version consistent dynamic reconfiguration of component based distributed systems xiaoxing ma y luciano baresi carlo ghezzi valerio panzica la manna jian luy xxm lj nju.edu.cn baresi ghezzi panzica elet.polimi.it politecnico di milano dipartimento di elettronica e informazione milano italy ynanjing university state key laboratory for novel software technology nanjing china abstract there is an increasing demand for the runtime recon guration of distributed systems in response to changing environments and evolving requirements.
recon guration must be done in a safe and low disruptive way.
in this paper we propose version consistency of distributed transactions as a safe criterion for dynamic recon guration.
version consistency ensures that distributed transactions be served as if there were operating on a single coherent version of the system despite possible recon gurations that may happen meanwhile.
the paper also proposes a distributed algorithm to maintain dynamic dependences between components at architectural level and enable low disruptive version consistent dynamic recon gurations.
an initial assessment through simulation shows the bene ts of the proposed approach with respect to timeliness and low degree of disruption.
categories and subject descriptors d. .
general terms design reliability management keywords dynamic recon guration version consistency componentbased distributed system .
introduction oftentimes component based distributed systems cbdss must cope with changes in the environment in which they are embedded and in the requirements they must satisfy.
such changes may be hard to predict at design time or they may be too expensive to identify and handle by the initially designed software.
it is therefore necessary to modify existing parts of the implementation or add new functionality at runtime without blocking the system.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.compared to o line maintenance dynamic modi cations are more di cult since in addition to the correctness of the new version they must also preserve the correct completion of on going activities.
at the same time they should also minimize the interruption of system s service usually called disruption and the delay with which the system is updated also called timeliness .
dynamic recon gurations of cbdss are not trivial .
a safe approach that avoids the direct manipulation of application speci c states enables the recon guration of components after they have reached a quiescence status .
this approach has the advantage of a clear separation of concerns between computation and architectural re con guration.
but since recon guration is oblivious to application states it must be conservative.
it blocks all potentially dependent computations before enabling any recon guration to ensure consistency and thus it may bring more disruption than necessary.
the quiescence based approach only considers static dependences between components speci ed by architectural con gurations.
since these dependences pessimistically include all potential constraints among transactions one can reduce disruption by considering dynamic dependences.
these are temporal relationships between components caused by on going transactions and they only indicate the current constraints on the recon gurability of the system.
multiple transactions are allowed to run during recon guration thus reducing the degree of disruption and improving the timeliness of the recon guration.
existing proposals only use dynamic dependences to ensure some local consistency properties.
in contrast the approach presented in this paper exploits them to ensure the global consistency of multi party distributed transactions through the notion of version consistency .
dynamic recon gurations are seen as sequences of runtime updates of components version consistency ensures that every transaction be entirely served by either the old versions of system s components or by the new ones no matter when the recon guration happens.
this approach introduces less disruption than the quiescence based one since a component can be updated even when it is not quiescent but it has not been used yet or it will not be used anymore by any on going transaction.
besides version consistency as a new criterion for the safe dynamic recon guration of cbdss the paper also proposes a management framework for multi party distributed transactions.
the framework exploits dynamic dependencies a distributed algorithm to update the dependency model ac245 cordingly at runtime and a locally checkable condition that is su cient to ensure version consistent dynamic recon gurations.
the rest of the paper is organized as follows.
section introduces our model of cbds and the challenges posed by dynamic recon guration.
section highlights the limitations of the two most representative approaches and paves the ground for our proposal.
section presents version consistency and the management framework.
section summarizes the main results of the assessment conducted to evaluate the proposal.
section surveys related approaches and section concludes the paper.
.
problem setting similarly to uml component diagrams a componentbased distributed system may be described as a set of components nodes with in ports and out ports.
components are linked by directed edges from out ports to in ports.
the resulting directed graph is called the system s static con guration where each node is tagged with the current version of the component it represents.
a static con guration can be described as follows de nition static configuration .
a static conguration of a component based distributed system is a directed graph whose nodes represent versioned components with in ports and out ports.
a directed edge from the outport of a given node nto the in port of other node m represents a static dependence that is the possibility for nto require a service provided by m. figure our example system.
figure shows an example system used throughout the paper.
a portal component portal interacts with an authentication component auth and a business processing component proc while proc interacts with both auth and a database component db .
this means that portal statically depends on proc andauth and proc depends on auth anddb.
our approach supports the dynamic recon gurations of cbdss with transactional behavior that is systems whose execution evolves through atomic separate tasks transactions .
this model is largely adopted in many applications from systems implemented on top of component based infrastructures like ejbs or spring to service oriented applications.
atransaction is a sequence of actions executed by a component that completes in bounded time.
actions include local computations and message exchanges.
transactions are described by the rectangles t0..t4in the sequence diagram shown in figure which is used hereafter as an example.
a transaction tcan be initiated by an outside client or by portalauthprocdbbgett oken cred return token process token data verify token ok dboperation t0t1 t2t3 t4a c dfigure detailed scenario.
another transaction t0.tis called a root transaction in the former case and a sub transaction oft0 in the latter case.
if a transaction tinitiates sub transactions t along with its sub transactions is said to be a distributed transaction .
for example t4is a sub transaction of t2in the sequence diagram of figure .
the host component node of transactiontis denoted as ht.
the termsub t t2 denotes that t2is a direct subtransaction of t1.
a transaction can only be a direct subtransaction of one transaction.
the set ext t fxjx t sub t x gis the extended transaction set oft which containstand all its direct and indirect sub transactions.
the extended transaction set of a root transaction models the concept of distributed transaction that can span over multiple components.
by de nition a root transaction is not a sub transaction of any other transaction.
a root transaction has a unique system wide identi er.
for each transactiont htmust know root t which is the identi er of the root transaction of t. a transaction can initiate a sub transaction on a neighbor component only when the host component of the initiating transaction is statically dependent on the neighbor component in charge of executing the sub transaction.
for example the sequence diagram of figure illustrates a distributed transaction where root transaction t0initiatest1 andt2.
in turn transaction t2initiatest3andt4.
we also assume that transactions are also always noti ed of the completion of their sub transactions and that a transaction cannot end before the termination of its sub transactions.
the other messages exchanged between htandhti because of tand its direct sub transaction ti are temporally scoped between the two corresponding messages that initiate tiand notify its completion.
figure shows a detailed usage scenario for the example system.
the portal rst gets an authentication token from auth and then uses it to require the service from proc.proc veri es the token through auth and then starts computing and interacting with db.
if we consider the root transactiont0atportal its extended transaction set is ext t0 ft0 t1 t2 t3 t4g wheret1atauth is in response to the gettoken request t2atproc in response to process t3at auth in response to verify andt4atdbfort2 s request of database operations.
di erent transactions may run concurrently in the system.
246if the executions of two transactions on the same component do not interfere with each other we assume they are safe.
in contrast if they compete for some resources we rely on theisolation provided by components to regulate the access.
.
runtime updates a dynamic recon guration policy de nes when the update can be performed and how it must be accomplished to keep the system consistent.
a dynamic recon guration is an atomic sequence of runtime updates of components1.
more rigorously an update is speci ed as a tuple !
!
t s where is the original system s con guration and !is the set of components that must be substituted by the new versions in !
.
the update happens when the system is in state s and the state transformerttrasformssintos0 t s which is a state of the updated system with con guration .
the system is expected to continue from s0with no externallyvisible erroneous behavior.
the global state of a cbds comprises the local states of all components and all messages in transit.
the state transformer is de ned on global states but in practice one can hardly manipulate states other than those local to the to be updated components.
we assume that given a runtime update !
!
t s the corresponding o line update !
!
is correct.
this means that the transactions running on satisfy the old system speci cation sand the transactions on satisfy the new speci cation s0.
given the distributed nature of these transactions we can only adopt a weak de nition of correctness of a runtime update which is dened as follows the transactions that end before the update satisfy s the transactions that begin after the update satisfy s0 the transactions that begin before the update and end after it satisfy either sors0.
for example if we consider the running example one may assume that auth be updated to exploit a stronger encryption algorithm to prevent security threats.
although the new algorithm is incompatible with the old one the other components need not to be updated because all encryption decryption operations are done within auth.
the speci cation of all other transactions remains unchanged the o line update would be easy and we assume it to be correct.
the problem is that if we update auth at runtime we should ensure that all running transactions execute correctly before and after the update.
if the update were allowed to happen any time it would be di cult to ensure it .
an obvious restriction on when the update can happen is to impose that components targeted for update be idle.
de nition idle component .
a component is idle i it is not currently hosting transactions and its current local state is equivalent to the initial one.
1we consider any architectural change that can be treated as a replacement of components.
for example service rebindings can be seen as updates of the components that implement the services.
2this is to say that 0is equal to where all components in!have been substituted by the new versions in !
.note that if we restrict updates to occur when components are idle thentonly needs to be locally de ned on the initial state of all substituted components.
the initial state of the new component is assumed to be equivalent to the current state of the idle component being replaced.
the assumption that components can only be updated when they are idle is often insu cient to guarantee safe runtime updates.
in fact if we consider the scenario of figure and substitute auth when idle but after serving gettoken after time c the resulting system would behave incorrectly since the security token would be created with an algorithm and validated by another.
since the correctness of arbitrary runtime updates is undecidable even if the corresponding o line update is correct and the runtime update only happens when to be updated components are idle we can only derive some automatically checkable conditions that are su cient for the correctness by scoping the class of updates we consider.
these conditions must be a strong enough to ensure the correctness of runtime updates b weak enough to allow for low disruptive and timely changes and c automatically checkable in a distributed setting without enforcing unnatural centralized solutions .
.
quiescence and tranquillity in a seminal paper kramer and magee proposed a criterion called quiescence as a su cient condition for a node to be safely manipulated in dynamic recon gurations.
they also model a distributed system as a directed graph and de ne a transaction as an exchange of information between two and only two nodes initiated by one of the nodes.
transactions are the means by which the state of a node is a ected by other connected nodes in the system.
transactions consist of a sequence of one or more message exchanges between the two connected nodes.
it is assumed that transactions complete in bounded time and that the initiator of a transaction is aware of its completion .
a transaction tmay also depend on other consequent transactions ti the completion oftdepends on the completion of all the ti.
this de nition of transaction corresponds to our de nition of distributed transaction between only two nodes.
through the notion of dependency between transactions however they also capture the concept of a distributed transaction involving multiple nodes.
de nition quiescence .
a node is quiescent if .
it is not currently engaged in a transaction that it initiated .
it will not initiate new transactions .
it is not currently engaged in servicing a transaction .
no transactions have been or will be initiated by other nodes which require service from this node.
a node satisfying the rst two conditions is said to be passive.
a node is required to respond to a passivate command from the con guration manager by driving itself into a passive state in bounded time.
the last two conditions further make the node independent of all existing or future transactions and thus it can be manipulated safely.
to drive a node into a quiescent status in addition to passivating it all the nodes that statically depend on it must also be passivated to ensure the last two conditions.
247according to this approach a node cannot be quiescent before the completion of all the transactions initiated by statically dependent nodes.
this means that the actual update could be deferred signi cantly.
in our example auth cannot be quiescent before the end of the transactions hosted byportal and proc t0andt2 .
moreover all the other nodes that could potentially initiate transactions which require service from auth directly or indirectly are passivated and their progress blocked till the end of the update.
again in our example portal and proc are to be passivated before changing auth.
this means that the adoption of this approach could introduce signi cant disruption in the service provided by the system.
to reduce disruption vandewoude et al.
proposed the concept of tranquillity as alternative to quiescence.
the idea is that there is no need for waiting a transaction to complete if it will not request the service provided by the node targeted for update even if the node has been involved in the transaction.
it is also permitted to update a node even if some on going transactions will require the service provided by the node in the future but they have not interacted with it yet.
de nition tranquillity .
a node is tranquil if .
it is not currently engaged in a transaction that it initiated .
it will not initiate new transactions .
it is not actively processing a request .
none of its adjacent nodes are engaged in a transaction in which it has both already participated and might still participate in the future.
while claimed to be a su cient condition for application consistency during a dynamic recon guration the notion of tranquillity is based on a rather strong assumption.
if we used the de nition of tranquillity in our model the notion of distributed transaction could not be fully expressed as de ned in section .
in fact under the assumption imposed by tranquility a distributed transaction initiated by a root transaction tat noden could only contain subtransactions hosted by adjacent nodes directly connected ton.
this means that a sub sub transaction i.e.
a subtransaction initiated by another sub transaction hosted by a node that is not directly connected to n would not be part of the distributed transaction and thus it could use any version of the components since it is an independent entity.
this limitation would permit unsafe updates in the scenario of figure .
in fact after auth returns the token to portal it will not participate in the session initiated by portalanymore.
in addition before the request for veri cation is sent auth has not participated in the session initiated byproc and so auth is tranquil at time c .
however if auth were updated at this time the veri cation would fail because the token was issued by the old version of auth which might use a di erent encryption algorithm to validate the security token.
this failure would not happen if the system entirely complied with either the old or the new system con guration.
to conclude we can say that the quiescence based approach is a general and safe solution but it can be highly disruptive.
the tranquillity based approach is less disruptive but its assumption is too restrictive to be applicableto a wide set of systems e.g.
our example .
our goal is to get the best of the two proposals and add e ciency and timeliness to safety.
.
dynamic reconfiguration the notion of version consistency is proposed as a su cient condition for the safety of dynamic recon gurations.
de nition version consistency .
transaction t is version consistent with respect to an update !
!
t s i t1 t22ext t jht12!
ht22!
.
a dynamic recon guration caused by an update !
!
t s is version consistent if all transactions hosted by the current con guration are version consistent.
the de nition is justi ed by the fact that we assume the new con guration to be correct and by the fact that any extant transaction with all its direct and indirect subtransactions is entirely executed in the old or in the new con guration.
also note that a transaction that ends before starts after the update cannot have a direct or indirect subtransaction hosted by the new old version of a component being updated.
for our example if the update of auth happens after transaction t0begins but before it sends a gettoken request toauth time a all transactions in ext t i.e.
all transactions in figure are served in the same way as if the update happened before they all began.
if it happens at any time after auth replies to the verify request issued by proc time d all transactions in ext t0 are served the same way as if the update happened after they all ended.
however if it happens at time c thenht1 auth but ht3 auth0.
as botht1andt32ext t0 t0would not be version consistent.
in general the tranquillity based approach is not su cient for version consistent dynamic recon gurations.
it is equivalent to limiting the extended transaction set to exttran t fxjx t sub t x g. it only ensures a kind of local consistency but not the global consistency of entire distributed transactions.
the quiescence based mechanism if one takes dependent transactions into account ensures version consistency because no distributed transactions depending on the node to be updated can exist when the node is quiescent.
however it would take a too pessimistic attitude.
.
dynamic dependences since version consistency is not directly checkable we need to identify a condition that is checkable on a component or a set of components and ensure that its their runtime update does not break version consistency this condition must also allow for low disruptive and timely recon gurations.
dynamic dependences are the means to de ne such a condition and they can easily be added to the diagram of figure through properly labelled edges.
dynamic edges represented as dashed arcs are added and removed dynamically and they are labelled as either future orpast.
a future edge represents the possibility for the source node to initiate a transaction on the target node a past edge witnesses the fact that a transaction initiated by the source node has already been executed on the target node.
future and past edges are also labelled with the identi er of a root transaction.
we use cfuture past !
tc0to denote a future past 248edge labelled with the identi er of root transaction t from component cto component c0.
de nition valid configuration .
a static conguration decorated with edges representing dynamic dependences between corresponding components hereafter a conguration is valid i future and past edges are created and removed at runtime according to the following constraints .
host validity the hosting component cof a transaction t is augmented with a pair of edges cfuture !
root t candcpast !
root t cas soon as tis initiated and till it ends .
locality any future edgecfuture !
tc0 orpast edge cpast !
tc0 cannot exist without a static edgec !c0 connecting the same two nodes .
future validity afuture edgecfuture !
tc0must be added before the rst sub transaction t02ext t witht06 t is initiated and it cannot be removed as long as transactions hosted by cwill initiate further t002ext t onc0.
.
past validity apast edgecpast !
tc0must be added at the end of a transaction t02ext t onc0 initiated by a transaction hosted on a statically dependent node cand cannot be removed at least until the end of t. figure shows some con gurations of the example system two concentric cycles correspond to a pair of local future past edges labelled with t0 .
the con guration of figure a corresponds to time a in figure transaction t0 just began on portal.
the dynamic edges indicate that i there may be a transaction in ext t0 running on portal ii in order to serve transactions in ext t0 portal might use auth and proc in the future and also proc might use auth and db.
figure b corresponds to time b and says that a transaction in ext t0 t1 is currently running on auth but no further transactions in ext t hosted by portal will initiate any sub transaction on auth anymore because there is not0 labelled future edge between the two nodes.
figure c which corresponds to time c in figure indicates that auth might have hosted transactions in ext t initiated by portal in the past and might host other transactions inext t0 initiated by proc in the future.
figure d corresponds to time d in figure and shows that auth although it might have hosted transactions in ext t0 is not hosting and will not host them anymore.
note that to keep a con guration valid and consider alternative execution ows one can adopt a conservative management of future past edges between components.
for example ift2onproc needed to evaluate the results from dbbefore deciding whether to ask auth for veri cation one could keep the future edge from proc toauth tillt2does not need auth anymore.
in the worst case this could be till the end oft2.
on the other hand with the validity of the con guration preserved future past edges should be removed created as early late as possible to reduce spurious dependencies between components that could hinder actually legitimate dynamic recon gurations.
for instance the future edge from portal toauth in figure a is removed once portal figure some con gurations of the example system with explicit dynamic dependences.
realizes that t0will not initiate sub transactions on auth anymore this happens just after t0initiatest1.
given a valid con guration we can identify a locally checkable condition that is su cient for the version consistency of dynamic recon gurations.
de nition freeness .
given a con guration a component c or a set of components !
is said to be free of dependences with respect to a root transaction ti there does not exist a pair of t labelled future past edges entering c or!
.c or!
is said to be free in i it is free with respect to all the transactions in the con guration.
auth is free of dependences with respect to t0in the congurations of figure a and d while the local dynamic edges at auth trivially falsify its freeness in the con guration of figure b .
intuitively for a valid con guration the freeness of a component cwith respect to a root transaction tmeans that the distributed transaction modeled by ext t either has not used cyet otherwise there should be a past edge or will not use canymore otherwise there should be a future edge .
this leads to the following proposition.
proposition .given a valid con guration of a system a dynamic recon guration of a set of its components !
is version consistent if it happens when !is free in .
proof.
if we suppose that version consistency does not hold there is a transaction tthat is not version consistent that is 9t1 t22ext t jht12!
ht22!
.
.
there is no ongoing transaction hosted by any c2!
when the update happens.
this follows from the hostvalidity of and the freeness of components in !.
.
let !be the set of unchanged components.
because tbegins no later than t1andt1begins before the update since ht12!
tbegins before the update.
similarlytends after the update because of t2.
since no transaction is hosted by any components in !when the update happens htmust be in !.
a consider the sub transaction chain from ttot1.
there must be such tiandtjthatsub t i tj hti2 !
htj2!.
according to the pastvalidity of and the fact that tjmust have already ended when the update happens see point there is a past t labelled edge entering htj.
b because of the validity of the static con guration after the update !0must inherit all the incoming static dependence edges from !.
without any loss of generality let t2be the rst transaction in ext t initiated on a component in !
.
consider the sub transaction chain from ttot2.
there must be atksuch thatsub t k t2 htk2 !.
beforetkinitiatest2 all transactions from tto tkin the chain will not be a ected by the update because they are independent of transactions not inext t andt2is the rst transaction in ext t hosted by a component in !
.
according to the future validity of and the fact that t2is still to be initiated when the update happens there is a futuret labelled edge from htkto a component in!.
so there is a pair of t labelled past future edges entering !.
this contradicts the freeness of !.
.
distributed management of dependences an advantage of specifying dynamic dependences with future and past edges is that the validity of a con guration can be achieved through the cooperation of components.
each component makes its decisions locally with limited information about the application logic checking for freeness is also local to the part of the system to be updated.
the de nition of valid con guration gives lower bounds for the time intervals during which dynamic dependence edges should exist to keep a con guration valid.
one can satisfy all the conditions straightforwardly by creating all the dynamic edges at the beginning of a root transaction and by removing them at the end of it.
however although version consistency would be ensured disruption could be too high.
we assume that given a transaction t its host component htknowsf t the set of static edges through which it might initiate sub transactions on neighbor components in the future and p t the set of static edges through which it has initiated sub transactions in the past3.
the overall con guration with dynamic dependences is maintained in a distributed way.
each component only has a local view of the con guration that includes itself and its direct neighbors.
a component is responsible for the creation and removal of the dynamic edges leaving from it but it is also always noti ed of the creation and removal of the dynamic edges entering it.
components exchange management messages besides those related to transactions to keep the consistency among the views of neighbor components.
the maintenance of the distributed con guration may slightly delay the execution of the actual transactions but it guarantees that no transactions will be blocked forever.
.
.
management algorithm the management of dynamic edges for di erent distributed transactions is independent of each other since these edges are labelled with the identi ers of the corresponding root transactions.
if we consider a distributed transac3it is safe to over estimate f t andp t but better accuracy means better timeliness and less disruption in the dynamic recon guration.
this information can be extracted automatically from the component but also by monitoring its transactions the degree of accuracy of this information is up to the user.
note that similar information is also required to decide the actual tranquillity of components .tionext t our algorithm consists of three steps set up progress and clean up.
through these steps the locality of the con guration is ensured by only creating dynamic edges that pair the existing static ones and the host validity is preserved by always creating local future and past edges if they do not already exist when a transaction is initiated and by removing them only after the end of the transaction if there are no other on going transactions that need these edges .
in more detail the three steps carry out the following actions and help preserve future and past validity as follows set up this step is carried out when the root transactiontis initiated and before it initiates any sub transaction.
during this phase htcreates a future edge for each of its out going static edges that tmight use to initiate subtransactions according to f t noti es corresponding neighbor components and waits for their