a study and toolkit for asynchronous programming in c semih okur david l. hartveld danny dig arie van deursen university of illinois delft university of technology oregon state university usa netherlands usa okur2 illinois.edu d.l.hartveld student.tudelft.nl digd eecs.oregonstate.edu arie.vandeursen tudelft.nl abstract asynchronous programming is in demand today because responsiveness is increasingly important on all modern devices.
yet we know little about how developers use asynchronous programming in practice.
without such knowledge developers researchers language and library designers and tool providers can make wrong assumptions.
we present the first study that analyzes the usage of asynchronous programming in a large experiment.
we analyzed open source windows phone wp apps comprising 12m sloc produced by developers.
using this data we answer research questions about use and misuse of asynchronousconstructs.
inspiredbythesefindings wedeveloped i asyncifier an automated refactoring tool that converts callback based asynchronous code to use async await ii corrector a tool that finds and corrects common misuses ofasync await .
our empirical evaluation shows that these tools are i applicable and ii efficient.
developers accepted patches generated by our tools.
categories and subject descriptors d. .
software engineering coding tools and techniques general terms design experimentation keywords program transformation asynchronous c .
introduction user interfaces are usually designed around the use of a single user interface ui event thread every operation that modifies ui state is executed as an event on that thread.
the ui freezes when it cannot respond to input or when it cannot be redrawn.
it is recommended that long running cpu bound or blocking i o operations execute asynchronously so that the application app continues to respond to ui events.
asynchronous programming is in demand today because responsiveness is increasingly important on all modern devices desktop mobile or web apps.
therefore major programming languages have apis that support non blocking permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.asynchronous operations e.g.
to access the web or for file operations .
while these apis make asynchronous programming possible they do not make it easy.
asynchronous apis rely on callbacks.
however callbacks invert the control flow are awkward and obfuscate the intent of the original synchronous code .
recently major languages f c and visual basic and scala introduced asyncconstructs that resemble the straightforward coding style of traditional synchronous code.
thus they recognize asynchronous programming as a first class citizen.
yet we know little about how developers use asynchronous programming and specifically the new asyncconstructs in practice.
without such knowledge other developers cannot educate themselves about the state of the practice language and library designers are unaware of any misuse researchers make wrong assumptions and tool providers do not provide the tools that developers really need.
this knowledge is also important as a guide to designers of other major languages e.g.
java planning to support similar constructs.
hence asynchronous programming deserves first class citizenship in empirical research and tool support too.
we present the first study that analyzes the usage of asynchronous libraries and new language constructs async await in a large experiment.
we analyzed open source windows phone wp apps comprising 12m sloc produced by developers.
while all our empirical analysis and tools directly apply to any platform app written in c e.g.
desktop console web tablet in this paper we focus on the windows phone platform.
we focus on wp apps because we expect to find many exemplars of asynchronous programming given that responsiveness is critical.
mobile apps can easily be unresponsive because mobile devices have limited resources and have high latency excessive network accesses .
with the immediacy of touch based uis even small hiccups in responsiveness are more obvious and jarring than when using a mouse or keyboard.
some sluggishness might motivate the user to uninstall the app and possibly submit negative comments in the app store .
moreover mobile apps are becoming increasingly more important.
according to gartner by more than billion apps will be downloaded annually .
the goal of this paper is twofold.
first we obtain a deep understanding of the problems around asynchronous programming.
second we present a toolkit tools to address exactly these problems.
to this end we investigate wp apps through tools and by hand focussing on the following research questions permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
rq1 how do developers use asynchronous programming?
rq2 to what extent do developers misuse async await ?
we found that developers heavily use callback based asynchronous idioms.
however microsoft officially no longer recommends these asynchronous idioms and has started to replace them with new idioms in new libraries e.g.
winrt .
developers need to refactor callback based idioms to new idioms that can take advantage of the async await keywords.
the changes that the refactoring requires are non trivial though.
for instance developers have to inspect deep call graphs.
furthermore they need to be extra careful to preserve exception handling behavior.
thus we implemented the refactoring as an automated tool asyncifier .
we also found that nearly half of wp8 apps have started to use the month old async await keywords.
however developers misuse async await in various ways.
we define misuse as anti patterns which hurt performance and might cause serious problems like deadlocks.
for instance we found that of methods that use the expensive async await keywords do this unnecessarily of methods do not follow an important good practice out of apps misses opportunities in async methods to increase asynchronicity and developers almost always unnecessarily capture context hurting performance.
thus we implemented a transformation tool corrector that finds and corrects the misused async await .
this paper makes the following contributions empirical study to the best of our knowledge this is the first large scale empirical study to answer questions about asynchronous programming and async await that will be available soon in other major programming languages.
we present implications of our findings from the perspective of four main audiences developers language and library designers researchers and tool providers.
toolkit we implemented the analysis and transformation algorithms to address the challenges asyncifier andcorrector .
evaluation we evaluated our tools by using the code corpus and applied the tools hundreds of times.
we show that our tools are highly applicable and efficient.
developers findourtransformationsuseful.
using asyncifier weapplied and reported refactorings in apps.
replied and accepted each one of our refactorings.
using corrector we found and reported misuses in apps.
replied and accepted each of our patches.
outreach because developers learn new language constructs through both positive and negative examples we designed a website to show hundreds of such usages of asynchronous idioms and async await .
.
background when a button click event handler executes a synchronous long running cpu bound or blocking i o operation the user interface will freeze because the ui event thread cannot respondtoevents.
codelisting1showsanexampleofsuchan event handler method button click .
it uses the getfromurl method to download the contents of a url and place it in a text box.
because getfromurl is waiting for the network operation to complete the ui event thread is blocked and the ui is unresponsive.
keeping uis responsive thus means keeping the ui event thread free of those long running or blocking operations.
ifcode synchronous example 1void button click ... string contents getfromurl url textbox .
text contents 5string getfromurl string url webrequest request webrequest .
create url webresponse response request .
getresponse stream stream response .
getresponsestream return stream .
readasstring these operations are executed asynchronously in the background the foreground ui event thread does not have to busy wait for completion of the operations.
that frees up the ui event thread to respond to user input or redraw the ui the user will experience the ui to be responsive.
cpu bound operations can be executed asynchronously by i explicitly creating threads or ii by reusing a thread from the thread pool.
i o operations are more complicated to offload asynchronously.
the naive approach would be to just start another thread to run the synchronous operation asynchronously using the same mechanics as used for cpu bound code.
however that would still block the new thread which consumes significant resources hurting scalability.
the solution is to use asynchronous apis provided by the platform.
the .net framework mainly provides two models for asynchronous programming the asynchronous programming model apm that uses callbacks and the task asynchronous pattern tap that uses tasks which are similar to the concept of futuresfound in many other languages such as java scala or python.
.
asynchronous programming model apm the asynchronous programming model was part of the first version of the .net framework and has been in existence for years.
apm asynchronous operations are started with a beginmethod invocation.
the result is obtained with an endmethod invocation.
in code listing begingetresponse is sucha beginmethod and endgetresponse is an endmethod.
begingetrepsonse is used to initiate an asynchronous http getrequest.
the .net framework starts the i o operation in the background in this case sending the request to the remote web server .
control is returned to the calling method which can then continue to do something else.
when the server responds the .net framework will call back to the application to notify that the response is ready.
endgetresponse is then used in the callback code to retrieve the actual result of the operation.
see figure for an illustration of this flow of events.
the apm beginmethod has two pattern related parameters.
the first parameter is the callback delegate which is a managed type safe equivalent of a function pointer .
it can be defined as either a method reference or a lambda expression.
the second parameter allows the developer to pass any single object reference to the callback and is called state.
the .net framework will execute the callback delegate on the thread pool once the asynchronous background operation completes.
the endgetresponse method is then used in the callback to obtain the result of the operation the actual webresponse .1118code apm based example 1void button click ... getfromurl url 4void getfromurl string url var request webrequest .
create url request .
begingetresponse callback request 8void callback iasyncresult aresult var request webrequest aresult .
asyncstate var response request .
endgetresponse aresult var stream response .
getresponsestream var content stream .
readasstring dispatcher .
begininvoke textbox .
text content figure where is callback based apm code executing?
note a subtle difference between the synchronous sequential example in code listing and the asynchronous apmbased example in code listing .
in the synchronous example thebutton click method contains the ui update setting the download result as contents of the text box .
however in the asynchronous example the final callback contains an invocation of dispatcher.begininvoke ... to change context from the thread pool to the ui event thread.
.
task based asynchronous pattern tap the task based asynchronous pattern provides for a slightly different approach.
tap methods have the same base operation name as apm methods without begin or end prefixes and instead have an async suffix.
the api consists of methods that start the background operation and return a taskobject.
the taskrepresents the operation in progress and its future result.
the taskcan be queried for the status of the operation synchronized upon to wait for the result of the operation or set up with a continuation that resumes in the background when the task completes similar to the callbacks in the apm model .
.
drawbacks of apm and plain tap using apm and plain tap directly has two main drawbacks.
first the code that must be executed after the asynchronous operation is finished must be passed explicitly to the beginmethod invocation.
for apm even more scaffolding is required the endmethod must be called and that usually requires the explicit passing and casting of an async state objectinstance see code listing lines .
second even though the beginmethod might be calledcode tap async await based example 1async void button click ... var content await getfromurlasync url textbox .
text content 5async task string getfromurlasync string url var request webrequest .
create url var response await request .
getresponseasync .
configureawait false var stream response .
getresponsestream return stream .
readasstring figure where is the async await based code executing?
from the ui event thread the callback code is executed on a thread pool thread.
to update the ui after completion of the asynchronous operation from the thread pool thread an event must be sent to the ui event thread explicitly see code listing line .
.
pause play with async await to solve this problem the asyncand awaitkeywords have been introduced in in c .
.
when a method has the asynckeyword modifier in its signature the awaitkeyword can be used to define pausing points.
when a taskis awaited in an awaitexpression the current method is paused and control is returned to the caller.
when the await edtask s background operation is completed the method is resumed from right after the awaitexpression.
code listing shows the tap async await based equivalent of code listing and figure illustrates its flow of execution.
the code following the awaitexpression can be considered a continuation of the method exactly like the callback that needs to be supplied explicitly when using apm or plain tap.
methods that have the asyncmodifier will thus run synchronously up to the first awaitexpression and if it does not have any it will complete synchronously .
merely adding the asyncmodifier does not magically make a method be asynchronously executed in the background.
.
where is the code executing?
there is one important difference between async await continuations and apm or plain tap callback continuations apm and plain tap always execute the callback on a thread pool thread.
the programmer needs to explicitly schedule a ui event to interface with the ui as shown in code listing and figure .
inasync await continuations the awaitkeyword by default captures information about the thread in which it is executed.
this captured context is used to schedule execu 1119tion of the rest of the method in the same context as when the asynchronous operation was called.
for example if the await keyword is encountered in the ui event thread it will capture that fact.
once the background operation is completed the continuation of the rest of the method is scheduled back onto the ui event thread.
this behavior allows the developer to write asynchronous code in a sequential manner.
see code listing for an example.
comparing the code examples in code listings and will showthattheresponsiveversionbasedontap async await only slightly differs from the sequential version.
it is readable in a similar fashion and even the ui update setting contents of the text box is back at its original place.
by default awaitexpressions capture the current context.
however it is not always needed to make the expensive context switch back to the original context.
to forestall a context switch an await ed taskcan be set to ignore capturing the current context by using configureawait false .
in code listing in getfromurlasync none of the statements following the await expressions require access to the ui.
hence the await edtaskis set with configureawait false .
in button click the statement following await getfromurlasync url does need to update the ui.
so that awaitexpression should capture the original context and the task should not be set up with configureawait false .
.
research questions we are interested in assessing the usage of state of the art asynchronous programming in real world wp apps.
.
methodology corpus of data we chose microsoft s codeplex and github as sources of the code corpus of wp apps.
according to a recent study most c apps reside in these two repositories.
we developed wpcollector to create our code corpus.
it is available online and can be reused by other researchers.
we used wpcollector to download all recently updated wp apps which have a wp related signature in their project files.
it ignores apps without commits since and apps with less than non comment non blank lines of code sloc .
the latter toy apps are not representative of production code.
wpcollector makes as many projects compilable as possible e.g.
by resolving installing dependencies because the roslyn apis that we rely on see analysis infrastructure require compilable source code.
wpcollector successfully downloaded and prepared apps comprising 12m sloc produced by developers.
our analysis uses all apps without sampling.
in our corpus apps are targeting wp7 released in october .
another apps target wp8 released in october .
apps target both platforms.
analysis infrastructure we developed asyncanalyzer to perform the static analysis of asynchronous programming construct usage.
we used microsoft s recently released roslyn sdk which provides an api for syntactic and semantic program analysis ast transformations and editor services in visual studio.
because the publicly available version of roslyn is incomplete and does not support the async await keywords yet we used an internal build obtained from microsoft.table usage of asynchronous idioms.
the three columns per platform show the total number of idiom instances the total number of apps with instances of the idiom and the percentage of apps with instances of the idiom.
wp7 wp8 app app i o apm i o tap new thread bg worker threadpool new task we executed asyncanalyzer over each app in our corpus.
for each of these apps it inspects the version from the main development branch as of august 1st .
we developed a specific analysis to answer each research question.
.
how do developers use asynchronous programming?
asynchronous apis we detected all apm and tap methods that are used in our code corpus as shown in table .
because in wp7 apps tap methods are only accessible via additional libraries table tabulates the usage statistics for wp7 and wp8 apps separately.
the data shows that apm is more popular than tap for both wp7 and wp8.
we also manually inspected all apm and tap methods used and categorized them based on the type of i o operations network file system database user interaction and other i o e.g.
speech recognition .
we found that asynchronous operations are most commonly used for network operations.
there are two ways to offload cpu bound operations to another thread by creating a new thread or by reusing threads from the thread pool.
based on c books and