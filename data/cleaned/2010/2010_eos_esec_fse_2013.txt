identifying message flow in distributed event based systems joshua garcia daniel popescu gholamreza safi william g.j.
halfond and nenad medvidovic computer science department university of southern california los angeles ca usa joshuaga dpopescu gsafi halfond neno usc.edu abstract distributed event based deb systems contain highly decoupled components that interact by exchanging messages.
this enables flexible system composition and adaptation but also makes deb systems difficult to maintain.
most existing program analysis techniques to support maintenance are not well suited to deb systems while those that are tend to suffer from inaccuracy or make assumptions that limit their applicability.
this paper presents eos a static analysis technique that identifies message information useful for maintaining a deb system namely message types and message flow within a system.
eos has been evaluated on six off the shelf deb systems spanning five different middleware platforms and has exhibited excellent accuracy and efficiency.
furthermore a case study involving a range of maintenance activities undertaken on three existing deb systems shows that on average eos enables an engineer to identify the scope and impact of required changes more accurately than existing alternatives.
categories and subject descriptors d. .
distribution maintenance and enhancement d. .
patterns general terms design experimentation keywords distributed event based systems message flow maintenance .
introduction distributed event based deb systems developed using messageoriented middleware mom platforms have become widespread.
in the market size for mom licenses was about billion by the end of the decade the market for all middleware licenses was current affiliation google inc main st los angeles ca usa popescu google.com permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.nearly billion with mom among the fastest growing middleware platform types .
one of the reasons for deb systems popularity is that they are highly decoupled which facilitates the development of scalable concurrent and heterogeneous distributed applications .
to achieve this low coupling the components of a deb system implicitly invoke other components by publishing messages that a connector routes to the correct recipients in turn the recipient components may consume these messages and perform some functionality in response.
although implicit invocation provides many benefits it renders themaintenance of deb systems labor intensive and error prone .
a major reason for this is that implicit invocation makes it difficult to determine the types of messages passed within a system and where those messages will flow at runtime.
in particular two types of programming practices lead to this difficulty high branching invocation statements and ambiguous interfaces.
a high branching invocation statement is a type of statement that may have multiple targets at runtime.
such statements often stem from mechanisms used to implement implicit invocations such as callback functions and reflection .
prior work has demonstrated that identifying the targets of high branching invocation statements through manual inspection is challenging while existing automated program analysis techniques are unable to compute that information accurately .
this makes it difficult for maintainers to determine the impact of a change identify dependencies between components and localize faults.
for deb system maintenance it is often necessary to know which messages can be consumed by a component.
however components in mom based deb systems often rely on ambiguous interfaces .
an ambiguous interface accepts a single abstract message type and requires that a component internally filter and dispatch each message based on the message s attributes .
this complicates maintenance because examining the entry point of a message does not reveal explicit type information about the message only that the generic message type is consumed.
instead the maintainer must infer this information by other means such as examining the operations performed on a consumed message.
researchers have recognized the need for automated support of deb system maintenance.
however existing techniques have limitations that affect their accuracy and or applicability to mom systems.
for example a suite of analysis techniques has focused on improving the performance of deb systems .
however these techniques rely on a set of added specialized programming language features and do not handle the ambiguous interfaces prevalent in mom based systems.
another technique lsme uses developer provided regular expressions to identify message types.
however this technique neither identifies the specific attributes thatpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
367define a message type nor computes how messages may flow within a component.
our prior work helios is a semi automated technique that improves on lsme by using developer provided annotations to identify message flow within a component.
like lsme however helios is unable to identify the attributes that uniquely identify each message type.
to address the limitations of existing approaches we have developed a new technique eos that automatically identifies a deb system s message properties specifically the system s message types and message flow.
the key insight underlying our work is that these message properties can be identified by analyzing a deb system s implementation and aggregating message revealing information defined by statements along different possible execution paths.
our approach leverages this insight to fully automate the identification of message information via a static program analysis.
our evaluation of eos on six existing deb systems shows that our technique is both accurate and fast.
eos averaged over precision and recall of the subject systems message types and dependencies and could analyze each system in about a minute.
furthermore a case study involving a range of maintenance activities undertaken on three existing deb systems shows that on average eos enables an engineer to identify the scope and impact of required changes more accurately than existing alternatives.
the remainder of the paper is organized as follows.
section discusses how modern deb systems are typically implemented and existing challenges for identifying message flow in deb systems.
section describes how eos addresses these challenges.
section presents our evaluation results.
section overviews the relevant related work.
section presents our conclusions.
.
background and motiv ation a distributed event based deb system consists of components that send and receive messages in response to events that occur in the system .
components in deb systems communicate via two types of message interfaces the message source is the interface that publishes a message while the message sink is the interface that consumes a message.
to publish a message a deb component passes an instance of the mom s message type to a message source and to consume a message the component provides a method whose input parameter is the mom s message type.
the specific api a component must implement or use for the sinks and sources is typically defined by the underlying mom platform s abstract base component class.
similarly the message types either implement or extend the mom platform s base message type.
figure shows the partial implementation in java of two simple deb components an adder lines and a printer lines .
both extend the mom s abstract base component class component and provide an implementation of the message sink interface consume .
the parameter to consume is of type message which is the mom s base message type.
component debadder receives a message at line checks whether its name attribute is add and if so calls the addmethod to perform the addition.
the result of the addition is published by calling the pubmethod which wraps a call to the mom s message source interface publish .debadder can also receive messages whose name attribute is resultrequest for which it creates and then publishes an instance of the mom s base message type that contains the previously calculated sum value lastresult .
the debprinter component consumes messages whose name attribute is lastresult .
there are three different mechanisms for defining message types in modern deb systems attribute based nominal and subjectbased .
attribute based message types which are defined as sets of named attributes are used in figure .
by convention a message1public class debadder extends component private biginteger sum null private string sumstr sum public void consume message m string nameattr string m.getattr name if add .equals nameattr message summsg this .add m this .pub summsg else if resultrequest .equals nameattr if sum !
null message m2 new message m2.setattribute name lastresult m2.setattribute sumstr sum this .pub m2 private message add message m3 integer n1 m3.getattr num1 integer n2 m3.getattr num2 sum n1 n2 message m4 new message m4.setattribute name currentsum m4.setattribute sumstr sum return m4 private pub message m publish m 28public class debprinter extends component public void consume message m string nameattr m.getattr name if lastresult .equals nameattr ... figure the debadder anddebprinter components type has a special attribute that names the message which we refer to as the name attribute.
nominal message types are explicitly declared in the underlying programming language s type system.
for example a class called addthat inherits from the class message would be a nominal message type.
in subject based message typing each message type is defined via a pre determined string subject field.
an example is a message with a subject field whose value is message add .
both nominal and subject based message types can be represented as attribute based types for subject based messages a corresponding attribute based type has an attribute to represent the subject field for nominal types a corresponding attribute based message type has an attribute to represent the programming language class of the nominal type.
therefore for simplicity of the explanation we restrict our discussion in the rest of this paper to attribute based messages.
however it is important to note that our technique is not limited to attribute based messages.
in fact two of the mom platforms used in our evaluation section support nominal message typing.
the message types in a given deb system can be divided into published message types pmts which are the types sent via a message source interface and consumed message types cmts which are the types received via a message sink interface.
an example pmt published at line is tsum f name currentsum sum e g an example cmt of debadder is tadd f name add num1 e num2 e g. note that edenotes an unknown value.
a message type such as tlast f name lastresult sum e g can be both a pmt and a cmt since it is published by debadder at line and consumed by debprinter at line .
there are two types of relationships between pmts and cmts anintra flow dependency represents a relationship where a pmt may be published by a given component as the result of the component s consumption of a cmt an inter flow dependency represents a relationship where a pmt may be published by one component and then consumed by another component.
in debadder an intra 368flow dependency exists between taddandtsumsince the consumption oftaddleads to the publication of tsumat line .
an inter flow dependency exists between debadder and debprinter since tlast published at line can be consumed at line of figure .
as mentioned in section identifying the types and flow of messages is difficult due to the use of ambiguous interfaces and implicit invocation .
ambiguous interfaces in deb systems make it difficult to identify the message types that can be published or consumed at a given source or sink.
for example consider the two message interfaces shown in figure consume message m andpublish message m .
these interfaces only indicate that the consumed and published types are of the base type message .
however from our inspection of the code we know that the types are actually taddandtlast.
similarly implicit invocation makes it difficult to identify message flow.
for example without knowing the message types present at lines and of figure it would be challenging for a software maintainer to determine whether there exists an inter flow dependency among these statements as there is no explicit definition of the relationship in the code.
simple and straightforward solutions are unlikely to remedy this problem or would result in crude estimates of the correct relationships.
for example a naive solution for identifying message types would be to convert them all to nominal types e.g.
consume addmsg m andpublish lastresult m .
this would allow one to subsequently leverage explicit subtyping relationships among the resulting nominal types.
however even if a mom platform were to provide such interfaces the underlying programming languages would still be unable to support dynamic dispatch of appropriate messages to these more specific interfaces .
similarly one can simply assume that all message sources could be connected to all message sinks but this would result in significant over approximation of the message flows.
a key insight underlying our approach is that message types and their relationships can be identified through systematic analysis of a deb system s components.
by focusing on certain kinds of statements which we call message revealing statements we are able to identify useful information about the message attributes that make up a message type.
by themselves these statements do not give us a complete picture but by combining and aggregating the information along control flow paths that originate from message sources or terminate at message sinks we can identify message types.
for example consider the cmt taddat line .
here we can see that along the path where the condition at line is true a message object originating from the message sink is assumed to have an attribute name with the value add and then also the attributes num1 and num2 which are accessed at lines .
similarly consider the pmt tlast created at line .
along a path containing lines the message object published at line is created at line and has two attributes name and sum added on lines before it is published.
identifying these message types also allows us to identify flows and relationships among the statements that define a message type.
in section we describe how we formalize this intuition to create an automated analysis that is able to detect message types and flows in a deb system.
.
deb system analysis in eos eos is a static analysis technique for identifying attributebased message types and message flow in deb systems.
the input to eos is the implementation of the deb system and a specification of the underlying mom s api.
this specification comprises the generic message class methods that access and modify a message or its attributes and for moms that support attribute based message types the name of the special attribute that denotes a mes sage name.
from our experience all major mom frameworks provide apis for this functionality and the specification needs to only be performed once per mom api.
the output of eos is the deb system s message flow graph mfg which shows the system s message types and the relationships between those types.
the mfg is a directed graph c p e where cis the set of consumed message types cmts pis the set of published message types pmts and eis the set of directed edges representing intra flow c p dependencies and inter flow p c dependencies.
eos consists of two core analyses findcmt which computes cmts and findpmt which computes pmts.
both analyses are defined as summary based iterative data flow analyses that propagate message flow information extracted from different types of message revealing statements.
the analyses assume that aliases can be resolved precisely.
each analysis propagates the message flow information using four data flow sets for each statement sin a system s implementation in contains information that flows along a program path to s gen contains information that is generated at s kill stores information that is no longer valid because of information generated at s and out stores information that flows tos s successors.
all four data flow sets are initially empty.
as detailed in sections .
and .
the analyses update the data flow sets for each statement in a method until a fixed point is reached.
both findcmt andfindpmt compute a summary of each method in a deb component.
the method summary describes the messageflow information that can be inferred from a method.
method summaries make eos s analyses inter procedural thus allowing an entire deb application to be analyzed.
methods are analyzed in reverse topological order with respect to the deb component s call graph so that a given method s summary is computed before any methods that call it are analyzed.
cycles in the call graph e.g.
from recursion are handled in the standard manner by treating the involved methods as one super method.
in both analyses eos must calculate the names of attributes and the value of the special message name attribute.
to do this eos uses string constant propagation which provides a precise solution since by convention deb systems use constant strings to define these values.
eos does not calculate the value of other attributes and we use eto denote these unknown values.
eos stores attribute information in two sets attr andtypehier .attr is a set of pairs t name value where tis a message type and name value is the name and value of one of t s attributes.
typehier is a set of message type pairs t t0 where t0extends tby including all of t s attributes and a new attribute name value pair.
next we define the analysis for identifying cmts section .
and describe the key steps of the analogous analysis for identifying pmts section .
.
we then discuss how the cmts and pmts are used to identify message flow dependencies section .
.
.
identifying consumed message types the findcmt analysis is shown as algorithm and computes the information needed to identify a deb component s cmts.
the input to findcmt is a single method of a deb component and its outputs are the attr typehier and insets.
to compute cmts findcmt identifies and tracks three types of consumed message revealing cmr statements cmr entry cmr attr and cmr invoke.
together these statements identify the message types entering methods and the attributes that could be contained in those message types.
eos uses the information extracted from these statements to identify the attributes of each cmt.
cmr entry statements are points at which messages enter a method.
findcmt creates a reference type pair to track each message that originates from a cmr entry.
a reference type pair is an369algorithm findcmt input meth2methods output attr typehier in 1gen f p tentry jp2p typeof p messageg 2worklist fentry of method methg 3repeat 4s first statement of worklist 5match sdo case if rv equals rattrval f g foreach r attrname 2getattrinfo rattrval do handlecmrattr s r attrname rv case rattrval r getattribute attrname handlecmrattr s r attrname e case if r hasattribute attrname f g handlecmrattr s r attrname e case r f a updatesets gen attr typehier a summary f kill f r ti j r ti 2in i2stmtsg case ri rj gen f ri tk j rj tk 2in k2stmtsg kill f ri tk j ri tk 2in k2stmtsg case return ri kill f r tj j r tj 2in r6 ri j2stmtsg out in nkill foreach s02succ s in foreach s02succf s in worklist worklist fs0j s02 succ s g 25until worklist procedure handlecmrattr s r attrname val input s2stmts r attrname val 1typehier typehier i2stmtsg 2attr attr f ts attrname val j ti ts 2typehier i2stmtsg 3gen f r ts j r ti 2in i2stmtsg 4kill f r ti j r ti 2in i2stmtsg ordered pair r ti where ris a reference to a message object and tirepresents the message type assigned to that object.
we use the subscript ito denote the line number at which the message type t originated.
all four data flow sets in out gen and kill propagate reference type pairs.
at line of algorithm findcmt creates a reference type pair p tentry for each parameter pof type message in method meth s parameters p. these reference type pairs are added to gen so that they will be propagated to other cmr statements.
for example for the method entry at line of figure gen f m t4 g. cmr attr statements perform operations on an attribute of a message object.
findcmt can identify attribute information by correlating these operations with the statement s reaching referencetype pairs i.e.
reference type pairs that flow into the statement via itsinset.
there are three variants of cmr attr statements if statements that check whether an attribute has a particular value statements that retrieve an attribute from a message object and ifstatements that check whether a message object has an attribute.
the first cmr attr variant handled at line of algorithm allows findcmt to infer the value of an attribute the name of that attribute and the message type to which that attribute belongs.
the first cmr attr variant checks if an attribute referenced by rattrval has a predetermined value referenced by rv.
an example of this variant appears at line of figure where the predetermined value add is compared to the value of the attribute reference nameattr .
from this cmr attr variant findcmt can infer that the value of the attribute referenced by nameattr is equal to add along one pathoriginating from the cmr attr statement and is not equal to add along the other path.
handling the first variant of cmr attr statements involves three steps identify the name and value of the attribute corresponding to rattrval as well as the reference to the attribute s containing message object create a new message type from the identified attribute information and propagate different information along the two branches originating from the cmr attr statement.
in the first step findcmt looks for definitions of rattrval by traversing all of its definition use chains.
specifically getattrinfo traverses each definition use chain of rattrval until it reaches a call of the form r getattribute attrname at which point it adds a pair r attrname to its result set.
this internal logic of getattrinfo is straightforward and is thus elided from algorithm .
for the example at line of figure the call to getattrinfo nameattr returns m name .
the second step begins once getattrinfo has identified all definitions of rattrval .findcmt iterates over getattrinfo s result set and calls handlecmrattr procedure which creates new message types from the identified attribute information.
for the example at line of figure findcmt calls handlecmrattr with m name add .
the in set contains m t5 as the sole reaching reference type pair.
handlecmrattr creates a new message type t6 from t5and records this by adding t5 t6 totypehier .handlecmrattr also updates attrwith t6 name add to match the newly created type with the identified attribute information.
finally handlecmrattr creates a new reference type pair m t6 adds m t6 to gen and adds m t5 tokill .
in the third step findcmt uses branch sensitive transfer functions to propagate the new reference type pairs along one branch of the cmr attr statement but not along the other branch.
at line of algorithm findcmt propagates the newly generated reference type pairs to the inset of the cmr attr s successor statement on the true branch.
so at line of figure findcmt propagates m t6 along the true branch to in .
at line of algorithm findcmt propagates the cmr attr statement s unmodified reaching reference type pairs to the inset of its successor on the false branch.
so at line of figure findcmt propagates m t5 along the false branch to in .
the second variant of cmr attr identified at line of algorithm allows findcmt to infer the name of an attribute and the message type to which that attribute belongs.
specifically this cmr attr variant retrieves the attribute s name attrname from the message object referred to by r.findcmt can infer that all message types paired with rin the cmr attr statement s reaching reference type pairs are expected to contain the retrieved attribute attrname .
as in the previous variant findcmt calls handlecmrattr however no attribute value information is provided in this case and the unknown value e is passed to handlecmrattr instead.
since this variant of cmr attr is not contained within an ifstatement all of the new reference type pairs are propagated to the inset of s s successor by line of algorithm succf s is undefined for non branching statements .
to illustrate consider the cmr attr statement at line of figure .
to analyze the statement findcmt calls handlecmrattr with the arguments m name e .
the sole reaching reference type pair for line is m t4 sohandlecmrattr adds t4 t5 totypehier .
the attr set is updated with t5 name e .
finally gen is set to f m t5 gandkill is set tof m t4 g. the transfer function at line of algorithm propagates m t5 toin .
the third variant of cmr attr handled at line of algorithm accounts for ifstatements that check whether a message object referred to by rhas an attribute named attrname .
from this cmr attr370statement findcmt can infer that along one path originating from the statement all message types associated with rin the reaching reference type pairs contain this attribute and along the other path they do not.
findcmt handles this cmr attr statement by creating for each reaching reference type pair that contains r a new message type that includes the attribute as is done with the second cmr attr variant and propagating branch sensitive information as is done with the first variant .
cmr invoke statements handled at line of algorithm are invocations of deb component methods.
at the point of each cmrinvoke findcmt incorporates information from the summary of the invocation s target method.
a method s summary comprises the contents of the attr typehier and outsets of the method s exit point.
if any of these sets include message types defined by the method s formal parameters then that means the cmr statements in the method operate on the arguments provided by the cmr invoke.
to account for the actions within the target method updatesets substitutes the message types of the cmr invokes s arguments for the message types defined by the corresponding formal parameters in the summary.
the target method s summary is then used to update the attr typehier and gensets of the statement containing the cmr invoke.
to illustrate consider the cmr invoke statement at line of figure .
the summary of the invoked method add whose implementation starts on line of figure is attr f t17 num1 e t18 num2 e g typehier f t16 t17 t17 t18 g and out .t16is highlighted because it is the message type referred to by add s formal parameter m3 and will be substituted with a message type from an argument at a call site.
in this case the argument provided by the cmr invoke m has a message type oft6 which will be substituted for t16.updatesets performs this substitution sets gen toout and adds the summary s attr andtypehier sets to the corresponding sets in findcmt .
the last two case blocks in algorithm handle assignment and return statements.
line handles assignment statements by updating the statement s genandkillsets so that message reference ripoints to all the message types pointed to by rjand the reaching reference type pairs involving riare no longer propagated.
line of algorithm handles return statements by updating the killset of the statement so that only the reaching reference type pairs referenced by riare allowed to propagate beyond the return statement.
findcmt analyzes each method in the deb component once and the analysis of each method terminates when the worklist is empty.
since findcmt only adds items to the worklist when an inset changes termination occurs when all insets have reached a fixed point.
the insets will reach a fixed point because there is a finite upper bound on each inset the set of all reference type pairs defined in the method and each iteration of the algorithm causes theinset to monotonically grow with new reference type pairs.
in general iterative data flow analysis is o n2 but with the optimal statement traversal it can be o cn where cis the maximum loop nesting depth in the method s control flow graph.
the du chains used by getattrinfo can be pre computed for each method in o n2 using standard reaching definition .
after findcmt analyzes all methods of a deb component eos identifies the attributes of each cmt by using the information contained in the attrandtypehier sets.
by definition a cmt originates from a message sink interface.
therefore eos identifies the message type tsinkdefined at the message sink extracts each sequence of pairs in typehier that extend tsink and finds their corresponding attributes in attr.
for example consider the type t18.
the set of pairs in typehier that extends t18isf t4 t5 t5 t6 t6 t17 t17 t18 g where t4 tsink.
for these message types the relevantalgorithm findpmt input meth2methods attr typehier inc output attr pubtypes typehier 1worklist fentry of method methg 2gen f p tentry jp2p typeof p messageg 3repeat 4s first statement of worklist 5in s p2pred s out 6match sdo case r createmessage gen f r ts g kill f r ti j r ti 2in i2stmtsg case r setattribute attrname val typehier typehier f ts ti ji2stmts r ti 2inc g attr attr f ts attrname val j ts ti 2typehierg gen f r ts j r ti 2in i2stmtsg kill f r ti j r ti 2in i2stmtsg case publish r pubtypes pubtypes f ti s ji2stmts r ti 2in g case r f a updatesets gen attr typehier pubtypes a summary f kill f r ti j r ti 2in i2stmtsg case ri rj gen f ri tk j rj tk 2in k2stmtsg kill f ri tk j ri tk 2in k2stmtsg case return ri kill f rj ti j rj ti 2in ri6 rj i2stmtsg out in nkill worklist worklist g 28until worklist set of pairs in attrisf t5 name e t6 name add t17 num1 e t18 num2 e g.t4has no attributes.
thus the attributes of t18extracted by eos are f name add num1 e num2 e g. note that for a given type t0created from t the value of each attribute of t0 e.g.
name add takes precedence over prior values of the same attribute in this case name e .
.
identifying published message types the findpmt analysis is shown in algorithm and computes the information needed to identify a deb component s pmts.
the algorithm takes as its input a single method of a deb component and the attr typehier and insets computed by findcmt for clarity in this section we denote the latter as inc.findpmt utilizes the inc set in addition to its own inset since a cmt can be published after it is consumed.
the outputs of findpmt are updated versions of the attrandtypehier sets and a new set called pubtypes .pubtypes is a set of pairs ti l where tiis a pmt that originated on line iof the program while ldenotes the line where the type is published.
to compute pmts findpmt identifies and tracks four types ofpublished message revealing pmr statements pmr create pmr attr pmr publish and pmr invoke.
together these statements identify the message types created in methods the attributes that could be contained in those message types and which of these types are published.
in the remainder of this section we elaborate on the four types of pmr statements.
pmr create statements initialize a reference to an object of type message .
there are two variants of pmr create statements that explicitly create a new instance of message via a method e.g.
newinstructions or factory methods and statements that implicitly create such instances via the list of formal parameters to a method.371an example of the first pmr create variant is shown on line of figure .
the addmethod s declaration on line of figure is an example of the second pmr create variant.
algorithm tracks