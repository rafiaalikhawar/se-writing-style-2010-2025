where does this code come from and where does it go?
integrated code history tracker for open source systems katsuro inoue yusuke sasaki pei xia and yuki manabe osaka university osaka japan inoue peixia y manabe ist.osaka u.ac.jp abstract when we reuse a code fragment in an open source system it is very important to know the history of the code such as the code origin and evolution.
in this paper we propose an integrated approach to code history tracking for open source repositories.
this approach takes a query code fragment as its input and returns the code fragments containing the code clones with the query code.
it utilizes publicly available code search engines as external resources.
based on this model we have designed and implemented a prototype system named ichi tracker .
using ichi tracker we have conducted three case studies.
these case studies show the ancestors and descendents of the code and we can recognize their evolution history.
keywords code search software evolution open source system i. i ntroduction open source systems are extremely useful resources for the construction of current software systems.
even software systems in the industry increasingly use open source systems due to their reliability and cost benefits .
one of usages of the open source systems is to reuse the source code of the open source systems for other projects.
we can easily get the source code files of various projects from the repositories on the internet such as sourceforge and maven central .
those source code files are copied and modified if necessary and they are built into a new system.
repeating such inter project copies of files and code fragments makes a lot of code clones among the open source projects and the interdependency of those projects is becoming very complex .
consider a case that there is an open source code file used by a system but we do not know much about the original project.
we are wondering if we could safely and effectively reuse that source code file for a new project.
in such a situation it is very important to identify the origin of the source code.
by identifying the original project we would understand various characteristics of the project such as developers copyrights licenses created dates and so on.
also we would like to know the evolution of the source code since the reuse and maintenance information of the source code by many other projects is a very important clue for the software developers to make a decision to reuse the source code.current software engineering tools do not provide sufficient support to explore code history.
to know the code origin we have to specify project names and or urls.
also to know the code evolution we have to understand the interrelations of open source projects.
code search engines such as google code search and koders are very useful tools to explore open source repositories for the origin and evolution of code.
however current code search engines only allows to get keywords and or code attributes as their inputs and they return source code files which contains those keywords and attributes.
selecting appropriate inputs for those search engines is not easy task for general users.
in this paper we will propose an integrated approach to code history tracking for open source repositories.
also we will present its prototype system named ichi tracker integrated code history tracker .
ichi tracker takes a code fragment as its query input and returns a set of cloned code fragments which can be found by popular source code search engines such as spars r google code search and koders .
ichi tracker helps us to understand the backward and forward history of the query code fragment.
using ichi tracker we have performed various case studies.
in this paper we will show three examples of tracking code texture.java kern malloc.c and sshtools .
contributions of this paper are as follows.
we have proposed and implemented an integrated code history tracking model to find similar code fragments using code search engines.
this model is very effective to identify the evolution of code.
also it would be useful to find plagiarism or illegal reuse of code.
an analysis method of code history using a similarity metric called cover ratio and the last modified time has been proposed and used for the case studies.
using these techniques the code histories of three case studies have been presented.
in this paper we will first describe the tracking model in section ii.
in section iii detailed processes of ichi tracker will be explained.
section iv will show our case studies.
section v will discuss our approach and section vi willinput query q integrated code history tracker ichi tracker output results r code fragment r1c r1a r2c r2a rnc rna internet code fragment with clone search query sq search results sr code attribute optional code attribute attribute ... attribute ... ... attribute ... attribute ... ... attribute ... attribute ... ... attribute ... attribute ... ... qa qc r1 r2 rn open source repositories code search engines spars r koders google code search figure .
integrated model for code history tracking with ichi tracker show the related works.
in section vii we will conclude our discussions with some future works.
ii.
i ntegrated code history tracking model a. overview fig.
shows our model for the integrated code history tracking.
the core of this model is ichi tracker which takes an input query qand replies an output result set r. the details will be described in section iii.
input query qis composed of code fragment qcandcode attribute qa.qcmay be a complete source code file or a part of a source code file which is in question.
qais a set of associated information characterizing qc such as the file name project name url of repository created time last modified time and so on.
qais optional and could be added to improve the quality of the output results.
output result ris composed of results r1 r2 ... rn and each result riis composed of a code fragment ricand its code attribute ria.
both qcandriccontain at least one pair of type code clones1.
this means that each riccontains a clone of the whole or a part of qc.
attribute qaof query qis optional in the sense that the file name and project name might help to improve the search quality.
attribute riaof result ricontains valuable 1type clones are syntactically identical fragments except for variations in identifiers literals types whitespace layout and comments .
in this paper we assume that clones are type unless explicitly stated otherwise.information to know the characteristics of the cloned code fragment ric.
the last modified time could be used to identify the ancestor or descendant relations.
the project name and url would be indicators of prevalence and popularity of the query code among the open source projects.
sometimes those attributes might not be obtained easily.
we will discuss this issue in section v b .
in order to track a code history of open source systems we would need to have a huge repository containing various open source systems and their historical versions.
in addition to using our code search engine spars r we use external search engines google code search and koders assuming that those engines collect and contain sufficiently enough open source systems.
google code search and koders are very popular search engines since they provide a lot of useful information for open source systems.
google code search provides search features with keywords associated with optional attributes such as package names languages and licenses.
koders provides the keyword search feature with language names and license types.
these engines contain huge source code repositories behind them and those repositories are kept updated by their crawling activities and also the user s con2google has terminated its service for google code search on jan. .
all the discussion and data here are based on the service when it was available.
3since koders does not allow to send automated queries we have manually sent it the keywords obtained by our system.clone pair result ric query qc x x cover ratio di x qc a case of single clone pair clone pairs result ric query qc y cover ratio di y z y z qc b case of two clone pairs y z z figure .
definitions of cover ratios tributions.
spars r is our java component search engine with the keyword input and component rank mechanism .
the java class repository is kept updated by our research group.
ichi tracker gives the search query sq to those code search engines and gets the search result srfrom those engines.
b. cover ratio assume that the query code fragment qcand a result code fragment ricshare code clone xas shown in fig.
a .
the cover ratio diofricforqcis defined as follows.
di x qc here x means the size token length of x. if there are multiple clone pairs between qcandric then we add those clone sizes excluding their overlapping area and divide it by the query code size qc as shown in the case of two clone pairs of fig.
b .
if the cover ratio is .
then the result fragment contains the overall of the query code qc and if it is .
then the result does not contain any part of qc.
note that each result r1c r2c... may have different cover ratio d1 d2 ... since they may share different clones with qc.
the cover ratio can be an important attribute of each result which indicates how close the result code is to the query code.
input query q output results r word extraction keyword selection result forming search query sq search results sr code clone filtering query generation search result analysis yes no control and data flow results ok?
figure .
processes of ichi tracker iii.
p rocesses of ichitracker fig.
shows an overview of the processes of ichi tracker.
for the simplicity here we present only one strategy we have taken to choose keywords for the code search engines but we could consider many variations of different strategies algorithms and parameter settings some of which will be discussed in section v b. word extraction at the beginning code fragment qc in input query qis tokenized and the words from source code part only are extracted.
a single word of camel case or snake case is not decomposed into multiple words.
if code attribute qais additionally given those are also extracted.
keyword selection next the keywords used for the following query generation are selected from the extracted words.
initially the reserved words of the source code language are removed.
also short length words less than characters are deleted.
then we apply a simple word selection strategy that nmost frequently used words are chosen from the source code part.
finally we obtain npopular words which are not language s keywords and whose length are or more.
query generation using the selected keywords a search query sqfor the code search engines is created.
as the search engines we use spars r google code search and koders because of their availability and flexibility.
all of these search engines accept a keyword sequence as their query input so we use the sequence of nmost frequently used words as sq.
if the additional input attribute qais accepted by thesearch engines it is also given to the search engines.
result ok?
the header lists of the results of each search engine are received.
if the length mof each list is greater than the predetermined maximum limit mmax then the system retries from step with n most frequently used words assuming that the search query sq was too broad.
this means that we add one word to the previous keyword list and we expect narrower results than the previous try.
as the default setting we start with n 1andmmax is .
search result analysis using the header lists each source code sr1 sr2 .
.
.
sri .
.
.
is downloaded from each search engine.
the downloaded files might be complex html forms consisting of not only source code but other information such as frame window line number highlighted keyword file name project name language license and so on.
from such results the pure code parts and their associated comments are extracted as the resulting code.
also useful information for the code attributes such as file name project name license url and others are extracted if those are available.
code clone filtering the code clones between the input query code fragment qcand each source code sri obtained in step are computed.
if sridoes not share a clone with qc then we delete srifrom the result list.
we have used a code clone detection tool ccfinder with its parameter setting for the minimum token length .
this step works as a filtering out process of sr. in general code search engines reply many false positive results and we have to elaborate to choose appropriate query keywords or to structure queries to get better precision .
on the other hand by using this code clone filter we can easily remove unrelated code and so we can simply use code search engines without such elaboration of the input query.
result forming all the remaining code in step and their code attributes are combined and packed as the output result rof this system.
in our current implementation all result code fragments r1c r2c ... in rare not a part of files but they are complete files returned from each search engine.
iv.
e xperiments we have conducted several case studies to explore the applicability of ichi tracker.
all these experiments have been performed under pc workstation with dual xeon x5550 .66ghz processors and 24gb memory between feb. and may .
a. case study texture.java texture.java is a loc java file to define a graphic texture object in game programs.
it was developedtable i number of output results r and search results sr for texture.java asquery code fragment qc a case of no file name attribute r sr iteration gcs koders spars r subtotal keywords in sq capsule image write readint memreq mipmapstate filter apply gcs google code search these are the numbers of different files.
the actual sr is much larger.
no code clone filtering had been done due to long download time.
b case of file name as input attribute r sr iteration gcs koders spars r subtotal keywords in sq texture capsule image write readint memreq mipmapstate filter texture.java is used for the file specifier of google code search and koders and texture is used for a search keyword for spars r. by a game engine project jmonkeyengine .
this file is popularly used by many 3d games.
we have given ichi tracker the overall source code of this file as the input query code fragment qc.
as an optional attribute the file name texture.java is associated when it is needed.
table i shows the number of the output results r and also the number of the search results sr classified by each search engine.
a is the case where no file name or other attributes is given.
b is the case where the file name texture is given as an input attribute.
iteration means the trial process of ichi tracker as shown in fig.
here we show the details of possible iterations from to .
this does not mean that ichi tracker always tries all of these iterations.
it performs the search result analysis step and the code clone filtering step at a specific iteration only.
by default of sr 50for each search engine it stops and performs full processes at iteration gcs koders and spars r for case a .
for case b it stops at iteration for all search engines.
keywords are the list of keywords given to each code search engine.
in the case b google code search and koders allow to input the file name so we use the full file name as their input.
spars r does not accept the file name so we give word texture as one of its input keywords.
in both cases the output results share the code clones withtexture.java whose cover ratio are .
or higher.
as we can see these tables the iteration converges fairly fast and we get the output results.
it is very clear that search results srfrom three search engines initially contain many false positives i.e.
files containing no clones which will be filtered out by the code clone filtering.
this situation is exemplified more clearly by the case a where no file name is specified since the file name is very important clue to get the same code fragment.
however even without the file name we would get sufficient cloned results if we give an adequate keyword set.
an interesting observation of case a is that the number of the output results obtained from google code search and remained after the code clone filtering first increases along with the iteration then it decreases.
this is because an appropriate number of keywords recalls many possible candidates but too many ones narrow the search results and eliminate possible candidates files with low cover ratios.
the total execution time for case a was about min.
and case b min.
note that the manual overhead time for koders is not included here.
most of the time was to search and download the source code files from search engines.
for example in case b the time for the word extraction and the code clone filtering was only sec.
and sec.
respectively.
the rest was for searching and downloading.
the execution time is strongly affected by the response time of the code search engines and the network performance and the total execution time varies time to time significantly.
fig.
shows the distribution of output results of case b at iteration .
this figure is plotted by two attributes the last modified time as xaxis and the cover ratio as yaxis.
project names of all source code files including qchave been investigated manually and listed on the right hand side of the figure.
they are sorted by the last modified time.
we have found four versions of jmonkeyengine and .
the evolution of those four versions is linked by the arrows in the figure.
the circles are clusters of similar files which are exactly or of lines are the same.
from this figure we can observe the following.
texture.java code evolves along with the project progress.
this is seen by the change of cover ratios over the versions.
only an exception is revision and which is almost the same as revision only line difference .
each version of texture.java is copied to many other projects which are easily identified as similar files in clusters a b and c. in the case of cluster c there are files exactly the same as the query code qc which are lined up on the line of cover ratio .
.
five of those have been duplicated just after qcwas created.
there is one outlier project which was copied from jmonkeyenginetable ii number of output results r and search results sr for kern malloc.c asquery code fragment qc a case of no file name attribute r sr iteration gcs koders subtotal keywords in sq freep caddr t freelist kb next weird addr gcs google code search these are the numbers of different files.
the actual sr is much larger.
no code clone filtering had been done due to long download time.
b case of file name as input attribute r sr iteration gcs koders subtotal keywords in sq kern malloc.c freep caddr t freelist kb next kern malloc is used for the file specifier.
revision fairly later after the new version revision and has been created.
in addition to these attributes we have extracted the licenses of the input query code and the output results.
the input query code is under new bsd license clause bsd license and the output results are also new bsd license except for two projects and of zlib libpng license .
using ichi tracker we are able to find many code clones for the input query code fragment.
by analyzing those found files fragments and their attributes we can easily and effectively identify evolution and propagation of the query code fragment.
b. case study kern malloc.c kern malloc.c is a c function which allocates a specified size memory block in the kernel address space.
we have taken an old code from lites project where unixlike operating system had been developed .
this source code itself and its file name were used as the input query of ichi tracker.
the reason of using this file for the input query is that it was developed based on major unix systems .
bsd and mach microkernel.
also it is fairly old and it has been taken over and maintained by many other various projects.
we have executed ichi tracker in two cases with and without the file name kern malloc.c associated.
in this case study only google code search and koders are used as the code search engines since spars r does not contain c files in its repository.
table ii shows the output results and the search results.
in the same manner as the previous case evolution of jmonkeyengine project cluster of same or similar files file in new bsd license file in zib libpng license .
.
.
.
.
.
26cover ratio last modify time18 13a bc1 jmonkeyengine r3448 k simplexe g simplexe k jmonkeyengine r3800 g the project08 g tank combat game k wrathofthetaboos g wrathofthetaboos k lasthaven g jme cotk g ardor3d g jmonkeyengine r4099 g fairytale soulfire g jmonkeyengine r4490 g jmonkeyengine r4490 s xenogeddon g deathsquadrendezvous g partiendolapana g tholos g ardor3d g cosmic engine g fregatclient3d g footballmanagerdesia g multiplicity g jmerefactoring g java3dfh g figure .
distribution of output results of case b at iteration texture.java with file name study case study the iteration of the processes converges fairly fast even without the file name attribute specified as the query input.
also the converged search results contains no false positive answer.
this might suggest that the code clone filtering would not be needed if we give sufficient number of keywords and have the iteration converged.
however if we wait for the convergence the search results become too narrow and we might lose some cloned results e.g.
in case b google code search initially outputs results but it is reduced to after the convergence .
the execution time was about min.
for case a and also min.
for case b where most of the time was occupied by searching and downloading from the code search engines as described in case study .
fig.
shows the distribution of output results of case a at iteration for google code search and iteration for koders where no file name had been specified.
from this figure we observe the following.
the cover ratio of the output results diverges along the time scale.
some of those remain very close to the query code qc but others get away from the query code.
unlike case study there is no clear cluster ofsimilar results.
there are many variations of different code fragments meaning there are many small changes among the projects.
all of these results are under bsd license either original bsd license clause bsd license or new bsd license clause bsd license .
by using ichi tracker we could easily overview the evolution of a core part of the unix os kernel code.
c. case study sshtools sshtools is a suite of java ssh applications providing a java ssh api terminal and so on .
ignoring some tiny sized files we have selected files of the latest version .
.
last modified time is and made the tracking with those files as the input code fragments and file names.
in this case study we have set up a threshold of the cover ratio .
and the resulting files with more than the threshold are considered as similar files.
fig.
shows the number of similar files found for each query of the sshtool s files.
we observe that out of the files contains code clones with other projects.
of them have less than similar files for each several0.
.
.
.
.
.
01cover ratio last modified time26 lites .
g kame g kernel source archive cmu mach .
k simos k lites .
.u3 g kame g lites .
g netnice g the rio ram i o project k kame g ftp in the university of edinburgh g psumip g mip summer98 g netnice g freebsd sparc g reflexprotocol g ftp in stockholm university g netnice g freebsd cam2.
.5r g netbsd v1.
k sonicosx k openbsd pv xen g labyrinth bsd labyrinthos k openbsd v1.
k oskit g pmon g psumip g proyecto a.t.l.d.
gnu hurd extremeli nux k mach g openbsd v1.
k savannah g pmon g unofficial oskit source k g unofficial oskit source oskit k chord ns3 g ftp in stockholm university g openbsd loongson vc g results by g google code search and k koders file in original bsd license file in new bsd license qc figure .
distribution of output results of case a at iteration gcs and koders kern malloc.c without file name table iii search results for several files in ssht ools query file in sshtools project name cover ratio license copyright last modified of found file of found file time socketproxysocket.java cvs client interface in java .
gpl mindbright technology ab sftp.java apache ant .
apache .
apache software foundation stringscanner.java programmer s friend .
.
cpl .
manfred duchrow generalutil.java gruntspud cvs client .
gpl brett smith base64.java base64 notation .
public domain no copyright charbuffer.java java telnet daemon .
gpl dieter wimberge all license and copyright of the query code files in sshtools are in gpl and lee david painter and contributors respectively.
files have similar files and one file has more than similar files.
we have also investigated the different licenses appeared in each similar file.
sshtools is under gpl license however files out of files have similar files with different licenses from gpl .
files out of the files have similar files with different licenses and file has similar files with different licenses.
table iii shows a part of the detailed analysis results.
in this table we present the oldest ancestor project for the query code.
as seen in this table there are many differentancestor projects.
this means that sshtools is a collection of various tools developed by several different projects.
for each query file there are similar files with the high cover ratios in those projects.
an intriguing observation would be evolution of licenses and copyrights of those files.
those found files had different licenses and copyrights but they have been unified into gpl version and lee david painter and contributors respectively.
this would suggest that those codes in different projects had been donated and that their licenses and copyrights had been modified.
input files similar files found by ichi tracker figure .
histogram of similar files found for each query file in sshtools v. d iscussions a. application of integrated code history tracking as shown in the case studies ichi tracker provides an overview history and evolution of a query source code.
it spots the projects in which the query code locates and it identifies the cloned code fragments in the same or different projects which describe the evolution history of the original project.
this is a very important and needed feature when we reuse the source code at our hand.
in case b shown in fig.
we can understand that the code qchad been reused by other projects around late through early except for project .
on the other hand more than a half part of qchas been reused by projects and in cluster b. this would suggest that we would prefer to reuse the newer and recently created code rather than the older code qcor its similar ones.
if the newer code would provide the sufficient functionalities we might choose to copy from project rather than i.e.
qc .
in case a in fig.
various projects with different cover ratios are currently active so we could choose an appropriate new one based on their functionalities.
one important application of using ichi tracker is to check license evolution.
in our case studies the licenses had evolved from new bsd license to zlib libpng license in case b and from original bsd license to new bsd license in case a .
those evolutions would be consistent and cause no trouble to reuse them.
however if we would find inconsistent licenses such as bsd license and gpl license in evolution we have to care about reusing those codes.
ichi tracker can easily check such inconsistency.
in such sense this system is very effective to identify plagiarism or illegal use of open source systems.
b. approach and processes of ichi tracker code search engines in this implementation of ichi tracker we have used engines google code search koders and spars r. our system might be seen as a meta code search system over these three search engines.
however the pre and post processes used here are not simple nor straightforward ones as usual meta search systems.
the output results of our case studies show that google code search replies more output results than other engines.
however those output results do not always cover the output results of other engines so the output results of other engines are still important.
we can extend the external search engines for better results but we need to create the interface program for each new search engine.
we may think that using the internet search systems such as google or bing is more effective rather than using the code search engines.
we can easily try our case studies to those internet search systems.
we have tried those keywords listed in table i and ii with google and bing.
the results contain various kinds of output including search results from google code search and koders raw source code files in open source repositories compound source code forms with various extra explanations e mail archives document files related to the query code and many other unrelated files.
those might contain source code fragments which cannot be found by the code search engines but extracting useful code parts from those various kinds of files would be an excessive challenge here.
keyword selection as described in section iii we have taken a strategy of selecting keywords for the code search engines such that we choose nmost frequently used keyword in the query code fragment and nis initially and is incremented by one until the search results become less than for each engine.
we could consider many other different algorithms and different parameter settings for the keyword selection.
at the beginning of the development of ichi tracker we took another algorithm which starts with nkeywords say n and decrements nby one for each loop until a sufficient number of results is obtained.
in many cases this strategy might eventually reach to the same results as the current implementation however choosing the initial value ofnis not easy.
also since we get sufficient results with keywords in many cases starting from one and incrementing nare faster than decreasing from .
we have investigated a strategy of using keywords only in the comment parts of the query code fragment.
the output results heavily depend on the query source code but a general tendency is that the search engines return many noncloned source code files for a few keywords as their input.
if we give more keywords in comments those non cloned files could be eliminated but the number of the output results become less.
also we have investigated keywords from the source code part which are used less frequently in that file.
in such case the output results heavily depend on the selection of the keywords whose frequency is only one.
most lessfrequent keywords appear only once and if we do not choose appropriate keywords specific to the query code the query results from code search engines become fairly broad ones which contain many unrelated and non cloned code fragments.
as an extreme strategy we have tried randomly selected keywords from the code part.
the result also heavily depends on the selected keywords but a general tendency would be that in many cases we get weaker search results by the random strategy in the sense that the results contain less cloned code fragments than the strategy of using mostfrequently used keywords.
we have used keywords equal to or longer than characters.
our investigation has indicated that including or shorter keywords generates many unrelated search results from the code search engines.
also breaking into smaller keywords from the camel case keywords e.g.
camelcase camel and case and snake case keywords e.g.
snake case snake and case would eliminate the characteristics of the query code and might increase unrelated results.
input and output attributes current implementation of ichi tracker uses the file name as only an input attribute associated with source code fragment.
this attribute is passed to google code search and koders.
those search engines allow other attributes as their extra input such as language and license.
if we would extend our system to accept those attributes then the search results might be refined.
however we have to elaborate individual interface and to tune other parameters for better performance with those attributes.
as the attributes of the output results we have mainly used the cover ratio and the last modified time.
the cover ratio is computed automatically by the query code fragment and the code clone filtering results under the current implementation.
the last modified time is obtained manually through the repositories whose location is presented by the code search engines.
this extraction might be performed automatically but there are many different types of repositories so that the implementation would not be simple.
other output attributes such as license developer and project name are also important information to understand the code history and evolution more deeply.
an approach of analyzing comments in the source code similar to an automatic license detection method will help to extract those attributes automatically.
c. performance issue the case studies described in section iv showed that ichi tracker required about to min.
to get the output results.
these response times might be slow as an interactive tool.
however the current implementation of ichi tracker is a prototype to validate our approach to the integrated code history tracker so the performance of ichi tracker is not our main focus now.there is room for a significant improvement of the performance.
currently ichi tracker sequentially downloads the source code files after it receives the header lists of the search results from the code search engines.
this process could be parallelized and speed up by using multiple download threads.
however the overall performance might be bounded by the performance of the code search engines and the network environment.
d. quality of search result it is not straightforward to evaluate the quality of the search result of ichi tracker since this tool heavily depends on external search engines whose detailed insides are not known to us.
especially the source code repositories for those external engines should be investigated for the recall computation of our tool but we cannot do it.
we would consider the ratio r sr is an indicator of the precision of the external search engines.
for example as shown in table i a at iteration gives .
.
this does not indicate that we will have false positive results in the final output.
the code clone filter will remove those false positive results so that the remaining final results will always contain code clones for the input query qc.
e. threats to validity the empirical studies we have conducted have several threats to validity.
first we have selected three targets for the case studies.
if we had chosen different targets then we might have different consequences.
we have several other trials with different target files and have found no significant differences from those case studies.
however we would need to accumulate the experiences of various kinds of targets.
we have used ccfinder as a code clone detector for filtering out the unrelated query results and it may report false positives as mentioned before.
we would assume the ratio of the false positive is fairly low but we might need to check with different code clone detectors.
vi.
r elated works a. origin and evolution of code there are many research studies on analyzing and tracing code origin provenance evolution genealogy and so on through code clone analysis .
duala ekoko et.
al propose clone tracker to trace and manage code clone history .
they have developed a tool for supporting clone tracking with an abstract clone information named clone region descriptor.
davies et.
al.
propose software bertillonage for determining the origin of code entities with anchored signature matching method .
these researches are closely related to our work.
however their objectives are different from ours in the sense that they analyze various characteristics of code fragment in their local repositories.
in our case we analyze the origin and evolution of the query code in internet repositories.b.
code search engines code search is not only a very emerging research area but also a very useful resource for software engineers these days .
we have used google code search koders and spars r as the code search engines here.
in addition to these ordinary keyword based search engines many complicated search mechanisms have been proposed.
javacio is a meta search engine for source code jar files and documents which executes a query for a keyword set and returns search results using google code search koders and others .
exemplar is a code search engine which expands the user s query keywords to api calls by a dictionary made by help documents .
codebroker is an interactive development tool to support code completion by searching and providing useful code fragments in the repository which flexibly extracts various information from a partial code fragment on edit and finds appropriate artifacts .
there are many other approaches to code search and grechanik el.
al.
have well summarized and classified those engines in .
however none of these engines have features of accepting code fragments as their inputs or filtering out nonclone search results.
parseweb is similar to our system in the sense they use code search engines for collecting source code .
it uses a type matching query such as source destination and generates method invocation sequences as the output.
also parseweb performs a code analysis to extract the method invocation sequences.
our approach uses the code search engines as the resource of code collection too but the query input is a code fragment and the resulting output is the code fragments containing code clones with the query code fragment.
also we use the code clone filter for the elimination of unrelated code fragments returned from the code search engines.
lchecker takes a similar approach to the license compliance of the target source code file .
it tokenizes the input source file and makes a query to google code search.
the resulting license information is compared to the query file.
this system targets only the license compliance without tracking overall history of code.
there are various different code search engines with different types of query inputs and search mechanisms but none of those provides the code search features with both the code fragment query input and the code clone filter.
c. open source repositories there are many useful open source repositories on the internet.
one example is sourceforge in which we can find thousands of very active open source development projects.
however it does not provide a precise code search feature but it shows the overall project information.
schwarz et.
al.
proposes an idea of linking method of clones across repositories without actual implementation.
sourcereris a large scale software repository with keyword and fingerprint based search features .
these repositories will be very important and useful resources of the open code clone search if they would provide sufficient features to locate the specific source code fragments.
d. code clone detection and management there are many active researches on code clone detection and analysis .
among those there are works focusing on code clone search with scalability and performance for the large scale repositories.
lee et.
al.
proposes a clone indexing method for detecting similar code fragment in a large repository .
keivanloo et.
al.
also proposes a hybrid approach to real time and scalable code clone search using two types of indexing .
those are important and useful techniques for the code clone search for the local repositories however to explore code history of open source systems we have to collect a huge amount of code and to keep updated everyday by ourselves.
our approach does not require such overhead.
vii.
c onclusion in this paper we have proposed an integrated model to code history tracking and presented the detailed processes of ichi tracker which is a prototype system for the model.
we have conducted experiments with several case studies which show the applicability and effectiveness of our approach.
there are several future works.
one is to improve the performance and usability of the current prototype implementation of ichi tracker by which users can use the system interactively.
another would be to explore a unified approach of local repositories and internet repositories by which we might get more better recall with sufficient performance.
one interesting idea to extend the history tracking is to use the search results as the new search queries.
repeated tries of this loop would change the queries gradually from the original code and might produce morphed code.
tracking such code chain will be a new challenge.
acknowledgment we are grateful to the anonymous reviewers for their useful comments.
our colleagues yoshiki higo norihiro yoshida and takashi ishio have contributed to this work for their valuable suggestions and supports.
this work has been partially supported by japan society for the promotion of science grant in aid for scientific research a no.
exploratory research no.
and global coe program founding ambient information society infrastructure and also by mext for the development of next generation it infrastructure the stage project .