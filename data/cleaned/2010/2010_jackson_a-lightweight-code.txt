mit open access articles a lightweight code analysis and its role in evaluation of a dependability case the mit faculty has made this article openly available.
please share how this access benefits you.
your story matters.
citation joseph p. near aleksandar milicevic eunsuk kang and daniel jackson.
.
a lightweight code analysis and its role in evaluation of a dependability case.
in proceedings of the 33rd international conference on software engineering icse .
acm new york ny usa .
as published publisher association for computing machinery acm persistent url version author s final manuscript final author s manuscript post peer review without publisher s formatting or copy editing terms of use creative commons attribution noncommercial share alike .
a lightweight code analysis and its role in evaluation of a dependability case joseph p .
near aleksandar milicevic eunsuk kang daniel jackson computer science and artificial intelligence laboratory massachusetts institute of technology jnear aleks eskang dnj csail.mit.edu abstract adependability case is an explicit end to end argument based on concrete evidence that a system satis es a critical property.
we report on a case study constructing a dependability case for the control software of a medical device.
the key novelty of our approach is a lightweight code analysis that generates a list of side conditions that correspond to assumptions to be discharged about the code and the environment in which it executes.
this represents an unconventional trade o between at one extreme more ambitious analyses that attempt to discharge all conditions automatically but which cannot even in principle handle environmental assumptions and at the other ow or contextinsensitive analyses that require more user involvement.
the results of the analysis suggested a variety of ways in which the dependability of the system might be improved.
categories and subject descriptors d. .
design methodologies general terms software dependability safety reliability keywords dependability case problem frames property part diagram code analysis side conditions .
introduction the construction of a dependability case an explicit argument that a system satis es a critical property is increasingly being advocated not only for assurance that is establishing the dependability of a system but also as an integral part of development by making design and implementation decisions that simplify and strengthen the case and thus improving the dependability of the delivered system.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm acm ... .
.this paper reports on applying this idea to a medical system the control software for a proton therapy machine focusing in particular on the use of a lightweight static analysis.
the starting point is the articulation of a safety critical property of the system namely that when the treatment door is inadvertently opened in the middle of a treatment the system should terminate the delivery of the radiation by inserting a physical beam stop.
we constructed a dependability case for the property from the system level down to the code.
a static analysis developed specially for the purpose of this study was applied to the code which generated a list of side conditions that represented obligations to be discharged some about the physical peripherals and some about the computer infrastructure.
the side conditions were classi ed into those that were more or less reasonable that is more or less likely to hold and based on this classication some design and implementation alterations were proposed that might strengthen the dependability case.
the contributions of the paper include a concrete illustration of an approach to constructing a dependability case that we have outlined in earlier papers involving identi cation of partial but critical properties of the problem domain construction of a property part diagram showing the relationship between component speci cations and system level requirements and checking of the code against the component speci cations.
a lightweight code analysis based on symbolic execution that incorporates user provided speci cations so that in particular calls to a middleware api can be interpreted appropriately discharges control ow conditions automatically using symbolic state information but delegates to the user the harder problem of discharging conditions that are related to the state of external peripherals and presents the results to the user for evaluation in a form that aids navigation and review.
a strategy for improving the dependability of the system by generating a list of side conditions that correspond to environmental assumptions reviewing them manually and then adjusting the design and implementation to eliminate the less desirable assumptions.
the paper is organized as follows.
we begin by outlining the context of the case study the basic structure of the installation and the software and the existing safety mechanisms including a redundant hardware layer that mitigatepotential safety problems section .
we discuss the critical property considered and show how property part diagrams were constructed for them section .
we then describe the code analysis that we performed section and the results of the analysis section the list of conditions that were generated and how they were evaluated.
we discuss the recommendations that were made to the developer of the system to improve the safety of the system and lessons that we learned from the case study section .
we conclude with a discussion of related work section .
.
overview of the system the burr proton therapy center bptc at the massachusetts general hospital is one of only a handful of places in the world o ering radiation therapy with protons.
in contrast to gamma ray and electron therapy proton therapy o ers more precise targeting and therefore less collateral damage making it safer and more e ective for a variety of conditions in particular tumors of the eye brain tumors and tumors in small children.
like most other software controlled medical devices the proton therapy system at the bptc is complex.
there are three treatment rooms each containing a robotic positioning couch on which the patient lies a gantry allowing coarse aiming of the proton beam and a nozzle for ne control over the beam.
the beam from the cyclotron is multiplexed between the rooms and guided to the nozzles by a system of electromagnets.
in the basic treatment scenario the therapist calls up the prescription from a database positions the patient and the gantry and submits a beam request.
technicians in the master control room oversee the cyclotron and system settings and grant requests by allocating the beam.
since the software design group at mit has collaborated with the development team at the bptc led by the center s director dr. jay flanz on a project exploring new ways to structure and analyze software to ensure safety while retaining exibility to extend functionality.
the bptc team is currently working on a major enhancement of the system that will allow pencil beam scanning in which a ne beam scans the tumor in contrast to the current approach which uses a more di use beam whose outline is contained by custom collimators that are inserted in the nozzle aperture.
the bptc system incorporates a number of safety mechanisms.
the beam emerges from the nozzle and passes through an ionization chamber allowing a redundant dose check before arriving at the patient.
a completely separate hardware system based on programmable logic arrays and independent hardware relays checks for a variety of critical conditions and in particular can shut o the beam if the preset overdose is reached or exceeded.
in addition the system contains various safety features to mitigate the risk of inadvertent radiation exposure not only to patients but also to employees of the hospital i.e.
therapists and physicians .
for this case study we chose the critical property of one particular safety feature and constructed a dependability case to argue that the system satis es the property door safety property when the treatment door is opened in the middle of a treatment session the system inserts the beam stop to terminate the treatment.
in a previous study we had investigated a similar property using an ad hoc approach based on a mostly manual re view of the code .
in this study we analyzed the door safety property using the framework we have recently developed and using a new code analysis tool built for this purpose.
.
dependability case adependability case is an explicit end to end argument that a system satis es a critical property.
it is explicit in that it provides concrete evidence that the system establishes the property and end to end that its claim about dependability spans the system both horizontally in terms of real world phenomena of interest from input to output and vertically from the design level down to the code .
these two characteristics contrast with the conventional processbased approach to dependability which typically mandates a particular regimen of documentation testing and perhaps even formal veri cation and does not require concrete evidence that these e orts ensure dependability.
.
overview of construction in our approach the construction of a dependability case involves the following steps .identifying critical system level properties a large complex system usually has a long list of requirements some of which are more critical to dependability than others.
the rst task in constructing a case involves prioritizing the requirements and identifying the most critical ones.
.articulating the system structure having identi ed a critical property the parts of the system and their interactions are described using a problem diagram from jackson s problem frames approach .
a hallmark of this approach is the distinction between parts that are components of the machine to be built e.g.
modules of the software and parts that are domains in the environment e.g.
physical peripherals or human operators .
this distinction is essential to a dependability case since the critical requirements that are of interest are stated in terms of phenomena in the real world which are often not observable at the interface of the machine.
for example the requirement that the door opening causes the beam stop to be inserted concerns the domains in which the door and the beam stop are situated how the software behaves at its interface with these domains will of course turn out to be vital but is not relevant at the requirements level.
.assigning properties to parts the critical requirement is decomposed into properties on individual parts of the system.
a property on a software component is the speci cation that the software must be implemented to ful ll a property on an environmental domain is an assumption about how the domain behaves.
we use a property part diagram to express dependencies between properties and parts.
the diagram illustrates how di erent parts of the system each satisfying its own property together establish the highlevel requirement.
the resulting dependency structure in the property part diagram corresponds to the design level argument in the dependability case.rtworksrpc serverdoorbeam stopdoor open beam stop inserted safetycontrol unitbeam control unittreatment control unit beammanagertreatment managersystemmanagerdoor eventbeam stop eventdoor signalbeam stop signal rt msgsrt msgsrpc msgsrpc msgsrpc msgsdatadaqtcp ip msgsfigure problem diagram for the door safety property.
a box represents a system part and the label on an edge between two boxes a shared phenomenon through which they interact.
related parts are grouped inside a dotted box.
the requirement the circle is expressed in terms of phenomena on two environmental domains the door and the beam stop.
.analyzing the design level case the propertypart diagram is analyzed to ensure that the decomposition from the previous step is correct namely that the combination of the properties on the individual parts together satisfy the system requirement.
the analysis may help reveal a missing domain assumption or a weak speci cation.
.checking each individual part finally after having established the dependability case at the designlevel the implementation of each software component is checked to ensure that it conforms to its speci cation.
discharging a domain assumption involves consulting a domain expert to ensure that the assumption is a reasonable characterization of the domain s behavior.
.
building a case for the door safety we demonstrate our approach by describing the construction of a dependability case for the door safety property in the bptc system.
our goal is to build a case to argue that when the door is opened during treatment the system inserts the beam stop to immediately halt the delivery of radiation.
the problem diagram in figure illustrates the structure of the bptc system which consists of physical equipment such as the treatment door and the beamstop low level control units which interact with hardware sensors and actuators to control the physical equipment high level managers which direct the control units to carry out the treatment and intermediate communication mechanisms including standard tcp ip and rpc protocols as well as an o the shelf messaging library called rtworks .
the software components run on commodity unix workstations on a local area network.
the software consists of around lines of c code distributed across several hundred source les.
the system parts interact with each other by sharing phenomena which include for example signals generated by a physical device and sensed by a control unit and rtworks and rpc messages sent over the network.
in the diagram these phenomena appear as labels on the edges between the parts the arrow on an edge shows the direction in which information associated with a phenomenon ows from one part to another.
in a typical scenario the parts of the bptc system communicate with each other in the following manner.
a control unit initiated by a hardware signal sends a tcp ip message to an intermediate component called datadaq .
datadaq then relays the message to a manager that is responsible for handling the event through rtworks.
the manager processes the message and prepares an appropriate response by delegating the task to another manager through rtworks or by sending an rpc message directly to a control unit.
an important aspect of the problem diagram is that it states the door safety property only in terms of phenomena that occur in the environment namely the events of the door opening and the beam stop being inserted.
it does not mention anything about phenomena inside the software components i.e.
the control units datadaq or the managers .
thus our next task involves using the problem diagram as a starting point to derive domain assumptions and speci cations that are su cient to establish the property and assign them to the corresponding parts.
the problem diagram is elaborated into a property part diagram figure that shows how the requirement is decomposed into properties on the individual parts of the system.
in this case all the properties take a simple form that one event leads to another and are stated informally.
an edge in the property part diagram shows how one property is discharged either by a combination of other properties or by a component of the system.
for example the property on datadaq states that when it receives a message from the safety control unit indicating that the door has been opened datadaq noti es the treatment manager by invoking the function rtdaqindooropen this is a partial speci cation that must be fullled by the implementation of datadaq for the door safety property to hold.
when the treatment manager is noti ed of the door opening it instructs the beam control unit to insert the beam stop eventually by invoking the function bsinsert this property is shown in the diagram as being fullled together by the two managers.
since datadaq uses rtworks to communicate to the managers the speci cation of datadaq depends on the correct behavior of rtworks in handling requests to create and send messages.
hence there is an edge from the property of datadaq to that of rtworks.
similarly the managers rely on rtworks and the rpc server for communication to ful ll their responsibility.rtworksrpc serverdoorbeam stopdoor open beam stop inserted safetycontrol unitbeam control unittreatment control unit beammanagertreatment managersystemmanagerdatadaqdoor open door signaldoor signal door open msgdoor open msg rtdaqindooropenrtdaqindooropen bsinsertcreate deliver messagescreate deliver messagesbsinsert beam stop signalbeam stop signal beam stop insertedfigure property part diagram for the door safety property.
a box represents a part and a circle represents a property.
an edge originating from a circle shows a dependency of the denoted property on a part or another property.
an edge between two boxes shows interaction between the parts for simpli cation we omit the labels that represent shared phenomena.
.
the door safety property depends not only on the specications of software but also on assumptions on the environment.
when the treatment door is opened we expect the door sensor to generate a signal to be sent to the safety control unit.
if the sensor fails to do so for some reason e.g.
a power failure then the system will not insert the beam stop regardless of how the rest of the system behaves.
thus stating these domain assumptions is crucial to achieving dependability.
the dependency structure in the property part diagram corresponds to the argument that the system establishes the door safety property.
if the software components satisfy their speci cations and the domains behave as expected then the system should insert the beam stop when the door is opened.
the properties on the individual parts correspond to the premises of the argument these premises must be shown to hold by analyzing the implementation or discharging the domain assumptions.
the argument together with evidence for discharging its premises forms the dependability case for the door safety property.
in section we describe the code analysis that we performed to produce evidence that the implementation of the treatment and beam managers conform to their speci cations.
if properties and parts are speci ed formally an argument can be mechanically checked for validity that is the combination of the speci cations and domain assumptions indeed establish a critical property.
we modeled the bptc system in the alloy modeling language and analyzed the argument for the door safety property using the alloy analyzer a sat based analysis tool.
due to limited space we do not describe the model in this paper however the complete al loy model is available on eskang mgh model .
.
code analysis as noted above in this particular case the properties asserted of the software components in the property part diagram all take a particular form that the occurrence of one event leads to another.
in the code these properties translate into a relationship in the call graph that calling one function inevitably leads to calling another.
the property on the managers that support the door safety property for example is rtdaqindooropen bsinsert rtdaqindooropen is a function in the implementation of the treatment manager and bsinsert is a function in the beam control unit.
having formulated the desired properties of the software this way a lightweight analysis is used to show that a call to rtdaqindooropen really does cause the call to bsinsert .
the analysis takes a component and its partial speci cation and produces a set of side conditions that if true imply that the component satis es its speci cation.
if the analysis produces no side conditions then the analysis has proved the component correct with respect to the speci cation.
more often however the analysis fails to discharge all of the side conditions and leaves some for the user to manually discharge.
the analysis scales to large codebases for two reasons.
first it examines only a single component at a time an approach that is made possible by the practice of decomposing requirements into partial speci cations on individual parts.
second the analysis is designed to give up quickly.
as the analysis navigates the path from origin to destination figure snapshot of the prototype tool displaying a list of side conditions to reach bsinsert .
it attempts to evaluate conditional expressions using symbolic state but the set of conditions that can be evaluated without user input is small.
to mitigate this the analysis prompts the user for more information for example when a procedure whose code is missing is called and if it cannot evaluate a condition at all adds it to the list of generated side conditions to be reported to the user and discharged by other means.
this lightweight style of code analysis is intended to support a feedback loop between the design and implementation steps.
a side condition represents a proof obligation but it also gives the user information about how the design of the system can be improved since a side condition that is too di cult for the analysis to handle often points to potential design aws such as tight coupling and unnecessary dependencies.
after examining the set of side conditions the analysis generates the user may choose to redesign the system to eliminate the most problematic of these conditions update the implementation and rerun the analysis.
a screenshot of our tool appears in figure .
the lefthand pane contains the tree of function calls leading from the premise to the conclusion of the desired property the topright hand pane allows the user to browse the code and the bottom right hand pane contains a summary of the symbolic environment used in the analysis and the side conditions the analyzer has discovered.
.
strategy and implementation to check whether components in the bptc system propagate events as they should we implemented a lightweight ow sensitive context sensitive static analysis.
only a single path need be followed since in this particular system all branches away from the normal path represent erroneous behavior.
this makes the analysis very lightweight since it avoids the path explosion problem entirely.
it is still necessary however to ensure that this normal path is indeed followed and that requires evaluating the conditions along the way.
the evaluation of conditions is based on abstract state computed by the analysis.
the state obtained by the symbolic evaluation alone is not however su cient to evaluateall conditions.
in addition the analysis needs domain knowledge that constrains the initial state indicates what values are returned by calls to missing code and gives the source and destinations of messages which are determined in the implementation by a publish subscribe subsystem that registers event types with handlers using initialization les in a special language .
this domain knowledge is encoded in tables provided by the user.
these tables were constructed from the speci cation documents of the system and using the domain knowledge of the developers.
.
analysis algorithm the pseudocode describing the analysis is outlined in figure .
for each statement in the code s control ow graph the top level analysis function analyze applies the function analyzestmt with the current symbolic environment env.
the algorithm has global access to the entire codebase through the data structure code which maps each function to a list of statements.
it also has access to domain knowledge which contains the set of user provided information about the symbolic state.
the analysis proceeds as follows.
when the statement to be analyzed is a variable assignment we simply assign the symbolic value of the right hand side expression to the environment line .
if the statement is a conditional we rst attempt to determine whether or not the condition can be resolved to a constant lines .
if not then we check the two branches to see if any one of them will immediately return an error.
if so we add the condition that would lead to the non erroneous branch as a side condition using the helper function generatesidecondition and analyze that branch lines .
if we cannot immediately determine which branch to proceed into then we pause the analysis and ask the user for more domain knowledge to resolve the condition line .
once the symbolic environment has been updated with a new piece of domain knowledge we re analyze the statement.
if the statement is a function call and the code for the function is available then we simply analyze the body of the code line .
if not then we rst check whether the information about the function call already exists in the cur input a list of statements to be analyzed and symbolic environment 3analyze stmts env 4foreach stmt in stmts analyzestmt stmt env input statement to be analyzed and symbolic environment 9analyzestmt stmt env ifstmt v e then variable assignment env v eval analyzestmt e env else if stmt if cond then b1 else b2 then conditional analyzestmt cond switch eval cond env case true analyze b1 env case false analyze b2 env case symbolic ifb1 is error block then generatesidecondition !cond analyze b2 env else if b2 is error block then generatesidecondition cond analyze b1 env else can t proceed ask user pause else if stmt f a b ... then function call iff in code then code for f available analyze it analyze code env else if f a b ... in domain knowledge then return value of f is known update environment update env domain knowledge generatesidecondition f a b .. does not crash else can t proceed ask user pause figure pseudocode for the analysis algorithm.
rent set of domain knowledge.
if so we update the symbolic environment accordingly and generate a side condition that says that the function must not crash since this would lead to an undesirable consequence of the program never reaching its goal lines .
finally if no information is known about the missing function we prompt the user for domain knowledge line .
if the analysis completes successfully but does not reach its goal in our case bsinsert the procedure that inserts the beam stop then this implies either that the implementation of the system is incorrect i.e.
does not conform to the speci cation or that the domain knowledge provided by the user is insu cient.
in general the analysis prompts the user for precisely the domain knowledge it needs.
it is designed to be an interactive process between the user and the analyzer when the analysis fails the user inspects the reason for failure and1static boolean rtdaqindooropen rtvar id id trmgr state state f 4boolean dooropen areanotsecured keyinservicemode tcrkeyswitch 6if state trmgr initialization f return true 8g 9if !rtvargetboolrtvalue id dooropen f trace error msg return false 12g 14if dooropen f if !eventssafetyevent trmgr door isopen f trace error msg return false 18g if state trmgr irradiating jj state trmgr managing interruption f if !eventsinterruption trmgr door isopen f trace error msg return false 24g 25g 26gelsef ... 28g 29return true g figure example c code from the treatment manager software.
adds domain knowledge to avoid that problem.
in practice this design leads to speci c questions to be posed to domain experts.
domain knowledge therefore involves no guesswork if the domain expert can answer the question then the correct domain knowledge has been obtained.
.
example as an example of our analysis consider the code snippet in figure the rst part of rtdaqindooropen .
the analysis proceeds as follows .
the rst conditional line is encountered and the analysis is unable to determine which branch to follow.
the user must provide domain knowledge stating that state !
trmgr initialization .
.
the second conditional line is encountered and the analysis determines that the false branch must be chosen in order to avoid an error.
it emits the side condition rtvargetboolrtvalue id dooropen true .
.
the third conditional line is encountered and the analysis is unable to determine which branch to follow.
the user must add domain knowledge stating that rtvargetboolrtvalue id dooropen sets dooropen to true .
.
the fourth conditional line is encountered and the analysis examines the eventssafetyevent function and determines that it returns true .
.
the fth conditional lines is encountered and the analysis is unable to determine which branch to follow.
the user must add domain knowledge that state trmgr irradiating in other words that the system is in the irradiating state .
.
the sixth conditional line is encountered and the analysis nds the call to eventsinterruption .
the analysis generates the side condition that eventsinterruption trmgr door isopen returns true that is that the treatment room door is indeed open .
when the analysis is complete then the user has provided the following domain knowledge state !
trmgr initialization the treatment manager is not in the state corresponding to initialization .
rtvargetboolrtvalue id dooropen sets dooropen to true that the door is open .
state trmgr irradiating the treatment manager is in the irradiating state .
and must manually discharge the following side conditions rtvargetboolrtvalue id dooropen true that the library call for determining whether the door is open completes successfully .
eventsinterruption trmgr door isopen true .
.
analysis effort since our analysis involves interactions with the user to gather domain knowledge we did not measure the elapsed time for the analysis.
after all of the domain knowledge has been provided by the user the analysis took seconds to generate all of the side conditions on an intel dual core cpu .
ghz running ubuntu.
even though the entire bptc system consists of lines of code across hundreds of c les once the number of paths have been narrowed down to the single critical path using the domain knowledge the analysis had to explore only lines of code across source les.
we consulted one of the developers of the bptc system who provided us with the necessary knowledge about the system state at the time when rtdaqindooropen is called and the expected behavior of the function calls in the managers.
the number of pieces of domain knowledge required for this analysis were relatively small and mainly involved the api calls to rtworks and the rpc server.
this illustrates the appealing feature of our analysis by utilizing knowledge of a human expert to discharge side conditions we were able to avoid analyzing large portions of the codebase if available that would have normally been tackled by a more conventional analysis.
the bptc system is large enough that manual inspection of the code or even the code of a single component would be nearly impossible.
our lightweight analysis allows the inspector to direct his or her attention to the lines of code that are relevant to the property being investigated making manual inspection tractable even for very large pieces of software.
event logging evtrepreportevent true evtrepforwardevent true evtrepsendmessage true hciloggerlog true system calls sprintf strbu er s s hostname devicename strncpy shorttextevent newparttextevent strlen newparttextevent fprintf hcilogfile s strcat infomsg tr .
all calls must not cause a segmentation fault message building act inhibit beam act first action act inhibit beam act last action tipcmsgappendint4 beamactionmsg act inhibit beam true tipcmsgappendint2 beamactionmsg true tipcmsgappendint2 beamactionmsg double scattering mode true tipcmsgappendstr beamactionmsg true global state external domains rtvargetboolrtvalue rtvar door closed dooropen true trmgrgetcurrenttrmgr current treatment manager trmgrgetroomid current room id trmgrgetbeamdeliverytechnique double scattering mode bmtoolgetbeamallocation true bmstateisrequestvalid true figure side conditions for the door safety property categorized in terms of their characteristics.
.
results figure shows the results of the analysis as a list of side conditions sorted by our determination of their type.
first we found that the safety critical code we analyzed depends on less critical components that perform logging figure .
the three evtrep functions report events to the logging facilities while the hciloggerlog sends events to the hci manager to display them to the user.
both of these logging components depend on system calls for formatting strings and writing them to les on disk figure .
operations like strcat sprintf and strncpy can cause segmentation faults fprintf can fail if the lesystem is full.
either situation might cause the beam stop not to be inserted.
second the process for building and invoking an rpc call takes several steps and all must complete successfully for the beam stop to be inserted figure .
the rst two side conditions in this section represent properties of message types that can easily be veri ed manually the others however rely on the proprietary smart sockets implementation of the rpc server.
finally we discovered many side conditions related to the use of global state figure .
the rtvargetboolrtvalue function for example looks up the value of a global variable thetrmgrgetcurrenttrmgr function inspects the global state to obtain a pointer to the current treatment manager.
it is di cult to build con dence in code that depends on global state because less critical code could modify that state at anytime.
if the global state is not in the expected con guration the safety critical code may not function correctly.
this dependence means that allcode with access to the global state must be treated as safety critical and analyzed as such this task was outside the scope of our case study.
.
discussion .
recommendations we found no evidence of bugs in the implementation.
moreover a more sophisticated analysis might have been able to discharge some of the side conditions reported but still excluding the side conditions that re ect properties of the environment .
in our view however we treat the undischarged sideconditions as suggestions for how the system might be improved so that its safety is more evident.
in this section we review these suggestions.
some are easily implementable with few changes to the existing codebase others would require more signi cant redesign of the system.
it should be noted that the software is backed by a redundant hardware safety system so the software is not a single point of failure.
first some of the side conditions can be eliminated by replacing them with ones that can be more easily discharged or by reordering parts of the implementation.
for example string manipulation might be done using a safe string library instead of standard c functions this would eliminate the side conditions on system calls.
error logging might be done after instead of before the beam stop is inserted eliminating the side conditions related to logging.
both of these examples involve relatively straightforward refactoring and would strengthen the dependability case.
other side conditions point to larger issues in the design of the system and may suggest changes at the architectural level.
highly critical functionality e.g.
the response to the door opening depends on generic components e.g.
rtworks that serves multiple areas of functionality some of which are of lower priority e.g.
patient positioning .
a better approach might be to construct a separate reliable communication pathway reserved for emergency functions such as the beam stop insertion thereby eliminating the dependency on rtworks.
.
lessons learned theorem provers and static analyzers are designed to prove that a system satis es a property they do not leave behind side conditions for the user to discharge.
in our experience with the bptc system producing a complete proof would be very di cult because the set of components involved in producing the proof is large and includes components for which neither code not precise speci cations are available.
by introducing a human element into the analysis e ort and by dealing with di cult proof obligations by eliminating them from the critical path rather than by proving them correct we are able to balance investment in analysis and design and obtain some degree of con dence from more lightweight analyses.
the way a system is structured and coded has a big inuence on how e ective such a lightweight analysis can be as noted by griswold .
in this study the systematic structure of the bptc system was a great help because of the pervasive use of events rather than for example communication through global variables it was easy to formulate properties in terms of simple control ow.
many of the speci cations in the bptc system had the form if event a happens then event b should happen.
this makes the analysis easier to implement with some domain knowledge about which functions send and receive events the analysis can check code against such a speci cation without the use of a constraint solver.
even speci cations that do not naturally take this form can often be recast in terms of the events that cause the desired outcome.
because event causality is transitive there is a natural modularity that the analysis exploits for each module the analysis connects an originating event to a target event.
consistent coding conventions can be exploited in the analysis.
the bptc code for example uses the convention that each function call returns true for success and false for failure.
the programmers also used a standard set of functions to indicate error conditions.
these conventions can be encoded as domain knowledge and can be used by the analysis to improve both scalability and precision.
for example by expecting most functions to return true our analysis is able to emit more speci c side conditions for missing functions.
.
limitations some analyses are di cult to perform using our lightweight engine.
our analysis cannot handle extensive global state dynamic allocation or concurrency and does not address timing constraints.
additionally the soundness of our analysis is dependent upon the accuracy of the domain knowledge the user provides about environmental domains.
the analysis o ers no guidance in discharging the domain knowledge instead it relies on the user to consult with a domain expert for example a physicist who understands the expected behavior of the proton beam or a technician with the knowledge of the beam stop mechanics.
our analysis by itself does not provide su cient evidence to support a dependability case.
to further strengthen the case it should be combined with other techniques including extensive unit and integration testing historical data on the reliability of framework components more sophisticated and complete analysis of critical components and evaluation by domain experts of domain assumptions.
unifying results from di erent kinds of analyses to demonstrate dependability remains a challenging research problem .
.
related work dependability cases traditional approaches to evaluating dependability of software systems in industry are process based .
in these approaches a system is considered suitable for certi cation by a government agency if its development adheres to one or more standards such as common criteria or iec .
the main criticism of processbased approaches is the lack of an evident link between the extent of the quality assurance activities that are mandated by the standards and the level of dependability that is inferred .
in response a number of case based approaches to software dependability have been developed.
the common goal behind these approaches is to provide an argument that directly links the developer s claims about the dependability of the system to concrete evidence e.g.
testing reports formal proofs etc.
that support them.
our approach belongs to this group.
kelly introduced the goal structuring notation gsn as a way to represent a safety case an argument that the system satis es its safety properties .
assurance based development abd is a methodology that integrates an assurance case with the development of a dependable system1.
in this approach based on the gsn the top system level requirements are decomposed into smaller subgoals which are discharged using various strategies .
lutz and pattersonhine proposed an approach to building an argument to support the system s ability to detect and handle safetyrelated contingencies.
like abd the structure of their argument is based on the gsn but they discharge subgoals using analysis of fault models.
in both of these approaches the premises of an argument sub properties that together imply the system level property are linked to the methods by which they are discharged these methods may include testing inspection or formal methods.
in contrast the property part diagram connects the premises the speci cations and domain assumptions to theparts that are responsible for ful lling them.
in other words whereas these approaches tend to focus on the structure of the development process for evidence of dependability we instead focus on the structure of the product.
code analysis there is a rich body of work in the literature on techniques for checking code conformance against speci cations.
many of them deal with checking behavioral speci cations or heap invariants .
our approach is much more lightweight in nature it does not attempt to discharge the side conditions itself and it relies on the user s domain knowledge to prune the search space down to a single critical path.
in this respect our work is similar to murphy notkin and sullivan s re exion model .
the user of the re exion model tool provides a mapping between portions of the source code and their counterparts in the high level system model similar to the way in which our approach relies on the user s domain knowledge.
the re exion model is concerned with system wide structural conformance of the code against the design while our analysis is applied to ensure a behavioral property at the individual component level.
1we prefer the more general term dependability case over the more common terms safety case which seems to exclude systems that are mission critical but not safetycritical and assurance case which de emphasizes the role of cases in design.giving special treatment to events and informing the analysis of those events through speci cations is not a new idea and is part of the framework by popescu garcia and medvidovic .
by extending the idea of domain knowledge to function speci cations we can also analyze functions for which we have no implementation.
snelting and his colleagues describe an analysis technique to extract a set of conditions that need to hold for a path to be taken between two locations in a program called path conditions and use a constraint solver to nd an input value that could lead to safety violation .
although our side conditions are similar to theirs in nature it would be di cult to generate many of the conditions that arise in the bptc system automatically using their technique for example a condition on a function for which the source code is not available such as rtworks .
.
conclusion most published e orts to establish the safety of critical systems have taken the system as a given and have focused on the question of what analysis is su cient to discharge all proof obligations.
in our approach we seek a balance between analysis and design trying to reduce the critical path that is responsible for ful lling critical properties so that a simpler analysis can be used to establish them.
the analysis we developed for this case study supports this balance by generating side conditions that are either discharged by manual analysis or eliminated by refactoring.
in applying this analysis to the therapy system we found that the set of side conditions generated was reassuringly small but still gave useful insights into how the system might be improved.
.