partition based regression verification marcel b ohme school of computing national university of singapore marcel comp.nus.edu.sgbruno c. d. s. oliveira school of computing national university of singapore oliveira comp.nus.edu.sgabhik roychoudhury school of computing national university of singapore abhik comp.nus.edu.sg abstract regression verification rv seeks to guarantee the absence of regression errors in a changed program version.
this paper presents partition based regression verification prv an approach to rv based on the gradual exploration of differential input partitions.
a differential input partition is a subset of the common input space of two program versions that serves as a unit of verification.
instead of proving the absence of regression for the complete input space at once prv verifies differential partitions in a gradual manner.
if the exploration is interrupted prv retains partial verification guarantees at least for the explored differential partitions.
this is crucial in practice as verifying the complete input space can be prohibitively expensive.
experiments show that prv provides a useful alternative to state of the art regression test generation techniques.
during the exploration prv generates test cases which can expose different behaviour across two program versions.
however while test cases are generally single points in the common input space prv can verify entire partitions and moreover give feedback that allows programmers to relate a behavioral difference to those syntactic changes that contribute to this difference.
index terms software verification testing and analysis i. i ntroduction software verification seeks to guarantee the absence of errors in a program but is rather expensive in practice.
there are two main reasons verification requires specifications which may be difficult to write and maintain and the verification process can be very time consuming.
however there is some hope for a cheap form of regression verification rv .
the goal of rv is not to verify the correctness of a program ad absolutum but relative to an earlier version.
thus rv seeks to guarantee the absence of regression errors.
this more modest goal allows rv to avoid separate forms of formal specifications.
the previous version serves as sufficient specification for checking whether the changed version is at least as correct as the previous version.
yet in practice rv for all inputs is very time consuming.
godlin and strichman proposed a decision procedure that takes two program versions and either proves behavioral equivalence thus the absence of regression or provides a witness of behavioral difference.
the authors report that the verification of non equivalent versions can take a long time to terminate or run out of memory.
in fact generally proving the equivalence between two programs is an undecidable problem.
while the termination of rv provides strong regression guarantees for all inputs the interruption of the verification procedure due to time or memory constraints yields no guarantees at all.
regression verification regression testing partition based regression verification unverified input space verified input space fig.
.
prv versus regression verification and regression testing this paper presents partition based regression verification prv a gradual approach to rv based on the exploration ofdifferential partitions .
a differential partition is a subset of the common input space of two program versions that serves as unit of verification.
instead of verifying the entire input space at once prv allows gradually verifying such partitions one by one.
as illustrated in figure prv shares the advantages of both regression testing rt and rv .
like rv if all differential partitions are shown equivalent then prv guarantees the absence of regression errors for all inputs.
more importantly prv allows a form of partial verification if the verification procedure is interrupted prv guarantees the absence of regression errors for the explored partitions that are shown equivalent.
thus like rt prv allows the gradual checking for regression.
however while rt provides verification guarantees only for the concrete executed sample inputs prv seeks to guarantee the absence of regression for entire input partitions.
in practice this partial verification approach is crucial as verifying the complete input space can be infeasible due to time or other resource constraints.
technically differential partitions are computed using a form of symbolic execution and require deterministic program execution.
in contrast to other input partitioning techniques differential partitioning accounts for the inputs of two programs.
a differential partition is characterized by a symbolic condition that defines a range or subset of valid input for that partition.
input is grouped according to whether it reaches the same syntactic changes and whether it propagates the same differential state to the output.
if an input computes the same output in both versions the respective partition is said to be equivalence revealing .
in such case both versions are soundly guaranteed to compute the same output for all input satisfying the symbolic condition.
otherwise the respective partition is said to be difference revealing .
c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
1input i 2a o 3i i i i 4if i a 6if a o i 8output o a programs p and p input output pi 0o i 0o i p i 0o0 i 0o0 i prvi 0o o0 i o o0 i i 0o i o0 i b differential partitions fig.
.
running example incomplete bugfix figure illustrates differential partitions in a concrete example.
program pcomputes output obased on the values of inputiand is changed to p0by substituting line with the commented code.
figure .b shows the symbolic output that is computed based on the evaluation of the input variables for both programs.
the bottom three rows depict one equivalencerevealing and two difference revealing input partitions.
note that the analysis of only a single version is insufficient to expose all interesting subsets of input.
in particular a test suite t fi i 1gcovers all paths in both programs and even reveals a difference.
however input i is a missing test case that could represent a regression error.
intuitively it is interesting because the branch in line is evaluated in different directions in both versions.
prv explores a distinct difference revealing partition for this input.
prv provides an alternative to regression test generation techniques .
upon allowing the continued exploration even of difference revealing partitions the developer may in formally verify such partitions.
the test cases generated for each difference revealing partition can be checked against the developer s expectation.
the program slice used to compute the partition can be inspected to determine the changed statements contributing to the difference.
the symbolic conditions and summaries cf.
fig.
.b can be further analyzed by tools.
our initial experience with prv is very encouraging.
for the studied subjects prv efficiently exposes regression errors that are not detected by the considered test generation methods.
in summary the main contributions of this paper are a gradual approach to regression verification that continuously verifies the input space of a program against another version of that program to find regression errors.
if the verification procedure is interrupted prv guarantees the absence of regression errors for the explored input space that has been shown equivalence revealing.
adifferential partitioning technique based on symbolic execution that soundly partitions the input of two versions.
the partitioning technique symbolically groups input of the two programs and creates partitions which either guarantee behavioral equivalence or expose differences for a certain subset of inputs.
an alternative to regression test generation .
the approach can be used to generate test cases for partitions where differences are found.
as illustrated by our experimental evaluation finding such test cases is competitive with state of the art regression test generation techniques.
theimplementation andexperimental evaluation of prv.
unexplored partition a execute test case b compute differential partition c generate next test case witnessing test case equivalence revealing partition difference revealing partition d continuous exploration fig.
.
exploration of differential partitions ii.
p artition based regression verification prv takes two successive program versions and continuously verifies differential partitions def.
.
the gradual regression verification can be interrupted at any time.
in this case the regression guarantees are retained for the verified input space.
for every partition prv generates a concrete sample input that is added to regression test suite t. the programmer can check difference revealing test cases in t for regression errors and relate an output difference to the set of syntactic changes that contribute to that difference.
the intuition of partition based regression verification is presented in figure while the detailed procedure is outlined in algorithm .
later in theorem we will claim the exhaustiveness of this exploration algorithm.
definition differential partition a differential partition dp p0is obtained by partitioning of the common input space of two program versions p p0.
inputs in any differential partition dp p0have the following property either all inputs in dp p0produce the same output inpandp0 an equivalence revealing partition or all inputs indp p0produce different outputs in pandp0 a differencerevealing partition .
the exploration starts with a random test case in the queue.
depicted as black dot in figure .a this random test case tis taken from the queue and executed upon both versions.
test casetis a point in the common input space1of both versions representing concrete knowledge about the differential behavior.
in figure .b input is grouped into a differential partition that yields the same differential behavior as t. this input exercises all those statement instances that are relevant to the reachability and propagation of the syntactic program changes exercised by t. hence in algorithm the symbolic condition is computed as a conjunction of the pertinent branch conditions.
later in theorem we will claim the soundness of this generalization from a test case to a differential partition.
1the derivation of the common input space for versions with different input spaces is discussed in e.g.
the new version has one more input variable.303algorithm partition based regression verification input versionspandp0 changescandc0 letqueue lett letv addrandominput toqueue whilequeue6 do lett choosenexttestcase queue letcondition computedpartition t p p0 c c0 callgenerateadjacenttestcases condition queue addttot addcondition tov end while output verified input space v regression test suite t as depicted in figure .c the next test case is executed outside of the explored input space.
to generate such adjacent test cases the constituent branch conditions are negated one by one cf.
alg.
similar to other path exploration techniques.
this yields a number of intermediate constraints.
if a constraint solver finds a satisfying witness to one of these constraints then it is added to the queue waiting to be executed.
as depicted in figure .d after the execution of the next test case from the queue again the corresponding differential partition is computed.
this procedure repeats until all differential partitions are explored or some time budget is exhausted.
asearch strategy would assign some distance or fitness to each constraint and decide the order in which the partitions corresponding to intermediate constraints are explored.
this is implemented in the procedure choosenexttestcase not listed .
in particular prv takes from the queue in the order they arrive but prioritizes test cases that promise different output the propagation of already exercised changes and the execution of another set of changes in that order.
finally every executed test case is added to the regression test suite t. each test case is a witness of one differential partition.
the set of explored differential partitions vrepresents the verified input space.
a. computing differential partitions the computation of the differential partition for a given test case is presented in algorithm .
it implements the functionality of procedure computedpartition called in algorithm and requires determinism for every execution of the same input on the same program the same output is computed.
also the deletion of variable assignments e.g.
x x inpis represented by dummy statements e.g x x inp0 cf.
.
upon execution of the test case ton both programs pand p0 the symbolic condition is computed.
input that does not exercise a syntactic change or that does not propagate the differential state to the output is equivalence revealing.
if t does not exercise a changed statement then prv employs the reachability condition def.
to group input that does not execute a change for the same reason .
if texercises at least one changed statement but yields the same output in both versions then prv employs the propagation condition def.
.algorithm procedure computedpartition input inputt versionspandp0 changescandc0 let trace execute t p let trace execute t p0 letcondition false ifnot exist an instance of c02c0in 0then letcondition v c02c0reach c0 else letoibe the instance of output oin leto0 ibe the instance of output oin ifvalue oi value o0 i then letcondition prop o c c0 else letcondition diff o c c0 end if end if output conditioncondition input that yields different output is difference revealing.
iftyields different output in both program versions then prv employs the difference condition def.
to group input that computes different output for the same reason .
these reasons are defined upon the exercised dynamic and static program dependencies as enunciated in the following.
b. computing reachability conditions intuitively an input tdoes not execute a changed statement c because the conditions of the branch instances siupon which cstatically control depends are evaluated in the direction that does not favor the execution of c. 1input i j 2a b 3if i a 5for c c j c b c 7if j if a change c fig.
.
intuition of reachability condition an example is shown in figure .
input does not execute the changed statement in line .
why?
because the branch in line is not evaluated to true .
this is because the condition in line is evaluated to true and the condition in line to false .
the remainder of this section explains the computation of the reachability condition based on the relevant slice of the branch in line .
definition relevant slice given an execution trace and a statement instance siin therelevant slice ofsiin contains all statement instances ri in that are in the transitive closure of dynamic data controland potential dependence of si.304a statement instance sipotentially depends on conditional statement instance riin path iff.
there exists a variable v used insisuch that vis not defined between riandsiin but there exists another path fromritosialong which vis defined and evaluating ridifferently may cause this untraversed path to be executed.
note that relevant slices have a desirable property if two inputst0andt1exercise the same relevant slice computed w.r.t.
a statement instance si then the variables used in si have the same symbolic values for t0andt1 .
relevant slices are used to define the reachability propagation and difference conditions.
the property of relevant slices is utilized to prove theorem establishing that these conditions indeed characterize differential partitions as defined in definition .
definition reachability condition the reachability condition reach c computed over the trace w.r.t.
statement cis the path condition computed over the union of the relevant slices of all instances siin of every statementsthatctransitively statically control depends on.
if an input t0does not exercise statement c then every inputt1satisfyingreach c t0 p does not exercise c. a path condition is a quantifier free first order logic formula on program inputs.
any test input satisfying the path condition of a path is guaranteed to also exercise all statement instances in path .
the negation of a constituent branch condition in the reachability condition computed w.r.t.
statement cmay change the reachability of c. c. computing propagation conditions intuitively an input tdoes not propagate the semantic effect of the exercised changes to the output because certain statement instances niupon which the output dynamically depends carry the same values in both versions.
on a high level nirepresents the point where the differential program states converge.
any attempt of negating a branch beyond that point to propagate a difference in program state is futile.
2a 2o false false 2a 2o false false a old version p b new version p fig.
.
intuition of propagation condition figure shows the dynamic dependency graphs augmented by concrete values and computed for the execution of input upon the version pairs in figure .
the dashed arrows indicate potential dependence while the concrete arrows indicate either dynamic data or control dependence.
each node is labeled with the line number of the statement instance itrepresents.
the values for the instance of line are different in both versions.
that is the program state is infected after the execution of the change.
however the value of the output in line is the same for both versions.
why?
the semantic effect of the change in line is not propagated to the output in line 8for the execution of onpandp0 because the branch in line 4is evaluated in the same direction in both versions even though it dynamically depends on the statement in line which carries different values in both versions.
in the remainder of this section we explain how the instance of line 4is added to the convergence set niand define the propagation condition based on ni.
as shown in algorithm both dynamic dependency graphs ddgs are computed over the traces and 0for the execution of input ton both versions pandp0.
the ddgs are augmented by potential dependencies and the concrete values for the variables used in every node.
output instances oiin ando0 iin 0are aligned and passed into procedure p ropalign to compute nirecursively.
algorithm computing differential state convergence ni input execution traces and output statement o addg augmentedddg addg0 augmentedddg oi o0 i alignableoutput addg addg0 o ni ifischanged o0 i then add oi o0 i toni else call p ropalign oi o0 i procedure propalign si s0 i ri si getdependson r0 i s0 i getdependson for allr0 i2r0 ido if ischanged r0 i 9ri2ri align ri r0 i value ri value r0 i then call p ropalign ri r0 i else add si s0 i toniandreturn end if end for end procedure output statement instances ni assuming that instances siands0 ican be aligned the tuple si s0 i is added to the set niif not all of the subsequent instancesr0 ican be aligned the values of the variables used inriandr0 iare different or r0 iis a changed statement.
this is represented by the intuitively named predicates in line .
note we do not assume that both ddgs can be aligned completely which would be rather difficult indeed due to the different number of instances every statement can have in both executions.
instead the alignment begins from the output statement instances e.g.
return which we assume to be alignable and follow the dependence edges recursively.
the instance at which alignment fails is added to ni.
in figure the instances in line are added to nibecause they depend on the changed statement in line that also has different values.305definition propagation condition let statements cin programpbe changed to c0yielding p0.
given traces and 0for the execution of input tonp andp0and algorithm computes nifor and 0and program output statement o the propagation condition is defined asprop o c c0 def ni n0 i 2ni rsc ni rsc n0 i value ni value n0 i v c2creach c v c02c0reach c0 .
every input satisfying the same propagation condition does not propagate the effects of the exercised changes for the same reason.
hence definition is a conjunction of five conditions.
the necessary conditions and leverage the property of relevant slices.
note rsc ni is the path condition computed over the relevant slice of statement instance niin trace .
every input exercising the same relevant slice w.r.t.
ni compute the same symbolic value for ni.
the negation of a constituent branch condition may change the computation of niand thus enable propagation.
the necessary condition captures that the symbolic values for the alignable instances inniare the same.
the negation of such an equivalence condition may enable propagation.
the necessary condition and captures that those changes not exercised by the test casetare also not exercised by other input satisfying the same propagation condition.
the negation of a constituent branch condition may enable the reachability of other changes.
d. computing difference conditions intuitively input tcomputes different output because it exercises a certain set of statement instances in pthat contribute to computing the symbolic output of pand another set of statement instances in p0that contribute to computing the symbolic output of p0.
definition difference condition let statements cbe changed to c0.
given instances oiof output statement oin trace ando0 iofoin trace the difference condition is defined as diff o c c0 def rsc oi rsc o0 i value oi value o0 i v c2creach c v c02c0reach c0 .
every input satisfying the same difference condition propagates the semantic effect of the exercised changes for the same reason.
to achieve this property definition is a conjunction of five necessary conditions.
the necessary conditions and leverage the property of relevant slices.
every input exercising the same relevant slice w.r.t.
oi compute the same symbolic value for oi.
the negation of a constituent branch condition may change the computation of oiand thus disable propagation.
the necessary condition captures that the symbolic output values are different in both versions.
the negation of this condition may disable propagation.
the necessary conditions and capture that those changes not in or 0are also not exercised by other input satisfying the same difference condition.
the negation of a constituent branch condition may enable the reachability of other changes.a set of changed statements ctsemantically interferes for the execution of input ton both program versions if tyields different output in pandp0and everyc2ctcontributes to computing the output.
thione et al.
approximate semantic interference based on static data and control dependence.
it can be used to understand the origin of regression.
interestingly every changed statement in the relevant slice ofo0 icontributes in computing o0 iand therefore semantically interferes.
this allows the developer to inspect the set of changes responsible for an observed semantic difference.
e. generating adjacent test cases algorithm generates adjacent test cases from the provided symbolic condition and adds those to the queue .
it implements generateadjacenttestcases called in algorithm .
algorithm generate adjacent testcases input conditioncond queuequeue letcond m n k for all iin do constr m n i ifexistst that satisfies constr then addt toqueue end if end for let n reorder n for allifromnto0do constr m i i ifexistst that satisfies constr then addt toqueue end if end for let m reorder m for allifrommto0do constr i i ifexistst that satisfies constr then addt toqueue end if end for output queuequeue the symbolic condition is composed of branch conditions m inp0 branch conditions n inp and equivalence conditions of the form value si value s0 i orvalue si value s0 i cf.
line .
first the constituent equivalence conditions 0to kare negated oneby one lines .
if there exists a solution to the computed constraint it is added to the queue.
second if some branch conditions are removed from a path condition the remaining branch conditions have to be reordered before negation lines .
otherwise the exploration algorithm ceases to be exhaustive cf.
.
hence the branch conditions m inpare reordered as follows if a branch instancebis in the relevant slice of branch instance bk then the branch condition of bis placed before the branch306condition of bk.
otherwise the branch condition of bis placed after the branch condition of bk.
the reordered branch conditions in pare negated one by one and conjoined with m inp0 line .
if there exists a solution to the computed constraint it is added to the queue.
lastly the branch conditions in p0are reordered and negated one by one lines .
again if there exists a solution to the computed constraint it is added to the queue.
f .
theorems in the following we postulate the soundness of algorithm that computes the differential partition for a given test case and the exhaustiveness of algorithm that explores differential partitions.
for the lack of space the detailed proof has been moved to the corresponding technical report .
in practice the absence of regression errors can be guaranteed for all inputs to the same extent as symbolic execution can guarantee the absence of program errors see e.g.
.
specifically we assume deterministic program execution.
theorem sound generalization given statements cin programpare changed to c0yielding p0 every input satisfying the condition computed by algorithm for input tis in the same differential partition as t. informally the differential behavior of a point in the common input space is soundly generalized to the set of points in the same differential partition.
in particular let algorithm compute the symbolic condition for a test case t. ift is equivalence revealing then every input satisfying is equivalence revealing.
similarly if tis difference revealing then every input satisfying is difference revealing.
theorem exhaustive exploration if there exists an input t0that computes different values for the outputoin versionspandp0and algorithm terminates with regression test suite t then there exists a test case t2t so thatt0satisfiesdiff o t p t p0 c c0 .
informally if the verification procedure terminates then all differential partitions have been explored.
the respective proof leverages the exhaustiveness of the exploration based on relevant slices as shown in .
iii.
e mpirical study our experiments evaluate the relative efficiency of prv and discuss practicability based on our experience.
the experiments do not prove the scalability of prv.
in fact prv suffers from the same limitations as symbolic execution.
similarly it can benefit from relevant optimizations such as domain reduction parallelization and better search strategies .
a. setup and infrastructure prv has been implemented into our dynamic backward slicing tool jslice .
the differential partitions are explored in a breadth first manner starting from the same initial input within the time bound of five minutes unless stated otherwise.every version of the same subject uses the same test driver to construct necessary input objects strings or arrays from the input integers that come as solution to a first order logic formula from the z3 constraint solver .
the subject programs are analyzed on a desktop computer with an intel 3ghz quad core processor and 4gb of memory.
b. subject programs the subjects summarized in figure are chosen according to two criteria they represent a variety of evolving programs and are discussed in related work which allows the comparison with our own experimental results .
there are versions of programs ranging from to almost lines of code loc .
some versions are derived by seeding faults called mutants of the original versions.
some are real versions that were committed to a version control system.
subject reference classes functions loc versions min tcas replace siena apache cli total fig.
.
subject programs we compare the empirical results of the