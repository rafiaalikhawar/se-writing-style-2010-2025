seeking the ground truth a retroactive study on the evolution and migration of software libraries bradley e. cossette and robert j. walker department of computer science university of calgary calgary alberta canada bcossett walker ucalgary.ca abstract application programming interfaces apis are a common and industrially relevant means for third party software developers to reuse external functionality.
several techniques have been proposed to help migrate client code between library versions with incompatible apis but it is not clear how well these perform in an absolute sense.
we present a retroactive study into the presence and nature of api incompatibilities between several versions of a set of java based software libraries for each we perform a detailed manual analysis to determine what the correct adaptations are to migrate from the older to the newer version.
in addition we investigate whether any of a set of adaptation recommender techniques is capable of identifying the correct adaptations for library migration.
we nd that a given api incompatibility can typically be addressed by only one or two recommender techniques but sometimes none serve.
furthermore those techniques give correct recommendations on average in only about of cases.
categories and subject descriptors d. .
distribution maintenance and enhancement.
general terms experimentation design measurement veri cation.
keywords api adaptive change recommendation systems.
.
introduction software developers rely on external libraries to provide reusable functionality.
ideally developers can rely solely on the application programming interface api that libraries permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa copyright acm ... .
.provide to access their functionality without worrying about their implementation details they hope that the api is a contract that will not change .
however software libraries are susceptible to the same environmental pressures to change that all software systems face .
as a result library maintainers need to evolve their systems in ways that sometimes result in an incompatibility between the old and new versions of their api .
this raises a dilemma for both api developers and client developers whether to migrate to the new api version and endure the adaptive e ort or to refuse to migrate to the new version risking the problems bugs and security risks that come from relying on obsolete software.
much research has addressed the issues involved in migrating source code to accommodate api changes .
yet only a few papers empirically study how apis change over time classifying the nature of the changes these systems undergo .
despite numerous evaluations of change recommendation or library migration approaches there exists no established corpus of unbiased library change data.
to both fully appreciate the complexities of real library migration issues and to serve as a standardized basis for evaluating novel solutions we need a collection of all points of breaking change between a set of api versions that also identi es the correct replacement to migrate dependent code in each case.
such a corpus would permit absolute measurements of the quality of recommendations including knowledge of misses important goals for this growing research area.
we present an empirical investigation into the changes of java software libraries and their apis across multiple revisions.
we identify all points of change in each new version of an api that resulted in a binary incompatibility with respect to its previous version.
a binary incompatibility bi is de ned as any change to a type such that code compiled and linked without error to a binary containing that type prior to the change does not link to a new binary containing the changed type lists of bi kinds are available on line.1for each bi we determine whether replacement functionality exists in the new library version we manually apply six library migration techniques to each bi to observe the ability of each to recommend correct replacements and we analyze each of the replacements we found to classify the nature of the transformation that would need to be applied to client source code to 1e.g.
java based apis 1adapt to that particular library change.
we found that existing change recommendation techniques were successful on average in only of the cases examined.
furthermore we discovered that the majority of library changes could not have their needed transformations automatically enacted upon client source code without signi cant developer intervention and or speci cation.
the rest of this paper is structured as follows.
in section we discuss previous work on library migration.
in section we present the methodology we followed in our study.
in section we present our observations on the data we have collected including quantitative descriptions of bis technique e ectiveness and classi cations.
we present a preliminary extension to an additional technique in section .
in section we discuss our ndings their implications and threats to the validity of our work.
the contributions of this paper are the classi cation and analysis of source code transformations necessary to adapt to library change a corpus of complete library change data for use in evaluating and replicating library migration techniques and a tool independent comparison of change recommendation techniques.
.
related work existing research on addressing the issues caused by api evolution has focused primarily on how to preserve backwards compatibility through the provision of adaptive layers e.g.
wrappers that simulate the original legacy interface .
alternatively some work has considered how to migrate client systems to the new library version by altering the client s implementation.
.
supporting library migration some work has examined how the original library developer can specify or capture the changes enacted between library versions in order to mechanically enact them on a client s source code without developer intervention.
in the simplest cases the library maintainer uses tooling to record refactorings enacted on their source code and from this generates a refactoring script that can then be shipped with their new library version another technique requires the library developer to provide annotated rules for changed functionality that describe how to update dependent code .
while such techniques spare client developers a substantial amount of work they have signi cant limitations as to the kinds of api evolution and hence the corresponding migrations that they can support.
the migration approaches devised by such techniques are also done in isolation from client source code and may not be aware of the particular characteristics of how the client uses their libraries.
other related approaches include attempts to inline missing functionality from the old library into the developer s source code a technique that is not always appropriate .
several techniques recommend how to replace broken functionality caused by an upgraded api.
these techniques use one or more analysis techniques to compare two library versions and attempt to reconcile how the versions have changed.
the analyses include the lexical comparison of method signatures whether new functionality in a library is a code clone of previous functionality how a model of the underlying software is altered between versions how a library s use of its own api has changed how other developers have migrated their code or test suitesto accommodate the api change and using a combination of some of these techniques .
.
empirical studies of api change there are few empirical studies on how apis evolve.
finding actual points of change in libraries is painstaking work and determining how undocumented changes to an api should be addressed requires substantial investigation.
nearly all evaluations of api migration tools utilize noa priori knowledge of what the actual changes and replacements should be in the libraries analyzed.
dig and johnson s case studies on api evolution are among the few exceptions.
for two versions of ve apis they determined how many breaking and non breaking changes occurred in each classi ed each change as refactorable or non refactorable and provided a breakdown as to the kinds of refactorable and non refactorable changes they encountered.
an often cited statistic from their work is that ...over of these changes are refactorings.
pp.
unfortunately their work has three main shortcomings from our perspective a they analyze only a single transition between library versions b they analyze only public entities thus ignoring api specialization points provided through protected entities and methods common in object oriented frameworks and c they consider only those entities that they deem intended to be reused and for which there was publicly available documentation thus not supporting developers who utilize apis in unexpected ways.
in our previous work we report data on bis across the evolution of three libraries encompassing versions in total .
we showed that libraries frequently and seriously change over time and that even in later supposedly mature versions substantial change can occur.
our results only presented a coarse grained summary of the kinds of bis introduced in each version and of the distribution of changes over the life of each library we did not classify or resolve any of the changes we found.
the only other result in this area is an estimate by henkel and diwan that of the deprecated methods and class constructors in the java .
.
sdk could be replaced with refactorings.
they provide no details of how they arrived at this gure.
.
.
experiment based studies in order to evaluate api migration techniques researchers need data about how apis have evolved in reality so as to interpret whether the techniques output is correct however to date there is no corpus of software library change data that is publicly available for tool veri cation and testing and there is only one study in which the researchers identi ed change set data independently from the evaluation of their api migration technique .
in examining the literature common practices for approximating change set data when evaluating api migration and change recommendation tools include searching for keywords like refactoring in the commit logs of version control systems restricting the evaluation to a few well documented changes and their replacements using a recommendation tool to generate predictions then checking each prediction to see if it appears to be correct comparing tool predictions and performance relative to prior techniques and investigating cases where predictions di er and choosing a sample of negative recommendations sometimes 2representing as little as .
of the entire dataset to evaluate the recall accuracy of the technique .
some techniques present no evaluation of their e ectiveness .
other researchers have chosen to evaluate their tools and techniques through case studies in which they enacted a library migration for a few software systems or simulated a library migration for a subset of type changes across several software systems .
in these cases performing actual migration tasks provides a fair evaluation of whether the tool and technique deals with all the necessary cases as the compiler and or the run time behaviour of the program will catch missed ones the drawback is that the changes these tools are evaluated on tend to be a small subset of the potential changes that exist in that library or in software apis in general.
there is no reason without digging deeper to presuppose that these are representative scenarios.
.
methodology our goal in this work is to create a corpus of api change data which describes what has changed and what it has been replaced with in the new version of su cient completeness and accuracy to be useful to researchers to evaluate the effectiveness and limitations of api migration approaches.
we were also interested in understanding how changes in libraries potentially impacted the e ectiveness of techniques that are intended to detect such changes or to adapt source code to them.
we augmented our basic data collection with two additional analyses for each change how e ective are recommendation techniques in nding the appropriate replacement for each change?
how feasible is it to mechanically transform client source code to automatically migrate each existing dependency to its replacement?
we chose to analyze ve java based apis apache struts versions .
.
.
.
.
.
.
.
.
.
.
.
.
.
log4j versions .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
jdom versions .
.b6 .
.b7 .
.b8 .
.b9 dbcp versions .
.
.
.
.
.
.
.
.
.
.
.
.
.
and slf4j versions .
.
.
.
.
.
.
.
.
we chose the struts log4j and jdom libraries for the sake of replicating previous library migration studies of dig and johnson of sch afer et al.
and of wu et al.
of dig and johnson and of kapur et al.
and of kapur et al.
respectively our choice of the dbcp and slf4j libraries was in uenced by their popularity as reported elsewhere .
.
determining points of change to determine the changes within each library we examine the binary incompatibilities introduced between successive versions of the same library.
our use of bis o ers several advantages over what has previously been attempted the determination of what is and is not a bi can be mechanically determined from an analysis of the jar les of two library versions with a negligible risk of missing a breaking change between the versions it does not rely on the correctness and completeness of documentation and nally the introduction of a bi into a new library version represents a point of change that must be addressed in client code to migrate to the new library.
binary incompatibility thus represents in the general case a necessary but not su cient condition to overcome in migrating between libraries.
to determine the bis between two library versions we built an analysis tool based on clirr an open source tool for analyzing precompiled api jar les for binary compatibil ity.2for each adjacent pair of library versions we used our tool to determine the entities classes methods and elds in the old api which were binary incompatible with the new api thereby generating a report listing clirr s classi cation of each.
the nal report for each api version transition was written to a le in comma separated value format and imported into microsoft excel.
.
finding replacement functionality for each entity we found in the old api manifesting a bi with the new api we examined the new api to determine if it contained an appropriate replacement.
to assist our investigation we systematically applied analysis techniques that have been proposed in the various change recommendation techniques described in section .
.
each technique was applied independently of the others to evaluate its ability in isolation to nd the correct solution for each bi.
once all techniques were applied if we had found a suitable replacement for the binary incompatible entity we recorded it as the replacement in our corpus.
in cases where we found an answer but had doubts as to whether it was correct we marked the replacement as unsure .
in a few situations we found multiple potential replacements.
we decided that in all such cases we would record as the replacement the entity for which adaption of the client was easiest.
finally for those cases in which we failed to nd a replacement we recorded the entity as deleted .
we chose to apply seven change recommendation techniques manually using only tooling available to us in the eclipse ide v3.
.
we describe these below.
original code comments.
we examined the code comment associated with the binary incompatible entity to see if it had a deprecated tag and or if the comment indicated what the replacement functionality should be.
we then investigated the comment s recommendation to see if it was an appropriate replacement this step was necessary as we found a number of cases where deprecated tags referred to entities that did not exist in the new api.
release documents.
we examined the release notes if available and any other documentation we could nd online to see if the bi had been documented and if its replacement was speci ed.
similar approaches are used in the literature for collecting change sets.
implementation details and data ow analysis.
we applied a series of investigative techniques on the code to determine if it was possible to reason about what the replacement for the code should be.
primarily this entailed three things i studying the implementation of the entity as well as its usage to reason about the intent behind the functionality ii performing static dependency analysis on the entity and any other types methods or elds referenced by it including constants and iii examining the inheritance hierarchy and subclasses of the containing class.
this approach took considerable time and e ort to apply.
call analysis .
the call analysis technique examines