sherlock scalable deadlock detection for concurrent programs mahdi eslamimehr jens palsberg ucla university of california los angeles usa mahdi palsberg cs.ucla.edu abstract we present a new technique to nd real deadlocks in concurrent programs that use locks.
for .
million lines of java our technique found almost twice as many real deadlocks as four previous techniques combined.
among those deadlocks happened after more than one million computation steps including new deadlocks.
we rst use a known technique to nd deadlock candidates and then we determine that of them are real deadlocks.
our technique combines previous work on concolic execution with a new constraint based approach that iteratively drives an execution towards a deadlock candidate.
categories and subject descriptors d. .
software engineering keywords concurrency deadlocks .
introduction java has a concurrent programming model with threads shared memory and locks.
the shared memory enables threads to exchange data e ciently and the locks can help control memory access and prevent concurrency bugs such as data races.
in java the statement synchronized e fsg rst evaluates the expression eto an object then acquires the lock of that object then executes the statement s and nally releases the lock.
locks enable deadlocks which can happen when two or more threads wait on each other forever .
for example suppose one thread executes synchronized a fsynchronized b f. .
.gg while another thread concurrently executes synchronized b fsynchronized a f. .
.gg permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.one possible schedule of the program lets the rst thread acquire the lock of aand lets the other thread acquire the lock ofb.
now the program is deadlocked the rst thread waits for the lock of b while the second thread waits for the lock of a. usually a deadlock is a bug and programmers should avoid deadlocks.
however programmers may make mistakes so we have a bug nding problem provide tool support to nd as many deadlocks as possible in a given program.
researchers have developed many techniques to help nd deadlocks.
some require program annotations that typically must be supplied by a programmer examples include .
other techniques work with unannotated programs and thus they are easier to use.
in this paper we focus on techniques that work with unannotated java programs.
we use open source benchmarks that have a total of more than .
million lines of code which we use straight of the box without annotations.
we can divide deadlock detection techniques into three categories static dynamic and hybrid.
a static technique examines the text of a program without running it.
one of the best static tools is chord which for our benchmarks reports deadlocks which include both false positives and false negatives.
a dynamic technique gathers information about a program during one or more runs.
until now four of best dynamic tools are deadlockfuzzer contest jcarder and java hotspot which together for our benchmarks report real deadlocks.
finally hybrid techniques may be able to combine the best of both worlds static and dynamic.
one of the best hybrid tools is goodlock which is highly e cient and for our benchmarks report a total deadlocks which may include both false positives and false negatives.
in this paper we focus on dynamic techniques.
the advantage of a dynamic technique is that it reports only real deadlocks.
the main shortcoming of the previous dynamic techniques is that they mostly nd deadlocks that occur afterfewsteps of computation.
our experiments show that those techniques leave undetected many deadlocks that occur after one million steps of computations.
we believe that this shortcoming stems from their approach to search for executable schedules .
a schedule is a sequence of events that must be executed in order.
a real deadlock is a combination of deadlock pattern such as the one in the example above and an executable schedule that leads to the deadlock.
we will show how to do a better search for executable schedules.
the challenge.
help programmers nd more reproducible deadlocks than with previous techniques.our result.
we present a technique that for a deadlock candidate searches for an input and a schedule that lead to the deadlock.
we use goodlock to quickly produce a manageable number of deadlock candidates.
our technique combines previous work on concolic execution with a new constraintbased approach to drive an execution towards a deadlock candidate.
we have implemented our technique in a tool called sherlock that nds real deadlocks in java programs.
for our benchmarks our tool found almost twice as many real deadlocks as four previous techniques combined.
our technique is particularly good at nding deadlocks that happen after many execution steps we found deadlocks that happened after more than one million computation steps including new deadlocks.
our tool is fully automatic and its user needs no expertise on deadlocks.
once our tool reports a deadlock our tool can replay the execution that leads to the deadlock.
in summary the two main contributions of this paper are an e ective and easy to use tool for dynamic deadlock detection and a large scale experimental comparison of seven deadlock detectors.
the rest of the paper.
in the following section we present our approach and in section we present the key innovation that makes our approach work.
in section we present our experimental results in section we discuss limitations in section we discuss related work.
.
our technique overview.
in a nutshell we rst produce a set of deadlocks candidates and then we do a separate search for each of the deadlock candidates.
the key idea is to turn each search for a deadlock into a search for a schedule that leads to the deadlock.
we structure those searches in a particular manner that eslamimehr and palsberg used in their work on data race detection and that we illustrate in figure .
each circle in figure is a schedule.
the search is an alternating sequence of execute andpermute steps execute permute i execute whereiis a nonnegative integer.
the execute function attempts to execute a given schedule and determine whether it leads to a deadlock and the permute function permutes a given schedule.
the search begin with an initial schedule found simply by executing the program.
the search fails ifexecute cannot execute a given schedule if permute cannot nd a better permutation or if the search times out.
our key innovation is a permute function that works well for deadlock detection.
each call to execute may produce a more promising schedule after which a call to permute will further improve that schedule.
in more detail each call to execute will both try to execute the given schedule andcontinue execution beyond that schedule typically until termination of the program.
part of the continued execution may make progress towards the desired deadlock.
the call to permute will permute the events in the schedule to make the next call to execute have a better chance to succeed.
executeexecuteexecutepermutepermute initial scheduleschedule that leads to a deadlockfigure an illustration of the basic technique.
the alternation of permute andexecute steps is more powerful than either one alone.
for our benchmarks our technique nds deadlocks while execute alone nds only deadlocks and permute alone nds only deadlocks.
eslamimehr and palsberg s work on data race detection showed how to implement execute via a series of concolic executions as we will summarize below.
in section we show how to de ne a permute function that successfully helps to nd deadlocks.
data types.
we use these data types in sherlock program a java program input input to a java program lock a java object event threadid statementlabel schedule event sequence link threadid statementlabel lock statementlabel lock cycle link set deadlock cycle input schedule sherlock works for java programs which have the type program .
the input to such programs is a vector of values we use input to denote the type of input vectors.
each object in java contains a lock for simplicity we refer to each object as a lock and use lock to denote the type of locks.
we have one threadid for each program point that creates a thread.
notice that one threadid may cover multiple dynamic threads.
when a program execution executes a particular statement in a thread with a particular threadid we refer to that as an event that has type event .
the standard notion of schedule is here the data type schedule which is a sequence of events.
in the context of deadlock detection two key data types arelink andcycle .
we use link to describe that a thread in a particular statement has acquired a lock and now wants to acquire another lock.
we use cycle which is a set of links to describe a deadlock.
adeadlock is the type of information that we need to replay an execution that leads to a deadlock.
a deadlock has three components namely the cycle that is the deadlock theinput that we should supply at the beginning of the execution and the schedule that the execution should follow to reach the deadlock.deadlock candidates.
our technique relies on access to a set of deadlock candidates.
we use havelund s technique goodlock to produce deadlock candidates for our benchmarks of more than .
million lines of code.
those deadlock candidates are an excellent starting point for our search.
goodlock combines model checking and dynamic analysis into an e cient deadlock detector that can produce both false positives and false negatives.
here is the interface to goodlock goodlock program!
cycle set we use goodlock as a black box that is as an unmodi ed component for which we rely only on its input output behavior.
notice that goodlock maps a java program to a set of eventsets that is a set of deadlock candidates.
we use an extension of goodlock that can handle deadlocks of any number of threads .
havelund reported that deadlocks that involve three or more threads are extremely rare in practice and indeed for our benchmarks goodlock found only deadlock candidates that involve two threads.
the initialrun function.
here is the interface to the initialrun function initialrun program!schedule a call to initialrun simply executes the program with some particular input and records the schedule.
our benchmarks are drawn from open source repositories and each one comes with a speci c input.
for each benchmark we use the predetermined input in initialrun because those inputs appear to exercise the code well.
alternatively we could pick some other input for example at random .
we leave to future work to investigate whether the e ectiveness of our approach would be signi cantly a ected by the quality of the inputs.
the execute function.
here is the interface to the execute function execute program schedule cycle !
input schedule boolean fnoneg the arguments to execute are a program a schedule and a deadlock candidate.
a call to execute will attempt to execute the given schedule determine whether it leads to a deadlock and try to execute a longer schedule that contains the events embodied in the deadlock candidate.
consider the call a trace found execute p s c here found is aboolean that is true if the given schedule sleads to a deadlock and that is false otherwise.
if found is true then ais the input to the program that was used to execute the schedule.
additionally trace is the schedule that was actually executed.
the implementation of execute uses concolic execution .
our explanation of execute is in two steps rst we summarize the idea of concolic execution and then we explain the implementation of execute .
consider the sequential program x if y fsg which has input y and which contains a statement s. how can we nd an input that leads to execution of s?
a good answer is to use directed testing that executes the program multiple times with di erent inputs and each time hopefully gets closer to execute s. the insight of directed testing is deadlock set sherlock programp f cycle set candidates goodlock p schedules0 initialrun p deadlock set dlocks for each cyclec2candidates dof boolean found false boolean stalled false inti schedules s0 while found stalled i f case execute p s c of input schedule boolean a trace true f dlocks dlocks f c a trace g found true g input schedule boolean a trace false f case permute trace c of schedules0 fs s0g none fstalled trueg g none fstalled trueg g i i g g return dlocks g figure sherlock.
to use information from one execution to generate a more promising input to the next execution.
speci cally we need a listing of all the assignments and conditions and similar constructs encountered.
for example for the program above suppose the rst run uses input y .
the execution encounters one assignment x and one condition y .
we can read those as constraints and form the conjunction x y .
the last condition encountered y in this case led us o the path towards s. to get a more promising input we solve the constraints and might get the solutionfx y 10g.
here we see that we can try inputy which indeed leads to execution of s. such an execution that records constraints is called a concolic execution .
the word concolic stems from that the execution is both concrete it executes as usual and symb olic it record constraints .
if the statement sis nested deeply we may need many concolic executions before we either nd an input that leads to execution of sor we give up.
our implementation of execute uses eslamimehr and palsberg s generalization of directed testing to a concurrent program and a sequence of events.
the idea is to nd an input that leads to execution of all of the events in the sequence in order.
we can do that by iterating the above idea and by controlling the thread scheduler.
each iteration leads to execution of one of the events and the next iteration takes the constraints from the previous iteration as its starting point.
we control the thread scheduler to ensure that we execute the events in the right order.
if we can match the event sequence then we continue exploration in an attempt to execute as many of the events embodied in the deadlock candidate as possible.
however if we cannotmatch the event sequence then execute returns none which may happen for a variety of reasons including nondeterminism that stems from system calls and external events.
the permute function.
here is the interface to the permute function which maps a schedule and a deadlock candidate to a better schedule or else to none if no better schedule was found permute schedule cycle !
schedule fnoneg in the following section we describe permute in detail.
sherlock pseudo code.
figure shows pseudo code for sherlock which we will go over in detail.
we hope our pseudo code and explanation will enable practitioners to implement our technique easily.
the input to the sherlock procedure is a program while the output is a set of real deadlocks.
the rst three lines of sherlock declares these three variables a set of deadlock candidates called candidates that we initialize by a call to goodlock a schedule called s0 that we initialize to the trace produced by an initial run of the program and a set of deadlocks called dlocks that initially is the empty set and that we eventually return as the result of the procedure.
the main body of the pseudo code consists of a for eachloop that tries each of the event sets in the set of candidates.
the body of the for each loop declares these four variables a boolean found that tells whether we have found a schedule that leads to the desired deadlock a boolean stalled that tells whether permute was able to improve a given schedule and whether execute was able to match the trace and execute a longer trace with the events embodied in the deadlock candidate an integer ithat counts the number of pairs of calls to permute andexecute and a schedule called s that we initialize to s0.
for each deadlock candidate we use a while loop to do an alternation of calls to execute andpermute as illustrated in figure .
intuitively the while loop terminates if either we nd the deadlock we give up or we time out.
the time out condition i was never exercised in our experiments the highest number of iterations of the while loop for our benchmarks was .
in the body of the while loop we rst call execute to match the given schedule after which either we declare success or proceed with a call to permute or abandon the search.
similarly after the call to permute we either continue with the next iteration of the while loop or we abandon the search.
notice how each iteration of the while loop begins with s extends it to trace and then improves it to a new value of s. if we nd a deadlock then we record the input and the trace that lead to the deadlock.
if we abandon the search then the deadlock candidate may still be a real deadlock.
example.
we now present an example in which we walk through a run of sherlock on the following program with four shared variables and two threads a bare shared variables that contain objects x yare shared variables that contain integers yhas an initial value received from user input thread thread l1 x l5 x l2 synchronized a fl6 synchronized b f l3 if y f l7 if y2 x2 f l4 synchronized b fgl8 synchronized a fg g g g gthe example is a re ned version of the example in section we have added two assignments and two if statements.
the point of the example is that the program enters a deadlock only when it executes the bodies of both if statements.
for a deadlock to happen ymust be and the program must execute a particular schedule that lets xbe at the time the program evaluates the condition at l7.
so while a deadlock is possible most executions are deadlock free.
we will explain how our technique nds the deadlock.
we use these abbreviations for events e1 l1 e2 l2 e3 l3 e4 l4 e5 l5 e6 l6 e7 l7 e8 l8 .
the call to goodlock produces a single deadlock candidate namely the following cycle which in the for each loop will be called c c f thread l2 a l4 b thread l6 b l8 a g now we do an initial run of the program.
suppose that the initial input which becomes the value of the shared variable y is .
we get s e1 e2 e3 e5 e6 e7 now we run the rst iteration of the while loop.
first we runexecute which matches the schedule and nds out that with input y it can add the event e4.
so we have trace e1 e2 e3 e5 e6 e7 e4 the call to permute ontrace gives s e5 e6 e7 e1 e2 e3 e4 now we run the second iteration of the while loop.
the call toexecute matches the schedule with input y so we have trace e5 e6 e7 e1 e2 e3 e4 the call to permute ontrace gives s e5 e6 e1 e2 e7 e3 e4 now we run the third iteration of while loop.
the call to execute matches the schedule with input y adds the evente8 and enters a deadlock.
the schedule is trace e5 e6 e1 e2 e7 e3 e4 e8 our key innovation is permute which we explain next.
.
our permute function our permute function combines ideas from static analysis and dynamic analysis.
background dynamic race detection.
many researchers have studied how to extract information from execution traces.
a pinnacle of this area is the paper by serbanuta chen and rosu that presented a sound and maximal model of execution traces it subsumes all other sound models that rely solely on information from an execution trace.
they also showed how to use the model to do dynamic race detection.
their race detector works in two steps rst run the program to get a trace then nd an executable permutation of the trace that leads to a race.
their model helps guarantee that the chosen permutation is executable.
as shown later by said wang yang and sakallah one can phrase the problem to nd an executable permutation of a trace as a constraint solving problem and one t t 1oet idx o etn idx e2forkoe idx o e val first idx e2joino te val last idx oe idx e2 e type read0 v e tiwp null e val e var init v e12e pwsoe idx oe1 idx w e12e pwsvv e22e pws e26 e1 oe1 idx oe idx oe idx oe2 idx oe2 idx oe1 idx a v e ei ej 2eoi oj c oi1 oj2 oi2 oj1 where c f t1 li1 la lj1 lb t2 li2 lb lj2 la g andei1 t1 li1 ej1 t1 lj1 ei2 t2 li2 ej2 t2 lj2 figure constraints for our permute function can use an smt solver to produce that permutation.
in essence said et al.
presented a permute function that works well for race detection.
eslamimehr and palsberg combined said et al.
s permute function with concolic execution and thereby obtained an e cient and useful dynamic race detector.
we will present a permute function that works well for deadlock detection.
a static characterization of potential deadlocks.
deshmukh emerson and sankaranarayanan presented a static analysis of library code that identi es potential deadlocks.
their analysis delivers a library interface that describes how to call library functions with deadlock safe alias relationships among library objects.
in outline their approach has two steps.
first from the text of a library their static analysis builds a lock order graph and a representation of alias information.
the lock order graph describes the order in which the code acquires locks.
for example for the statement synchronized a fsynchronized b f. .
.gg the graph contains an edge from a node synchronized a to a node synchronized b .
second from the lock order graph and the alias information they derive constraints and show that the constraints are solvable if and only if the lock order graph is acyclic.
in other words the constraints are solvable if and only the library code cannot deadlock.
they use an smt solver to solve the constraints.
we will use their approach to handle lock orders in our de nition of permute .
a memory less permute function for deadlock.
now we give an overview of a baseline version of our permute function that we call the memory less permute function later we give a constraint based de nition.
our memory less permute function leads to a deadlock detector that nds deadlocks in our benchmarks which is already better than the previous dynamic techniques with which we compare.
at the end of this section we present an enhanced permute function that leads us to nd an additional deadlocks.
our memory less permute function combines aspects of said et al.
s permute function with aspects of deshmukh et al.
s static analysis and a constraint that encodes a deadlock candidate.
let us now explain the key observation that makes the combination work.
said et al.
generates a constraint that at the top level has two conjuncts a constraint that guarantees that the permutation of a trace will be sequentially consistent and2 a constraint that represents a data race.
we replace with a representation of deadlock candidate let us now take a closer look at .
the constraint about sequential consistency has three conjuncts that represent that the permuted trace must .
preserve the happens before relation for each thread .
satisfy write read consistency and .
satisfy synchronization consistency .
write read consistency means that a read event must read the value written by the most recent write event to that location and synchronization consistency means that the permuted trace is consistent with the semantics of the synchronization events.
our observation is that we can use .
and .
and then replace .
with the deshmukh et al.
s lock order constraints.
intuitively we replace dynamic information about synchronization and lock order from a single trace with static lock order information about the entire program .
the wholeprogram view of lock order makes our permute function efcient and powerful.
the grand total is a constraint that consists of the constraints .
and .
from said et al.
deshmukh et al.
s lock order constraints and a representation of a deadlock candidate.
this constraint if solvable represents a permuted trace.
if the input trace contains all the events embodied in the deadlock candidate and permuted trace is executable then the execution leads to the deadlock.
we use an smt solver to solve the constraint and as explained earlier right after the call to permute we run execute on the permuted trace to nd out whether it is executable.
constraints.
now we give full details of the constraints that we use in our permute function.
suppose we have a program a trace he1 eniof an execution of the program a lock order graph v e produced by a standard interprocedural static analysis of the program and a deadlock candidate c. the constraints use nposition variableso1 on.
the idea is that the value of oiis the position ofeiin the permuted trace.
the symbol denotes the happens before relation.
the constraints are of the form v e c where each of the four conjuncts is de ned in figure .
here is said et al.
s constraint .
is said et al.
s constraint .
v e is deshmukh et al.
s lock order constraints and cis a representation of a deadlock candidate.
figure uses helper functions that we explain below.
the constraint is formed by conjunctions and disjunctions of inequalities of the form oi oj .
a solution to theconstraints is an injective function s fo1 ong!f ng first we explain .
we use the same notation as said et al.
.
in particular for a trace and a threadid t we let het et nbe subsequence of t events in and we let t first denoteet 1and we let t last denoteet n. we assume that the set of threadids is t. for each event ein we usee idx to denote its index in we usee type to denote the event type which ranges over fread write fork join acquire release g and we use e tid to denote the threadid.
additionally we usee var to denote either in read or write a shared variable or in fork or join a synchronization object.
further we usee val to denote either in read or write a concrete value or in fork or join the child threadid.
fork denotes the set of fork events in and similarly join denotes the set of join events in .
the rst conjunct of expresses that the happens before relation per thread must be preserved.
the second conjunct of expresses that a fork event happens before the rst event of the forked thread.
the third conjunct of expresses that the last event of a thread happens before the thread participates in a join event.
next we explain .
we use the same notation as said et al.
.
in particular for a read event e we usee tiwp to denote the thread immediate write predecessor which is a write event that comes before ein that has the same threadid as e has the same variable as e and for which no other such write event occurs in betweene tiwp ande.
if no such write event exists then we write e tiwp null.
additionally for a read event e we usee liwp to denote thelinearization immediate write predecessor which is a write event that comes before ein that has a possibly di erent threadid than e has the same variable as e and for which no other such write event occurs in between e liwp ande.
if no such write event exists then we write e val e var init wheree var init is the initial value of variablee var .
finally for a read event e we usee pws to denote the predecessor write set which is the set of write eventse0such thate0 var e var and eithere0 tid6 e tid or bothe0 tid e tid ande0 e tiwp .
we usee pwsv to denote the subset of e pws for which for each element e02e pwsv we havee0 val e val .
the constraint has a conjunct for each read event in .
each of the conjuncts is a disjunction of two disjuncts one per line of the de nition of .
the rst disjunct says that if the read event doesn t have thread immediate write predecessor then the value read is the initial value and all writes to that variable come after that read in .
the second disjunct says that if contains a linearization immediate write predecessor then every possible write event e1 for the value read must come before the read event and no other such write event e2 can come between e1 and the read event.
next let us explain v e .
following deshmukh we rst use a standard interprocedural analysis to compute a lock order graph v e for the entire program.
the nodes v are events that acquire locks and the edges eexpress nested relationships between the nodes e1 e2 2eif and only if the body of e1containse2.
now v e is a conjunction of one constraint per edge ei ej 2e namely oi oj that expresses that eimust happen before ej.
finally let us explain how crepresents a deadlock candidatecwith two links in the cycle.
the de nition and expla nation generalize easily to cycles with more than two links though we haven t found any programs with such deadlocks.
the deadlock candidate can be understood as a collection of the four events ei1 ej1 ei2 ej2listed in figure .
a precondition for the deadlock candidate to be a real deadlock is thatei1andei2must both happen before both of ej1 andej2.
we have that v e contains oi1 oj1 and oi2 oj2 so to ensure that the precondition is met we let c be oi1 oj2 oi2 oj1 .
in case some or all of the four events occur multiple times in the trace we let the candidate refer to the rst occurrence of each event in the trace.
example.
let us return to the example from section and explain details of the call to permute in the rst iteration of the while loop.
that call is permute trace c where trace e1 e2 e3 e5 e6 e7 e4 andcis the deadlock candidate c f thread l2 a l4 b thread l6 b l8 a g here are the constraints used by the permute function.
first we list trace which preserves the happens before relation for each thread o1 o o2 o o3 o o5 o o6 o next we list trace which ensures write read consistency o5 o next we list v e which represents deshmukh et al.
s lockorder constraints o2 o o6 o finally cencodes the deadlock candidate c o2 o o6 o one possible solution is s e5 e6 e7 e1 e2 e3 e4 which ignores the constraints that involve e8becausee8 doesn t occur in trace .
so we can return sas the result of the call to permute in the rst iteration of the while loop.
an enhanced permute function for deadlock.
the full version of our permute function has memory and takes advantage of the schedules that have been submitted in all previous calls.
the idea is to use the schedules that have been submitted earlier to relax the happens before relation.
we do the relaxation by taking the union of the happensbefore relations from all those schedules.
the result is a constraint system that is more likely to be satis able and that leads us to nd more deadlocks in our benchmarks.
one nal enhancement of our permute function is based on partial order reduction.
the issue is that permute might produce a permuted trace that is semantically equivalent with the input trace and therefore must fail to lead to the deadlock candidate.
we use flanagan and godefroid s approach to partial order reduction to avoid such a situation.
our implementation uses flanagan and godefroid s approach as a checker that determines whether an input trace and the permuted trace are equivalent.
in case the input trace and the permuted trace are equivalent we repeatedly askpermute for a di erent output until we get one we want.
.
experimental results our implementation of goodlock is an extension of java pathfinder .
in our implementation events are at the java bytecode level.
we use soot to instrument bytecodes to implement execute on top of the lime concolic execution engine .
we ran all our experiments on a linux centos machine with two .
ghz xeon quad core processors and gb ram.
.
benchmarks figure lists our benchmarks which we have collected from six sources from eth zurich sor tsp hedc elevator.
from java.util oracle s jdk .
.
arraylist treeset hashset vector.
from java grande raytracer moldyn montecarlo.
from the apache software foundation derby.
from cern colt.
from dacapo avrora tomcat batic eclipse fop h2 pmd sun ow xalan.
the sizes of the benchmarks vary widely we have huge 1m loc large 20k 1m loc medium 1k 8k loc and small less than 1k loc benchmarks.
figure also lists the high watermark of how many threads each benchmark runs and the input size in bytes for each benchmark.
most of the benchmarks come with a speci c input except the four benchmarks from oracle s jdk .
.
for which we use a test harness from previous work .
each benchmark is supposed to terminate so every real deadlock is a bug.
.
deadlock detectors we compare sherlock with one static deadlock detector namely chord one hybrid deadlock detector that we call goodlock and four dynamic deadlock detectors namely deadlockfuzzer contest jcarder and java hotspot .
additionally we compare with a combined dynamic technique that we call dcjj.
chord is a static technique and by design it may report false positives its main objective is to report all real deadlocks or as many as possible .
goodlock monitors an execution computes a lock dependency relation and uses the transitive closure of this relation to suggest potential deadlocks.
deadlockfuzzer contest jcarder java hotspot and sherlock are all dynamic techniques that report only real deadlocks.
deadlockfuzzer begins with a set of deadlock candidates produced by a variant of goodlock.
for each deadlock candidate deadlockfuzzer executes the program with a random scheduler that is biased towards executing the events in the deadlock candidate.
the idea to use a random scheduler for java can be traced back to stoller .
contest uses heuristics to perturbate the schedule and thereby hopefully reach a deadlock.
one of the techniques is to insert time outs.jcarder instruments java byte code dynamically and looks for cycles in the graph of acquired locks.
the instrumented code records information about the locks at run time.
a later separate phase of jcarder post processes the recorded information to search for deadlocks.
the java hotspot virtual machine from oracle can track the use of locks and detect cyclic lock dependences.
the utility detects java platform level deadlocks including locking done from the java native interface jni the java virtual machine pro ler interface jvmpi and java virtual machine debug interface jvmdi .
we use dcjj to stand for the union of deadlockfuzzer contest jcarder and java hotspot in following sense.
we can implement dcjj as a tool that for a given benchmark starts runs of deadlockfuzzer contest jcarder and java hotspot in four separate threads and if any one of them reports a deadlock then dcjj reports a deadlock.
.
how we handle reflection many of the benchmarks use re ection and contest and java hotspot handle re ection well.
we enable the other deadlock detectors to handle re ection with the help of the tool chain tamiflex .
the core of the problem is that re ection is at odds with static analysis and bytecode instrumentation re ection may make make static analysis unsound and may load uninstrumented classes.
tamiflex solves these problems in a manner that is sound with respect to a set of recorded program runs.
if a later program run deviates from the recorded runs tamiflex issues a warning.
we have combined each of chord goodlock deadlockfuzzer and jcarder with tamiflex and we have run all our experiments without warnings.
as a result all the deadlock detectors all handle re ection correctly.
.
measurements figure shows the numbers of deadlocks found in benchmarks by techniques.
when we compare deadlocks we focus on the program points where locks are acquired.
for each benchmark and each tool the reported deadlocks turns out to be disjoint that is any two deadlocks have nonoverlapping program points.
even across tools we found no cases of partially overlapping deadlocks each pair of reported deadlocks are either identical or disjoint.
as a result we can easily compare tools.
we have manually inspected all the deadlocks reported by the dynamic tools and we believe that the deadlocks are rather unrelated.
while one can imagine that a code revision may remove multiple deadlocks we found no obvious signs of correlation between the reported deadlocks.
figure shows the time each of the runs took in minutes and seconds and it shows the geometrical mean for each technique.
we made no attempt to throttle the amount of time that the tools can use.
.
evaluation we now present our ndings based both on the measurements listed above and on additional analysis of the deadlocks that were found.
sherlock versus other dynamic techniques.
we can see in figure that sherlock nds the most deadlocks of all the dynamic techniques.
among those deadlocks deadlocks were found only by sherlock and are entirely novel to this paper while were also found by dcjj.
du name loc threads input size brief description bytes sor a successive order relaxation benchmark tsp traveling salesman problem solver hedc 30k a web crawler application kernel elevator a real time discrete event simulator arraylist arraylist from java.util treeset treeset from java.util hashset hashset from java.util vector vector from java.util raytracer measures the performance of a 3d raytracer moldyn n body code modeling dynamic montecarlo a nancial simulator using monte carlo techniques to price products derby .6m apache rdbms colt 110k open source libraries for high perf.
scienti c and technical computing avrora 140k avr microcontroller simulator tomcat 535k tomcat apache web application server batic 354k produces scalable vector graphics images based on apache batic eclipse .2m non gui eclipse ide fop 21k xsl fo to pdf converter h2 20k executes a jdbcbench like in memory benchmark pmd 81k java static analyzer sun ow 108k tool for rendering image with raytracer xalan 355k xml to html transformer total 4587k figure our benchmarks.
ally deadlocks were found only by dcjj.
in summary we have that the combination of dcjj and sherlock found deadlocks in the benchmarks.
found only by dcjj found by both found only by sherlock total let us consider the deadlocks that dcjj found but sherlock missed.
those deadlocks were in arraylist treeset vector derby tomcat eclipse pmd .
deadlockfuzzer found eleven of those and contest found the remaining four and also four of the eleven found by deadlockfuzzer .
for example deadlockfuzzer found the following deadlock in tomcat while sherlock missed it.
the deadlock happens when tomcat uses oracledatasourcefactory.
the nature of the deadlock is much like the example in section .
if we use the notation of that example then ais an object of class java.util.properties while bis an object of class java.util.logging.logger.
two threads execute synchronizedoperations on those objects in the pattern of the example in section hence they may deadlock.
the reason why deadlockfuzzer found deadlocks that sherlock missed is that deadlockfuzzer uses a random scheduler while the initial run of sherlock uses the standard scheduler.
we conclude that sherlock nds the most deadlocks and that deadlockfuzzer and contest remain worthwhile techniques that each nds deadlocks that the other dynamic techniques don t nd.
dcjj details.
the combined dynamic technique dcjj found deadlocks.
we notice that intuitively jcarder deadlockfuzzer contest in words if jcarder nds a deadlock then deadlockfuzzer or contest or both also nds that deadlock.
we also notice that if java hotspot nds a deadlock then either deadlockfuzzer or contest or both also nds that deadlock or the deadlock is one particular deadlock in elevator which sherlock nds too .
chord.
chord is one of the best static deadlock detectors yet our experiments suggest that chord produces a large number of false positives.
additionally chord missed ve real deadlocks namely one deadlock in each of elevator vector raytracer batic and xalan.
we conclude that accurate static deadlock detection remains an open problem.
timings.
the geometrical means of the execution times show that deadlockfuzzer is the fastest dynamic technique while sherlock is the slowest.
the timings for deadlockfuzzer and sherlock include the time to execute goodlock.
number of schedules.
the number of calls to execute turns out to be rather modest for every benchmark it is at most twice the number of deadlock candidates.
this shows that the combination of execute andpermute is powerful.
number of steps of execution.
this table shows the lengths of the schedules that lead to deadlocks found by sherlock including the found only by sherlock sherlock schedule length total new dcjj the schedules can be as long as million events whichstatic hybrid dynamic benchmarks chord goodlock deadlockfuzzer contest jcarder java hotspot dcjj sherlock total new dcjj sor tsp hedc elevator arraylist treeset hashset vector raytracer moldyn montecarlo derby colt avrora tomcat batic eclipse fop h2 pmd sun ow xalan total figure the numbers of deadlocks found in benchmarks by techniques.
static hybrid dynamic benchmarks chord goodlock deadlockfuzzer contest jcarder java hotspot sherlock sor tsp hedc elevator arraylist treeset hashset vector raytracer moldyn montecarlo derby colt avrora tomcat batic eclipse fop h2 pmd sun ow xalan geom.
mean figure timings in minutes and seconds.shows that the permute method scales to long schedules.
for each of seven benchmarks derby colt tomcat batic eclipse sun ow xalan at least one real deadlock happens with a schedule that has more than a million events.
among the deadlocks found after at least a million steps were found only by sherlock.
given that sherlock can reproduce every deadlock we conclude that sherlock does a much better job than previous work to nd reproducible deadlocks than the previous techniques with which we have compared.
.
limitations our approach has four main limitations.
first our current implementation of sherlock supports synchronized methods and statements but has no support for other synchronization primitives such as wait notify and notify all.
we leave support for those to future work.
second our approach relies on goodlock to produce deadlock candidates.
in case goodlock misses a deadlock so will sherlock.
note here that goodlock itself is a partly dynamic analysis that analyzes a particular execution.
if we run goodlock multiple times perhaps with di erent inputs we may in total get a larger set of deadlock candidates and miss fewer deadlocks.
third our approach relies on a constraint solver both in permute and execute .
the form of constraints that we use inpermute has a decidable satis ability problem while the form of constraints that we use in execute are derived from expressions in the program text and may be undecidable.
so for execute the power of the constraint solver is critical.
fourth our approach has no support for native code.
.
related work in section we discussed six techniques for deadlock detection namely chord goodlock deadlockfuzzer contest jcarder and java hotspot and we did a large scale experimental comparison of all six and sherlock.
the goal of this section is to highlight some other notable techniques and tools in the area of deadlock detection for unannotated programs.
run time monitoring systems.
arnold vechev and yahav presented the qvm run time environment that continuously monitors an execution and potentially detects defects including deadlocks.
huang zhang and dolby presented an e cient approach to log execution paths and then do o line computation in order to reproduce concurrency bugs such as deadlocks.
another idea is to let the operating system detect deadlocks .
all three approaches monitor executions but do nothing to drive an execution towards a deadlock.
model checking.
demartini et al.
presented a translation from java source code to promela that enables deadlock detection via the spin model checker .
the translator predates java and would require signi cant extension to handle our benchmarks.
chaki et al.
and godefroid presented model checkers for c that can nd deadlocks.
static deadlock detectors.
static deadlock detectors have a goal that is dual to our objective to nd real deadlocks they attempt to nd all deadlocks and possibly some false positives.
chord remains one of the best among the scalable static deadlock detectors for java to date hence it was our choice for experimental comparison in this paper.dynamic deadlock detectors for java.
asn rst extracts constraints from a deadlock candidate and formulates them as barriers and then uses a form of random scheduling to trigger real deadlocks with high probability.
conlock rst does an initial run and generates scheduling constraint from the trace and from a deadlock candidate and then uses a form of random scheduling that works within the limits of the generated scheduling constraints.
wolf rst does an initial run and does cycle detection then prunes away cycles that cannot be executed then generates a synchronization dependency graph and nally uses a form of scheduling based on that graph.
the papers on asn and conlock report on experiments with a single java benchmark of lines of java for which the tools found and deadlocks respectively.
they also report on experiments with larger c c benchmarks.
the paper on wolf reports on multiple benchmarks the largest of which is lines of java and for which the tool found deadlocks.
none of those tools use schedule permutation or concolic execution.
static analyses of traces.
our permute function embodies a static analysis of a trace.
researchers have presented many such analyses that might help de ne alternative permute functions.
other dynamic techniques.
penelope is a dynamic tool that detects atomicity violations.
penelope runs a program and then analyzes with an smt solver the recorded reads and writes to predict a schedule that leads to an atomicity violation.
penelope doesn t use concolic execution.
recent papers show how to detect data races in event driven and reactive programs their techniques might also be useful for deadlock detection in such programs.
dynamic deadlock detectors for other languages.
pct probabilistic concurrency testing is a concurrencybug including deadlock detector for c and c that uses a probabilistic technique to generate a thread schedule.
they found one bug in each of eight benchmarks.
their largest benchmark is thousand lines of code.
magicfuzzer is a deadlock detector for c and c that uses a variant of the technique used in deadlockfuzzer.
the novelty is that magicfuzzer can con rm multiple cycles in the same run.
for benchmarks of about million lines of code magicfuzzer found real deadlocks.
.
conclusion we have shown how to detect deadlocks by a combination of concolic execution and a novel approach to schedule permutation.
the result is a scalable and useful deadlock detector.
for a large benchmark suite our tool sherlock found deadlocks that were missed by earlier techniques.
among those deadlocks about a third namely deadlocks were found with schedules that have more than million events.
our technique can nd deadlocks after many steps of computation because the combination of concolic execution and schedule permutation helps drive an execution towards a deadlock candidate.
our experiments show that deadlockfuzzer contest and sherlock together nd a total of real deadlocks in .
million lines of code.
as far as we know this is the most comprehensive list of real deadlocks for those benchmarks that is reported in the literature.