see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation z3 str a z3 based string solver for web application analysis article august .
.
citations 169reads author s including xiang yu zhang taiyuan univ ersity of t echnolog y publica tions citations see profile vijay ganesh geor gia instit ute of t echnolog y publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y vijay ganesh on may .
the user has r equest ed enhanc ement of the do wnlo aded file.z3 str a z3 based string solver for web application analysis yunhui zheng xiangyu zhang department of computer science purdue university usa zheng16 xyzhang cs.purdue.eduvijay ganesh electrical and computer engineering university of waterloo canada vganesh uwaterloo.ca abstract analyzing web applications requires reasoning about strin gs and non strings cohesively.
existing string solvers eithe r ignore non string program behavior or support limited set of string operations.
in this paper we develop a general purpose string solver called z3 str as an extension of the z3 smt solver through its plug in interface.
z3 str treats strings as aprimitivetype thusavoidingtheinherentlimi tationsobservedinmanyexistingsolversthatencodestrings in terms of other primitives.
the logic of the plug in has three sorts namely bool int and string.
the string sorted term s include string constants and variables of arbitrary length with functions such as concatenation sub string and replace.
the int sorted terms are standard with theexceptio n of the length function over string terms.
the atomic formulas are equations over string terms and in equalities ov er integer terms.
not only does our solver have features that enable whole program symbolic static and dynamic analysis but also it performs better than other solvers in our experiments.
the application of z3 str in remote code execution detection shows that its support of a wide spectrum of string operations is key to reducing false positives.
categories and subject descriptors d. .
software program verification d. .
testing and debugging general terms verification algorithms keywords string analysis string constraint solver web applicatio n .
introduction constraint solving plays an important role in web program analysis for the purpose of test generation for coverag e permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
bug finding and vulnerability detection .
the reason is that solver based analysis tools enable more precise analysis with the ability to generate interesting b ugrevealing inputs.
furthermore solver based analysis too ls are often more robust and easier to build than otherwise.
while most powerful constraint solvers like z3 support a rich input language for traditional program analysis the y typicallydon tsupportcombinedlogicsoverstringsandno nstring operations essential for web program analysis.
in this paper we present z3 str a satisfiability solver tha t supports a rich combined logic over strings and non string operations aimed atsymbolic static anddynamicanalysis o f web applications.
z3 str is built as an extension of the powerful z3 smt solver using its plug in interface.
z3 str treats strings as a primitive type thus avoiding the inhere nt limitations observed in many existing string solvers that e ncode strings in terms of other primitives.
the supported logic has three sorts namely bool int and string.
the string sorted terms include string constants and variable s of arbitrary length with functions such as concatenation sub string and replace.
the int sorted terms are standard with the exception of the length function over string terms.
the atomic formulas are equations over string terms and in equalities over integer terms.
formulas are construc ted in the usual way through boolean combination of atomic formulas.
z3 str takes a formula in this logic as input and decides if it is satisfiable.
many string solvers such as hampi dprle and rex support only string operations.
however such logics are not sufficiently expressive for many program analysis since non string operations are also widely used in web applications.
more importantly the string and non string operations interact in subtle ways leading to program errors that are hard for humans to find without automation.
finally a string only analysis will likely miss pure integ er or string to integer constraints e.g.
length of string thus resulting in path constraints that are not precise enough leading to false positives.
manyrecentworks onstringsolvers haveaddressed exactly this problem namely how to efficiently reasonaboutstringandnon stringconstraintsgeneratedduri ng analysis of web applications.
a key feature of all these approaches to string solvers is to transform both string and non string constraints to a uniform domain.
some solvers including early versions of kaluza convert strings into bit vectors which are also used to rep resent integer constraints.
the resulting constraints can be solved using an existing smt solver.
however to convert apermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
114string into a bit vector its length has to be decided before hand as a prerequisite of the bit vector encoding.
hence current techniques have to enumerate the possible length values and then encode the string constraints based on the concrete length values.
the encoded constraints are then passedtoansmtsolver.
thisrequiresencodingrepetitivel y and querying the smt solver many times.
consequently these techniques are more suitable for dynamic analysis wherein string length values can be easily computed from concrete execution paths.
however for static analysis tec hnique such concretization based solvers may be either too inefficient or even non terminating.
the reason is that during static analysis of a program the range of lengths of a string term in the program may not be precisely knowable.
by contrast our algorithm is designed in an incremental fashion to follow the plugin interaction protocol of z3 leveraging its power of incremental solving.
given a set of string equations the algorithm systematically breaks dow n constant strings into sub strings and splits variables to s ubvariables to denote their sub structures until the breakdown is so fine grained that the variables are bounded with constant strings characters.
any implied length constrai nts are checked internally by z3 for consistency with the given input length constraints.
contributions .
our contributions include the following we develop a novel string solver that has a rich input language supporting string and non string terms and operations.
sinceitisunknownifthesatisfiabilityproblemofstring equations with length constraints in general is decidable we carefully refine the problem scope so that we can develop a sound and terminating algorithm.
our system is complete for positive equations and length.
wedohandledis equations butwehaven testablished completeness for it.
we believe the refined problem definition is sufficient for constraints generated from real world web application.
we empirically compare z3 str with other solvers and show that our solver out performs others in terms of efficiency in addition to providing a richer input language and supporting both static and dynamic analysis.
we also apply the solver in remote code execution vulnerability detection.
our experimental results show that the capability of modeling commonly usedstringoperationsis keytoreducingfalse positives.
z3 str is publically available at edu homes zheng16 str .
z3 strhasbeensuccessfullyevaluatedbytheesec fse artifact evaluation committee and found to meet expectations.
.
motiv ating example in this section we use a piece of php script as an example to demonstrate the limitations of existing solvers and motivate our approach.
the second column of the table in fig.
shows the example php script.
in lines rolecan be assigned to one of four different strings according to the value of the session variable session .
lines calculate the total cost based on the variable post submitted by the client.
and finally in lines if the cost is larger than a function notifyadmin is invoked for the user whose rolestarts with the character n .tosuccessfully invokethefunction notifyadmin theinput and session variables have to satisfy certain branch conditions at lines and where both string and nonstring constraints are involved.
more importantly the str ing condition at line is actually related to but not control de pendent on the integer conditions at lines and .
therefore we have to reason about the string and non stringparts together since they are closely correlated with each other.
assume we are interested in identifying the variable valuations that drive the execution to the statement where notifyadmin is invoked.
let us compare the ways that existing solvers handle this problem.
stp is a smt constraint solver.
it supports integer and boolean operations but does not support strings.
part of the string equivalence problem could be solved by using integer ids to denote constant strings as shown by the modification in lines and marked in green in the stp column of the table in fig.
.
however more complex string operations such as concatandsubstr are not natively supported so that we have to ignore the predicate at line .
therefore the satisfying solution got from stp states the function will be called as long as the price posted makes the total cost larger than which is imprecise.
hampi is one of the most popular open source string solvers.
itwas originally designed for detectionofsqlinj ection vulnerabilities.
itwas thenwidelyused inotherweb ap plicationanalysis .
itmodelsstringsascontext free grammars cfg and supports regular expressions.
string concatenation is modeled based on the cfg.
it can handle queries about whether a string expression is in a regular expression or a cfg.
however it does not model arithmetic and boolean operations.
more importantly hampi is path insensitive meaning that it is not able to reason about path feasibility.
thus in fig.
statements related to the arit hmetic computation as well as the path conditions which are marked in red are not supported and will be ignored.
the grammar rule at line is generated by hampi modeling the possible values of role.
consequently hampi determines that notifyadmin will always be executed.
besides hampi doesn t support direct string comparison and other string operators like indexof andsubstr .
other solvers that work exclusively in the string domain have similar limitations.
kaluza is the core of a javascript dynamic test generation framework .
it extends both stp and hampi and supports int boolean and string constraints generated fro m an execution path.
kaluza leverages hampi s frontend to model strings as bit vectors so they can be reasoned uniformly with other types of constraints in stp.
however a pre requesite is that the lengths of bit vectors have to be known before hand.
hence before solving the string values kaluza first tries to find a satisfying solution to string lengths.
then it encodes string constraints based on the concrete length values.
however string lengths vary from path to path and sometimes may be unknown in the static analysis context.
for example in fig.
the length of role can change in different paths.
hence multiple paths cannot be encoded.
to use kaluza one has to have a path exploration engine and perform per path encoding.
even given a path if there are multiple satisfying solutions of length constraints the solver has to enumerate individual concre te solutions and encode separately.
this suggests that the stp solver needs to be frequently queried inducing high cost.
php script stp hampi kaluza pisa g session g session g session g session g session if g if g if g if g if g if g if g if g if g if g role visitor role id 1 role visitor role visitor else else else else else role new role id 2 role new role new else else else else else if g if g if g if g if g role admin role id 3 role admin role admin else else else else else role session role id var role session role session role visitor new admin session p post p post p post p post p post total taxrate p total taxrate p total taxrate p total taxrate p total taxrate p total total ship total total ship total total ship total total ship total total ship if total if total if total if total if total if substr role n if substr role n if substr role n if substr role n if substr role n notifyadmin notifyadmin notifyadmin notifyadmin notifyadmin not supported modification needed have to explore concrete paths one by one figure existing solver comparison.
... if substr x abc if ... else ... figure example for search space elimination furthermore building the string solver outside the underlying smt solver prevents the smt solver from pruning search space by leveraging the string solving results.
consider the example in fig.
.
assume the string comparison at line is unsat.
with the separated design the comparison is invisible to the path exploration engine so that the engine has to explore both branches and the paths inside the branches.
if the string solver is built inside the smt solver like in our proposed design the smt solver can easily avoid exploring the paths involving the true branch.
a few recent solvers work in a way very similar to kaluza and thus have the same limitations.
they are mostly used in the context of dynamic test generation or symbolic executioninwhichindividualpathsareexplored andcanno t be directly applied in static analysis.
some of them do not support certain important operations.
for example kaluza has very limited support of replace demanding hints from concrete execution traces.
pisa is thefirst path andindex sensitivestringsolve r that is applicable for static analysis.
it s a part of a commercial tool and the source is not publically available.
it supports int boolean and string operations by translating them all into a third party language m2l str .
however its expressiveness for arithmetic operations is restricte d due to the limitations of m2l.
it does not support binary operations between two variables since pisa requires at least one of them is constant.
therefore the statements in lines are not supported and the predicate at line may not be correctly modeled.
as a result the reachability anal ysis is incomplete.
furthermore it doesn t support numeri c multiplications and divisions.
from the above discussion we make two observations.
first reasoning about both strings and non strings simultaneously is needed.
second existing techniques aiming at solving string and no string constraints together fall sho rt as they rely on other theories e.g bit vector or languages e .g.
m2l inheriting their limitations.
hence we aim todevelo p an independent more general and more capable string theory inside an existing smt solver.
.
design of z3 str solver string theory plug in new inference consistenc y check assignment new axiom z3 con gruence closure core sat solver theory solvers arithmetic ... constraints sat a possible model unsat figure architecture overview in this section we present the details of z3 str.
a key choice in the design is to support strings as a primitive type so that we do not need to convert them to other representations such as bit vectors.
this avoids determining stri ng lengths before the solving process which can be very difficult through static analysis.
more importantly it allows us to support unbounded string variables and related operations that otherwise cannot always be supported if lengths havetobedeterminedapriori.
furthermore buildingz3 st r using z3 s plugin api also has the advantage of leveraging the state of the art capabilities of z3.
at the beginning of this section we briefly introduce the z3 smt solver especially how it interacts with a theory plug in.
then we describe the details of z3 str.
.
z3 smt solver and its plug in api z3 is an smt solver developed bymicrosoft research.
input constraints are provided to z3 as a boolean combination of atomic formulas where these atomic formulas are defined over theories supported by z3 such as integer and real arithmetic bit vectors arrays and functions.
the ar chitecture of z3 is shown in fig.
.
it is mainly composed of the following modules the congruence closure engine a sat solver based dpll t layer and several default theory solvers or plug ins solvers specialized in solving the satisfiability problem of theories such as integer linear arith metic bit vectors etc.
.
the congruence closure engine is a key module of z3.
briefly it detects if functional terms are equivalent and if so maintains them in appropriate equivalence classes.
the sat based dpll t layer is responsible for handling the boolean structure of the input formula.
for example it may assert conjunction of theory formulas to the respective solvers and backtrack if its assertions to t he theory solver are unsatisfiable.
the z3 solver works roughly as follows the core congruence closure and dpll t layer traverses the boolean116 t t t s0 s1 t t t add t f t t t f t s2 s3s4s5 state fac ts axiom try backtrack interaction with string plugin .add t f t t t s6 figure example of string solving structure of the input formula and asserts a conjunction of literals or facts atomic formulas or their negation to the appropriate theory plug insbased on the type tof the terms used in the literals.
the theory plug in derives new facts in domaintfrom the asserted facts and conveys them back to the core as new axioms.
any equivalence between the terms in the newly derived axioms and existing terms is detected by the congruence closure engine and appropriate equalities are derived.
if the derived equalities and disequaliti es are over shared variables i.e.
shared by multiple theory plug ins then the core asserts them to all such plug ins.
the core detects if the input formula and derived facts are unsatisfiable under the current assignment.
if so it backtracks.
this process repeats until a satisfying assignment is produced or the input formula is deemed unsatisfiable.
.
string solving procedure overview next we will use an example to explain how z3 str works.
consider the string constraint on the right of fig.
.
since the core cannot interpret the string operations it treats them as four independent boolean variables e1 e2 e3and e4 and tries to assign values to them.
initially state s0 there is no fact or axiom.
the core starts by setting e1and e4totrueand reaches state s2.
then assume the core tries truefore2before assigning e3at state s3.
recall that the core can detect functionally equivalent terms i.e.
based on the theory of uninterpreted functions .
hence from the facts e1 true e2 trueande4 true the core puts x y concat abc m andconcat efg n into one equivalence class and notifies the plug in.
the plug in thus knows the two concats above are equivalent.
however from the semantics of concatenation these two concats cannot equal to each other under any circumstances because they do not share a same prefix.
the plug in informs the core about the new finding through an axiom e1 e2 e4 .
withthenewaxiomandtheexistingfacts thecoredetectsa conflict on e4 in the boolean domain .
the core backtracks to states2and tries the other option for e2.
note that when the core backtracks it discards the recent fact and any insertions into equivalence classes as the consequence of the fact.
then the core assigns truetoe3so that abcd will be put in the same equivalence class as concat abc m .
again based on the concatenation semantics the value of string variable mcan be inferred by the string theory plugin which must be d .
this new finding is formulated by introducing a new variable e5 in an axiom concat abc m abcd e5 which is sent back to the core.
the new state iss6in the figure.
from the existing facts and the new axiom the core derives e5istrue.
at state s6 all boolean expressions have been assigned and the assignments are consistent.
besides the satisfyin gterm bool var bool true false contains term string term string term int var int number term int term int length term string indexof term string term string term string var string conststring concat term string term string substring term string term int term int replace term string term string term string expr bool term bool term bool term bool term int term int term string term string not expr bool expr bool expr bool expr bool expr bool if expr bool then expr bool else expr bool expr bool implies expr bool assertion assert expr bool figure constraint syntax values of string variables x yandmcan be retrieved from their equivalence classes.
so a set of consistent and satis fying solutions for the input constraint has been found and the search procedure terminates.
.
constraint syntax the constraint syntax is presented in fig.
.
for simplicity we only list three primitive types int bool andstring1.
our plug in supports the following string operations string equation concatenation length substring contains indexof replaceandsplit2.
.
supporting string operations in this section we will explain how the string operations are supported.
we first discuss three primitive operations string equation concatenation andstring length .
then we will explain how to reduce other string operations to an equivalent formula based on these primitives.
z3 core can directly model the equivalence relation between object s i.e.
variables and constants by putting them into the same equivalence class.
hence our overall strategy is to reduce various string operations to simple equivalence relations .
the z3 str algorithm is incremental driven by the try andbacktrack procedure of the z3 core.
.
.
string concatenation string concatenation is a very commonly used operation.
it is also a primitive operation in z3 str.
the plug in is notified by the z3 core when a string equation is asserted as part of the try and backtrack process.
in particular th e core invokesacall backfunctionintheplug in providingt he abstract syntax tree ast of the equation as a parameter.
the call back function inspects the ast if it involves strin g concatenations the function tries to perform ast transfor mation to reduce the ast to a new one that is simpler and easier to resolve.
the reduction is conveyed to the core by adding an axiom with the form of ast ast withastandast the original and the transformed syntax trees respectivel y. recall that since the core does not understand the string domain it treats both astandast independent bool variables.
as asthas been assigned a true value with the new axiom the core will assign a true value to ast 1z3 supports more primitive types 2splitisnotpresentedinthesyntaxduetoitsspecialformat.117definitions y compoundstring s compoundstring x compoundstring x var string s conststring split compoundstring p compoundstring compoundstring expr bool auxiliary functions split y recsplit nil y recsplit yl s yr uniontext sh st s an bracketle tyl sh st yr true an bracketri ht uniontextrecsplit yl s yr recsplit yl x yr yl x1 x2 yr x1 x2 x uniontextrecsplit yl x yr recsplit yl nil len s y s len y len x y length x len y len nil figure definitions for algorithm and table which is a new fact triggering further plug in processing.
the reduction continues until the simple equivalent form of expressions e.g.
x y withya constant string or a compound string composed of constants and variables are reached.
the dependences of these simple expressions are then constructed so that the plug in can try assigning values to free variables i.e.
variables do not depend on others if any to produce a satisfying solution.
algorithm concatenation reduction algorithm callback y1 y2 reduce y1 y2 foran object y y1 y2 s equivalence class do reduce y1 y reduce y2 y ify1 y2is of the form x sthen foranyyinvolving xin existing eq classes do reduce y algorithm.
the high level concatenation reduction process is presented in algorithm .
upon the core assigning true to a string equation of two compound strings i.e.
concatenations of constants and variables as defined in fig.
function callback in z3 str is invoked.
the core idea behind the concatenation reduction given in algorithm is to derive new equations between the sub strings on two sides of the equation and over all terms equivalent to these substrings recall that z3 s core maintains equivalence class es of terms .
for instance assume a string variable xhas its equivalence class x a x1 .
if a new equation x ab is asserted to the plug in we can use the concatenation reduction algorithm to derive x1 b from this new fact and the equivalence class.
furthermore if the new equation is of the form x swithsa constant string in lines the algorithm traverses all the expressions in existing equ ivalence classes that involve xand replaces xwiths which may trigger further reduction.
reduction rules.
the first four rules in table are concatenation reduction with relevant definitions in fig.
.
in table the second column shows the transformation and the thirdcolumn is the condition ofthe reduction.
notethat thetransformation ruleisintheformof origformula new formula which is essentially the axiom we add to the z3 core.
for easier presentation we flatten an ast to a compound string that is a flat concatenation of constants and variables.
note that during flattening all the consecutive constantstringsareconcatenatedtoalongerconstantstri ng.
rule head const rmv removes theleft most common constant substring of the left hand side lhs and the right hand side rhs of an equation.
note that we assume the rhshas the longer constant stringwithout losing generality.
ifthelhsand therhsdonotshare acommon prefix an axiom origformula is added causing backtrack.
rule tail const rmv is similar.
after applying the constant removal rules we get to a point that either the lhs or the rhs starts with a variable.
rule split allows further reduction for such expressions.
without losing generality assume the lhs is of the form x1 y1 in which x1is a variable and y1a compound string.
the rule divides the rhs compound string y2to two substrings yhandyt by calling function split and asserts x1 yhandy1 yt.
the split function may also generate a new constraint cthat denotes the side effect of splitting.
the condition is conjoined with the two assertions.
note that there are many ways of splitting y2.
hence thesplit function returns a set of splittings which are associated with operator.
the operation is similar to a boolean orbut it requires only one option can be true.
for example x y trueimplies either x true y flaseor x false y true.
the details of function split y is shown in fig.
.
it is a recursive process by function recsplit yl yr which returns the set of possible splittings.
particularly it sp lits the leading literal of yrat a time and moves it to the end ofyl.
hence the process starts with yl nil yr y and terminates with yl y yr nil.
if the literal is a constant s it creates multiple splittings that split at different positions in s. ifthe literal is a variable x it creates one splitting which is to split xtox1andx2withx1and x2fresh variables.
the correlation of variables is asserted in the splitting condition which will be part of the reduced equation i.e.
cin rule split .
consider a compound string ab x. the generated splits are ab x true a b x true ab x true ab x1 x2 x1 x2 x .
an important observation of the split rule is that the individual options of the operator in the transformed formula are simpler than the original formula .
this guarantees monotonicity in reducing the original formula.
note that these simpler options will be explored and further reduced byz3 str separately.
however we also addnew constraint c to the system during splitting which may raise the concern of termination.
we will further discuss this issue in sec.
.
.
rule concretize replaces a variable xiny1 x y2with a constant string when they become equivalent.
note that in order to ensure the inserted formula is an axiom we have to conjoin x swith the original expression.
simple equations.
when no more reduction can be conducted if each equivalence class has a constant the solving process terminates with a sat solution.
otherwise the plug in builds a dependence graph of variables involved in simple equations which are equations in the form of x y and the equivalence class of xhas no more than one nonsingleton compound string terms i.e.
not a constant or a variable .
for example in x y xdepends on all vari 118table reduction rules rule reduction condition head const rmv s1 x1 y1 s2 y2 x1 y1 s3 y2 ifs1 s3 s2 s1 x1 y1 s2 y2 s1 x1 y1 s2 y2 if s1is not a prefix of s2 tail const rmv y1 x1 s1 y2 s2 y1 x1 y2 s3 ifs3 s1 s2 y1 x1 s1 y2 s2 y1 x1 s1 y2 s2 if s1is not a suffix of s2 split x1 y1 y2 angbracketleftyh yt c angbracketright split y2 x1 yh y1 yt c concretize x s y1 x y2 y1 s y2 ifx s stringlen y1 y2 len y1 len y2 free var context x x x ... x a free variable ables inside y. note that complex formulas will cause reduction andgenerate simple formulas.
from the dependence graph we identify free variables i.e.
variables that do no t depend on others and do not have constants in their equivalence class.
we then assign concrete values to free variable s by adding new axioms.
such assignments will be explained when we discuss the string length operation.
example.
consider the following constraint composed of three clauses with x y andzstring variables.
z x y z a w x d abd the solving process is presented in table .
the second column shows the fact assignment from the core the third column shows the corresponding equivalence class th e fourth column shows the reduction action.
in step the new fact does not trigger any reduction.
in step the two compound strings in the equivalence class of zcauses reduction by rule split .
in step the axiom added in step causes the fact x ab .
in steps and the core tries to explore the and options in the axiom added in step but detects conflicts.
it then explores the option in step .
in step no more reduction can be performed z3 str hence looks at variable dependences and identifies that w2 is a free variable.
note that in the current context we have y w2andw1 w2 wfrom the option.
assigning an empty string to w2produces a sat solution.
.
.
.
string length string length is another important primitive operation as other operations can be reduced to it.
since the z3 core does not understand the semantics of the operation it simply treats it as an integer variable.
z3 str hence needs to ensure the correlation between the length variable and the correspondingstring.
thebasicdesignistogeneratetheco rresponding length constraints in the integer domain when the plug in is invoked by the core upon new facts in the string domain.
if the new length constraints cause any conflict in the integer domain the core will backtrack and try a different solution in the string domain.
rule stringlen describes how z3 str generates length constraint upon a new fact y1 y2.
it calls function len defined in fig.
to translate the two compound strings to integer expressions and asserts their equivalence.
it tran slates a constant string to its length and introduces a length variable length x for a string variable x. example.
consider the following three clauses.
x1 a x2 x1 efg x2 x1 e length x2 suppose the core first assigns truetox1 a .
this fact allows z3 str to add the axiom x1 a length x1 .
now assume the core tries the first option of the second clause.
z3 str adds the axiom x2 x1 efg length x2 length x1 .
it causes a conflict with the third clause in the integer domain.
the core then turns to the second option and finds the sat solution.
in the previous discussion of concatenation rules we mention that we can assign any value to a free variable.
however a free variable xin the string domain may be constrained by length assertions in the integer domain on the variable itself or on other variables that are dependent on x. since length constraints do not constrain string values but rathe r their length we introduce a free variable rule free var to allow the core to try to assign predefined constant strings of various lengths to a free variable in order to satisfy leng th constraints.
according to the rule if the plug in detects that a string variable xis a free variable in the current context it adds an axiom which states that the current context implies that xmay have constant strings of various lengths.
the context is the conjunction of all the facts set by the core upto this point.
we have to use the context as the antecedent as xmay not be a free variable in a different context.
any conflicts by length constraints will cause the core to try a constant string of different length.
consider the example in the previous section .
if we have an additional clause length z the assignment of w2 will be unsat the core will further try to assign w2 which generates a sat solution.
.
.
other operations the concatenation and length operations are supported by performing incremental reduction and adding new axioms gradually driven by the try and backtrack process.
the other operations are supported in a different way.
we perform pre processing to translate them to formulas using concatenation and length operations.
substring.
thesubstringoperator substring x i j takes three arguments.
it returns a substring of xstarting at positioni and its length is j. the substring operator can be reduced to a formula with concatenation and string length operations.
particularly as shown by rule substring since the return string is a part of the first argument we break the first argument into three pieces x1 x2andx3 and assert the middle piece x2equals to the return string.
we assert the lengths of x1andx2to respect the position and length constraints.
contains.
the string membership operator contains x1 x2 takes two parameters and checks whether x2is a substring of x1.
according to rule contains we break x2 into three pieces xp x2andxs.
note that the middle piece isx2.
the negation of contains is more challenging as it is essentially an operation with universal quantifier.
our method is to generate solutions for x1andx2as if the constraint did not exist and use post processing to check if x2 is contained in x1.
if so we force the core to backtrack.
indexof.
the operation indexof x1 x2 returns the starting position of substring x2inx1.
ifx2is not a substring of x1 it returns .
as shown by rule indexof we break x1into three pieces xs1 xs2andxs3.
the result value ihas119table example for concatenation reduction step fact eq class reduction action 1z x y z x y 2z a w z x y a w x y a w x y a w x a y w x a w1 y w2 w1 w2 w 3x d abd x d abd x d abd x ab x ab x ab ... conflict between x ab andx backtrack ... conflict between x ab andx a backtrack x ab a w1 ab a w1 w1 b identify w2as the free variable based on dependences z y w2andw w2 assign w2 sat solution w2 y x z ab w1 b table preprocessing rules for other operations rule new formula substring substring x i j xt x x1 x2 x3 x2 xt length x1 i length x2 j contains contains x1 x2 x1 xp x2 xs indexof indexof x1 x2 i x1 xs1 xs2 xs3 i i greaterorequalslant0 i contains x1 x2 i greaterorequalslant0 i length xs1 xs2 x2 contains xs1 x2 replace replace x1 x2 x3 xt x1 xs1 xs2 xs3 i indexof x1 x2 if i greaterorequalslant0 thenxt xs1 x3 xs3 length xs1 i elsext x1 split split x1 x2 x1 xt1 x2 xt2 contains xt1 x2 contains xt2 x2 two options if and only if x1doesn t contain x2 iis .
otherwise if and only if xs2equals to x2 its predecessor xs1doesn t contain x2 andtequals to the length of xs1.
replace.
the transformation is shown in rule replace .
in the rule we assume only one substring is replaced.
it can be easily extended to support cases in which less than nreplacements occur with na pre defined constant.
split.we support splitin a similar way to that of replace.
in the rule we assume only one substring matches the patternx2.
it can be extended to support cases with less than noccurrences.
.
an improved algorithm for a restricted theory of strings unfortunately it is unknown if the satisfiability problem of string constraints with length operations is decidable i n general .
this has a bearing on our algorithm in that it may not terminate for certain cases stuck in infinite splitting.
to avoid such non termination we restrict the th eory in certain ways as described below.
for this restricted theory the satisfiability problem becomes decidable and ou r algorithm is one such decision procedure.
tobetterillustratetheproblem observeinrule split while we are simplifying the original equation we may introduce new ones denoted by c which may cause further splitting.
in some cases the splitting becomes infinite.
x b a x ... ex i x a x1 x2 b x x1 x2 ... consider the above example which shows part of the reduction of a string equation with the same variable appears as the prefix of lhs and the suffix of rhs.
the equation is not satisfiable.
however according to our reduction rule split one of the options as shown induces new equivalence between therhs s of and .
observethat the new equation has a very similar form as the original one.
hence the exploration and reduction will not terminate i.e.
x1in will be further splitted .
x y1 y2 y y y3 y4 x ex ii such non termination could also occur in equations that involve multiple variables.
assume the above two clauses.part of their reductions are shown as below.
in the first reduction yis splitted and in the second reduction xis splitted.
observe that the equivalence between rhs of and rhs of and the equivalence between rhs of and rhs form a recursion of the form of the original two clauses causing infinite reduction.
... x y2 y1 y1 y2 y y1 y2 ... ... y y4 x1 y3 x2 x x1 x2 ... the root cause of non termination is that the splitting of a variable directly or indirectly causes further splitting of the same variable.
in ex i the splitting of xintroduces new equivalence such that a subpart of it x1 sets out to be splitted.
however we observe that such cases rarely happen in the constraints generated from web applications.
therefore we define a sub class of the problem that is decidable and leads to an algorithm that ensures termination.
the refined problem.
we capture the essence of the non termination issue using a graphical representation of equation in fig.
.
such graphical representation was introduced in various studies of string theories .
a solid horizontal segmentrepresents avariable oraconstantstri ng.
we call it the projection of the variable or string.
a compound string consisting of a sequence of variables and constant strings is denoted as a sequence of segments that are slightly misaligned vertically for better visibility.
the equivalent compound strings e.g.
the lhs and rhs of an equation are projected to the same graph.
the vertical dotted linesrepresenttheboundariesofsegmentsandthealignmen t across strings.
notethatthepositionsoftheboundariesma y vary for different solutions.
for example fig.
a shows the graphical representation of example ex i. fig.
b shows a simplified one for ex ii.
it is the union of the two projections regarding equation and by unifying the two y s in and and omitting some compound strings for readability.
a split corresponds to that the end of a variable segment falls in the middle of another variable segment.
we call it a cut.
definition .we say a varaible xcutsy denoted as x y if there is a reduction from x y1 y2 y y3to x y2 y1 y1 y2 y3 y y1 y2 .120x x a b x yy1 xy4 a b x yy1 xy4 c figure subgraphs a and b show the graphical represent ation of ex i and ex ii c shows a well formed solution of ex ii.
hence in fig.
a the top x in the lhs of the original equation cuts the bottom x in the rhs .
in b the top x cutsyandycuts the bottom x. we observe that non termination is caused by cases in which the projections from the same variable overlap but not completely coincide .
the shaded regions in fig.
represent the overlapping regions.
as such a cut of a segment will have its projection in other segments of the same variable.
these projections mayfurthercuttheoriginal segmen t due to the overlap resulting in infinitecutting.
in fig.
a the cut at circlecopyrton the bottom xhas its projection at circlecopyrton the topxand this projection cuts the bottom xagain.
figure b is similar.
note that overlapping of multiple projections of the same variable implies recursive self constraining of the same va riable.for instance in fig.
a it implies the prefix and suffix of xare mutually constrained.
based on our observation such self constraining is very rare in the program analysis context.
hence we preclude such cases in order to devise a better algorithm that guarantees termination.
the formal definitions regarding the refined problem are presented as follows.
definition .given a solution of a set of string constraints and a variable x the projection of the solution regardingxuses the segment of xas the base and projects all the other variables that overlap with xin some constraint according to the solution.
fig.
b and c are sample solution projections regardingyforex ii.
definition .we say a solution is well formed if and only if in the projection regarding any variable there is no t a variable xwhose multiple projections overlap.
fig.
c is a well formed solution but b is not as the x segments overlap.
given the definitions the problem is refined to finding well formed solutions of a set of string constraints .
the revised algorithm.
we revise the previous algorithm.
the revision mainly lies in the split function.
we introduce a few new definitions.
mapping varidentifies the original string variable of an intermediate variable .
fo r example in ex i var x1 x. we also annotate each intermediate variable xwith the variable ythat cuts var x and induces the generation of x. note that xyimplies that x is a suffix of yaccording to the definition of a cut.
initially we annotate all string variables with themselves.
we revise the recursive split function particularly the part that splits a variable.
the function is invoked with the variable xzthat causes the split.
for instance given an equation xz y1 y2 recsplit xz nil y is called to start splitting.
if it is to split a variable yin the rhs.
it checks if z var y to avoid self splitting.
note that sincex var x for any original variable x we triviallyprevent direct self splitting.
if the cut is admissable th e splitted variable y1inherits the annotation zandy2retains theannotation of y. ifthe cutis not admissable thevariable is not splitted.
example.
lets revisit ex ii.
we annotate the original clauses initially as follows.
xx y1 y2 yy yy y3 y4 xx part of the reduction of is as follows.
... xx y2 yx y1 yy yy yx yy ... part of the reduction of is the following.
... yy y4 xy y3 xx xx xy xx ... from and we have yx yy y4 xy .
however yx will not cause splitting of xy 1asvar x1 x which is the annotation of y1.
hence the search will focus on splitting y4 which corresponds to the well formed solution as shown in fig.
c .
.
ev aluation ourevaluationconsistsoftwoexperiments.
inthefirstexperiment wecomparetheperformanceofz3 strwithkaluza which only supports encoding a single path.
in the second experiment we compare z3 str with our prior work on a solver that integrates hampi and stp and supports encoding multiple paths in terms of both efficiency and effectiveness.
we choose to compare with these two solvers as they can solve string and non string constraints togethe r. all experiments are run on an intel core i5 2520m machine with 8gb memory.
.
comparison with kaluza we use the test cases shipped with the kaluza package to compare performance.
since we currently do not support regular expressions we remove the constraints relate d to regular expressions which account for a small percentag e of all the constraints.
then we run both solvers times for each test case and take average of the execution time.
the results are presented in table .
we can see z3 str is faster than kaluza in out of cases.
we also observed solutions provided by kaluza are partially incorrect.
in th e last case kaluza outperfoms z3 str.
this case has a large set of simple string constraints that are easy to satisfy.
we observed a lot of backtrackings due to string length inconsistencies in z3 str for this case.
further analysis shows t hat because the version of z3 we use does not allow us to acquire the concrete values assigned to length variables in th e integer domain during the solving process we cannot leverage the values explicitly to optimize splitting.
although t he infeasible splittings are immediately rejected by the inte ger121definitions var x the original string variable of a temporary variable w hich is generated by splitting each variable xis annotated with a variable yto denote xwas generated by ycuttingvar x .
initially we annotate xwithxitself.
auxiliary functions recsplit xz yl s yr uniontext sh st s an bracketle tyl sh st yr true an bracketri ht uniontextrecsplit xz yl s yr recsplit xz yl yw yr braceleftbigg yl yz yw yr yz yw yw uniontextrecsplit xz yl yw yr z!
var y yl yw yr true uniontextrecsplit xz yl yw yr otherwise recsplit xz yl nil figure new definitions and split function.
theory z3 str has to pay the cost of unnecessary splitting and backtracking.
in contrast kaluza first acquires the con crete length values and then performs encoding.
because these constraints are simple kaluza does not need to enumerate multiple solutions for string lengths.
z3 is recentl y open sourced.
we are looking into if z3 str can communicate with the integer theory better to improve performance.
we also want to point out again that z3 str is more general in one respect than kaluza as z3 str does support encoding multiple program paths while kaluza does not.
table comparison with kaluza stats correct?
time s varcstrkz k zk z bettermatch1 check check0.
.
.9x bettermatch2 check check0.
.
.7x concat check0.
.
.2x idxof check0.
.
.4x indexof check check0.
.
.7x match check0.
.
.8x replace check check0.
.
.2x search check check0.
.
.5x split check0.
.
.3x streq check check0.
.
.3x substr check0.
.
.3x substridxof check0.
.
.4x big1 check check0.
.
.6x big2 check check0.
.
.4x average .2x regular expression constraint removed.
.
comparison with our prior work in our prior work in detecting remote code execution vulnerabilities which allow malicious php code to be injected and executed we developed a solver that supports encoding multiple program paths for static analysis.
it com bines stp and hampi in an alternative and iterative ai fashion.
it uses stp to generate sets of feasible paths without considering string behavior.
it then uses hampi to encode string behavior along those paths.
solving the strin g constraints determines the true path feasibility.
we use th e same set of benchmarks to compare the performance.
the two solvers are provided the same set of constraints.
each constraint encodes an entire program after using a static slicer to prune irrelevant parts .
the results are listed in table .
we use ai solver to denote the prior solver.
the data suggest that z3 str performs much better.
this is because inai solver infeasible paths caused by string constraints cannot be detected by stp and have to encoded and passed on to hampi todetermine their true feasibility whereas z3 can leverage the interal results from z3 str toavoid them en tirely.
the frequent queries to stp and hampi also cause overhead in process starting and finishing.
eliminating false positives in .
next we will show that z3 str allows us to remove all the false positives fp i ntable comparison with ai solving stats ai solver z3 str ai solver application varcstriteration real s real s z3 str aidicms v3.
.
.
.4x phpmyfaq v2.
.
.
.
.3x zingiri webshop v2.
.
.
.
.7x phpmyadmin v3.
.
.
.
.8x phpldapadmin v1.
.
.
.
.
.6x phpscheduleit v1.
.
.
.
.9x freewebshop v2.
.
r2 .
.
.5x ignition v1.
.
.
.3x monalbum v0.
.
.
.
.6x webportal v0.
.
.
.
.6x fws adminedit.php name explode .
get if post write changes if name txt name sql if name txt ... fp fopen get w fwrite fp post else ... figure fp type in zingiri webshop the prior work as z3 str supports the commonly used string operations while the prior solver does not.
in web applications clients often can upload files or save user input in a server side file.
sometimes the file name can be provided by the client too.
if arbitrary user input can be saved in a user specified file ending with .php a rce vulnerability is introduced since the client may inject and execute arbitrary php code by writing and manipulating that file.
many web applications have proper protection by having checks on file names before file writes.
the reason for the fps we had before is because we cannot model the file name checking logic due to the string operators used.
two of the fps have file name checking similar to that in fig.
.
function explode is used to separate a string to substrings.
previously due to the lack of support of split we cannot model the function and have to use free variables to denote name.
as a result its relation with get is missed.
therefore the assertions of get being ended with .php and the reachability conditions at line are sat.
with z3 str we can modelexplode precisely with splitand correctly determine that writing to .php file is infeasible.
the remaining four fps are similar to fig.
in which getfileext cannot be properly modeled.
with z3 str the function can be modeled using substring andindexof .
hence we can correctly decide that the file write at line is not reachable when the file name extension is .php .
.
related work there is a vast literature on the problem of solving equations of all manner through unification and term rewriting .
schulz uses a combination of tehcniques from122 modul tinymce plugins ajaxfilemanager ajax save te xt.php path not important .
post if getfileext post php ... else if file exists path ... else fp fopen path w fwrite fp post figure fp type in adidcms string unificationandmakanin salgorithmstosolvethepr oblemofterminatingminimalandcompletewordunification .
based on the underlining representation existing string analysescanberoughlycategorizedintotwokinds automat abased and bit vector based .
we have made comparison with a number of these existing works in sections and .
hence in this section we focus on the other works.
automata regular expressions are a natural form to represent strings so that many works are based on them.
java string analyzer jsa applies static analysis to model flow graphs of java programs.
these graphs capture dependencies among string variables.
finite automata can be computed from the graphs to reflect possible string values.
shannon et al.
used finite state machines fsms to model strings.
string computation is modeled by fsm refinement.
they have ad hoc rules for integer relations but do not support integer constraints in general.
hooimeijer and weimer designed an heuristics based approach to find a sat solution.
they search lazily to avoid building full automata.
as a result the performance is improved greatly compared to their previous work .
rex uses symbolic automata where labels are represented by predicates.
it uses symbolic language acceptor and explore s various optimizations of symbolic automata like minimiza tion to leverage the underlying smt solver and eliminate inconsistencies.
also the trade offs between the language acceptor based encoding and automata specific algorithms are discussed .
symbolic automata are implemented in the symbolic automata library .
stranger develope d by yu et al.
analyzes strings for php based on automata.
viewpoints uses dfa to model client and server side input validation functions.
the inconsistency between val idation functions can be found by comparing their dfas.
surveyed a large set of existing string solvers and compared them using a table.
usingautomata fsm regular expressions allows theabove techniques nicely support infinite strings and regular expr ession related operations.
however many of them have difficulties in handling string constraints related to integers like lengthandsubstring with variable indices .
more importantly manyof them donot provide nativesupport for other types of constraints such as integer which is needed in reasoning about both string and non string behavior together.
in string automata are extended with arithmetic automata to support integers and length constraints in addition to string constraints.
prefix suffix operations and presburger arithmetic constraints on integer variables i .e.
linear arithmetic constraints boolean connectives quan tification are also supported.
incomparison z3 stris bas ed on term rewriting and leverages z3 which may allow better scalability and support a richer set of theories.
thestepsystem had a different rewriting style string solver.
it was complete for a specific fragment of strings called queues whereaconcatenationisrestrictedtohav ing at most one variable.
it can solve equations and inequalitie s.it also used extensions for general concatenation length a nd reverse.
z3 str supports multiple variables.
bj rner et al.
proposed a string constraint solving technique to reason about feasibility of a concrete execution path.
it works in a way similar to kaluza encoding strings into bit vectors.
hence it needs to enumerate concrete length values.
it supports common integer related stringoperationsexpect replace.
regularexpressionsarenot supported.
redelinghuys et al.
developed a constraint solving engine that can handle multiple types of constraint s for java pathfinder.
it first ignores string constraints and gets a satisfiable solution for numeric and boolean variable s. these concrete values are then used to encode string constraints to bit vectors with fixed lengths .
if the string p art is unsat it tries a different sat solution from the nonstring domains.
they can handle many operators.
they have limited support for replace requiring the result and arguments must be concrete.
they do not handle regular expressions.
as discussed in section the above technique s have similar limitations as kaluza as they only allow encoding one path and hence not ideal for static analysis.
the path exploration engine can hardly leverage the string solv ing results to prune search space see fig.
.
there have been a lot of theoretical research in general string theory .
some proposed algorithms to solve string equations.
however these algorithms usually do not consider important string operations such as length.
z3 str shares some similarity to in splitting variable s. in contrast we refined the problem scope to make the problem decidableandyetsufficientfor webprogram analysis andthe algorithm is incremental driven by the try and backtrack procedure of z3.
.
conclusion we develop a general purpose string solver z3 str as an extension of z3.
z3 str treats strings as a primitive type avoiding the inherent limitations observed in many existin g solvers that encode strings in terms of other primitives.
it supports string constants and variables of arbitrary lengt h and commonly used string operations.
it allows encoding single or multiple program paths such that it can be used in both dynamic and static analysis.
the underlying algorithm based on constant string and variable splitting is sound and guarantees termination for a restricted theory that is sufficient in practice.
our system is complete for positive equations and length.
we do handle dis equations but we haven t established completeness for it.
our experiments show that z3 str outperforms other state of the ar t solvers and its support of various string operations allows us to eliminate all false positives in remote code execution vulnerability detection.
.