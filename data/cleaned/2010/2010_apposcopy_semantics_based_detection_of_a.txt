apposcopy semantics based detection of android malware through static analysis yu feng university of texas at austin usa yufeng cs.utexas.edusaswat anand stanford university usa saswat cs.stanford.eduisil dillig university of texas at austin usa isil cs.utexas.edu alex aiken stanford university usa aiken cs.stanford.edu abstract we present apposcopy a new semantics based approach for identifying a prevalent class of android malware that steals privateuserinformation.
apposcopyincorporates i ahighlevel language for specifying signatures that describe semantic characteristics of malware families and ii a static analysis for deciding if a given application matches a malware signature.
the signature matching algorithm of apposcopy uses a combination of static taint analysis and a new form of program representation called inter component call graph to efficiently detect android applications that have certain control and data flow properties.
we have evaluated apposcopy on a corpus of real world android applications and show that it can effectively and reliably pinpoint malicious applications that belong to certain malware families.
categories and subject descriptors d. .
security and protection general terms security verification keywords android inter component call graph taint analysis .
introduction as the most popular mobile operating system the android platform is a growing target for mobile malware .
today many of the malicious applications that afflict android users exploit the private and monetized information this work was sponsored by the air force research laboratory under agreement number fa8750 permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.stored in a user s smartphone.
according to a recent report nearly half of android malware are multi functional trojans that steal personal data stored on the user s phone.
in response to the rapid dissemination of android malware there is a real need for tools that can automatically detectmaliciousapplicationsthatstealprivateuserinforma tion.
two prevalent approaches for detecting such android malware are taint analyzers andsignature based detectors taint analyses such as are capable of exposing applications that leak private user information.
unfortunately since many benign apps also need access to sensitive data to perform their advertised functionality not every app that leaks user information can be classified as malware.
for instance an email client application will necessarily lea k email addresses of the user s contacts in order to perform its functionality.
thus taintanalysescannotautomaticallyd istinguish benign apps from malware and a security auditor must invest significant effort in order to determine whether a given information flow constitutes malicious behavior.
signature based malware detectors includingcommercial virus scanners classify a program as malware if it contains a sequence of instructions that is matched by a regular expression.
as shown in a recent study malware detectors that are based on syntactic low level signatures can be easily circumvented using simple program obfuscations .
hence thesemalwaresignaturesmustbefrequentlyupdated as new variants of the same malware family emerge.
in this paper we present apposcopy a new semanticsbased approach for detecting android malware that steal private user information.
drawing insights from the respective advantages of pattern based malware detectors and taintanalyzers apposcopyincorporates i ahigh levelspec ification language for describing semantic characteristics of android malware families and ii a powerful static analysis for deciding if a given application matches the signature of a malware family.
the semantic high level nature of the signature specification language allows analysts to specify key characteristics of malware families without relying on the occurrence of specific instruction or byte sequences making apposcopy more resistant to low level code transformations.
the signature based specification language provided by apposcopy allows specifying two types of semantic properties control flow and data flow of android applications.
an example of a control flow property is that the malware contains a broadcast receiver which launches a service upon the completion of some system event.
an example of a data flow property is that the malware reads some private dataof the device and sends it through a designated sink e.g.
internet sms message etc.
.
to match the signatures specified in this language apposcopy s static analysis relies on two key ingredients.
first we construct a new high level representation of android applications called the inter component callgraph iccg which is used to decide whether an android application matches the control flow properties specified in the signature.
second apposcopy incorporates a static taint analysis which is used for deciding whether a given application matches a specified data flow property.
we have evaluated apposcopy on a corpus of real world android applications and show that it can effectively and reliably pinpoint malicious applications including obfusca ted ones that belong to certain malware families.
despite the theoretical undecidability of the semantic signature matching problem apposcopy yields both few false positives and few false negatives on current android applications.
.
motiv ating example in this section we illustrate our approach using a simplified version of the golddream malware family.
as described in jiang s security report the key characteristic of members of this family is that they register a receiver for certain system events such as sms messages or outgoing phone calls.
when these events trigger the execution of code in the receiver the malware then starts a background serviceforsendingprivateuserinformation suchasthephone s unique imei number and subscriber id to a remote server.
.
golddream signature in apposcopy to detect a sample of golddream malware an analyst firstwritesasignatureofthismalwarefamilyinourdatalogbased language.
in this case the behavior of golddream is captured by the specification in figure .
here lines introduce a new user defined predicate gdevent x which describes the events that the golddream malware listens for.
in this case gdevent x evaluates to true when xis either sms received ornew outgoing call but to false otherwise.
using this predicate lines describe the signature of the golddream malware family.
in this case the signature uses three kinds of predicates provided by apposcopy component type predicates suchasreceiver r and service s specify that randsarebroadcastreceiver andservice components in the android framework.
control flow predicates an example of a control flow predicate is icc which describes inter component communication in android.
in our example icc system r e expresses that the android system invokes component r when system event ehappens and icc r s means that component rtransitively invokes component s. data flow predicates suchasflow x so y si express that the application contains a flow from source soin component xto a sink siin component y. hence lines state that component ssends the device and subscriber id of the phone over the internet.
therefore according to the signature simplified version infigure2 anapplication abelongstothegolddreammalware family if i acontains a broadcast receiver that listens for system events sms received ornew outgoing call lines and ii this broadcast receiver starts a service which then leaks the device id and subscriber id over the internet lines .
.
gdevent sms received .
.
gdevent new outgoing call .
.
golddream receiver r .
icc system r e gdevent e .
service s icc r s .
flow s deviceid s internet .
flow s subscriberid s internet .
figure golddream signature simplified .
golddream malware detection given an android application aand malware signature s apposcopy performs static analysis to decide if app a matches signature s. apposcopy s static analysis has two important ingredients i construction of the iccg which determines the truth values of control flow predicates used in the signature and ii static taint analysis which is used to decide the truth values of data flow predicates.
figure shows a partial iccg for an instance of the golddream malware family.
nodes in the iccg correspond to components and node labels denote component names.
the shapes of the nodes indicate component types rectangles denote broadcast receivers ellipses indicate activities an d polygons are services.
an iccg edge from one node ato another node bmeans that component astarts component b for example by calling the startactivity method of the android sdk.
the edges in the iccg may also be labeled with additional information such as system events.
goingbacktothespecificationfromsection2.
theiccg shown in figure matches the sub query receiver r icc system r e gdevent e service s icc r s because i there exists a node in the iccg representing a receiver component namely zjreceiver ii there is an edge from the node representing the android system tozjreceiver labeled with sms received iii zjreceiver hasanoutgoingedgetoaservicecomponentcalled zjservice .
next to decide data flow queries apposcopy performs taint analysis tracking flows from sourcestosinks.
here sources represent sensitive data such as the phone s device id and sinks represent operations that may leak data such as sending text messages.
for our example application the taint analysis yields the following result com.sjgo.client.zjservice getsimserialnumber !internet getdeviceid !internet getsubscriberid !internet getdeviceid !sendtextmessage getsubscriberid !sendtextmessage cxboy.android.game.fiveink.fivelink id !internet model !internet net.youmi.android.adactivity getdeviceid !webview externalstorage !webview here apposcopy has identified source sink flows in three components zjservice fivelink andadactivity .
for example the first three lines under zjservice indicate that it sends the phone s serial number device id and subscriber id over the internet.
recall that the golddream malware signature includes the data flow query flow s deviceid s internet flow s subscriberid s internet wheresis a service.
since the taint analysis reveals that zjservice leaks the device and subscriber id to the internet this query evaluates to true and apposcopy concludes this application is golddream malware.
observe that althoughfigure partial iccg for an instance of the golddream malwa re family table a partial list of icc related apis.
activitystartactivity intent startactivityforresult intent int startactivityifneeded intent int startnextmatchingactivity intent servicestartservice intent bindservice intent broadcastreceiversendbroadcast intent sendbroadcast intent string sendorderedbroadcast intent string there are other source sink flows in this example such as fromdeviceid towebview inadactivity these other flows do not necessarily correspond to malicious behavior.
.
malware spec language thissectiondescribesapposcopy smalwaresignaturelanguage which is a datalog program augmented with builtin predicates.
for each malware family the user defines a unique predicate that serves as the signature for this malware family.
the user may also define additional helper predicates used in the signature.
in what follows we first give some background on datalog and then describe the the syntax and semantics of apposcopy s built in predicates.
.
datalog preliminaries a datalog program consists of a set of rulesand a set of facts.
facts simply declare predicates that evaluate to true.
for example parent bill mary states that bill is a parentofmary.
eachdatalogruleisahornclausedefininga predicate as a conjunction of other predicates.
for example the rule ancestor x y parent x z ancestor z y .
says that ancestor x y is true if both parent x z and ancestor z y are true.
in addition to variables predicates can also contain constants which are surrounded by double quotes or don t cares denoted by underscores.
datalog predicates naturally represent relations.
specifically if tuple x y z is in relation a this means the predicatea x y z is true.
in what follows we write the type of a relation r x y ...as s1 x s2 y ... where s1 s2 ...are descriptive texts for the corresponding domains.
.
apposcopy s built in predicates we now describe the syntax and semantics of the four classes of built in predicates provided by apposcopy.
.
.
component type predicates component type predicates in apposcopy represent the differentkindsofcomponentsprovidedbytheandroidframe table a partial list of life cycle apis.
activityoncreate bundle onrestart onstart onresume onpause onstop ondestroy serviceoncreate onbind intent onstartcommand intent int int ondestroy broadcastreceiver onreceive context intent work.
an android application consists of four kinds of components activity service broadcastreceiver andcontentprovider .
activity components form the basis of the user interface and each window of the application is typically controlled by an activity.
service components run in the background and remain active even if windows are switched.
broadcastreceivercomponentsreactasynchronouslytomessagesfromotherapplications.
finally contentprovidercomponents store data relevant to the application usually in a database and allow sharing data across applications.
corresponding to each of these android components apposcopy provides pre defined predicates called service c activity c receiver c andcontentprovider c which representthetypeofcomponent c.forexample activity c is true ifcis anactivity .
each of these four predicates correspond to relations of type comp c where domain cis the set of all components in the application.
.
.
predicate icc a key idea behind inter component communication icc in android is that of intents which are messages passed between components.
intents are used to start activities start stop and bind services and broadcast information to broadcast receivers.
table shows a list of android apis that are used in icc.
we refer to those methods all of which take intent objects as arguments as icc method s. we use the term icc site to represent a statement that invokes one of the icc methods listed in table .
when component a initiates icc with component b the android system will eventually call life cycle methods associated with componentb.
the life cycle methods are shown in table .
whileanintentobjectpassedtoiccmethodscancontain many different types of information apposcopy s signature language takes into account only two kinds action and data.
actionis a string that represents the type of action that the receivingcomponentneedstoperform and dataspecifiesthe type of data that the component needs to operate on.
for example a component for editing images will receive intents with corresponding action editand data type image .
apposcopy s iccpredicaterepresentsinter componentcommunication in android and corresponds to a relation of type source c target c action a data d where domain1.
public class mainact extends activity .
protected void oncreate bundle b .
foo .
bar .
.
void foo .
intent i new intent .
i.setaction android.intent.action.send .
i.settype text plain .
startactivity i .
.
void bar .
intent n new intent .
n.setclass msgact.class .
startactivity n .
.
.
public class msgact extends activity ... figure icc example.
activity android name msgact intent filter action name android.intent.action.send data mimetype text plain intent filter activity figure a snippet of androidmanifest.xml cis the set of all components in the application and a anddare the sets of all action and data values defined by the android system.
since not all intents are required to have action and data values domains aanddalso include a special element which indicates no value.
intuitively if predicate icc p q a d is true this means that componentppasses an intent to qthrough invocation of an icc method and aanddrepresent the action and data strings of the intent.
to formally state the semantics of the icc predicate we first define targets of icc sites definition .
.thetarget of an icc site m i ... is the set of components that will receive the intent stored in variableiin some execution of the application.
definition .
.we write m1 m2iff method m1directly calls m2in some execution of the program.
we define to be the reflexive transitive closure of .
in other words m1 m2ifm1transitively calls m2.
we now define the semantics of the iccpredicate as follows definition .
.the predicate icc p q a d is true iff i m1is a life cycle method defined in component p ii m1 m2 iii m2contains an icc site whose target is component q and iv the action and data values of the intent areaandd respectively.
example .consider the code in figure which defines two activities mainactandmsgact.
theoncreate life cycle method of mainactcallsfoowhich initiates icc at line by calling startactivity with intent i. the action associated with intent iissendand the data type is text plain .
according to the manifest in figure msgactdeclares an intent filter forsendactions on data type text plain meaning that msgactis a target of the icc site at line .
hence predicate icc mainact msgact send text plain is true.
we now define the predicate icc p q which is true if component pcan transitively launch component q definition .
.leticc direct p q be a binary predicate which is true iff icc p q is true.
the predicate icc is the reflexive transitive closure of icc direct .table a non exhaustive list of android methods that are candidates of abuse operation description broadcastreceiver void abortbroadcast block current broadcaster.
runtime process exec java.lang.string execute a command.
system void loadlibrary java.lang.string perform native call.
packagemanager list getinstalledpackages get all application packages.
dexclassloader void init ... classloader load classes from .jar and .apk files.
our malware signature language includes the predicate icc because it allows writing signatures that are resilient to high level control flow obfuscation.
in particular if the signature contains the predicate icc p q adding or deletingdummycomponentsforthepurposesofdetectionevasion will not affect the truth value of this predicate.
.
.
predicate calls apposcopy provides another control flow predicate called calls representing a relation of type comp c callee m where domains candmrepresent the set of all components and methods in the program respectively.
intuitively calls c m is true if method mis called by componentc.
moreprecisely calls c m istrueiff nisalife cycle method defined in component candn m. thecallspredicate is useful for defining malware signatures because it can be used to check if a component calls android api methods that can be abused by malware.
table .
.
lists a few of such dangerous methods.
.
.
predicate flows apposcopy provides a data flow predicate flowsused for querying whether an app leaks sensitive data.
more specifically taint flow is defined in terms of sources and sinks.
definition .
.asource resp.
sink is a labeled i.e.
annotated program variable that is either a method parameter or method return value.
the corresponding method is referred to as the source method resp.
sink method .
an example of a source is the return value of method getdeviceid which yields the phone s unique device id.
an exampleofasinkisthethirdparameterof sendtextmessage which corresponds to the text to be sent through sms.
source and sink annotations are discussed in section .
.
and table .
.
shows a partial list of source and sink methods.
theflowpredicaterepresentsarelationoftype srccomp c src src sinkcomp c sink sink where domain c is the set of components and src and sink are the sets of allsourcesandsinksintheprogram.
todefinethesemantics of theflowpredicate we first define taint flow definition .
.ataint flow so si represents that a source labeled socan flow to a sink labeled sithrough a series of assignments or matching loads and stores.
definition .
.the predicate flow p so q si is true iff i mandnare the source and sink methods corresponding to source soand sink si ii calls p m andcalls q n are both true and iii there exists a taint flow so si .
example .consider the code in figure where the return value of getdeviceid is a source labeled getdeviceid table examples of apis with source and sink annotations sources sinks telephonymanager string getdeviceid smsmanager void sendtextmessage ... telephonymanager string getsimserialnumber smsmanager void sendmultipartextmessage ... telephoneymanager string getsubscriberid smsmanager void senddatamessage ... telephoneymanager string getvoicemailnumber dataoutputstream write ... telephoneymanager string getsimoperator datagramsocket void send ... location double getlatitude abstracthttpclient httpresponse execute ... location double getlongitude ndef void writendefmessage ... public class listdevice extends activity protected void oncreate bundle bd .
device n m .
... .
string x deviceid .
string y telephonymanager.getdeviceid .
string z x.concat y .
m.f z .
n m .
string v n.f .
smsmanager.sendtextmessage null v null nul l figure example illustrating data flow and the third parameter of sendtextmessage is a sink labeled !sendtextmessage .
this application exhibits a taint flow from getdeviceid to!sendtextmessage because variable yholding the return value of getdeviceid can flow to variable vdue to the chain of assignments loads and stores performed in lines .
hence the following predicate evaluates to true flow listdevice getdeviceid listdevice !sendtextme ssage .
static analyses this section describes apposcopy s static analyses for deciding whether an application matches a malware signature.
the main idea is to compute an over approximation of the icc calls andflowrelations.
.
pointer analysis callgraph contruction in order to build the inter component callgraph and track information flow apposcopy starts by performing a pointer analysis which computes the set of abstract heap objects that each variable may point to.
in the remainder of the paper we use the notation v oto denote that variable vmay point to an abstract heap object represented by oin some execution of the program.
since the precision of the underlying pointer analysis is critical for detecting malware with few false alarms we use a field and context sensitive andersen style pointer analy sis .
forcontext sensitivity weuseahybridapproachthat combines call site sensitivity and object sensitivit y .
in particular our approach is similar to the technique described in and uses call site sensitivity for static meth od calls and object sensitivity for virtual method calls.
another key ingredient of our malware detection algorithm is callgraph construction which is used for resolving the targets of virtual method calls.
since callgraph precision has significant impact on the precision of the iccg apposcopy computes the callgraph on the fly simultaneously refining the targets of virtual method calls and points to sets until a fixed point is reached.
the set of edges in the resulting callgraph represent the relation from definition .
.
an edge in the callgraph from method m1to method m2 corresponds to m1 m2.
similarly m1 m2represents that there exists a path in the callgraph from m1tom2.table api for setting intent attributes targetsetcomponent componentname setclassname context string setclassname string string setclass context class action setaction string data typesettype string setdata uri setdataandtype uri string .
inter component control flow analysis we now describe the construction of the inter component call graph iccg which is used for deciding icc queries.
definition .
.an iccg for a program pis a graph n e such that nodes nare the set of components in p and edges edefine a relation e n a d n wherea anddare the domain of all actions and data types defined by the android system augmented with the element .
in other words iccg is a directed graph where nodes are components in an application and edges are labeled with actions and data types.
the special element indicates that the intent defining the icc does not have action or data type information associated with it.
given a callgraph andtheresultsofthepointeranalysis apposcopyconstructs the iccg by performing two key steps that we explain next.
.
.
data flow analysis for intents the first step of iccg construction is a data flow analysis to track the information stored in intent objects.
specifically we track three kinds of information about intents target in the android framework a component can specify the target of an intent and hence the icc by calling the methods shown in the first row of table .
such intents whose targets have been explicitly specified are called explicit intents .
action a component can specify the action that the icc target needs to perform by calling the methods shown in the second row of table .
data type an application can specify the data type that the recipient component needs to operate on by calling the methods shown in the last row of table .
whenacomponentdoesnotspecifythetargetofanintent explicitly the android system resolves the recipient components of the icc based on intent filters declared in the manifest file.
an intent filter specifies the kinds of actions that a component will respond to.
for instance consider the androidmanifest.xml file from figure .
here msgactdeclares that it responds to intents whose corresponding action and data type are sendandtext plain respectively.
in order to build the iccg apposcopy first performs a forward interprocedural dataflow analysis called the intent analysis which overapproximates the target action andmustalias y x newval y x s mayalias y x mustalias y x newval y x s mayalias y x newval y x s newval xi x s i xi dom x.setcomponent s uniontext i i figure transfer function for setcomponent data type associated with each intent object.
specifically for each variable iof typeintent our analysis tracks three variables it ia andidwhose domains are sets of components actions and data types respectively.
we initialize the dataflow value for each variable to be and define the join operator as set union.
table shows the set of android api methods for setting attributes of intent objects.
since other methods do not change attributes of intents the transfer function for any statement not included in table is the identity function.
figure shows the transfer function for setcomponent in the form of inference rules.
since transformers for the other statements from table are very similar we only focus on setcomponent as a representative.
in figure environment denotes data flow facts for targets of intent variables as a mapping from each variable to its corresponding dataflow value.
now consider the statement x.setcomponent s wherexis a variable of type intent and sis a string specifying the target component.
if another variable yis an alias ofx then the target of ywill also be affected by this statement.
hence our transfer function must update the data flow values of all variables that are aliases of x. now there are three cases to consider.
if xandyare guaranteed to be aliases as in the first rule of figure then we can kill its old value and update its new value to s i.e.
a strong update .
in the second rule if ymayaliasx theny s target could either remain unchanged or become s hence we only perform a weak update.
finally if yandxdo not alias then y s target definitely remains unchanged and its existing dataflow values are preserved.
the mayaliasand mustaliasrelations used in figure are defined according to figure .
in the definition of the mustaliasrelation o represents the set of concrete memory locations represented by abstract memory location o. based on the results of this data flow analysis we can now determine whether an intent is explicit or implicit.
specifically if xt does not contain the target of the intent must have been explicitly specified.
hence we write explicit x if ne ationslash xt .
otherwise xmaybe an implicit intent denoted implicit x .
example .consider again the code from figure .
here for intent ideclared at line we have it ia action.send id text plain for the intent nat line our analysis computes nt msgact na nd .
since ne ationslash nt we conclude explicit n .
on the other hand iis identified to be implicit.
.
.
iccg construction we now describe iccg construction using the results of the intent analysis.
in what follows we write iccsite m i to denote that method mcontains an icc site with intent i and we write p mto indicate that component phasx o y o mayalias x y x o o .x o y o o .y o o mustalias x y mustalias x x figure may and must aliasing relations iccsite m i explicit i p m q it a ia d id p q a d e explicit iccsite m i implicit i p m a ia d id intentfilter q a d p q a d e implicit figure iccg construction rules a life cycle method m andm mfinally the predicate intentfilter p a d means that component pdeclares an intent filter with action aand data type d. this information is extracted from the application s manifest file.
figure8showstheiccgconstructionrules.
thefirstrule explicit considers icc sites in method mwhere intent i has its target component explicitly specified i.e.
q it andq ne ationslash .
in this case if method mis reachable from component p we add an edge from component ptoqin the iccg.
furthermore if a ia andd id the edge from ptoqhas action label aand data type label d. the second rule in figure applies to icc sites where intentimay be implicit.
if a ia andd id we need to determine all components qthat declare intent filters with action aand data type d. hence we add an edge from component ptoqifintentfilter q a d is true.
example .consider again the code from figure and the data flow facts computed in example .
using the implicit rule for the icc site in method foowith intent i we infer the edge mainact msgact action.send text plain .
using the explicit rule for icc site in method barwith intentn we add the edge mainact msgact .
.
taint analysis we now describe apposcopy s taint analysis for answering data flow queries.
we first discuss how we annotate sources and sinks and then describe our taint propagation rules.
.
.
annotations apposcopyprovidesthreetypesofannotationscalled source sink andtransfer annotations.
source annotations are used to mark android framework methods that read sensitive data and sink annotations indicate methods that leak data outside of the device.
in contrast transfer annotations are used for describing taint flow through android sdk methods.
in our approach transfer annotations are necessary because apposcopy analyzes the source code of android applications but notthe underlying implementation of the android platform.
hence we have manually written annotations for android sdk methods that propagate taint between parameters and return values.
example .figure shows representative examples of source sink and transfer annotations.
all three kinds of specifications are written using the flowannotation and sources and sinks are indicated by the special prefixes and!
respectively.
in figure the annotation at line is a sourc e annotation indicating that getdeviceid s return value is a taint source.
the sink annotation at line indicates that1.
source annotation in android.telephony.telephonyma nager .
flow from getdeviceid to return .
string getdeviceid ... .
sink annotation in android.telephony.smsmanager .
flow from text to !sendtextmessage .
void sendtextmessage ... string text ... ... .
transfer annotation in java.lang.string .
flow from this to return .
flow from s to return .
string concat string s ... figure source sink and transfer annotations.
sendtextmessage is a sink for its formal parameter text.
lines correspond to transfer annotations for the android library method concatwhich is not analyzed by apposcopy.
according to line if the thisparameter of concatis tainted then its return value is also tainted.
similarly the annotation at line states that if parameter sof concatis tainted then so is the return value.
we emphasize that the source sink and transfer annotations are notwritten by individual users of apposcopy which already comes with a set of built in annotations that we have written.
apposcopy uses the same pre defined annotations for analyzing every android application.
.
.
static taint analysis we describe apposcopy s taint analysis using the inference rules shown in figure which define two predicates tainted o l andflow so si .
the predicate taintedrepresents a relation o abstractobj l sourcelabel where domainois the set of all abstract heap objects and lis the set of all source labels such as getdeviceid .
iftainted o l is true this means that any concrete heap objected represented by omay be tainted with l. the predicate flow so si representsarelationoftype l sourcelabel l sinklabel .
ifflow so si is true this means that source somay reach sinksi.
hence the flowpredicateisastaticover approximation of the taint flow relation introduced in definition .
.
all of the rules in figure use the notation mito denote thei th parameter of method m. for uniformity of presentation we represent the thispointer as m0and the return value as mn 1wherenis the number of arguments of m. the first rule labeled source in figure describes taint introduction.
in this rule we use the notation src mi l to denotethatthe i thparameterof misannotatedwithsource labellas described in section .
.
.
hence if variable mi may point to heap object oandmiis annotated as source l then heap object oalso becomes tainted with label l. the second rule called transfer performs taint propagation.
here the predicate transfer mi mj corresponds to the transfer annotations from section .
.
and indicates there is a flow from the i th to the j th parameter of android sdk method m. according to this rule if i mican flow tomj ii miandmjmay point to heap objects o1and o2respectively and iii o1is tainted with label l theno2 also becomes tainted with label l. thethirdrulelabeledsinkdefinesthe flowpredicateusing thetaintedpredicate.
here the notation sink mi si means that the i th parameter of miis passed to some sink labeled si.
hence according to this rule if miis passed to sink si andmimay point to a heap object othat is tainted with labelso then there may be a flow from source soto sinksi.
the taint analysis of apposcopy consists of applying the rules from figure until a fixed point is reached.
observesrc mi l mi o tainted o l source tainted o1 l mi o1 mj o2 transfer mi mj tainted o2 l transfer tainted o so mi o sink mi si flow so si sink figure rules describing the taint analysis.
that the rules from figure do not describe transformers for individual instructions such as stores because we use the points to facts computed by a whole program pointer analysis.
that is if any variable vin the program may flow to mithrough a chain of heap reads and writes we will have mi ovwhereovis the location pointed to by v. example .consider the code in figure and annotations in figure .
say x y zpoint to heap objects o1 o2 o3 respectively.
since src getdeviceidreturn getdeviceid and y o2 the source rule infers tainted o2 getdeviceid .
transfer concat concat return denotes a transfer annotation at line where concat 1 o2 concat return o3 thus the transfer rule infers tainted o3 getdeviceid .
finally consider the call to method sendtextmessage which has a sink annotation sink sendtextmessage3 !getdeviceid .
since the argumentvandzare aliases we have sendtextmessage3 o3.
hence we deduce flow getdeviceid !sendtextmessage .
.
implementation ev aluation our implementation consists of about lines of java and uses several publicly available software such as soot and bddbddb .
soot is used to convert android s .apk files tojimple a higher level intermediate representation.
a pre processing step processes jimple instructions to extract various types of program facts and our static analyses are specified as datalog programs.
the bddbddb system takes as input the datalog specification of a static analysis and extracted program facts and outputs the results of the analysis.
apposcopy s static analyses use manually writte n models of the android framework currently we have models for about classes that are relevant for our analyses.
to evaluate the effectiveness and accuracy of apposcopy we performed four sets of experiments including evaluation on i known malware ii google play apps iii obfuscated malware.
in addition iv we also compare apposcopy with another research tool called kirin for android malware detection.
the remainder of this section describes the details and results of our evaluations.
.
evaluation on known malware in our first experiment we evaluate the effectiveness of apposcopy on malware instances from the android malware genome project which contains real malware collected from various sources including chinese and russian third party app markets.
all of these malicious applications belong to known malware families such as droidkungfu geinimi and golddream.
to perform this experiment we manually wrote specifications for the malware families included in the android malware genome project.
for this purpose we first read the relevant reports where available and inspected a small number of instances 1for simplicity of presentation we assume every variable is a pointer to a heap object.table examples of apposcopy s signatures.
malware family signature adrd adrd receiver r icc system r boot completed re ceiver s service t icc r s icc s t icc t s flow t deviceid t enc flow t subscriberid t enc f low t enc t internet .
beanbot beanbot receiver r service s service t service q icc system r phone state calls r abortbroadcast icc r s icc s t icc s q flow s deviceid s internet flow s line1number s internet flow s simserialnumb er s internet .
coinpirate coinpirate receiver r receiver t icc system r sm s sent icc system r sms received service s calls r abortbroadcast calls s sendtextmessage ic c r s icc s t flow s deviceid s internet flow s subscriberid s internet flow s model s inte rnet flow s sdk s internet .
for each malware family.
table shows signatures that we wrote for some of these malware families.
table presents the results of this experiment.
the first column indicates the malware family and the second column shows the number of analyzed instances of that malware family.
the next two columns show the number of false negatives fn and false positives fp respectively.
in this context a false negative arises if an application abelongs to a certain malware family fbut apposcopy cannot detect thatais an instance of f. conversely a false positive arises if an application adoes not belong to malware family fbut apposcopy erroneously reports that it does.
the final column of table reports apposcopy s overall accuracy which is calculated as the number of correctly classified instances divided by the total number of samples.
as shown in the last row of table the overall accuracy of apposcopy over all malware instances that we analyzed is .
.
that is it can correctly classify approximately out of malware instances accurately.
however looking at the results more closely we see that apposcopy performs quite poorly on the basebridge malware family.
specifically among the samples that we analyzed apposcopy only classifies of these application s as instances of basebridge.
upon further inspection of this family we found that many of the basebridge instances dynamically load the code that performs malicious functionality.
such behavior can inherently not be detected using static analysis and causes apposcopy to yield many false negatives.
observe that if we exclude basebridge from our samples the overall accuracy of apposcopy rises to .
.
fortheothermalwarefamiliesforwhichapposcopyyields false negatives there are several contributing factors.
first since we have written the specifications by inspecting only a small number of samples our signatures may not adequately capture the essential characteristics of allinstances of that family.
second the malware family may have some key feature that is not expressible in our malware specification language.
for example if a given malware performs malicious functionality without leaking sensitive data apposcopy wi ll be unable to detect it.
a third contributing factor for false negatives is due to missing models.
specifically while our static analysis is sound we do not analyze the underlying codeoftheandroidsystem butinsteadrelyon method stubs that capture the relevant behavior of the android sdk.
if these applications call sdk methods for which we have not provided stubs apposcopy may yield false negatives.
based on the data from table we observe that apposcopy reports very few false positives.
among the malware samples apposcopy reports two instances of the geinimi family as instances of both geinimi as well as the droidkungfu family.
this corresponds to an overall false positive ratio of less than .
indicating that apposcopy s staticanalysisispreciseenoughtoaccuratelyanswercontro land data flow queries about android applications.table evaluation of apposcopy on malware from the android malware genome project.
malware family samples fnfpaccuracy droidkungfu .
anserverbot .
basebridge .
geinimi .
droiddreamlight .
golddream .
pjapps .
adrd .
jsmshider .
droiddream .
bgserv .
beanbot .
gingermaster .
coinpirate .
droidcoupon .
total .
finally we remark that apposcopy s analysis time on these malicious applications is moderate with an average of seconds per analyzed application containing lines of dalvik bytecode on average.
.
evaluation on google play apps in a second experiment we evaluate apposcopy on thousands of apps from google play.
since these applications are available through the official android market rather than less reliable third party app markets we would expect a large majority of these applications to be benign.
hence by running apposcopy on google play apps we can assess whether our high level signatures adequately differentiate benign applications from real malware.
in our experiment among the apps analyzed by apposcopy only16ofthemwerereportedasmalware.
specifically apposcopy reported two applications to be instances of droiddreamlight one to be an instance of droiddream and another one to be an instance of pjapps.
the remaining applications were categorized as droidkungfu.
to decide whether these apps are indeed malware we uploaded them to virustotal for analyzing suspicious applications .
virustotal is a service that runs multiple anti virus tools on the uploaded application and shows their aggregate results.
based on the results provided by virustotal the majority of anti virus tools agree with apposcopy s classification for of the reported malware.
for the remaining three applications the majority of the tools classify them as malicious adware while apposcopy classifies them as instances of droidkungfu.
this experiment confirms our claim that apposcopy does not generate a lot of false alarms and that our malware signatures can distinguish benign applications from real malware.
similar to the experiments from section .
apposcopy takes an average of seconds to analyze a google play application with lines of dalvik bytecode on average.
.
evaluation on obfuscated apps to substantiate our claim that apposcopy is resilient to code transformations we compare the detection rate of apposcopy with other anti virus tools on obfuscated versions of known malware.
for this experiment we obfuscated existing malware using the proguard tool which is commonly used by malware writers to evade detection.
in addition since the databases of some of the anti virus tools include signatures of malware samples obfuscated by proguard we also applied three additional obfuscations that are not performed by proguard first our obfuscator changes the names of components classes methods and fields.
second all invocations to methods of android.
classes are redirected through proxy methods.
third our obfuscator also performs string encryption including encryption of component names as well as action and data type values of intents.
table shows the results of our third experiment on obfuscated malware.
each row in this table corresponds to an application that is an instance of a known malware family and whose unobfuscated version can be identified as malware by all tools considered in our evaluation .
each column in the table corresponds to a leading anti virus tool namely avg symantec eset dr. web kaspersky trend micro and mcafee.
a check indicates that the tool is able to detect the obfuscated version of the program as malware and a cross means that the tool is unable to classify the obfuscated version as malicious.
as table shows apposcopy is resistant to these obfuscations for all malware that we considered.
in contrast none of the other tools can successfully classify all of the obfuscated apps as malware.
.
comparison with kirin inadditiontocomparingapposcopywithcommercialantivirus tools we also compared apposcopy against kirin which is the onlypublicly available research tool for android malware detection.
as explained in section kirin is a signature based malware detector that classifies an app as malware if it uses a dangerous combination of permissions specified by the malware signature.
on the set of malicious apps considered in section .
kirin reports only apps out of malicious apps to be malware.
this corresponds toafalsenegativerateof48 whichisquitehighcompared to the false negative rate of apposcopy.
on the other hand for the set of applications taken from google play and considered in section .
kirin reports of these apps to be malware while apposcopy classifies only .
of these apps as malicious.
we manually inspected out of the apps classified as malware by the kirin tool and also compared with the results of virustotal.
our evaluation revealed that the overwhelming majority of the apps classified as malware by kirin are false positives.
hence our experiments demonstrate that apposcopy outperforms kirin both in terms of false positives as well as false negatives.
.
related work taint analysis.
bothdynamic andstatictaint analyses have been proposed for tracking information flow in mobile applications.
for example taintdroid and vetdroid are dynamic taint analyses that track information flowbyinstrumentingthedalvikvm andexamplesofstatic taint analyses include .
while apposcopy employs static taint analysis as one of its components we observe that not every application that leaks sensitive datais malicious in fact many benign apps transmit sensitive data for performing their required functionality.
thus taint analyses on their own are not sufficient for automatically differentiating malicious apps from benign apps and we propose to combine taint analysis with high level malware signatures to effectively identify malicious code.
signature based malware detection.
many techniques for identifying existing malware are signature based meaning that they look for patterns identifying a certain malware family.
in its simplest form these patterns are sequences of bytes or instructions .
since such syntactic patterns can be defeated by semantics preserving transformations previous work has considered semantics aware malware detection .
similar to apposcopy detects malware based on their semantic rather than syntactic characteristics.
however our signatures are much higher level compared to the templatized instruction sequences used in and allow directly specifying control and data flow properties of android applications.
furthermore the underlying signature matching techniques are also very different.
a popular signature based malware detection technique for android is the kirin tool .
the malware signatures in kirin specify dangerous combinations of android permissions and kirin decides if an application matches a signature by analyzing its manifest file.
as demonstrated in our experimental evaluation kirin yields many more false positives and false negatives compared to apposcopy.
another related approach is the behavioral detection technique described in .
in that approach one specifies common malware behavior using temporal logic formulas.
however a key difference between apposcopy and behavioral detection is that our techniques are purely static while requires monitoring behavior of the application at run time.
the droidranger tool uses permission based behavioral footprint to detect instances of known malware families.
behavioral footprints include characteristic malware features such as listening to certain system events calling suspicious apis and containing hard coded strings.
while these behavioral footprints can be viewed as high level malware signatures they differ from those of apposcopy in several ways behavioral footprints neither refer to information flow properties of an application nor do they express control flow dependencies between different components.
furthermore behavioral footprints include hard coded string values which are easy to obfuscate by malware writers.
zero day malware detection.
a known limitation of signature based approaches including apposcopy is that they can only detect instances of known malware families.
in contrast zero day malware detectors try to uncover unknown malware families.
for example riskranker performs several risk analyses to rank android applications as high medium or low risk.
these risk analyses include techniquestoidentifysuspiciouscodethatexploitsplatformlevel vulnerabilities or sends private data without being triggered by user events.
in addition to identifying instances of known malware droidranger also tries to uncover zero day malware by performing heuristic based filtering to identify certain inherently suspicious behaviors.
many recent malware detectors such as use machine learning to detect zero day malware.
for example drebin performs light weight static analysis to extract features such as permissions and api calls and trainstable comparison between apposcopy and other tools on obf uscated malware.
family avg symantec eset dr. web kaspersky trend micro mcafee apposcopy droidkungfu geinimi droiddreamlight golddream droiddream beanbot gingermaster pjapps bgserv coinpirate jsmshider anserverbot droidcoupon adrd success rate .
.
.
.
.
.
.
.
an svm to find a hyperplane separating benign apps from malware.
the droidapiminer tool also considers api features and uses machine learning to automatically classify an application as malicious or benign.
while learning based approaches are powerful for detecting unknown malware their precision relies on representative training sets.
we believe all of these zero day malware detection techniques are complementary to apposcopy while apposcopy can identify instances of known malware families with few false alarms zero day malware detectors can help uncover new malware families albeit at the cost of more false positives or more involvement from a security auditor.
static analysis for malware detection.
static analysis and model checking have been used to detect security vulnerabilities for a long time.
in the context of mobile malware the saaf tool uses program slicing to identify suspicious method arguments such as certain urls or phone numbers.
the work described in performs various static analyses including taint analysis to better un derstand smartphone application security in over popular android apps.
one of the interesting conclusions from this study is that while many apps misuse privacy sensitive information few of these apps can be classified as malware.
the pegasus system focuses on malware that can be identifiedbytheorderinwhichcertainpermissionsandapis are used.
the user writes specifications of expected app behavior using temporal logic formulas and pegasus model checks these specifications against an abstraction called th e permission event graph peg .
pegasus differs from our approach in that i it targets a different class of malware and ii pegabstractstherelationshipbetweentheandroidsystem and the application while iccg abstracts the relationship between different components in the application.
some recent papers address the detection of re packaged apps which often inject adware or malicious features into legitimate apps .
while some repackaged apps may contain malware these techniques mainly focus on clone rather than malware detection.
analysis of icc.
comdroid analyzes icc of android apps to expose security vulnerabilities such as intent spoofing or unauthorized intent receipt.
chex performs static analysis to identify app entry points and uses this information to detect component hijacking vulnerabilities.
in contrast to apposcopy comdroid and chex are meant to be used by developers to identify security vulnerabilities in their own applications.epicc also addresses icc in android and proposes a static analysis for inferring icc specifications .
these specificationsincludeiccentryandexitpoints informationabout the action data and category components of intents used for icc as well as intent key value types.
while our iccg encodes similar information to the specifications inferred by epicc we show that the iccg is a useful abstraction for specifying and identifying android malware.
.
limitations likeanysignature basedsolution apposcopyisnotinvincible it is very hard to design any signature based scheme that cannot be defeated by a suitably designed automatic obfuscator.
inparticular similartoanystaticanalysisbased system apposcopy may be defeated by obfuscation techniques such as dynamic code loading and use of reflection in combination with obfuscation of method or class names.
however such attempts to escape detection are likely to be deemed suspicious and may invite further scrutiny.
second since apposcopy performs deep static analysis to uncover semantic properties of an app it may be unfit for scenarios that require instant detection of malware.
however smartphoneappsaregenerallydistributedthrough centralized app stores which enables deployment of apposcopy to scan apps as they are submitted to the app store.
.
conclusion and future work we presented apposcopy a static analysis approach for detecting malware in the mobile apps ecosystem.
malware that belong to one family share a common set of characteristic behaviors which an auditor can encode through apposcopy sdatalog basedmalwarespecificationlanguage.
apposcopy performs deep static analysis to extract data flow and control flow properties of android applications and uses these results to identify whether a given application belongs to a known malware family.
our experiments indicate that apposcopy can detect malware with high accuracy and that its signatures are resilient to various program obfuscations.
there are several opportunities for future work.
we will develop techniques to improve the efficiency and precision of apposcopy s static analyses.
we also plan to develop techniques to automatically de obfuscate apps to enhance apposcopy s resilience to some types of obfuscations see section .
finally we plan to develop techniques to automaticallylearnmalwaresignaturesfromasetofappslabeled with their corresponding malware family or as benign .
.