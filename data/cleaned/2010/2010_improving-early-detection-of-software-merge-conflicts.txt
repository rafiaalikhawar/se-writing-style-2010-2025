see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation improving early detection of software merge conflicts article in proceedings int ernational conf erence on softw are engineering june .
ic se.
.
citations 92reads author s m rio guimar es univ ersity of lisbon publica tions citations see profile ant nio rit o silv a univ ersity of lisbon publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y ant nio rit o silv a on july .
the user has r equest ed enhanc ement of the do wnlo aded file.improving early detection of software merge conflicts m ario lu s guimar aes and ant onio rito silva department of computer science and engineering inesc id ist technical university of lisbon lisbon portugal fmario.guimaraes rito.silva g ist.utl.pt abstract merge conflicts cause software defects which if detected late may require expensive resolution.
this is especially true when developers work too long without integrating concurrent changes which in practice is common as integration generally occurs at check in.
awareness of others activities was proposed to help developers detect conflicts earlier.
however it requires developers to detect conflicts by themselves and may overload them with notifications thus making detection harder.
this paper presents a novel solution that continuously merges uncommitted and committed changes to create a background system that is analyzed compiled and tested to precisely and accurately detect conflicts on behalf of developers before check in.
an empirical study confirms that our solution avoids overloading developers and improves early detection of conflicts over existing approaches.
similarly to what happened with continuous compilation this introduces the case for continuous merging inside the ide.
keywords version control merge conflicts awareness continuous merging i. i ntroduction because of productivity today almost all software systems are built by teams of programmers working in parallel.
in this context software merging concerns the creation of a version of the system that integrates the intentions of concurrent changes.
in general developers modify private working copies of the system to ensure stability during programming.
however this prevents them from knowing what co workers are which may affect private work.
therefore conflicts emerge due to concurrent work and become more complex as changes grow without being integrated and as further developments are made.
consequently the later conflicts are detected the harder it is to resolve them because more code must be reworked.
besides a conflict detected late is generally harder to resolve since the changes that caused it are no longer fresh in developers minds .
in a field study perry et al.
concluded that the number of software defects increase with parallel work which was found to be considerable and inadequately supported by tools.
their conclusions remain valid today as parallel work increases with the growing distribution of software teams which still use tools and processes similar to those found in their study.in a recent work brun et al.
studied nine of the most active open source projects in github com and concluded that even with modern version control systems like git merge conflicts are frequent persistent and appear not only as overlapping textual edits but also as subsequent build and test failures .
industry experts have proposed several best practices to control merge conflicts like continuous integration which recommends frequent merges and check ins to avoid conflicts staying undetected for too long.
unfortunately merging is cumbersome and disrupts programming flow so some developers do not merge as frequently as desirable teams avoid parallel work because of difficult merges and developers rush their tasks to avoid being the ones responsible for the merge .
to support developers awareness of co workers activities helps break the isolation of private work by informing developers where in the code their co workers are currently making changes.
this information can be used by the developer to detect conflicts earlier.
however because of the complex semantics of today s programming languages like polymorphism and late binding it is very hard for developers to detect conflicts by themselves while they are programming.
in addition awareness may overload developers with too much information thus making detection of conflicts harder .
this paper presents a novel solution that reduces the amount of information developers have to digest.
the present solution continuously merges uncommitted and committed changes to create a background system that is analyzed compiled and tested to detect conflicts with high precision and accuracy on behalf of developers while they are programming that is before check in.
detected conflicts are then presented to the affected developers inside the ide.
in comparison to our initial paper this details the evolution of our solution presents our full fledged tool and its empirical evaluation using controlled user experiments.
the contributions of this paper are the following a novel solution that introduces continuous merging inside the ide much like to continuous compilation an empirical evaluation which provides quantitative and qualitative evidence that our solution improves early detection of conflicts when compared with existingapproaches based on change and dependency based awareness.
subsequent sections are summarized as follows.
section ii motivates the need to detect conflicts early.
section iii explains the limitations of existing awareness approaches to this problem and section iv describes our solution.
section v presents the implementation of our solution in eclipse and section vi reports an empirical evaluation that sustains our solution.
section vii lists the related work and section viii concludes.
ii.
m otivation the need to detect conflicts early was determined by industry and research and it is illustrated next.
suppose that mike anne and bob check out the same working copy of the zoo application from their mainstream version control system vcs .
mike changes class mammal to extend animal and commits.
simultaneously anne creates class primate by extending mammal and adds primate.move int x int y to move primates to location x y .
then she does a clean merge with mike s changes at the head of the repository and commits.
meanwhile bob adds method animal.move int dx int dy to move animals by some distance from their current location updates his working copy with mike s and anne s changes at the head and finally commits.
note that all vcs merges were clean because the developers changed different files though a merge conflict exists in the final state at the head shown in fig.
.
animal px int py int move int dx int dy mammal primate x int y int move int x int y figure .
the final merge at the head.
the merge conflict is an unexpected override between the methods added by anne and bob and at runtime it will cause the following bug when method animal.move int dx int dy is invoked on a primate this will move to location dx dy instead of moving distance dx dy from its current location as expected for all animals.
note that this conflict is very difficult to find.
only bob could detect it since after merging mike s and anne s changes from the head only his working copy has the conflict.
nevertheless the vcs told him that the merge was clean so he does not suspect his co workers changes.
besides he had to merge other files making him overlookthose of mike and anne.
he even had a test for animal which ran successfully before he checked in.
however it did not consider primates because bob did not know about that class when he wrote the test.
or all he wanted was to rush his check in.
unfortunately the bug will enter production and further developments will be made on top of broken code.
eventually the bug will be found and the developers will have to resolve it.
they will have to remember what they did before determine the impact of the bug on other parts of the code and decide what to do.
all this certainly takes time because the changes are no longer fresh in their minds.
at least they will have to remove one of the duplicated points rename one of the move methods and change where in the code there are dependencies on the removed point and renamed method.
although simple this example shows that conflicts can be difficult to detect and are costly to resolve when found late.
iii.
p roblem would it not be helpful to detect the above conflict as it emerges during programming and avoid all that rework?
awareness defined as an understanding of the activities of others which provides a context for your own activity has been suggested to help developers detect conflicts early .
in general these proposals use presence and change awareness.
presence awareness informs where others are looking in the code which may be useful to find co workers for collaboration though it does not help with conflict detection.
change awareness informs where changes are being made in the code which may help detect conflicts early.
however reporting which files types or program elements are being changed may overload developers with notifications that are irrelevant to what they are .
some of these tools use dependency based awareness and notify when two files types or program elements connected by a path of dependencies e.g.
extends and calls with length n have been simultaneously changed by the developer and a co worker.
their idea is to reduce the number of notifications to help developers focus on the most relevant ones which may indicate a conflict with co workers.
for example instead of notifying concurrent changes in every file some tools only notify concurrent changes to the dependencies of files changed by the developer.
notwithstanding dependency based awareness does not prevent developers from being overloaded especially when the choice of granularity in the tool is that of file or type level for example it causes false direct conflicts n and false indirect conflicts n because of concurrent changes to independent program elements in the same type or dependent types respectively.
in addition developers still have to investigate the notifications to determine if theybear any conflict thus stealing time from programming.
unfortunately it can be difficult for developers to detect conflicts by themselves because of the complex interdependencies between program elements like polymorphism and late binding.
for example in fig.
it is unlikely that mike upon receiving the notifications primate mammal and mammal animal would be able to correlate them to discover an unexpected override especially if he is busy and tired of irrelevant notifications.
iv.
s olution our solution continuously merges all uncommitted and committed changes inside a software team to create a background system that is analyzed compiled and tested to precisely and accurately detect conflicts on behalf of developers before check in.
this introduces the case for continuous merging inside the ide similarly to the current experience of continuous compilation.
a. collaborating inside teams the model of our solution is that of a team of programmers working along a development line orbranch in a vcs as shown in fig.
.
outside collaborators development lineanne bob merged system figure .
the team model.
ateam comprises a set of members e.g.
anne and bob a development line and a special system that merges all uncommitted changes of the members and those committed in the development line called the merged system .
in addition the team s development line and its members may receive code from the outside that is from other programmers or teams participating in a major joint development.
code exchanges with outside collaborators go in both directions.
however we are only interested in those incoming to the team.
they also follow project specific policies that are not relevant to discuss in this paper.
the first member creates the team and associates it with the development line.
this initializes the merged system with a copy of the system at the head of the development line .
at any time members may join and leave the team which continues to exist until the last member leaves.
members modify their working copies of the system in the development line using common vcs operations check out modify update merge check in pull andpush.
this copy modify merge process generates a flow of changes from all members and the head which are then sent to update the merged system in the background.
changes in working copies are captured when files are saved and sent automatically or manually.
the last allows members to control when their changes are transmitted as for example when they are stable enough to be shared.
note that whether automatic or manual transmission only occurs if the working copy has no compilation errors so the merged system will not be affected by syntactic errors due to invalid files.
additionally members leaving the team cause their changes to be removed from the merged system.
changes in the head check ins are processed automatically.
unlike before where the model is able to ensure that changes are only transmitted if files are syntactically valid here the team should follow the recommended practice to forbid compilation errors from entering the development line which can be easily supported by modern ides and vcses e.g.
via pre commit hooks .
this model is very flexible and supports mainstream vcses and their workflows found today in practice.
b. merged system albeit physically made of folders and files the system under construction and the merged system are abstractly modeled as a tree of typed and attributed nodes like in fig.
for the part that constitutes the file primate.java.
zoo animals folder primate.java file package zoo.animals primate class visibility public extends mammal x field visibility private type int initval y field visibility private type int initval move int int method visibility public type void body .
.
.
figure .
the abstract model of the system.
every folder file and program element inside a file is a node having a type and a set of attributes none for folders in the system s tree.
the possible types and attributes are specified by the domain which in the figure is that of java.
this system model allows us to compare two states of a file to determine differences at node and attribute level.
this is important to track the changes made to the nodes andtheir attributes by every member and at the head which are used for background merging and to find members to report conflicts.
members changes are computed by comparing working copy files with their bases in the development line while head s changes are computed by comparing successive file states at the head.
in addition the model is extended with edges not shown for clearness representing dependencies between program elements like the extends dependency from primate to mammal .
thus it forms an abstract semantic graph used for analysis of the merged system explained later .
the merged system is updated in the background by merging the most recent changes using structural merging .
this collects the changes of each node in the system s tree merges them and returns the new merged state which is used to rewrite the node in the merged system.
this is done for every recently changed node in the system s tree thus resulting in an updated merged system.
structural merging allows fine grained merges of source files to be done automatically in places where a textual merge would require manual intervention.
for example changes to different program elements or attributes of a program element in the same line of a source file are merged automatically contrasting with a conflict on the line given by textual merging.
for example fig.
shows the changes made by anne and bob in their working copies of a base file f.java the rectangles and strikes and the resulting file in the merged system.
note that structural merging was able to merge the changes of the attributes of class f and float pi despite being on the same line.
likewise additions of int a and int b at the same line are handled transparently because structural merging recognizes them as different program elements.
the gray color represents temporary resolutions of structural conflicts done in the merged system as explained next.
c. detection of conflicts our solution detects conflicts of different types namely structural language behavior and test conflicts.
structural conflicts these conflicts are detected during background merging and they are temporarily resolved in the merged system using default resolutions to not halt background merging this does not change the code in the working copies.
apseudo direct conflict occurs when different attributes of a node are concurrently changed or the same attribute is simultaneously changed to the same value.
in fact it is a warning that reminds there is no structural conflict but only the possibility of a semantic conflict probably it may be detected as a language conflict see below .
in fig.
this conflict occurs in class f and float pi after anne and bob changed these program elements attributes.
the attribute change change conflict occurs when the same attribute of a node is concurrently changed to different class f public float pi int q int m return f.java base finalclass f public float pi .
int a int q int m return q f.java anne publicclass f public float pi intb intq intm return f.java bob public final class f float pi .
int a int b int q int m return q f.java merged system figure .
file merging example.
values.
one example is the initval attribute of int q which was changed by anne to and by bob to .
in this case the default resolution is to assign a default value to the attribute in the merged system.
default values are predefined for each attribute type and for int it is zero in gray .
thenode change deletion conflict occurs when there are simultaneous changes and deletions to the same node.
this happened with method m changed by anne and deleted by bob.
in this case the default resolution is to ignore deletions to preserve changes so anne s change prevails in the merged system.
we tested this decision with twenty one graduate students by exposing them to a change deletion situation and they all decided to preserve the change.
the inconsistent node type conflict happens when trying to put nodes of a different type at the same location in the system s tree.
for example a developer adds a file named f.java while another adds a folder named f.java .
if this occurs the default resolution is to remove the node from the merged system.
in practice this bizarre case should never occur but the model supports it.
an important advantage of structural merging is that a direct conflict never occurs when different program elements in a file are changed thus reducing overload by avoiding notifications of false direct conflicts.
note that developers are always alerted to structural conflicts and once they resolve them in their working copies the merged system is updated with their resolution this is why default resolutions in the merged system are always temporary.
language conflicts the merged system is automatically compiled every time it is updated.
we call the resulting compilation errors language conflicts because they are caused by invalid combinations of developers changes withrespect to the static semantics of the programming language.
one example is the invisible method conflict that occurs when a developer makes a method private while another one adds a call to it outside that method s class.
a more complex example is the undefined constructor conflict that occurs when a developer adds a constructor with one argument to a class having no constructors as another developer creates a subclass of that class.
by leveraging the compiler to detect language conflicts we avoid re implementing complex checks of programming language rules we just listen to the compilation output process the errors and report corresponding language conflicts on the user interface see section v .
behavior conflicts these conflicts represent potentially unwanted behavior due to unexpected interactions between concurrent changes.
they are detected after updating the merged system by searching for conflict patterns that is logical conjunctions of facts regarding the program elements and their dependencies in the abstract semantic graph of the merged system which identify unwanted behavior.
the simplest is the dependency based conflict previously discussed in section iii.
its pattern is 9x y2g dep x y where xandyare nodes changed in the graph gand have a transitive dependency dep.
more specialized patterns are generally more interesting because they represent conflicts that are more difficult to find by developers like the unexpected override conflict in section ii which can be found using the pattern 9a b m m22g extends a b method a m method b m equalsignature m1 m2 where ais a super class of b. note that these patterns are deemed as behavior conflicts only if the facts correspond to nodes changed by different team members we omitted this part in the above definitions to avoid complicating them .
an advantage of this model is that conflict patterns can be easily added to support an increasing number of complex behavior conflicts e.g.
unexpected dynamic binding and are reusable across projects.
moreover conflict patterns contrast with tests which have to be designed and only detect conflicts on the features they test.
test conflicts a test conflict is a test that fails after updating the merged system and its execution flow has reached two or more methods changed by different members.
taking the zoo application imagine that anne adds a test to verify if all species have a price returned by method getprice while bob creates class chimpanzee without such method because he is not aware of anne s requirement .
afterwards the merged system is updated with both changes and anne s test fails when verifying the price of chimpanzee as the following execution flow shows zoo.testing.zootests.setup zoo.testing.zootests.testanimalgetprice anne ... zoo.animals.animal.getprice ljava lang class zoo.animals.chimpanzee.getprice bob this results in a test conflict for testanimalgetprice because its execution flow has a method changed by anne the test itself and a method missing in the class created by bob.
in this example the test tried to call getprice via reflection on chimpanzee.
our solution intercepts reflection calls too and checks if missing methods were deleted or never existed which was the case for bob.
consequently this test conflict is named missing method conflict .
tests are very useful to detect conflicts involving reflection which are hard to find using conflict patterns.
d. reporting conflicts each conflict is reported to the members that changed the node or nodes affected by it.
for structural conflicts the affected node is that at the location of the conflict in the system s tree for language conflicts the affected nodes are the ones involved in the compilation error for behavior conflicts they are those that match the corresponding conflict pattern and for test conflicts they are the nodes which represent the methods in the failed execution flow.
only the members that changed the affected nodes and their attributes are notified of the conflict.
such members are found by looking for who changed the affected nodes in the node change tracking information.
v. i mplementation in eclipse our tool called wecode implements our solution for java programming inside the eclipse ide.
wecode has both client and server plugins and at the moment it supports subversion a. the server this plugin runs on equinox and is responsible for managing teams it handles members joins and leaves tracks their changes to the system s tree does background merges and updates the conflicts affecting the team.
each team holds a project inside equinox containing the code of the team s merged system.
this is updated every time changes are received from client plugins or from checkins in the team s development line which is monitored by the server.
the merged system is automatically compiled by the eclipse java tools installed in equinox.
the server listens for marker deltas imarkerdelta corresponding to 1subversion was our first choice because it had the best plugin for eclipse when we started development.
currently we plan to support other vcses like git and mercurial figure .
continuous merging inside the ide.
errors in the compilation output to update the language conflicts affecting the team.
at the same time the server compares the previous and the updated states of the merged system to determine how it was modified during background merging.
this is done to find out which conflict patterns need to be verified to update the behavior conflicts affecting the team.
in what concerns the detection of behavior conflicts we leverage the abstract semantic graph implemented by the eclipse java tools to look for instances of conflict patterns in the merged system.
test conflicts are found by running junit test cases after updating the merged system.
to support this we created modified versions of the org.eclipse.junit.
fcore runtime g plugins to collect the execution flows of running test cases.
in particular we have a version of class remotetestrunnerclient core plugin installed on the server jvm and a version of class remotetestrunner runtime plugin installed on the test jvm which opens a socket connection to the server and sends back the results as tests are run.
the server launches the test jvm with an agent library that instruments the methods entry points in all loaded classes except those of the java runtime junit and equinox eclipse with code that logs method calls.
test execution flows are then collected by logging the method calls between each test start and end.
every conflict detected by the server contains a detailed message that describes what happened the affected programelements and the affected members that have modified those elements thus speeding up conflict resolution on the client side.
all conflict updates are sent to the client plugin of affected members.
b. the client this plugin collects changes to folders and files in the developer s working copy by listening to events sent by the subversion plugin and the eclipse ide and sends them to the server.
in addition it receives from the server the latest changes of other members and the most recent conflict updates.
all these sends and receives are automatic or by developer s request.
the client plugin also offers the following two views that constitute the main of wecode s user interface.
the team view following fig.
this view lists all members in the team including the head and details their changes to folders files and program elements down to fields and methods.
this view has buttons that developers may use to publish their changes and receive updates within their team located in the server at the url .
the team view uses red and yellow icons to mark files simultaneously changed by the developer and other members.
the red icon alerts that there are structural conflicts other than pseudo inside the file while the yellow icon indicates that even though they modified the same file none or only pseudo direct conflicts exist.
this color scheme avoids developers wasting time investigating notifications by helping them focus on urgent files.
in addition the iconsare kept minimal to avoid overloading the user interface we only show them in the developer s subtree and at folder and file nodes.
supporting icons for other conflict types or at finer grained nodes might be distracting in this view but we need to investigate it further.
developers can use this view to compare and exchange code among them or between them and the head.
for example they can access the file compare editor of any file node to integrate other members changes so that they resolve conflicts while changes are fresh in their minds or stay updated with the most recent code within the team.
they can also use a chat view2to ask other members if their changes are already stable thus avoiding merging unfinished code.
for instance a true direct conflict red icon can be collaboratively resolved by merging other members changes publishing the locally merged file and asking those members to accept the merged file thus turning the icon yellow.
the team merge view this view lists all language behavior and test conflicts affecting the developer which in the figure are those already introduced in the paper.
every conflict has a detailed description that reports its nature the affected program elements the affected members and how these changed the affected elements.
the description results from instantiating the placeholders of the conflict s template.
for example the template for tests conflicts includes the message returned by the failure which for the test case in the figure is the message in assertnotnull price not ... .
developers can double click a conflict in the team merge view to quickly jump to its location which can be a program element or a statement inside a method.
in addition conflicts are signaled in the package explorer and inside editors at their location in the affected files for an example of a conflict at statement level see line of fig.
in .
all the information is unobtrusively presented to developers in a way that resembles the continuous compilation experience in eclipse s problems view.
with these features the team merge view helps developers speed up resolution instead of wasting time investigating many change notifications to detect conflicts as discussed back in the problem section section iii .
c. preparing for the evaluation to support the evaluation of our tool we created an additional view called team alerts which uses dependency analysis to offer a heuristic mode of conflict detection similar to those in .
this view notifies the developer about co workers changes to the apis referenced by files modified by the developer.
the notifications are listed for the file selected in the package explorer or opened in the active editor.
2the collaboration view in eclipse ecf figure .
team alerts view showing notifications for feline.java.
figure .
notifications are signaled in the package explorer view.
for example fig.
lists the notifications for feline.java.
the red icons alert that a co worker changed program elements used in feline.java whereas the yellow icons alert for changes to unused program elements in types referenced by feline.java.
the notifications may be double clicked to open an editor to compare the co worker s file that in the resource column with its corresponding local file.
the icons are also shown for files in the package explorer red icons win to alert developers when they are focused somewhere else as shown in fig.
.
vi.
e valuation the evaluation here described shows that our solution does not overload developers with notifications and improves early detection of conflicts when compared to existing approaches based on change and dependency based awareness.
a. experimental design to show this we ran several controlled user experiments comprising three treatments that correspond to different levels of support for conflict detection the repository had no support the heuristic was supported by the team alerts view and the merge used the team merge view.
using this scheme we wanted to assess the number of conflicts detected in each treatment before check in and the notification overload this one for the last two treatments .
the experiments involved twenty one graduates in computer engineering from our university one half being recent bachelors and the other being phd students having enough experience with the tools used in the experiment namely eclipse java and subversion.
the experiment was ran once for each team comprising one subject and one confederate the experiment host .
the teams were randomly assigned into the treatments so that the number of bachelors and phds was the same for all treatments.
subjects were told they were going to be studied on how they managed conflicts between concurrent programming tasks modifying the zoo application a total of classesand locs which was sent to them at least two days before their session.
at the beginning of their experiment they watched a treatment specific video showing the tools using a conflict that would not occur during their session.
then they were given a guide with six tasks and the code to type in each task.
they were told to follow the task order and say aloud when a task started or finished and when a conflict was detected.
all sessions were recorded with prior subject agreement.
at the end a questionnaire containing point likert scale and free response questions was given.
all this was designed so that each experiment took less then one hour and thirty minutes.
the confederate followed a list of concurrent tasks which inserted the following indirect conflicts at about the same time for all subjects two undefined constructor conflicts language one unexpected override conflict behavior and one missing method conflict test .
all conflicts were inserted before subjects had finished half of their work so that they had enough time to detect them before the end.
the confederate also checked in after every task in the repository case this was unnecessary in the other cases because the tool was configured to automatically publish changes to the team s server.
b. results quantitative analysis table i shows the number of conflicts detected d and not detected nd in each treatment before subjects checked in at the end of their tasks a conflict was considered detected when merge subjects said they had seen it in the team merge view and when heur.
repo.
subjects said something like i think there is a problem i changed this and my co worker changed that and the problem was a conflict.
what is the effect of the awareness mode on the ability of developers to detect conflicts early?
table i shows that repo.
subjects found none of the conflicts before check in.
only one subject synchronized frequently with the repository but he only looked for direct conflicts at file level.
in general all repo.
subjects were observed during check in to pay attention only to those files that they and the confederate also changed thus missing the indirect conflicts.
the heur.
subjects did better but most only detected conflicts after importing changes from their co worker mainly to stay updated with the most recent code as one said thus producing a compilation error in their working copies that caught their attention.
only one succeeded in finding the unexpected override conflict by correlating the additions of two methods in the hierarchy.
in contrast merge subjects were able to detect all conflicts early on given the detection capability provided by this mode.
in general they started resolution at their best opportunity generally between their tasks and only then they decided to import from their coworker as needed to resolve the conflicts.table i number of conflicts detected in each treatment .
the effects of the treatments are statistically significant according to pearson 2test p .
merge heur.
repo.
pearson 2df p d .
.
nd the results in table i provide evidence that repository support and dependency based awareness are not sufficient to support early detection of indirect conflicts and that the continuous merging approach has greater potential.
qualitative analysis table ii shows the scores of the likert questions in the questionnaire.
q1 s scores show that subjects had a very different perception about the number of false positives presented in the two modes which is consistent with the kind of support in these modes.
q2 s scores express a strong wish of being informed about conflicts during programming and interestingly the subjects that scored higher in such feature were those who experienced it thus reinforcing the usefulness of continuous merging.
when asked to justify their score the subjects responded we could avoid spending too much time resolving conflicts at the end .
additionally it would help resolve conflicts while we still remembered the code where they happened.
heur.
q2 allows to manage conflicts as they occur and does not let changes grow.
merge q2 it allowed me to reduce the time to resolve conflicts instead of a slow commit later.
merge q2 regarding this question one said i did not give maximum score because i occasionally paused my work to check if the conflict was important to resolve right away merge q2 and another said early detection is crucial to avoid wasting too much time during resolution.
although it may cause distraction i believe with practice it is possible to manage distractions heur.
q2 .
in general subjects were able to manage interruption by paying more attention to awareness information after file saves and between tasks.
still we think interruption management requires further research.
q3 s scores summarize subjects overall experience with the awareness modes in our tool suggesting they really appreciated knowing what was happening around them that would help coordinate with others.
the questionnaire ended by asking subjects to express their opinion about the tool and suggest improvements i liked to know in real time who was changing the code i was using and where heur.
i appreciated being informed about remote changes with different levels of severity heur.
table ii questionnaire scores in point likert scale s trongly disagree s trongly agree .
t he values are shown as mean std.dev.
and n.a.
for not applicable .
merge heur.
repo.
q1 the mode s view listed many false positives that is alerts not corresponding to real conflicts thus distracting me.
.
.
.
.
n.a.
q2 i liked would like to be informed about conflicts while i am programming instead of being warned only later at check in.
.
.
.
.
.
.
q3 i would use this mode s view and recommend it to other colleagues.
.
.
.
.
n.a.
some changes that appeared as yellow at the beginning revealed to be problematic heur.
i liked less the fact that the tool did not signal the potential compilation error due to the concurrent addition of constructors heur.
i liked the icon in the editor informing me about the conflict and with whom i was conflicting merge i liked most its simplicity of use merge i liked tests being run on the merge of the code of the entire team merge this qualitative part shows that subjects deeply appreciate being informed about conflicts during programming and that there is a tendency to favor continuous merging.
c. threats to validity every experiment is challenged by threats to its construct internal and external validity.
construct validity we think that the application tasks conflicts and questionnaires used in our study are valid by construction to evaluate our tool and the effect of the different awareness modes on the ability of developers to detect conflicts.
subjects also knew nothing about which conflicts would occur or that our tool was being evaluated so as to avoid influencing them.
internal validity the confederate was used to prevent confounds caused by varying behaviors of genuine coworkers that might have influenced subjects behavior.
the subjects also had no previous experience with our tool so there were no learning effects on their performance and we neutralized programming skills as much as possible by giving the code to type in each task.
the best we could do to avoid personal characteristics e.g.
curiosity from confusing the results was to randomly select subjects into treatments.
as such we think our study has internal validity.
external validity the major threat to the generalization of our study s results is that changing a simple application like zoo by typing pre written code is not representative of real practice.
regarding this our study didnot cover aspects due to the complexity of real software development which may influence how programmers use and benefit from a conflict detection tool.
these include project aspects like size and geographical distribution and tool aspects such as usability and interruption management so studies in real projects are needed.
our study might be threatened because of our choice of conflicts.
the results show that our solution performs better than others for the chosen conflicts.
however we think that it will not perform worse for other conflicts especially due to its detailed detection capability.
even though we need to understand the kind of merge conflicts occurring in real projects it is reasonable to assume that indirect conflicts will be at least as complex and hard to detect as those in the study so we think our automatic conflict detection solution will be advantageous in practice.
in addition our choice of tasks might be threatened in terms of the false positives they did or did not generate despite our efforts to avoid bias in any way.
the use of students seems reasonable considering one study reporting students and professionals have no major difference in understanding dependencies and relationships in software which is important to find conflicts between concurrent changes.
to sum up our results are indicative of the benefits of our solution and suggest that a longitudinal study in the industry is necessary to ground a theory of awareness of software conflicts.
vii.
r elated work this section outlines several tools related to our work which provide awareness of software changes.
tools that provide awareness of direct conflicts at file granularity may overload the developer because of changes to independent program elements inside the same files .
a fine grained solution like ours does not have this shortcoming.
other tools go beyond these and support dependencybased awareness.
tukan signals developers with the presence of co workers and the changes they made in elements near a dependency path from the element focused on by the developer.
presence signals help find co workers for collaboration and change signals help prevent direct and indirect conflicts.
signals are ranked according to a dynamic function of path length and relevance which by default emphasizes more the shorter paths as these are assumed to connect elements having a stronger dependency.
this tool does not have a place where all signals are listed so developers are expected to contact co workers or to inspect concurrent changes once they see a signal of interest before making changes to the focused element otherwise it can be difficult to remember where signals exist in the code for later investigation.
collabvs provides presence awareness and notifies about direct and indirect conflicts involving elements connected by an unlimited dependency path.
there is no rankingmechanism to help developers focus on the most interesting notifications.
developers can select the element granularity at which conflicts are detected to that of file type or method but in practice it can be difficult to determine which works best at each moment .
developers upon receiving a notification may set a watch on the element edited by the co worker to remind the developer to check for conflicts after some time or after the co worker removes focus from the element.
however this mechanism may provoke disturbance since watches need to be requested to co workers timeouts can be hard to set properly and coworkers may enter and leave elements frequently.
palant r notifies an indirect conflict when a file modified by the developer depends on a file that had its public apis altered by a co worker.
its main focus is on syntactic indirect conflicts.
notifications carry the modifications to the public apis of types in remotely changed files.
in addition a notification is a bomb if there is a dependency on a code element type or method that had its public signature edited in the remote file otherwise they are just a warning of possible interesting changes to the remote file s public apis.
this inspired our design of wecode s team alerts view.
notifications are also red or yellow respectively when the remote file was checked in or is still being changed by a co worker.
this tool does not support indirect conflicts involving remote files not present in the developer s working copy these are files created by co workers or that the developer did not check out.
both collabvs and palant r do not notify conflicts involving check ins bypassing the tool or done before developers checked out via the tool.
this is supported by wecode s model of team work in a development line.
all the above tools only support direct conflicts and dependency based indirect conflicts.
in addition developers must investigate notifications to determine if conflicts really exist.
in contrast wecode considers the unpredictable semantics that result from merging the changes to an objectoriented system made by a whole team.
besides using analysis wecode uses a merged system to detect complex conflicts via compilation and testing which is a feature that awareness tools like the above do not provide.
for example testing can detect conflicts which are very hard or undecidable via analysis like involving code reflection.
yoohoo reports api changes that may break the code or that are of interest to the developer as determined by the dependencies within the files owned recently committed or selected by the developer.
this tool is not designed to detect conflicts but to help developers adapt their code to the evolution of apis in external projects or in branches of sub teams within a large team.
crystal does separate background merges of pairs of repositories comprising that of the developer and that of a co worker or a central master.
the result is one of textual merge failure build failure tests failure or testspassed relationship for each repository pair.
this tells each pair of developers if their mutual merge is problematic but does not tell them which conflicts are exactly occurring so they have to interrupt their work and spend time discovering conflicts.
in contrast wecode does a single background merge of all developments of a team working on the same branch and informs inside the ide about the precise details of the conflicts affecting the team as a whole.
this allows us to catch complex conflicts involving two or more developers and avoids duplication of awareness icons caused by the same conflict in multiple merged repository pairs.
wecode does not distract developers because of textual merge failures that are easily handled via structural merging.
our solution also supports uncommitted changes so conflicts can be found as soon as developers want to be informed.
three studies compared support for early conflict detection against not having such support .
like them we concluded that users like to have support for early conflict detection but unlike them our study also compared two support levels.
viii.
c onclusion and future work the problem of merge conflicts in collaborative programming is an important one as they are known to cause software defects.
the industry and research recognize this problem and that a conflict detected earlier is much easier to resolve than when detected later at check in or production.
awareness has been proposed to help developers detect conflicts earlier.
however all known approaches require developers to detect conflicts by themselves and may overload them with notifications hence making detection difficult.
we have proposed a novel solution that precisely and accurately detects conflicts on behalf of developers thus avoiding overloading them with notifications.
it introduces the notion of continuous merging inside the ide which enables earlier resolution of conflicts while developers still have their changes fresh in their minds making resolution easier.
an empirical evaluation confirmed that our solution improves early detection of conflicts and avoids overloading developers in comparison with existing approaches.
there are several directions for our future work.
first we will continue improving wecode s collaborative features and usability.
second we want to do a longitudinal study with professional programmers in an industrial setting to determine the influence of continuous merging in their software process and to check if new collaborative patterns emerge.
third we want to measure the overall effect of continuous merging on software quality.
acknowledgment the first author was supported by fct scholarship sfrh bd .
this work was also supported by fct inesc id multiannual funding through the piddac program funds.