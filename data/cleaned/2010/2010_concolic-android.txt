automated concolic testing of smartphone apps saswat anand georgia tech saswat gatech.edumayur naik georgia tech naik cc.gatech.eduhongseok y ang university of oxford hongseok.yang cs.ox.ac.uk mary jean harrold georgia tech harrold cc.gatech.edu abstract we present an algorithm and a system for generating input events to exercise smartphone apps.
our approach is based on concolic testing and generates sequences of events automatically and systematically.
it alleviates the pathexplosion problem by checking a condition on program executions that identi es subsumption between di erent event sequences.
we also describe our implementation of the approach for android the most popular smartphone app platform and the results of an evaluation that demonstrates its e ectiveness on ve android apps.
categories and subject descriptors d. .
testing and debugging symbolic execution testing tools keywords gui testing testing event driven programs android .
introduction mobile devices with advanced computing ability and connectivity such as smartphones and tablets are becoming increasingly prevalent.
at the same time there has been a surge in the development and adoption of specialized programs called apps that run on such devices.
apps pervade virtually all activities ranging from leisurely to missioncritical.
thus there is a growing need for software quality tools in all stages of an app s life cycle including development testing auditing and deployment.
apps have many features that make static analysis challenging a vast software development kit sdk asynchrony inter process communication databases and graphical user interfaces guis .
thus many approaches for analyzing apps are based on dynamic analysis e.g.
.
a question central to the e ectiveness of any dynamic analysis is how to obtain relevant program inputs.
the most indivisible and routine kind of inputs to an app are events .
a permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.tap on the device s touch screen a key press on the device s keyboard and an sms message are all instances of events.
this paper presents an algorithm and a system for generating input events to exercise apps.
apps can have inputs besides events such as les on disk and secure web content.
our work is orthogonal and complementary to approaches that provide such inputs.
apps are instances of a class of programs we call eventdriven programs programs embodying computation that is architected to react to a possibly unbounded sequence of events.
event driven programs are ubiquitous and besides apps include stream processing programs web servers guis and embedded systems.
formally we address the following problem in the setting of event driven programs in general and apps in particular.
branch coverage problem given a constant bound k e ciently compute a set of event sequences that execute each branch of an event driven program that can be executed by some event sequence of length up to k. the above problem poses two separate challenges how to generate single events and how to extend them to sequences of events.
we next look at each of these in turn.
generating single events.
existing approaches for generating all events of a particular kind use either capturereplay techniques to automatically infer a model of the app s gui or model based techniques that require users to provide the model .
these approaches have limitations.
capture replay approaches are tailored to a particular platform s event dispatching mechanism but many apps use a combination of the platform s logic and their own custom logic for event dispatching.
for example where the platform sees a single physical widget an app might interpret events dispatched to di erent logical parts of that widget di erently.
in contrast model based approaches are generalpurpose but they can require considerable manual e ort.
in this paper we present a new approach which is both general and automatic to address this problem.
the approach builds on a systematic test input generation technique called concolic testing also known as dynamic symbolic execution which has made signi cant strides in recent years.
our approach symbolically tracks events from the point where they originate to the point where they are ultimately handled.
the approach is thus oblivious to where and how events are dispatched.
generating event sequences.
our concolic testing approach for generating single events can be extended naturally to iteratively compute sets of increasingly longer sequences of events.
an algorithm hereafter called allseqs can generate all event sequences of length up to ksuch that each event sequence executes a unique program path.
however allseqs does not scale as the value of kis increased because typical programs have a large number of program paths.
for instance for a simple music player app written for the android mobile app platform allseqs generates one event sequences two event sequences three event sequences and 21k four event sequences.
this problem is known as the path explosion problem and in practice allseqs may fail to solve the aforementioned branch coverage problem within a time budget for a high value ofk.
although several techniques have been developed in recent years to address the path explosion problem e.g.
the problem is still intractable for realworld software.
in this paper we present a new technique acteve stands for a utomated c oncolic t esting of eve ntdriven programs to alleviate the path explosion problem.
acteve is tailored to event driven programs such as smartphone apps.
the key insight underlying acteve is a notion of subsumption between two event sequences.
if an event sequence issubsumed by another event sequence then acteve avoids generating sequences that are extensions of and instead generates extensions of 0only.
such pruning of results in compounded savings as longer event sequences are generated.
we show that acteve is relatively complete with respect to allseqs .
speci cally acteve covers the same set of branches as allseqs for a given upper bound on the length of event sequences.
acteve computes subsumption between event sequences by checking for simple data and controlow facts of each program execution in isolation.
compared to existing techniques for the path explosion problem acteve has at least four distinctive characteristics that greatly improves its applicability to real world software such as android apps.
first it does not impose any unrealistic assumption e.g.
methods are free of side e ects about the program.
second it does not store and match program traces or program states which can dramatically increase memory overhead.
third it does not require powerful e.g.
support for quanti ers or specialized constraint solvers to reason about path constraints of multiple program paths simultaneously.
fourth it does not require static analysis of real world code that often contain parts that are beyond the scope of static analysis.
despite its above mentioned simplicity in our empirical study acteve produced signi cant savings because subsumption between event sequences exists frequently in real apps.
for example for the previously mentioned music player app using k our algorithm explores only of the inputs out of that allseqs explores.
we have implemented acteve in a system for android apps.
our system instruments and exercises apps in a mobile device emulator that runs an instrumented android sdk.
this enables our system to be portable across mobile devices leverage android s extensive tools e.g.
to automatically run the app on generated inputs and exploit stock hardware in particular our system uses any available parallelism and can run multiple emulators on a machine or a cluster of machines.
our system also builds upon recent advances in concolic testing such as function summariza1acteve can also be used for bounded veri cation of safety properties by converting a given assert e statement to if !e assert false and checking reachability of the assert false statement.tion generational search and satis ability modulo theories smt solving .
we show the e ectiveness of our system on ve android apps.
the primary contributions of this work are as follows.
.
a novel approach to systematically generate events to exercise apps.
our approach based on concolic testing is fully automatic and general in contrast to existing capture replay based or model based approaches.
.
an e cient algorithm acteve to solve the branchcoverage problem.
our key insight is a subsumption condition between event sequences.
checking the condition enables acteve to prune redundant event sequences and thereby alleviate path explosion while being complete with respect to allseqs .
.
an implementation and evaluation of acteve in a system for android apps.
our system is portable exploits available parallelism and leverages recent advances in concolic testing.
.
overview of our approach in this section we illustrate our approach using an example music player app from the android distribution.
we rst describe the app by discussing its source code shown in figure section .
.
we then describe how we generate events to exercise this app section .
and how we extend them to sequences of events section .
.
.
the music player app android apps are incomplete programs they implement parts of the android sdk s api and lack a main method.
when the music player app is started the sdk creates an instance of the app s main activity mainactivity and calls its oncreate method.
this method displays the main screen depicted in figure a which contains six buttons rewind play pause skip stop and eject.
the method also sets the main activity as the handler of clicks to each of these buttons.
the app waits for events once oncreate nishes.
when any of the six buttons is clicked the sdk calls the main activity s onclick method because the main activity was set to handle these clicks.
if the eject button is clicked this method displays a dialog depicted in figure b that prompts for a music le url.
if any of the other buttons is clicked the onclick method starts a service musicservice with an argument that identi es the button.
the service processes clicks to each of the ve buttons.
for brevity we show only how clicks to the rewind button are processed in the processrewind method.
the service maintains the current state of the music player in mstate .
on start up the service searches for music les stored in the device and hence the state is initialized to retrieving .
clicks to each button have e ect only in certain states for instance clicking the rewind button has no e ect unless the state is playing orpaused in which case processrewind rewinds the player to the start of the current music le.
.
generating single events our rst goal is to systematically generate single input events to a given app in a given state.
for concreteness we focus on tap events which are taps on the device s touch screen but our observations also hold for other kinds of events e.g.
key presses on the device s keyboard .public class mainactivity extends activity button mrewindbutton mplaybutton mejectbutton ... public void oncreate ... setcontentview r.layout.main mplaybutton findviewbyid r.id.playbutton mplaybutton.setonclicklistener this ... similar for other buttons public void onclick view target if target mrewindbutton startservice new intent action rewind else if target mplaybutton startservice new intent action play ... similar for other buttons else if target mejectbutton showurldialog public class musicservice extends service mediaplayer mplayer enum state retrieving playing paused stopped ... state mstate state.retrieving public void onstartcommand intent i ... string a i.getaction if a.equals action rewind processrewind else if a.equals action play processplay ... similar for other buttons void processrewind if mstate state.playing mstate state.paused mplayer.seekto figure source code snippet of music player app.
our goal is to generate tap events such that each widget on the displayed screen of the app is clicked once.
in android the widgets on any screen of an app are organized in a tree called the view hierarchy where each node denotes the rectangular bounding box of a di erent widget and the node s parent denotes its containing widget.
figure shows the view hierarchy for the main screen of the music player app depicted in figure a .
given this hierarchy we can achieve our goal of clicking each widget once by generating cartesian coordinates inside each rectangle in the hierarchy and outside its sub rectangles.
as we discussed in the introduction existing approaches either infer the hierarchy automatically via capture replay or require users to provide it model based techniques both have limitations.
we present a new approach that is general and fully automatic.
our approach is based on concolic testing and symbolically tracks events from the point where they originate to the point where they are handled.
for this purpose our approach instruments the android sdk and the app under test.
in the case of tap events whenever a concrete tap event is input this instrumentation creates a fresh symbolic tap event and propagates it alongside the concrete event.
as the concrete event ows through the sdk and the app the instrumentation tracks a constraint on the corresponding symbolic event which e ectively identi es all concrete events that are handled in the same manner.
this not only lets our approach avoid generating spurious events but also enables it to exhaustively generate orthogonal events.
for the main screen of our music player app for instance our approach generates exactly tap events one in each of the rectangles and outside sub rectangles in the screen s view hierarchy depicted in figure .
section describes how our approach generates these events in further detail.
a main screen.
b eject dialog.
figure screen shots of music player app.
framelayout1 framelayout2 textview linearlayout2 linearlayout1 bu5on1 rewind bu5on2 play bu5on3 pause bu5on4 skip bu5on5 stop bu5on6 eject figure view hierarchy of main screen.
.
generating event sequences our concolic testing approach for generating single events can be extended naturally to iteratively compute sets of increasingly longer sequences of events.
however as we discussed in the introduction the allseqs concolic testing approach causes the computed sets to grow rapidly for the above music player app allseqs produces oneevent sequences two event sequences three event sequences and 21k four event sequences.
we studied the event sequences produced by allseqs for several android apps and found a signi cant source of redundancy namely that a large fraction of events do not have any e ect on the program state.
we call such events read only because we identify them by checking that no memory location is written when they are dispatched and handled.
upon closer inspection we found diverse reasons for the prevalence of read only events which we describe below.
first many widgets on any given screen of any app never react to any clicks.
as shown in the view hierarchy of the main screen of the music player app figure these include boilerplate widgets e.g.
framelayout and linearlayout which merely serve to layout other actionable widgets e.g.
button and informational widgets that display non editable texts e.g.
textview .
thus only of widgets on the main screen of the music player app namely the six buttons are actionable and clicks to the remaining widgets constitute read only events.
second many widgets that are actionable might be disabled in certain states of the app.
this situation often occurs when apps wish to guide users to provide events in a certain order or when they wish to prevent users from providing unde ned combinations of events.
third gui based programs are conservative in updating state.
in particular they avoid unnecessary updates to suppress needlessly re drawing widgets and notifying listeners.
for instance if an event wishes to set a widget to a state then the event handler for that widget reads the current state of the widget and does nothing if the current state is already e ectively treating the event as read only.
based on the above observations we developed acteve that does not extend event sequences that end in a readonly event.
pruning such sequences in a particular iteration of our approach prevents extensions of those sequences from being considered in future iterations thereby providing compounded savings while still ensuring completeness with respect to allseqs .
we show that the read only pattern is an instance of a more general notion of subsumption between event sequences.
an event sequence that ends in a read only event is subsumed by the same event sequence without that nal event.
for our example music player app using read only subsumption our approach explores four event sequences compared to by the allseqs approach which does not check for subsumption but is identical in all other respects.
besides clicks to many passive widgets in this app e.g.
linearlayout being read only another key reason for the savings is that even clicks to actionable widgets e.g.
button are read only in many states of the app.
for instance consider the two event sequence .
the rst event stop writes to many memory locations e.g.
elds mplayer and mstate in class musicservice shown in figure .
however the second event rewind does not write to any location because the processrewind method of class musicservice that handles this event only writes if the state of the music player is playing orpaused whereas after the rst stopevent its state is stopped .
thus our approach identi es the rewind event in sequence as read only and prunes all sequences explored by allseqs that have this sequence as a proper pre x. section presents a formal description of subsumption the read only instantiation of subsumption and the formal guarantees it provides.
.
generating single events in this section we describe how our approach systematically generates single events.
we use tap events in android as a proof of concept.
tap events are challenging to generate because they are continuous and have more variability than discrete events such as incoming phone calls sms messages battery charging events etc.
moreover tap events are often the primary drivers of an app s functionality and thus control signi cantly more code of the app than other kinds of events.
the principles underlying our approach however are not speci c to tap events or to android.
we begin by describing how android handles tap events.
figure shows the simpli ed code of the dispatchevent method of sdk class android.view.viewgroup .
when a tap event is input this method is called recursively on widgets in the current screen s view hierarchy to nd the innermost widget to which to dispatch the event starting with the root widget.
if the event s coordinates lie within a widget s rectangle as determined by the contains method of sdk class android.graphics.rect then dispatchevent is called on children of that widget from right to left to determine whether the current widget is indeed the innermost one containing the event or if it has a descendant containing the event.
for instance any tap event that clicks on thepause button on the main screen of our example music player app results in testing for the event s containment inpublic class android.view.viewgroup public boolean dispatchevent event e float x e.getx y e.gety for int i children.length i i view child children if child.contains x y if child.dispatchevent e return true return false public class android.graphics.rect public boolean contains float x float y return x this.left x this.right y this.top y this.bottom figure source code snippet of android sdk.
the following widgets in order as the event is dispatched in the view hierarchy depicted in figure .
we also indicate whether or not each test passes framelayout1 yes !
framelayout2 yes !linearlayout2 no !linearlayout1 yes !button4 no !button3 yes .
our approach uses concolic testing to generate a separate tap event to each widget.
this requires symbolically tracking events from the point where they originate to the point where they are handled.
let x y denote variables that our approach uses to symbolically track a concrete tap event x y .
then for each call to contains x y on a rectangle in the view hierarchy speci ed by constants xleft xright ytop ybottom our approach generates the following constraint or its negation depending upon whether or not the tap event is contained in the rectangle xleft x x right ytop y y bottom our approach starts by sending a random tap event to the current screen of the given app.
for our example app suppose this event clicks the pause button.
then our approach generates the following path constraint x y c1 x y c2 x0 x y0 y p1 x0 y0 c3 x0 y0 c4 x00 x0 y00 y0 p2 x00 y00 c5 x00 y00 c6 constraints c1andc2capture the fact that the event is tested for containment in framelayout1and framelayout2 respectively and the test passes in both cases.
the event is then tested against linearlayout2but the test fails notice the negation in c3 .
constraints c4throughc6arise from testing the event s containment in linearlayout1 button4 the skipbutton and button3 the pause button .
we explain constraints p1andp2below.
our approach next uses this path constraint to generate concrete tap events to other widgets.
speci cally for each ci it uses an o the shelf constraint solver to solve the constraint vi j 1cj cifor xand y. if this constraint is satis able any solution the solver provides is a new concrete tap event guaranteed to take the path dictated by this constraint in the view hierarchy.
that path in turn generates a new path constraint and our approach repeats the above process until all widgets in the hierarchy are covered.
condition label l2label input variable a global variable g2gvar fg1 gmg expression e ajgjaop e boolean expression b bop e jtruejfalsej bjb bjb b program s skipjg ejs1 s2j ifbls1elses2jwhilebls figure syntax of programs.
we now explain the role of constraints p1andp2in the path constraint depicted above.
these constraints introduce new symbolic variables x0 y0 x00 and y00.
they arise because as a tap event is dispatched in the android sdk various o sets are added to its concrete xandycoordinates to account for margins convert from relative to absolute positions etc.
the already simpli ed path constraint depicted above highlights the complexity for concolic execution that a real platform like android demands we instrument not only the sdk code shown in figure but allsdk code as well as the code of each app under test.
dropping any of the above constraints due to missed instrumentation can result in the path divergence problem in concolic testing where the concrete and symbolic values diverge and impair the ability to cover all widgets.
.
generating event sequences in this section we describe how our approach generates sequences of events.
to specify our approach fully and to express and prove the formal guarantee of the approach we use a simple imperative language which includes the essential features of android apps.
we begin with the explanation of our language and the associated key semantic concepts sections .
and .
.
we then describe our algorithm proceeding from the top level routine section .
to the main optimization operator sections .
and .
.
finally we discuss the formal completeness guarantee of our algorithm section .
.
appendix b in presents the proofs of all lemmas and the theorem discussed in this section.
.
core language our programming language is a standard while language with one xed input variable aand multiple global variablesg1 .
.
.
gmfor some xed m. a program smodels an android app and it is meant to run repeatedly in response to a sequence of input events provided by an external environment such as a user of the app.
the global variables are threaded in the repetition so that the nal values of these variables in the i th iteration become the initial values of the variables in the following i th iteration.
in contrast the input variable ais not threaded and its value in thei th iteration comes from the i th input event.
other than this initialization in each iteration no statements in the program scan modify the input variable a. the syntax of the language appears in figure .
for simplicity the language assumes that all the input events are integers and stored in the input variable a. it allows such an event inato participate in constructing complex expressions e together with global variable gand the application of an arithmetic operator aop e such asa g. boolean expressionsbcombine the expressions using standard comparison operators such as and and build conditions on program states.
our language allows ve types of programming integer n2 integers global state symbolic global state branching decision d hl truei j hl falsei instrumented constraint c bd path constraint c c1c2 ck concolic state !
h ci input event sequence n1n2 nk set of globals w fg1 gmg trace hc1 w 1i hck wki figure semantic domains.
constructs with the usual semantics skipfor nothing assignments to global variables g e sequential compositions s1 s2 conditional statements ifbls1elses2 with anl labeled boolean b and loops whilebls .
note that although the input variable acan appear on the rhs of an assignment it is forbidden to occur on the lhs.
thus once initialized the value of anever changes during the execution of a program.
note also that all boolean conditions are annotated with labels l. we require the uniqueness of these labels.
the labels will be used later to track branches taken during the execution of a program.
example .
the following program is a simpli ed version of the music player app in our language if g stopped l0f if a play l1fg playing g else if a skip l2fg skipping gelsefskipg gelsef if a stop l3fg stopped gelsefskipg g to improve the readability we use macros here stopped stop playing play and skipping skip .
initially the player is in the stopped state which is the value stored ing but it can change to the playing orskipping state in response to an input event.
when the player gets the stop input event the player s state goes back to stopped .
we write globals e and globals s to denote the set of free global variables appearing in eands respectively.
throughout the rest of the paper we x the input program and the initial global state given to our algorithm and denote them by sinand in.
.
semantic domains we interpret programs using a slightly non standard operational semantics which describes the concolic execution of a program that is the simultaneous concrete and symbolic execution of the program.
figure summarizes the major semantic domains.
the most important are those for concolic states !
input sequences and traces .
aconcolic state !speci es the status of global variables concretely as well as symbolically.
the state consists of the three components denoted by !
!
and!
c respectively.
the component keeps the concrete values of all the global variables while the component stores the symbolic values of them speci ed in terms of expressions.
we require that global variables do not occur in these symbolic values only the input variable ais allowed to appear there.
theccomponent is a sequence of instrumented constraints c1c2 ck where each ciis a boolean expression bannotated with a label and a boolean value.
as for symbolic values we prohibit global variables from occurring in b. the annotation indicates the branch that generates this boolean value as well as the branching decision observed during the execution of a program.
aninput event sequence is just a nite sequence of integers where each integer represents an input event from the environment.
atrace is also a nite sequence but its element consists of a path constraint cand a subset wof global variables.
the elementhc wiof expresses what happened during the concolic execution of a program with a single input event as opposed to an event sequence .
hence if is of length k it keeps the information about event sequences of length k. thecpart describes the symbolic path constraint collected during the concolic execution for a single event and the w part stores variables written during the execution.
as in the case of concolic state we adopt the record selection notation and write i cand i wfor thecandwcomponents of thei th element of .
also we write hc wito mean the concatenation of with a singleton trace hc wi.
our operational semantics de nes two evaluation relations hs n !i !
.
w and hs i .
the rst relation models the run of swith a single input eventnfrom a concolic initial state !.
it says that the outcome of this execution is !
and that during the execution variables in ware written.
note that the path constraint !
crecords all the branches taken during the execution of a program.
if the execution encounters a boolean condition blthat evaluates to true it still adds truehl trueito thec part of the current concolic state and remembers that the true branch is taken.
the case that blevaluates to false is handled similarly.
the second relation describes the execution of swith an input event sequence.
it says that if a program sis run repeatedly for an input sequence starting from a global state this execution produces a nal state and generates a trace which records path constraints and written variables during the execution.
note that while the rst relation uses concolic states to trace various symbolic information about execution the second uses traces for the same purpose.
the rules for the evaluation relations mostly follow from our intended reading of all the parts in the relations.
they are described in detail in appendix a in .
recall that we xed the input program and the initial global state and decided to denote them by sinand in.
we say that a trace isfeasible if can be generated by runningsinfrom inwith some event sequences that is hsin ini .
our algorithm works on feasible traces as we explain next.
.
algorithm acteve takes a program an initial global state and an upper bound kon the length of event sequences to explore.
by our convention sinand indenote these program and global state.
then acteve generates a set of traces of length up to k which represents event sequences of length up tokthat achieve the desired code coverage.
formally satis es two correctness conditions.
.
first all traces in are feasible.
every can be generated by running sinwith some event sequence of length up to k. .
second achieves the full coverage in the sense that if a branch of sinis covered by an event sequence ofalgorithm algorithm acteve inputs programsin global state in boundk .
outputs set of traces of length up to k. f g fori 1to kdo i symex sin in i i prune i end for returnsk i i length up to k we can nd a trace in such that every event sequence 0satisfying i.e.
0j also covers the branch.
the top level routine of acteve is given in algorithm .
the routine repeatedly applies operations symex and prune in alternation on sets iand iof traces of length i starting with the set containing only the empty sequence .
figure illustrates this iteration process pictorially.
the iteration continues until a given bound kis reached at which pointsk i iis returned as the result of the routine.
the main work of acteve is done mostly by the operations symex and prune .
it invokes symex sin in i to generate all the feasible one step extensions of traces in i .
hence symex sin in i f hc wij i 1and hc wiis feasibleg where hc wimeans the concatenation of with a singlestep tracehc wi.
the symex operation can be easily implemented following a standard algorithm for concolic execution modulo the well known issue with loops as we did in our implementation for android.2in fact if we skip the pruning step in acteve and set ito ithere equivalently prune returns simply we get the standard concolic execution algorithm allseqs for exploring all branches that are reachable by event sequences of length kor less.
the goal of the other operation prune is to identify traces that can be thrown away without making the algorithm cover less branches and to lter out such traces.
this ltering is the main optimization employed in our algorithm.
it is based on our novel idea of subsumption between traces which we discuss in detail in the next subsection.
example .
we illustrate our algorithm with the music player app in example and the bound k .
initially the algorithm sets f g. then it extends this empty sequence by calling symex and obtains 1that contains the following three traces of length htruehl0 truei a play hl1 truei fggi htruehl0 truei a play hl1 falsei a skip hl2 truei fggi htruehl0 truei a play hl1 falsei a skip hl2 falsei i trace describes the execution that takes the true branches ofl0andl1.
it also records that variable gis updated in this execution.
traces 0and 00similarly correspond to executions that take di erent paths through the program.
2when sincontains loops the standard concolic execution can fail to terminate.
however symex is well de ned for such programs because it is not an algorithm but a declarative speci cation.f g 0symex !
1prune !
1symex !
2prune !
2symex !
figure simulation of our acteve algorithm.
next the algorithm prunes redundant traces from .
it decides that 00is such a trace lters and sets f 0g.
this ltering decision is based on the fact that the last step of 00does not modify any global variables.
for now we advise the reader not to worry about the justi cation of this ltering it will be discussed in the following subsections.
once 1and 1are computed the algorithm goes to the next iteration and computes 2and 2similarly.
the trace set 2is obtained by calling symex which extends traces in 1with one further step f htruehl0 falsei a stop hl3 truei fggi htruehl0 falsei a stop hl3 falsei i 0htruehl0 falsei a stop hl3 truei fggi 0htruehl0 falsei a stop hl3 falsei ig among these traces only the rst and the third have the last step with the nonempty write set so they survive pruning and form the set .
after these two iterations our algorithm returnss2 i i. .
subsumption for a feasible trace we de ne nal f 0j9 hsin ini .
g which consists of the nal states of the executions of sinthat generate the trace .
let and 0be feasible traces.
the trace is subsumed by denoted v if and only if nal nal .
note that the subsumption compares two traces purely based on their nal states ignoring other information like length or accessed global variables.
hence the subsumption is appropriate for comparing traces when the traces are used to represent sets of global states as in our algorithm acteve .
we lift subsumption on sets t t0of feasible traces in a standard way tvt0 2t 02t0 v .
both the original and the lifted subsumption relations are preorder i.e.
they are re exive and transitive.
a typical use of subsumption is to replace a trace set tnew by a subset toptsuch thattnewvtopt toldfor sometold.
in this usage scenario tnewrepresents a set of traces that a concolic testing algorithm originally intends to extend and toldthat of traces that the algorithm has already extended.
reducingtnewtotoptentails that fewer traces will be explored so it boosts the performance of the algorithm.
why is it ok to reduce tnewtotopt?
an answer to this question lies in two important properties of the subsumption relation.
first the symex operation preserves the subsumption relationship.
lemma .
for setst t0of feasible traces tvt0 symex sin in t vsymex sin in t0 second iftis subsumed by t0 running symex witht0 will cover as many branches as what the same thing withtcovers.
let branch c fdjbd cifor somei2f1 jcjgg algorithm the rprune operation inputs set of traces.
outputs set f jj j j j w6 g the formal statement of this second property appears in the following lemma lemma .
for all sets t t0of feasible traces if tvt0.
sfbranch j j c j 2symex sin in t g sfbranch j j c j 2symex sin in t0 g in the lemma j jmeans the last element in the trace and j j cchooses the ccomponent of this element.
so the condition compares the branches covered by the last elements of traces.
using these two lemmas we can now answer our original question about the subsumption based optimization.
suppose thattoptis a subset of tnewbuttnewvtopt told for sometold.
the lemmas imply that every new branch covered by extending tnewfor the further k steps is also covered by the same thing for topt told.
more concretely according to lemma the extension of tnewfor the furtherk or smaller steps will continue to be v related to that oftopt told.
hence running symex with such extendedtnewwill cover only those branches that can also be covered by the same thing for the similarly extended topt told lemma .
since we assume that the kor smaller extensions of toldare already explored this consequence of the lemmas means that as long as we care about only newly covered branches we can safely replace tnewbytopt even whentoptis a subset of tnew.
.
pruning the goal of the pruning operator is to reduce a set of feasible traces to a subset such that is subsumed by and all strict pre xes of v spre x where spre x f j9 j 0j g. the reduction brings the gain in performance while the subsumption relationship together with an invariant maintained by acteve ensures that no branches would be missed by this optimization.
our implementation of pruning adopts a simple strategy for achieving the goal.
from a given set the operator lters out all traces whose last step does not involve any writes and returns the set of remaining traces.
the implementation appears in figure and accomplishes our goal as stated in the following lemma lemma .
for all sets of feasible traces rprune is a subset of and satis es the condition in .
note that the pruning operator can be implemented di erently from rprune .
as long as the pruned set satis es the subsumption condition in our entire algorithm acteve remains relatively complete meaning that the optimization with pruning will not introduce new uncovered branches.
appendix c in shows another implementation of pruning that uses the notion of independence.
3this condition typechecks because all pre xes of feasible traces are again feasible traces so that the rhs of vcontains only feasible traces.
.
relative completeness fori let symexi sin in t be thei repeated application of symex sin in to a settof feasible traces where the repeated application symex0 sin in t is de ned to bet.
also lift the branch operation to a trace set branch t fbranch i c j 2t i2f1 j jgg theorem completeness .for everyk branch acteve sin in k branch sk i 0symexi sin in f g the rhs of the equation in the theorem represents branches covered by running the standard concolic execution without pruning.
the theorem says that our algorithm covers the same set of branches hence same program statements as the standard concolic execution.
.
empirical evaluation in this section we present the empirical evaluation of our technique.
first we describe the implementation of acteve section .
.
next we present the studies including the subjects used the empirical setup and the study results sections .
.
.
finally we discuss threats to the validity of the studies section .
.
.
implementation the implementation of our system uses the soot framework and consists of lines of java code.
figure shows a data ow diagram of our system.
our system inputs java bytecodes of classes in android sdk and app under test .
java bytecodes of a class are obtained by either compiling its source code as done in our empirical evaluation or converting android s dalvik bytecode into java bytecodes .
our system outputs a set of tests test inputs each of which denotes an event sequence.
the script shown in the inset box is an example of a test that our system can generate.
each line in the script corresponds to an event.
tapgenerates a tap event on the screen at the speci ed xand ycoordinates.
tests similar to the one in this script can be automatically executed using monkey a tool in the android sdk.
tap .
.
tap .
.
our system has four components instrumenter runner concolic testing engine and subsumption analyzer.
we explain each in turn.
instrumenter inputs android sdk and the java class les of the app under test and outputs instrumented sdk app .
this component instruments the java bytecodes of each class of the app under test and any third party libraries that the app uses.
it also instruments classes in the android framework e.g.
android.
but this step is performed only once because the way in which a class is instrumented does not depend on any other class.
instrumenter operates on a three address form of java bytecode produced by soot called jimple.
instrumenter performs three types of instrumentations.
first it instruments app for concolic execution which involves two main steps adds a meta variable eld that stores the symbolic value corresponding to each variable eld inserts a new assignment before every assignment such that the new assignment copies the content of meta variable eld corresponding to the r value of the original assignment to themeta variable eld corresponding to l value of the original assignment.
second instrumenter instruments app to record elds of java classes that are written only during the handling of the last event in the sequence of events corresponding to a test.
third instrumenter ensures that in instrumented sdk app user speci ed method summaries are symbolically executed instead of the original methods.
runner inputs instrumented sdk app .
the rst time the component is called it generates a test randomly thereafter it inputs tests from either the concolic testing engine or the subsumption analyzer.
runner outputs test inputs that includes the randomly generated test and tests that it inputs.
for each of those tests in test inputs it also outputs apath constraint and a write set which are used internally by the other two components.
runner executes instrumented app with the test on an emulator that uses instrumented sdk .
besides these android framework classes no other components of the framework such as dalvik virtual machine of the android execution environment are modi ed.
this feature of our system makes it easily portable to di erent versions of android.
execution of a test generates the path constraint of the path that the apptakes and write set which is a set of elds of java classes that are written during the last event in the input event sequence.
writes to array elements are recorded as writes to one distinguished eld.
runner uses a set of typically emulators each of which can execute a di erent test at any time.
such parallelism enables our system to perform systematic testing of realistic apps.
execution of an app in a realistic environment such as an emulator or an actual device takes orders of magnitude more time than execution of similar desktop applications.
concolic testing engine inputs path constraint of a path and outputs new tests for current iteration .
the component rst computes a set of new path constraints by systematically negating each atomic constraint i.e.
conjunct of the input path constraint as in standard concolic testing.
then it checks satis ability of each of those new path constraints and generates and outputs new tests corresponding to satis able path constraints using the z3 smt solver .
subsumption analyzer inputs write set a set of elds of java classes that are written when app responds to the last event in the event sequence corresponding to a speci c test.
it may output one seed test for next iteration .
subsumption analyzer implements the rprune operator in algorithm .
it outputs the test that corresponds to its input write set ifwrite set is non empty.
the output test is called the seed test because new tests are generated in the next iteration by extending this test with new events.
if write set is empty subsumption analyzer outputs no test.
one important feature of subsumption analyzer is that it can be con gured to ignore writes to a given set of elds.
this feature is useful because in android many events lead to writes to some memory locations which fall into two classes locations that are written to and read from during the same event of an event sequence i.e.
never written and read across events locations that result from android s low level operations such as optimizing performance and memory allocation and correspond to elds of android classes that are irrelevant to an app s behavior.
subsumption analyzer ignores writes to these two classes of writesconcolic tes ng engine subsump on analyzer runner emu emu ... emu emu ... emu emu ... instrumenter test inputs instrumented sdk app android sdk app under test path constraint write set seed test for next itera on new tests for current itera on figure data ow diagram of our system.
because they are irrelevant to an app s behavior in subsequent events of an event sequence.
.
subject apps we used ve open source android apps for our studies.
random music player rmp is the app that is used as the example in section .
sprite is an app for comparing the relative speeds of various 2d drawing methods on android.
translate is an app for translating text from one language to another using google s translation service on the web.
timer is an app for providing a countdown timer that plays an alarm when it reaches zero.
ringdroid is an app for recording and editing ring tones.
.
study the goal of this study is to measure the improvement in e ciency of acteve overallseqs .
first we performed concolic execution for each subject using acteve andallseqs .
we usedk for rmp translate and sprite.
however because allseqs did not terminate for the other two apps when k in our hour time limit we used k for timer and k for ringdroid.
note that acteve terminated for all ve apps even for k .
in this step we used concurrently running emulators to execute tests and compute path constraints for corresponding program paths.
second for each algorithm we computed three metrics .
the running time of the algorithm.
.
the number of feasible paths that the algorithm nds.
.
the number of satis ability checks of path constraints that the algorithm makes.
we measure the running time of the algorithms metric because comparing them lets us determine the e ciency ofacteve overallseqs .
however by considering only running time it may be di cult to determine whether the efciency of our algorithm will generalize to other application domains and experimental setups.
furthermore we need to verify that the savings in running time is due to the reduction provided by our algorithm.
thus we also compute the other two metrics metrics and .
figure shows the results of the study for our subjects.
in the gure the horizontal axis represents the three metrics where each cluster of bars corresponds to one metric.
within each cluster the ve bars represent the corresponding metric running time hours feasible paths x constraint checks x acteve as of allseqsrmp .
.
.7translate .
.
.1sprite .
.
.9timer .
.
.8ringdroid .
.
.2figure results of study running time number of feasible paths explored and number of constraint checks made by acteve normalized with respect to those metrics for allseqs .
for the ve subjects.
in the rst cluster the height of each bar represents the normalized ratio expressed as a percentage of the running time of acteve to that of allseqs .
the number at the top of each bar in this cluster is the running time of acteve measured in hours.
similarly in the second and third clusters the height of each bar represents the normalized ratio of the number of feasible paths explored and the number of constraint checks made respectively by acteve to the corresponding entities for allseqs .
the number at the top of each bar in the second and third clusters is the number of feasible paths explored and the number of constraint checks made respectively by acteve .
for brevity these numbers are rounded and shown as multiples of a thousand.
for example the rst cluster shows the ratio of the running time of acteve to that of allseqs rmp is translate is sprite is timer is ringdroid is .
this cluster also shows that the running time ofacteve is .
hours for rmp .
hours for translate hour for sprite .
hours for timer and .
hours for ringdroid.
the results of the study show that acteve is signi cantly more e cient than allseqs .acteve requires only a small fraction of the running time of allseqs to achieve the same completeness guarantee.
thus usingacteve provides signi cant savings in running time overallseqs .
the results also illustrate why the running time for acteve is signi cantly less than for allseqs acteve explores only .
.
of all feasible paths that allseqs explores acteve checks signi cantly fewer constraints .
.
than allseqs .
.
study the goal of this study is to record the number of paths pruned by acteve because this reduction in the number of paths explored highlights why acteve is more e cient thanallseqs .
to do this we performed concolic execution of each app for k and we recorded the following information for each iteration of acteve andallseqs .
the number of feasible paths that symex explores recall that symex explores new feasible paths.
.
the number of feasible paths that remain after prune .
symex prune symex prune symex prune symex feasible program paths using log scale translate allseqs actevefigure results of study for translate app the number of paths using a logarithmic scale after symex and prune operations in each iteration.
figure shows the results of the study for one subject app the results for the remaining apps are similar and are shown in appendix d in .
in each graph the horizontal axis represents the symex and prune operations performed in each iteration.
the vertical axis shows the number of paths using a log scale.
for example the graph for translate in figure shows that acteve explores paths in iteration .
the subsequent pruning step lters out paths.
thus only the remaining paths are extended in iteration .
in contrast allseqs explores paths in iteration all of which are extended in iteration .
the results clearly show the improvement achieved by the pruning that acteve performs.
first the graphs show thatacteve explores many fewer paths than allseqs and the rate of improvement increases as the number of iterations increases.
for example in the fourth iteration of symex acteve explores paths and allseqs has explored paths.
second the graphs also show that at each iteration of prune the number of paths that will then be extended decreases the descending line in the graphs represents the savings that prune produces.
in contrast the horizontal line for the same interval corresponding to allseqs shows that no pruning is being performed.
.
threats to validity there are several threats to the validity of our studies.
the main threat to internal validity arises because our system is con gured to ignore writes to certain elds that do not a ect an app s behavior see section .
under subsumption analyzer .
we mitigate this threat in two ways.
first our implementation ignores only elds of android s internal classes that are clearly irrelevant to an app s behavior it never ignores elds of app classes third party libraries or elds of android classes e.g.
widgets that store values that can be read by an app.
second we ran our system using the allseqs algorithm that performs no pruning and checked if any ignored eld is written in one event and read in a later event of an event sequence.
most of the elds that our system is con gured to ignore are never read and written across events.
for the few that were we manually con rmed that it is safe to ignore them.
threats to external validity arise when the results of the experiment cannot be generalized.
we evaluated our technique with only ve apps.
thus the e ciency of our technique may vary for other apps.
however our apps are representative of typical android apps considering the problem that our technique addresses.
.
related work memon presented the rst framework for generating running and evaluating gui tests.
several papers e.g.
present components and extensions of this framework.
most existing gui testing approaches either use capture replay to infer the gui model automatically or require users to provide the gui model .
an exception is the work of ganov et al.
which uses symbolic execution to infer data inputs to gui components.
our work also uses symbolic execution but focuses on event inputs.
our techniques for e ciently generating sequences of events are complementary to the above approaches.
signi cant advances have been made in recent years to alleviate path explosion in concolic testing.
these include compositional testing e.g.
using program dependence information to avoid analyzing redundant paths e.g.
using input grammars e.g.
using models of library classes e.g.
or constraint solvers that support higher level program abstractions e.g and using path exploration heuristics that cover deep internal parts of a program e.g.
.
our input subsumption idea is complementary to the above ideas for taming path explosion.
our system indeed leverages some of the above ideas.
it uses method summaries and models for certain android framework classes a grammar to specify input events and state of the art constraint solving provided by the z3 smt solver.
.
conclusion and future work in this paper we presented a technique acteve to automatically and systematically generate input events to exercise smartphone apps.
we described our system that implements acteve for android and presented the results of our empirical evaluation of the system on ve real apps.
the results showed that for our subjects acteve is signi cantly more e cient than the naive concolic execution technique referred to as allseqs .
we have at least three important directions for future work.
first acteve only alleviates path explosion.
the improved e ciency of acteve overallseqs may not be su cient to handle apps that have signi cantly more paths than our subjects.
an example of such an app is one that has many widgets e.g.
a virtual keyboard .
we plan to study other subsumption patterns besides the read only pattern that we currently exploit to tame path explosion.
the independence pattern described in appendix c in is an example.
second our system currently handles only one type of events i.e.
tap events .
there are many other types of events such as incoming phone calls and gestures.
extending our system to handle other types of events will widen its applicability to more apps.
third we intend to conduct a more exhaustive empirical evaluation with more subjects to further con rm acteve s improvement over allseqs .