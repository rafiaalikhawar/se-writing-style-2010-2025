localizing sql faults in database applications sarah r. clark jake cobb gregory m. kapfhammer james a. jones and mary jean harrold georgia institute of technology sclark jcobb harrold cc.gatech.edu allegheny college gkapfham allegheny.edu university of california irvine jajones ics.uci.edu abstract this paper presents a new fault localization technique designed for applications that interact with a relational database.
the technique uses dynamic information specific to the application s database such as structured query language sql commands to provide a fault location diagnosis.
by creating statement sql tuples and calculating their suspiciousness the presented method lets the developer identify the database commands and the program statements likely to cause the failures.
the technique also calculates suspiciousness for statement attribute tuples and uses this information to identify sql fragments that are statistically likely to be responsible for the suspiciousness of that sql command.
the paper reports the results of two empirical studies.
the first study compares existing and database aware fault localization methods and reveals the strengths and limitations of prior techniques while also highlighting the effectiveness of the new approach.
the second study demonstrates the benefits of using database information to improve understanding and reduce manual debugging effort.
i. i ntroduction real world software applications have large and complicated code bases.
as such finding the faults that cause the programs to fail through the process of fault localization can be both time consuming and difficult.
to reduce the time and effort required to locate the faults researchers have developed statistical coverage based techniques to automate the fault localization.
these methods typically select a program entity such as a statement or a branch in the source code and utilize coverage information recorded from program executions along with statistical methods to infer or correlate this entity with program failure e.g.
.
studies performed using these fault localization techniques demonstrate their effectiveness in reducing the code that developers must inspect to locate the fault e.g.
.
yet the programs on which these studies have been performed are relatively small and written in a single language and thus do not consider other important components of the system with which the program interacts.
consequently studies have not evaluated the effectiveness of these existing methods for systems that interact with complex external components.
one such external component is a database an essential part of many software applications .
brooks and colleagues report that the most common types of errors in three real world industrial systems result from data access and handling including interactions between the application and the database.
they also report that another common type of error relates to the way data is passed among subsystems or between the system and the database.
1private correspondence with the authors.
the most common type of database is a relational database 2with which applications interact using the structured query language sql to select update insert and delete data .
not only can sql commands contain control and data dependencies but the results of their executions often determine further calculations and execution paths of the program.
as such these results can potentially propagate the effects of an sql fault to other parts of the application.
existing methods are limited in the information that they can provide to the developer because they do not address applications use of relational databases.
database specific faults include problems with the structure of the database i.e.
schema faults incorrect values stored in the database i.e.
data faults and problems with the sql commands used to query and modify the database i.e.
sql faults .
although the overall goal of our work is to develop techniques capable of localizing all these types of faults our first technique and the one presented in this paper is a new approach to fault localization that targets sql faults.
our database aware method monitors sql commands executed by database applications and uses the observed database interactions to assist in debugging the program in two ways.
first the technique helps developers discover the specific sql calls that are made at runtime which lets developers study and reason about the contents of the commands.
second the technique informs the statistical calculation of the database commands and attributes that are most likely to be the cause of program failures thus giving the developers guidance as to where to focus their attention during testing and debugging.
our technique creates statement sql tuples by combining executed sql command information with program locations i.e.
statements at which these commands are executed.
the method then computes the suspiciousness of each program statement and each statement sql tuple and provides a ranking of them both.
if multiple sql commands are executed at a particular location our technique further decomposes the commands to produce statement attribute tuples and assigns a suspiciousness to each to help the developer identify which part of the sql query is most associated with program failure.
the main benefit of our method is that unlike previous approaches to fault localization it uses database specific information to rank sql commands in the program along with their associated attributes.
thus the technique can help developers locate faults in a database application more precisely than 2a survey of developers that appeared in infoworld in september reported that .
of the respondents indicated that they use relational databases .
u.s. government work not protected by u.s. copyright ase lawrence ks usa213existing approaches that consider only program statements.
another benefit of our technique is that it provides a link between program statements and the sql commands that they executed.
the developer can use this information to discover the sql commands that were generated by the program find errors within these commands and discover the places in the program where they were invoked.
a third benefit of our technique is that it serves as a starting point for additional research on fault localization for both database applications and programs with other kinds of external components such as configuration files and network communication.
thus it can help in addressing the complexities of real world software.
this paper also presents the results of empirical studies that evaluate our technique when applied to three database applications.
the first study investigates how well our database aware fault localization approach performs compared to an existing statistical fault localization technique.
the study reveals that although the existing technique performs well on faults related to the java code it is not always as effective for databasespecific faults.
the second study examines the qualitative value of the additional database specific information that the new method provides to the developer.
this study shows that depending on the database application s structure this additional information can be extremely valuable.
the main contributions of this paper are the first database aware fault localization technique which includes information from sql calls made by the application and thus uses database related information in computing suspiciousness for fault localization.
a prototype database aware fault localization system that provides the developer with a ranked list of suspicious entities as well as details about the sql commands executed by the database application.
empirical studies that compare our new technique with an existing fault localization method and illustrate the limitations of these existing approaches in providing information related to faults in the database commands and the improvement over existing fault localization techniques that can be achieved with database aware approaches.
our results show that at least one such technique the one we present in this paper provides up to .
improvement in fault localization effectiveness over existing non database aware techniques.
such results highlight the need for research in this area.
ii.
r elational databases and motivating example this section presents background on relational databases as well as an example illustrating the limitations of applying existing fault localization techniques to database applications.
a. relational databases the most common type of database is the relational database .
figure shows a simple relational database consisting of one table s ale that records product sales.
database tables have columns or attributes to identify the stored data and rows that contain collections of related data.
the s ale tablesale merchant id customer id product price cat food .
soda .
cheese .
hammer .
nails .
drill .
fig.
a populated database table.
table i sample configuration.
usertype merchant attributes product p rice where clause merchant id userid usertype customer attributes product p rice where clause customer id userid contains attributes merchant id customer id product and price .
the second row in the table is an bracketle t2 soda .
an bracketri htwhere is the merchant id is the customer id soda is the product and .
is the price .
applications use sql to access modify add to and delete data in the database.
sql provides four main commands for interaction with the database select retrieves data from the database update modifies existing data in the database insert adds new data to the database and delete removes data from the database.
b. motivating example the first column in figure contains a code snippet method printproductssold that uses the database table in figure to display sales information about products sold mer chant id customer id product and price .
each time a product is sold a record is added to the database table to reflect the sale.
the method then prints a list of the products sold.
a user of the system can be either a customer or a merchant .
the user classification and the user s customer or merchant number are determined at login.
the method printproductssold receives information for the user requesting the data in usertype anduserid .
for this code snippet the attribute list and the where clause for the sql query are stored externally.
method calls conf.getattributes and conf.getwhere defined elsewhere in the application retrieve the attribute list and where clause respectively from the external configuration for the specified user type and id.
method call printresultset rs also defined elsewhere in the application prints its parameter.
table i shows the initial configuration for the example code snippet in figure .
in the table each user type has its own set of data a list of attributes and a where clause.
the expression userid in each where clause refers to the userid passed into the method calls that get data from the configuration.
the merchant configuration has a fault in the where clause which reads instead of .
the second through eighth columns of figure provide information about the test cases three have merchant as the user type and four have customer as the user type.
the top of each column identifies the user the bullets in the columns indicate which statements were executed by the test case and 214program entities test cases printproductssold string usertype string userid merchant merchant merchant customer customer customer customer suspiciousness string attributes conf.getattributes usertype userid .
string whereclause conf.getwhere usertype userid .
string sql select attributes from sale where whereclause .
preparedstatement ps new preparedstatement .
resultset rs ps.executequery sql .
printresultset rs .
pass fail status f f p p p p p fig.
example program test cases and suspiciousness scores.
the bottom of the column shows the execution results with p representing passed and frepresenting failed.
for example the first test case which uses the inputs merchant and1 executes all of the statements and fails.
existing fault localization techniques that use coverage information about program entities e.g.
statements or predicates utilize a statistical metric to associate each entity with a suspiciousness score.
one example is the ochiai metric suspiciousness s failed s totalf ailed failed s passed s where failed s is the number of failing test cases that execute s totalfailed is the total number of failing test cases and passed s is the number of passing test cases that execute s. other metrics for computing suspiciousness are also based on passing and failing test cases and the coverage provided by them e.g.
.
the last column in figure shows the suspiciousness computed using the ochiai metric for the example code snippet and test suite.
although the example has a fault in the sql query at statement no information is provided by the fault localization technique to help developers identify the faulty query.
in fact considering the suspiciousness values given even statement has the same suspiciousness as the other statements.
this limitation of existing faultlocalization methods the lack of suspiciousness score for the database specific entities motivated the development of our new database aware fault localization technique.
iii.
d atabase a ware fault localization this section defines the terms used for database aware fault localization describes the challenges we encountered while developing our technique and presents a new database aware fault localization method.
a. database interactions sql provides four main commands for interaction with the databases select update insert and delete .
for our purposes we give a name to a statement in the application that invokes the database driver and executes these commands database interaction point.
a database interaction point is a location in the source code where control and data transfer from the application to the database system and back again.
one unique aspect of database applications is the querying and modification process.
we discuss the implications of these database application design choices for fault localization in section iv f. there are two steps in this process building the sql command and executing the sql command.
for an application to build an sql command there are three main approaches applications can construct sql commands within the code such as by creating or modifying a string an external source such as a configuration file or user input can provide the sql command to the application or part of the command can be built in the code and other parts of the command such as attributes can be received from an outside source.
for an application to execute an sql command there are two approaches applications may use many database interaction points to execute the sql commands or applications use one or few centralized database interaction point.
these sql execution patterns are not mutually exclusive an application may contain more of one type or use a more even mixture of both types.
b. database fault localization entities existing fault localization techniques select a program entity such as a statement a branch or a predicate on which to perform the fault localization.
the first challenge we encountered in developing our database aware fault localization technique was to identify an appropriate database entity that would be most useful for fault localization.
our first approach was to localize on database attributes.
using existing statistical metrics such as tarantula and ochiai we calculated the suspiciousness for each attribute used in the sql queries made by the application.
although ranking attributes by their suspiciousness proved to be quite accurate the technique was not able to relate these attributes to the application.
thus this method could not report sufficient information to the developers to locate the fault.
our second approach aimed to address the limitations of the attribute ranking approach by relating the attributes back to the application code.
to accomplish this relationship between attributes and the application we created statement attribute tuples which link each statement with the attributes that it 215executes.
we calculated the suspiciousness of the statementattribute tuples using the same statistical metrics we used in the first approach.
again the rankings were effective in identifying the faulty attribute as suspicious but two new difficulties arose.
first depending on the application many statement attribute tuples received the same suspiciousness score.
second when the sql command was built dynamically or retrieved from a file it was not obvious which sql command had been executed.
without the sql command providing the context in which the attributes were interacting it was often difficult to know how to proceed with the faulty statement attribute tuple.
to provide this context our third approach constructs statement sql tuples.
knowing the sql commands that execute at each statement and computing their suspiciousness scores was successful.
however we lost the information about which attribute in the command was most suspicious.
thus to regain the precision lost in localizing on entire sql commands rather than just faulty attributes we created and present in the next section a technique to leverage the strengths of both the statement sql and the statement attribute approaches.
c. our integrated technique our database aware fault localization technique has two main goals for sql faults to localize on the faulty statement sql tuple or statement attribute tuple and to provide additional information about the sql commands executed by the test suite.
figure gives a dataflow diagram that represents our database aware fault localization technique.
the technique accepts as input an application a a test suite tfora and a database used by a. the technique outputs to the developer the sql execution data and the suspiciousness rankings of statements statement sql tuples and statementattribute tuples for multi sql statements.
instrument application instruments ato produce a an instrumented version of the application.
aperforms the same sequence of operations as a but also records statementcoverage information the sql commands executed and the statement that executed each sql command.
run test cases executes awith test suite t and records and outputs the statement coverage and the executed sql command information.
identify statement sql statement attribute tuples produces statement sql tuples and multi sql statementattribute tuples.
statement sql tuples are defined as the set of an bracketle ts c an bracketri htsuch that for each test case t t the execution produces st which contains the coverage information of each statement sduring execution of t ct which is a set of sql command data tuples an bracketle ts c an bracketri htwhere cis an sql command that was executed and sis the statement that initiated the sql call and pt which indicates whether tpassed or failed.
multisql statement attribute tuples are produced as the set sa t for each test case t tby parsing attributes from the sql commands cfrom each statement sql tuple an bracketle ts c an bracketri htonly when statement shas executed multiple unique sql commands.
3in the dataflow diagram labeled edges represent data and rounded boxes represent the processing of the data.
identify statement sql statement attribute tuplesruntestcasesinstrument application calculate statement suspiciousnesscalculate statement sql suspiciousness compute rankingscalculate statement attribute suspiciousnessexecuted sql statement sql tuplesstatement coveragemulti sql statement attribute tuples statement suspiciousness scoresstatement sql suspiciousness scoresapplicationa testsuitet database developerstatement attribute suspiciousness scores suspiciousness rankingssqlexecution data fig.
database aware fault localization technique.
in the example in figure statement is a multi sql statement because two unique sql commands are executed select pr o d u c t pr i c e from s a l e where me rch an t id ?
select pr o d u c t pr i c e from s a l e where cu sto me r id ?
these commands expand to the four statement attribute tuples an bracketle t5 product an bracketri ht an bracketle t5 price an bracketri ht an bracketle t5 customer id an bracketri ht and an bracketle t5 merchant id an bracketri ht.
calculate statement suspiciousness calculate statementsql suspiciousness and calculate statement attribute suspiciousness produce statement suspiciousness scores statement sql suspiciousness scores and statementattribute suspiciousness scores respectively by employing m the suspiciousness metric.
mcan be any of the existing coverage based suspiciousness metrics such as tarantula or ochiai .
in this case an entity emay be a statement s a statement sql tuple an bracketle ts c an bracketri ht or a statement attribute tuple an bracketle ts a an bracketri ht.
our technique records the number of passing and failing test cases that cover each entity and applies mto obtain the suspiciousness score.
to illustrate consider the example in figure .
when suspiciousness is computed using the integrated database aware fault localization technique with the ochiai metric the suspiciousness of the faulty query at statement i.e.
select .
.
.
m erchant id ?
is .
.
figure 5a shows the result of applying ochiai to the statement attributes tuples and figure 5b reveals the outcome of using the result to inspect a suspicious sql command.
216program entities test cases printproductssold string usertype string userid merchant merchant merchant customer customer customer customer suspiciousness string attributes conf.getattributes usertype userid .
string whereclause conf.getwhere usertype userid .
string sql select attributes from sale where whereclause .
preparedstatement ps new preparedstatement .
resultset rs ps.executequery sql .
an bracketle t5 select p roduct p rice from s ale where m erchant id ?
an bracketri ht .
an bracketle t5 select p roduct p rice from s ale where c ustomer id ?
an bracketri ht .
printresultset rs .
pass fail status f f p p p p p fig.
example program test cases and suspiciousness scores from figure with sql command tuples included.
attribute pass fail suspiciousness product .
price .
customer id .
merchant id .
a attribute suspiciousness at statement .
suspiciousness sql subclause select .
product .
price from s ale where .
merchant id ?
b suspicious sql command attributes.
fig.
expansion of attributes from sql commands at statement in figure .
in the final step compute rankings creates a single list by combining statement suspiciousness scores and statement sql suspiciousness scores.
this step then sorts the list by suspiciousness scores from greatest to least and outputs the suspiciousness rankings.
this ranked list of statements statement sql tuples and statement attribute tuples along with the executed sql command information is then presented to the developer for use in locating the fault.
in the example in figure after sorting the statement sql tuple an bracketle t5 select .
.
.
m erchant id ?
an bracketri htand the statement attribute tuple an bracketle t5 m erchant id an bracketri ht with suspiciousness scores of .
appear as the top ranked entities.
this sql command and attribute are in fact the sources of the fault in this example.
in our example in figure the existing technique was unable to localize the faulty statement.
however our databaseaware technique was able to pinpoint the database interaction point the faulty sql command and the attribute involved in the faulty subclause of that command.
although the sql command in this example is simple for illustrative purposes the additional information provided by our technique can be especially useful when the sql commands are obfuscated or large and complex as they often are in practice.
iv.
e mpirical studies to evaluate our technique we implemented it and performed two empirical studies.
this section discusses the implementation describes the subjects overviews the empirical setup and presents the results of the studies.
a. implementation we implemented our technique in java for use on java database applications.
we modified c obertura 4to provide per test case coverage because the original implementation supports only aggregate test suite coverage.
we used p6s py to capture executed sql commands.
to enable association of sql commands with database interaction points in the program and to identify statement sql tuples we modified p6s py to capture statements that dispatch sql commands.
to identify statement attribute tuples we used a modified version of the u nity parser to create a tool that parses the output of our modified p6s py .
our modifications to the unity parser let the tool parse additional constructs and syntactic variances that occur across sql dialects.
to compute the suspiciousness of program entities our tool collects statement coverage and statement sql coverage and identifies all statements that execute multiple unique sql commands to create the appropriate statement attribute tuples.
the tool then uses this coverage information along with the results of the junit test cases to compute the suspiciousness of every observed entity using the ochiai metric .
the tool sorts the program statements statement sql and statementattribute tuples by suspiciousness to provide a ranking.
finally we use scripts that we created to execute the mutated versions process the data and assess the effectiveness of the technique.
b. subjects for our studies we used three programs itrust jw hois server and m essage switch .
table ii shows the number of lines of java code the number of database tables referenced by the application and the number of database interaction 217table ii subject details.
subject java loc db tables dbi points itrust jw hois server message switch table iii mutants for each subject program.
subject code mutants sql mutants itrust jw hois server message switch points in each application.
the first subject itrust 5which was created as a class project at n. c. state university for teaching testing techniques is a medical application that caters to patients and the medical staff.
itrust uses a mysql database and is predominately written in java.
itrust s database queries are mostly static the majority come from prewritten string literals and are not constructed at runtime.
for our studies we considered only the java portion of the application.
we ran of the junit test cases that accompany the application excluding those that tested the http interface.
the second subject jw hois server 6is an open source whois server implemented in java that includes configuration files velocity templates 7and permits a variety of database dialects to be used.
in our studies we configured jw hois server to use hsqldb.
6unlike itrust jw hois server s database commands are constructed dynamically at runtime from data stored in the configuration files.
we used the junit test cases provided by the application.
the third subject m essage switch is a proprietary application used by a transaction processing company.
the application is implemented in java and uses an oracle 8database.
message switch also includes configuration files and spring templates.7message switch provides its database commands in configuration files completely external to the java code.
to evaluate our technique we ran the junit test cases used by the company to test the application.
for each subject we created single fault mutants and used them as faulty versions of the subject.
we created two types of mutants code mutants contain code faults in the application and sql mutants contain sql faults in the application.
table iii shows the number of mutants for each subject by mutant type.
we manually created the mutants because existing mutation tools are unable to process our subject programs.
we constructed each mutant by applying one of the mutation operators to the original program.
examples of such mutations can be found in section iv e. c. empirical setup for each mutant of the program we identified the faulty entities for each technique instrumented the program to gather sql command and statement coverage ran the test suite and recorded the coverage identified the multi sql database interaction points parsed the sql commands to obtain statement attribute tuples for the multi sql statements calculated the suspiciousness of all monitored entities ranked the entities according to decreasing suspiciousness scores and assessed the effectiveness of the approach.
to facilitate the evaluation we performed the identification of the faulty entities in step differently depending on the type of mutation in the program for code mutants we identified the faults by program statements and for sql mutants we identified the faults by statement sql tuples.
d. study quantitative evaluation the goal of this study is to compare the effectiveness of statement based fault localization techniques that do not provide special treatment of database interactions with our database aware fault localization technique.
to evaluate the effectiveness of a proposed technique previous work in fault localization e.g.
uses a ranking system as well as the percentage of code a developer would not need to inspect by utilizing the ranked results.
we emulated this evaluation approach for this study.
we used the ochiai metric to compute suspiciousness values and rankings for each entity.
we defined the faulty entities for statement based fault localization for code mutants we used the statement containing the mutated code for sql mutants we used either the mutated statement when the mutation occurred within the application code e.g.
a string literal containing sql or the database interaction point where the faulty sql command was executed when the mutation was external to the source code.
we defined the faulty entities for database aware fault localization for code mutants we again used the mutated statement for sql mutants we used the faulty statement sql tuple or statementattribute tuple consisting of the database interaction point and the faulty sql command or attribute respectively.
table iv shows our results the percentage of faults that can be found without examining and of the code.
the data is separated by subject and then by fault type.
sql refers to sql faults code refers to code faults and all refers to the combination of both the sql and the code faults.
the data is also separated by the technique used to calculate the rankings stmt refers to the statement based technique and db refers to the database aware technique.
we found that for itrust the statement based approach did well at localizing both sql and code faults.
specifically .
of the code faults .
of sql faults and .
of all faults were found within the top of the statement rankings.
statement based fault localization also performed well on m essage switch for both types of faults .
of the code faults .
of the sql faults and .
of all faults were found within the top of the statement rankings.
however the approach did not do as well for the sql faults in jw hois server only .
of the code faults .
of the sql faults and .
of all faults were found within the top1 of the statement rankings.
218table iv study results.
subject fault stmt db stmt db type itrust sql .
.
code .
.
.
all .
.
.
jw hois server sql .
.
.
code .
.
.
.
all .
.
.
.
message switch sql .
.
code .
.
.
.
all .
.
.
.
by comparing the results of the statement based approach with the results using our database aware technique we can see that our database aware technique does considerably better for jw hois server especially for the sql faults.
the itrust results for both the statement based and the databaseaware techniques are very similar.
thus there was little room for improvement and our technique succeeded in not degrading the effectiveness.
for itrust .
of the code faults .
of the sql faults and .
of all faults were found within the top of the entity rankings.
for jw hois server .
of the code faults .
of the sql faults and .
of all faults were found within the top of the entity rankings.
for m essage switch .
of the code faults .
of the sql faults and .
of all faults were found within the top of the entity rankings.
e. study qualitative case study the goal of this study is to evaluate the additional benefits of our technique that are difficult to quantify numerically.
we realize that not all developers will debug by stepping through the application one entity at a time in ranked order.
developers may use the rankings to identify sections of code that seem suspicious and then investigate further from that point.
nevertheless after a section of code that includes a database interaction point has been identified as suspicious our database aware technique provides additional information that can be useful to the developer.
for this case study we assume the developer has located a suspicious section of code.
each of our subjects builds its sql commands in a slightly different manner so we selected one mutant of each subject to examine.
for each mutant we provide a code sample to illustrate the suspicious section of the application a description of the mutation and a discussion of the additional information provided to the developer by our technique.
itrust the majority of sql commands in itrust are static strings embedded in the source code.
itrust typically prepares and executes these commands at or close to the location of the string.
for example ps conn.preparestatement update globalvariables set value ?
where value timeout ps.setint mins int numupdated ps.executeupdate in this example the mutation is an attribute replacement the clause value timeout was originally name timeout where value andname are both attributes of the globalvariables table.
because the sql command is in a string literal just before the databaseinteraction point the ps.executeupdate call the developer would be able to identify the sql command quickly when the database interaction point is suspicious.
our technique provides some additional assistance by revealing the literal values used in executions of the sql command update globalvariables set value where value timeout update globalvariables set value where value timeout these values can provide clues beyond those given by the structure of the sql command itself.
in this particular example value is being assigned integer values but is compared with a textual string.
jw hois server jw hois server builds sql commands dynamically from command fragments contained in non standard configuration files and string literals.
all sql commands in the application are executed by one of two database interaction points.
the majority of the sql commands are executed by the following method private final synchronized resultset execpst preparedstatement pst throws sqlexception resultset res pst.executequery return res theexecpst method takes the sql command to execute as the parameter pst.
it is apparent that the suspiciousness of this database interaction point alone does not easily lead the developer to the faulty sql command as it would in itrust .
furthermore the sql commands are constructed in a more dynamic manner as illustrated in this method protected final string getwherepart vector string qv this.getqfield final string qf this.getqfield .get stringbuilder ret new stringbuilder where qf ?
and inetnumend ?
and this.bytelengthfield ?
if this.getwhereaddition .length if !this.getwhereaddition .startswith ret.append ret.append this.getwhereaddition ret.append order by qf asc inetnumend asc return ret.tostring in the method getwherepart pieces of the where clause including use of the inetnumend attribute are contained in string literals and the rest are input through method calls and member fields.
the calls to getqfield andgetwhereaddition and the access of bytelengthfield all reference data from an external configuration file.
a sample from one such file is 9logging code has been omitted from all jw hois server examples.
219db.inetnum.table inetnum db.inetnum.objectlookup inetnum inet db.inetnum.qfield inetnumstart db.inetnum.key descr db.inetnum.bytelength bytelength db.inetnum.display netname as network bytelength inetnumstart inetnumend descr source db.inetnum.recurse.person admin c tech c many sql mutations for jw hois server involve changes to configuration files.
in this example the value of db.inetnum.key changed from netname to descr .
for this application identifying the database interaction point as suspicious is not particularly useful to the developer it takes many steps to work back to where the preparedstatement was created and even then it is not immediately apparent which tables attributes and values were used in the sql command.
our technique provides additional helpful information it supplies the full sql commands executed at the database interaction point ties each command to the test case that executed the command and indicates the correlation of each command with the failure of test cases in the test suite.
the database interaction point alone is not ranked highly because it is executed by both passing and failing test cases.
in contrast our technique identifies the database interaction point and mutated sql command with high suspiciousness dbpool.java select descr netname as network bytelength inetnumstart inetnumend source from inetnum where inetnumstart ?
and inetnumend ?
and bytelength ?
order by inetnumstart asc inetnumend asc suspiciousness .
for this application our technique aides the developer both through a more precise ranking and by directly presenting the command information.
even if existing techniques identified the database interaction point in jw hois server as highly suspicious which they do not the developer would be left with more manual effort in locating the relevant command.
message switch message switch utilizes static sql commands which it retrieves from external configuration files.
m essage switch is similar to itrust in that its sql commands are not constructed dynamically and similar to jw hois server in that the commands come from external files rather than being defined directly in the source code.
message switch is a proprietary application so we are unable to show the actual contents of the source or configuration files.
instead the following examples emulate the structure database access strategies and sql command patterns of the application.
database interaction in m essage switch tends to follow the pattern shown below public coursegrade selectstudentgradebycourse long studentid string course coursegrade grade null grade template.queryforobject getsqlbykey sql select student grade by course studentmapper new object studentid course course return grade the static sql command to execute is identified by the key sql select student grade by course .
in this case the developer must first locate the definition of the key to find the value which corresponds to a configuration file entry containing the sql command.
the key