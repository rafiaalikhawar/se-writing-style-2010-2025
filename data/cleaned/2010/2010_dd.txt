dynodroid an input generation system for android apps aravind machiry rohan tahiliani mayur naik georgia institute of technology usa amachiry rohan tahil naik gatech.edu abstract we present a system dynodroid for generating relevant inputs to unmodi ed android apps.
dynodroid views an app as an event driven program that interacts with its environment by means of a sequence of events through the android framework.
by instrumenting the framework once and for all dynodroid monitors the reaction of an app upon each event in a lightweight manner using it to guide the generation of the next event to the app.
dynodroid also allows interleaving events from machines which are better at generating a large number of simple inputs with events from humans who are better at providing intelligent inputs.
we evaluated dynodroid on open source android apps and compared it with two prevalent approaches users manually exercising apps and monkey a popular fuzzing tool.
dynodroid humans and monkey covered and respectively of each app s java source code on average.
monkey took 20x more events on average than dynodroid.
dynodroid also found bugs in of the apps and bugs in of the top free apps on google play.
categories and subject descriptors d. .
testing and debugging general terms reliability experimentation keywords gui testing testing event driven programs android .
introduction mobile apps programs that run on advanced mobile devices such as smartphones and tablets are becoming increasingly prevalent.
unlike traditional enterprise software mobile apps serve a wide range of users in heterogeneous and demanding conditions.
as a result mobile app developers testers marketplace auditors and ultimately end users can bene t greatly from what if analyses of mobile apps.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.what if analyses of programs are broadly classi ed into static and dynamic.
static analyses are hindered by features commonly used by mobile apps such as code obfuscation native libraries and a complex sdk framework.
as a result there is growing interest in dynamic analyses of mobile apps e.g.
.
a key challenge to applying dynamic analysis ahead of time however is obtaining program inputs that adequately exercise the program s functionality.
we set out to build a system for generating inputs to mobile apps on android the dominant mobile app platform and identi ed ve key criteria that we felt such a system must satisfy in order to be useful robust does the system handle real world apps?
black box does the system forgo the need for app sources and the ability to decompile app binaries?
versatile is the system capable of exercising important app functionality?
automated does the system reduce manual e ort?
e cient does the system generate concise inputs i.e.
avoid generating redundant inputs?
this paper presents a system dynodroid that satis es the above criteria.
dynodroid views a mobile app as an event driven program that interacts with its environment by means of a sequence of events.
the main principle underlying dynodroid is an observe select execute cycle in which it rst observes which events are relevant to the app in the current state then selects one of those events and nally executes the selected event to yield a new state in which it repeats this process.
this cycle is relatively straightforward for ui events inputs delivered via the program s user interface ui such as a tap or a gesture on the device s touchscreen.
in the observer stage dynodroid determines the layout of widgets on the current screen and what kind of input each widget expects.
in the selector stage dynodroid uses a novel randomized algorithm to select a widget in a manner that penalizes frequently selected widgets without starving any widget inde nitely.
finally in the executor stage dynodroid exercises the selected widget.
in practice human intelligence may be needed for exercising certain app functionality in terms of generating both individual events e.g.
inputs to text boxes that expect valid passwords and sequences of events e.g.
a strategy for winning a game .
for this reason dynodroid allows a user to observe an app reacting to events as it generates them and lets the user pause the system s event generation manually generate arbitrary events and resume the system s eventgeneration.
our overall system thereby combines the benets of both the automated and manual approaches.
we discussed how dynodroid handles ui events but signi cant functionality of mobile apps is controlled by non ui events we call system events such as an incoming sms message a request by another app for the device s audio or a noti cation of the device s battery power running low.
satisfying our ve desirable criteria in the presence of system events is challenging for two reasons.
first the number of possible system events is very large and it is impractical to generate all possible permutations of those events.
for instance android supports di erent broadcast receivers each of which can send noti cations called intents to an app.
second many system events have structured data that must be constructed and dispatched correctly to the app alongside an intent.
for example generating an incoming sms message event entails constructing and sending a suitable object of class android.telephony.smsmessage .
a distinctive aspect of mobile apps is that all such apps regardless of how diverse their functionality are written against a common framework that implements a signi cant portion of the app s functionality.
dynodroid exploits this aspect pervasively in observing selecting and executing system events as we describe next.
dynodroid addresses the problem of handling a very large number of system events by using the observation that in practice a mobile app reacts to only a small fraction of them we call relevant events.
an event is relevant to an app if the app has registered a listener for the event with the framework.
finding when an app registers or unregisters such a listener does not require modifying the app it sufces to instrument the framework once and for all.
the observer monitors the app s interaction with the framework via this instrumentation and presents the selector only events that the app has registered to listen.
finally the executor constructs any data associated with the selected event and dispatches it to the app.
a salient aspect of dynodroid concerns how it constructs this data.
for instance the listener for network connectivity change events expects an object of class android.net.networkinfo describing the new status of the network interface.
dynodroid cannot arbitrarily create such objects it must obtain them from a pool maintained by system service android.net.connectivitymanager .
finally whenever an event is executed any previously relevant event may become irrelevant and vice versa for the next observe select execute cycle.
we implemented dynodroid for the android platform and applied it to diverse real world open source apps.
we compared the performance of dynodroid in terms of each app s java source code coverage to two prevalent approaches one involving expert users manually exercising these apps and another using monkey a popular fuzzing tool.
dynodroid humans and monkey covered and code respectively on average per app.
dynodroid was able to cover of the code covered by humans per app on average showing its ability to automate testing.
also dynodroid achieved peak coverage faster than monkey with monkey requiring 20x more events on average showing the effectiveness of our randomized event selection algorithm.
finally dynodroid found bugs in of the apps.
in a separate experiment we applied dynodroid to the top free apps in google play and it found bugs in of them.
we summarize the main contributions of our work .
we propose an e ective approach for generating inputs to mobile apps.
it is based on a observe selectexecute principle that e ciently generates a sequence of relevant events.
to adequately exercise app functionality it generates both ui and system events and seamlessly combines events from human and machine.
.
we show how to observe select and execute system events for android in a mobile device emulator without modifying the app.
the central insight is to tailor these tasks to the vast common framework against which all apps are written and from which they primarily derive their functionality.
.
we present extensive empirical evaluation of the system comparing it to the prevalent approaches of manual testing and automated fuzzing using metrics including code coverage and number of events for diverse android apps including both open source apps and top free marketplace apps.
the rest of the paper is organized as follows.
section describes the overall system.
the next three sections present its three main parts section the executor section the observer and section the selector.
section presents our experimental results.
section surveys related work and section concludes.
.
system architecture this section presents the system architecture of dynodroid.
algorithm shows the overall algorithm of dynodroid.
it takes as input the number nof events to generate to an app under test.
it produces as output a list lofn events it generates.
the rst generated event is to install and start the app in a mobile device emulator.
the remaining n events are generated one at a time in an observe selectexecute cycle.
each of these events constitutes either a ui input or non ui input to the app which we call ui event and system event respectively.
the two kinds of events are conceptually alike each event of either kind has a type and associated data.
we distinguish between them because as we explain below dynodroid uses di erent mechanisms to handle them.
the executor executes the current event denoted e in the current emulator state denoted s to yield a new emulator state that overwrites the current state.
next theobserver computes which events are relevant in the new state.
we denote the set of relevant events e. finally the selector selects one of the events from eto execute next and the process is repeated.
figure presents a data ow diagram of dynodroid that provides more details about the mechanisms it uses to implement the executor the observer and the selector on the android platform.
theexecutor triggers a given event using the appropriate mechanism based on the event kind.
it uses the android debug bridge adb to send the event to an android device emulator that is running the app under test.
for ui events the adb host talks to the adb daemon adbd on the emulator via the monkeyrunner tool.
note that this tool which is used to send events to an emulator via an api is unrelated to the monkey fuzz testing tool which runs in an adb shell directly on the emulator.
for system events the adb host talks to the activity manager tool am on the emulator which can send system events as intents to running apps.
section describes the executor in further detail.selector instrumented sdk hierarchy viewer monkey runner adb daemon ac vity manager intercepted calls from apps to sdk app under test adb host observer e is ui event all relevant events e e1 u e2 selected event e from e e is system event executor system events e2 ui events e1 device emulator ini al event e install and start app figure data ow diagram of dynodroid for the android platform.
algorithm overall algorithm of dynodroid.
input number n of events to generate.
output listlofnevents.
l empty list e event to install and start app under test s initial program state forifrom 1tondo append etol execute event ein current state sto yield updated state.
s executor e s compute set eof all events relevant in current state s. e observer s select an event e2eto execute in next iteration.
e selector e end for theobserver computes the set of events that are relevant to the app under test in the current emulator state.
it consists of two parts to handle the two kinds of events the hierarchy viewer tool for ui events and the instrumented framework sdk for system events.
hierarchy viewer provides information about the app s gui elements currently displayed on the device s screen.
the observer computes the set of relevant ui events e1from this information.
the instrumented sdk provides information about broadcast receivers and system services for which the app is currently registered.
the observer computes the set of relevant system events e2from this information.
it provides the set of all relevant events e e1 e2to the selector .
section provides more details about the observer .
theselector selects an event from eas the next event to be triggered.
dynodroid implements various selection strategies that one can choose from upfront including deterministic vs. randomized and history dependent vs. history oblivious strategies.
section describes these strategies and section evaluates them on a code coverage client for open source apps.
.
executor dynodroid allows both machine and human to generate events in order to combine the bene ts of automated and manual input generation.
figure shows how dynodroid allows switching between machine and human.
the executorlistens to commands from a console and starts in human mode in which it does not trigger any events and instead start state final state human mode machine mode resume pause start console emulator console commands state transi1ons human executor events to app figure state transition diagram of dynodroid.
allows the human to exercise the app uninterrupted in the emulator until a resume command is received from the console.
at this point the executor switches to machine mode and generates events until the given bound nis reached or a pause command is received from the console.
in the latter case the executor switches to human mode again.
human inputs do not count towards the bound n. also nothing prevents the human from exercising the app in machine mode as well along with the machine.
finally the stop command from the console stops dynodroid.
theexecutor executes an event chosen by the selector on the emulator via the android debug bridge adb .
it uses separate mechanisms for executing ui events and system events.
ui events are triggered using the monkeyrunner tool.
this tool is a wrapper around adbthat provides an api to execute ui events.
system events are triggered using the activity manager tool am .
broadcast events of any type can be triggered using this tool provided the correct arguments are supplied.
.
observer theobserver computes the set of relevant events after an event is executed.
we consider an event relevant if triggering it may result in executing code that is part of the app.
the goal of the observer is to e ciently compute as small a set of relevant events as possible without missing any.
this section describes how the observer computes relevant ui events section .
and relevant system events section .
.
.
ui events these are events generated by the sdk in response to interaction by users with the device s input mechanisms.table mapping registered callback methods and overridden methods to relevant ui events.
relevant event tap tap drag text short long if app registers callback onclicklistener x onlongclicklistener x ontouchlistener x x x onkeylistener x oncreatecontextmenulistener x if app overrides method ontouchevent x x x performlongclick x performclick x onkeydown x onkeyup x dynodroid supports two input mechanisms touchscreen and navigation buttons speci cally back and menu buttons .
we found these su cient in practice for three reasons they are the most common input mechanisms the mechanisms we do not support keyboard trackball etc.
are devicedependent and there is often redundancy among di erent input mechanisms.
theobserver analyzes the app s current ui state in order to compute relevant ui events.
first it deems clicking each navigation button as a relevant ui event since these buttons are always enabled.
second it inspects the view hierarchy which is an android speci c tree representation of the app s ui currently displayed on the touchscreen.
the sdk provides two ways by which an app can react to inputs to a ui element by overriding a method of the corresponding view object s class or by registering a callback with it.
the sdk dispatches each input on the touchscreen to the root node of the view hierarchy which in turn depending on the position of the input dispatches it recursively to one of its children until the view to which the input was intended executes a callback and returns true denoting that the input was successfully handled.
the observer obtains the view hierarchy from a service called viewserver that runs on android devices having debug support.
once it obtains the view hierarchy it considers only the view objects at leaf nodes of the tree as interesting as these correspond to visible ui elements that users can interact with.
it extracts two kinds of data from each such object about the corresponding ui element a the set of callback methods registered and the set of methods overridden by the app for listening to inputs to this ui element and b the location and size of the ui element on the touchscreen the position of its top left corner its width height and scaling factor .
the native hierarchy viewer does not provide all of the above data we modi ed the android sdk source to obtain it.
the observer uses the data in item a to compute which ui events are relevant as dictated by table .
it supports all common touchscreen inputs tap inputs limited kinds of gestures and text inputs.
finally the observer uses the data in item b to compute the parameters of each such event as dictated by table .
.
system events these are events generated by the sdk in response to nonui inputs such as an incoming phone call a change in geo location etc.
the sdk provides one of two means by which an app can receive each type of system event broadcast receiver andsystem service .
in either case the app registers a callback to be called by the sdk when the event occurs.
the app may later unregister it to stop receiving the event.
theobserver uses the same mechanism for extracting relevant system events via broadcast receivers and system services it instruments the sdk to observe when an app registers or unregisters for each type of system event.
this instrumented sdk is a le system.img that is loaded on the emulator during bootup.
it is produced once and for all by compiling java source code of the original sdk that is manually modi ed to inject the instrumentation.
a system event becomes relevant when an app registers to receive it and conversely it becomes irrelevant when an app unregisters it.
as in the case of ui events the observer computes not only which system events are relevant but also what data to associate with each.
unlike for ui events however this data can be highly structured sdk objects instead of primitive typed data .
we next outline how the observer handles speci c broadcast receivers section .
.
and system services section .
.
.
.
.
broadcast receiver events android provides two ways for apps to register for system events via a broadcast receiver depending on the desired lifetime dynamically or statically.
in the dynamic case the receiver s lifetime is from when context.registerreceiver is called to either until context.unregisterreceiver is called or until the lifetime of the registering app component.
in the static case the receiver is speci ed in le androidmanifest.xml and has the same lifetime as the app.
in either case the receiver de nes a callback method overriding broadcastreceiver.onreceive that the sdk calls when the event occurs we provide an example below .
the observer supports both kinds of receivers.
the gingerbread sdk version we instrumented has di erent kinds of system events as intents for which an app may register via a broadcast receiver.
as a proof of concept we chose the top receivers used by the top free apps in the google play market.
supporting additional intents is straightforward it involves identifying the type of data associated with the intent and providing valid values for the data.
the data includes an optional uri and a bundle object which is a key value map that contains any extra information.
finally for statically registered receivers we also explicitly identify the receiver in the intent since unlike ui events which are dispatched to a single view object broadcast intents are by default dispatched to all receivers possibly from several apps that register for them.
table shows the type and values of the data used by the observer for our chosen broadcast intents.
all the data shown except those of type uri are provided in a bundle object.
for instance an app may register the following receiver for the sms received intent which is broadcast upon incoming sms messages public class smsreceiver extends broadcastreceiver override public void onreceive context c intent e bundle b e.getextras object p object b.get pdus smsmessage a new smsmessage for int i i pdus.length i a smsmessage.createfrompdu byte p table user event parameters l t w hdenote left position top position width and height of the view respectively.
tl tr bl br mb mt ml mr denote top left right bottom left right and mid bottom top left right points of the view respectively.
event type parameters description tap tap l w t h trigger tap at center of view longtap longtap l w t h trigger longtap at center of view drag random one of drag l t l w t h drag l w t h l t randomly trigger one of gestures drag l t h l w t drag l w t l t h tl to br br to tl bl to tr drag l t h l w t h drag l w t h l t h tr to bl ml to mr mr to ml drag l w t l w t h drag l w t h l w t mt to mb mb to mt text arbitrary xed string trigger arbitrary text input to trigger this event the executor serializes the appropriate intent along with a bundle object that maps a kay named pdus to an smsmessage object array representing arbitrary but well formed phone numbers and message texts.
.
.
system service events system services are a xed set of processes that provide abstractions of di erent functionality of an android device.
we distinguish services whose o ered functionality depends on app provided data from those that are independent of such data.
we call such services internally vs.externally triggered as they depend on data internal or external to the app under test.
for instance the alarmmanager service is internally triggered as it depends on the alarm duration given by an app but the locationmanager service is externally triggered as it depends on the device s geo location.
dynodroid only controls externally triggered services as the app itself controls internally triggered services.
table shows how dynodroid handles events of each externally triggered service.
the register unregister mechanism shows how an app registers or unregisters for the service which the observer observes via sdk instrumentation.
since services are global components the observer uses the id of the app under test to lter out observing other apps that may also register or unregister for these services.
the callback mechanism shows how the app speci es the callback to handle events by the service.
lastly the trigger mechanism shows how the executor triggers the callback usually via a command sent from the activitymanager tool running on the emulator see section .
the following example showing how an app may use the locationmanager service gpsstatus.listener l new gpsstatus.listener override public void ongpsstatuschanged int event ... locationmanager lm getsystemservice location service lm.addgpsstatuslistener l ... lm.removegpsstatuslistener l from the point at which the app registers to listen to gps status changes by calling addgpsstatuslistener to the point at which it unregisters by calling removegpsstatuslistener theobserver regards gps status change as a relevant system event.
if the selector described in the next section selects this event then the executor triggers it by sending telnet command geo x g to the emulator where gis an arbitrary geo location a triple comprising a latitude longitude and altitude .
this in turn results in invoking callback ongpsstatuschanged de ned by the app.algorithm event selection algorithm biasedrandom .
varg map from event set of events pairs to int g empty map input seteof relevant events.
output an event in e. for each eine do if e e is not in domain of g then initialize score of event ein context e. g e e init score e end if end for varl map from events to int l map from each event in eto while truedo e event chosen uniformly at random from e if l e g e e then select ethis time but decrease its chance of being selected in context ein future calls to selector .
g e e g e e return e else increase chance of selecting ein the next iteration.
l e l e end if end while procedure initscore e int case e of text event return non text ui event return system event return end case .
selector theselector selects an event for the executor to execute from the set of relevant events ecomputed by the observer .
we implemented three di erent selection strategies in the selector called frequency uniformrandom and biasedrandom .
this section describes these strategies.
the frequency strategy selects an event from ethat has been selected least frequently by it so far.
the rationale is that infrequently selected events have a higher chance of exercising new app functionality.
a drawback of this strategy is that its deterministic nature leads the app to the same state in repeated runs.
in practice di erent states might be reached in di erent runs because of non determinism inherent in dynamic analysis of android apps due to factors such as concurrency and asynchrony however we cannot rely on them to cover much new app functionality.table broadcast receiver events with associated data as implemented in dynodroid.
these implemented events have no associated data battery action power connected action shutdown time set audio becoming noisy date changed user present media eject and boot completed .
action name data type description data value appwidget update int ids of app widgets to update random sized array of random ints connectivity changeandroid.net.networkinfo status of the network interfacerandom networkinfo object from android.net.connectivitymanager package addedint uid assigned to new package bool true if this follows a removed broadcast for the same packageuid of random installed package random bool package removedint uid previously given to package bool true if removing entire app bool true if an added broadcast for the same package will followuid of random installed package random bool random bool package replaced int uid assigned to new package uid of random installed package media mounteduri path to mount point of media bool true if media is read only mnt sdcard false timezone changed timezone time zone representation america los angeles time zone media buttonandroid.view.keyevent key event that caused this broadcastkeyevent object with action as action up and value as keycode media play pause sms receivedandroid.telephony.smsmessage array of received sms messagesarray of smsmessage object with arbitrary msisdn and message media unmounted uri path to mount point of media mnt sdcard phone stateint phone state idle jringingjo hook string incoming phone number1 ringing an arbitrary msisdn media scanner finished uri mnt sdcard new outgoing call string outgoing phone number an arbitrary msisdn the uniformrandom strategy circumvents the above problem by selecting an event from euniformly at random.
this is essentially the strategy used by the monkey fuzz testing tool with three key di erences.
first monkey can only generate ui events preventing it from covering app functionality controlled by system events.
second monkey does not compute relevant events and can send many events that are no ops in the current state hindering e ciency and conciseness of the generated event sequence.
third monkey does not compute a model of the app s ui which has pros and cons.
on one hand it prevents monkey from identifying observationally equivalent ui events e.g.
taps at di erent points of the same button that have the same e ect of clicking the button and hinders e ciency and conciseness on the other hand dynodroid sends mostly xed inputs see table to a widget and may fail to adequately exercise custom widgets e.g.
a game that interprets taps at di erent points of a widget di erently .
a drawback of the uniformrandom strategy is that it does not take any domain knowledge into account it does not distinguish between ui events and system events nor between di erent contexts in which an event may occur nor between frequent and infrequent events.
for instance an event that is always relevant e.g.
an incoming phone call event stands to be picked much more often than one that is relevant only in certain contexts e.g.
only on a certain screen of the app .
as another example navigation buttons back and menu are always relevant but often have different behavior on di erent screens.
these observations motivate our nal and default selection strategy biasedrandom .
this strategy is shown in algorithm .
like the frequency strategy it maintains a history of how often each event has been selected in the past but it does so in a context sensitive manner the context for an event eat a particular instant is the set eof all relevant events at that instant.
this history isrecorded in global variable gthat maps each pair e e to a score.
the map starts empty and is populated lazily.
at any instant the score for a pair e e in the map is either meaning event eis blacklisted in context e i.e.
ewill never be selected in context e or it is a non negative integer with higher values denoting lesser chance of selecting event ein context ein the future.
we found it suitable to use the set of relevant events eas context because it is e cient to compute the observer already computes e and it strikes a good balance between factoring too little and too much of the state into the context.
each time the selector is called using this strategy in an observe select execute cycle it runs the algorithm on lines taking as input the set of relevant events efrom the observer and producing as output the selected event e2e for the executor to execute.
it starts by mapping for everye2e the pair e e to its initial score in global map g unless it already exists in g. we bias the initial score lines depending on the kind of event.
if eis a text event its initial score is .
in other words text inputs are blacklisted in all contexts.
intuitively the reason is that text inputs are interesting only if they are followed by a nontext input e.g.
a button click.
hence we forbid selecting text inputs in the selector altogether and instead require theexecutor to populate all text boxes in the current ui before it executes the selected non text event.
we distinguish between two kinds of non text events non text ui events and system events.
we choose initial score of for the former and for the latter reducing the relative chance of selecting system events.
this bias stems from our observation that system events tend to be relevant over longer periods than ui events with ui events typically being relevant only when a certain screen is displayed.
a hallmark of our algorithm however is that it never starves any event in any context.
this is ensured by lines which re table handling of events of externally triggerable system services in dynodroid.
service register unregister mechanism callback mechanism trigger mechanism audiomanagerregistermediabuttoneventreceiver c unregistermediabuttoneventreceiver invoke component denoted by componentname object csend keypress event with keycode of anymedia button viamonkeyrunner requestaudiofocus l abandonaudiofocus call onaudiofocuschange in audiomanager.onaudiofocuschangelistener object lsimulate incoming phone call from a xed msidn nvia telnet command gsm call n locationmanageraddgpsstatuslistener l removegpsstatuslistener call ongpsstatuschanged in gpsstatus.listener object lset geo location to xed value g via telnet command geo x g addnmealistener l removenmealistener call onnmeareceived in gpsstatus.nmealistener object lsend xed nmea data svia telnet command geo nmea s addproximityalert g p removeproximityalert trigger pendingintent pset geo location to registered proximal value gvia telnet command geo x g requestlocationupdates removeupdates if locationlistener speci ed call on changed or onprovider else call pendingintent or post to message queue of given looperset geo location twice via commands geo x g1 and geo x g2 g1is random geo location g2is based on g1and registered criteria.
requestsingleupdate auto unregister after updatesame as above same as above sensormanagerregisterlistener l s unregisterlistener call on changed on sensoreventlistener object lset random values x y z for sensor s via telnet command sensor set sx y z telephonemanagerlisten l s with state snon zero zerocall ondataactivity or any of several on changed methods on phonestatelistener object ltrigger state change via telnet command gsm c d cis random gsm command and dis random valid data.
table emulator con guration in our evaluation.
feature name feature value device ram size gb emulator hardware features all except gpu emulation sdcard size gb files on sdcard pdf img vcf arr zip type count 3gp m4v mov mp3 peatedly pick an event efrom euniformly at random until one satis es condition l e g e e in which case it is returned as the event selected by the current selector call.
just before returning we increment g e e to reduce the chance of picking ein context ein a future selector call.
lis a local map that records the number of times event e was randomly picked by the above process in the current selector call but passed over for not satisfying the condition.
thus fewer the number of times that ehas been chosen in context ein past selector calls or higher the number of times that ehas been passed over in context ein the current selector call the higher the chance that ewill be selected to execute in context ein the current selector call.
.
empirical evaluation we evaluated dynodroid on real world android apps and compared it to two state of the art approaches for testing such apps manual testing and automated fuzzing.
all our experiments were done on linux machines with 8gb memory and .0ghz processors.
we used the gingerbread version of android which is the most popular version installed on of all devices that recently accessed google play .
table shows the emulator con guration that we used in all experiments.
for each run an app was given a freshly created emulator along with only default system applications and the above con guration.
we next describe two studies we performed measuring app source code coverage section .
and nding bugs in apps section .
.
figure distribution of open source apps.
.
study app source code coverage our rst study measures the app source code coverage that di erent input generation approaches are able to achieve.
we randomly chose apps from the android open source apps repository f droid for this study.
these apps are su ciently diverse as evidenced in figure .
the sloc of these apps ranges from to .9k with a mean of .7k.
we obtained app coverage metrics by using emma a popular java source code coverage tool.
emma generates detailed line coverage metrics to the granularity of branches and provides coverage reports in di erent formats that assist in analysis and gathering statistics.
evaluated approaches.
we evaluated the following ve approaches in this study dynodroid using each of the three selection strategies frequency uniformrandom biasedrandom the monkey fuzz testing tool provided in the android platform and manual testing conducted in a study involving ten users.
table shows the setup we used for each of these ve approaches on each app.
we ran each of the three variants of dynodroid for events we ran monkey for events and we allowed the users in our study to manually generate an unlimited number of events.
we used di erent numbers of events for dynodroid and monkey because those are the numbers of events that the two tools were able to generate in roughly the same duration in three hours for each of the apps on average.
dynodroidtable testing approaches used to test each app.
approach events runs dynodroid frequency dynodroid uniformrandom dynodroid biasedrandom monkey humans no limit table kinds of ui events triggered by monkey.
event type proportion touch motion trackball minor navigation major navigation system keys apps switch others keyboard volume camera buttons runs 5x slower than monkey primarily due to performance issues with the version of the o the shelf hierarchy viewer tool it calls after each event.
on the plus side as we show below dynodroid achieves peak code coverage much faster than monkey requiring far fewer than even the events we generated.
monkey triggers a large variety of ui events but no system events.
table summarizes the kinds of ui events it triggers in its default con guration that we used.
these events are strictly a superset of the kinds of ui events that dynodroid can generate see section .
.
all ten users that we chose in our study are graduate students at georgia tech who have experience with not only using android apps but also developing and testing them using android developer tools.
we provided each of them with each app s source code the ability to run the app any number of times in the android emulator and the ability to inspect app source code coverage reports produced from those runs.
they were allowed to provide any kind of gui inputs including intelligent game inputs and login credentials to websites.
they were also allowed to modify the environment by adding removing les from the emulator s sdcard to manually trigger system events via a terminal by studying the apps source code etc.
we ensured that each app was assigned to at least two users.
likewise we ran each automated approach involving randomization monkey and the uniformrandom and biasedrandom strategies in dynodroid three times on each app.
we considered the highest coverage that a user or run achieved for each app.
perhaps surprisingly for certain apps we found fairly signi cant variation in coverage achieved across the three runs by any of the random approaches.
upon closer inspection we found certain events in these apps that if not selected in a certain state irreversibly prevent exploring entire parts of the app s state space.
two possible xes to this problem are i allowing a relatively expensive event during testing that removes and re installs the app dynodroid currently installs the app only once in a run and ii to simply run the app multiple times and aggregate their results.
finally android apps may often call other apps such as a browser a picture editor etc.
to prevent the automated approaches in the study from wandering far beyond the appunder test we prevented both dynodroid and monkey from exercising components not contained in the app under test.
coverage results.
the results of our code coverage study for the apps are shown in the three plots in figure .
to enable comparisons for each app across plots each point on the x axis of all three plots denotes the same app.
we next elaborate upon the results in each of these plots.
figure 4a compares the code coverage achieved for each of the apps by dynodroid vs. human where human denotes the user who achieved the best coverage of all users in our user study for a given app and dynodroid uses the biasedrandom strategy.
the bar for each app has three parts the bottom red part shows the fraction of code that both dynodroid and human were able to cover i.e.
the intersection of code covered by them .
atop this part are two parts showing the fraction of code that only dynodroid and only human were able to cover i.e.
the code covered by one but not the other .
both dynodroid and human cover of code per app for an average of .
dynodroid exclusively covers of code for an average of and human exclusively covers of code for an average of .
in terms of the total code covered for each app human easily outperforms dynodroid achieving higher coverage for of the apps.
this is not surprising given that the users in our study were expert android users could provide intelligent text inputs and event sequences and most importantly could inspect emma s coverage reports and attempt to trigger events to cover any missed code.
but all the ten users in our study also reported tediousness during testing how easy it was to miss combinations of events and that it was especially mundane to click various options in the settings of apps one by one.
dynodroid could be used to automate most of the testing e ort of human as measured by what we call the automation degree measured as the ratio of coverage achieved by the intersection of dynodroid and human to the total coverage achieved by human.
this ratio varies from to across our apps with mean and standard deviation .
these observations justify dynodroid s vision of synergistically combine human and machine.
it already provides support for intelligent text inputs where a user with knowledge of an app can specify the text that it should use instead of random text in the speci c text box widget prior to execution or can pause its event generation when it reaches the screen key in the input and let it resume as described in section .
figure 4b compares the code coverage achieved for each of the apps by dynodroid vs. monkey.
it is analogous to figure 4a with monkey instead of human.
both dynodroid and monkey cover of code per app for an average of .
dynodroid exclusively covers of code for an average of which is attributed to system events that only dynodroid can trigger.
monkey exclusively covers of code for an average of which is attributed to the richer set of ui events that monkey can trigger see table vs. table .
another reason is that dynodroid only generates straight drag gestures but monkey combines short sequences of such gestures to generate more complex e.g.
circular gestures.
finally dynodroid uses xed parameter values for ui events whereas monkey uses random values giving it superior ability to exercise custom widgets.
in terms of the total code covered for each app however dynodroid outperforms monkey achieving higher coverage for of the apps.
app code coveragecommon only dynodroid only human a code coverage achieved by dynodroid biasedrandom vs. human.
app code coveragecommon only dynodroid only monkey b code coverage achieved by dynodroid biasedrandom vs. monkey.
number of eventsbiasedrandom uniformrandom frequency monkey c minimum number of events needed for peak code coverage by various approaches.
figure results of the app source code coverage study.
each point on the x axis in all three plots denotes the same app from the open source apps used in the study.
figure 4a shows that dynodroid can be used to automate to a signi cant degree the tedious testing done by humans.
figure 4b shows that dynodroid and monkey get comparable coverage but figure 4c shows that monkey requires signi cantly more events to do so.
note that the y axis in figure 4c uses a logarithmic scale.
figure 4c compares the minimum number of events that were needed by each automated approach monkey and dynodroid using each of the selection strategies to achieve peak code coverage for each of the apps recall that we ran monkey for events and dynodroid for events .
to strike a good tradeo between measurement accuracy and performance we invoke emma to aggregate coverage after every events for each approach on each app and hence the minimum number of reported events is .
it is evident that all three strategies in dynodroid require signi cantly fewer events than monkey in particular monkey requires 20x more events than biasedrandom on average.
this is despite dynodroid considering both system and ui events at each step.
the reason is that dynodroid only exercises relevant events at each step and also because it identi es observationally equivalent events.
finally of the three selection strategies in dynodroid biasedrandom performsthe best with each of the other two strategies requiring 2x more events than it on average.
.
study bugs found in apps the second study we performed shows that dynodroid is an e ective bug nding tool and is also robust.
to demonstrate its robustness we were able to successfully run dynodroid on the most popular free apps from google play.
the popularity metric used is a score given to each app by google that depends on various factors like number of downloads and ratings.
these apps are uniformly distributed over all app categories in google play the minimum maximum mean and standard deviation of the number of apps in these categories is .
and .
respectively.
we also found that dynodroid exposed several bugs in both the open source apps we chose from f droid and the most popular free apps from google play.
table 8table bugs found by dynodroid in the open source apps from f droid and the top free apps from google play.
the two classes of apps are separated by the double line with all the open source apps listed above.
null ptr denotes a null pointer dereference exception and array idx an array index out of bounds exception.
app name bugs kind description passwordmakerproforandroid null ptr improper handling of user data.
com.morphoss.acal null ptr dereferencing null returned by an online service.
hu.vsza.adsdroid null ptr dereferencing null returned by an online service.
cri.sanity null ptr improper handling of user data.
com.zo cc.applications.aagtl null ptr dereferencing null returned by an online service.
org.beide.bomber array idx game indexes an array with improper index.
com.addi null ptr improper handling of user data.
com.ibm.events.android.usopen null ptr null pointer check missed in oncreate of an activity.
com.nullsoft.winamp null ptr improper handling of rss feeds read from online service.
com.almalence.night null ptr null pointer check missed in oncreate of an activity.
com.avast.android.mobilesecurity null ptr receiver callback fails to check for null in optional data.
com.aviary.android.feather null ptr receiver callback fails to check for null in optional data.
summarizes these bugs.
we mined the android emulator logs for any unhandled exceptions that were thrown from code in packages of the app under test while dynodroid exercised the app in the emulator.
to be conservative we checked for only fatal exception as this exception is the most severe and causes the app to be forcefully terminated.
we manually ascertained each bug to eliminate any false positives reported by this method but found that all the bugs were indeed genuine and did cause the app to crash.
.
related work there are broadly three kinds of approaches for generating inputs to mobile apps fuzz testing which generates random inputs to the app systematic testing which systematically tests the app by executing it symbolically and model based testing which tests a model of the app.
we elaborate upon each of these three approaches in this section.
fuzz testing.
the android platform includes a fuzz testing tool monkey that generates a sequence of random ui events to android apps in a mobile device emulator.
recent work has applied monkey to nd gui bugs and security bugs .
fuzz testing is a black box approach is easy to implement robustly is fully automatic and can e ciently generate a large number of simple inputs.
but it is not suited for generating inputs that require human intelligence e.g.
playing and winning a game nor is it suited for generating highly speci c inputs that control the app s functionality and it may generate highly redundant inputs.
finally monkey only generates ui events not system events.
it is challenging to randomly generate system events due to the large space of possible such events and highly structured data that is associated with them.
systematic testing.
several recent e orts have applied symbolic execution to generate inputs to android apps.
symbolic execution automatically partitions the domain of inputs such that each partition corresponds to a unique program behavior e.g.
execution of a unique program path .
thus it avoids generating redundant inputs and can generate highly speci c inputs but it is difcult to scale due to the notorious path explosion problem.
moreover symbolic execution is not black box and requires heavily instrumenting the app in addition to the framework.
model based testing.
model based testing has been widely studied in testing gui based programs using the guitar framework.
guitar has been applied to android apps iphone apps and web apps among others.
in general model based testing requires users to provide a model of the app s gui though automated gui model inference tools tailored to speci c gui frameworks exist as well .
one such tool in the android platform that dynodroid also uses for observing relevant ui events is hierarchy viewer .
model based testing harnesses human and framework knowledge to abstract the input space of a program s gui and thus reduce redundancy and improve e ciency but existing approaches predominantly target ui events as opposed to system events.
the exsyst tool extends model based testing using a genetic algorithm to continually re ne models from run time feedback with the goal of maximizing the code coverage of the given app.
it uses guidance based on branch distance measurement and also aims to produce small test suites.
.
conclusion we presented a practical system dynodroid for generating relevant inputs to mobile apps on the dominant android platform.
it uses a novel observe select execute principle to e ciently generate a sequence of such inputs to an app.
it operates on unmodi ed app binaries it can generate both ui inputs and system inputs and it allows combining inputs from human and machine.
we applied it to a suite of real world apps and compared its performance to two state of the art input generation approaches for android apps manual testing done by expert users and fuzz testing using the popular monkey tool.
we showed that dynodroid can signi cantly automate testing tasks that users consider tedious and generates signi cantly more concise input sequences than monkey.
we also showed its robustness by applying it to the top free apps on google play.
lastly it exposed a few bugs in a handful of the apps to which it was applied.