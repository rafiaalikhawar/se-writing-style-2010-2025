automated design of self adaptive software with control theoretical formal guarantees antonio filieri university of stuttgart stuttgart germanyhenry hoffmann university of chicago chicago usamartina maggio lund university lund sweden abstract self adaptation enables software to execute successfully in dynamic unpredictable and uncertain environments.
control theory provides a broad set of mathematically grounded techniques for adapting the behavior of dynamic systems.
while it has been applied to speci c software control problems it has proved di cult to de ne methodologies allowing non experts to systematically apply control techniques to create adaptive software.
these di culties arise because computer systems are usually non linear with varying workloads and heterogeneous components making it difcult to model software as a dynamic system i.e.
by means of di erential or di erence equations.
this paper proposes a broad scope methodology for automatically constructing both an approximate dynamic model of a software system and a suitable controller for managing its non functional requirements.
despite its generality this methodology provides formal guarantees concerning the system s dynamic behavior by keeping its model continuously updated to compensate for changes in the execution environment and e ects of the initial approximation.
we apply the methodology to three case studies demonstrating its generality by tackling di erent domains and different non functional requirements with the same approach.
being broadly applicable and fully automated this methodology may allow the adoption of control theoretical solutions and their formal properties for a wide range of software adaptation problems.
categories and subject descriptors d. .
design methodologies i. .
model development modeling methodologies general terms design experimentation theory performance reliability keywords adaptive software control theory dynamic systems nonfunctional requirements run time veri cation.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction the growing complexity of computing systems is placing increased burden on application developers.
this situation is made worse by the dynamic nature of modern systems which can experience sudden and unpredictable changes e.g.
application workload uctuations and system component failure.
it is increasingly up to software engineers to manage this complexity and ensure applications operate successfully in dynamic environments.
the use of autonomic orself adaptive techniques has been proposed to help engineers manage this burden.
such systems modify their own behavior to maintain goals in response to unpredicted changes.
while adaptation of an application s functional aspects i.e.
semantic correctness often requires human intervention its non functional aspects such as reliability performance energy consumption and cost represent an important and challenging opportunity for applying self adaptive techniques.
for example customers require continuous assurance of agreed performance and quality levels.
these non functional aspects can be managed by mapping them into speci c quantitative properties.
these properties can be measured and used to trigger adaptations guaranteeing requirements are met even in the face of unforeseen environmental uctuations .
such measurement driven adaptation has been studied for decades in the context of control theory .
control systems have achieved widespread usage in many engineering domains which interact with the physical world.
in such systems the controller measures quantitative feedback from a sensor e.g.
a speedometer and determines how to tune anactuator e.g.
a fuel intake to e ect the controlled plant e.g.
an engine .
one major advantage of using control theory is that such techniques emit analytical guarantees of the system s dynamic behavior.
in principle adaptable software can be considered a controllable plant allowing control theory to be applied to self adaptive software systems.
while researchers have applied notions from control theory to software systems the control of software can still be considered in its very preliminary stage.
there are many challenges that must be overcome to advance the application of control theory to software systems and many of these challenges arise from the di culty of modeling the controlled systems .
speci cally software applications have complex often non linear interactions with the hardware and system software that support their execution.
in addition dynamic changes due to maintenance or workload uctuations may invalidate a previously e ective model.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
this di culty in de ning concise and precise models of software behavior usually leads to the design of controllers focused on particular operating regions or conditions or ad hoc solutions which address speci c computing problems using control theory but do not generalize .
for example hellerstein et al.
de ne a controller for .net thread pools that is not straightforwardly adapted to other architectures though the high level task is quite similar .
furthermore this lack of generality requires application developers to spend signi cant development time designing and implementing control systems.
thus there is a need for generalized methods which can automatically synthesize control systems that compensate for shortcomings in system models due to non linear component interaction or dynamic uctuations in the environment.
we address this need by presenting a methodology which automatically builds suitable system models and then uses those models to synthesize a controller suitable for the selfadaptive management of non functional application requirements.
given a software system and a non functional requirement e.g.
performance accuracy energy our methodology rst uses a training phase to generate a linear model of the system and then synthesizes a con gurable controller.
the controller overcomes potential non linearities using a kalman lter to adapt the linear model dynamically.
in addition for drastic changes in system behavior the controller incorporates a change point detection strategy to trigger an online model rebuilding phase.
this methodology is general in the sense that it allows users to apply control theoretic techniques to a variety of scenarios without requiring the users to be control experts.
thus general users can bene t from the formal guarantees of control systems without being experts themselves.
critically the methodology synthesizes these controllers without a priori knowledge of system.
we evaluate our methodology in two ways.
first we perform a formal assessment of the guarantees it provides.
second we perform an empirical assessment of the methodology on three di erent software applications video compression energy e cient resource provisioning and dynamic binding and delegation.
similar problems appear as case studies in the literature concerned with self adaptive software and are here dealt with using our generalized approach.
.
controlling software our goal is to ease the development of self adaptive software systems by automatically synthesizing a control system capable of managing non functional aspects of the software s behavior.
toward that end this section presents background on essential properties of self adaptive software and relates them to analogous concepts in control theory.
we begin with an existing software system and some nonfunctional aspect which we want the software to self manage.
we assume no knowledge of the internals of the software system.
instead we assume that the system allows quantitative measurement of the speci ed non functional aspect and there is some tunable parameter of the system that a ects that aspect.
our methodology rst derives a model mapping the parameter s settings into expected feedback.
then the methodology synthesizes a control system that uses the derived model to ensure the speci ed aspect achieves the desired quality of service.we therefore refer to the adaptable software as our plant .
the combination of the original software and synthesized controller is called the controlled system.
the controller continuously determines the value of a control variable which represents a setting for the tunable parameter.
we assume that the software s user expresses a goal or setpoint representing the operating target for the speci ed non functional aspect of the controlled system e.g.
failure probability response time energy consumption or a convenient combination thereof.
from the perspective of software engineering a controller should be able to provide the following properties setpoint tracking.
the self adaptive system should achieve the user speci ed setpoint.
furthermore if a user changes the setpoint the controller should drive the system toward a new setting satisfying the new requirement.
for example consider a system that selfmanages the quality of a video streaming service.
the system may have one setpoint for premium users who receive high de nition quality and another for normal users who are served with reasonable quality depending on available system resources.
setpoint tracking refers to the property that the self adaptive system achieves the goal.
disturbance rejection.
disturbance rejection refers to the property that the self adaptive system maintains the setpoint despite unpredictable deviations from expected behaviors e.g.
uctuating load conditions or hardware failures.
in addition the system should not react to short lived transient external forces.
for example a controlled software system should not react to every cache miss or the occasional page fault.
instead a self aware system should be able to distinguish between a condition of chronic page faults that e ect performance and a single page fault that will not have a lasting e ect on the system.
robustness to inaccurate measurements.
quantitative assessment of the running system usually relies on monitoring and or other measurement procedures.
each of these might be subject to temporary biases be a ected by noise or might require a certain time to converge to a convenient accuracy.
a controller should provide a reasonable behavior even in presence of transitory errors on measured values.
besides reducing the sensitivity to measurement errors robustness allows for the use of less invasive monitoring instruments sometimes required for high accuracy but expensive in terms of performance overhead.
not surprisingly all of these properties have counterparts in control theory.
in particular they can be mapped to a combination of the following four properties of the controlled system stability.
a control system is asymptotically stable if there exists an equilibrium point to which the system tends i.e.
for any given input the output converges to a speci c value within a convenient accuracy .
as time tends to in nity the distance to the equilibrium point tends to zero.
if the equilibrium point is determined by a setpoint whenever the setpoint is reachable an asymptotically stable system will converge to the setpoint while an unstable system would not.
absence of overshooting.
an overshoot occurs when the system exceeds the setpoint prior to convergence.
low settling time.
settling time refers to the time required for the controlled system to reach the setpoint.
robustness.
a robust control system converges to the setpoint despite variations in the initial model.
this property de nes how well the system will react to disturbances and inaccurate measurements.
one advantage of using control systems in self adaptive software is that the above four properties of a controller can be guaranteed analytically given the mathematical de nition of the control system.
thus a self adaptive system based on control can provide the user with quantitative guarantees on its convergence the time to convergence and its robustness in the face of errors and noise.
since the advent of autonomic computing and the increasing popularity of self adaptive software both in research and industry many software controllers adopted the popular feedback loop scheme .
however in most of these cases the similarities with control theory end with the name.
indeed the use of control theory requires modeling software behavior as a dynamic system i.e.
by means of a system of di erential or di erence equations.
abstracting software behavior as a dynamic system is in general a non trivial task requiring mathematical skills and expertise not mastered by most software engineers.
model identi cation methodologies could reduce such di culty.
on the other hand the availability of a broad set of o the shelf identi cation procedures could lead to accurate models but with a complexity that makes them quite hard to control .
the next section describes our methodology for automatically synthesizing a control system that provides these properties for some non functional aspect of a software system.
.
control methodology this section describes our methodology for automatically devising controllers for adaptable software systems.
users provide the initial software system and indicate a tunable parameter or control variable that can change the dynamic behavior of the system.
additionally the users should specify a non functional requirement for the system to control.
critically the methodology needs no prior knowledge of the tunable parameter s e ects on the speci ed non functional aspect.
instead an appropriate model and control system is automatically devised by the methodology.
for example a user might specify a web service as the software the number of servers allocated to the service as the tunable parameter and the response time as the aspect to be controlled.
given these inputs our methodology will devise a controller that guarantees the desired response by dynamically tuning the server allocation based on measured performance feedback.
the methodology works in two phases as illustrated in fig.
.
first it pro les the software system the block labeled mb in the gure to build a model mapping parameter settings into feedback measurements.
second the methodology uses this model to synthesize a control system labeledc z capable of managing the software s desired non functional behavior.
di erent controllers can be synthesized which trade increasing computational complexity for increased robustness to approximations in the model or unpredictable environmental changes.
.
model building phase our methodology rst builds a model of the system to be controlled.
it starts by testing a set of systematically sampled values of the control variable and measuring the effect on the speci ed non functional requirement.
this process produces a mapping of variable setting to measured feedback.
continuing the web example model identi cation measures response time for di erent numbers of servers.
the model building phase uses arpe to build a rst order model of the reaction to the control variable.
arpe is based on linear regression and we con gure it to identify a model of the form k k where is our measured e ect and is the control variable setting.
arpe determines the value of which is then used to synthesize the control system.
the linear model given by may not capture small variations that arise in real systems and it does not deal with abrupt changes in the operating point like one server becoming unreachable in the platform due to hardware or network failures.
however there are many cases where simple linear models e ectively capture a trend .
for example increasing the number of servers allocated in our web service example will always speed it up until it reaches the application s maximum parallelism then the computation speed will not increase.
to be e ective the model does not need to capture the exact relationship between the number of servers and the speedup.
to overcome potential errors in the model our methodology generates three di erent control systems.
each represents a tradeo between the computational cost of the controller and its robustness.
the rst controller has the lowest computational cost and is robust as long as the model captures the trend.
the second controller requires more computation but it updates the identi ed model online allowing the system to overcome some unmodeled dynamics and nonlinearities.
the third controller is the most computationally expensive but overcomes dramatic errors by deriving a completely new model online instead of incrementally updating it.
the rst controller is described in section .
and is used as a baseline to build the second and the third whose online correction mechanisms are described in section .
.
the controller s ability to overcome approximations in the model is discussed in section .
.
.
controller synthesis phase in the second phase our methodology performs automated control synthesis starting from the model identi ed in .
its goal is to build a control system that tracks the setpoint rejects disturbances and tolerates errors in the identi ed model.
we will refer to the setpoint as and the measured feedback at time kas k .
we can measure how well the controller is tracking the setpoint by calculating the error at time kase k k .
small errors indicate the controller is tracking the setpoint well.
a major advantage of control theory is that it provides analytical guarantees about the self adaptive software system and thus achieves predictable behavior in the presence of variability.
we perform this analysis using the ztransform a frequency domain representation of a discrete time control signal like that in equation .
for example c z represents the z transform of the controller 301mbc z p z control normal mode model building mode figure basic scheme for the rst control solution the control strategy is switched between a rst model building phase and a second normal operation mode where the controller uses the model built in the previous step.
whilep z represents that of the plant i.e.
the software system .
here z 1is the unit delay encoding the temporal shift between the actuation and its e ect.
we perform analysis in the z domain because so makes it easy to prove that the control system has the desired properties.
transforming the discrete time system into a z transform equivalent allows us to use the concept of transfer functions which capture the input output relationship of a function.
for example a controller takes the error signale k as input and outputs a control variable k .
in the z domain the relationship between these two values is expressed as the z transform of the output divided by the z transform of the input signal i.e.
c z n z e z .
our methodology designs the controller by determining the functionc z that achieves the desired properties.
it then performs an inverse transform to produce a set of di erence equations that control the behavior of the self adaptive software.
this section describes the process the methodology uses to devise these control equations.
given a model identi ed in the previous phase the methodology rst determines the z transform of the model given by equation z m z n z where m z is the z transform of the discrete time feedback signal k and n z transforms k .
the control system should select k to obtain a certain k with the properties described in section the guarantee that the system will reach the selected value in a nite time possibly smaller than a prescribed value and the ability to withstand perturbations and variations.
in order to synthesize the controller once for all possible systems we need to express the transfer function p z of the plant software system .
its input is n z while the output is m z therefore p z follows from eq.
p z m z n z z our goal is to design a controller with transfer function c z that ensures the desired properties of the self adaptive software system.
the controlled system the closed loop feedback system has a transfer function g z which is affected by both the controller and the plant g z p z c z p z c z thus g z is an arbitrary transfer function representing the relationship between the setpoint m z and the feedback m z .g z represents a family of controllers with di erent tradeo s between their settling time and ability to track the setpoint while rejecting disturbances.
this tradeo is determined by the polepofg z i.e.
the value for which the function approaches in nity.
for stability we require p .
larger values of pproduce longer settling times and greater disturbance rejections.
thus our methodology considers transfer functions of the form g z p z p knowingg z from eq.
and p z from eq.
we can solve eq.
to nd a family of stable controllers that will track the desired set point c z p z z the input of the controller is the error between m z and m z while its output is n z .
c z n z m z m z p z z given this z transform of the controller the methodology simply performs an inverse z transform to convert into a discrete time relationship which can easily be implemented in software.
recalling that e k k k the methodology synthesizes the controller as k k p e k this equation selects the value of the control variable based on its previous value and on the error between the desired e ect and its measured value.
the formal assessment of the properties that this control strategy o ers are described in section .
.
.
online model updates this section discusses the three separate mechanisms our methodology uses to provide robustness despite approximations in the models.
each technique uses a di erent strategy toupdate the model dynamically in response to system variations or model errors.
the three techniques are implicit model updating incremental explicit updating and model rebuilding.
each extends the previous one adding additional computation to achieve increased robustness.
.
.
implicit model update the rst technique is to simply apply the controller of section .
without any explicit update mechanism.
this technique can overcome modeling errors as long as the model captures the general trend of the relationship between the control variable and the measured feedback.
this solution requires simply measuring feedback and computing the control variable according to .
thus the computational complexity is simply o with a small constant factor.
remarkably this simple system is robust even for extremely noisy applications as long as there are no drastic changes in the trend represented in the model.
our empirical evaluations shows one case study where this controller achieves good results despite a noisy application domain.
.
.
explicit incremental update the second technique works when the online variations are relatively small i.e.
if the application enters a new phase with a di erent computational load.
in this case the methodology continuously updates an estimate of see while the controller executes.
using this technique our methodology produces an adaptive controller that automatically adjusts itself to accomplish its mission despite changes in the system s dynamics.
the value of is estimated using a kalman lter .
s initial value is the result of the linear regression applied during the model building phase.
in order to track possible changes in its value the methodology assumes varies slowly.
the observations coming from data collected online are usually noisy because of possible intrinsic randomness in the involved phenomena.
assuming the noise is gaussian with variance q the resulting dynamic model used for the kalman lter is as k k k k k !
k as k where!
n q .
using the kalman lter the system estimates the model s slope at time kas k .
this estimate ofalpha is then substituted into so that the controller acts with the most recent update to the model.
computing the kalman lter updates is still constant time in terms of complexity but with a larger constant factor because the kalman lter must be updated at every time step.
incremental model updates provide robustness despite shifts and variations in the system allowing control to be applied even when no single model can capture all dynamics of the deployed system.
this approach also allows the controller s linear model to capture unmodeled non linearities by constantly updating the slope of the model at the current operating point.
this update process is analogous to approximating a curve with a series of tangent lines.
.
.
model rebuilding the third technique provides the greatest robustness at a cost of the greatest complexity.
consequently this technique can handle abrupt variations like a server failure or other catastrophic change in the system.
this technique augments the incremental update process by adding a change point detection procedure to identify when an abrupt change in the environmental conditions requires to restarts the estimation procedure described in section .
.
speci cally the methodology considers a time window of n control actions.
it then computes the average error e1for the rstn samples and the average error e2for the second n samples.
ifje1 e2j threshold then the rebuilding phase is triggered.
this technique prevents triggering a rebuild when the goal is infeasible.
this choice despite its simplicity is general enough to work in almost all cases.
regardless this component is modular permitting a di erent strategy to be substituted for speci c situations.
the discussion of the best change point detection technique is outside the scope of this work.
rebuilding the model requires sampling the control variable at di erent operating points resulting in a complexity of o n wherenis the number of possible settings for the variable.
building a new model from scratch when the error is high ensures that the control system accounts for the current sys tem dynamics.
notice that with a reasonably long time horizon the incremental updates will eventually converge to the same operating point as the rebuilt model but we add this safety feature to increase the convergence speed in the face of drastic unpredicted environmental uctuations.
if the error stays within the acceptable bound the rebuilding will never be triggered and the overhead will not be incurred.
.
formal assessment assessing the properties of the controlled system is mainly a matter of checking the model and controller equations.
recalling section we would like to check that the system is stable has a low settling time does not overshoot and is robust to model inaccuracies.
this analysis can largely be performed in the z domain.
the z transform that represents the controlled system is given by equation .
the rst three properties can be ensured directly from this equation.
enforcing the stability of the controlled system means ensuring that the pole pis non negative and less than i.e.
p .
therefore our methodology will only emit poles in this valid range.
the settling time of the controlled system is also determined from equation .
its inverse transform is k pk thus askincreases the system approaches .
we de ne the settling time as the time it takes the system to achieve of the nal value of i.e.
the system s operating point is only a small distance from the desired goal.
we refer to this region which is within of the goal as the con dence zone.
analyzing equation the rst value of kfor which our output enters the con dence zone is k log logjpj which means that after k control steps the signal reaches the con dence zone.
that value depends on which is usually chosen to be de ning the con dence zone as the interval in which the controlled variable has reached of its nal value.
in that case k log logjpj which depends only onp.
therefore the position of the pole determines also how fast the system will reach its equilibrium.
the pole s value pcan be used to trade responsiveness how fast the controller reacts measured as settling time and robustness in the face of noise or unmodeled variance in system behavior.
the controller acts based on its model or estimation of the e ect of its action on the system.
as noted above even the simplest formulation of the controller can overcome errors in the model because the system actively incorporates feedback which keeps the controller informed of the e ect of its action.
to complete the tradeo analysis we show the relationship of the pole pto the error the system can withstand.
assume our methodology estimates k as k but the true value is k k .
this multiplicative perturbation is often used to quantify the error of an estimation.
for example implies that the estimate may be times smaller or larger than the true value.
we test the largest perturbation that our system can withstand while still tracking the setpoint.
in other words we want to nd the values of k for which our plant is still stable.
the plant transfer function p z is z therefore given a perturbation it becomes p z z. the con 303troller transfer function is c z p z z .
the controlled system s transfer function under perturbation becomes g c z p z c z p z p z p which is again stable and without oscillation if and only if the two denominator poles are between and .
thus for a stable system k p which means that choosing the value of the pole pde nes how safely the controller acts with respect to model perturbations.
if p is the estimation can be inaccurate by a factor of .
in conclusion there is a fundamental tradeo between the controller reactivity and the safety with respect to perturbations that the controller can withstand.
this tradeo can be exploited carefully choosing the pole p. this relationship between the pole and the tolerable perturbation quanti es what we mean when we say the basic control system will provide implicit model updating as long as the model captures the trend between the control variable and the feedback signal.
for example for a pole of p the system can tolerate a perturbation of .
suppose the methodology provides a model that estimates speedup as a function of allocated servers.
the predicted speedup can be o by a factor of without a ecting setpoint tracking and stability.
the additional techniques of incremental model updating and model rebuilding allow the controlled system to update the model and provide these same guarantees in the face of unmodeled non linearities that exceed the tolerable perturbation or catastrophic system failures that invalidate the model completely.
we note that the methodology outputs control systems providing these guarantees despite the fact that it begins with no a priori knowledge of the control variable.
.
experimental evaluation in this section we describe our experimental evaluation.
we have three di erent case studies each demonstrating one of the three strategies for dynamically updating the controller s model.
we evaluate the rst two results by means of two common metrics the mean square error mse and the mean average percentage error mape .
recalling that represents the goal and its actual value the mse and mape are de ned as mse nnx i mape nnx i i i clearly the mse and mape represent two di erent metrics on the system.
the mse is related to the quantity involved in the sense that if the signals have a low magnitude the mse can be small but still represent signi cant errors.
on the contrary the mape is a relative number that determines how far from optimal the system is.
in the third test case we will show some images of the controller behavior to make it easy to visibly grasp the bene ts of using our methodology to automatically devise control strategies.
.
video compression the rst case study deals with video compression.
we suppose that a camera is recording a video to be streamed over the network and stored in an archive.
our case studystarted thinking of surveillance video but this is not the only example that we can come up with to justify our choice.
for example if you have limited channel to stream news video like bbc or cnn you might want to do something similar.
we divide the video into frames using one jpg for each frame and send the frame separately over the network.
the frames can be preprocessed to reduce the quality of the image as much as possible maintaining however some acceptable standards on the resulting quality.
the quality loss should enable us to reduce the size of the compressed image and therefore the disk space needed to store the frames.
our primary aim is the image quality reduction that should follow a certain setpoint.
in this case our software system is the video encoder.
our non functional requirement is the quality of the compressed videos quanti ed as structural similarity ssim index .
ssim is a unitless metric that ranges from to with values closer to indicating images that are very close.
we use ssim to quantify the quality loss due to compression.
in this example our control variable is a command line parameter that indicates the density of the compression procedure.
given these inputs we use our methodology to automatically devise a control system that selects the density parameter for the next frame based on the measured ssim score for the previous frame.
we evaluate our methodology by running the compression scheme with the synthesized controller for a number of videos.
for each video we compute the average compression percentage c per frame the average ssim the mse and mape.
the data are reported in table .
as can be seen with all the videos we achieve a reduction in space that is superior to reducing the quality.
our value is sometimes superior to the setpoint since the image could not have been reduced further without a too big quality loss for example in the ssim version of pumpkin candle .
the procedure is shown to work both with high resolution videos and with low resolution ones.
the reduction in size is a consequence of the quality setpoint but it can be noted that the controller invariably achieves good compression and setpoint tracking.
in fact the mse and mape values are uniformly low.
.
energy control our second case study also deals with video compression however to demonstrate the generality of the approach we now control energy instead of quality.
this can be useful to extend battery life when encoding video on a mobile device or to save energy bills when working on servers.
we can in uence the energy of the system by changing the speed of the processor.
recent processors support tradeo s between the processor speed and energy allowing the system to perform more work for a greater energy consumption .
we would like to use our methodology to synthesize a controller which will maintain energy goals.
again our software system is the video encoder.
our non functional requirement is now the energy consumption of the video encoder running on our intel xeon dual socket e5 system.
the system is connected to a wattsup device that provides real time feedback of full system energy consumption.
in this case we measure energy consumption relative to the default con guration with the processors at full speed.
in this example our control variable is the processor s clock speed which is available to software through304table video compression through density reduction results.
the resulting quality is close to the speci ed goal.
thanks to the compression there is an evident reduction in the video size.
video frames resolution goal mse mape size o size c c obama victory speech .
.
.
.
.
mb48.
mb .
.
.
.
.
.
mb .
samsung advertisment .
.
.
.
.
mb34.
mb .
.
.
.
.
.
mb .
amazing nature .
.
.
.
.
mb141.
mb .
.
.
.
.
.
mb .
planet earth from space .
.
.
.
.
mb417.
mb .
.
.
.
.
.
mb .
lawnmower .
.
.
.
.
mb50.
mb .
.
.
.
.
.
mb .
night tra c .
.
.
.
.
mb8.
mb .
.
.
.
.
.
mb .
new york tra c .
.
.
.
.
mb21.
mb .
.
.
.
.
.
mb .
pumpkin candle .
.
.
.
.
mb10.
mb .
.
.
.
.
.
mb .
raining .
.
.
.
.
mb32.
mb .
.
.
.
.
.
mb .
speedometer .
.
.
.
.
mb15.
mb .
.
.
.
.
.
mb .
alpha centaury .
.
.
.
.
mb4.
mb .
.
.
.
.
.
mb .
thecpufrequtils package in linux.
with these inputs we use our methodology to automatically devise a control system that selects the processor speed for the next frame based on the measured energy consumption of the previous frame.
we evaluate our methodology by running the encoder with the synthesized controller for several videos.
for each video we set two targets the rst is an energy e ciency improvement of and the second is .
we use our methodology to automatically generate one controller that uses implicit updating and one that does incremental updating with the kalman lter.
for each video we run each controller for each energy goal and report the results in table which shows the average energy e ciency gain as well as the mse and mape.
as shown in the table all videos achieve average energy consumption very close to the desired value with uniformly low mse and mape.
while both controllers provide good results the kalman ler tends to have lower error.
we note that these energy e ciencies include the overhead of running the controller itself.
.
service dynamic binding in the context of service oriented architectures soa dynamic binding is the mechanism allowing abstract operations to be mapped to concrete components implementing them.
if multiple functionally equivalent implementations are available for an abstract operation the selection among them is usually based on their non functional properties e.g.
in .
consider for example a software providing a geo localization service that has to assure a certain reliability per request .
this means that whenever a request is issued the service can fail to serve it with a probability of at most .
assume the ab stract localization operation could be backed either on the servicess1 maps or s2 maps.
the availability of each of these two alternatives may change at runtime for example because of changing load conditions network timeouts or maintenance.
the goal of the dynamic binder is to decide for each incoming request which alternative to select in order to continuously provide the desired reliability in spite of possible changes in the reliabilities of s1 ands2.
in we faced this problem by manually modeling the behavior of the system through a discrete time markov chain and devising a suitable controller by hand.
in this work we consider the software as a black box and let our methodology automatically construct a model of it and generate a suitable controller1.
we assume a monitoring infrastructure estimating at each time pointkthe actual reliability k of our geo localization service and feeding its current value to the controller.
the error is then quanti ed as the di erence between the monitored reliability and its target setpoint k .
the goal of the controller is to decide the value of the control variable which represents the probability of selecting s1 in order to keep the error as close as possible to consequently the probability of selecting s2 is .
our experiments are reported in figure .
all plots show the initial model building phase emphasized by a di erent background pattern when the domain of the control variable is explored in order to approximate its relation with 1as explained in having a module able to automatically decide the dynamic binding problem between two alternatives is enough to solve the multiple alternative problem by composing multiple instances of it into a binary decision tree.305table results controlling energy consumption.
video frames resolution goal controller mse mape blue sky1080p25 .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
crowd run1080p .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
ducks take o 1080p .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
factory .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
intotree1080p .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
oldtown cross 1080p .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
pedestrian area .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
station2 .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
sun ower .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
tractor .
implicit update .
.
.
.
kalman .
.
.
.
implicit update .
.
.
.
kalman .
.
.
the measured reliability.
figures 2a and 2b show the step response of two automatically generated controllers.
the rst was con gured to have a pole in while the second in .
as expected from the discussion of section both of the controllers are stable and converge to the setpoint when feasible.
the former has a longer settling time than the latter after a change in the setpoint occurs.
although when settled the two controllers show a coherent behavior leading exactly to the same steady state performance.
notice also at time the goal becomes unfeasible and both of the controllers keep trying to minimize the error moving the actual reliability as close as possible to the setpoint.
figures 2c and 2d replicates the same scenario of 2a and 2b but with the addition of white noise with a standard deviation of 2and bounded by to each of the reliabilities of s1 ands2.
despite its longer settling time the controller with pole in shows a signi cantly more ef fective rejection of the disturbances than the controller with pole in .
the former is also more e ective in avoiding overshooting the control signals while the latter introduces many spikes temporarily compromising the stability of the controlled system.
this is an empirical example of trade o between short settling time and robustness to noise that has been discussed in section which requires a careful decision about the position of the pole.
figure 2e shows the situation where the reliability of s1 changes smoothly.
thanks to the continuous tracking of enacted by the kalman lter the model of the system is updated online allowing the controller to cope with the variations without undergoing a new identi cation phase.
finally in figure 2f the case of an abrupt change in the reliabilities of s1 ands2 is reported.
the reliabilities of the two services sharply change at time .
after a short time the change detection mechanism detects the change and triggers a model rebuilding.
the re 306sulting updated model captures the new situation allowing for e ective control.
a matlab implementation of this case study is available online2for simulation purposes.
numerical mathematical programming is an established instrument for control experts to study controller s performance by simulating disturbances and process dynamics.
a java prototype implementation based on the spring framework can be downloaded.
spring is an industrial strength lightweight container for j2ee applications.
the monitoring infrastructure and the controller have been implemented through the spring aspect oriented programming aop features to show how our methodology can be integrated in existing applications without an unfeasible burden on the established development cycle for further details on the spring framework please refer to or the o cial website3 .
a running instance of the spring implementation is also accessible from previous url with a web interface to ease the demonstration.
.
related work adaptation is becoming a key concern in software applications .
an adaptive application must select from many con gurations the one that is most appropriate to obtain some speci c performance result.
there are many examples from hardware to software development.
the evaluation of a new microprocessor design requires studying the impact of input data sets and workload composition .
compiler level advancements have been developed to support adaptive implementations for performance or power and low level architectures are dynamically adjusted and targeted .
another example comes from high performance computing where it is common to change an application parameter to adapt a running application.
in a threshold value is changed while executing parallel monte carlo ocean color simulations while presents a study on tuning fast fourier transformations on graphic processing units.
also rahman et al.
and tiwari et al.
studied the e ect of compiler parameters on both performance and power energy consumption for scienti c computing.
a lot of modeling and tuning e ort has recently been devoted to the speci c application of mapreduce .
self management techniques are also prominent in industry e.g.
companies like ibm see projects like the ibm touchpoint simulator the k42 operating system oracle oracle automatic workload repository and intel intel ras technologies for enterprise .
control theory is capturing an increasing interest from the software engineering community that looks at selfmanagement as a means to meet qos requirements despite unpredictable changes of the execution environment .
examples of this trend can be seen in research on control of web servers data centers and clusters management operating systems and across the system stack .
the application of control theory in software engineering however is still in a very preliminary stage.
developing accurate system models for software is in fact hard.
moreover strong mathematical skills are needed in order to deal with complex non linear dynamics of real systems .
filieri icse control di culties usually lead to the design of controllers focused on particular operating regions or conditions and ad hoc solutions that address a speci c computing problem using control theory but do not generalize .
for example in the speci c problem of building a controller for a .net thread pool is addressed.
this work aims at leveraging the e ort of adopting formally guaranteed control theory methods for software adaptation by providing a widely applicable push button methodology which reduces the need for strong mathematical background to devise ad hoc modeling and control solutions.
despite their broad variety most of the methodologies for the development of self adaptive applications resembles a three steps process data collection and analysis modeling and control.
the glue of the whole process is usually the software model.
it has indeed the purpose of lling the gap between the possible control choices and the e ect they have on the satisfaction of the requirements.
this is not a novelty of self adaptive software but its advent is casting a new light on the property such model has to satisfy while complex precise quality models have been used in the past to enable design time optimization of software architectures such complexity often inhibits their applicability for runtime adaptation because of the short time available for veri cation and control .
our methodology proposes a systematic data collection procedure enabling the automatic construction of an approximate model.
once built through a rst identi cation phase such model can easily be kept updated online and allows for the application of established and e ective control results.
.
conclusion and future work this paper proposes a methodology that takes a tunable variable and feedback mechanism to produce a closed loop control strategy that provides formal guarantees for an adaptive software system s dynamic behavior.
the methodology leverages control theory to prove that whenever the desired behavior is feasible our controller is capable of selecting the appropriate variable setting to achieve the goal despite unpredicted disturbances and approximate estimates and measurements.
our results show that it is possible to automatically design a controller that trades o responsiveness and robustness to model perturbations.
this methodology makes it possible for non experts to build self adaptive software that bene ts from mathematically grounded control theoretic techniques and their formal guarantees without the background needed to design ad hoc solutions which might however be needed to improve the controller performance on speci c problems.
our system would work also in case of multiple independent control variables and output measures however we plan to study an automatic control synthesis technique for coupled multiple input multiple output mimo systems i.e.
when the controller needs to coordinate several control variables toward the satisfaction of multiple possibly con icting objective requirements.
we also plan to incorporate the synthesis of multiple di erent controllers and to switch between those strategies at runtime allowing to continuously adjust the trade o between responsiveness and robustness.
in addition we plan to exploit the capabilities of the kalman lter to forecast future values of and de ne a proactive control strategy to support complex adaptation strategies.
.
.
.751setpoint actual reliability .
.
.751reliability s1 reliability s2 .
.
.751control control a p .
.
.
.
.
.
.
.
.
b p .
.
.
.
.
.
.
.
.
c p noisy .
.
.
.
.
.
.
.
.
d p noisy .
.
.
.
.
.
.
.
.
e p kalman tracking .
.
.
time .
.
.
time .
.
.
time f p change point detection figure behavior of the dynamic binding system in di erent conditions and for di erent con gurations.
.