identifying the characteristics of vulnerable code changes an empirical study amiangshu bosu dept.
of computer science university of alabama tuscaloosa al usa asbosu ua.edujeffrey c. carver dept.
of computer science university of alabama tuscaloosa al usa carver cs.ua.edumunawar hafiz dept.
of computer science auburn university auburn al usa munawar auburn.edu patrick hilley dept.
of math and computer science providence college providence ri usa philley friars.providence.eduderek janni dept.
of mathematical sciences lewis clark college portland or usa derekjanni lclark.edu abstract to focus the efforts of security experts the goals of this empirical study are to analyze which security vulnerabilities can be discovered by code review identify characteristics of vulnerable code changes and identify characteristics of developers likely to introduce vulnerabilities.
using a three stage manual and automated process we analyzed code review requests from open source projects and identified vulnerable code changes vcc .
some key results include code review can identify common types of vulnerabilities while more experienced contributors authored the majority of the vccs the less experienced contributors changes were .
to times more likely to be vulnerable the likelihood of a vulnerability increases with the number of lines changed and modified files are more likely to contain vulnerabilities than new files.
knowing which code changes are more prone to contain vulnerabilities may allow a security expert to concentrate on a smaller subset of submitted code changes.
moreover we recommend that projects should a create or adapt secure coding guidelines b create a dedicated security review team c ensure detailed comments during review to help knowledge dissemination and d encourage developers to make small incremental changes rather than large changes.
categories and subject descriptors k. .
software management software development software process general terms measurement security human factors permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.keywords code review security defects open source vulnerability inspection .
introduction a project manager s life is full of analyzing trade offs in the course of making important decisions.
one important decision is to allocate appropriate resources to identify security vulnerabilities and fix the root causes in order to deliver a secure and error free product.
it takes an expert to effectively perform security critical tasks but experts are a scarce resource .
a project manager should ensure that a product gets optimum attention from security experts that too very early in the development cycle.
modern software development is incremental and evolutionary i.e.
make a small change submit the change validate the suggested change via peer code reviews and merge the change into the main codebase.
a project manager interested in security will find it appealing to be able to filter changes that have potential vulnerabilities and identify the root causes of those vulnerabilities before the changed code becomes production code.
the objective of this study isto use data from open source software oss projects to identify characteristics that indicate which code changes are likely to contain vulnerabilities so that managers can more effectively focus the security experts effort on those changes.
specifically we explore the characteristics of the vulnerabilities identified during code review which types of code changes are more likely to contain vulnerabilities and which types of developers are more likely to introduce code changes that contain vulnerabilities.
to facilitate this exploration we define vulnerable codechanges vcc as code changes that contain exploitable vulnerabilities.
there have been numerous efforts to characterize vulnerable code or modules as described in section .
.
our approach differs from these previous efforts in two key ways our study focuses on data gathered during the peer code review process and in addition to identifying characteristics of vulnerable code we also identify characteristics of the authors of vulnerable code.
first we focus on data gathered during the peer code review process for a number of important reasons as follows.
peer code review data is rich because it documents the discussion between the developers and reviewers regarding potential defects.
when the defect contains a security vulnerability these discussions have the potential to provide additional insight about the source of thatpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
vulnerability.
datasets created from defect repositories the approach used in most prior studies may contain vulnerabilities that were identified before release as well as vulnerabilities that were identified after release.
conversely the dataset created from the code review repository contains only vulnerabilities detected before the code was merged into the main branch i.e.
before release .
vccs identified during code review contain vulnerabilities that could be eliminated prior to release by using careful coding and review techniques.
the longer it takes to detect and fix a security vulnerability the more that vulnerability will cost .
therefore eliminating vulnerabilities early via careful coding and reviewing should help to reduce the cost of developing secure software.
second our focus on identifying characteristics of the authors who contribute vulnerable code is motivated by the importance of human factors in all aspects of software development.
we hypothesize that differences among developers knowledge experience and motivation will affect their likelihood of authoring vccs.
there have not been many studies investigating this issue.
this study characterizes the authors who create vccs based on their project experience and whether they are volunteers or full time paid participants in the oss projects.
knowing which code changes are more prone to contain vulnerabilities will allow a project manager to focus the security experts efforts on a smaller subset of submitted code changes.
for example code changes that exhibit the characteristics identified in our study should be integrated to the project only after a careful review from a security expert.
conversely changes that are less prone to containing a vulnerability would only go to a security expert if one of the other reviewers raised a potential security concern.
this approach would prevent the security experts from wasting their valuable time performing tasks that could be performed by other reviewers who lack the security expertise.
to characterize the vccs we developed a method for analyzing peer code review requests mined from popular open source software oss projects.
each of these projects uses the gerrit code review tool which captures the data necessary for our analysis.
based on an empirically built and validated set of keywords we used a three stage systematic analysis process to identify vccs described in those peer review requests.
the main contributions of this work are as follows.
we provide empirical insights into the characteristics common to vccs their locations and their authors in the context of of code reviews we perform the first study to analyze security vulnerabilities using peer code review dataset and we describe an empirically sound methodology to systematically analyze large dataset via a manual and automated process.
the rest of the paper is organized as follows.
section provides background about security defects and peer code review.
section introduces the research questions.
section describes the research methodology.
section presents the results.
section discusses the implications of the results.
section addresses the threats to validity.
finally section concludes the paper.
.
background to familiarize the reader with the context and background of this study this section describes why we focused on a specific set of security vulnerabilities introduces previous research on characterizing vulnerable code and illustrates the benefits of peer code review in identifying security vulnerabilities.
.
security vulnerabilities hundreds of types of security vulnerabilities can occur in code design or system architecture.
the security community uses common weakness enumerations cwe to distinguish security vulnerabilities.
each security vulnerability is described by a cwe entry which contains a unique cwe id and a short specification description language severity and common causes .
variants of vulnerabilities e.g.
different ways to overflow a buffer are each represented by their own cwe id.
in this paper we concentrate on the ten most common vulnerability types as enumerated in table in section .
.
we chose those ten categories based on previous studies and the open web application security project owasp list .
.
characterizing vulnerable code previous researchers have sought to predict which components are likely to contain security vulnerabilities.
first regarding code attributes neuhaus et al.
s vulnerability prediction model for the mozilla projects predicted of the known vulnerabilities in the top of the vulnerable components with precision .
gegick et al.
s regression tree model built using lines of code alert density and code churn information identified of the vulnerable components with false positive rate .
in addition studies that attempted to correlate code complexity with the presence of vulnerabilities found a weak but significant correlation in the mozilla javascript engine and varying degrees of correlations in php applications .
code complexity metrics were also used to predict vulnerable files in mozilla firefox and linux kernel .
however a follow up study found the presence of non security defects as a better predictor of vulnerable components than code complexity metrics .
second regarding code commit characteristics researchers have focused on predicting vulnerabilities based on large number of commits commit size and code churn.
they have found that linux kernel files that underwent a large number of revisions were more likely to contain vulnerabilities .
also commits that contain vulnerabilities had twice as much code churn lines added modified or deleted to a file from one version to another as non vulnerable code commits which also suggests that larger commit size may harbor more vulnerabilities.
moreover three metrics on code churn were able to predict vulnerable files in the linux kernel and mozilla firefox .
third regarding human factors there are relatively few studies that use developer characteristics to predict vulnerabilities i.e.
the type of developers that are most likely to create vulnerabilities .
studies found linux kernel files modified by more than nine developers and apache files modified by a new effective author i.e.
modifying a file for the first time were more likely to be vulnerable.
finally shin et.
al.
found metrics about a developer s social network that could predict vulnerable files .
most of the prior studies focused on code and file metrics with a few studies that consider human aspects.
our current study differs from these previous works by focusing on three factors i.e.
human aspects the characteristics of the vccs and vulnerability locations together using one dataset.
.
peer code review peer code review is the process of analyzing code written by a teammate i.e.
a peer to judge whether it is of sufficient quality to be integrated into the main project codebase.
this informal type of software inspection has been established as an effective quality improvement approach .
for many software teams the relatively high cost of the traditional inspection process often258outweighs its benefits thereby reducing the prevalence of formal inspections in practice .
on the other hand oss communities have championed the use of a more informal code review process via electronic communication e.g.
mailing lists .
recently many mature successful oss projects have mandated peer code reviews to ensure the quality and integrity of code integrated into the main project branch.
compared with the traditional fagan style code inspection contemporary peer code reviews are more informal tool based and occur regularly in practice .
in addition to their positive effect on software quality in general code reviews can be an important practice for detecting and fixing security bugs early .
for example an expert reviewer can identify potentially vulnerable code and help the author eliminate the vulnerability or decide to abandon code.
peer code review can also identify attempts to insert malicious code.
oss and commercial organizations have both been increasingly adopting tools to manage the peer code review process .
for this study we chose ten oss projects that used the gerrit code review tool to manage their code review process.
gerrit is one of the most popular open source code review tools.
this web based tool is under active development and is used by many large and popular oss projects.
in addition gerrit integrates with the git version control system.
developers make local changes and then submit the patchset all files added or modified in a single revision to a gerrit repository for review.
the gerrit interface facilitates the review process by showing the changes side by side and allowing reviewers to add inline comments about the code an example is shown in figure in section .
the author can then respond to the comments.
gerrit documents this discussion between the author and the reviewer.
if reviewers suggest changes the author can make those changes and upload a new patchset.
this process repeats until the reviewers approve the patchset which can then be merged into the main project branch.
for more details a typical workflow of a gerrit code review can be found in the android developer guide life of a patch .
.
research questions the goal of this study is to empirically analyze the types of vulnerabilities detected in code reviews the characteristics of vccs and the characteristics of developers who are more likely to authors these vccs.
the following subsections introduce six research questions two about each of the following topics characteristics of vulnerabilities locations of vulnerabilities and characteristics of developers writing vulnerabilities.
.
characteristics of vulnerabilities types of vulnerabilities detected the most foundational question is which types of vulnerabilities can be identified via peer code review.
this information will help project managers understand what effects the addition of peer code review can have on the overall security of their software projects.
to gather this information the first research question is rq1 which types of vulnerabilities do reviewers detect during peer code review?
vccs likely to be abandoned not only is it important to identify which types of vulnerabilities can be detected through peer code review it is also important to understand whether developers fix those vulnerabilities or abandon them.
when a reviewer identifies a vulnerability in a patchset the author can choose either to fix the vulnerability or to abandon the change.
the patchset cannot be merged into the main code branch unless the author fixes thevulnerability.
because a code author s goal is to have her changes merged into the main code branch she will attempt to address all comments by a reviewer and only abandon those changes that are too difficult to fix.
therefore the abandonment rate of vccs during peer code review is a good indication of the relative difficulty of fixing various types of vulnerabilities.
the next question addresses this issue.
rq2 vccs containing which types of vulnerabilities are more likely to be abandoned?
.
locations of vulnerabilities size of the files patchsets containing vulnerabilities prior studies have shown that code churn is a predictor of defect density .
to determine whether this relationship holds specifically for security vulnerabilities the next research question is rq3 is the amount of code churn in patchsets and files that contain vulnerabilities significantly larger than it is in patchsets and files that do not contain vulnerability?
type of the files patchsets containing vulnerabilities there is no clear evidence about whether new code or changes to existing code is more likely to contain vulnerabilities.
we can make the following arguments on both sides of the issue.
regarding new code during early stages of code development it is reasonable to assume that a developer may be more focused on the functionality of that module than on security.
thus a developer may introduce more security vulnerabilities in early versions of the code.
regarding changes to existing code because that code has already been examined by numerous developers many of the security vulnerabilities will likely have been identified and removed.
when developers modify existing code they can see how previous authors have coded securely and copy the coding style.
these practices would suggest that existing code has less vulnerabilities than new code.
conversely developers may modify files without understanding the context and full implications of the changes.
this lack of knowledge could result in the introduction of vulnerabilities.
the next research question seeks to gather data to identify whether either of these relationships hold rq4 which type of files new or modified are more likely to have vulnerabilities?
.
characteristics of developers effect of author experience on vccs oss projects have code authors with varying experience and backgrounds.
one could argue that because novice programmers are often unaware of secure code practices they are more likely to introduce vulnerabilities.
conversely in more mature oss projects experienced developers are more likely to develop or modify the security critical components.
because they are working in the portion of the code that is more likely to be vulnerable experienced developers may author more vccs.
finally if most of the oss developers lack sufficient knowledge about security then developer experience might have no effect on the likelihood to introduce vulnerabilities.
this uncertainty leads to the next research question rq5 does an author s experience affect the likelihood of writing vccs?
effect of author s employment many popular oss projects are sponsored by commercial organizations e.g.
google android and redhat ovirt .
although the majority of the contributions in a259sponsored oss project come from the employees of the sponsoring organization sponsored employee there may be many other developers volunteers or employees from other organization that have an interest in the project .
sponsored employees and other contributors may have different motivations for participating in an oss project.
a volunteer s motivation may be learning through participation being a part of a intellectually stimulating project or trying to integrate his innovative ideas into the project .
the motivation of an employee from another organization may be to prioritize features that are important for his or her employer.
the primary motivation for a sponsored employee may be to align the project goals with the organizational focus and enhance the reputation of the sponsoring organization through reliable software.
these different motivations suggest that security may have a different priority for each type of contributor.
the motivation for a sponsored employee suggests that he or she may be less likely to create vulnerabilities than the other types of contributors.
our last research question investigates this question.
rq6 in cases where an oss project is sponsored by an organization are authors employed by that organization less likely to write vccs than other authors?
.
research method in our previous work on peer code review in oss projects we reported that members of oss communities often provide detailed review comments and suggestions about potential defects .
in another exploratory work we validated a set of keywords describing vulnerabilities and showed that using those keywords to text mine code review comments could identify code reviews that detected security vulnerabilities .
for example if a reviewer suspects the presence of a potential buffer overflow his her review comments will likely contain either buffer overflow or both.
building on those results we developed the stage methodology shown in figure and described as follows.
.
stage mining code review repositories following a similar approach as mukadam et al.
we developed the gerrit miner tool that can mine the publicly accessible code review data posted in a gerrit code review repository.
we identified oss projects that had publicly available gerrit repositories with regular code review activity.
in may we used gerritminer to mine the gerrit repositories of those oss projects.
to ensure that we had sufficient data for our analysis we chose the ten projects that each contained more than code review requests each.
each of these projects requires all code changes to be posted to gerrit for review prior to inclusion in the project.
we conducted a more detailed analysis on those ten projects listed in table .
.
stage building keyword set we searched the review comments with a set of keywords to identify potential vulnerabilities detected by reviewers.
because the effectiveness of a keyword based mining approach is highly dependent upon having the proper set of keywords we used an eight step empirical approach described below to identify the sets of keywords shown in the third column of table .
we based steps of the approach on prior text mining studies with modifications to fit our current context.
we used the text mining tm package of r to support the calculations in steps .
.
we created and refined an initial set of keywords.table keywords associated with vulnerabilities vulnerability typecwe id keywords race condition race racy buffer overflow buffer overflow stack integer overflow190 integer overflow signedness widthness underflow improper access22 290improper unauthenticated gain access permission cross site scripting xss cross site css xss htmlspecialchar php only denial of service dos crash248 755denial service dos crash deadlock deadlock sql injection sql sqli injection format string format string printf scanf cross site request forgery352 cross site request forgery csrf xsrf forged common keywords security vulnerability vulnerable hole exploit attack bypass backdoor common added later threat expose breach violate fatal blacklist overrun insecure .we searched the gerrit databases using the initial set of keywords to build a corpus of documents where each document was a code review comment containing at least one keyword.
.to handle the code snippets in the corpus documents we applied identifier splitting rules i.e.
isbufferfull became is buffer full or read string became read string .
.we then cleaned the corpus by removing white space punctuation and numbers.
we also converted all words to lowercase.
then we created a list of tokens for each document.
.
we applied the porter stemming algorithm to obtain the stem of each token e.g.
buffer buffered buffering all became buffer .
.
we created a document term matrix from the corpus.
.we determined whether any additional words co occurred frequently with each of our initial keywords co occurrence probability of .
in the same document .
.we manually analyzed this list of frequently co occurring additional words to determine whether to include any in the final keywords list.
the last row of table lists the keywords added through this method.
the result of this stage is an empirically built set of keywords that feed into stage .
.
stage building a dataset of potential vccs we divided this stage into three steps based on the study selection procedure in systematic literature reviews .
in the first step database search we queried the code review database created in stage for each project to identify code review requests with comments containing at least one of the keywords identified in stage .
this search resulted in a total of review comments.
in the second step comments audit two of the authors independently audited the comments of each code review identified in the database search to eliminate any reviews that clearly did not contain260figure three stage research method table overview of projects project domain technology loc using gerrit sincerequests minedycomments auditedthoroughly audited android mobile os c c java 13m october chromium os operating system c c 12m february gerrit code review management java gwt servlet 169k august itk vtk visualization toolkit c .1m august mediawiki wiki software php sql javascript 985k september omapzoom mobile dev.
platform c c 10m february openafs distributed file system c 1m july ovirt virtualization management java 843k october qt application framework c .5m may typo3 content management php sql javascript .1m august based on ohloh ymined during may 2013total vulnerabilities.
we excluded a review request only if both auditors independently determined that it should be irrelevant to vulnerability.
review requests that passed this step had the potential to have a security vulnerability.
this step reduced the number of candidates for vccs from to .
to illustrate this process consider three example review requests returned when we searched the keyword buffer in the android project.
in request a reviewer commented is this needed?
how do you notify the other cpu that the buffer is available?
although this comment has the keyword buffer the auditor determined that it is not related to a vulnerability and can therefore be eliminated.
figure shows two additional review requests and that contain the buffer keyword in the comments.
for these two requests because the comments suggested that there may be a vulnerability present we did not eliminate them.
in the third step thorough audit we thoroughly audited the code review discussions and associated patches for the review requests.
two authors independently audited the review request in detail to determine whether the reviewer identified a vulnerability.
if we found a vulnerability we classified the vulnerability based on cwe specification.
we considered a code change vulnerable only if a a reviewer raised concern about potential vulnerabilities b our manual analysis of the associated code segment indicated the presence of a vulnerability and c the code author either explicitly acknowledged the presence of the vulnerability in the review comments or implicitly acknowledged the presence of the vulnerability by making the recommended changes in the subsequent patches.
consider the two code reviews shown in figure .
in request top of figure the reviewer described a scenario in which the buffer overflow vulnerability may occur.
the author then ac knowledged that possibility explicitly in the comments.
this discussion confirmed that this change is a vcc and should be retained for further analysis.
in contrast in request bottom of figure the reviewer asked the author to add a description in the method signature to explain the behavior in case the caller method supplied an overflowed buffer e.g.
the name parameter is not null terminated .
this more detailed information made it clear that this change is not a vcc and should be excluded.
in this step we considered a code review request to be vulnerable only if both auditors agreed.
in case of any doubt author hafiz an expert in security vulnerabilities provided his suggestion to help the auditors reach a conclusion.
we calculated inter rater reliability using cohen s kappa .
kappa value for this step was found .
substantial .
table indicates the number of code review requests inspected during the three stages for each of the projects.
.
results using the approach in section we identified vccs across the projects see the total column in table .
for each vcc we extracted the following metrics about the vulnerability project review request id author reviewer date vulnerability type patch set number and number of lines changed.
in addition we computed metrics about the characteristics of the vcc author at the time the vcc was posted details in section .
.
the following subsections examine each of the research questions in detail.
1cohen s kappa values are interpreted as following .
as slight .
.
as fair .
.
as moderate .
.
as substantial and .
as almost perfect agreement261figure gerrit example keyword buffer overflow true buffer overflow top not a security defect bottom .
rq1 types of vulnerabilities detected table shows the vcc distribution across vulnerability types.
among the vccs we identified race conditions vulnerabilities were the most common specifically the time of check to time of use toctou cwe .
this result may be because many of the projects in the study have to manage shared resources across threads which may result in race conditions.
buffer overflow vulnerabilities were present in about of the vccs.
this result is expected because the buffer overflow vulnerability is prominently featured among all vulnerabilities reported in vulnerability repositories such as the national vulnerability database nvd .
also six of the ten projects that we analyzed are written in c c .
typically the buffer overflows we identified originated from either incorrect calculations of buffer size or from use of unsafe string functions e.g.
sprintf strlen andstrcmp which commonly occur in c c code.
integer overflow vulnerabilities which are similar to buffer overflows were the third most common type of vccs .
the two most common sources of these vccs were mistakes in integer arithmetic and failure to account for the differences in integers between bit and bit systems.
interestingly integer vulnerabilities were not limited to the c c projects.
eight of the ten projects included vccs that reported integer overflow issues.
we identified vccs reporting improper access vulnerabilities.
these review requests often generated a lot of attention and resulted in the involvement of project security experts during the review process see also rq2 in section .
.
the other category ranks fifth.
it includes cross site request forgery cwe memory leak cwe information leakage cwe security misconfiguration cwe and command injection cwe .
cross site scripting xss and denial of service dos vulnerabilities were less common.
web based applications are more sus ceptible to xss vulnerabilities.
our dataset contains only three web applications that could harbor xss vulnerabilties.
the low frequency of dos vulnerabilities may result from the fact that these vulnerabilities are often classified as other vulnerabilities.
for example a buffer overflow can lead to denial of service.
in our study we classified a vcc as reporting a dos vulnerability only if the review comments explicitly discussed a dos scenario.
the results show that peer code review identified various types of vulnerabilities.
peer code review identified all of the top security vulnerabilities as ranked by nvd .
however the ranking of the vulnerabilities found in our study differ from the ranking suggested by nvd.
xss buffer overflow and sql injection are the most commonly reported vulnerabilities in nvd .
in our study we identified fewer xss and sql injection vulnerabilities because there were fewer projects web and database applications that could have the vulnerabilities.
however considering web applications only xss vulnerabilities were very prominent mediawiki and typo3 .
sql injections were also present in mediawiki and typo3 each .
nevertheless the main conclusion from these results is not the ranking but the fact that all kinds of vulnerabilities are reported in vccs.
this results indicate that peer code review leads to the identification of different vulnerability types.
therefore projects concerned about security should adopt peer code review to identify vulnerabilities early.
.
rq2 vccs likely to be abandoned overall approximately of the vccs identified during peer review were merged into the code repository i.e.
they were not abandoned .
within that set of changes most authors fixed the vulnerability prior to merging the code into the trunk.
in a very few cases rather than fixing the vulnerability the author opened a new bug for the vulnerability and asked the reviewers to approve the change as is i.e.
with the vulnerability present .
figure shows that vccs containing some types of vulnerabilities were significantly more likely to be abandoned than vccs containing other types p .
vccs containing the improper accesses vulnerabilities the fourth most common type of vulnerability which threaten application integrity and data privacy were the most likely to be abandoned.
unlike buffer overflows andinteger overflows that are easier to fix improper access issues are more complicated architectural issues and have critical consequences that require involvement of managers or developers with design knowledge.
if the reviewer can hypothesize a scenario where an access violation may occur she will reject the change and instruct the author to redesign the solution.
this requirement for additional work likely led to the high abandonment rate for vccs with improper access vulnerabilities.
vccs related to deadlock andother vulnerabilities which were found at relatively low rates were also abandoned at a high rate.
vccs related to the two most common vulnerabilities buffer overflowandrace condition were abandoned at a moderate rate between to .
while most vulnerability types were frequently fixed some of the most critical vulnerabilities were fixed less often.
in general vulnerabilities identified during code review are easy to fix.
although special attention needs to be given to the most critical vulnerabilities due to their relatively high abandonment rate.
.
rq3 size of the files patchsets containing vulnerabilities we define nlc number of lineschurned as the total number of lines changed added or removed in a file between revisions.
because the projects included in this study all required code changes to be posted to gerrit it can be said that gerrit is the262table number of vulnerabilities identified project race buffer integer improper xss dos deadlock sql format other total condition overflow overflow access crash injection string android chromium os gerrit itk vtk mediawiki omapzoom openafs ovirt qt typo3 total of total figure status of vulnerable code changes gatekeeper between the developer s local branch and the main code base .
this requirement means that some very large patchsets were submitted to gerrit to follow the policy but were likely not reviewed.
consistent with the result of a prior study our manual inspection of some of these large patchsets indicated that they were performing tasks like merging branches importing new versions of third party libraries importing externally developed code or changing copyright information.
to ensure that our analysis only included changes that actually underwent peer code review we needed to eliminate this type of change.
because it was not possible to manually review all the large changes we used an alternate approach to identify those changes that should be excluded.
the most objective way to determine whether a change was reviewed was the presence of inline comments section .
in gerrit.
using this concept for each project we identified the largest patchset in terms of nlc that contained at least one inline comment i.e.
it was reviewed .
we then excluded any patchsets that contained more nlcs under the assumption that they were likely not peer reviewed.
this process excluded a total of review requests .
of the total .
we used this smaller set of review requests i.e.
out of total for rq3 and rq4.
table lists the average nlc for all patchsets for all files for the patchsets containing a vulnerability and for the files containing a vulnerability.
for each project the average nlc for the vulnerable files was larger than the average nlc for all files.
analyzing the average nlc observations from the projects together i.e.
two from each project this difference is significant wilcoxon signed rank test z .
p .
.
additionally in projects the average nlc for the vulnerable patchsets wastable average nlc for patchsets and files all vulnerableratio all vulnerable projectpatchsets filespatchsets filespatchsetsfiles android .
.
chromium os .
.
gerrit .
.
itk vtk .
.
mediawiki .
.
omapzoom .
.
openafs .
.
ovirt .
.
qt .
.
typo3 .
.
higher than the average nlc for all patchsets.
again analyzing all projects together this difference is significant wilcoxon signed rank test z .
p .
.
to further understand these results we calculated the ranking of each vulnerable patchset and each vulnerable file in terms of nlcs relative to all patchsets and files.
approximately of the vulnerable patchsets were in the top of all patchsets and of the vulnerable patchsets were in the top .
the same ratios held for the vulnerable files.
this result supports earlier findings that vulnerability contributing commits were significantly larger than non vulnerability contributing commits and increased likelihood of defects in large changes .
therefore the probability of a file or patchset containing a vulnerability increases with the number of lines churned.
because larger changes are more difficult to review and more likely to have vulnerabilities developers should strive to make small incremental changes where possible.
.
rq4 type of the files patchsets containing vulnerabilities table shows the average number of vulnerabilities per 10k files and the average nlc for new files and modified files.
overall the number of vulnerabilities is significantly higher in the modified files than in the new files wilcoxon signed rank test z .
p .
this result indicates that modified files are more likely to contain vulnerabilities than new files.
based on the result from rq3 it is possible that this observation was caused by the nlc in the files rather than whether they were new or modified.
an analysis of nlc showed that the nlc was significantly higher in the new files than in the modified files.
this result is the exact opposite of what we would263table modified files vs. new files modified files new files projectvulnerabilities 10k filesnlcvulnerabilities 10k filesnlc android .
.
chromium os .
.
gerrit .
.
itk vtk .
.
mediawiki .
.
omapzoom .
.
openafs .
.
ovirt .
.
qt .
.
typo3 .
.
have expected if the new vs. modified distinction was not relevant i.e.
new files should have had more vulnerabilities because they had a higher nlc on average .
therefore we can conclude that whether a file is new or modified does affect the likelihood of vulnerabilities.
modified files are more likely to contain vulnerabilities than the new files.
this result may be due to our initial argument that when a developer changes someone else s code s he may introduce vulnerabilities due to lack of knowledge of the overall design and implications of the change.
along this line meneely et al.
found that new effective authors nea i.e.
authors making changes to a file for the first time made of the observed vulnerabilities .
while we did not calculate nea in our study this phenomenon may provide an explanation of our observed result.
this argument is also consistent with previous findings that code which changes frequently computed either by code churn or by number of revisions is more likely to contain vulnerabilities.
because modified files are more likely than new files to contain vulnerabilities patchsets that contain large modified files should be reviewed carefully for vulnerabilities.
.
rq5 effect of author experience on vccs the vccs were written by a total of authors.
to answer this research question we defined the experience of an author to be the number of posted code review requests crr in the current project at the time they posted the vcc.
the rationale is that the more code changes an author posts for a given project the more experienced s he has with that project.
this measure of experience is similar to the ones used in previous software engineering studies .
because of the varying number of contributors to each of the projects we also calculated percentile ranks of the authors based on experience at the time they posted the vcc.
the average experience of the authors contributing vccs is significantly higher than the average experience of all authors wilcoxon signed ranks test z .
p .
.
this result is bit surprising because intuition would suggest that inexperienced authors who are unaware of secured coding practices should be more likely to write vccs.
in fact of the vcc authors were in the top of authors based on experience with in the top .
in terms of number approximately of the vcc authors had made over code changes prior to authoring vccs.
zeller stated that because experienced authors usually take the responsibilities of working on the riskiest parts of the system they may be responsible for the critical bugs .
security critical modules are risky so this results support zeller s argument.
in addition the fact that the most experienced authors introduce the majority of the vccs supports mcgraw s claim that most developers even the most experienced lack knowledge about secure coding practices .
conversely rahman and devanbu tested zeller s hypothesis and they did not find any supporting evidence regarding association between author experience and severity of bugs .
because we calculate experience based on activity level the more code someone writes the higher his her experience metric it is possible that more experienced authors introduce more vccs simply because they commit more code.
to analyze this result in more detail we split the top of authors based on experience from the remaining .
each group contributed approximately of the vccs overall.
table shows the percentage of the crrs and the percentage of the vccs contributed by members of each group.
the percentage of code contributed by the top authors column of table is similar to that found in prior oss studies .
in all cases the percentage of vccs introduced by top of authors is significantly less than the percentage of code contributed by them t10 p .
we computed the ratio between vcc and crr for the two groups under vcc crr in table .
if the most experienced authors introduced more vccs simply because they contributed more code the ratios should be close to .
however we found those ratios less than for the top authors and more than for the remaining of authors.
the last column of table shows that less experienced authors in the remaining are .
to times more likely to contribute a vcc than more experienced authors in the top .
while the majority of the vccs are introduced by the most experienced authors less experienced authors are .
to times more likely to write vccs.
this result has two key implications even experienced developers make secure coding mistakes and code from inexperienced authors needs more careful security reviews.
.
rq6 effect of author s employment we were able to reliably determine the sponsoring organizations for six out of the ten projects.
those six projects account for of the vccs in this study.
using the author s email address we determined whether he or she was an employee of the sponsoring organization.
table shows the sponsoring organization email domains employee crr percentages and employee vcc percentages for the six sponsored projects.
overall the percentage of vccs authored by sponsored employees was significantly higher than the percentage of crrs authored by volunteers t6 p meaning that changes from sponsored employees were more likely to have vulnerabilities than changes from other contributors.
we again checked whether this result was due to the patchset size effect from rq3.
in this case there is no significant difference between the average nlc for the patchsets submitted by sponsored employees and table contributions by bottom of authors crr vcc vcc crr vcc likelihood of remaining times project top remain ing top remain ing top remain ing android .
.
.
chromium os83 .
.
.
gerrit .
.
.
itk vtk .
.
.
mediawiki .
.
.
omapzoom .
.
.
openafs .
.
.
ovirt .
.
.
qt .
.
.
typo3 .
.
.6264table code changes and vccs authored by employees project sponsoring companyemail domain crr vcc android google google.com android.com53.
.
chromium osgoogle google.com chromium.org89.
.
mediawiki wikimedia wikimedia.org .
.
omapzoom texas instrumentsti.com .
.
ovirt redhat inc. redhat.com .
.
qt digia nokia previously digia.com nokia.com50.
.
the average nlc for the patchsets submitted by non employees t6 p .
therefore we argue that sponsoredemployees are more likely to contribute vulnerable code than other contributors regardless of the patchset size.
this result was contrary to our a priori expectation.
we pose two hypotheses for this result.
first sponsored employees may be more likely to work on the security sensitive components of the projects therefore writing more vccs.
second code changes coming from non employees may be reviewed more thoroughly prior to submission to gerrit.
for example we found instances where employees of samsung sony mobile and t mobile submitted code changes to the android repository.
before submitting those changes the authors may have performed some testing and review of the code on their own.
conversely code changes from google employees the sponsoring company may not be reviewed prior to submission to gerrit.
we have not tested these hypotheses yet but we believe that further investigation is needed to better understand this result.
employees of organization sponsoring the oss project are more likely to write vccs.
code from sponsored employees needs to be reviewed more thoroughly.
.
discussion our results provides empirical evidence about the usefulness of peer code review to identify different types of vulnerabilities.
therefore in addition to the known benefits of code reviews i.e.
detecting bugs maintaining code integrity improving the relationships between the participants and spreading knowledge expertise and development techniques among the review participants peer code review also increases security by facilitating the identification and removal of vulnerable code changes.
this study produced two types of results.
first some results are consistent with findings from previous studies large files patchsets more likely to contain vccs and modified files are more likely to contain vccs .
these results are still interesting because they were produced from a different data source than the one used in the previous studies providing some additional confirmatory power.
second other results provide some new insights.
specifically the results about the characteristics of vcc authors are surprising and new see section .
and section .
.
even though the projects included in this study are popular and successful oss projects with a lot of talented developers the most experienced developers still authored vccs.
during our analysis of the code changes we observed different developers creating similar types of vulnerabilities.
many of those common mistakes were as simple as using unsafe methods using non sanitized inputs the tocttou race condition and overflows in integer arithmetic.
because developers can avoid those types of mistakes by learning the practices of secure coding we argue that developers lack adequate knowledge of secure coding practices.
moreover contrary to our initial belief we found that employees of the organization sponsoring the oss project were more likely to author vccs.
we believe these findings warrant further research.
based on the results and our observations during this study we make the following recommendations.
the websites of many oss projects contain guidelines for coding style and for general development .
unfortunately the projects included in this study did not provide secure coding guidelines for their developers.
even experienced developers making common insecure coding mistakes see section .
suggest their unawareness of secure coding guidelines.
to educate their developers we suggest that projects either reference existing online secure coding guides e.g.
cert secure coding standards or publish a few secure coding practices on the project webpage.
during our thorough audit of the review comments section .
we found that reviewers in three projects android chromium os and typo3 would refer a change to the security team when they were unsure of the security implications.
other projects may also have security teams that we did not observe in the review comments.
we suggest that projects create a security code review team whose members have the most knowledge about secure coding.
as mcgraw suggests these developers can be further trained in software security and can think like an attacker in their daily work .
this security review team could use our results along with other vulnerability prediction models to focus their efforts on the riskiest modules.
to enable the information documented during code reviews to be as useful as possible we suggest that reviewers provide detailed comments that include the rationale for their suggested change.
in addition to indicating the security problem the detailed feedback will also disseminate security knowledge.
two comments about the same problem that we observed duringthorough audit section .
show the contrast between high detail comment and low detail comment and illustrate the benefits of providing detailed comments.
comment sprintf is not a good function to ever use because you can end up with buffer overruns.
please use snprintf and also ensure that your output is always terminated 0n00 which i believe snprintf will do comment use snprintf while comment does suggest a fix to the problem comment1 provides useful information that will not only benefit the patch submitter but also educate others who read the comment.
the more detailed comment also provides the rationale behind the suggested change so the developer can better understand how to make the change and why it is necessary.
this additional detail also helps disseminate knowledge about a secure coding concept throughout the project.
we found that large changes are more likely to include vulnerabilities section .
.
because it is more difficult for reviewers to review large patchsets in a timely manner instead of submitting a large patchset developers should check in early check in often .
finally for researchers we observed different developers making the same mistakes.
there is a need for automatic code review tools to be built and integrated with existing265code review tools like gerrit that can detect those common mistakes.
the balachandran extension for reviewboard another code review tool performs automated code review based on static analysis.
while this tool is useful it does not target security issues specifically.
another alternative is the commercial tool klocwork .
however this tool will likely not be appealing to most oss projects due to the cost.
.
threats to v alidity this section is organized around the common validity threat types.
.
internal validity the primary threat to internal validity is project selection.
that is it is possible that set of projects analyzed did not provide a good representation of the types of security vulnerabilities that we were interested in studying.
while we only included projects that practice modern code review supported by gerrit we included most of the publicly accessible gerrit based projects that contain a large number of code review requests.
as the data in table shows these projects cover multiple languages and application domains.
furthermore it is possible that projects supported by other code review tools could have behaved differently.
we think this threat is minimal for three reasons all code review tools support the same basic purpose detecting defects and improving the code the focus of the study was on security vulnerabilities rather than on the specifics of the code review tools themselves and none of the code review tools focus specifically on security vulnerabilities so there is no clear reason that one would be favored over another for this study.
.
construct validity the first construct validity threat is that if the keyword set was incomplete the search could have missed some vccs.
section .
describes our process for building an empirically validated set of keywords.
to further validate the completeness of the keyword set we randomly chose code review requests that did not contain any of the keywords from each of the projects .
the sample size of was designed to provide a confidence interval .
a manual review of those code review requests found only one security vulnerability a memory leak .
this analysis increases our confidence in the validity of the keyword set.
the second construct validity threat is the appropriateness of the comments audit step of stage section .
.
this step excluded about of the review requests that contained at least one keyword.
the only way to ensure that a vcc was not excluded would have been to review the details of each request.
at minutes per request it was not feasible to give a detailed review to all requests that contained at least one keyword.
to reduce the chances of eliminating a vcc two researchers independently reviewed each comment and discarded it as a vcc only if both of them agreed.
we also performed a detailed review of randomly chosen code review requests from each project that were excluded and found only eight that contained vccs.
while we were not able to identify all of the vccs we did identify the majority of them.
it is possible that the missed vccs could have changed the overall results but we have no reason to believe any specific type of vcc was systematically eliminated in this phase.
to reduce the threat to experimenter bias two authors independently inspected and classified each of the review request that passed the comments audit step.
the authors discussed any disagreements and consulted with security expert hafiz for additional input to reach final agreement.
author hafiz then independently inspected of the identified vccs and found only one that was nota vcc and one that was misclassified.
this small number of errors should not significantly alter the results.
another threat is the validity of our experience measure i.e.
number of prior code changes or reviews .
because experience is multi factorial measuring it is complex.
for example how does one account for contributions to other projects?
while a different experience measure may have produced different results we believe that our experience measure is a reasonable representation of a developer s experience and familiarity with the current project.
finally for rq3 section .
and rq4 section .
we excluded a relatively small number of very large code changes under the assumption they were not reviewed.
it is possible that we excluded some code review requests that were actually reviewed.
we were conservative in setting the minimum nlc to exclude with the smallest being .
because most oss code changes are small and oss proponents encouraged small patches it is reasonable to assume that very large patchsets with no inline comments were not reviewed.
.
external validity the projects chosen for our study include oss that vary across domains languages age and governance.
for each project we mined a large number of code review requests for our analysis.
therefore we believe these results can be generalized to many other oss projects.
however because oss projects vary on characteristics like product participant type community structure and governance we cannot draw general conclusions about all oss projects from this single study.
to build reliable empirical knowledge we need family of experiments that include oss projects of all types.
to encourage replication we published our scripts2.
.
conclusion validity our dataset of vccs was built from the review requests mined from the diverse projects which is large enough to draw conclusion with confidence level .
we also tested all data for normality prior to conducting statistical analyses and used appropriate tests based upon the results of the normality test.
the threats to conclusion validity are minimal.
.
summary and future work this study created a dataset of vccs from code review requests mined from popular open source software oss projects using an empirically built and validated set of keywords.
the results show that peer code review is an effective method for identifying most of the common types of security vulnerabilities and that certain types of vccs are more difficult to fix than others.
while we obtained a number of important results one result is novel and particularly interesting.
the majority of the vccs are written by the most experienced authors supporting mcgraw s claim that most developers regardless of experience lack knowledge of secure coding practices .
even though the less experienced authors wrote fewer vccs overall their code changes were .
to times more likely to be vulnerable.
while this study focused on vulnerabilities identified through peer code review there is a need to study the characteristics of the vulnerable changes that were missed during peer code review.
therefore we consider that as our next step for this research work.
.