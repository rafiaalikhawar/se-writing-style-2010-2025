formalizing hardware software interface specifications juncao li1 fei xie2 thomas ball1 vladimir levin1 and con mcgarvey1 1microsoft corporation redmond wa usa.
email juncaoli tball vladlev conmc microsoft.com 2dept.
of computer science portland state university portland or usa.
email xie cs.pdx.edu abstract software drivers are usually developed after hardware devices become available.
this dependency can induce a long product cycle.
although co simulation and co verification techniques have been utilized to facilitate the driver development hardware software hw sw interface models as the test harnesses are often challenging to specify.
such interface models should have formal semantics be efficient for testing and cover all hw sw behaviors described by hw sw interface protocols.
we present an approach to formalizing hw sw interface specifications where we propose a semantic model relative atomicity to capture the concurrency model in hw sw interfaces demonstrate our approach via a realistic example elaborate on how we have utilized this approach in device driver development process and discuss criteria for evaluating our formal specifications.
we have detected fifteen issues in four english specifications.
furthermore our formal specifications are readily useful as the test harnesses for co verification which has discovered twelve real bugs in five industrial driver programs.
i. i ntroduction in modern computer systems such as pc devices and drivers are usually manufactured separately because their development processes need highly different expertise.
driver development commonly requires the device s presence in order to exercise the functionalities and test the implementation conformance to hardware software hw sw interface protocols.
to alleviate such dependency and shorten the product cycle co simulation and co verification techniques have been utilized to facilitate the driver development .
one key challenge is to develop the test harnesses i.e.
hw sw interface models.
such models need to be abstract enough to ensure the test efficiency however they also should be accurate to avoid false positives.
currently english is the de facto language for specifying hw sw interface protocols.
since many such protocols are public standards their english specifications need to be selfexplanatory.
however english does not have formal semantics therefore these specifications commonly contain ambiguities and inconsistencies.
figure illustrates an excerpt from the english document of the intel 8255x 100mbps ethernet controller specification .
this excerpt describes how the shared memory between hardware and software should be operated by hardware when a cu ru command unit receive unit command is issued from software.
there are two issues first the content of table is inconsistent with its title underlined the ru and cu difference .
second the cu hpq start command is neither defined nor mentioned in any other part of this document.
this is quite confusing fig.
.
excerpt from intel ethernet controller document.
when compared to the cu start command.
such kind of specification issues pervasively exist see section viii for details in various english documents for hw sw interfaces.
these issues can cause confusion produce bugs and lead to product failures.
therefore formal hw sw interface models are greatly desired to augment english specifications.
we characterize the problems in device driver development and present a practical approach to formalizing the hw sw interface specifications where b uchi automata ba and labeled pushdown systems lpdss serve as the foundational formal models for hardware and software respectively.
our approach has the following contributions relative atomicity.
we propose a semantic model relative atomicity to capture the various atomicity levels in hw sw interface designs.
relative atomicity can greatly simplify the concurrency model for hw sw interface specifications by excluding infeasible context switches.
specification of hw sw interface protocols.
we develop a formal specification approach for hw sw interface protocols and demonstrate it via a realistic example.
we design a specification language modelc that utilizes the c semantics with three restrictions to achieve finite state and two extensions to support relative atomicity and nondeterminism.
protocol coverage.
we strictly follow hw sw interface protocols to specify formal models.
therefore all hw sw behaviors allowed by protocols are captured by formal models.
this is very important to ensure the test coverage when formal models are used as test harnesses.
application and evaluation criteria.
we present how our approach can be applied to the device driver developmentprocess and discuss four criteria for evaluating our formal specifications.
one key idea is the model doc ratio that helps establish a quantitative relation between formal specifications and english specifications.
we have formalized four types of hw sw interfaces such as ethernet controller devices drivers and usb universal serial bus devices drivers.
we detected fifteen issues in the english specifications.
furthermore our formal specifications are readily useful as the test harness to verify five windows driver implementations with respect to their device behaviors.
all the drivers had been well tested.
however our co verification tool cover still discovered twelve real bugs.
these specification issues and driver bugs confirmed by windows architects are previously unknown to either the hardware or software engineers.
outline.
the rest of this paper is organized as follows.
section ii discusses the related work.
section iii introduces the background of this paper.
section iv summarizes a common development process for devices drivers in industrial settings.
section v presents the specification techniques we have designed for hw sw interfaces.
section vi demonstrates our formal specification approach via a realistic example.
section vii elaborates on the application of our approach in the device driver development process as well as the criteria that we have proposed for evaluating our formal specifications.
section viii presents the evaluation results.
section ix concludes and discusses the future work.
ii.
r elated work there has been lots of research on formalizing interface semantics such as i o automata by lynch et al.
interface automata by de alfaro et al.
and !
automata used in component based design of embedded systems by li et al.
.
kroening et al.
have used systemc to specify hw sw interface designs.
however none of the research is suitable for representing software implementations since the stack is not formally modeled.
we model the software stack so that our specification can closely resemble the implementation semantics of hw sw interface.
as a significant benefit our formal specifications can be used without any modification as the test harness for software resp.
hardware implementations.
therefore many previously unknown driver bugs have been discovered by our co verification tool.
another approach that models hw sw interface is exemplified by monniaux where both hardware and software are specified using c programs formally two pushdown systems pdss .
the hw sw concurrency is modeled by a straightforward composition of the two pdss.
representing hardware also as a pds is neither necessary nor efficient because hardware designs do not require a stack and verification of concurrent pds as the product of multiple pdss costs much more efforts than that of a single pds verification of concurrent pds is undecidable in general .
monniaux has applied this approach to verify usb host controller driver implementations however no real bug was found.kuznetsov et al.
have developed hw sw interface models to test windows drivers via symbolic execution.
in their approach most hardware design logic is abstracted away by non determinism therefore the interface models cannot serve as hw sw interface specifications.
furthermore false bugs may be reported due to the over abstraction of the hardware behaviors.
in practice finite state machines such as !
automata and ba are common representations for hardware.
pdsequivalent models are common representations for software.
for example cospan formalcheck uses !
automata as the formal representation of hardware.
the slam engine verifies c programs for safety properties where boolean program a pds equivalent model is used as the software representation.
furthermore concurrent pds is a suitable model for multi threaded software since each software thread contains a stack that needs to be represented.
although verification of concurrent pds is undecidable in general decidability can be achieved by bounding the number of context switches .
iii.
b ackground this section introduces the background of our research.
first we discuss the formal representations for hardware and software respectively.
second we introduce the windows driver framework that will be used as examples throughout the rest of this paper.
a. formal representations b uchi automaton ba as the hardware representation.
abab is a tuple q q f where is the input alphabet qis the finite set of states q q is the set of state transitions q0 qis the initial state and f q is the set of final states.
baccepts an infinite input string iff if and only if it has a run over the string that visits at least one of the final states infinitely often.
we use q q to denote a ba transition from state qtoq with the input symbol .
labeled pushdown system lpds as the software representation.
anlpds p is a tuple i g g0 !
where iis the input alphabet gis a finite set of global states is a finite stack alphabet g i g is a finite set of lpds rules and g0 !
g is the initial configuration.
lpds extends pds in such a way that an lpds can take input.
a configuration of pis a pair g !
representing a software state where g gis a global state andw is a stack content.
an lpds rule is written as g g w where i g g w and g is referred to as the head of this rule.
concurrent labeled pushdown system clpds .
a clpds cp as the product of multiple lpds is a tuple i g n g0 !
!
where n .
a clpds cpis different from an lpds pin the sense that cp has more than one stack.
for each stack there is a set of lpds rules i where i n. a clpds rule has the form of g i n cp g !
i n where g i g !i i. there is only one stack content 2updated in a clpds transition.
we refer to the lpds rule that is selected to be executed in a clpds rule as the active lpds rule.
clpds can represent multi threaded software.
synchronizing ba and lpds resp.
clpds .
we demonstrate how to combine the execution of ba band lpds p reps. clpds cp .
since a clpds rule actually depends on its active lpds rule we only need to study how to combine ba transitions and lpds rules.
we define the input alphabet of bas the power set of the set of atomic propositions that may hold on a configuration of p the input alphabet of pas the power set of the set of atomic propositions that may hold on a state of b and two labeling functions as follows lp2b g which associates the head of an lpds rule with the set of propositions that hold on it.
lb2p q i which associates a state of bwith the set of propositions that hold on it.
given a ba transition t q q and an lpds rule r g g !
they enable each other iff lb2p q and lp2b g .
furthermore let rbe the active lpds rule of a clpds rule r we also say that tandr enable each other.
b. windows driver framework drivers check device status or send commands to devices by reading or writing device registers and receive notification of state changes from devices through interrupts.
in windows devices and drivers are organized through stacks as illustrated in figure .
each layer of a driver stack services a function driver e.g.
mouse network card bus driver e.g.
pci usb intermediate software layers software hardware bus device e.g.
pci usb function device e.g.
mouse network card ddi device driver interface isr interrupt service routine interrupt interruptsignal signalintermediate hardware layers interrupt signalddi isrddi isr fig.
.
a generic view of windows device and driver stacks.
layer of the corresponding device stack.
different layers of a driver stack usually have different i o interfaces.
for example usb drivers use device driver interface ddi functions such aswdfusbretrieveconfigdescriptor to read usb device registers pci drivers read device registers using ddi functions such as read register uchar .
one common method to classify device resp.
driver layers is by deciding whether devices of a layer interconnect other devices.
if yes this type of devices are referred to as bus devices e.g.
pci peripheral component interconnect bus otherwise this type of devices are referred to as function devices e.g.
a network adapter card connected to the pci bus.
we usually refer to function devices resp.
function drivers directly as devices resp.
drivers .
for example a pci function device is referred to as a pci device.
iv.
c ommon development process of devices drivers as illustrated in figure we have observed a common development process for device driver frameworks in industrial settings where a device driver framework e.g.
usb refers to a type of hw sw interface as well as the devices and drivers that both utilize this interface.
the development process has three stages design hw sw interface protocoldraft specificationmanual proof readingissues detected published english specificationpassed develop devices or driversdevices or drivers failed in house testing passed released products conformance testing certification passeddesign stage development stage post release stageenglish ship the productfailed fig.
.
development process of device driver frameworks.
design stage.
usually a device driver framework is initially designed by a group of hardware and software companies together.
the hw sw interface protocol is described in a draft english specification which is shared between these participant companies for revision.
engineers from these companies proof read the english specification and try to identify potential problems in the hw sw interface design.
development stage.
the english specification is made public after it has been agreed upon by the participant companies.
the companies will start to develop their own hardware resp.
software products for this device driver framework based on the english specification.
during this stage other companies who have not participated in the design stage may also develop their own hardware resp.
software products that are compliant with this device driver framework.
how well a product complies with the hw sw interface protocol highly depends on the development engineers interpretations of the english specification.
in order to further ensure the hw sw interface compliance a product also needs to be tested according to the english specification.
because test 3engineers from different companies may have their own interpretations of the specification the test cases vary thus the test coverage of different products can be significantly different so is the products quality in terms of the hw sw interface compatibilities.
figure illustrates such an example which contains two excerpts respectively from a linux driver and a windows driver for the same hardware device the intel 8255x 100mbps ethernet controller.
the two c functions respectively illustrated in figure a and figure b have the same functionality which is to issue a software command to the device however the implementations are different.
before issuing a new command the linux driver always waits until the command register becomes free this rule is indicated by the english specification however the windows driver does not wait before issuing any new command unless the parameter waitforscb is set to be true which is due to some kind of performance optimization.
obviously the windows driver is more efficient because it tries to avoid unnecessary checks on hardware registers.
on the other hand it is also more challenging to maintain the driver s correctness because the driver developer must guarantee that when d100issuescbcommand is called with waitforscb being false the command register should always be free.
int e100 exec cmd nic nic u8 cmd dma addr t dma addr int err .
.
.
spin lock irqsave .
.
.
previous command is accepted when scb clears for i i e100 wait scb timeout i if last command has been completed if likely !ioread8 nic csr scb.cmd lo break cpu relax if unlikely i e100 wait scb fast udelay if last command timeout if unlikely i e100 wait scb timeout err eagain goto err unlock issue a new command if unlikely cmd !
cuc resume iowrite32 dma addr nic csr scb.gen ptr iowrite8 cmd nic csr scb.cmd lo errunlock spin unlock irqrestore .
.
.
return err a linux driver code excerpt.
ntstatus d100issuescbcommand pfdo data fdodata puchar scbcommandlow boolean waitforscb wait for the last command to complete?
if waitforscb true if !waitscb fdodata wait for the command register to become free return status device data error if last command timeout issue a new command write register uchar puchar fdodata csraddress scb command low byte scbcommandlow return status success b windows driver code excerpt.
fig.
.
excerpts from the linux and windows drivers for the intel 8255x 100mbps ethernet controller.post release stage.
after a product passes in house testing the company may choose to ship this product to market directly or send it to a third party organization for conformance testing.
conformance testing decides whether a hardware resp.
software product complies with the hw sw interface protocol.
test cases are developed by engineers from the third party organization based on the english specification.
the product passes the certification if all the test cases succeed.
during the development process it is desired that a formal hw sw interface model is present.
this can help validate the hw sw interface design convey the hw sw interface protocol precisely and provide a uniform test harness for devices drivers.
v. s pecification techniques for hw sw interfaces in this section we first discuss the types of concurrency related to hw sw interfaces.
then we present our approach that utilizes transaction level modeling tlm to abstract away hardware implementation details.
furthermore we propose a semantic model relative atomicity to simplify the complexities of hw sw interface specifications.
we also elaborate on how we utilize the concept of non determinism in our approach.
at last we present our specification language modelc.
a. concurrency in a hw sw system there are three types of concurrency related to hw sw interfaces hardware concurrency software concurrency and hw sw concurrency.
they should be represented at a proper level of details in hw sw interface specification.
hardware concurrency.
hardware is concurrent in nature and hardware concurrency exists in various levels of design abstractions.
from the view point of software there are two types of hardware concurrency concurrency between hardware modules and concurrent assignments to hardware registers.
for example an intel ethernet controller has modules such as command unit receiving unit interrupt management etc.
although these modules are fully concurrent they may not be driven by the same clock signal therefore they are asynchronous.
each module can be further divided into smaller modules or directly implemented .
when a module is directly implemented its operation consists of a sequence of steps that are driven by a clock signal.
the states of the module are maintained by hardware registers which are updated simultaneously upon clock cycles.
how the registers should be updated each clock cycle depends on the registers states before the clock cycle and the transition rules specified by the hardware design.
software concurrency.
drivers are usually designed multithreaded.
for example multiple threads can run concurrently to service different requests such as interrupts from hardware and i o requests from user applications.
from the view point of hardware there are two types of software concurrency multiple threads concurrently operate hardware e.g.
read write hardware interface registers and an isr 4is invoked to service a hardware interrupt so the currentexecuting thread will be preempted .
conceptually we can understand each thread as an lpds.
the threads together can be represented as a product of the lpdss i.e.
a clpds model.
since the verification of clpds requires a lot more efforts than that of lpds it is desired that software behaviors are modeled using a single lpds as much as possible.
as we shall demonstrate later the second type of software concurrency can be represented as a single lpds following the semantic model of relative atomicity.
hw sw concurrency.
a device and its driver run asynchronously and only transition synchronously when they interact through their interface.
the hw sw concurrency describes two situations most of the time software and hardware transition asynchronously so their states do not affect each other and when hardware and software interact with each other their synchronous transition will be decided by the states of both hardware and software.
b. transaction level modeling of hardware we use ba as the formal representation of hardware where hardware behaviors are represented as ba transitions.
we utilize the idea of tlm to specify such ba transitions.
tlm is a common approach to hardware specification where the design logic is specified by transaction functions while the implementation details such as clock signals are abstracted away.
hardware transaction.
since our goal is to specify hw sw interface protocols the design logic rather than the implementation details is relevant.
thus the clock driven semantic feature of hardware implementations is unnecessary to be preserved in our specification.
for example a data transfer command is usually processed in multiple clock cycles however it is only necessary to describe this command as one hardware state transition from the view point of software.
we define a hardware transaction to represent a hardware state transition i.e.
a ba transition in an arbitrarily long but finite sequence of clock cycles.
hardware transactions are atomic to software.
the concept of hardware transaction preserves hardware design logic that is visible to software but hides details that are only necessary for synthesizable register transfer level rtl designs .
hardware transaction function.
consider a hardware transaction as a ba transition we define a hardware transaction function as a c function that describes a set of ba transitions labeled by the same input symbol.
let the current states and next states of a transaction function be qrepresenting the hardware states when entering the function and q representing the hardware states when exiting the function respectively a transaction function is formally denoted as f q q where .
any terminating c function can be treated as a transaction function.
in order to differentiate the definition of hardware transaction functions from normal c functions we use the keyword atomic to indicate the type of transaction functions see figure for example .c.
relative atomicity concurrent threads usually have different execution priorities.
since higher priority threads preempt lower priority threads they should be considered atomic to the lower priority threads.
relative atomicity captures this semantic feature by stating that a higher priority thread is relatively atomic to a lower priority thread.
in hw sw interface designs relative atomicity captures two ideas hardware transactions are atomic from the view point of software and isrs for hardware interrupts are atomic to other lower priority software routines see figure for example .
any software concurrency that follows the relative atomicity model can be represented by a single lpds.
otherwise a clpds is necessary.
relative atomicity is a very important semantic concept to help reduce the complexities in hw sw interface specification co simulation and co verification.
d. using non determinism we utilize non determinism mainly in two ways updating the state variables which contributes to the dataflow of the specification deciding the conditions of branches or loops which contributes to the control flow of the specification.
for both ways the use of non determinism abstracts away unnecessary details.
for example one important utilization of non determinism in our approach is how we model the hardware concurrency.
non deterministic interleaving.
hardware is concurrent in nature.
for example a network card processes software command and receives data concurrently.
to specify this kind of hardware concurrency we design an approach called nondeterministic interleaving which has three steps identify the concurrent modules e.g.
command unit receive unit etc.
of the target hardware device specify the modules using separate c functions which we refer to as module functions and non deterministically invoke these module functions in a hardware transaction function.
when the transaction function is executed multiple times these module functions are executed in a non deterministic sequence.
from the view point of software the effect of hardware concurrency is modeled by the set of hardware states after non deterministic many executions of the hardware transaction function.
see section vi b for examples.
e. the modelc language we design a specification language modelc to support both the software specification and the hardware tlm specification.
modelc uses c semantics with two extensions to support nondeterminism and relative atomicity.
in modelc numbers are treated as bounded integers so hardware registers can be properly modeled unbounded recursion is not allowed and dynamic memory allocation is not allowed.
it is important to note that modelc is simply a c language with these extensions and restrictions.
other languages such as systemc can also be adapted to support the formal specification following our approach.
5vi.
s pecifying hw sw i nterface protocols we demonstrate how we formally specify the hw sw interface protocols through an example the pio digital i o device driver interface .
one important rule for our specification is to capture all possible hw sw behaviors that are allowed by interface protocols.
as illustrated in figure our formal specification has a hw sw interface a hardware model and a software model.
software modelhardware modelhw swinterfaceoutput2porta ... software routines ......output2portb ... isr hw transaction function atrun dio runisr from hardware to software write register uchar ... from software to hardware atwriteporta ... atwriteportb ... ...... wr a rd a wr b no evt ... intr no intr ... i fig.
.
formal specification framework.
the hardware states are specified using global variables the software states are specified using both the global variables and stack contents of modelc programs the hardware behaviors are specified using hardware transaction functions such as atrun dio andatwriteporta the software behaviors are specified using c functions such as output2porta and isr.
conceptually we can consider a hardware transaction function as a set of ba transitions labeled by the same input symbol from and an atomic software statement as a set of lpds rules labeled by the same input symbol from i. the input alphabet of ba bis the power set of the set of atomic propositions induced by software interface events and the input alphabet iof lpds pis the power set of the set of atomic propositions induced by hardware interface events where a hardware resp.
software interface event is triggered at a hardware resp.
software state.
the labeling function lb2p resp.
lp2b maps hardware resp.
software states to input symbols in i resp.
.
for b there are input symbols such as wr a rd a no evt where the propositional variables wr a andrd a represent the software interface events when software writes reads the hardware register of port a and the propositional variable no evt represents that there is no software interface event.
on the other direction for p there are input symbols such as intr no intr i where the propositional variable intr represents the hardware interface event i.e.
an interrupt and the propositional variable no intr represents that there is no hardware interface event i.e.
no interrupt.
a. specifying hw sw interface the hw sw interface as the abstraction of the hw sw stack layers between the target device and driver see figure propagates hardware resp.
software interface events to software resp.
hardware .
a hardware interface event happenswhen hardware updates the software interface states and vice versa.
for example when a device raises an interrupt the hw sw interface will call the corresponding isr.
on the other hand when a driver writes to a hardware interface register the hw sw interface will update the related hardware registers accordingly.
in general the hw sw interface describes the synchronous transitions of hardware and software when an interface event happens.
hardware transaction function labeled by the input symbol fwr a g atomic void atwriteporta uchar ucregdata f if port a is configured as an input port if g dioregs.cw.cwd4 f write to the output register instead of the port gdiostate.outputrega.ucvalue ucregdata gelse f otherwise configured as an output port update both the port and the output register gdioregs.a.ucvalue ucregdata gdiostate.outputrega.ucvalue ucregdata g g fig.
.
an implementation of a hardware transaction function responding to a software interface event.
figure illustrates an example of a hardware transaction function in response to a software register write operation.
this transaction function describes a set of hardware state transitions i.e.
ba transitions when software writes to the hardware register of port a. all these ba transitions are labeled by the same symbol wr a .
figure illustrates how function calls to a ddi write register function are related to hardware transaction functions such as atwriteporta .
conceptually the software interface event happens i.e.
wr a is evaluated as true when entry stack symbol of atwriteporta is reached.
void write register uchar puchar pregister uchar ucregdata f switch pregister f case reg porta atwriteporta ucregdata return case reg portb atwriteportb ucregdata return .
.
.
case reg config atwriteconfig ucregdata return case reg status atwritestatus ucregdata return default abort register address error.
return g g fig.
.
relating register write function calls to hardware transaction functions.
if hardware raises an interrupt isr should be executed to service this interrupt.
the hw sw interface simulates this process as illustrated in figure .
the global variable isrrunning represents software interface states and the global variable interruptpending represents hardware interface states.
the function runisr has three steps check prepare the precondition before invoking isr invoke 6void runisr f atomic f make sure only one isr is invoked if isrrunning true jj interruptpending false return isrrunning true g dioisr invoke isr atomic fisrrunning false interruptpending false g g fig.
.
interrupt monitoring function.
isr and set both the hardware and software to proper status after isr.
the atomic blocks are used to indicate that the first and third steps describe synchronous state transitions of both hardware and software.
conceptually when hardware formally ba raises an interrupt by setting the interrupt pending status interruptpending to be true the propositional variable intr will also become true.
as for software the contextswitch to isr is modeled as a function call following the idea of relative atomicity.
the corresponding lpds rules for such function calls are labeled by intr i therefore these lpds rules are enabled when the interrupt is raised.
b. specifying hardware model the hardware model describes the desired hardware behaviors when hardware works asynchronously with software to realize system functionalities.
for example when there is an input to port a the hardware model decides whether an interrupt should be raised based on both the current hardware state and the input value.
conceptually the behavior of the hardware model is represented as a set of ba transitions labeled by the symbol no evt i.e.
when there is no software interface event.
figure illustrates an example of a transaction function atrun dio that models the set of ba transitions for the pio device when this device executes asynchronously with the driver.
during each execution of the transaction function hardware transaction function labeled by the input symbol fno evt g atomic void atrun dio f switch choice f non deterministic choices case runports break port i o management case runinterrupt break interrupt management .
.
.
g g fig.
.
the transaction function for the hardware model of pio digital i o card.
one module function is non deterministically selected thus only one module is exercised with its related state variables updated.
the concurrency between the modules is simulated by the non deterministic interleaving between the module functions when the transaction function is executed multiple times.c.
specifying software model the software model describes desired operation sequences for software to control hardware.
it is straightforward to specify software behaviors using modelc because modelc is designed based on the c semantics.
in english documents specifications about software are usually categorized by functionalities.
for every functionality a piece of englishbased pseudo code is provided to describe the desired software operations.
we use a c function to replace each of the pseudocode pieces.
the left side of figure illustrates an example of void output2porta uchar ucregdata write to port a write register uchar reg porta ucregdata if port a is configured as input set it as output if g swstate.cw.cwd4 software must maintain the i o status of all ports gswstate.cw.cwd4 write register uchar reg config gswstate.cw.wholebyte while choice atrun dio runisr fig.
.
left side a c function about how to output to port a right side execution of the hardware transaction function and isr interleaved with software statements following the idea of relative atomicity.
such a c function for the pio driver model.
this function describes the desired software operations for outputting a byte to port a where each atomic software statement1is considered as a set of lpds rules labeled by no intr i. the right side of figure demonstrates interleaved executions of device with respect to driver following the idea of relative atomicity.
the hardware transaction function atrun dio see figure describes ba transitions labeled by no evt and the function runisr see figure invokes an isr according to the interrupt pending status.
in implementation all the c functions of a software model can be realized in several concurrent driver threads the number of threads and how the functions should be combined into the threads highly depend on implementation details .
when the executions of concurrent driver threads cannot be captured by relative atomicity we need to utilize clpds the product of lpds as the formal representation of the driver.
d. summary generalization.
we have demonstrated how we specify hw sw interface protocols via an example.
our approach is also applicable to other hw sw interfaces in devices drivers and microcode firmware because tlm is already widely used in hardware development in hw sw interface designs it is de facto to have different execution priorities for 1for readability we assume that such statements are atomic from the view point of hardware.
7concurrent components such as software threads and hardware transactions ba and lpds resp.
clpds are suitable formal representations for hardware and software respectively because they closely resemble the hardware and software semantics.
liveness constraints.
we abstract away some implementation details using non determinism which may cause specification imprecisions e.g.
introducing loops that are not in the original design.
these loops can be excluded by liveness constraints.
one way to introduce liveness constraints is via linear temporal logic ltl assertions.
in automata theoretic approach such ltl assertions can be represented as a b uchi automaton and then used to constrain the behavior of the target model during verification .
vii.
a pplications and evaluation criteria a. applications we employ formal models to describe the hw sw interface protocols in the device driver development process.
our approach improves the development process in the following four aspects refer to figure in the design stage automatic verification tools are applied to check the correctness of formal models that describe the hw sw interface protocols.
during the development stage formal models are referred to alongside the english specifications therefore it is easier for both development engineers and test engineers to have precise understanding about how hardware and software should interact following the hw sw interface protocols.
during in house testing formal models can be utilized by validation techniques such as co verification and co simulation .
there are three benefits reduce the duplicate efforts in developing test harnesses provides a uniform and systematic platform for validation and improve the test coverage since it is hard to manipulate real hardware devices to exhibit all possible interface behaviors e.g.
failures in testing.
in conformance testing formal models can serve as the golden models.
first equivalence checking testing can be used to check if a hardware resp.
software product complies with the hardware resp.
software formal model.
second a hardware resp.
software formal model can be used as the test harness of the software resp.
hardware products.
among these advantages the ability to provide a uniform and systematic platform for validation is very important.
in traditional testing because devices and drivers are manufactured separately some failures due to interface incompatibility only occur when a specific version of device is combined with a specific version of driver.
it is hard to pinpoint the responsibility for such failures because both the device and the driver are black boxes or at least one of them is .
using formal specifications as the uniform validation platform will greatly relieve this problem.b.
evaluation criteria we discuss four criteria to help evaluate our approach correctness assurance.
since formal models have accurate semantics automatic tools can be applied to validate their correctness.
for example the c compiler alone can detect a large amount of specification inconsistencies we have also used cover to verify the correctness of formal models see section viii .
manual effort.
the manual effort required in the specification of a formal model mainly depends on the complexity of the hw sw interface protocol and the experience of the specification engineer.
in general the complexity of a hw sw interface protocol can be approximately quantified by the size of its english document and the experience of specification engineers can be quantified by their experience in hardware and software development.
more quantification is discussed in section viii.
false positives.
formal models are specified using techniques such as non determinism that may lead to over abstraction.
this is one root cause of false positives in co simulation and co verification.
we implement our formal models based on hw sw interface protocols therefore any over abstraction with respect to the protocols should be considered as an error to be refined.
comparison with the english specification.
it is important to compare formal models with their english specifications.
different english specifications may describe hw sw interface protocols in different levels of details.
however enough details must be included when specifying a formal model in our approach.
for example an english specification may omit the input restrictions on a device s i o port however this detail must be specified explicitly in the formal model i.e.
if the device s input is not specified in the english specification nondeterministic values should be given as the input in the formal model.
we define a concept model document ratio to help analyze the relation between a formal model and its english specification2.
given that the formal model has lfmlines of modelc code and the english document has pdocpages of specification about the hw sw interface protocol we define the modeldocument ratio as definition model doc lfm pdoc when the model doc ratio is high we know that the hw sw interface protocol is loosely described by the english specification so the deviations of hw sw interface behaviors in various products are usually very high.
when the modeldoc ratio is low we know that the english specification is elaborate.
viii.
e valuation as discussed in section iv development processes of device driver frameworks have three stages design develop2we target standard specifications which commonly use structured english.
8ment and certification.
we have applied our approach to the first two stages.
first for the design stage we have applied our approach to the next generation of a pervasively used industrial standard.
our approach has led to the detection of five issues in the draft english hw sw interface document.
one of the issues is a spec inconsistency in an algorithm pseudo code that describes the hardware side interface protocol.
this finding has triggered a discussion between two companies who participated in the design of this hw sw interface protocol.
our formal model has lines of modelc code that covers about pages of the english document.
therefore the model doc ratio is .
which indicates that the draft english document is considerably elaborate compared with the other case studies see below .
using the formal model as the test harness our co verification tool cover has discovered two real bugs in a prototype windows driver for this device driver framework.
second for the development stage we have applied our approach to three long existing device driver frameworks the sealevel pio digital i o device driver framework a.k.a.
pio the intel 8255x 100mbps ethernet controller device driver framework a.k.a.
ethernet controller and the usb .
device driver framework .
our formalization process has led to the detection of ten issues in the english documents.
furthermore cover has been applied to co verify four fully functional windows device drivers developed for the device driver frameworks one pio driver from open systems resources osr one ethernet card driver and two usb device drivers all from microsoft.
cover has discovered ten real bugs.
all of these bugs which could cause serious system failures including data loss interrupt storm device hang etc.
are previously unknown to the driver developers.
we use two sets of tables to present the evaluation of our formalization process.
table i illustrates the overall statistics about the formalization for the pio device driver framework.
the statistics are gathered before and after the fortable i formalization of the pio device driver framework .
gathered before the formalization process hw sw interface doc.
document size pages the portion of the doc.
for the hw sw interface protocol pages the portion of the doc.
that cannot be modeled pages specification engineer s experience in driver development years specification engineer s experience in hardware design years specification engineer s experience in formal verification years specification engineer estimated manual effort person day gathered after the formalization process the actual manual effort person day specification issues found in the english document issues size of modelc code in formal model lines size of comments in formal model lines model doc ratio as lines of modelc code pages of the modeled doc.
.
malization respectively.
we require the specification engineer to give an estimation of the manual effort necessary for formalization so we can compare how well english documents with different complexities can be handled by an engineer.we also present the specification engineer s experiences in three areas that may affect the result of the formalization.
we have discovered two specification issues in the english document for pio one spec inconsistency and one specincompleteness3.
take the spec incompleteness issue as an example the document does not mention the default value of the interrupt pending register which is usually disabled by default in many english documents for hw sw interface specifications therefore we assign non deterministic initialization values to this register in our formal specification.
coincidentally the windows driver of this device does not clear the interrupt pending register during the driver initialization.
this uninitialized register affects the driver s interrupt handling process which can lead to data loss.
table ii illustrates the detailed statistics about the formal model for the pio hw sw interface protocol.
the formal model as implemented in files has lines of comments and lines of modelc code.
this corresponds to pages of the english document.
in the form of comments we have added