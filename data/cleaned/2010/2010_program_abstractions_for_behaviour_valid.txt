program abstractions forbehaviourvalidation guido decaso v ctor braberman departamento decomputaci n fceyn uba buenos aires argentina gdecaso vbraber diegog dc.uba.ardiegogarbervetsky sebasti nuchitel department of computing imperial college london uk s.uchitel doc.ic.ac.uk abstract code artefacts that have non trivial requirements with respect to the ordering in which their methods or procedures ought to be called are common and appear for instance in the form of api implementations and objects.
this work addresses the problem of validating if api implementations provide their intended behaviour when descriptions of this behaviour are informal partial or non existent.
the proposed approach addresses this problem by generating abstract behaviour models which resemble typestates.
these models are statically computed and encode all admissible sequences of method calls.
the level of abstraction at which such models are constructed has shown to be useful for validating code artefacts and identifying findings which led to the discovery of bugs adjustment of the requirements expected by the engineer to the requirements implicit in the code and the improvement of available documentation.
categories andsubjectdescriptors d. .
software program verification validation d. .
testing and debugging debugging aids generalterms algorithms design verification keywords behaviour model synthesis automated abstraction source code validation .
introduction code artefacts that have non trivial requirements with respect to the order in which their methods or procedures ought to be called are commonplace.
such is the case for many api implementations and objects.
in practice descriptions of intended behaviour are incomplete and inforpermission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bearthisnoticeandthefullcitationonthefirstpage.
tocop yotherwise to republish topostonserversortoredistributetolists re quirespriorspecific permission and orafee.
icse may21 honolulu hawaii usa copyright2011acm ... .
.mal if documented at all hindering verification and validation of the code artefacts themselves and the client code thatusestheartefacts.
hence researchershavenotreliedon these descriptions and developed techniques to support the mining or synthesis of typestates from api implementations which are then used to verify if client code conforms to the implemented protocol .
such approaches however addressonlypartoftheproblem theyassumethecodefrom which the typestate is extracted is correct that it conforms to the ordering of methods or procedures intended at the time of design or developing the requirements for the api.
this work addresses the complementary problem of validating if api implementations provide their intended behaviour when descriptions of this behaviour are informal partial or non existent.
validation of api implementation behaviour can result in the identification of bugs in the code which induce undesired requirements adjustment of the requirements expected by the engineer to the requirements implicit in the code and the improvement of available documentation for that code.
in this work we argue that an automatically constructed abstraction of an api implementation can be useful for validation against poorly documented requirements or the engineer s mental model and can lead to the identification of problems in the code in the requirements or the engineer s understanding of both.
given that validation is an activity that requires human intervention the level at which an apiimplementationisabstractediskeyandhasdifferentrequirements than those abstractions used for verification .
in this paper we present a novel technique for automatically constructing abstractions in the form of behaviour models from code artefacts equipped with requires clauses for methods.
these models similarly to typestates encode all admissible sequences of method calls.
the level of abstraction at which such models are constructed aims at preserving enabledness of sets of operations resulting in a finite model with intuitive and formal traceability links to the code.
this level of abstraction and the traceability links have shown to be useful for validation code artefacts and identifying findings that relate to bugs in code and problems in expected or documented requirements.
literature on typestate synthesis refers to safety and permissiveness as a way to characterize abstraction properties a typestateis safe if no call sequenceviolates the library s internal invariants it is permissive if it contains every such sequence.
previous approaches have aimed e.g.
at modular program analysis using typestates which are both safe and permissive for cases in which the library s internalstate is finite but may not be permissive for the infinite case.
our approach deals with infinite internal state space and is permissive at the cost of safety.
we believe and experience so far indicates that this supports well identification of implementation and requirements issues.
the rest of this paper is organised as follows.
we begin with an overview of the approach using a simple example section and then provide a formal framework for our approach section .
subsequently we present an algorithm for constructingenabledness abstractions section and report on its use on a number of relevant source code subjects.
section .
finally we discuss related work section ideas for future work and conclusions section .
.
overview in this section we provide a black box overview of the approach using a small example.
1typedef struct node intdata struct node next node 3typedef struct list intsize node first list list l 8intinv return l null l size 9intlist l list malloc sizeof list 11if l null return l size l first null 13return 16intaddreq return l!
null 17intadd intdata node tmp l first 19while tmp next !
l first tmp tmp next tmp next node malloc sizeof node 22if tmp next null l null return tmp next data data tmp next next l first l size return 30intremove req return l!
null l size 31voidremove node newfirst l first next free l first l first new first 37intdestroy req return l!
null 38voiddestroy ... figure a singly linked list c implementation consider the c source code of figure which implements a singly linked integer list.
it features a nodestructure which contains a datafield and a pointer to the nextnode in the list or to the first one if standing on the last node .
the list itself is stored in another structure which holds the total number of elements and a pointer to the first node.
the implementation provides an initialization operation which creates the liststructure an addoperation which stores a new integer at the end of the list a removeoperation which eliminates the first element if any and a destroyoperation which frees the memory used by the list and all its nodes.
note that besides its basic functionality this list implementation is augmented with an invariant inv figure singly linked list enabledness abstraction and a requires clause for each of its operations add req remove req anddestroy req .
how can we validate if this implementation provides the intended functionality when there is no formal and validated model of the intended functionality to compare against?
we propose to automatically extract a behaviour model such as the one shown in figure .
in this model we abstracted the concrete state space of the singly linked based on the set of operations the concrete states enable that is the set of operations for which their requires clauses hold1.
the abstract state s5groups concrete states that allow execution of addanddestroy.
abstract state s7groups concrete states that allow add remove anddestroy.
ands0 groups all concrete states that do not allow any operation.
note that initial states are marked with a double circle .
the behaviour model in figure allows an engineer to validate the implementation of the singly linked list against his or her mental model of the intended behaviour of the source code.
it is simple to see that this model describes states which relate to whether a singly linked list is empty s5 non empty s7 or inactive s0 .
consider now the removeoperation.
it is only featured in a transition that loops over state s7.
this is suspicious since it is indicating that whenever we erase an element from a non empty list we always end up having a non empty list.
there would seem to be a removetransition missing from s7tos5 which would model the case when the last element is removed from the list.
the implementation of removedoes not ever empty the list.
surely this is an unintended fault.
upon inspection of operation removein figure we can observe that the listsizefield is not being decremented.
fixing this fault is straightforward and yields an enabledness behaviour abstraction that is the same as figure but with the addition of the missing removetransition from s7tos5.
the abstraction in figure could also prompt the discovery of interesting aspects of the implementation under analysis.
for instance both initializing the list and adding an element can lead to the terminal state s0.
inspection of the source code shows that memory availability has an impact on the list s behaviour.
it is interesting to note that suchobservations elicitedeasilyfromtheabstraction would require explicit modelling and or manipulation of the memory management aspects of the program s environment to be detected in verification based approaches.
in summary the example above illustrates how the depiction of an abstract model that integrates the behaviour of multiple procedures that use a common data structure for providing more complex services can support validation and aid identification of potential problems the implementation mayhave.
thelevelofabstractionnotonlyyieldsacompact finite abstract model from an infinite concrete state space but also allows tracing back concerns to the source code for 1our tool automatically assigned the displayed state names.identifying and fixing problems in the latter.
in the next two sections we show how enablednesspreserving abstractions like the one in figure can be built automatically from software implementations such as the one depicted in figure .
.
formalmodel in the following we will use pred d to refer to the set of predicates over an arbitrary set d formally defined as pred d def f f d true false .
additionally cwill denote the set of configurations to which programs evolve.
as we mentioned before the object under analysis for our technique is the source code of a program.
we will first define an action system as the semantic interpretation of a program s source code.
this action system