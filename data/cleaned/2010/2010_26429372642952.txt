abstraction aware verifying compiler for yet another mdd naoyasu ubayashi di ai peiyuan li y u ning li shintaro hosoai y asutaka kamei kyushu university fukuoka japan ubayashi acm.org aidi posl.ait lipeiyuan posl.ait liyuning posl.ait hosoai qito kamei ait .kyushu u.ac.jp abstract this paper rethinks both modularity and compilation in the light of abstraction between design and implementation.we propose a new compilation approach called abstractionaware verifying compiler in which abstraction is the target of compilation.
both a design model and its code are in putted as the first class software modules to the compiler.
categories and subject descriptors d. .
software program verification keywords architecture interface abstraction .
introduction abstraction has been an important issue in software engineering .
this paper rethinks both modularity and com pilation in the light of abstraction between design and im plementation.
although it is preferable to firmly separatedesign from its implementation this separation is not easybecause an abstraction level how much should be a designmodel more abstract than its code?
tends to change during the progress of software development.
in general an impor tant decision on software architecture is made at the designphase and a decision on the detailed program structure con cerning api usages variables and methods is made at thecoding phase.
however this distinction is relative and vague in many cases.
for example the importance of some classes and methods might be recognized at the coding phase even ifthey should be extracted at the design phase because devel opers cannot always grasp all of the design concerns.
it is notavoidable to fluidly go back and forth between design andimplementation.
it is error prone to manually check whether or not a design model is a faithful abstraction structure of its code whenever a design model or code is modified.
to deal with this problem we propose a new compilation approach called abstraction aware verifying compiler permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provide d that copies are not made or distributed for profit or commercial advantage and tha t copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permissionand or a fee.
request permissions from permissions acm.org.
ase september v asteras sweden.
copyright acm ... .
.
which abstraction is the target of compilation.
this compiler receives a design model and its code as an input verifies whether or not the design model is an abstraction of the code and generates the object code.
our compiler isbased on a modularity vision whose concept is not only program code but also a design model is a module .
we consider that the abstraction level of a design model may flu idly change as a result of reconsidering the balance betweendesign and its implementation.
however this type of separation of concerns is not well supported by current mdd model driven development that takes a transformationapproach such as qvt queries views transformations or atl atlas transformation language to generate code from a design model.
on the other hand our approach yetanother mdd is a type based module integration to bridgedesign and code preserving an abstraction level.
this paper is structured as follows.
our modularity vision is introduced in section .
the implementation of our compiler is shown in section .
an abstraction refinement process using this compiler is shown in section .
the overviewofiarch an ide integrated development environment for supporting our idea is illustrated in section .
concludingremarks are provided in section .
.
new modularity vision for mdd in this section we propose a new modularity vision in which a uml design model such as a class diagram and asequence diagram is regarded as a design module.
.
type based traceability in this paper we extend archface an architectural interface mechanism previously proposed by us to represent abstraction explicitly.
the new archface can deal with abstraction by introducing the notion of architectural pointsshared between design and code.
these points termed archpoints have to be modeled as design points in a uml model and be implemented as program points in its code.
class declarations method definitions and events such as message send are called design points.
archface can play a role as a design interface for a design model and as a programinterface for a program.
the traceability between design and code can be verified by an archface type system.
by regarding a design model as a module the type system can be applied to the model.
design and code are synchronizedwhen both a design model and its code conform to the same archface .
abstraction is taken into account in this synchronization because an abstraction level is determined by selecting shared architectural points declared in archface .
table design points program points archpoints diagram design point program point archpoint pointcut uml2 metamodel java class diagram class class a class class uml operation method a method method property field a field field sequence diagram message method call a mcall call uml messageend sendevent message method exec a mexec execution messageend receiveevent interaction control flow cflow constraint target predicate structure inheritance class inherit association class assoc membership class method field memberof behavior sequence message send receive sequence call execution iteration sequence iteration branch sequence alt aspectj pointcut used with call orexecution pointcut table shows the types of design points program points and archpoints.
these points can be mapped each other.
the idea of archpoints and their selection originates in aop aspect oriented programming notions such as join pointsand pointcuts.
we focus on archpoints embedded in class diagrams and sequence diagrams because structural and behavioral aspects of software architecture can be basicallyrepresented using these diagrams.
the followings are the formal definitions of a design model program code and archface .
definition design a design model is a tuple dm d d c where d is a set of partial ordered design points and dc is a set of constraints among them.
the type of a design point is arelated uml metamodel element.
a constraint is represented using predicates shown in table .
definition code a program is a tuple pg p p c w h e r e p is a set of partial ordered program points and pc is a set ofconstraints among them.
the type of a program point and a constraint among these points are shown in table .
definition archface archface is an interface for enforcing constraints on a design model and its program.
this interface isa tuple af a a c where a is a set of partial ordered archpoints and ac is a set of constraints among them.
thetype of an archpoint and a constraint among these points areshown in table .
.
archface design and code descriptions we illustrate design and program modules using the observer pattern as an example.
figure shows the relation between these modules and archface .
.
.
archface archface which supports component and connector architecture consists of two kinds of interface component and connector .
the former exposes archpoints and the latter defines how to coordinate archpoints.
pointcut advice in aspectj is used as a mechanism for exposing archpoints pointcut and coordinating them advice .
list is a component interface for a subject.
archface exposes archpoints from ports.
four port declarations line correspond to the traditional interface in which eachmethod declaration can be regarded as exposure of method execution.t h e notifyobservers port line exposes an update call archpoint that has to be called under the control flow of setstate.
the operator is used to symbolize logical and .
this archpoint is combined with an update execution archpoint specified in a component interface for observers list line .
interface component csubject port addobserver execution void addobserver observer o port removeobserver execution void removeobserver observer o port getstate execution string getstate port setstate execution void setstate string figure type based mdd interface component csubjectbehavior extends csubject port notifyobservers cflow setstate call update interface component cobserver port update execution void update interface component cobserverbehavior extends cobserver port updatestate cflow update call string getstate list is a connector interface specifying the coordination among archpoints exposed from component s ports.
the execution of archpoints is coordinated by connects multiple indicates the connection is repeatable .
in notifychange a n update call archpoint in csubject is bound to an update execution archpoint in cobserver.
interface connector cobserverpattern csubject cobserver interface connector cobserverpatternbehavior extends cobserverpattern connects multiple notifychange csubject.notifyobservers cobserver.update connects obtainnewstate cobserver.updatestate csubject.getstate .
.
design and program modules both design and program modules are same as traditional uml diagrams and code.
however there is a crucial difference.
an interface archface resides between them and it makes them software modules.
observerpatterncd a class diagram and observerpatternsd a sequence diagram shown in figure are design modules faithful to the archfacedeclared in list and .
a program module is also 558same as a traditional module such as java class.
list and are java classes implementing the archface .
public class subject private vector observers new vector private string state public void addobserver observer o observers.add o public void removeobserver observer o observers.remove o public string getstate return state public void setstate string s state s for int i i observers.size i observer observers.get i .update public class observer private subject new subject private string state public void update state subject.getstate system.out.println update received from subject state changed to state .
module integration to integrate design and program modules each design module models its archface and each program module implements the same archface .
the conformance to archface can be checked by a type system that takes into account not only program but also design interfaces.
type checkingin an abstraction aware compiler is performed by verifying whether a design point program point corresponding to an archpoint exists in a design module program module while satisfying constraints among design points program points e.g.
the order of message sequences specified by cflow .
the followings are the formal definitions of archface check traceability between and abstraction.
definition archface check of design model a design model conforms to archface iff a a a set of archpoints d d a set of design points s.t.
mapt odesign a d a function a d a n d mapt odesign a d ac ac a set of constraints among archpoints dc dc a set of constraints among design points s.t.
mapt odesign prime ac dc a function ac dc a n d mapt odesign prime ac dc a n d3 the value of the above dcistrue.
definition archface check of program code a program conforms to archface iff a a a set of archpoints p p a set of program points s.t.
mapt ocode a p a function a p a n d mapt ocode a p ac ac a set of constraints among archpoints pc pc a set of constraints among program points s.t.
mapt ocode prime ac pc a function ac pc a n d mapt odesign prime ac pc and the value of the above pcistrue.
definition traceability a design model is traceable to its program iff both of them conform to the same archface .
definition abstraction a design model dmis an abstraction of a program pgiff dmis traceable to pgand d p .
d and p are cardinal numbers of the set d and the set p respectively.
.
compiler construction in this section we show how to implement an abstractionaware verifying compiler.
.
overview our compiler includes the functions of traditional model compiler and ordinary compiler i.e.
program compiler .the former translates a design model into program code.the latter translates the program code into executable code.the abstraction aware verifying compiler can generate notonly skeleton code but also override archpoint related program points to the existing code preserving an abstractionlevel specified by archface .
we do not have to separate generated code from non generated code as in .x way architectureimplementation mapping .
for example in the caseofsetstate in list skeleton code such as for observer.update is generated.
if a developer refines the code as list line using vector class the compiler checks the type of observers and preserves the update call.
annotation comments for code modification are not neededin our approach although these comments are used to sup port round trip engineering in most mdd tools.
type checking plays a key role in the abstraction aware verifying compiler because a bstraction can be preserved if a design module models archface type checking between a design model and archface is passed and a program module implements the same archface type checking between a program module and archface is passed .
in this section we focus on the type checking algorithm.
our type checking algorithm consists of the following phases translate design modules program modules and archface into logical formulas and check whether or not a formulatranslated from a design module satisfies a formula trans lated from archface type checking for a design module and check whether or not a formula translated from a programmodule satisfies archface type checking for a program module .
compilation is executed correctly if both type checks do not generate errors.
we use an smt satisfiability modulo theories solver a tool for deciding the satisfiability of logical formulas.
an smt solver generalizes sat satisfia bility by adding equality reasoning arithmetic and otherfirst order theories.
the expressiveness of smt is higher than that of sat.
yices is used as an smt solver in our compiler implementation because a sequence of archpoints can be easily encoded using an array.
yices provides a scheme like input language.
.
phase translation into logical formula we show how to translate design program modules and archface into logical formulas.
.
.
translation of design module from definition we can define a design module as a tuple of d d1 ... d n and dc dcond d1 ... d n ... dcond m d1 ... d n w h e r e diis a partial ordered design point and dcond jis a logical expression for specifying a constraint among design points.
design is regarded correct ifthe logical formula below is satisfied.
design dcond ... dcond m partially ordered design points can be considered as a setof design points sequences not a single sequence due toiteration or inheritance.
a sequence diagram can be rep resented by a sequence of message send and receive design points.
an inheritance structure of a class diagramcan be also represented by a partial order of class design points.
a part of observer pattern notification sequence can be translated into list figure .
the notation classname messagename kindofdesignpoint is used to represent each design point.
the sequence is a constraint satisfied when the order of design point occurrence is correct1.
1the constraint sequence d1 ...d n is the syntactical sugar oforder d1 d2 ... order dn dn .
the constraint order is a predicate for specifying the order.
other constraints such as iteration can be also defined using order.
design sequence csubject setstate message receive csubject update message send cobserver update message receive cobserver getstate message send csubject getstate message receive program sequence csubject setstate execution iteration csubject size call vector size execution csubject get call vector get execution csubject update call cobserver update execution cobserver getstate call csubject getstate execution cobserver println call system out println execution csubject sequence csubject addobserver a mexec sequence csubject removeobserver a mexec sequence csubject getstate a mexec sequence csubject setstate a mexec cobserver sequence cobserver update a mexec csubject sequence csubject setstate a mexec csubject update a mcall cobserver sequence cobserver update a mexec cobserver getstate a mcall notifychange iteration csubject update a mcall cobserver update a mexec obtainnewstate sequence cobserver getstate a mcall csubject getstate a mexec archface sequence csubject setstate a mexec iteration csubject update a mcall cobserver update a mexec cobserver getstate a mcall csubject getstate a mexec figure translation into logical formula define type count subrange count define i0 count ... define i4 count assert and maptocode archpoint i0 i1 i1 i2 i2 i3 i3 i4 order preservation plist i0 csubject setstate execution plist i1 csubject update call plist i2 cobserver update execution plist i3 cobserver getstate call plist i4 csubject getstate execution program plist csubject setstate execution ... plist system out println execution check check the assertion assert and i j alist i csubject setstate a mexec alist j cobserver getstate a mcall figure type checking with yices .
.
translation of program module from definition we can define a program module as a tuple of p p1 ... p n prime and pc pcond p1 ... p n prime ... pcond m prime p1 ... p n prime w h e r e piis a partial ordered program point and pcond jis a logical expression for specifying a constraint among program points.
an implementation is consistent if the formula below is satisfied.
pr o g r a m pcond ... pcond m prime the behavioral aspect of list can be translated into list figure .
the notation classname kindofprogrampoint is used to represent each program point.
.
.
translation of archface from definition archface is an interface for enforcing constraints on a design model and its program.
the processof deriving logical expressions for representing constraintsfrom archface descriptions consists of four steps translation of execution pointcut translation of cflow t r a n s lation of a connector and synthesis of translated formulas.in step ports with execution pointcut are translated into list figure in which archpoints exposed from ports arepicked up.
the first target of translation is a port defined byexecution because an a mexec archpoint can be a trigger of architectural behavior.
this archpoint is regarded as asequence consisting of a single archpoint.
in step a portincluding cflow is translated into list .
control flow can be translated into a sequence of archpoints.
in step list10 is obtained from the cobserverpattern connector.
if multiple is specified in a connect statement an iteration predicate is generated.
otherwise a connect statement is translated into a sequence predicate.
in step list is obtained by synthesizing list and .
.
phase type checking from definition type checking for a design module is performed by verifying the satisfiability of design mapt odesign archface .
the maptodesign maps an archpoint to its corresponding design point.
for example cobserver update a mexec is mapped to cobserver update message receive.
from definition type checking for aprogram module is performed by verifying whether or notpr o g r a m mapt ocode archface is satisfied.
the maptocode maps an archpoint to its corresponding program point.
both type checking algorithms are basically same.
asan example we show the latter type check for a programmodule .
in case of the observer pattern the logical formula above is encoded to list figure .
the symbol plist whose definition is omitted due to the space limitation is an array including all program points.
the occurrence order of mapt ocode archpoint s p e c i fi e di n sequence and iterationis encoded in line .
the iteration predicate can be encoded to yices by expanding the iteration limited times one time in list .
in this case only the boundedchecking is available.
as shown here predicates representing architectural constraints can be translated into the yices input language.
the preservation of order and the preservation of an abstraction level are represented in line andline respectively because i0 ... i4are not continuous numbers.
the assertion in list checks whether there is abisimulation relation between an archpoint sequence and a program point sequence.
this assertion is satisfied.
from definition the traceability between design and code is bidirectionally maintained by defining a mapping design points and program points via archface .w e c a n preserve an abstraction level by ignoring program pointsthat are not linked to archpoints.
the execution order of 560archpoints representing observer pattern is preserved even if program points which do not change the sequence of archpoints e.g.
size are added to the code.
there is a bisimulation relation between design and code in terms ofarchpoints.
using bisimulation to relate a specification andan implementation has been around for about years pi oneered by milner r. and c.a.r.hoare.
the novel point of our approach is the realization of bisimulation in terms of a type system based on archface .
our compiler supports not only type checking but also bounded model checking.
the temporal formula csubject setstate a mexec cobserver getstate a mcall can be checked.
in this specification in the future is an operator of ltl linear temporal logic .
this ltl formulais automatically generated from archface and is encoded to list figure in which alist is an array including archpoints.
the correctness of a program can be guaranteed ifits design model and the traceability to the code are verified.
.
abstraction refinement process an abstraction aware verifying compiler supports the preservation of consistency between design and code in terms ofan abstraction level specified by archface .
however it is an open question to explore an appropriate abstraction struc ture and decide which abstraction level is reasonable.
thisis an essential problem on software abstraction.
althoughwe cannot provide the best solution at this time we try torelax this problem by giving an iterative abstraction refine ment process called agar archface guided abstraction refinement metric for measuring an abstraction level andrefactoring patterns for abstraction refinement.
.
agar figure illustrates agar in which an abstraction level is determined by archpoint selection.
the level becomes high if the number of selected archpoints is few.
on the other hand an abstraction level becomes low if the number ofselected archpoints is large.
by exploring an appropriate setof archpoints a developer can find an appropriate level theresult of convergence of iterative and agile fluid moving in which an abstraction level is fluidly changed.
agar originates in cegar counter example guided abstraction refinement an iterative abstraction refinementprocess in model checking.
agar is a process of iteratively exploring appropriate abstraction between design and im plementation.
this process consists of three steps createan initial archface design and code check the design traceability and measure an abstraction ratio and refineabstraction by modifying archface design and code.
we have to modify design or code when traceability is violated.
assume that archface description in list line is below.
this specifies that update is not directly called from setstate butnotify has to handle an update process.
port notifyobservers cflow execution void setstate string call void notify port update cflow execution void notify call update in this case type checking between archface and code detects an error.
if list is preferable a developer has to change the code list to conform to the archface .o t h erwise the violation is resolved if the abstraction level is changed to high.
that is the violation in observer pattern figure agar overview disappears if list is changed to list line .
abstraction mismatch traceability violation between designand code can be a trigger of refining abstraction whicharchpoint should be included in archface or excluded from archface to resolve this abstraction mismatch?
agar is an abstraction refinement process using abstraction awaretraceability check and an abstraction ratio.
in the case of an error its counter example can be provided and the support tool gives a developer repair choices.
.
metric for abstraction level we propose abstraction ratio am e t r i cf o rm e a s u r i n ga n abstraction level based on definition .
the value of thismetric is archpoint programpoint.t h e a b s t r a c tion ratio of observer pattern notification sequence can be calculated .
from the number of archpointsand the number of program points see list and .
thevalue .
indicates that archface in list and is approximately more abstract than the implementationin list and .
an abstraction ratio helps a developer to determine which archpoint should be available in a design.
it is preferable to help a developer to decide an appropriate abstraction ratio.
we do not recommend chasing metrics because an adequate abstraction ratio changes corresponding to design sit uations.
the determination of abstractions is a core task required to a developer.
however if an abstraction level converges to a specific value in the process of agar the value can be an appropriate abstraction level .f o r m o u r e x p e r i ence the structural aspect of the design tends to convergefast and the behavioral aspect tends to converge slowly.
.
tool support the iarch consists of the followings model program editor archface generator abstraction aware verifying compiler and abstraction metrics calculation.
figure is a snapshot of iarch implemented as an eclipse plug in.
the left side is a sequence diagram of the observer pattern and the right side is an archface definition.
in iarch s y n tactical sugar is introduced into the original archface .t h e structural aspect can be described as java like interface andthe behavioral aspect can be specified using process algebra.
fixing inter model inconsistency is an important problem 561 hd w z d figure iarch ide .
our approach can verify inconsistency not only between a model and code but also between models by type checking.
.
discussion and conclusions our research motivation is close to .
cassou d. et al.
explored the design space between abstract and con crete component interaction specifications.
they introduced interaction contract that expresses allowed interactions between components describing both data and control flow constraints.
they provided an adl for sense compute controlapplications and describe associated compilation and veri fication strategies.
our approach provides a general model for design traceability because the model can be applied to not only sense compute control applications but alsoother kinds of system.
aldrich j. et al.
proposed archjava an extension of java.
archjava unifies architecture and implementation ensuring that the implementation con forms to architectural constraints.
although the approach ofarchjava is similar to our vision archjava does not contain such an idea that a uml model can be regarded as a module.
it is nice to introduce a new language.
however it is important to improve mdd using ordinary uml and programming languages because they are familiar to many developers in industry.
y. zheng and r. n. taylor proposed .x way architecture implementation mapping for deep separation of generated and non generated code.
we cancorrespond the former and the latter to design concerns and implementation concerns respectively.
moreover this sep aration of concerns can be regarded abstraction specifica tion between design and implementation.
however it is not easy to change the separation of concerns or abstraction between generated and non generated code.
the code gen eration approach only is insufficient in terms of changingabstraction.
steel j. and j ez equel j. m. introduce model types an application of typing in mdd.
model type an extension to object oriented typing to a model treats models as a collection of interconnected objects and can dealwith the relationships defined in mof meta object facil ity metamodels.
in our approach an interface is treatedas the exposure of archpoints.
a set of design and program modules implementing the same archpoints belong to the same type.
this idea can generalize the traditional interface notion and can be accepted in the mdd context.
the contribution of this paper is summarized as follows the notion of module and interface is introduced to theworld of design modeling archface integrates design interface with program interface and our type system can check the traceability between design and code in terms ofabstraction.
this novel idea enables yet another mdd.
additional costs are not needed to introduce our approach because archface descriptions can be generated from a uml model editor and archface is just an extension of the notion of program interfaces.
that is we can substitute archfacefor traditional program interfaces.
our approach can integrate research on design modeling with research on programming in terms of modularity and type systems.