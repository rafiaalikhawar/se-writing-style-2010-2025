efficienthybrid typestate analysisby determining continuation equivalentstates eric bodden software technology group department ofcomputer science technischeuniversit tdarmstadt germany bodden acm.org abstract typestate analysis determines whether a program violates a set of finite state properties.
because the typestate anal ysis problem is statically undecidable researchers have propo sed a hybrid approach that uses residual monitors to signal prop erty violations at runtime.
we present an efficient novel static typestate analysis that is flow sensitive partially context sensitive and that g enerates residual runtime monitors.
to gain efficiency our analysis uses precise flow sensitive information on an int raprocedural level only and models the remainder of the program using a flow insensitive pointer abstraction.
unlike previous flow sensitive analyses our analysis uses an addi tional backward analysis to partition states into equivale nce classes.
code locations that transition between equivalen t states are irrelevant and require no monitoring.
as we show in this work this notion of equivalent states is crucial to obtaining sound runtime monitors.
we proved our analysis correct implemented the analysis in the clara framework for typestate analysis and applied it to the dacapo benchmark suite.
in half of the cases our analysis determined exactly the property violating pr ogram points.
in many other cases the analysis reduced the number of instrumentation points by large amounts yieldin g significant speed ups during runtime monitoring.
categories andsubject descriptors d. .
software program verification validation general terms algorithms experimentation performance verification keywords typestate analysis static analysis runtime monitoring eric conducted most of this research as a ph.d. student at mcgill university under supervision of laurie hendren.
this work was supported by nserc and cased permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
icse may cape town south africa copyright acm ... .
.connected closed errorclose reconnectclose reconnect write writeclose write figure finite state machine for connection property .
introduction a typestate property describes which operations are available on an object or even a group of inter related objects depending on this object s or group s internal state the typestate.
for instance programmers must not write to a connection handle that is currently in its closed state.
figure shows a non deterministic finite state machine for this property.
it monitors a connection s close reconn ect and write events and signals an error at its accepting stat e. typestate properties aid program understanding and one can even define type systems that prevent programmers from causing typestate errors or derive static typest ate analyses that try to determine whether a given program violates typestate properties.
unfortunately the typest ateanalysis problem is generally undecidable.
researchers ha ve therefore proposed a hybrid approach that uses static analysis results to generate a residual runtime mon itor.
this monitor captures actual property violations as they occur but only updates its internal state at relevant statements as determined through static analysis.
a correct runtime monitor must observe events like close and write that can cause a property violation but also events like reconnect that may prevent the violation from occurring.
missing the former causes false negatives while missing the latter causes false positives i.e.
false warn ings.
either is unacceptable as runtime monitors must handle property violations exactly when they occur.
a correct static analysis must therefore determine program location s that can trigger either kind of such relevant events.
in this work we present an efficient novel static typestateanalysis algorithm called nop shadows analysis1that uses a forward and a backward pass to identify provably irrelevant code locations.
for every program statement sof interest the forward analysis determines the possible typestates th at can reach s. the additional backward analysis partitions these states into equivalence classes.
a program location 1the aspect oriented programming community uses the term shadow to refer to instrumentation points.that can only transition between equivalent states is irrel evant.
this eases the burden on the programmer as the programmer does not need to consider such irrelevant locations during manual code inspections.
moreover we eliminate the monitoring instrumentation from these program locations speeding up the residual runtime monitor.
our novel analysis is not only simpler than earlier approaches it is also both precise and efficient.
any precise typestate analysis has to be flow sensitive and requires must alias information to determine that the cod e c1.reconnect c2 c1 c2.write correctly uses the connection that c1andc2refer to the analysis needs to know that c1andc2must point to the same object i.e.
that c1andc2 must alias.
such information is expensive to compute.
to gain efficiency our analysis computes flow information and must alias information on an intra procedural level only and models the remaining program using a carefully designed flow insensitive pointer abstraction.
to evaluate our approach we have implemented our analysis in the clara framework for typestate analysis and applied the analysis to the dacapo benchmark suite .
our results show that our lightweight abstractions are precise enough to exactly tell apart property violating progr am points from irrelevant program points in half of the cases.
for these cases the analysis determines exactly the proper tyviolating program locations.
in many other cases the analysis identifies and disables large amounts of irrelevant pro gram points.
this eases manual code inspection and as we show speeds up the resulting residual monitor significantl y. our modest abstractions restrict the analysis time to a few minutes in most cases.
we proved our analysis correct.
as we found out during this process two analyses that we and others published previously are unsound.
they fail to identify certai n program locations that trigger violation preventing even ts like reconnect above.
as a consequence the resulting run time monitors may cause false warnings at runtime.
this unsoundness is caused by the fact that traditional typestat e analyses use a forward analysis pass only and have no notion of equivalent states like our novel analysis does.
to summarize this paper presents the following original contributions a novel flow sensitive static typestate analysis called nop shadows analysis that detects equivalent typestates to determine all statements that are relevant to causing or preventing a property violation an implementation of the nop shadows analysis in the clara framework that generates efficient residual runtime monitors a set of experiments that shows that the analysis is both precise and efficient and an explanation of why some other static analyses that use a forward analysis pass only generate unsound runtime monitors.
we structured the remainder of this paper as follows.
we start off by giving a brief overview of the clara framework in which we implemented our analysis.
in section we give an example to illustrate the nop shadows analysis itself.
we explain the full analysis in section followed by our experiments in section .
in section we discuss how we improve over the state of the art.
we conclude in section .claracompile weave woven programprogrammonitor aspect with property annotation static analysis engineoptimized instrumented programruntime monitordefine or generate test run figure overview of clara .
the clara framework clara compile time approximation of runtime analyses is a novel research framework for the implementation of hybrid typestate analyses.
we developed clara to support easy implementation of the analysis that we present in this paper among others.
clara s major design goal is to de couple the code generation for efficient runtime monitor s from the static analyses that convert these monitors into faster residual monitors.
in this work we can only give an overview of clara .
the author s dissertation gives a more detailed account.
clara is available at figure gives an overview of clara .
with clara the researcher first defines a set of typestate properties denot ing each property as an annotation to an aspectj aspect that implements a runtime monitor for the same property.
annotations directly encode a non deterministic finite st ate machine just as the one in figure .
in the author s dissertation we show how researchers can even use runtimemonitoring approaches like tracematches javamop and others to generate these annotated aspects automatically from high level monitor specifications.
clara weaves the monitoring aspect into the program under test and emits helper classes that implement the runtime monitor as defined by the aspect.
clara extends the aspectbench compiler for this purpose.
clara then invokes its static typestate analysis engine.
researche rs can add a number of static analyses to clara and have them applied in any order.
these analyses obtain through the finite state machine defined in the aspect s annotation enough information about the typestate property to precisely approx imate the set of relevant instrumentation points.
when an analysis determines that an instrumentation point is irrel evant to a property i.e.
the program can neither violate the property nor prevent a property violation at this point the n clara automatically disables the instrumentation for this property at this point.
the result is an optimized instrumented program that updates the runtime monitor only at program points at which instrumentation remains enabled.
the approach that we present in the following instantiates clara s static analysis engine with a combination of two previously published supporting analyses and our novel nop shadows analysis.
.
analysis by example we motivate our analysis using our running example it is an error to write to a connection object that was closed unless the connection was re connected in between.
figure shows the appropriate non deterministic finite state1public static void main string args connection c1 newconnection args c1.close c1.reconnect c1.close c1.close c1.write args c1.close c1.reconnect c1.write args figure simple example program using a single connection machine that clara obtains from parsing the annotation in the specified aspect.
the state machine accepts events of type close reconnect and write .
when a write follo ws a close then the state machine moves into its error state.
clara represents error states as accepting states.
let us call the language that this state machine accepts l. figure shows a simple example program that uses a single connection along with the analysis information that we compute explanation follows .
to keep the example simple this program contains only straight line code no outgoing method calls that may change the connection s type state and no aliasing.
our implementation however handles complete java programs including method calls recur sion loops exceptions and aliasing see section .
our example program violates the connection property by closing the connection even twice at lines and and then writing to the connection line .
note though that all other statements in this program are irrelevant to the property violation.
in particular one does not need to monitor the close and reconnect operations at lines and because they precede the violating fragment of the run.
conversely the operations at lines to follow this fragment and hence do not need to be monitored either.
a little more subtle it is even correct to omit monitoring one of the two close events at lines and .
but not both!
the static analysis that we present in the following will eliminate the instrumentation at exactly those shadow s that we just identified as irrelevant nop shadows as we call them.
instrumentation will only remain in lines and or and an optimal result for this program.
exampleapplicationofanalysisalgorithm.
for a method containing nshadows the nop shadows analysis consists of up to n rounds where each round identifies a single nop shadow until no further nop shadows can be identified.
each round consists of a forward and a backward pass.
the forward pass computes for every statement sthe typestates that can reach s. the backwards pass conversely computes classes of states from which the property state machine can reach a violating state using the remainder of the program execution that follows s. the forward pass uses a determinized version of the finitestate machine from the property specification.
figure 4a shows this state machine for our example.
in the following we will call this state machine mforward .
we number mforward s states for presentation purposes.
the forward0 2closereconnect write writeclose reconnect close reconnectwrite a deterministic finite state machine mforward forl write closewrite close reconnect write b deterministic finite state machine mbackward forl figure finite state machines for connection example analysis starts off in this state machine s initial state an d then updates the state according to the shadows that it encounters during analysis.
in figure we show the states that the forward analysis computes before and after each statement next to the downward arrow.
for instance the close statement at line changes the typestate from to .
importantly at property violations e.g.
at line the analysis will reach the violating state .
the backward pass on the other hand uses a deterministic finite state machine for l s mirror language l. for any word w w1.
.
.
w n l we define the mirror word wasw wn.
.
.
w .
the mirror language lis defined byl w w l .
while it would be sound for our backwards pass to use any finite state machine that accepts the language l we specifically use the state machine that we obtain by reversing mforward by flipping all edges and swapping initial and accepting states and then determinizing this finite state machine again.
the resulting state machine is minimal for l .
as we will explain in section a minimal finite state machine yields a more precise analysis result because in this state machine equivale nt states are collapsed into a single state.
for our example figure 4b shows the finite state machine that we obtain this way.
we omit the sink state that represents the empty state set.
we call this automaton mbackward .
note that we labeled each of this automaton s states with the set of states of mforward that this state represents.
these labels are important our analysis will compare states from the forward analysis with states from the backward analysis and labeling mbackward s states with their equivalent states ofmforward eases this comparison.
according to the semantics of clara s state machine notation a single program run can cause multiple property violations.
each violating sub path of the execution path starts at one of the program s possible entry points and ends at what we call a final shadow .
a final shadow is a shadow that is labeled with a symbol that leads into an error state like write in our example.
therefore in the example we apply the backwards analysis starting at both write statements lines and .
in figure we show the analysis result for both backwards analysis runs on the right hand side.
for instance the close statement at line changes the typestate from the state labeled with to the state labeled with .
the same statement further loops on the sink state as we show next to the left upward arrow the statement transitions from again to .nop shadow condition.
we now explain how we combine the forward and backward analysis information to iden tify nop shadows.
let source s be the state that the forward analysis computed just before a statement s target s the state for the location just after s and futures s the set of state sets that the backwards analysis computed for just after s. for instance for the close statement at line of figure we have source line target line futures line the following property is crucial to our approach because we compute futures s using a deterministic state machine forl the sets in futures s represent equivalence classes.
for instance the set represents the fact that using the remainder of the program execution one will reach a property violation from mforward s states or either way.
by using a minimal state machine we assure optimality when two states q1andq2are equivalent then in futures s both q1andq2will be members of the same class.
in the following for two states q1andq2we say that q1 andq2are equivalent and write q1 q2if the following holds q futures s .
q1 q q2 q a shadow is a nop shadow when it transitions between states in the same equivalence class.
let us denote by fthe set of accepting i.e.
violating states of mforward .
then we call a shadow at a statement sa nop shadow if .source s target s and .target s ne ationslash f. the second case is necessary because according to clara s monitoring semantics a monitor must signal repeated property violations every time the violation occurs.
this is use ful when the monitor executes error handling code.
for instance on c. close c.write c.write the monitor should signal a violation after both write events.
this is althou gh the second write event does not change the typestate we havesource s target s .
need for re iteration .
it is important to note that by our above definition a nop shadow is only a nop shadow in its current context i.e.
if all other shadows remain enabl ed.
this is because after identifying any particular single sha dow as a nop shadow by disabling this shadow we change the program s transition structure and previous nop shadows may therefore not be nop shadows any more.
this is exactly the case at lines and of our example according to the nop shadow condition both shadows are nop shadows.
however disabling one of these shadows will render the other one necessary one needs to observe one of these two shadows otherwise the runtime monitor will not reach its vi olating state at line .
conversely our nop shadow conditi on does not initially identify the reconnect shadow at line as a nop shadow.
this is because disabling this shadow while keeping the shadows at lines and enabled would cause a false positive at runtime at line .
however after any of these latter two shadows have been enabled the reconnect shadow will become a nop shadow too and can be disabled as well.
to be both sound and effective we therefore programmed our analysis to disable a single shadow at a time and then re compute the analysis information re iteratin guntil no further nop shadow can be identified.
the number of iterations is bounded by the number of shadows that the current method holds.
in our example we reach a fixed point in the 7th iteration instrumentation will only remai n in lines and or and .
while this result is optimal for this particular program note that because our algorithm disables shadows one by one it works in a greedy fashion.
in theory this may cause the algorithm to reach its fixed point in a local optimum instead of the global optimum.
the author s dissertation appendix c gives a constructed example that demonstrates this behavior.
as we will show however our simple greedy solution performs very well in practice.
we conjecture that this is due to the usually relatively simple structure t hat typical finite state properties have.
.
nop shadowsanalysis we next explain how we handle the general analysis problem involving loops outgoing method calls recursion ex ceptions and aliasing.
for every shadow sin the instrumented program to determine whether sis a nop shadow our analysis needs to compute source s target s and the setfutures s .
the analysis needs to fulfil multiple conditions to compute these pieces of analysis information in a sound way.
we need to consider all possible control flow paths through the program that could potentially lead up to the execution of sand that are completed by the continuation of the control flow after s. then along every such path we must assure that we never merge futures sets at any point merging sets would compute incorrect equivalencies.
lastly the analysis must be able to distinguish th e typestates of multiple different combinations of objects .
in particular the analysis must be able to handle aliasing.
to cope with the analysis distinguishes the analysis information for different objects by propagating configura tions instead of bare state sets a configuration c q b combines an automaton state set qwith a variable binding b. when cis associated with a statement s then the state setqholds all possible typestates just before executing s. the binding bdescribes the object s which this state set is associated with.
in our connection example for any given statement sthere could exist multiple connections that are in different typestates when sexecutes.
the variable bindings help distinguish these different typestates.
a variabl e binding maps one or more variables from the typestate specification to object representatives2that model the runtime objects that these variables are bound to.
the treatment of variable bindings is quite intricate but has been presente d in previous work .
hence we ease our presentation by abstracting from variable bindings and instead assuming that we perform typestate analysis only for one single object rep resentative.
for the remainder of this paper we therefore as sume that a configuration is just a set of automaton states without any binding.
the author s dissertation gives a complete treatment including variable bindings with proo f. 2object representatives transparently model runtime objects at compile time.
two representatives are equal when they must alias i.e.
represent the same runtime objects.
in addition they support a must not alias operation.
object representatives combine flow insensitive whole prog ram points to sets with intra procedural flow sensitive alias information.
we compute points to sets with sridharan and bod k s context sensitive points to analysis .we ensure condition i.e.
not merging state sets by simply not merging configurations at any time.
in particular we do not merge configurations at control flow merge points if a conditional execution leads to a configuration c1 on one branch and to c2on another branch then we propagate both c1andc2after both branches have merged.
for efficiency we designed the nop shadows analysis to compute flow sensitive analysis information only on an intr aprocedural level.
in particular our must alias analysis i s only intra procedural.
one may think that such an analysis would have to be quite imprecise.
however before we designed our analysis we manually investigated the instru mentation points that our typestate instrumentation cause s and found that in most cases intra procedural analysis in formation was sufficient to determine nop shadows.
to take care of condition i.e.
maintain soundness in the prese nce of inter procedural control flow we pair this precise intra procedural information with coarse grained inter proced ural summary information that can be computed relatively efficiently.
the results that we present in section confirm that this solution is both precise and efficient.
in line with our example from section the nop shadows analysis computes for every shadow bearing method both a forward and a backward analysis pass.
the forward and backward analysis are both instances of a general worklist algorithm that we show as algorithm .
in this algorithm the syntax f denotes the function that is equal to f on all values v except for x in which case it returns y f v y ifv x f v otherwise we will explain the internal workings of this algorithm in section .
.
first we will explain how we initialize the algo rithm s parameters.
algorithm worklist initial succcfg succext wl initial before after stmt.
while wlnon empty do pop job stmt cs from wl before before cs csifshadows stmt otherwise forc cs shadow shadows stmt do c q c q label shadow cs cs c end for csnew cs after stmt ifcsnewnon empty then after after forstmt succcfg stmt do wl wl stmt csnew end for forstmt succext stmt do wl wl stmt mapsto wl stmt reaching csnew relatedshadows stmt end for end if end while4.
initializingthe worklistalgorithm the initialization depends on whether we perform a forward or backwards analysis.
the first argument to the algorithm is a set initial of initial jobs .
a job is a pair stmt cs associating a statement stmtwith a set csof configurations i.e.
with a set of sets of automaton states.
for the forward analysis we must initialize the algorithm with configurations that model all possible control flow that could have occured before entering the current method m but without having executed malready.
later in this section we explain how we soundly handle re executions of m as well trough a special successor function succext.
ifq0is the initial state of mforward andshadowsnotin m is the set of shadows outside of m then the set of initial jobs associates with m s entry statement eall configurations that are reachable from the initial configuration q0 by executing any of the shadowsnotin m initial e reaching q0 shadowsnotin m here we define for every set csof configurations and ssof shadows reaching cs ss as the smallest set of configurations for which holds cs reaching cs ss and c reaching cs ss a l q a q c reaching cs ss .
note that this fixed point computation is flow insensitive we do not consider the order in which the shadows in sscould execute.
this allows us to compute reaching very efficiently.
for the backwards analysis we generate initial configurations in a similar but not identical way.
a violating trace ca n only start at the beginning of the program but it can end causing a violation in the current method mitself or in another method either with mon the call stack or not .
we generate initial jobs to cover these three cases.
due to spac e limitations we give a formal definition in the accompanying dissertation .
the second and third arguments to the algorithm succcfg andsuccext are successor functions that model the possible control flow within the current method m respectively outside of m. figure visualizes both successor functions.
we show the current method m herefoo as a box.
the method contains two invoke statements.
the first statement resembles a potentially recursive call including mutual lyrecursive calls the second one a provably non recursive c all.
the dashed arrows denote the successor function succcfg which is given by m s control flow graph.
this graph allows us to soundly handle control flow caused by conditionals loops and exceptions.
solid arrows show the second interprocedural successor function succext.
during the execution ofm invoke expressions within mmay cause methods to be called.
these calls either can or cannot transitively perfo rm a recursive call back into m. when the call may be recursive then configurations that we computed for this call site can reach m s entry statement see arrow .
conversely for configurations that we computed for any of m s exit statements we need to propagate these configurations back to any potentially recursive call site within m see .
at compile time we can usually only determine that a method call may be recursive not that it must be.
hence we also need to propagate configurations from the call site to after itself see 3a .
for calls that are provably not recursive aspublic void foo x.foo y.bar 3a 3b method entry method exitpotentiallyrecursive call site provably non recursive call site figure functions succcfg dashed succext solid determined by a call graph it suffices to propagate configurations past the call site itself see 3b .
lastly we need to take into account the case in which method mreturns either normally or by throwing an exception succcfghandles both cases and then re executes.
to model this case we propagate configurations from m s exit s to its entry .
in line with figure we define succextas follows.
let heads m be the set of entry statements of m and tails m the set of m s exit statements3.
further let reccall m be the set of potentially recursive invoke statements of m andnonreccall m the set of provably non recursive invoke statements respectively.
then succext s. succcfg s if s nonreccall m heads m succcfg s if s reccall m succcfg reccall m heads m ifs tails m otherwise for the backward analysis we revert both successor functions the succcfgandsuccext i.e.
we flip all their edges before passing them to our worklist algorithm.
this causes the backward analysis to actually compute backwards.
the fourth and final parameter to our worklist algorithm is the automaton s transition function.
for the forward analysis we use the transition function of mforward .
for the backward analysis we revert this function flipping all edges.
effectively this yields a non deterministic versio n ofmbackward .
this is sufficient because algorithm determinizes states on the fly see line .
by not determinizing mbackward ahead of time we ensure that both the forward and the backward analyis act on the same state sets just the transition function differs.
this in turn makes it easi er to determine nop shadows.
.
actual worklistalgorithm algorithm first initializes its worklist wlwith the set of initial jobs as explained above.
the algorithm further 3usually heads m will be a singleton set but because our backwards analysis operates on a reversed control flow grap h where heads become tails and tails become heads heads m can contain more than one element in this setting.initializes two mappings before andafterthat store the configurations that have been computed so far before respectively after each statement.
these sets allow us to perform a terminating fixed point iteration.
next the algorithm iterates through its worklist.
for every job stmt cs the algorithm first updates stmt s beforeset.
then when a statement holds no shadow we just leave the configurations unchanged line in algorithm .
otherwise we compute line for every new configuration c cs andshadow atstmt successor configurations using the supplied transition function .
in clara programmers describe events through aspectj pointcuts.
although seldom the case pointcuts can overlap thereby causing one single statement to be associated with multiple shadows.
to compute the transition the algorithm accesses the shadows s unique label label shadow .
in our running example this label could be close reconnect or write .
to allow the analysis to later on compare state labels of mforward with the state set labels that mbackward uses we determinize state machines on the fly line computes the unique set of successor states.
the algorithm then updates stmt s after set and associates new jobs with two different kinds of successor statements.
first in lines the algorithm adds new jobs containin g the successor configurations csnewfor any statement that is a successor of stmtinm s control flow graph as determined by succcfg.
lines use the the external successor function succextto handle inter procedural control flow.
when propagating configurations along a succext edge it is not correct to just copy the configurations from the edge s source to it s target.
note that between any two executions ofm other methods may execute and cause transitions in the monitoring state machine.
to soundly model these potential transitions by other methods algorithm associates in line with any inter procedural successor not ju st the set of new configurations csnewbut instead the set of configurations reaching csnew relatedshadows stmt .
we defined the function reaching already above.
the function relatedshadows stmt computes the set of all shadows related to stmt.
we define this set as follows.
for any invoke statement stmt potentially recursive or not the set relatedshadows stmt contains all shadows in all methods transitively reachable through stmt except for the ones in mitself.
after all these are all the shadows that one can reach before reaching m s entry statement again.
otherwise i.e.
if stmtis a tail of m then relatedshadows stmt contains all shadows in the program except for the ones in m. our implementation further narrows down related shadows by comparing each shadow s variable binding to the binding stored in the configuration csnew.
it is worthwhile noting that because we compute the expression reaching csnew relatedshadows stmt for each statement separately we gain a certain amount of contextsensitivity.
while shadows inside a certain method m with m ne ationslash m may be relevant to one statement of mthey may be irrelevant to other statements in m and by recomputing the above function we properly distinguish such cases.
.
removing nopshadows in addition to the nop shadows analysis clara also contains implementation of a syntactic quick check and a flowinsensitive pointer based orphan shadows analysis .
because these analyses do not take control flow into account they take only milliseconds once points to information has been computed.
therefore before executing the more expensive nop shadows analysis we execute the quick check and the orphan shadows analysis first.
then if shadows remain enabled we compute the nop shadows analysis for every shadow bearing method.
the analysis information directly provides us with source target andfutures for every statement.
we use this information to identify and disable a nop shadow if possible and then re iterate until we can find no further nop shadows for this method.
in our benchmark set we had to iterate ten times or less for all but four methods.
when we reach the fixed point we proceed with the next method.
when all methods are processed we apply the flow insensitive orphan shadows analysis again and then re iterate the whole nop shadows analysis.
this is because disabling a shadow in one method may render shadows in other methods irrelevant.
it seems to be always sufficient to iterate this outer loop two to three times.
when this loop reaches a fixed point we stop.
.
experiments to validate our approach we verified a set of twelve typestate properties over ten benchmark programs of the dacapo benchmark suite .
this lead to property benchmark combinations.
of these combinations were interesting to us in the sense that shadows remained after applying the first two previously published analysis stag es.
the combinations comprised eight out of the original twelve properties.
table explains these properties.
we applied the nop shadows analysis to these combinations.
first we were interested in comparing the nop shadows analysis to a traditional typestate analysis that only has a forward component.
as we will explain in section one cannot use the latter to identify nop shadows and optimize runtime monitors but of course one can use both analyses to determine potentially property violating program poin ts i.e.
program points at which the abstraction reaches a final state.
we therefore modified our analysis to run the forward pass only recording all potentially property violat ing program points.
then we ran the nop shadows analysis as we described it earlier with all re iterations disabling nop shadows as they are identified and recording as well all potentially property violating program points.
interestin gly we discovered that for our benchmark set the program points completely coincided.
hence we can state that the backwards pass and the reiteration do not help with identifying these program points.
however they are crucial for identifying nop shadows on the preceding execution.
next we were interested in seeing what fraction of shadows the nop shadows analysis manages to identify as nop shadows.
table summarizes our analysis results.
the fraction of shadows that our analysis identified as nop shadows appears in white.
in gray we show the fraction of shadows which are known to trigger actual violations at runtime.
the remaining black slice represent shadows that remain active even after analysis either due to analysis imprecision or d ue to actual property violations.
for out of these combinations our novel nopshadows analysis was able to identify all shadows as irrelevant and therefore proved that the program cannot violate the stated property.
these cases appear as all white circles.
in four other cases shadows remained enabled but only because they do trigger a property violation.
thesefailsafeenum do not update a vector while iterating over it failsafeenumht do not update a hash table while iterating over its elements or keys failsafeiter do not update a collection while iterating over it failsafeitermap do not update a map while iterating over its keys or values hasnextelem always call hasmoreelements before nextelement on an enumeration hasnext always call hasnext before calling next on an iterator reader do not use a reader after its inputstream was closed writer do not use a writer after its outputstream was closed table relevant typestate properties and their names cases contain gray but no black fragments.
in other words the analysis gave exactly the correct result with no false positives in half of the cases.
in three cases the analysis failed to identify any nop shadow black circles .
in the remaining cases the analysis removed a sometimes significant amount of shadows.
this may speed up runtime monitoring for these cases depending on whether the test run exercises these shadows a lot.
for our experiments we used monitoring aspects generated from tracematches .
table gives qualitative information about the residual monitor s runtime overhead through the ring that surround each circle.
the dissertation gives the f ull data.
interestingly while there is some correlation betw een the number of remaining shadows and the runtime overhead that these shadows cause the correlation is not one to one .
for instance in jython failsafeiter there remain sha dows opposed to just in the case of lusearch failsafeiter .
nevertheless lusearch does show a perceivable runtime ove rhead but jython does not.
we conclude that the positive effect that the removal of a shadow smay have on the monitoring overhead depends to some extend on how often the program under test would execute sat runtime.
our analysis works well on the antlr fop hsqldb luindex lusearch and xalan benchmarks.
most of the potential false positives black in the figure appear only because the benchmarks use reflection.
due to a known deficiency java scloneable interface contains no public declaration of aclone method.
therefore java s type system may prevent clients from calling clone even oncloneable objects.
chart uses reflection to call the clone method on objects that implement the cloneable interface.
because chart clones collections our points to analysis has to saf ely assume that the collections could be of any type including emptyset which as a singleton object is stored in a static field causing our analysis to loose all context information .
bloat jython and pmd cause similar problems.
there appear to be few cases where our analysis is too imprecise because of its design.
for example two actually irrelevant final shadows remain enabled in hsqldb with reader and writer.
these false positives occur because xalan uses different methods to open close and write to streams.
a fully inter procedural analysis could rule out possible vi olations in these cases.
however we found that due to its intra procedural nature the nop shadows analysis has an interesting property the analysis revealed missing pre condit ions on xalan s methods.
for instance the write calling method is missing the pre condition that the argument file shouldantlr bloat chart fop hsqldb jython luindex lusearch pmd xalan failsafeenum0 failsafeenumht26 failsafeiter830 failsafeitermap444 49oome133 hasnextelem0 hasnext452 reader0 writer35 table shadows classified by our analysis.
white slices sh adows that the nop shadows analysis identified as irrelevan t. black slices shadows that we fail to identify as irrelevant due to analysis imprecision or an actual violation.
gray sl ices actual property violations that we found through manual ins pection.
the outer rings represent the residual monitor s r untime overhead.
solid overhead dashed overhead dotted no overhead.
oome outofmemoryerror not be in state closed .
in future work we plan to use this information to support program understanding and to further enhance precision.
detected property violations.
when manually inspecting the remaining shadows we found several actual property violations.
bloat violates writer because it contains a method that writes to a file handle that it then closes.
when called multiple times this method will violat e the property.
we could not confirm whether certain runs of bloat may actually call this method multiple times.
jython sometimes violates reader by closing a stream prematurely.
jython then catches the resulting exception and returns nul l. xalan violates hasnextelem by calling nextelement without a preceding call to hasmoreelements .
nevertheless the program is safe because it checks the size of the underlying vector to assure that the calls are legal.
the property specification is too simplistic in this setting.
several ben chmarks violate failsafeenum and failsafeenumht.
these benchmarks do indeed modify vectors or hash tables while iterating over them.
this can lead to unexpected behavior.
with iterators this does not usually happen because iterators have fast fail semantics and will throw a concurrentmodificationexception in such situations.
luindex violates the failsafeiter pattern.
this error probably remained undetected because it only occurs on quite unlikely execution paths.
the author s dissertation provides more details .
analysis time.
our analysis time is clearly dominated by the time it takes to compute the supporting analyses that the nop shadows analysis requires.
constructing a cal l graph and context sensitive points to sets took about two and a half minutes on average.
the nop shadows analysis itself took under seconds on average.
this time includes all re iterations of the orphan shadows analysis and nopshadows analysis that clara performs.
in of the cases the analysis finished in under one minute.
by far the worst case was bloat failsafeiter for which this analysis stage took minutes.
bloat is notoriously hard to analyze .
limitations andthreatsto validity.
we identified the following limitations of our approach.
all dacapo benchmarks load classes using reflection.
static analyses like ours have to be aware of these classes so thatthey can construct a sound call graph.
we wrote an aspectj aspect that would print at every call to forname and a few other reflective calls the name of the class that this call loads and the location from which it is loaded.
we further double checked with ond rej lhot ak who compiled suc h lists of dynamic classes earlier.
we then provided soot which is part of clara with this information.
the resulting call graph is sound for the program runs that dacapo performs.
obtaining a call graph that is sound for all runs may be challenging for programs that use reflection.
for eclipse we were unable to determine where dynamic classes are loaded from.
eclipse loads classes not from jar files but from resource urls which eclipse resolves inter nally usually to jar files within other jar files.
soot currently cannot load classes from such urls and that is why we omit eclipse in our experiments.
the jython benchmark generates code at runtime which it then loads.
we did not analyze this code and so made the unsafe assumption that this code would not cause any typestate changes.
otherwise the internal validity of our experiments is high because we directly measure the number of final shadows before and after the analysis.
the final shadows are exactly the points that programmers would first inspect when checking possible property violations.
hence reducing the number of final shadows will reduce the burden on the programmer.
this is especially true when eliminating all final shadows thus proving that the program cannot violate the property.
to measure the runtime overheads precisely we extended the dacapo harness with a custom driver class.
with this driver class dacapo first executes a warm up run and then re runs the benchmark multiple times until the relative sta ndard deviation of the determined runtimes drops below but at least times and at most times .
then we report the arithmetic mean of these runs.
dacapo s standard driver only measures a single benchmark run which has caused misleading results for us in the past.
the external validity is limited by our choice of benchmarks.
however the dacapo benchmarks are a realistic representative set of medium sized to large scale applica tions.
the suite contains both well behaved benchmarks that are free of reflection and benchmarks that are harder to analyze due to reflection.
our analysis excels on the former however further work is required to handle the latter more effectively.
we plan to address these problems by simulating reflection in a more fine grained manner.
.
related work strom and yemini were the first to suggest the concept of typestate analysis.
in the last few years researchers ha ve presented several new approaches with varying cost precision trade offs.
in the following we describe the approache s that are most relevant to our work.
type systembasedapproaches.
type system based approaches define a type system and implement a type checker.
this is to prevent programmers from compiling a potentially property violating program i n the first place and gives the advantage of strong static guarantees.
on the other hand the type checker may reject useful programs that statically appear to violate the state d property but will not actually violate the property at runtime.
our approach allows the programmer to define a program that may violate the given safety property.
our analysis then tries to verify that the program is correct and when this verification fails it delays further checks until runti me.
bierhoff and aldrich present a type system based approach that enables the checking of typestate properties in the presence of aliasing.
the author s approach aims at being modular and therefore abstains from potentially expensive whole program analyses like ours.
to be able to reason about aliases nevertheless bierhoff and aldrich associate special access permissions with