automatic recovery from runtime failures antonio carzaniga alessandra gorla andrea mattavelli nicol o perino mauro pezz e university of lugano faculty of informatics lugano switzerland saarland university computer science saarbr ucken germany abstract we present a technique to make applications resilient to failures.
this technique is intended to maintain a faulty application functional in the field while the developers work on permanent and radical fixes.
we target field failures in applications built on reusable components.
in particular the technique exploits the intrinsic redundancy of those components by identifying workarounds consisting of alternative uses of the faulty components that avoid the failure.
the technique is currently implemented for java applications but makes little or no assumptions about the nature of the application and works without interrupting the execution flow of the application and without restarting its components.
we demonstrate and evaluate this technique on four mid size applications and two popular libraries of reusable components affected by real and seeded faults.
in these cases the technique is effective maintaining the application fully functional with between and of the failure causing faults depending on the application.
the experiments also show that the technique incurs an acceptable runtime overhead in all cases.
i. i ntroduction software systems are sometimes released and then deployed with faults and those faults may cause field failures and this happens despite the best effort and the rigorous methods of developers and testers.
furthermore even when detected and reported to developers field failures may take a long time to diagnose and eliminate.
as a perhaps extreme but certainly not unique example consider fault n. in the firefox browser which was reported first in march and other times over the following ten years and is yet to be corrected at the time of writing of this paper summer .1the prevalence and longevity of faults in deployed applications may be due to the difficulty of reproducing failures in the development environment or more generally to the difficulty of diagnosing and eliminating faults at a cost and with a schedule compatible with the objectives of developers and users.
at any rate dealing with faults that escape the testing environment seems to be a necessity for modern software and in fact several lines of research have been devoted to avoiding or at least mitigating the effects of faults in deployed software.
a primary example is software fault tolerance.
inspired by hardware fault tolerance techniques such as raid software fault tolerance is based on the idea of producing and executing different versions of an application or parts of it so as to obtain a correct behavior from the majority or possibly even just one of the versions .
bug.cgi?id 3655the problem with these fault tolerance techniques is that they are expensive and are also considered ineffective due to correlation between faults.
therefore more recent techniques attempt to avoid or mask failures without incurring the significant costs of producing fully redundant code.
among them some address specific problems such as inconsistencies in data structures configuration incompatibilities infinite loops security violations and non deterministic failures while others are more general but require developers to manually write appropriate patches to address application specific problems .
in this paper we describe a technique intended to incur minimal costs and also to be very general.
the technique works opportunistically and therefore can not offer strict reliability guarantees.
still short of safety critical systems our goal is to support a wide range of applications to overcome a large class of failures.
similarly to other techniques the main ingredient we plan to use is redundancy.
in particular we propose to exploit a form of redundancy that is intrinsic in modern component based software systems.
we observe that modern software and especially reusable components are designed to accommodate the needs of several applications and therefore to offer many variants of the same functionality.
such variants may be similar enough semantically but different enough in their implementation that a fault in one operation might be avoided by executing an alternative variant of the same operation.
the automatic selection and execution of a correct variant to avoid a failure of a faulty one is what we refer to as an automatic workaround .
in prior work we have developed this notion of automatic workarounds by showing experimentally that such workarounds exist and can be effective in web applications .
we initially focused on web applications because they allowed us to make some simplifying assumptions regarding the state and execution flow of the application.
in particular web applications consist of a user interface built and modified by event driven procedures that always run to completion and are also essentially stateless the state of the application is typically held on the server side .
with this execution model it is relatively easy to apply an automatic workaround by changing the code of one or more procedures and simply re executing them by reloading the page .
web applications also simplify the failure detection problem since the user can be assumed to detect failures and explicitly request workarounds.in this paper we present a technique to apply automatic workarounds to general purpose possibly long running applications.
the technique is implemented for java applications but makes little or no assumptions about the nature of the application.
we make the very reasonable assumption that the application uses components taken from libraries and for simplicity in the following discussion we consider one such library per application.
the only two significant assumptions we make are that the library comes with a specification of the equivalence between the operations it supports and that failures are somehow detected and reported.
the equivalence specifications may be written by the programmer of the library or by a knowledgeable user of the library.
in any case they need to be written only once for each library.
in section iii we briefly discuss the possibility of deriving these specifications automatically.
as in our prior work we express those specifications with code rewriting rules that are supposed to produce semantically equivalent code.
as for failure detection our technique is almost completely independent of the particular detection and reporting mechanism.
in practice we use exceptions as a reporting mechanism and we experimented with implicit failure detectors such as run time exceptions as well as with more sophisticated detectors based on derived application specific invariants.
at a high level the technique works as follows when a failure is detected the state of the application is restored to a previous checkpoint then the code of the application is dynamically changed to replace a chosen code fragment that contains a call to the library with a potential workaround and then the execution is restarted from the checkpoint with that new code.
a bit more in detail the technique consists of an off line preprocessing that also instruments the application with the necessary machinery to apply workarounds at runtime.
the preprocessor identifies through static analysis those sections of the application code in which the application calls the library in ways that could potentially be rewritten and in which failures may be detected.
we refer to those sections of application code as roll back areas rbas .
the preprocessor then produces alternative versions of each rba using all the applicable rewriting rules.
these versions are then compiled and stored for possible use at runtime.
the preprocessor also instruments the application code by wrapping each rba in a loop.
the loop starts with a checkpoint of the state of the application then proceeds with the execution of the rba code and then iterates in case of failures.
the iteration restores the state to the initial checkpoint replaces the code of the rba with one of the alternative versions and resumes the execution with the new version.
we demonstrate and evaluate our technique by applying it to two popular libraries and four applications that use those libraries.
the first library is guava google s core library for collections caching string processing and more the second library is jodatime a utility to process and convert dates and time across multiple and diverse calendar systems.
the applications are an e book converter called fb2pdf a frameworkfor java microbenchmarks called caliper a search results clustering engine called carrot2 and a javascript source tosource compiler called closure .
we evaluate the effectiveness of our technique by measuring its ability to handle real as well as injected faults and also by measuring its runtime overhead.
in summary our experiments demonstrate that the technique is effective while incurring an acceptable overhead.
in particular the technique maintains the applications fully functional with between fb2pdf and carrot2 of the failure inducing faults with a run time overhead of between caliper and closure .
ii.
a m otivating example jodatime is an open source java library of utilities to deal with dates and time.
it provides full support for several calendars it allows to easily represent dates and intervals and to easily parse and format dates.
in may a developer reported issue n. with the jodatime library.2as it turns out that issue was fixed within a short period of time but the issue is still interesting because of the nature of the fault and the resulting failure.
issue n. reported a failure resulting in an exception when trying to get the instant corresponding to the beginning of the day on certain dates in countries that observe daylight saving time dst .
this failure could not be easily obtained in testing since it is triggered only under particular conditions namely in regions where the dst leap occurs over midnight e.g.
america sao paulo every year some years in us regions and some latin america regions .
1datetimezone tz datetimezone.forid america sao paulo 2datetimezone.setdefault tz gets a new instance of datetime with the current date and time 5datetime dt new datetime method call causing an exception in specific days and time zones.
8datetime startday dt.millisofday .withminimumvalue listing .
code failing on due to issue n. due to this issue the code in listing would fail with an exception on the day when daylight saving starts for instance .
the reason of the failure is that the invocation of dt.millisofday .withminimumvalue which is a way to get the representation of the beginning of the day would return .
on but that instant does not exist on because that day begins at .
due to the dst leap.
thus issue n. would cause any java application using jodatime in similar ways to fail unless the developer had also put in place a proper and specific exception handling procedure.
however that is unlikely because the failure scenario is somewhat obscure and hard to anticipate and test for.
one might argue that cases like this one are rare but while id atid 617889this specific case is in and of itself rare it is also indicative of many similar special cases or features whose implications are not fully understood and therefore not properly handled.
failing operation 2datetime beginday dt.millisofday .withminimumvalue workaround 4datetime beginday dt.todatemidnight .todatetime workaround 6datetime beginday dt.withtimeatstartofday listing .
workarounds for issue n. of jodatime fortunately however jodatime offers several different ways to get the instant representing the beginning of the day.
as shown in listing there are at least two alternative ways to obtain the same expected result that do not suffer from that failure.
such alternative operations could be easily documented and therefore be used as automatic workarounds at runtime.
iii.
i ntrinsic redundancy in reusable components the foundational idea of our technique is that failures might be avoided with workarounds consisting of operations or sequences of operations that are equivalent to the failing ones but that do not suffer from the same failures.
more specifically a workaround consists of operations whose effect is equivalent to the intended effect of the original failing sequence but whose implementation does not fail and therefore must be to some extent different.
in other words workarounds require redundancy different code to do the same thing.
moreover contrary to classic n version programming we expect this redundancy to be available at no cost since we argue that this redundancy is an intrinsic property of modular software.
it is therefore natural or even necessary to ask whether modern software is indeed intrinsically redundant and if so to what extent.
and if the extent is significant it would also be interesting to find out why.
in this section we provide some qualitative arguments with