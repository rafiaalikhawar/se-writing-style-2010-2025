self adaptation through incremental generative model transformations at runtime bihuan chen y xin peng y yijun yuz bashar nuseibehzx and wenyun zhao y school of computer science fudan university china yshanghai key laboratory of data science fudan university china zdepartment of computing and communications the open university uk xlero the irish software engineering research centre university of limerick ireland bhchen pengxin wyzhao fudan.edu.cn y.yu b.nuseibeh open.ac.uk abstract a self adaptive system uses runtime models to adapt its architecture to the changing requirements and contexts.
however there is no one to one mapping between the requirements in the problem space and the architectural elements in the solution space.
instead one re ned requirement may crosscut multiple architectural elements and its realization involves complex behavioral or structural interactions manifested as architectural design decisions.
in this paper we propose to combine two kinds of self adaptations requirementsdriven self adaptation which captures requirements as goal models to reason about the best plan within the problem space and architecture based self adaptation which captures architectural design decisions as decision trees to search for the best design for the desired requirements within the contextualized solution space.
following these adaptations component based architecture models are recon gured using incremental and generative model transformations.
compared with requirements driven or architecture based approaches the case study using an online shopping benchmark shows promise that our approach can further improve the e ectiveness of adaptation e.g.
system throughput in this case study and o er more adaptation exibility.
categories and subject descriptors d. .
design methodologies d. requirements speci cations d. software architectures general terms design management keywords self adaptive system runtime model requirements architecture design decisions model transformation permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction in software engineering requirements analysis seeks to solve the right problem while design space exploration seeks to solve the problem right .
both activities traditionally happen at development time.
after a software product is deployed changes to the problem or to the solution require a time consuming at best iterative development activity .
increasingly however software systems are required to respond quickly to changing environments and requirements by dynamically adapting their architectures to their perception of customers satisfaction.
model based approaches have been proposed as one way to achieve runtime self adaptation .
instead of relying on low level and error prone scripts for every possible adaptation with models at runtime a system can query analyze and manipulate them to realize dynamic adaptations .
speci cally requirements models e.g.
and architecture models e.g.
have been used for selfadaptation.
however some problems still remain.
requirements driven approaches assume that requirements elements e.g.
goals can be simply and directly mapped to architectural elements e.g.
components and thus neglect the complexity of architectural design.
architecturebased approaches on the other hand assume that requirements are well understood at design time and unchanged at runtime and thus are unable to support dynamic adaptations to changing requirements.
in any case both these two kinds of self adaptation approaches have a role to play and should be combined.
in the prior attempts to combine them e.g.
following kramer and magee s reference architecture architectural elements are regarded as a collection of interfaces to functional requirements hence lacking consideration of more complex architectural concerns.
a software architecture is not just a collection of functionalities but also a collection of design decisions concerning how those functionalities are structured and interacting with each other .
in that sense architectural adaptations must also re ect the adaptations of design decisions.
manifest as the adapted design decisions architectural adaptations may crosscut simultaneously multiple parts of a system for instance adding a logger function before any access to con dential information for better security.
architectural adaptations may also involve restructuring of existing functionalities to change the runtime structures or behaviors for instance changing the structure of collaborating components from sequential to parallel for better performance.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
in this paper we propose a new model based self adaptation approach that combines requirements and architectural adaptations and supports complex architectural adaptations using model transformation techniques.
we assume that requirements are available at runtime as goal models architectural design decisions are available at runtime as design decisions models expressed as decision trees and these models are consistent with each other.
our approach periodically searches for a better architectural design solution using the design decisions model.
if no solution exists given the constraints of current requirements and contexts goal oriented requirements reasoning is conducted to nd a better goal speci cation within the constraints of quality expectations and then the related design decisions are reconsidered to nd a design solution re ecting the adapted goal speci cation.
in either case architectural adaptations are achieved by executing the automatically generated model transformation scripts in qvt r query view transformation relations that incrementally transform the current runtime architecture model into an adapted one.
given the adapted architecture model the actual system recon gurations can be delegated to any existing architecture based management middleware e.g.
.
we conducted a case study using an online shopping benchmark to evaluate the proposed approach.
the results show promise that our approach can further improve the e ectiveness of adaptation e.g.
system throughput in this case study and o er more adaptation exibility than requirementsdriven or architecture based self adaptation approaches.
the rest of this paper is structured as follows.
section motivates our work through a running example.
section introduces some preliminaries required before section presents our proposed approach.
section evaluates our proposal.
section introduces and compares some related work before section draws our conclusions.
.
a motivating example an online shopping company has a business department in charge of marketing strategies and a technical department in charge of development and maintenance of the it systems.
suppose a sales promotion is launched for celebrating the new year.
it is anticipated that the system may su er performance degradation due to the payload of a large number of concurrent requests.
without adaptation to the increased load the response time and failure rate of order processing could increase resulting in customer dissatisfaction.
now consider the following two adaptation scenarios.
scenario a jack the chief architect of the technical department is noti ed of the problem and nds out that the bottleneck lies in the order veri cation process which has been implemented by several components including order information checking credit checking and fraud checking.
after reconsidering the design decisions of the current architecture jack decides to adapt the interaction structure of the order checking components from sequential to parallel processing for a better performance.
this architectural adaptation resolves the problem and the whole adaptation process is made transparent to the business department.
scenario b jack is noti ed and reconsiders the design decisions but cannot nd any architectural design alternative to alleviate the problem.
he raises the problem as an issue to bob the manager of the business department.
after reconsidering the business decisions that led to the currentrequirements speci cation bob decides to adapt the order veri cation process to involve only order information and credit checking and skip fraud checking even though he is aware of the potential loss due to higher risks.
this business adaptation may help accelerate the order processing process at the cost of a higher risk of malicious orders.
following this business requirement change jack can adapt the technical architecture accordingly.
to this end jack rst identi es the components that are in uenced by this requirement change and then removes the components that were introduced for the eliminated functionalities.
since the implementation of a requirement may be scattered across di erent parts of the architecture such architectural adaptations often crosscut multiple architectural elements.
the above analogy of the business and technical departments helps explain the following two observations.
first runtime adaptations often involve both requirements and architectural decisions where di erent concerns e.g.
business versus technical require di erent knowledge e.g.
requirements versus architectural design .
second mappings from requirements to architecture are non trivial which involves complex traceability from requirements to architectural elements and architects knowledge about design decisions.
model based self adaptation can thus be regarded as an automation of these adaptation processes at runtime based on the runtime representations of requirements and architectural design knowledge.
.
preliminaries this section brie y introduces the preliminaries i.e.
goaloriented requirements and architectural design decisions.
.
goal oriented requirements in goal oriented requirements analysis typically functional requirements are modelled as hard goals and quality requirements are modelled as softgoals .
a preference is specied for each softgoal to indicate its relative importance .
goals can be re ned into subgoals through and or decomposition links until the leaves of the decomposition hierarchy as tasks that can be accomplished by either software or human agents.
to satisfy an and or decomposed goal all at least one of its subgoals must be satis ed.
furthermore goals can relate to each other through the weighted contribution links w and w where the normalized weight wis in the range of .
a or sign indicates respectively that the satisfaction of the source goal contributes tow level satisfaction or denial of the target goal.
the top part of figure presents the requirements goal model of a simpli ed online shopping system as a graph.
the system is used as a running example throughout the paper.
in this graph hard goals softgoals and tasks are syntactically shaped as rounded rectangles clouds and hexagons respectively.
the semantics of the model are illustrated as follows.
the goal order be strictly verified is satis ed if all of its and decomposed subgoals check info check credit and check fraud are satis ed.
the goal order be verified can be satis ed by any one of the two or decomposed subgoals order be simply verified and order be strictly verified .
.
architectural design decisions architectural design decisions manifest themselves in the system s architecture for assuring the satisfaction of the sys 677productsbesold orderbe verifiedand and t7check infoorand orderbestrictly verifiedt6pay order .
.
orderbe checkedout andproductbe chosen t1search productt4add tocart t2viewin multimediaandandand t5place orderand andsecurity behigh t9check fraudand risk belowcostbe lowand and t0log .
.
.
.8performance behigh loggingorder verification sequential parallelpayment protocol synchro nousasynch ronouspartialfullcheck responsebe quick .
.
.
.
.
.
.
.
orderbesimply verified t8check creditor andand .
.
strictstrict verification simplesimple verificationpayment responsebe quickresources below mm viewing mmtextualdetailsbe viewed t3view intextoror textual viewingusability begoodbrowse responsebe quick0.
.
.
.
andfigure requirements goal model and design decisions of a simpli ed online shopping system adaptedgoal specificationadaptationrequest modeltransformation scriptsrequirements goalmodelrequirements adaptationmanager requirementslayer architecturelayer design decisionsmodeldesigndecisions adaptationmanager architecture transformertransformation generatoradapteddesign solution running systemruntimearchitecture modeliruntimearchitecture modeli 1currentmodel adaptedmodel execution engineanalyzer engineadaptationrequest qualityexpectations contextvalues runtime datareconfigurationsplanner figure overview of our approach.
tem s quality and business requirements .
every decision has one issue describing the problem and some options describing the alternative solutions.
each option has some applicable contexts that have to be met for the option to be considered some pros and cons for the quality requirements to record its impact on them and some architectural modications to realize the solution in the architecture .
for instance to realize order payment in online shopping different message protocols such as asynchronous protocol or synchronous protocol can be used.
the former has a quicker response but needs more resources than the latter.
however due to its complexity asynchronous protocol is considered only when the message concurrency is high.
.
our approach after an overview of our approach figure this section introduces the adaptations of requirements and design decisions and the generated architecture transformations.
.
the overall framework following the mape k monitor analyze plan executeknowledge control loop our framework consists of an analyzer engine aplanner and an execution engine .
thiscontrol loop is periodically executed.
speci cally the analyzer engine aggregates quality values and context values based on the collected data during runtime monitoring.
using the aggregated and expected quality values it tunes the expectations of quality requirements through a feedback controller proposed in our earlier work .
expectations are used to indicate the expected satisfaction levels of quality requirements which are di erent under di erent situations and thus need to be tuned.
the expected quality values can be speci ed in advance or updated at runtime e.g.
by taking the average of the last nmonitored samples .
the design decisions adaptation manager searches for the optimal design solution as a set of design options that best satisfy a given set of requirements and contexts using the design decisions model.
if such a solution can be found thetransformation generator generates the model transformation scripts in qvt r that incrementally transform the current runtime architecture model into an adapted one through the architecture transformer .
on the other hand if such a solution cannot be found the requirements adaptation manager is responsible for selecting the optimal goal speci cation as a set of tasks that best meet the quality expectations.
no adaptation will be performed when no such goal speci cation can be found.
the execution engine recon gures the running system according to the di erences between the architecture models before and after adaptations.
these system recon gurations are currently supported by re ective component models such as fractal and opencom service oriented adaptation techniques such as ao4bpel and vxbpel or architecture based management middleware .
the steps of the self adaptation are illustrated as follows.
.analyzer engine periodically tunes quality expectations and aggregates context values and then raises an adaptation request to design decisions adaptation manager .design decisions adaptation manager tries to nd an optimal design solution based on the design decisions model .
if a solution can be found transformation generator generates the model transformation scripts and architecture transformer incrementally executes them on the current architecture model .
if no solution can be found an adaptation request is raised to requirements adaptation manager and then678it tries to nd an optimal goal speci cation based on the goal model .
if a speci cation can be found design decisions adaptation manager nds an optimal design solution that reects the changed requirements and triggers step .
if no speci cation can be found no adaptation is needed which means that the current goal speci cation and design solution are already optimal .execution engine recon gures the running system based on the di erences between the current and adapted architecture models.
depending on the di erent possible outcomes there can be three adaptation loops and corresponding to successful architectural adaptation successful requirements adaptation and no adaptation respectively.
although it is also possible to directly raise an adaptation request to requirements adaptation manager i.e.
which could have bypassed the architectural adaptation in step we do not choose that path because most of negrained adaptations could already be handled transparently to the xed requirements through architectural adaptation.
to apply our approach application speci c analyzer engine and execution engine are plugged in respectively to obtain quality values and context values and to achieve actual system recon gurations.
as an input three applicationspeci c models i.e.
a goal model a design decisions model and an initial architecture model are required.
.
requirements adaptations we use requirements goal models as the business abstraction of a running system.
goal models capture the space of alternative speci cations i.e.
a set of leaf level tasks satisfying high level goals in the form of or decompositions.
for instance there are possible goal speci cations for satisfyingproducts be sold in figure .
further each goal speci cation is often better in satisfying certain quality requirements but worse in satisfying some others.
for instance one possible goal speci cation gsis in figure and it is better in usability be good .
and risk be low .
but worse in browse response be quick .
and check response be quick .
.
the requirements adaptation manager focuses on businessdriven decisions and receives an adaptation request only if no design solution can be found.
if requested it will perform a goal reasoning process which takes as input the goal model and the tuned quality expectations and nds among all the possible goal speci cations the optimal one that best satis es the quality expectations.
traditionally the optimal goal speci cation is the one with the highest weighted sum of the satisfaction levels of all softgoals .
this strategy tries to achieve the overall quality satisfaction as high as possible.
as a result some poorlysatis ed softgoals will be hidden under the well satis ed ones and it is unknown if these hidden softgoals meet their expectations.
therefore here we adopt another strategy which tries to meet as many softgoals expectations as possible.
in detail we compute for each softgoal a satisfaction delta which is the di erence between its satisfaction level and its expectation.
a positive negative satisfaction delta means a softgoal does does not meet its expectation.
then indicates the negative positive satisfaction level calculated by label propagation algorithms design issuedesign option1.. architectural modificationintention softgoal .. dependency linkimpact linkmotivation link1.. .. .. hard goaltask interference link0.. .. context10.. figure metamodel of design decisions.
we compute for each goal speci cation a weighted sum of the negative satisfaction deltas i.e.
nscore and a weighted sum of the positive satisfaction deltas i.e.
pscore .
finally the goal speci cation with the highest nscore is the optimal one that best satis es the expectations if multiple goal speci cations have the same highest nscore one of them that has the highest pscore is the optimal one.
for instance if the expectations for browse response be quick usability be good check response be quick and risk be low are respectively .
.
.
and .
their satisfaction deltas with goal speci cation gsare respectively .
.
.
.
.
.
.
.
.
and .
.
.
.
if the preferences for all softgoals are speci ed to nscore is .
.
.
and pscore is .
.
.
.
given these quality preferences and expectations gsis actually the optimal goal speci cation which con gures the or decomposed goals i.e.
business driven decisions details be viewed and order be verified to view in multimedia and order be strictly verified .
in general of course our approach is independent of the choice of such strategies.
speci c strategies can be integrated according to speci c adaptation objectives.
.
design decisions adaptations we introduce an architectural design decisions model to capture system architectural design and its candidate solutions.
figure shows the metamodel of architectural design decisions we adopted.
for a design decision a design issue is related to certain requirements intentions which can be hard goals softgoals or tasks through motivation links to indicate its motivation i.e.
to solve what problem or to meet what requirements and has multiple design options for solving the problem or meeting the requirements.
multiple design issues can be motivated by multiple requirements.
in addition a design option has some applicable contexts for the option to be considered contributes to certain quality requirements softgoals positively or negatively by impact links and has some architectural modi cations to realize at the architectural level.
the bottom part of figure shows the design decisions of the simpli ed online shopping system.
design issues and options are visually shaped as octagons and ellipses respectively.
the issue logging i.e.
what interactions should be logged is to meet task log.
its option full i.e.
log all interactions has a higher positive impact to softgoal security be high but also a higher negative impact to softgoal performance be high than option partial i.e.
only log database interactions .
the issue payment protocol is to meet task pay order .
its options synchronous and asyn 679order verification sequential paralleltextual viewing textual fullmm viewing mmlogging partialasynchr onouspayment protocol synchro nous strict verification s strictssimple verification s simplesstrict verification p strictpsimple verification p simplep figure design decisions model of the simpli ed online shopping system.
chronous have reverse impacts to softgoals resources be lowand payment response be quick .
the applicable context of option asynchronous is when the request currency is larger than .
the issue order verification i.e.
what structure can be used to perform order information checking customer credit checking and fraud checking is to meet goal order be verified .
its options sequential and parallel have reverse impacts to softgoals cost be low and check response be quick .
furthermore design decisions are often intertwined and crosscutting with each other with respect to the decisionmaking process and architectural modi cation process.
to model such relationships we introduce dependency and interference links to relate design issues and options.
dependency links indicate that only if a set of design decisions are made together can the structure or behavior of certain part of a system be determined.
for instance issues order verification simple verification and strict verification have to work together to determine the behavior and structure of order veri cation.
interference links express the interferences among di erent design options when performing their architectural modi cations which will be introduced in section .
.
.
to represent such intertwined design decisions and facilitate their decision making process we model them in decision trees.
figure gives the design decisions model of the simpli ed online shopping system with each decision tree representing a set of intertwined design decisions.
subscripts are used to di erentiate the design options with the same name but di erent architectural modi cations under di erent decision making process.
for instance following the different options of order verification options strict sor strict pwill result in architectural modi cations that respectively structure the checking components to sequential or parallel processing.
for clarity we only show the dependency links lines with an arrow in figure and omit the motivation and contribution links that are shown in figure .
for the pairs of issues textual viewing andmm viewing and simple verification and strict verification only one of them will be considered in the decision making process because they are exclusive to each other from the requirements perspective.
hence figure shows the decision trees re ecting the goal speci cation gsby indicating the decisions that should not be considered by dashed lines.
through motivation and impact links the gap between requirements and architectural designs are narrowed.
on the one hand following motivation links requirements changes architecture model elementelement typeconnector typecomponent type component connector parameter interfaceprovided interfacerequired interfacestructure link1.. .. .. 1figure metamodel of component based architecture model.
i.e.
a new goal speci cation will in uence the set of design decisions that need consideration.
for instance if goal details be viewed is recon gured from view in text to view in multimedia issue textual viewing will not be considered while issue mm viewing should be considered.
on the other hand using impact links sourced from design options to quality requirements tuned quality expectations and monitored context values the design decisions adaptation manager nds among all design solutions the optimal one i.e.
a set of design options that meet their applicable contexts and have the highest nscore as introduced in section .
.
for instance given the goal speci cation gs if expectations for performance be high security be high resources be low payment response be quick cost be lowand check response be quick are respectively .
.
.
.
.
and .
preferences for them are all speci ed to and option asynchronous does not satisfy its applicable context then the optimal design solution ds is with nscore being .
and pscore being .
.
.
architecture transformations to realize the changes of design solutions into the architecture we propose a set of primitive adaptation operations to express the architectural modi cation of each design option and then introduce the incremental and generative model transformations to execute the architectural modi cations.
.
.
expressing architectural adaptations we use component based architecture models as the design abstraction of the running system.
figure gives the metamodel of architecture model we adopted.
components i.e.
computational elements and data stores and connectors i.e.
interactions between components are respectively instances of component andconnector types that express the common behaviors.
they have provided interfaces to specify the services they o er and or required interfaces to specify the services they need and can have parameters to express their changeable characteristics.
a linkis a connection from a required interface to a provided interface.
in addition this metamodel could be extended to include application speci c properties for components and connectors.
figure shows the component based architecture model of the simpli ed online shopping system manifesting the design solution ds.
components connectors provided and required interfaces are visually shaped as rectangles rounded rectangles solid and hollow circles respectively.
components logger are only connected to database related components product and order .
products details are viewed in multimedia mode through connector getproddetmm .
order payment is realized using synchronous protocol.
order veri 680ckinfoffckinfogetcart listgetcart listsetpaidsetpaidplaceor derplaceor deraddprod tocartaddprod tocartgetprod detmmgetprod detmmgetprod listgetprod listpayord ersynpayord ersynsearchp rodsearchp rodmain product cartsearch order credit checkfraud checksyn payment info checkckcreditckcredit ckfraudckfraudloggerloglog logger oglogfigure architecture model of the simpli ed online shopping system.
cation is performed in sequential structure.
and we extend components by including the property dbrelated to indicate whether or not a component is database related.
based on this metamodel we propose a set of primitive adaptation operations to express the architectural modi cation of each design option.
these primitive adaptation operations are parsed to generate model transformation scripts as will be shown in section .
.
.
these operations include create component connector id name type ... interface id name type parameter id name type value when component connector condition ?
create link id name interface interface when component connector condition ?
remove component connector link when condition tune parameter value when condition with and ?respectively indicate there is one or more zero or more and zero or one of the preceding element.
for component connector creation default properties e.g.
id extended properties e.g.
dbrelated its provided or required interfaces and its parameters should be speci ed.
for link creation properties such as id name required interface and provided interface should be speci ed.
these creation operations can also specify a crosscutting object either component or connector and a crosscutting condition to indicate that these operations are performed for every component or connector that satis es the condition.
removal operations should specify the satisfying condition of the to be removed component s connector s link s .
parameter tuning operation should speci ed the new value and the satisfying condition of the to be tuned parameter s .
the condition can be expressed by operators such as and on the properties of components connectors links or parameters.
besides composite conditions are also supported by using andand or.
with these operations complex architectural adaptations can be expressed by combinations.
we associate each design option with adaptation and revocation architectural modi cations.
the former indicates the modi cation e.g.
create a component when the option is selected and the latter indicates the modi cation e.g.
remove a component when the option is deselected.
for instance the adaptation architectural modi cation for design option full is shown as follows.
for every componentthat is neither a logger nor a database related component it rst creates a logger component a logger connector and two links to connect them.
create component logcomp logcomp logcompt false interface logintfl logintf provided when component type logcompt anddbrelated false create connector logconn logconn logconnt interface logintf r logintf required interface logintf p logintf provided when component type logcompt anddbrelated false create link loglinks loglinks null logintf p when component type logcompt anddbrelated false create link loglinkt loglinkt logintf r logintfl when component type logcompt anddbrelated false the property required interface of the rst link is set to null which should be the crosscut components required interface for logging.
however we cannot specify them here because there are multiple crosscut components.
to solve this problem we assume that one link s required and provided interfaces have the same interface name so that the architecture transformer will nd this interface in the crosscut components according to the interface name when performing model transformations.
besides its corresponding revocation architectural modi cation is shown as follows.
it removes the previously created components and connectors.
the previously created links will be automatically removed because their referenced interfaces are removed with the components and connectors.
remove component when name logcomp remove connector when name logconn .
.
executing architectural adaptations the architectural modi cations of design options may affect the same part of the architecture and thus produce interferences.
for instance if option full has been realized in the architecture and there happens a switch from option synchronous to option asynchronous the newly created component asyn payment will not be linked to a logger connector because option asynchronous is not aware of the architectural modi cation of option full and vice versa.
to compensate such interferences the revocation and adaptation architectural modi cation of full should be re performed sequentially.
therefore we introduce interference links to indicate such a relationship in order to facilitate the transformation process.
in the online shopping system there exist interference links sourced from synchronous asynchronous strict andsimple tofull.
these interference links can be manually constructed at design time by architects.
to ensure consistency save e orts and reduce errors we use model transformations to automate the modi cations of architecture models.
besides we use qvt r as the language for model transformations since it is expressive enough it is a standard de ned by object management group omg and it is the most widely used declarative language to specify the relation between two models.
furthermore we use mediniqvt to execute model transformations because it implements omg s qvt r standard.
speci cally the transformation generator is implemented by using the java template engine freemarker .
it takes as input a new design solution and returns a set of ordered qvt r scripts.
the generator rst makes a copy of the681top relation m2m varid varname string enforce domain source sm am architecturemodel id varid name varname enforce domain target tm am architecturemodel id varid name varname ... template of creating links if linklist??
linklist?size !
list linklist as link structure tlink link index am link parent tm id link.id name link.name interface1 tintf1 link index am requiredinterface id link.interface1.id interface2 tintf2 link index am providedinterface id link.interface2.id list if ... top relation m2m varid varname string enforce domain source sm am architecturemodel id varid name varname enforce domain target tm am architecturemodel id varid name varname ... structure tlink0 am link parent tm id payasynlinkt name payasynlinkt interface1 tintf10 am requiredinterface id payasynintf r interface2 tintf20 am providedinterface id payasynintfa ... a b figure a relation in qvt r a a template of creating links b a script of create a link.
old new design solution and avoids redundant architectural modi cations by removing their same design options satisfying condition cthat the design option is not the target of an interference link or is the target of an interference link but its source is not in the design solution.
this condition is to avoid the negative e ect of interference on model transformations.
then it has an iterative step to parse the revocation adaptation architectural modi cation of design options satisfying c in the old new design solution to generate a qvt r script based on a template and remove corresponding design options until all design options are removed.
finally it saves the new design solution to the old one.
for instance ds1 and ds2 are respectively the old and new design solutions.
first the options with a strike through line are the same options and thus are removed.
then the options with a straight underline are the rst set of options satisfying c. finally the options with a wave underline are the second set of options satisfying c. therefore two qvtr scripts are generated.
figure a shows a template of creating links in a relation that copies the idandname of an architecture model and figure b gives part of the rst generated script that adds a link between a connector and a component for asynchronous payment.
ds1 full synchronous textual sequential strict s ds2 the architecture transformer is implemented by using the model transformation tool mediniqvt .
it takes as input the generated qvt r scripts and the current architecture model and returns an adapted architecture model.
the scripts are executed incrementally in the order as they are generated the rst script is executed on the given architecture model and then the following scripts are executed on the transformed architecture model of the previous script.
vrfoffrde rparvrforde rpargetcart listgetcart listsetpaidsetpaidplaceor derplaceor deraddprod tocartaddprod tocartgetprod dettgetprod dettgetprod listgetprod listpayord erasynpayord erasynsearchp rodsearchp rodmain product cartsearch orderasyn payment credit checkinfo checkloggerloglog logger loglogfigure architecture model after adaptation the dashed rectangles indicate the modi cations .
for instance figure shows the architecture model after performing the adaptation loop on figure .
the requirements adaptations include switching from multimedia mode and strict veri cation to textual mode and simple veri cation and the architectural adaptations include changing synchronous payment and sequential veri cation to asynchronous payment and parallel veri cation.
.
case study to evaluate the proposed approach we conducted a case study to answer the following two questions q1 can improvements be achieved by combining requirements and architectural adaptations?
section .
q2 can the approach scale with the growth of requirements and architecture models?
section .
.
experimental setup stress testing tool jmeter was used to simulate concurrent accesses and badboy was used to record the test plan.
the experiments were conducted on a thinkpad e430c laptop with intel core i3 .
ghz processor and 4gb ram.
the experiments were conducted on the online shopping benchmark which is implemented in java.
its requirements and architectural design decisions are illustrated in figure and figure .
the preferences for the softgoals in figure were all speci ed to and the initial expectations for softgoals security be high performance be high usability be good browse response be quick cost be low risk be low check response be quick resources be low and payment response be quick were respectively set to .
.
.
.
.
.
.
.
and .
and such tradeo s have to be made because soft goals often cannot be all fully satis ed.
the system was initially con gured to the design solution full synchronous mm sequential strict s that best satis es these quality expectations.
the system workload varied in the experiments as follows to simulate dynamic environments.
the workload rst increased from zero users to concurrent users in minutes i.e.
adding a user every seconds then held for minutes nally decreased back to zero users in minutes i.e.
removing a user every seconds.
the adaptation interval was set to one minute i.e.
the adaptation mechanism was periodically performed every one minute which is enough for the adaptation process in this case study.
for other applications the interval should be accordingly speci ed.
in the experiments the quality values such as performance i.e.
the time taken to process a request browse response throughput min time min static req arch reqarch full partial partial full sequential parallel mm textual strict simple synchronous asynchronsous asynchronous synchronsous textual mm simple strict strict simple simple strict parallel sequential full partial partial full sequential parallel synchronous asynchronsous asynchronous synchronsous parallel sequential simple strict mm textual strict simple textual mm figure the adaptation process of the approaches with self adaptation.
payment response check response and cost i.e.
the money paid to verify an order were obtained by system log analysis and resources i.e.
the memory consumed to complete an order payment were measured by memory analysis.
however to measure security risk and usability it often involves complex security analysis risk analysis and customer feedback analysis.
to simulate such real life analysis for simplicity here we assumed that security was a random value between and with full logging and between and with partial logging since full logging can often achieve a higher security than partial logging.
similarly risk was a random value between and with strict veri cation and between and with simple veri cation and usability was a random value between and with multimedia mode and between and with textual mode.
such ranges of values were speci ed by the domain experts according to their experience.
for each of the following four approaches we conducted the experiments using the same experimental settings.
static the approach without self adaptation req the requirements driven self adaptation approach arch the architecture based self adaptation approach reqarch the proposed self adaptation approach speci cally req only involves the proposed requirements adaptations and architectural adaptations are simply mapped to architectural elements.
arch assumes a static goal speci cation and only involves the proposed architectural adaptations.
.
effectiveness evaluation q1 to compare the e ectiveness of di erent approaches we measured the system throughput i.e.
the successfully nished orders in one minute which is the key performance indicator of this application.
the higher the overall throughput the more e ective the adaptation is considered to be.
figure shows the adaptation process of the self adaptation approaches req arch andreqarch to visually illustrate the di erences of our approach from requirementsdriven and architecture based approaches.
in figure the xaxis denotes time intervals of one minute and the yaxis denotes system throughput in each time interval.
the adaptations generated by each approach are respectively marked on the curves.
forstatic it can be observed that the system su ered a throughput loss when the workload increased to concurrent users at time and continuously had a low throughputuntil the workload decreased to concurrent users at time .
this is because the system su ered performance degradation due to the increasing workload.
forreq the system also su ered a throughput loss at time when check response and browse response were very slow.
unlike static req increased the expectations of check response and browse response and thus recon guring the system from multimedia mode and strict order verication to textual mode and simple order veri cation for a better response.
as a result req achieved a higher throughput than static at the following time but risk and usability were low achieving and their expectations were increased.
when the workload decreased to concurrent users check response and browse response got better and their expectations were decreased.
as a result req recon gured the system to strict order veri cation and multimedia mode at time and .
forarch the system su ered a performance degradation at time which was not handled in the case of req since the solution was out of the business level adaptation space.
butarch recon gured the system from full logging to partial logging for a better performance at the price of security.
after a time interval arch recon gured the system back to full logging because security was now more expected than performance.
at time check response was very slow and arch increased its expectation and thus recon guring the system from sequential veri cation to parallel veri cation.
at time the applicable context of asynchronous payment was satis ed and the expectation of payment response was increased and thus arch recon gured the system to asynchronous payment.
when the workload decreased arch recon gured the system back to synchronous payment and sequential veri cation at time and .
it can be seen thatarch achieved a higher throughput than static but a lower throughput than req from time which means that in this case the solutions in the design level adaptation space is less e ective in terms of throughput than the ones in the business level adaptation space.
forreqarch when design level adaptation is not enough business level adaptation is involved e.g.
at time and .
as a result as visually shown in figure and numerically shown in figure reqarch achieved the highest maximum and average throughput.
this shows that by combining requirements and architectural adaptations our approach is promising to o er more adaptation exibility and further improve the e ectiveness of adaptation.683table average results of the four approaches in terms of quality values.
app.
sec.
per.
ms usa.
bre.
ms risk cost cre.
ms reso.
b pre.
ms static .
.
.
.
.
.
.
.
.
req .
.
.
.
.
.
.
.
.
arch .
.
.
.
.
.
.
.
.
reqarch .
.
.
.
.
.
.
.
.
static req arch reqarch max min avg throughput min figure throughput of the four approaches.
in addition table reports the average results of quality values per interval of the four approaches.
columns respectively list the results of security performance usability browse response risk cost check response resources and payment response.
it can be observed that compared with the other three approaches our approach was better in performance related quality dimensions but worse in others.
in other words with the changing workload our approach can achieve a better performance which is always expected under high workload to improve throughput with the acceptable sacri ce of other quality dimensions.
in summary the observations from table and figure and answer q1positively that our approach is promising to further improve the e ectiveness of adaptation in terms of system throughput in this case study and o er more adaptation exibility than requirements driven or architecturebased self adaptation approaches with acceptable sacri ce of less expected quality dimensions.
.
performance evaluation q2 the performance of our approach is determined by requirements adaptation manager design decisions adaptation manager transformation generator and architecture transformer whose time complexities are respectively exponential time with the size of or decomposed goals exponential time with the size of design decisions linear time with the size of primitive adaptation operations and linear time with the size of architecture model.
we conducted a set of experiments to evaluate the performance of our approach.
table reports the experiment results.
the rst third fth and seventh columns respectively list the size of or decomposed goals design decisions primitive adaptation operations and architecture model.
and the other columns list the performance in milliseconds.
the requirements adaptation manager takes around .
seconds on the goal model with or decomposed goals with goal speci cations which is feasible in our approach and returns an out of memory error when the number of or decomposed goals climbs to with goal speci cations .
the design decisions adaptation manager takes around .
seconds on the design decisions model withtable performance of our approach.
ram ddam tg at or p. ms dd p. ms op.
p. ms am p. ms out out design decisions with design solutions which is feasible in our approach and returns an out of memory error with design decisions with design solutions .
the transformation generator takes less than .
seconds with primitive adaptation operations and the architecture transformer takes around .
seconds with architectural elements.
the above analysis answers q2positively that our approach scales well with the growth of models and can be applied to real life medium sized software systems.
.
related work instead of enumerating the related work in the area of self adaptive systems we refer readers to and for an introduction to the state of the art.
here we only discuss the most related studies in three areas requirements driven selfadaptation architecture based self adaptation and earlier work that combines them.
.
requirements driven self adaptation approaches have been proposed to use requirements models as the knowledge for self adaptation.
dalpiaz et al.
propose a conceptual architecture that provides systems with self recon guration capabilities.
wang et al.
propose a requirements monitoring and diagnosing framework to provide systems with self repairing capabilities.
elkhodary et al.
propose a feature oriented self adaptation framework fusion that can learn the impact of adaptation decisions.
baresi et al.
present flags to facilitate requirementsdriven adaptations.
peng et al.
propose a requirementsdriven self tuning approach through dynamic quality tradeo and value based feedback loop.
chen et al.
propose requirements driven approaches for survivability assurance of web systems and optimization of composite services.
fu et al.
propose a stateful requirements monitoring approach for self repairing socio technical systems.
salehie et al.
propose a requirements driven approach to support adaptive security for protecting variable assets.
souza et al.
propose evolution requirements to de ne possible changes to the requirements which can be integrated into our approach to provide richer requirements adaptations.
these approaches assume requirements e.g.
goals or features can be mapped to architectural elements directly e.g.
components or services and thus largely neglect the com 684plexity and details in architectural design.
in contrast our approach introduces a design decisions model as intermediary and uses incremental and generative model transformations to implement more complex architectural adaptations.
.
architecture based self adaptation oreizy et al.
introduce the concept of architecturebased runtime software adaptation and evolution management.
garlan et al.
propose an architecture based selfadaptation framework rainbow which provides a reusable infrastructure customizable for speci c systems.
rainbow executes system speci c adaptation strategies written in stitch language after a violation of the invariant imposed by the architecture model.
floch et al.
propose a mobilityand adaptation enabling middleware madam which exploits architecture models for runtime adaptation of mobile computing applications.
georgas and taylor propose a policy based approach to architectural adaptation management and establish the feasibility to apply the approach to robotic architectures.
morin et al.
propose to use model level aspects to encapsulate variants and manage dynamic variability and weave the corresponding aspects of a selection of variants into a base model to produce a new architecture model.
these approaches assume that requirements of self adaptive systems are well understood at design time and unchanged at runtime thus are unable to support architectural adaptations resulting from requirements changes.
furthermore most of these approaches support simple architectural adaptations such as adding removing or replacing components but cannot support complex architectural adaptations such as crosscutting adaptations and restructuring architectural elements.
the exceptions are oreizy et al.
s restructuring garlan et al.
s strategy writing and morin et al.
s aspect weaving however these changes rely mostly on human experts.
compared with them our approach further supports complex architectural adaptations such as crosscutting and restructuring ones using model transformation techniques.
.
combining requirements and architectural evolution or adaptation nuseibeh proposes to weave requirements and architectures for incremental software development and speedy delivery.
sawyer et al.
call for combining requirements and architectures at runtime for self adaptive systems.
since then several advances have been made in this direction.
kramer and magee propose to combine requirements and architectures for self management and propose a three layer reference model a goal management layer for deliberative planning a change management layer for reactive plan execution and a component control layer for applicationspeci c adaptation actions.
as an instantiation sykes et al.
use a planning as model checking technique to generate plans construct component con gurations according to the planned actions and the interface dependencies among components and choose the best one by utility functions on quality properties .
their approach constructs a component con guration based on the functionality dependencies thus regarding the architectures as a set of functionalities neglecting the complexity of architectural design.
tajalli et al.
propose a plan based layered architecture for software model driven adaptation plasma whichutilizes an architecture description language and a planningas model checking technique to enable dynamic re planning.
it supports architectural adaptations resulting from requirements changes that are provided by architects at runtime.
alferez et al.
propose a model based framework that supports the dynamic evolution of context aware systems to deal with unexpected context events.
it uses goal and feature models to respectively represent the alternative space of requirements and architectures.
however it also focuses on the functionalities of the systems and assumes each feature can be directly mapped to an architectural element thus neglecting the complexity of architectural design.
pimentel et al.
propose the stream a approach a systematic process to generate architectural design models from requirements models for adaptive systems using model transformations.
their focus is on the design time development of adaptive systems whilst our approach focuses on the runtime self adaptation.
in brief the main di erences of our approach from these approaches are that it further treats architectures as a set of design decisions concerning how the functionalities are structured and interact with each other it supports both requirements and architectural planning and it addresses crosscutting and restructuring adaptations using model transformation techniques.
.
conclusions and future work in this paper we proposed a model based self adaptation approach that combines requirements and architectural adaptations.
it uses architectural design decisions models to consider not only the functionalities of architectures but also their structures and behaviors.
in addition it treats requirements and architectural adaptations in a layered manner and supports crosscutting and restructuring architectural adaptations using incremental and generative model transformations.
our case study using an online shopping benchmark shows promise that our approach can further improve the effectiveness of model based self adaptation approaches e.g.
system throughput in this case study and o er more adaptation exibility.
currently our approach does not support adaptations resulting from unanticipated changes e.g.
adding a new goal or a new design option.
a possible remedy is to provide explicit management interfaces for the administrators to update relevant models at runtime.
in addition the interference links in the design decisions model are created manually which could be di cult to understand and maintain for large systems.
it is our future work to automate the creation of these links.
we also plan to extend our approach by supporting widely used architecture description languages e.g.
xadl .
and supporting more model transformation tools e.g.
mmt integrate it with architecture based management middleware e.g.
sm rt and apply our approach to more software systems to further evaluate its e ectiveness.
.
acknowledgment this work is supported by national natural science foundation of china under grant no.
national high technology development program of china under grant no.
2013aa01a605 erc advanced grant asap and science foundation ireland grant ce i1855.
.