mining parametric specifications choonghwan lee feng chen grigore ro su department of computer science university of illinois at urbana champaign clee83 grosu illinois.edu abstract speci cations carrying formal parameters that are bound to concrete data at runtime can e ectively and elegantly capture multi object behaviors or protocols.
unfortunately parametric speci cations are not easy to formulate by nonexperts and consequently are rarely available.
this paper presents a general approach for mining parametric speci cations from program executions based on a strict separation of concerns a trace slicer rst extracts sets of independent interactions from parametric execution traces and the resulting non parametric trace slices are then passed to any conventional non parametric property learner.
the presented technique has been implemented in jminer which has been used to automatically mine many meaningful and non trivial parametric properties of openjdk .
.
introduction formal speci cations de ne behaviors that systems or parts of systems should obey.
a parametric speci cation is a formal speci cation that carries parameters that are bound to concrete object instances at runtime.
as an example figure shows a nite state automaton fsa that describes a parametric speci cation involving two java classes collection and iterator .
each edge represents an event such as calling a method.hinitirepresents calling the constructor of collection and update calling a method that changes the contents of the collection object speci ed as a parameter c add remove and clearcan be such methods.
iterator represents creating an iteratorobject for a collection object and has two parameters the underlying collection object and the created iterator object.
hasnext and nextrepresent invocations on methods hasnext and nextofiterator respectively.
the nextmethod returns the next element in the iteration and the hasnext method checks if the iteration has more elements i.e.
hasnext checks if next is safe .
the speci cation in figure states the following safety property if an iterator iis created for a collection c the contents of cshould not be changed while iis being used indeed once the fsa enters state no method calls of the .
next i hasnext i init c iterator c i update c hasnext i update c figure collection iterator protocol mined with jminer.
iterator are allowed state does not accept hasnext ornext .
a violation of this property results in a runtime exception.
figure also shows a typical usage pattern of iterator every call to nextis usually guarded by a call to hasnext .
the use of parameters is crucial in order to properly distinguish among di erent object interactions.
indeed if one omits the parameters of the speci cation in figure then one would wrongly report a protocol violation when e.g.
two consecutive nextcalls are observed on two distinct iterators.
current parametric speci cation monitoring approaches maintain a clean separation between di erent object interactions each interaction being observed by a distinct monitor if an event is relevant to several monitors e.g.
an update event of a collection cwhich is relevant to all iteratorsioverc then that event is dispatched to all interested monitors .
this way monitors are not perturbed by irrelevant events or by unfortunate interaction interleavings.
the major objective of this paper is to present a technique that achieves the same degree of separation between di erent object interactions but for mining instead of monitoring.
numerous speci cation mining approaches have been proposed e.g.
among others.
parametric speci cations are much more challenging to mine than non parametric ones mainly due to the complexity of handling parameters.
indeed as discussed in section none of the existing approaches provides a satisfactory solution for mining parametric speci cations in their full generality and invulnerability to unfortunate interaction interleaving.
for example none of the approaches that we are aware of is able to mine the speci cation in figure in the presence of arbitrary interaction interleavings.
contributions.
in this paper we present an e ective and generic dynamic approach for mining parametric speci cations.
we strongly separate the tasks of parameter handling and of speci cation learning which has two major bene ts parameter handling makes no assumption on the types of speci cations to mine resulting in a generic parametric mining framework and learning is not a ected by parameters or perturbed by interaction interleavings reducing theevent specification learner source code package name unit test case trace slicer execution trace event specification stage i mine event specification stage ii mine parametric specification jminer architecture specification learner parametric specification trace slice trace slice trace slice execution trace execution trace figure mining parametric speci cations.
e ort to re use existing algorithms or to develop new ones and increasing the overall precision of mining.
the presented approach has been implemented in and extensively evaluated with jminer .
the major tasks performed by jminer are instrument the observed program to emit parametric events of interest at runtime run the instrumented program and collect a parametric execution trace slice the parametric trace into a set of independent object interactions called trace slices pass the resulting trace slices to any learner nally put everything together into one or more parametric speci cations.
when used on packages that provide unit tests jminer provides a completely automated parametric speci cation mining solution building upon the hypothesis that unit tests are devised to stress interactions among objects and methods that are likely to obey some protocol jminer learns the events of interest by rst running and observing the existing unit tests.
this worked well in practice and indeed jminer has been used to automatically mine many properties of openjdk6 like the one in figure .
the rest of this paper is organized as follows.
section highlights our overall approach to mining parametric speci cations.
section explains our novel trace slicing technique.
section describes the other parts of our framework in detail.
section discusses experiments and limitations.
section discusses related work.
section concludes.
.
approach overview here we give a high level overview of our mining approach.
definition .
event speci cation we write methodsasm tt tr tp1 tpn wheremis the method name ttis the receiver type tris the return type and tp1 tpn are the types of its parameters for uniformity we call each oftt tr tp1 tpnamethod parameter .
ifmis a set of methods let xmbe all the method parameters of reference type for all methods in m. an event speci cation is a pairhm xi wheremis a set of methods and x xm.
for example consider a set of methods m fiterator.hasnext iterator boolean iterator.next iterator object collection.iterator collection iterator g. then xm fcollection iterator objectg because boolean is not a reference type.
hm xmiforms an1.
arraylist.add arraylist .
abstractlist.iterator arraylist abstractlist itr .
abstractlist itr.hasnext abstractlist itr .
abstractlist itr.next abstractlist itr .
abstractlist itr.hasnext abstractlist itr .
abstractlist.iterator arraylist abstractlist itr .
abstractlist itr.hasnext abstractlist itr .
abstractlist itr.next abstractlist itr .
abstractlist itr.next abstractlist itr figure fragment of an execution trace.
event speci cation but one may prefer event speci cation hm xi wherexdrops object fromxm.
an event speci cation de nes a set of related methods and their parameters that would likely form a useful parametric speci cation.
parametric speci cations are speci cations adding parameters to properties speci ed using any non parametric trace formalism .
here we only consider regular patterns denable through fsa we only used fsa learners so far.
definition .aparametric speci cation is a tuple s m x s f wherehm xiis an event speci cation and s m s f is an fsa where sis the set of states s02sis the initial state is the transition partial function and f sis the set of nal states.
figure shows one such parametric speci cation.
as a notational convenience we write methods in mwith their parameters in x and drop the other parameters in xm x .
our parametric speci cation mining approach consists of two stages also giving the architecture of jminer as depicted in figure event speci cation learning section .
and parametric speci cation mining sections and .
.
the former yields a set of event speci cations.
the latter mines a parametric speci cation for each event speci cation.
providing precise event speci cations is inconvenient since it requires expert knowledge about the target software.
a set of overly diverse methods would result in a too complex speci cation likely to be application speci c while a set of too few methods would result in a too simple speci cation covering only part of the usage pattern.
our approach is to automatically learn event speci cations from unit tests when available based on the hypothesis that unit tests check the behavior of tightly interacting objects and thus the methods involved in such interactions likely obey some speci cation.
the parametric speci cation mining stage takes an event speci cation and various program execution traces as input and yields a parametric speci cation as output.
to obtain program execution traces we wrote a java virtual machine tool interface jvmti agent that logs information about the invoked methods and their arguments and attached it to the jvm.
jvmti provides a convenient means to access the call stack and to uniquely identify objects.
our jvmti agent records all method invocations from all threads in chronological order so that interactions that span over multiple threads can be recognized.
the events and parameters which are not relevant for the given event speci cation are then ltered out.
figure shows a resulting execution trace fragment when the event speci cation ishfcollection.add collection.iterator iterator.hasnext iterator.nextg fcollection iteratorgi.
each line corresponds to a method invocation and contains a method name together with the paired actual type and object identi er for each method parameter.
note that our execution trace ltering takes into account java s implicit upcasting.
for example arraylist.add is not ltered out because the method addis de ned by arraylist s superclass collection and is included in the event speci cation.
as explained in section the event parameters in ex ecution traces play a crucial role.
indeed if one dropped the parameters then one would see just one large and likely unreal and thus unsuitable for mining interaction that interleaves many di erent object interactions.
for example in the trace in figure events and are unrelated since their iterator objects are di erent.
however a speci cation learner making abstraction of parameters would infer a faulty speci cation allowing two consecutive nexts.
to infer accurate speci cations no matter how interactions interleave independent interactions need to be considered separately.
to this end our approach introduces trace slicing .
informally an interaction is a series of events that manipulate a set of objects.
for example two interactions exist in figure events and on harraylist abstract list 119i and events and on harraylist abstract list 131i.
our trace slicer identi es such interactions and passes them separately to the speci cation learner.
a speci cation learner nally infers a parametric specication from the set of separate interactions.
the learner need not be aware of parameters and consequently one can reuse existing learners and or easily develop new ones.
if an fsa learner is employed it would infer the pattern of alternation between hasnext and nextfrom the above two separate interactions.
the inferred fsa is nally annotated with parameters which produces a parametric speci cation.
.
slicing traces in this section we rst de ne trace slicing a process that dispatches events in the given execution trace to trace slices corresponding to di erent parameter bindings according to the given event speci cation.
we then introduce the concept of complete and connected parameter instances in order to remove trace slices that are meaningless and thus can generate noise in the process of mining speci cations.
we show that a parametric trace can comprise in the worstcase scenario exponentially many trace slices corresponding to complete and connected parameter instances .
.
parametric trace slicing our terminology used in this section is borrowed from .
definition .letebe a set of non parametric events called base events or simply events .
ane trace ortrace is a nite sequence of events in e i.e.
an element in e .
we writee2wwhen event e2e appears in trace w2e .
let and denote the sets of total and respectively partial functions from atob.
what follows extends the de nition above to parametric events and traces.
definition .
parametric events and traces letx be a set of parameters and letvxbe a set of corresponding parameter values .
ifeis a set of base events def.
then letehxidenote the set of corresponding parametric events eh i whereeis a base event in eand is a partial function in .
let dom befx2xj x de nedgand?
be the map unde ned everywhere i.e.
dom ?
.
partial maps in may also be called parameter instances orparameter bindings .
aparametric trace is a trace with events in ehxi that is a word in ehxi .
in figure e fadd iterator hasnext nextg x fcollection iteratorgandvx f158 .
.
.g.
in the parametric trace shown in figure addandharraylist 158iare the base event and resp.
the parameter binding of the rst parametric event.definition .we say that 0isless informative than written 0v i for any x2x if x is de ned then x is also de ned and x x .
for example harraylist 158ivh arraylist abstract list 119i.
definition .
trace slicing given parametric trace 2ehxi and partial function inx let the trace slice of be the non parametric trace in e de ned as follows where is the empty trace word and eh 0i ewhen 0v when 06v a trace slice rst lters out all the parametric events that are irrelevant to the parameter instance .
for example when the given parameter instance is harraylist abstract list 119iin figure the resulting trace slice does not contain the sixth event.
similarly events and are also ltered out.
event which binds only arraylist is added to the trace slice corresponding to harraylist abstract list 119i becauseharraylist 158ivh arraylist abstract list 119i.
a trace slice also forgets the parameter bindings of parametric events.
as a result a trace slice is non parametric and merely a list of base events.
for example the trace slice corresponding to harraylist abstract list 119iis add iterator hasnext next hasnext next .
dropping parameter information enables the parametric speci cation mining stage to use any learners as long as they take as input a set of strings where a string is a list of base events.
although the intuition is clear developing e cient and correct trace slicing algorithms is non trivial.
first traversing the trace more than once is undesirable due to e ciency concerns.
second an event may contain an incomplete binding of the given set of parameters.
for example for the trace in figure if we choose fcollection iteratorgas the set of parameters an addevent contains only a collection parameter leaving the iterator parameter unbound.
furthermore an event may belong to multiple trace slices because its parameter instance can be less informative than many other parameter instances introduced by the trace.
for example if the trace in figure contained another event iterator arraylist abstractlist list the rst event would also belong to the trace slice of harraylist abstract list 219i.
.
complete and connected instances since a trace slice corresponds to a parameter instance selecting an appropriate set of parameter instances is crucial in order to prevent meaningless trace slices such trace slices may result in learning inaccurate speci cations .
to select only appropriate parameter instances we use two criteria completeness and connectedness.
a parameter instance is complete ifdom x wherex is the set of parameters in the given event speci cation.
incomplete parameter instances are considered inappropriate and trace slices corresponding to those parameter instances are suppressed i.e.
is suppressed if dom x. for example if x fcollection iteratorgin figure the trace slice corresponding to habstract list 119iis suppressed.
the trace slice for this incomplete parameter instance is indeed meaningless because it does not represent an interaction between a collection and an iterator.
for some cases no event provides a complete parameter instance.
one such example is illustrated in figure when x fsocket socketinputstream socketoutputstream g. the rst1.
socket.
init socket .
socket.getinputstream socket socketinputstream .
socket.getoutputstream socket socketoutputstream .
socketinputstream.read socketinputstream .
socket.getoutputstream socket socketoutputstream figure part of an execution trace used for mining the speci cation in figure .
four events are part of one interaction hsocket socketinputstream socketoutputstream 288i but there is no event that provides the complete parameter instance.
parameter instances from multiple events therefore need to be combined.
definition .two parameter instances and 0arecompatible i for anyx2dom dom x x .
we cancombine compatible instances and written t t x x when x is de ned x when x is de ned unde ned otherwise for example hsocket socketinputstream 227iis compatible withhsocket socketoutputstream 288ibut is not compatible withhsocket socketoutputstream 588i.
two parameter instances disagreeing on any parameter are incompatible and thus cannot be combined.
hsocket socketinputstream 227i thsocket socketoutputstream 288iishsocket socketinputstream socketoutputstream 288i obtaining a complete instance when x fsocket socketinputstream socketoutputstream g. combining multiple parameter instances is therefore necessary for achieving a complete parameter instance.
however if done blindly it may introduce spurious parameter instances.
for example hsocket socketinputstream socketoutputstream 588i obtained by combining hsocket socketoutputstream 588iandhsocketinputstream 227iin figure is spurious because an interaction involving all three objects does not exist in the given trace.
trace slices corresponding to spurious parameter instances represent non existing interactions and consequently become noise.
to lter out spurious parameter instances we introduce the concept of connected parameter instances.
definition .if 2ehxi we de ne connectedness of parameter instances as follows if eh i2 then is connected and if 2are connected compatible and 1u ?
then 1t 2is also connected.
therefore a parameter instance is connected i it is formed by combining parameter instances of events in that share parameter bindings.
for example hsocket socketinputstream socketoutputstream 288iis connected in figure because of events and but hsocket socketinputstream socketoutputstream 588iis not.
in cases where there is no ambiguity we will say connected instead of connected.
connectedness is motivated by the following observation in most cases we are interested in mining speci cations for a set of interacting objects if two objects appear in the same event then they interact with each other.
therefore all the objects contained in a connected parameter instance directly or indirectly interact with one another.
experiments using our technique discussed in section show that passing only the trace slices corresponding to connected parameter instances to the speci cation learner and discarding the other trace slices e ectively removes noise in the mining process resulting in accurate speci cations.
computing all possible connected parameter instances is hard.
one should not mistakenly think that this problem reduces to computing the ordinary connected components p p0 q q0 q q0 r r1 q q0 r r2 r r1 s s0 conflict on r figure a graph showing that connectedness in a graph does not indicate connectedness.
of a graph where a vertex represents a parameter instance and an edge exists i the two associated parameter instances 1and are compatible and 1u ?.
figure shows one such graph.
p q rand sare parameters and p0 q0 r1 r2ands0are parameter values.
the graph connected component in figure correctly suggests that hp p0 q q0it hq q0 r r1ith r r1 s s0iis connected.
however it also suggests thathp p0 q q0ith q q0 r r2ith r r1 s s0iis connected which is wrong.
indeed computing the graphconnected components does not take into consideration the compatibility between parameter instances while computing the connected parameter instances must.
for example hq q0 r r1iandhq q0 r r2iare incompatible but the standard graph connected component fails to recognize it.
.
complexity of trace slicing in what follows we calculate the worst case complexity of the trace slicing problem in terms of the number of trace slices as a function of the total length nof the original parametric trace and the size of x the set of parameters.
more precisely we show that there are approximately1 n m mtrace slices in the worst case when m wherem is the size of x. note that ifjxj then we have at most ntrace slices and they are easy to compute.
however if jxj n then we have 2n 2trace slices showing that the addition of conicting edges like in figure makes the graph connected component problem harder.
the maximum of n m mis actually reached when m n e in which case it becomes en e. suppose that x fp0 p1 .
.
.
pmgfor somem and that e1h 1ie2h 2i enh ni.
the worst case is when any two events have at least one common parameter value so that u ?for any two parameter instances and such thateh i e0h 0i2 we can achieve that with minimal resources by designating a parameter instance hp0 p0iand assuming that that is common to all events.
each event may be in con ict with a certain number of other events.
for example suppose that e1h 1iis in con ict with a1 events on parameter p1 wherea1 .
the other a1 events are also in con ict with each other so we have a cluster of a1 events which are in con ict with each other on parameter p1.
the worst case is when the con icting a1events are in con ict with no other event and when for each trace slice corresponding to the remaining events each of them yields a new trace slice.
thus assuming that the remaining events generatestrace slices we have a1 sslices in total.
we can iterate the argument above and obtain a1 a2 am trace slices when we split the nevents of into clusters ofa1 a2 amevents with a1 a2 am n each cluster containing those events con icting on precisely one of the parameters p1 p2 .
.
.
pm respectively.
note that this is not only an over approximation.
it can actually happen as shown in figure .
the product is maximized when a1 1we do an approximate analysis making abstraction of the fact thatmmay not divide n etc.
p0 p0 p1 p1 p0 p0 p1 p1 p0 p0 p1 p1 a1 cluster of a1 p0 p0 p2 p2 a2 p0 p0 p2 p2 p0 p0 p2 p2 cluster of a2 p0 p0 pm pm p0 p0 pm pm p0 p0 pm pm am cluster of am figure clusters of a1 a2 amevents.
a2 am n m in which case it becomes n m m. therefore assuming that xis xed a priori as it is usually the case we can only have a polynomial in the length of the original parametric trace number of trace slices.
if xis not xed then one can actually fabricate an absolute worst case scenario which maximizes n m m. this case occurs whenm n e in which case the number of trace slices is exponential en e. although it is little likely in practice that the size of xis co related to the length of the trace it is instructive to have a clear understanding of the worst case complexity of the problem that we are attempting to solve.
.
slicing algorithm as discussed in section .
the number of trace slices is n m min the worst case.
since all trace slices can be distinct this number gives a lower bound for all trace slicing algorithms.
this lower bound is hard to achieve though since computing complete and connected parameter instances may require several operations of instance combination.
for example hp0 p0 p1 p1 p2 p2 .
.
.
pm pm 1iin figure can be obtained only after at least minstance combination operations hp0 p0 p1 p1 1ith p0 p0 p2 p2 1i thp0 p0 p3 p3 1i t. .
.thp0 p0 pm pm 1i .
furthermore a trace slicing algorithm needs to search for compatible parameter instances in order to create combined parameter instances.
our trace slicing algorithm in figure called slicer traverses the given trace only once and avoids the construction of meaningless trace slices.
slicer has two stages it rst processes the entire parametric trace event by event constructing intermediate results and then it constructs the set of trace slices each corresponding to a complete and connected parameter instance.
during the rst stage slicer stores in intermediate trace slices only for parameter instances that actually occur in observed events.
neither combined parameter instances nor trace slices for them are created at this stage.
the second stage constructconnected constructs holding all possible connected parameter instances by combining compatible parameter instances in the loop at lines .
for each complete and connected parameter instance its corresponding trace slice is nally constructed at lines .
collects all intermediate trace slices corresponding to s subinstances.
mergetraces is essentially the merge function of merge sort using the position of events in the trace for comparison events in trace slices are listed chronologically .
theorem .after running slicer on 2ehxi .
is de ned i is connected and dom x. .
if is de ned then .
this theorem tells all trace slices can be retrieved from .
we next analyze the complexity of slicer .
it rst calls handleevent ntimes and assuming that a self balancinginput x e1h 1ie2h 2i enh ni output e global e function slice fori 1tondohandleevent eih ii constructconnected function handleevent eh i if unde ned then e function constructconnected f j is de nedg while9 compatible 1u ?
1t do f 1t 2g foreach s.t.dom xdo f j 0v and is de nedg mergetraces figure slicer trace slicing algorithm.
binary search tree is used for the complexity of handleevent iso logn .
the loop at lines in constructconnected can pick 1and 2from and each iteration takes o m time for checking the compatibility and combining the two parameter instances.
there are j jiterations of the loop at lines with each iteration taking o m time.
the running time of the entire algorithm is thuso nlogn j j2 m j j m o nlogn j j2 m .
since the algorithm creates all possible connected parameter instances j jcan be calculated as follows the number of connected parameters with jdom j i is m i n m i because we can choose iparameters and there aren mparameter values for each parameter.
thus we have j j pm i m i n m i n m m and the time complexity of slicer iso nlogn n m 2m m o n m 2m m .
as for the space complexity it needs to maintain o j j connected parameter instances of length o m during trace slicing.
it also needs space for n m mtrace slices of size m as illustrated in figure .
therefore the space complexity iso n m m m n m m m o n m m m .
slicer iterates through all possible connected parameter instances in the loop at lines in constructconnected .
in our experiments this step was comparatively the most expensive wrt performance so we have investigated several possibilities to optimize it.
we next describe two of our optimizations which bring considerable performance bene ts.
instead of blindly picking a pair of parameter instances from and combining them our implementation proceeds in a bottom up manner.
at the rst step it picks two parameter instances 1and such that jdom j jdom j n and creates 1t if necessary.
after handling all parameter instances with nparameter bindings it picks parameter instances with n parameter bindings and so on and so forth until nreaches the size of x the set of parameters.
this way a parameter instance is considered for compatibility within only a limited window reducing the number of iterations.
our second optimization is to group parameter instances so that all parameter instances in the same group bind exactly the same parameters.
grouping also reduces the number of iterations at lines in constructconnected .
for example ifhp p1 q q1iis chosen as all parameter instances that belong to the group corresponding to fr sgwill be excluded from the list of candidates for 2because any parameter instance in this group would result in 1u ?.
.
learning in jminer here we discuss how the trace slicing technique in section is incorporated within our jminer parametric mining approach by means of discussing jminer s event specication learner from unit tests as well as its speci cation learner based on a re nement of the o the shelf pfsa .
.
learning event specifications the event speci cation learner dynamically infers a set of event speci cations from the target software.
it takes as input the source code a target package name and unit tests all for the target software .
providing these inputs is easy and requires no expert knowledge.
for example in order to mine speci cations in the java.util package of openjdk what the user needs to provide is the source code of openjdk the target package name java.util and the unit tests forjava.util .
here is e.g.
a typical unit test in openjdk .
import java.util.
.
public class checkforcomodification .
private static final int length .
public static void main string args throws exception .
list integer list new arraylist integer .
for int i i length i list.add i .
try for int i list .
if i length list.remove i .
catch concurrentmodificationexception e return .
throw new runtimeexception .
no concurrentmodificationexception .
this unit test case is written to test if a concurrent modication of a collection object is detected and a runtime exception is raised.
as the java compiler translates the for each loop at lines into arraylist.iterator abstractlist itr.hasnext and abstractlist itr.next an execution of this test case will reveal an interaction between arraylist and abstractlist itr .
an advantage of using unit tests for learning event specications is that tightly interacting objects are well isolated.
for example the unit test case above considers only one issue namely detecting a concurrent modi cation.
this isolation avoids tangential relationships among issues which are usually application speci c and thus not likely to obey a generic speci cation.
for example an interaction on a filereader object and an interaction on a filewriter object can be related in an application through a fileobject because both filereader and filewriter objects can be constructed with the same fileobject.
although somewhat related it is expected that reading and writing are two separate issues and thus speci cations involving both are unnecessary.
such tangential relationships rarely occur in unit tests.
moreover users can obtain unit tests for free as many software packages are shipped with them.
unit tests are well maintained as they are frequently run and failed cases are promptly addressed.
learning related methods and parameters.
we rst trace unit test executions using a jvmti agent like the one in section but one which also logs the thread identi er and the depth of the call stack in front of each event each thread has its stack and every method invocation is logged .
here is e.g.
part of the trace logged by the unit test above .
arraylist.
init arraylist .
arraylist.add arraylist integer .
arraylist.ensurecapacity arraylist .
abstractlist.iterator arraylist abstractlist itr .
abstractlist itr.hasnext abstractlist itr .
arraylist.size arraylist .
abstractlist itr.next abstractlist itr integer one can infer that addinvoked ensurecapacity andhiniti add iterator hasnext and nextwere invoked in order by the same method not shown here since they have the same thread identi er and depth of the call stack.
hinitiis a special name reserved for constructors.
although an execution trace from a unit test case usually contains relatively few events it may still be too large to precisely infer related methods.
we next analyze the execution trace in order to remove irrelevant events.
many heuristics are possible here we prefer to use two heuristics which were also used in and appear to work well keep only events corresponding to methods which are de ned in the user speci ed target package and which are directly invoked by methods of the class that declares the main entry of a test case.
our rationale for using these heuristics is that unit tests are rarely written for interactions among multiple packages and that a unit test consists of one core class for performing the actual test and other utility classes for supporting the core class.
all the relevant events are then partitioned into groups of related events.
two events are directly related i they share at least one common argument and related i they are connected through a sequence of directly related events.
for example hiniti event and add event are directly related due to arraylist andhiniti event and next event are related through iterator event .
an event speci cation is then created for each partition.
for each object used as a receiver in a partition its type is generalized to the least speci c type that speci es all methods involving that object.
then the least speci c type and all the involved methods after their declaring types are generalized to the least speci c types are added as a parameter and respectively methods.
for the trace above e.g.
a partition including abstractlist and abstractlist itr is rst generated.
then abstractlist is generalized to abstractlist because abstractlist speci es all involved methods.
as a result a parameter abstractlist and the generalized methods abstractlist.hiniti abstractlist.add and abstractlist.iterator are added.
similarly abstractlist itr adds a parameter iterator and two methods iterator.hasnext and iterator.next .
these two parameters and ve methods form an event speci cation.
filtering out generics parameters.
generics may yield undesirable event speci cations.
consider for example the following execution trace locale is a generic type .
arraylist.
init arraylist .
arraylist.add arraylist locale .
abstractlist.iterator arraylist abstractlist itr .
abstractlist itr.hasnext abstractlist itr .
abstractlist itr.next abstractlist itr locale .
arraylist.
init arraylist .
arraylist.add arraylist locale the above event speci cation learner would identify hasnext next hiniti add events and as the interaction on harraylist abstractlist itr locale 57i arraylist and abstractlist itr are subclasses of abstractlist and iterator respectively .
this interaction is spurious as it is about conceptually unrelated objects arraylist and abstractlist itr abstractlist itr is an iterator for arraylist which happen to be related due to locale .
the above spurious interaction is caused by the fact that abstractlist.add and iterator.hasnext bring locale to the event speci cation.
a general way to prevent this problem is to recognize parameters of generic types and avoid adding them to the event speci cation.
the rationale is that the instantiated types were unknown at the time the generic class was written and consequently they should be kept separate.hasnext next iterator hasnext update update init update hasnext figure fsa inferred by the pfsa learner.
to detect parameters of generic types jminer reads the generic signature which tells the parameters of generic type for each method using jvmti.
above it detects that the parameter of abstractlist.add and the return type of iterator.next are generic and thus it does not add locale to the event speci cation.
then locale can be ignored and the trace slicer will not recognize the spurious interaction.
.
learning parametric specifications jminer takes the event speci cations learned from unit tests as explained above and passes them to its core component the trace slicer.
as discussed in sections and the trace slicer takes an event speci cation and an execution trace produced by a program that exercises the target package and produces a set of trace slices each corresponding to an observed interaction.
the generated trace slices are then passed to any non parametric speci cation learner.
we included one such speci cation learner in jminer which we discuss below.
our learner consists of two components an o the shelf pfsa learner and an fsa re ner.
pfsa learner.
a pfsa is an fsa where each transition is labelled with how often the transition occurs.
a pfsa learner takes a set of strings as input and infers a pfsa.
several pfsa learning approaches have been proposed we here adopt the sk strings algorithm since it performs well at inferring small fsas.
it rst constructs an fsa that precisely accepts the input set of strings.
each transition is then annotated with a frequency saying how many times that transition was observed.
the sk strings algorithm then generalizes by merging states which are sk equivalent two states are sk equivalent i corresponding sets of bounded strings ones that are frequently generated from each of the two states are matched.
as a result of this approximation two states can be merged even when they are not strictly equivalent making it possible for the inferred fsa to accept not only the input strings but also other similar strings.
the reader is referred to for more details.
after running the sk strings algorithm the learner drops the frequency information yielding an ordinary fsa.
figure shows the fsa inferred by the sk strings algorithm for our collection iterator example figure shows the desired speci cation .
fsa re ner.
although pfsa learner s approximations are generally desirable in many application domains the resulting fsas turned out to often be overly general in our domain of mining speci cations from execution traces in that the mined fsas accept a large number of undesirable traces.
for example the trace hiniti iterator hasnext next iterator hasnext is accepted by the fsa in figure but it is impossible to occur in any program execution only one iteratorevent can be observed in any interaction between a collection and an iterator .
to prevent over generalized speci cations our speci cation learner implemented in jminer re nes the fsa inferred by the sk strings algorithm.
next iterator update update update update update next init hasnext hasnext figure expanded fsa of figure .
the overall goal of our re ner is to eliminate transitions caused by over generalization while keeping desirably generalized transitions.
an obvious step for avoiding over generalization is to remove all the transitions that are never taken by any of the trace slices provided as the input of the speci cation learner.
for example the iterator transition from state to state in figure is never taken the same iterator object cannot be created twice so it can be safely removed.
however that is not enough the resulting fsa still accepts infeasible interactions containing multiple iterator s e.g.
hiniti iterator hasnext update iterator hasnext .
the fundamental problem is that pfsa learners do not take the context into account when merging states while the context is important in programming languages.
for example the two transitions from states and to state in figure were obtained by the pfsa learner by merging two contextually di erent states.
modifying a pfsa learner to take the context into account seems hard.
instead our approach is to reverse engineer the fsa generated by the psfa learner to partly take the context into account.
more precisely our re ner rst expands the inferred fsa as follows if a state shasnincoming edges from the other states thensis replaced by ncorresponding states s1 s2 sn in order to di erentiate the originating state.
figure shows the expanded fsa of the one in figure .
states 2and indicate that an iterator has been already used whereas state 1indicates that no iterators have been used.
using the expanded fsa the re ner removes all the transitions that are never taken by the given trace slices i.e.
caused by over generalization in our case !
!
and !
.
then the re ner nally eliminates the states with no incoming transitions and merges states that have the same outgoing transitions.
for example state 2is eliminated and states 13and states 32are merged respectively.
the resulting fsa for the one in figure is shown in figure .
the reader is referred to for more details.
.
ev aluation of jminer we applied jminer to mining speci cations in four packages of openjdk java.util java.io java.lang and java.net .
openjdk contains various unit tests and is well documented allowing us to validate the mined speci cations.
selecting unit tests of a speci c package for event speci cation learning is easy because the unit tests are well structured.
we used execution traces obtained from the dacapo bench target event speci cations parametric speci cations package les events les events java.util java.io java.lang java.net table traces used in the experiments.
target event speci cations parametric speci cations package slicing learning java.io java.lang java.net java.util table times minutes windows 3ghz 1gb .
mark suite .
and the apache james server .
.
as training sets for speci cation mining.
dacapo contains programs and provides a harness to execute each program and validate an execution.
we used dacapo for mining speci cations in java.util java.io and java.lang and apache james which contains several test cases for whole system checking for mining speci cations in java.net .
table shows information on the traces used in our experiments.
two kinds of traces were used traces for learning event speci cations and traces for mining parametric speci cations.
we limited the execution time for each program in dacapo to one hour.
the event speci cation learning stage automatically inferred event speci cations.
jminer has an aggressive lter which automatically discards most of the learned event speci cations though the user can manually intervene and save or adjust any event speci cation .
the lter rst deletes methods that can be called anytime such as getters returning primitive types tostring and hashcode and thus are likely not involved in protocols and then removes all event speci cations having only one non constructor method these lead to obvious patterns .
only di erent event speci cations passed jminer s lter.
of them resulted in parametric speci cations but the other did not because dacapo and apache james generated no interactions corresponding to them target event parametric package speci cations speci cations java.io java.lang java.net java.util table shows the elapsed execution time for three separate stages event speci cation learning section .
trace slicing section and speci cation learning section .
.
table does not include the time spent on running unit tests and applications.
each number represents the total elapsed time e.g.
learning event speci cations for java.io took minutes.
trace slicing accounted for most of the time.
these traces contain an enormous number of events and parameter instances and our slicer relates events whenever they share the same objects no matter how far these events are from each other in the trace.
overall considering that high quality speci cations are invaluable we believe that the time spent on trace slicing is a minor aspect.
we next discuss some parametric speci cations that were automatically mined by jminer .
more can be found at .
init s getoutputstream s o getinputstream s i read i write o close s read i write o write o read i close s close s figure socket speci cation mined using jminer client socket.
figure shows a speci cation of a clientside stream socket.
the constructor of socket connects a new socket to the peer speci ed by its arguments.
then getinputstream and getoutputstream return the input stream and the output stream respectively which enable data transmission using readand write.
the speci cation states that data transmission can be repeatedly performed in arbitrary order until the socket is closed which is consistent with the documentation.
it also states that closecan be invoked multiple times which is undocumented but correct.
the speci cation also correctly suggests that the invocation of closeis optional because states and are also nal states.
in fact calling close is recommended but not mandatory because the connection is eventually closed when the socket object is reclaimed.
init l getinputstream e i accept l e getoutputstream e o read i write o write o read i write o close e close e figure serversocket speci cation mined with jminer.
serversocket.
figure shows an inferred speci cation for the server side socket.
after a serversocket objectlis instantiated accept listens for a connection and accepts it returning a new socket e.getinputstream and getoutputstream return an inputstream objectiand an outputstream objectorespectively which can be used for data transmission.
after these operations close can be invoked to close the connection.
this behavior spans over multiple threads in most cases because multiple clients can connect to the same port represented by a single serversocket object and a server needs to handle them simultaneously.
the trace slices in our experiments indeed involved two threads the data transfer was processed in a separate thread.
if each thread s trace was considered separately like in the speci cation could not be mined.
collection iterator.
figure shows a speci cation of collection and iterator .
as discussed in section the speci cation states a safety property of collection and a typical usage pattern of iterator .
in order to mine the speci cation in figure we slightly modi ed the automatically inferred event speci cation that de nes the ve methods collection.hiniti collection.add collection.iterator hasnext and next.
knowing that add remove and clear are similar all these methods update the collection we grouped the three methods into one hypothetical method which we called update .
init r read r close r figure reader speci cation mined using jminer.
reader writer.
figure shows a speci cation of a reader object stating that readcan be repeatedly called before close.
it does not enforce the invocation of close similarly to the socket speci cation above.
jminer also mined a similar speci cation for writer .
these speci cations are simple but can detect the wrong invocation of readorwrite after close.
.
limitations we have identi ed during our experiments a few limitations of our approach.
first the learning process is limited to the observed behaviors.
this is an inherent limitation of all dynamic approaches.
for example the speci cations in figures and wrongly enforce the order between getinputstream and getoutputstream because this was consistently observed in the training set.
also in figure one may expect that the speci cation should state that nexttoken is guarded by hasmoretokens .
surprisingly the inferred one allows the invocation of the two methods in an arbitrary order since it was actually observed that xalan an application in dacapo calls nexttoken without calling hasmoretokens .
init s nexttoken s hasmoretokens s figure stringtokenizer spec.
mined using jminer.
after inspecting the source code of xalan we could see that the pattern is not defective because xalan rst retrieves the number of tokens by calling counttokens and then consecutively calls nexttoken as many times as speci ed by counttokens .
due to counttokens a speci cation on stringtokenizer cannot be stricter than figure .
considering counttokens as well does not improve the speci cation because our technique cannot infer that the return value of this method indicates the number of allowed nexttoken calls.
this limitation is inherent to all fsa based approaches fsa cannot count.
.
related work ammons et al.
mines speci cations from execution traces and user provided input functions of interest attributes for those functions and a scenario seed.
their tool extracts a set of api usage scenarios from execution traces and then passes it to a pfsa learner.
providing attributes requires in depth knowledge one should understand the side e ect of each function the user should imagine a hypothetical object corresponding to a scenario and should mark a parameter as de ne or respectively as useif the parameter changes or depends upon the state of the object.
scenarios are identi ed starting from the seed event searching the execution trace along de ne usechain.
having explicit seed events and using the chain reduce the search space but it may result in failing to recognize complete in teractions.
for example assume the following trace .
arraylist.add collection .
abstractlist.iterator collection iterator .
abstractlist itr.hasnext iterator .
abstractlist.iterator collection iterator .
abstractlist itr.hasnext iterator .
arraylist.add collection also suppose that the seed event is iterator it is the only event that connects collection and iterator and that adddenes collection iterator de nes iterator and uses collection and hasnext uses iterator .
for example event depends on event as event de nes collection and event uses collection .
from these inputs two scenarios will be extracted and .
none of them are complete with regards to the interaction between collection and iterator none includes event because adddoes not use collection and consequently cannot be reached from iterator in a scenario.
since the retrieved scenarios are incomplete the pfsa learner will eventually infer a restricted fsa as shown in figure .
stating that adddenes collection and also uses it does not solve the problem.
in fact it causes another problem a scenario that includes operations on two distinct iterators will be extracted.
hasnext i next i iterator c i add c hasnext i figure restricted collection iterator usage pattern.
pradel and gross propose a dynamic mining technique based on collecting from execution traces a list of related receiver method pairs up to a user speci ed level of nested method calls.
unlike ours their technique does not consider individual interactions separately.
therefore it may merge individual interactions and thus infer inaccurate speci cations.
for example if the execution trace in figure is observed within a method their technique will not consider the two interactions separately and consequently infer a faulty speci cation that allows consecutive calls to next.
moreover it cannot infer a speci cation that spans over multiple threads since it creates a separate trace for each thread e.g.
the speci cation in figure cannot be mined.
furthermore it may fail to mine speci cations from distantly related events if the value of the level of nested method calls is too small.
if on the other hand the value is too large it may produce speci cations that include too many methods and would likely be application speci c. yang et al.
propose a technique to nd all pairs of methods that satisfy the prede ned particular pattern ab from execution traces.
although their chaining heuristic composes somewhat more complex patterns such as abc by connecting related speci cations into a chain it cannot infer useful and more complex patterns like in figure .
gabel and su extend their work considers an additional pre de ned pattern ab c .
it then combines instances of these basic patterns generating complex patterns.
unlike our approach it neglects parameters thus it may infer noisy speci cations from sequences of irrelevant events that happen to match the prede ned patterns.
dallmeier et al.
also present a technique for mining fsas from execution traces.
a state in the fsa inferred by their work represents the results of inspector methods that observe the internal state such as isempty and hasnext whereas a state in our approach is abstract e.g.
before using an iterator .
associating each state with inspectorscan help users to easily understand the speci cation but it fails to capture implicit states such as an iterator for a collection is being used because no methods in collection can observe it.
in our approach the sequence of method calls can capture those states.
moreover their work considers only one object and is essentially non parametric.
lorenzoli et al.
gives an advanced algorithm to mine extended nite state machines efsms i.e.
fsms extended with state constraints.
their approach proposes no trace slicing technique which is at the core of our approach instead they assume that the training traces are already given as separate interactions with constraints.
in principle one could use state constraints to encode parameter instances but considering the huge number of parameter instances encountered in our experiments we believe that would be impractical.
we have only looked at mining parametric fsas it may however be bene cial to plug their learner into jminer and use the latter for learning efsms from trace slices produced by our algorithm in section .
acharya et al.
proposes a static technique that generates a set of traces along possible execution paths directly from the source code and then produces an api usage pattern from it.
since it mines partial orders the resulting speci cations cannot describe loops thus it cannot mine the speci cations shown in this paper.
zhong et al.
also presents a static mining technique for sequential patterns from open source repositories.
unlike our approach their tool does not consider individual interactions separately.
for example if there are multiple distinct interactions on collectionin a method their tool can extract a faulty method call sequence.
since their tool inlines multiple methods the probability that a method call sequence consists of multiple interactions on collection is high which makes this approach improper to mine speci cations of frequently used classes.
chen and ro su introduce trace slicing for monitoring.
there is an inherent duality between parametric speci cation monitoring and parametric speci cation mining they both rely on a parametric trace slicing process for identifying interactions followed either by monitoring the resulting trace slices against given speci cations in the rst case or by inferring the speci cations that best explain the observed trace slices in the second case.
however a blind use of o the shelf trace slicing techniques for monitoring leads to noisy and ine cient trace slicers for mining.
it is allowed for trace slicers for monitoring to generate trace slices corresponding to incomplete or unconnected parameter instances because such trace slices can be ignored by the underlying monitor.
in the context of mining however such trace slices would result in faulty speci cations.
.
conclusion this paper presented a generic and automated approach to mine accurate parametric speci cations from execution traces with minimal e ort.
the event speci cation learner reduces the e ort by automatically inferring event speci cations from unit tests and the trace slicer identi es independent interactions allowing one to apply various learning techniques that do not handle parameters.
moreover our automaton re ner makes the inferred speci cations more accurate by eliminating spurious transitions.
our experiments indicate that the technique is e ective it mined many meaningful speci cations that involve multiple parameters.
.