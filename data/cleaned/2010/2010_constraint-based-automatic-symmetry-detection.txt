constraint based automatic symmetry detectionshao jie zhang jun sun chengnian sun yang liu junwei ma and jin song dong singapore university of technology and design singapore national university of singapore singapore nanyang technological university singapore shaojie zhang sunjun junwei ma sutd.edu.sg suncn dongjs comp.nus.edu.sg yangliu ntu.edu.sgabstract we present an automatic approach to detectingsymmetry relations for general concurrent models.
despite thesuccess of symmetry reduction in mitigating state explosion prob lem one essential step towards its soundness and effectiveness i.e.
how to discover sufficient symmetries with least human efforts isoften either overlooked or oversimplified.
in this work we showhow a concurrent model can be viewed as a constraint satisfactionproblem csp and present an algorithm capable of detectingsymmetries arising from the csp which induce automorphismsof the model.
to the best of our knowledge our method is thefirst approach that can automatically detect both process anddata symmetries as demonstrated via a number of systems.i.
introductionin practice a certain sometimes rich degree of symmetriesis ubiquitous in concurrent and distributed systems .a number of representative real world complex networks including a broad selection of biological technological andsocial networks are found to have a nontrivial symmetricstructure .
in theory given a model a symmetry is anautomorphism of its underlying state space which can beviewed as a graph .
a naive and complete symmetry detectionmethod thus needs to explore the complete space.
in general if a symmetry detection method is performed on a state space then the complete state space is required to be constructed priorto the exploration.
it is not only computationally expensiveor impossible but also against the original goal of symmetryreduction to reduce the explored state space.
a practical andpopular approach is to use static analysis to derive symmetriesat model level .existing symmetry reduction approaches have two mainlimitations in the identification of symmetries in a model.first the soundness and efficiency highly depend on humanefforts.
it is generally too difficult for machines to look throughthe behavior of concurrent models to pin down symmetriescorrectly.
most approaches require users to provide correctsymmetries which is tedious and error prone.
some languagesprovide dedicated instructions for specifying symmetries .
for instance mur provides a special data type witha list of syntactic restrictions.
all values that belongs to thistype are equivalent.
although there are automatic approacheswhich do not need expert insights they are designed for specificlanguages or require models to be written in specificpatterns .
thus they trade off generality for efficiency and consequently a user has to transform his problem into aform amenable to the approach.
second existing approachescan only handle a specific class of symmetries and largelyignore other classes of symmetries which could reduce statespace significantly.
as a result symmetries in the underlyingstate space are only partially discovered.in this work we develop a novel approach for symmetrydetection which addresses these two limitations.
not restrictedto a particular modeling language our approach works for gen eral concurrent models i.e.
concurrent composition of finite state machines which could communicate through channels synchronous events or shared memories in a fully automaticway.
further it is able to detect many kinds of processsymmetries and data symmetries together.
the workflow ofour approach is shown in figure .first a concurrent model is translated into a semantics equivalent nondeterministic sequential model using existingapproaches .
the motivation behind is two fold.
first itis nontrivial to analyze concurrent models whose behaviors arenot obvious such as subtle flexible communication patterns andnumerous possible interleavings between processes.
second wecan take advantage of well developed static analysis techniquesfor sequential models.
the worst case complexity of thetranslation is linear in the total number of atomic statementsof all processes.second we consider the problem of discovering symmetriesfrom a new angle.
our key insight is recognizing the similaritybetween the role of symmetries in constraint programming andthat in model checking.
our analysis transforms the sequentialmodel into a constraint satisfaction problem and extracts agraphical representation of the csp called colored graph.
eachautomorphism of the colored graph is proved to correspond toone in the concurrent model which is effectively discovered byapplying a graph automorphism generator named saucy .the detected symmetries can be used later to speed up theperformance of a state space exploration tool e.g.
a modelchecker or a simulator.the above steps can be performed fully automatically.the effectiveness and efficiency of our approach have beendemonstrated via a variety of systems.the rest of this paper is organized as follows.
section iipresents a simple motivating example.
section iii introducesrelevant background information and terminology used through out this paper.
section iv describes our automatic symmetrydetection approach in details and proves the soundness of ourapproach.
section v presents the results of our case studies.section vi surveys related work.
section vii concludes thepaper and discusses possible future work.
.
c ieee ase palo alto usa15fig.
automatic symmetry detection workflowii.
motivatingexamplein the following we use a token circulation protocol as a running example.
all the agents or nodes are deployedin a directed ring.
the protocol requires the existence of aleader.
each agent has two single bit variables recording itstoken and label and one boolean constant indicating whetherit is a leader.
only agents that are adjacent can interact thesource node is the initiator and the target is the responder .during an interaction two agents update both of their statesaccording to two predefined transition rules .
if two agentshave the same label the responder is a leader and the initiatoris not the responder sets its label to the complement of theinitiator s label otherwise the responder copies the label fromthe initiator.
if an interaction triggers a label change a tokenis passed from the initiator to the responder.
starting from anarbitrary configuration the protocol guarantees that eventuallythere is always one and only one agent holding a token.the concurrent model of this protocol withnagents isdescribed in figure using the syntax of communicatingsequential programs .
processrule1 orrule2 defineshow an initiatoruinteracts with a responderv.
everytime there is an interaction in the network the initiatorand responder must update themselves according to the twotransition rules.
a rule is applicable only if the guard condition e.g.
!leader label !
label is satisfied.
an event e.g.
rule2 may be attached with variables updating e.g.
token token label label .
thewhole token circulation protocol is described as processtokencirculation which is the interleaving modeled bythe operator of all possible interactions in the network.initially the system can be in any possible configuration andthe initial variable valuation is omitted here for simplicity.rule1 u v leader label label rule1 token token label label !rule1 u v rule2 u v label !
label rule2 token token label label !rule2 u v to ke n ci rc u la t i o n x ..n rule1 x x modn rule2 x x modn fig.
concurrent model of token circulation protocolsimple as the protocol is the protocol exhibits non trivialsymmetries a process symmetries that rotate every processfollowing the network direction b data symmetries that swapthe label values c the combinations of process and datasymmetries that permute processes and label values together.existing data symmetry detection approaches relyon scalarset annotations to discover fully symmetric compo nents i.e.
components which are identical up to rearrangingtheir identifiers .
although values of alllabelvariables arefully symmetric in this case that is permuting the values to0 and to for alllabelvariables together over all the statesand transitions of the state space results in the same state space the arithmetic operations on the variables prohibit the use ofscalarsets.
further the protocol does not take message passingparadigm so the approaches for detectingprocess symmetries are not applicable.
moreover as far as weknow there is no approach that considers process and datasymmetries which are not both full symmetries at the sametime i.e.
no existing approaches can find all symmetries inthis example.iii.
preliminariesthis section is devoted to the background knowledge ofsymmetry reduction in one application area of state spaceexploration i.e.
model checking and the relevant concepts ofconstraint satisfaction problems.a.
model checking with symmetry reductionwe present our work in the setting of labeled transitionsystems ltss .
an lts is a tuplel s init !
wheresis a finite set of states init2sis the initial state is a finiteset of events and!
s sis a labeled transition relation.a permutation is said to be an automorphism of an ltsliff it preserves the transition relation and the initial state i.e.
8s1 s22s e2 .s1e!s2 s1 e!
s2 init init.
a groupgis an automorphism group ofliff every 2gis an automorphism ofl.
a permutation is said to bean invariance ofland property iff it is an automorphism ofland where denotes logical equivalence under allpropositional interpretations .gis an invariance group ofland iff every 2gis an invariance ofland .
given a states2s the orbit ofsis the set s t 2g.
s t i.e.
the equivalence group which containss.
from the orbitof states a unique representative staterep s can be pickedsuch that for allsands0in the same orbit rep s rep s0 .intuitively if is an invariance of states of the same orbitare behaviorally indistinguishable with respect to .
based onthis observation an ltslcan be turned into aquotientltslgwhere states in the same orbit are grouped together.
ifgis an invariance group ofland thenlsatisfies ifflgsatisfies .there are two common types of symmetries for improvingthe performance of model checking.
aprocess symmetryis a permutation on identifiers of concurrent processes.
adata symmetryis a permutation on data values.
for example suppose a statestis s1 s2 sn wheresiis the local16state valuation of processi.
if is a process symmetry onthe process ids n then acts onstin the form st s s s n if it is a data symmetry then acts onstin the form st s1 s2 sn .b.
constraint satisfaction problema constraint satisfaction problem csp is a triple v d c wherevis a finite set ofvariables dis a set of finitedomainsandcis a finite set ofconstraints.
each variablevi2vhasan associated domaindi2dof possible values.
aliteralisa statement of the formvi dwherevi2vandd2di.for any literallof the formvi d we usevar l to denoteits variablevi.
the set of all literals is denoted by .
anassignmentis a set of literals each of which is a variablevaluation of the csp.
asolutionof a csp is a completeassignment which satisfies each constraint inc. a constraintcis defined over a set of variables and the set is denoted asvar c .asolution symmetryis a permutation of literals that preservesthe set of solutions .
aconstraint symmetryis a solutionsymmetry that preserves the constraints of the csp .
buta solution symmetry may not be a constraint symmetry.
forexample a csp is v x y z d c x y y z .
it only has one solution x y z .one of its solutions symmetries is x x .
but itis not a constraint symmetry because it maps the literals x y which satisfiesx yto x y whichdoes not satisfy it.
for a csp v d c avariable symmetry is a permutation onvsuch that for any constraintc2c v1 a1 vn an satisfiesciff v1 a1 vn an satisfiesc avalue symmetry is a permutation ondsuchthat for any constraintc2c v1 a1 vn an satisfiesciff v1 a1 vn an satisfiesc.avariable valuesymmetry is a permutation of the literals i.e.
v d that isa constraint symmetry.
note that a variable value symmetry isnot necessarily a composition of a variable symmetry and avalue symmetry.iv.
automaticsymmetrydetectionin the section we describe an automatic approach todetecting the symmetries of a concurrent model.
it translatesa concurrent model into a csp whose symmetries can beexploited using the state of the art detection approaches forcsps.algorithm gives an overview of the overall approach.
thereare three main steps.
the first step as described in procedureconcurrent2sequential converts a concurrent modelcurmodelinto its semantics equivalent nondeterministic sequential modelseqmodel.
the second step as described in lines separatelytransforms each enabling condition and each next state programinseqmodel and itsinitstatement to a semantics equivalentcsp as shown by proceduretransform.
these csps are thenmerged into one single csp.
the third step detects variable value and variable value symmetries in the merged csp asdescribed in proceduredetectsymmetries.
further we provethat each detected symmetry is a real automorphism of thealgorithm overview of our approach1autos vl csps 2seqmodel concurrent2sequential curmodel 3identify the set of global variablesvginseqmodel 4foreachsummandsumin seqmodeldo5identify the set of local variableslocalsofsum 6vl vl locals 7foreachfunction or enabling conditionfinsumdo8csps csps transform f 9csps csps transform init 10autos detectsymmetries merge csps vg vl lts of the original concurrent model.
lastly we present twolightweight but effective optimization methods.a.
step conversion from concurrent to sequentialwe briefly introduce the principle of modeling concurrentmodels by means of nondeterministic sequential models.
thecorresponding sequential model can be built by simulatingthe behavior of the concurrent model and keeping track oflocal states of each process and global states all the time.basically the preparatory step of the transformation is tointroduce a new integer variable state for each process inthe model to represent its control points and then a syntactictransformation is performed to translate each statement into oneor more sequential statements recursively.
then a concurrentmodel is reduced into a sequential one which captures all itsbehaviors.
note that the idea of linking concurrent models tonondeterministic sequential models goes back to the work ofashcroft and manna for proving the correctness ofconcurrent programs.
the detailed transformation process isalso explained in .
the transformation is general enough tohandle three different types of systems with respect to executionpatterns i.e.
sequential and parallel systems with synchronousand asynchronous communication.
therefore our approach isnot specific to one particular specification language.
moveover for a concurrent model its corresponding sequential model canbe extracted in linear time .
the resulting model has thetotal number of atomic statements of all processes in the worstcase.figure shows the sequential model for the token circulationprotocol.
the nondeterministic sequential model is written ina single process with data variables that describes a system asa set of guarded and nondeterministic transitions.
it containsa single parameterized recursive process definition and theinitial parameter valuations of this process.
the left hand sideof the process definition is a process name with a vector ofdata parameters.
here we refer to these parameters asglobalvariables.
an addition operator in the right hand side sums a list of nondeterministic transitions to which we refer to assummands.
a summand has a declaration oflocal variablesfollowed by an enabling condition an event if any and anext state program from left to right.
each local variable can beevaluated to any value of its type nondeterministically.
it isread 17typeag ..n 1typebit ..1proctokencirculation bit token bit label bool leader agu1.agv1.
leader label label rule1 token token label label !tokencirculation token label leader agu2.agv2.
label !
label rule2 token token label label !tokencirculation token label leader inittokencirculation fig.
sequential model of the token circulation protocolonlyand cannot be of array type1.
executability of a summandis decided by its enabling condition that is a boolean expression the action of the summand is decided by the event name theeffect of the summand is decided by its next state programwhich updates the global variables.
a next state program iscomposed of a sequence of statements.
a statement can bean assignment conditional or while loop statement.
besides there is an initial valuation of global variables denoted byinit which is the entry where the process starts to execute.
thesymbol denotes the nondeterministic choice of all possibleevaluations of global variables.for the running example the transition in processrule1 resp.rule2 is transformed into the first resp.second summand in the sequential model.
there are two processidentifiers used in each transition from the domain n .the initiator and responder idsuandvare transformed intou1andv1 resp.u2andv2 in the first resp.second summand.b.
step transformation from the sequential model to a cspwe describe how to convert a function or theinitstatementinto the static single assignment form ssa below fromwhich an equivalent csp is derived.
ssa is a form of asemantics preserving intermediate representation of a program which requires that each variable be assigned exactly once.the key feature of ssa is that each variable with the samename always has the same value in everywhere in the program.the immutability of variables is the primary reason why wetransform each function into a constraint system by the use ofssa.converting ordinary source code into ssa is relativelystraightforward.
in essence it replaces the target variable ofeach assignment with a fresh name.
every usage of this variablein the succeeding statements is replaced with the new name until a new assignment to the same variable occurs.
we call theexisting variablesoriginalvariables and other new variablesversionedvariables.further ssa defines an artificial function to represent thechoice between different branches of a conditional statementdefined formally as follows.
a new boolean variableb called1if a local variable is an array the language can be extended to support iteasily as we have done in our tool.decision variable is introduced to store the value of thecondition and theifandelsebranches are converted separately.for each variablexdefined in theiforelsebranch anadditional assignmentx000 x0 x00 b is inserted at theend of the block to achieve branch selection wherex0andx00are the last definitions ofxin theifandelsebranchesrespectively.
x0 x00 b ifbthenx0elsex00still converting a program to ssa form becomes morecomplicated whenwhile loop statements are involved.
awhile loop can be equivalently regarded as an infinite number ofnested conditional statements.
but it is impractical to transformit into such conditional statements.
so the assumption here isthat any loop can be finished in a finite number of iterations.in this way we reduce the problem of converting a loopto converting a list of conditional statements.
note that thisassumption puts little limitation on our approach.
because theloop considered here is the loop included in one next stateprogram that is atomically executed.
it is rare for a practicalsystem to put the whole loop in one atomic step.another challenge is handling array manipulation.
the reasonis that a new assignment statement of an array does notnecessarily kill all the old values in the array.
for instance the meaning of the assignmenta a 5is two fold.
first it increases the value of theithelement in thearray a by5.
second all the values of other elements areunchanged.
we cannot simply assign the left hand side witha new name which loses the second meaning.
thus wedefine a function as follows to handle array assignments.suppose an array assignment isarray valueandarray0is the latest name ofarraybefore the assignmentin the ssa form.
we replace the original assignment witharray1 array1 a rra y0 i n d e x va l u e wherearray1isa fresh name.
note that can be a polymorphic function soas to handle multi dimensional arrays.array1 array1 a rra y0 i n d e x va l u e array1 value 8j6 index.
array1 array0 take the next state program of the first summand infigure i.e.
token token label label as an example.
its ssa form istoken1 token1 t o k e n u1 token2 token2 t o k e n1 v1 label1 label1 l a b e l v1 label the ssa form we obtain can be more succinct by applyingcopy propagation technique commonly used in compileroptimization.
it eliminates unnecessary temporary copies of avalue generated by our transformation and further facilitatesour symmetry detection approach.
an assignment is anidentityassignmentif it is in the formx ywhich assigns the value ofytoxandyis either a variable or a constant.
copy propagationis the process of replacing the occurrences of targets of identityassignments with their values.the ssa form of a program always has the same behaviorsas the original program .
after the conversion of afunction to ssa the next conversion from ssa to a cspis straightforward.
each assignment is directly mapped toa constraint by interpreting each assignment operator as anequivalence operator.
both representations are very similar.it is easy to know the ssa and its csp representation haveequivalent behaviors as the following proposition states.proposition .given an ssa representationp letcpbe thecsp converted fromp.
if for an inputithe execution ofpproduces valuationsvfor all variables theniandvis asolution ofcpand vice versa.for an enabling condition since it is already a constraint itdoes not need any transformation.
for theinitstatement weconvert it into a constraint in a very similar way.
suppose theprocess in the sequential model isp dom1v1 do mnvn and itsinitstatement isp a1 an .
it is converted tov1 a1 vn an.
then we simply combine all theconstraints derived from each next state program enablingcondition and theinitstatement to build one large csp forthis whole sequential model.for the running example the conversion step builds thecorresponding csp for its sequential model as shown infigure .
since itsinitstatement represents all possibleevaluations of global variables it has no effect on symmetrybreaking in the csp and thus is skipped for simplicity.c.
step symmetry detection on cspnext we explain the procedure to discover constraintsymmetries in the merged csp which we denote ascfinthe following.
first we present the state of the art symmetrydetection method for csp on which our detection approach isbased.
however considering the role each constraint plays inthe sequential model this method is not completely suitablein terms of correctness and performance.
to cope with thisproblem we describe our alternations as follows.our approach is based on the automatic symmetry detectionmethod for csp proposed by puget .
it allows us to detectvariable symmetries value symmetries and non trivial onesinvolving both variables and values.
for each constraint theapproach first calculates all the allowed assignments.
then thegraph of this constraintcis constructed in the following way.avariablenode is created for each variable inc. an arrayrepresents a collection of scalar variables.
so a distinct variablenode is created for each element of the array.
aconstraintnodeis created forc.avaluenode is created for each value of eachvariable inc. anassignmentnode is created for each allowedassignment ofc.
edges connect each value node to its variablenode each assignment node to the value node representingeach variable value literal occurring in the assignment andeach assignment node to the constraint node.
so the numberof nodes in the colored graph is the sum of the number ofvariables literals constraints and allowed assignments and thenumber of edges is the sum of the number of literals allowedassignments and variables in allowed assignments.the graphs for all constraints are combined into a singlegraph calledcolored graph.
the coloring scheme for this graphis described in three rules all variable nodes with the same domain have the sameunique color for a variable all of its value nodes have the same uniquecolor.
if two variables have the same color their valuenodes have the same color for a constraint its assignment nodes all have the sameunique color.
if two constraints have the same color theirassignment nodes have the same color.it addresses symmetries by computing the automorphisms ofthe colored graph.
it has been proved that each automorphismof this graph corresponds to a constraint symmetry as restatedin the following theorem.theorem .
letc v d c be a csp .
its coloredgraphgis constructed as illustrated above.
suppose is anautomorphism ofgandsis an assignment ofc.
for eachconstraintc2c ssatisfiesciff s satisfiesc.before applying this method to our problem we have toaddress the concern raised by the differences of ordinary cspsand the csp we convert the sequential model into.
somevariables in a sequential model cannot be used at the sametime local variables in different summands for example.
sofor its corresponding csp it is unreasonable to detect variablesymmetries between those variables.
therefore the originalcoloring scheme is refined such that variable nodes which havethe same domain are of the same unique color iff each of them is a local variable of the same domain inthe same summand or each of them is an original global variable of the samedomain or each of them is the latest version of a global variableof the same domain.it is not difficult to show that each automorphism found underthe new coloring strategy is also an automorphism underthe original coloring strategy.
so theorem still holds.
thesoundness of our work is stated as follows.theorem .letl s init !
be its labeled transitionsystem of a concurrent modelm.
each automorphism weget in algorithm is an automorphism ofl.19v u1 v1 u2 v2 l e a d e r t o k e n l a b e l t o k e n1 t o k e n2 t o k e n3 l a b e l1 d ag ag ag ag bool bit bit bit bit bit bit c v1 u1 modn !leader leader label label token1 8t2ag.t6 u1!token1 token token2 8t2ag.t6 v1!token2 token1 label1 label 8t2ag.t6 v1!label1 label v2 u2 modn !leader label !
label token3 8t2ag.t6 u2!token3 token token2 8t2ag.t6 v1!token2 token3 label1 label 8t2ag.t6 v2!label1 label fig.
constraint satisfaction problem of the token circulation protocolproof sketchby definition we must show that i ifs1e!s2 then s1 e!
s2 and ii init init.supposepis an equivalent sequential model ofm ands1e!s2corresponds to the execution of the summandsumofp.
without loss of generality we assume there is only oneglobal variablevginpand one local variablevlinsum.s1e!s2is assumed to denote executingsumwhenvg value1andvl value2.
that is whenvg value1andvl value2 its enabling conditionfeis true eventeis executed and globalvariables are updated in its next state functionfnwhich leadsto states2.supposecis the constraint satisfaction problem convertedfrompin algorithm .
by theorem all the constraintsconverted fromfeandfnare satisfied whenvg value1andvl value2.
by theorem is a constraint symmetry ofc.so all of the constraints fromfeandfnare also satisfied when vg value1 and vl value2 .
again by theorem weget s1 e!
s2 .
similarly we can prove init init.note that the inverse of the theorem may not hold.
forexample if two processes of the same type identical up toswapping their process identifiers are intentionally modeled asprocesses of two different types this process symmetry is notreflected in its corresponding colored graph.the number of nodes in the colored graph of a csp is thesum of the number of literals which is the product of thevariable domain sizes and the number of allowed assignmentsfor constraints.
for a constraint withnvariables it may haveo mn possible assignments in the worst case wheremis thesize of the largest domain.
the time complexity of computingallowed assignments of one constraint iso mn and the timeand space complexity of constructing the colored graph for acsp accumulate tot o mn wheretis in the number ofconstraints.figure shows a part of the colored graph obtainedfrom the csp of the running example withn .
dueto space restriction and graph complexity we make thefollowing alternations for simplicity in order to help usersbetter understand its inherent symmetries while still preserv ing the essence of the graph.
this graph fragment shownis built from part of the first constraint in the csp i.e.
v1 u1 modn label label .
we skip therepresentation of all nodes generated fromv1 u1 modnand variable and value nodes forv1andu1.
note that rotatingthreelabelvariables clockwise still yields the same graph swapping any literals of the formlabel 0andlabel 1for all0 i 3in all the assignments yields the samegraph.
fig.
part of the colored graph of the running example s cspexamplefor the running example assume there are threeprocesses with ids and it has process symmetriesfrom rotating the processes following the direction of thenetwork i.e.
it has datasymmetries from swapping all the possible values of alllabelvariables i.e.
.
further new symmetries areintroduced by the product of these automorphisms.
therefore we discover symmetries in total.d.
optimizationin the step of symmetry detection we perform twolightweight but effective optimization techniques the first oneto speed up the construction of the colored graph and thesecond to remove symmetries which are useless for modelchecking.
breaking down array writing constraints each arraywriting constraint is involved with at least all the variables oftwo arrays which often becomes a performance bottleneck.in order to reduce the time consumption one straightforwardway is keeping the number of variables as small as possible.we transform it intok 1simple constraints each involving2permutations are written in the cyclic notation.
ifa1 a2 anaredistinct elements of then the cycle a1 a2 an denotes the permutation on i.e.
for1 i n ai ai an a1and for anyb2 a1 a2 an b b.20much fewer variables in the following way3wherekis thearray size and refine the coloring strategy such that elementsof different arrays have different colors.array1 value 8j2 n .j6 index!array1 array0 array1 valuearray1 array0 array1 array0 array1 array0 the soundness of the transformation is stated by thefollowing theorem.theorem .letcbe a csp .
andc0its corresponding csp ofcafter transforming all array writing constraints.
then anyconstraint symmetry ofc0is also a constraint symmetry ofc.proofassume is a constraint symmetry ofc0.
theconstraints incare separated into two sets one containing allthe array writing constraintss1and the other containing all therest constraintss2 similarly the constraints inc0are separatedinto two sets one containing all the constraints transformedfrom an array writing constraintss01and the other containingall the rest constraintss02.
sinces2ands02are identical isalso a constraint symmetry fors2.we define a functionevalswhich takes an assignmentsand a constraintc and returns the satisfaction ofcwhenevaluated ass.
without loss of generality we assume thereare no multi dimensional arrays inc. suppose an arraywriting constraintcins1isarray1 value 8j2 n .j6 index!array1 array0 .it is transformed into the listlcontainingn 1constraints array1 value array1 array0 a rra y1 array0 ins01.
letsbe an assignment ofc.
because all elements of an arrayhave the same color which is different from that of any othervariable.
for any elementarray0 wherek2 n array0 array0 wherek02 n .
thisalso applies to elements ofarray1.
there are three conditionsto be considered if the first constraint inlis evaluatedto false ats i.e.
evals array1 value false thenevals c false.
because is a constraintsymmetry eval s array1 value eval s array1 value false.
soeval s c false otherwise if there existsi2 n such thatevals array1 array0 falsewherei6 evals index thenevals c false.sinceevals array1 array0 false evals c falseandeval s array1 array0 eval s array1 array0 false.
becausei6 evals index eval s i eval s index .therefore eval s c false otherwise evals c 3for ease of presentation we only show how to transform a writing constraintof a one dimensional array.
it can be easily extended to multi dimensionalarrays.true.
that is evals array1 value trueand8j2 n andj6 evals index suchthatevals array1 array0 true.
considering is a constraint symmetry eval s array1 value eval s array1 value trueand8j2 n andj6 evals index such thateval s array1 array0 eval s array1 array0 true.
becausej6 evals index eval s j eval s index .
soeval s c true.therefore is also a constraint symmetry ofc.
removing redundant value symmetries the coloredgraph may contain some values of a variable which do notsatisfy any constraint transformed from an enabling conditionor theinitstatement.
it means that those values are impossibleto appear at any time during the execution of the system.take the csp v x y d c x y x as an example.
a value symmetry x x exists in the csp.
suppose the constraintx 1is originally derived from the enabling condition andy x 1is thenext stateprogram of the same summand inthe sequential model.
so neitherx 0norx 1is validin any state which makes useless for reducing the statespace.
therefore it is safe and appropriate to remove thesevalues during the graph construction in order to avoid redundantsymmetries later.
for each variable s value we record whetherit appears in at least one allowed assignment of a constraintrepresenting an enabling condition or theinitstatement.
ifnot it will be removed.v.
casestudieswe have implemented the colored graph construction de scribed in section iv.
the resulting graph is input to saucy which produces the generating set of the automorphism groupof a graph.
for a group its generating set is a subset whoseelements are denoted by generators such that each element ofthe group can be obtained by the combination of generatorsof this subset.
a generating set is often used as a compactrepresentation of a group.
then the generating set is input togap system which produces all the elements in the group.all experiment data is online part of which is summarizedin table i.the experimental cases cover a variety of computing systems.from the perspective of execution patterns they includesequential systems concurrent systems with synchronouscommunication using shared variables or shared actions and distributed systems with asynchronous message passingmechanism.
from the perspective of communication topologies they include networks of layers rings trees stars completegraphs and hypercubes.
from the perspective of symmetrytypes there are systems with only process symmetries withonly data symmetries and with both of them.in table i colored graph denotes the size of the coloredgraph generated for each configuration constructiondenotesthe time in seconds taken to construct the colored graph generators denotes the size of the generating set of the21table i symmetry detection results on a linux laptop with intel .8ghz and .
gb memorysystem colored graph construction s saucy s generators aut g scalarscdreader writer problem .
.00412nnpeterson s mutual exclusion protocol .
.0188362880ny1242071.
.03011479001600a prioritized resource allocator1 .
.004424ny3 .
.0057864three tiered architecture2 .
.0055144ny3 .
.
.
.00686912message passing in a hypercube network3 .
.02643840nn6115553.
.066546080dining philosophers105560.
.005110nn2010861.
.007120miler s scheduler .
.00100nnnon deterministic two hop coloring protocol in undirected rings .
.0125216nn1231051.
.0135288self stabilizing leader election protocol in complete graphs .
.39411479001600nn1516480915.
.326141307674368000self stabilizing leader election protocol in directed rooted trees .
.275416nn195807.
.0056128self stabilizing leader election protocol in rings .
.09319nn1221416951.
.266112hanoi puzzle38910.
.00312nn665201.
.02312scheduling the social golfer problem4 .
.0099725760nn1a configuration is written in the forma0 a1 ak where client processes0 a0have prioritylevel0 a0 a0 a1have priority level etc.2a configuration is written in the forma1 a2 ak which denotes that the system consists ofkserverprocesses andaiclients connected to serveri.3a configuration is denoted by the number of dimensions of the hypercube.
note that the configurationdiscomposed of2dprocesses.4a configuration is written in the formg s wwheregis the number of groups sis the number of golfers inone group andwis the number of weeks.automorphism groupgof the colored graph computed bysaucy saucydenotes the time taken by saucy to computegenerators aut g denotes the size ofgcomputed by gap.for systems whose configurations are not explained here a configuration of each one is identified by the number ofprocesses components.
the last two columns denote whetherthese symmetries can also be detectable by two popularexisting approaches scalarset scalar and static channeldiagrams scd which are introduced in section vi withoutmajor changes on the original model e.g.
rewriting eacharithmetic or relational operation on variables related to processidentifiers into the logical disjunction of all explicit variablevalues allowed by this operation or remodeling the processcommunication mechanism into channels only.
for a systemwith data symmetries such as two hop coloring protocol existing approaches are still unable to discover them evenif the system is changed into the form the approaches require.as table i shows the overhead of our approach is quite loweven for the systems with large automorphism groups.
we studythe same cases as the static channel diagram approach i.e.
peterson s protocol resource allocator three tieredarchitecture and message passing in a hypercube network andour approach is able to find all symmetries reported in theirwork efficiently.
however the effectiveness of our approach isnot limited to message passing systems or process symmetries.a.
performance improvementthe performance bottleneck of our approach lies in the sizeof the colored graph.
first allowed assignments for constraintsoften contribute the largest portion of the graph size.
for aconstraint withnvariables as discussed in sectioniv d1 in order to reduce its time consumption one straightforwardway is keepingnas small as possible.
so we break downa constraint into a set of sub constraints and guarantee that22table ii symmetry reduction results i on a windows laptopwith intel .4ghz and gb memory with pat .
modelstates without reduction states with reductiongaindining philosophers101544501548990.
.
14om1313052 three tiered architecture3 .
.
3188272ot non deterministic two hop coloring protocol in undirected rings31382444296.
.
5omot the logical conjunction of sub constraints is equivalent tothe original constraint.
this method has a side effect itincreases the number of constraints.
fortunately this effect isnegligible because the time consumption for computing allowedassignments is much more sensitive to the number of variablesin a constraint than to the number of constraints and theperformance bottleneck is its time consumption instead of itsmemory.
second we have observed that users may sometimesdefine larger variable domains than necessary.
our approachdoes not rely on the exact domain of variables but can takeadvantage of it to construct a smaller colored graph.b.
symmetry reductionwe apply detected symmetries to the depth first explorationof the whole state spaces of system configurations.
a classiccanonicalization function is used to calculate a uniquerepresentative for each equivalence class of states i.e.
applyingall the automorphisms to a visited state to find the lexico graphically smallest image.
table ii contains the experimentalresults before and after symmetry reduction for part of systemsconfigurations in table i. in the table statesmeans the numberof states stored ommeans exploring the configuration ran outof memory otmeans more than hours andgainmeans therelative improvement on stored states brought by symmetryreduction.
for the conducted experiments the saving in termsof memory is .
in average.the computational overhead of symmetry reduction stemsfrom checking whether the unique representative state of avisited state has been explored.
thus calculating representativestates would be costly in time if there are a large numberof automorphisms.
it is known as constructive orbit problem cop which isnp hard in general .
in practice only sys tems with full symmetries are supported by existing symmetryreduction approaches because representatives can be efficientlycalculated in polynomial time.one way of relaxing the prohibitive time requirement of copis to allow multiple representatives for each equivalence classof states.
table iii contains the experimental results for statespace exploration without symmetry reduction with symmetryreduction using unique representative and with symmetryreduction using multiple representatives.
from the table itis shown that multi representatives symmetry reduction storesmore states than single representative as expected.
here weconsider the algorithm of calculating multiple representativescalled local search in which is only dependent on thegenerators of an automorphism group.
a group with a largenumber of elements has a much smaller number of generators.so the multi representatives approach is much faster than thesingle representative one in most cases.
it remains our futurework to solve the cop problem efficiently for certain classesof automorphism groups in practice.vi.
relatedworkthe importance of detecting symmetries for state spaceexploration has garnered much interest in recent years andseveral methods have emerged.
the discussion on each methodwill largely be focused on the answers to two questions how much effort is required from model designers?
howmany kinds of symmetries can be detected?a.
scalarset methodone of the oldest and most widespread symmetry detectionapproaches is usingscalarset.
it is first introduced by ipand dill in the explicit model checker mur .
scalarsetis a data type which determines an unordered finite set ofconsecutive integer values.
it is a fully symmetric type i.e.
permuting any values of a scalarset type throughout the statespace must result in an automorphism.
so this method is onlycapable of handling fully symmetric components.
for usage a user may define a new scalarset type for a class of fullysymmetric components and assign each component s identifierto a unique value of this type.
then the verifier automaticallyextracts the automorphisms from scalarset types.
in this way scalarsets provide a convenient and efficient way for users todefine symmetries considering the number of automorphismsgenerated by a scalarset is the factorial of its size.
this methodis applied to several other model checkers like spin uppaal .however it has two disadvantages that impose a heightenedburden on designers.
first the applicability of this methodrelies on designers to have expert insights to precisely identifyidentical components in a system.
second in order to makesure the symmetry extraction method is sound a much rigoroussyntactic requirement is placed on operations of scalarsets torule out all possible symmetry breaking constructs.
last butnot least it is applicable only for fully symmetric systems.it is worth to mention that the local variables in our work actas a much more generalized version of the popular scalarset.they both represent a subrange of values.
a local variablemaybe the source of symmetries in a model whereas a scalarsetvariablemustbe the source of symmetries in a model.
sincescalarset variables have to be specified by designers the lackof a computer assisted approach results in correctly expressingsymmetries as wholly the designers responsibility.
but ourapproach automatically identifies which local variables are realsymmetry makers and which operations are symmetry breakingconstructs so as to remove all the burden from designers.23table iii symmetry reduction results ii on a windows laptop with intel .4ghz and gb memory with pat .
modelwithout reductionwith reduction unique with reduction multi statestime sec statestime sec statestime sec dining philosophers1015445015.
.
.2121684801212140536242114917834114om 13130523563om three tiered architecture3 .
.
.
.
.
.
.
ot35524103non deterministic two hop coloring protocol in undirected rings31382410.
.
.643317765118058668334151605om ot6614545718b.
static channel diagramsdonaldson and miler design a fully automatic approach todetecting process symmetries for channel based communicationsystems .
their approach also involves constructinga graph calledstatic channel diagramfrom a promela model whose automorphisms possibly correspond to the automorphismof the kripke structure along with the model.
each node iscreated for each process or channel.
if a process possibly sendsa message to a channel then a directional edge is created fromthe process node to the channel node.
similarly if a processpossibly receives a message from a channel then a directionaledge is created from the channel node to the process node.all process resp.channel nodes representing the same typeof processes resp.channel have the same unique color.
thegenerators for the automorphism group in the static channeldiagram are computed using a graph automorphism algorithm.but a computed generator may not be a real automorphismin the state space.
in order to preserve the soundness of thedetection approach each generator obtained from the diagramhas to be validated that it transforms the original programpinto an equivalent program with the complexityo p log p .similar to scalarset approaches there is a series of limitationson input promela programs to rule out symmetry breakingconstructs.
one of them is disallowing the use of processidentifiers in relational and arithmetic operations which iscommonly thought to be the source of breaking symmetries.however it is not necessary the case in many systems such asthe motivating example.
they propose a straightforward strategyto relax this restriction i.e.
rewriting a relational or arithmeticoperation into a disjunction of all possible combinations ofvariable valuations.
but the validity checking for each generatorwould suffer a significant loss in performance because the sizeof the program becomes at mosto nk of the original one wherenis the largest size of domains of variables representingprocess identifiers andkis the highest arity of any relationalor arithmetic operations involving these variables.lastly our method is remotely related to an on the flysymmetry detection and reduction approach proposed bywahl and d silva .
it starts a reachability checking withthe assumption that all processes are fully symmetric.
aseach transition is analyzed the asymmetries it induces areused to partition the processes.
our approach can deducehow an arbitrary transition breaks symmetries not limited toprocess symmetries prior to model checking.
so combiningtwo approaches can potentially improve the performance ofsymmetry reduction.vii.
conclusion andfutureworkthe main contribution of our work is a new automaticsymmetry detection approach.
to the best of our knowledge ourstudy is the first work to relax all the syntactic restrictions on themodel form and also the first work to consider various processsymmetries data symmetries and their combinations.
a varietyof case studies showed that the overhead of symmetry detectionis negligible and detected symmetries save the majority of astate space to be explored.a line of our future work is to design efficient algorithmsfor calculating representative states for automorphism groupsthat satisfy certain structural properties and are often used inpractice.
all existing symmetry detection approaches onlywork on one instance of a parameterized system at a time.we observe that for a parameterized system the distinctivefeatures of symmetries are often determined by the essenceof the system structure rather than concrete valuations ofthe parameters.
so the other interesting line of future workis to provide a once for all solution of obtaining universalsymmetries for the entire instances in a parameterized system.acknowledgementswe thank the anonymous reviewers for their invalu able comments.
this work is supported by project idd11100102a idg31100105a from singapore universityof technology and design and in part by ntu nap project formal verification on cloud from nanyang technologicaluniversity.