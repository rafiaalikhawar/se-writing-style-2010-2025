a trace simplification technique for effective debugging of concurrent programs nicholas jalbert eecs department uc berkeley ca usa jalbert cs.berkeley.edukoushik sen eecs department uc berkeley ca usa ksen cs.berkeley.edu abstract concurrent programs are notoriously di cult to debug.
we see two main reasons for this concurrency bugs are often di cult to reproduce traces of buggy concurrent executions can be complicated by ne grained thread interleavings.
recently a number of e cient techniques have tried to address the former reproducibility problem however there is no e ective solution for the latter trace simplication problem.
in this paper we formalize and prove the trace simpli cation problem is np hard.
we then propose a heuristic algorithm tinertia that transforms a buggy execution trace into an easier to understand simpli ed trace.
tinertia works by automatically and iteratively increasing the granularity of the thread interleavings in the buggy trace.
tinertia cannot guarantee optimal simpli cation however we empirically show that our algorithm often generates optimally simpli ed traces.
moreover we show that in the simpli ed trace the locations of preemptive context switches point to the cause of the bug.
we have implemented tinertia in a tool for c c programs using pthreads and applied it to benchmarks with up to lines of code.
categories and subject descriptors d. .
testing and debugging d. .
concurrent programming general terms algorithms experimentation reliability .
introduction software is becoming increasingly concurrent to take advantage of the multicore trend in hardware.
unfortunately concurrent programs are notoriously di cult to debug compared to their sequential counterparts.
we see two main reasons for this bugs due to concurrency happen under very speci c thread schedules and are often not reproducible during regular testing.
as a result the cyclic debugging permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa.
copyright acm ... .
.techniques that are e ective for sequential programs cannot be directly applied to concurrency bugs.
the traces generated by concurrent program executions can be complicated and di cult to understand.
we believe that negrained thread interleavings are chief among these complications especially when concurrency bugs are discovered by random scheduling based testing techniques or by recording real world production executions.
for the reproducibility problem a number of light weight and e cient techniques have been proposed to record and replay a concurrent execution .
a record and replay system dynamically tracks the execution of a concurrent program recording the non deterministic choices made by the scheduler.
a trace is produced which allows the program to be re executed forcing it to take the same schedule.
if captured in a trace a concurrency bug can be replayed consistently during debugging.
despite advances on the reproducibility problem the second problem remains a trace of a buggy execution can be complicated by the ne grained interleaving of various threads.
fine grained thread interleavings signi cantly increase the number of potential thread interactions one must reason about to understand a trace.
hence it is often desirable to create a simpler execution trace that shows the same bug but increases the granularity of thread interleavings.
to address this problem we propose an algorithm tinertia to automatically transform the trace of a buggy concurrent execution into a simpler trace with a coarsergrained thread interleaving that exhibits the same bug.
the simpli ed trace can then be used in debugging instead of the more complicated original one potentially relieving the programmer of some of the burden associated with reasoning about ne grained dependencies among threads.
in this paper we show that the general problem of simplifying a trace is np hard.
tinertia is a heuristic algorithm that runs in time polynomial in the size of the trace it computes a locally optimal simpli cation instead of the globally optimal simpli cation.
tinertia simpli es a buggy trace by greedily performing merges and removals on a trace to generate simpler intermediate traces.
an intermediate trace is then executed to validate that it is feasible and exhibits the bug.
thus the tinertia algorithm applies a purely experimental approach in the spirit of delta debugging to the problem of trace simpli cation.
we have implemented tinertia for c c programs with pthreads in a tool called thrille and applied this tool to benchmark programs having to over lines of code with known or seeded bugs.
our experiments show thread f l a g x i f x e r r o r thread while !
f l a g s l e e p x f l a g figure example program.
t2 while !
f l a g t2 s l e e p t1 f l a g t2 while !
f l a g t1 x t2 x t1 i f x t2 f l a g t1 e r r o r figure example buggy trace.
thrille produces nearly optimal simpli ed traces.
moreover we show that the simpli ed traces have at most preemptive context switches excepting one benchmark supporting the observation that most concurrency bugs can be caught with few preemptive context switches .
a manual check of a number of simpli ed traces con rmed the cause of the bug could be easily pinpointed by examining remaining preemptive context switches.
finally we address the argument that a debugging tool like thrille is unnecessary because one could use a context bounded model checker such as chess that returns a simpli ed trace by default to nd concurrency bugs we empirically show that a combination of race directed random testing and simpli cation is more e cient than basic context bounded model checking for a large fraction of our benchmarks.
the contributions of this paper are as follows we formally model the trace simpli cation problem and prove it is np hard.
we propose a heuristic trace simpli cation algorithm tinertia which greedily applies two types of simplifying operations to a buggy trace.
we describe the rationale behind each operation and provide empirical evidence as to their e ectiveness.
we describe an implementation of the tinertia algorithm for c c programs.
we experiment on programs from the parsec and inspect benchmark suites to show the e cacy of tinertia empirically.
.
overview in this section we informally describe the operation of our trace simpli cation algorithm tinertia on an example.
consider the program in figure .
assume all variables are initially all statements execute atomically on a sequentially consistent memory model and both threads run concurrently.
notice there is a data race over setting the value of variable x. if thread executes x after thread executes x but before thread checks the branch condition the program will hit an error.
we de ne an action to be an atomic statement executed by a particular thread.
for example thread executing the statement flag is an action.
a trace of a program execution is a list of actions.
figure is an example of a trace that exhibits a bug.
a trace can be viewed as a description of a serialized execution of a multithreaded programthat captures a thread interleaving.
we call two consecutive actions in a trace a context switch if the actions belong to di erent threads.
the trace in figure has seven context switches.
a non preemptive context switch is a context switch where the descheduled thread is disabled by the semantics of the program.
a preemptive context switch orpreemption is a context switch where the descheduled thread could have continued execution.
all context switches in the trace in figure are preemptive context switches except for the context switch occurring between action and action .
this is a non preemptive context switch because thread terminates and cannot legally execute any instruction.
using terminology from we refer to a maximal set of consecutive actions by the same thread as a thread execution interval tei .
the rst two actions of the trace in figure where thread executes an iteration of the spin loop is an example of a tei of thread .
every trace is composed of one or more teis and the number of context switches in a trace is one less than the number of teis.
the input to tinertia is a trace of a buggy multithreaded execution and the output is a simpler trace which exhibits the same bug.
we describe the output trace as a varianttrace of the original input trace.
a bug can be any distinguishable behavior of a program typical bugs include deadlocks segmentation faults and assertion failures.
our metric for trace simplicity and interleaving granularity is the number of context switches in a trace a trace with fewer context switches is simpler than a trace with more context switches.
given a buggy trace we would like to generate the simplest variant trace of .
that is we would like to generate the variant trace with the minimal number of context switches of all variant traces.
in section we show this trace simpli cation problem is np hard.
tinertia is a heuristic algorithm that iteratively applies a simplifying operation to a trace to generate a simpler intermediate trace.
an intermediate trace is validated by executing it.
if the intermediate trace describes a feasible program execution and exhibits the bug i.e.
it is a variant trace tinertia keeps the intermediate trace and continues to apply simplifying operations to it.
if the intermediate trace is invalid or does not exhibit the bug the simplifying operation is undone and a di erent simplifying operation is tried.
tinertia terminates when no simplifying operation can be applied to produce a valid variant trace.
the core simplifying operations performed by tinertia are the removal of the last tei of a thread and the merging of two teis.
we further subdivide the merging operation into two di erent forms two stage consolidate up and consolidate down.
we now describe the simplifying operations that tinertia performs on a trace remove last this operation is applied to a speci c threadtin the trace and generates a simpler trace by removing the last tei of thread t. this operation can remove extraneous threads and teis which do not contribute to the bug.
if this operation is successful at least one context switch is removed.
two stage consolidate up this operation is applied to a speci c action ain the trace and only has an e ect if ais the last action of a tei.
let thread t be the thread that executes action a. this operation is two stage in the sense that it rst operates at the tei granularity and then at the action granularity.
in the rst stage the operation nds the next tei after a1 t2 while !
f l a g t2 s l e e p t1 f l a g t2 while !
f l a g t1 x t2 x t1 i f x t1 e r r o r figure the variant trace generated by the remove last simplifying operation.
which is executed by thread tin the trace.
this operation then generates a new trace by removing that tei and inserting it directly after a. if this move produces a valid variant trace the operation terminates.
if the rst stage is not successful the second stage is executed.
the moved tei is returned to its original trace position.
then the maximal potentially empty pre x of actions of that tei is removed and inserted afterasuch that a valid variant trace is produced.
if successful the rst stage of the operation removes at least one context switch this can eliminate context switches unrelated to the bug that resulted from scheduling nondeterminism.
the second stage removes no context switches overall but can eliminate preemptive context switches by extending a tei until the executing thread becomes disabled.
consolidate down this operation is symmetric to the rst stage of consolidate up.
it is applied to a speci c action ain the trace and only has an e ect if a is the rst action in a tei.
let thread tbe the thread that executes action a. this operation nds the most recent tei of thread twhich was executed previous to a and then generates a new trace by removing that tei and inserting it directly before a. each successful application of this operation eliminates at least one context switch.
this operation can remove spin loops in traces where thread t1is waiting for thread t2to act in this case moving t1 s tei to the point after t2 performs its action causes t1to no longer wait.
tinertia rst applies the remove last operation to each thread until no progress can be made.
then a forward pass is made over the trace and the two stage consolidate up operation is applied to each action in the trace.
following that tinertia applies the consolidate down operation to each action in a reverse pass.
once this is completed tinertia starts again with remove last operation and continues through the phases until no progress can be made.
we now describe the application of the tinertia algorithm to the buggy trace in figure .
tinertia rst applies the remove last operation to each thread in the trace until no progress can be made.
figure shows the resulting variant trace.
the algorithm was able to successfully remove the action corresponding to thread resetting the ag action in figure because this action is extraneous and does not a ect thread hitting error .
this operation removes two context switches.
next tinertia takes the variant trace that resulted from applying the remove last operation and attempts to apply the two stage consolidate up operation to each action in turn going from the rst action in the trace to the last action.
the result of this pass is the variant trace in figure .
t2 while !
f l a g t2 s l e e p t1 f l a g t1 x t2 while !
f l a g t2 x t1 i f x t1 e r r o r figure the variant trace generated by the twostage consolidate up simplifying operation.
t1 f l a g t1 x t2 while !
f l a g t2 x t1 i f x t1 e r r o r figure the variant trace generated by the consolidate down simplifying operation.
this will be the simpli ed trace returned by tinertia .
when applied to the second action in figure the rst stage of the two stage consolidate up operation fails to produce a valid variant trace.
in this case it attempts to move the tei consisting of action and place it directly after action .
this however is an invalid trace because the ag has not been set yet.
thread will execute the spin loop again and will not execute the statement x at the appropriate point.
the second stage of two stage consolidate up also does not make progress as the only non empty pre x of the moved tei is the entire tei.
however a valid variant trace is generated when the twostage consolidate up operation is applied to action of the trace of figure .
in this case the operation moves the tei consisting of action to directly after action .
thread setting x action and thread checking the ag action are independent and thus commute.
this variant trace has two fewer context switches and is the only progress that the two stage consolidate up operation makes in this pass.
tinertia then takes the trace that resulted from the twostage consolidate up pass in figure and attempts to apply the consolidate down operation to each action in the trace starting at the last action and working toward the beginning.
the result of this pass can be seen in figure .
consolidate down is able to eliminate thread s initial iteration of the spin loop.
when the operation is applied to action in the trace in figure it moves thread s tei corresponding to the execution of the spin loop past the setting of flag.
this eliminates the need for thread to spin at all.
notice the actual trace generated by consolidate down has thread spinning once after the ag is set while thread will not spin at all when the trace is validated by execution.
we discuss how we implement this variant trace validity approximation in section .
.
.
the result of this pass is that one context switch is removed.
tinertia now attempts to again apply each operation to the trace in figure .
no operation will be able generate a valid variant trace so tinertia terminates and returns the variant trace in figure as the simpli ed trace.
in this example the tinertia algorithm returns the variant trace that is minimal in the number of context switches with ve fewer context switches than the original trace .
delta debugging is an automated search strategy for simplifying inputs which cause failure .
the deltadebugging based algorithm proposed by choi et al.
in is related to tinertia however the goals of the two algorithms are orthogonal.
their algorithm takes as input a passing trace pand failing trace fand generates a new passing trace p0and new failing trace f0such that every di erence between p0andf0is necessary to cause the bug.
the insight in that work is the di erences between p0and f0will illuminate the cause of the bug.
however there are no facilities in their algorithm to try to produce a simpler trace the simplicity of the resulting p0andf0depend heavily on the input traces.
indeed one can imagine fruitfully combining the two algorithms by rst simplifying the failing trace and then using the simpli ed trace as input to the delta debugging algorithm.
the execution reduction system described in by tallam et al.
has a similar goal to tinertia i.e.
to simplify a buggy trace.
their work targets event driven systems and does a thorough tracking of dynamic dependencies between threads to identify and remove irrelevant threads and teis.
tinertia on the other hand takes a purely experimental approach which could result in better simpli cation in cases where dynamic dependencies semantically commute.
their primary metric of simpli cation is the length of a trace.
we argue that the number of context switches i.e.
the granularity of the thread interleavings is an important metric of the simplicity of a trace and describe three operations which can be applied to a trace to reduce the number of context switches.
one could usefully combine the execution reduction system with tinertia rst run execution reduction on a buggy trace to remove unnecessary threads and teis and then run tinertia on the resulting trace to increase the granularity of the thread interleavings.
.
algorithm now that we have informally examined the operation of thetinertia algorithm on a small example in this section we formally model the problem of trace simpli cation and situate the tinertia algorithm within our formal model.
.
background definitions consider a multithreaded program execution.
let tbe the set of threads that are in the execution and let sbe the set of instructions executed by the threads in the execution.
we call the execution of an instruction s2sby a thread t2tanaction and denote it by the pair t s .
we uset a ands a to denote the thread and instruction of the action a respectively.
a multithreaded program execution can be seen as a sequence of actions.
we call such a sequence a trace and denote it by .
we will use to denote the ith action in the trace and to denote the subsequence .
in the rest of the discussion assume that we are given a trace a1a2 a n. we refer to a maximal set of consecutive actions by the same thread in a trace as a thread execution interval tei .
a tei is a subsequence of trace de ned as follows j ort t k nort t and 8l2 t t we say a trace of a multithreaded execution exhibits a bug if at the end of the execution the program state satis es a predicate say that denotes the bug.
for the rest of thisdiscussion assume trace exhibits a bug by satisfying at the end of its execution.
the goal of tinertia is to compute a simpli ed trace minsuch that the state of the program after executing minsatis es .
we next de ne the notion of simpli cation formally.
we say that two actions aiandajare related by the program order relation denoted by ai!paj i i j and t ai t aj .
let us call a trace 0avariant trace of if the following conditions hold 0is a permutation of a subset of the actions of 0denotes the pre x of a trace of a feasible multithreaded program execution the program state after executing 0satis es and 0conforms to the program order relation i.e.
if ai!p ajin andajis present in thenaiappears before ajin .
we can also associate a cost function with a trace the cost of a trace is equal to the number of context switches in the trace.
note that cost is equal to the number of teis in minus one.
.
problem definition as described earlier we are given a trace a1a2 a n of a multithreaded execution that satis es the bug predicate at the end of the execution.
we want to nd a varianttrace minsuch that cost min is the minimum of the cost of all variant traces of .
formally lettmin f 0j is a variant trace of and for all variant traces 00of cost cost g. the goal of our algorithm is to return an element oftmin.
such a trace minimizes the number of context switches in the multithreaded execution.
in our view such a trace is simpler than the original buggy trace.
unfortunately the problem of nding an element of tmin is np hard.
we next prove this claim.
theorem .
.
the problem of nding an element of tmin is np hard.
proof.
sketch consider a pair a whereais a set of actions and is a partial order relation on a. we require that minimally relates all pairs of actions ai aj2asuch thataiandajare from the same thread.
inter thread dependencies may also appear in .
an observed buggy trace is a linear order on asuch that the trace conforms to i.e.
ifaiappears before ajin then it must not be the case thataj ai.
assume that the bug is exhibited by any trace which is a linear order on aand conforms to .
then a trace simpli cation problem a is to come up with a linear order on athat conforms to and has the minimum number of teis.
note that we use to represent the error predicate .
in a real program we can assume that represents the re exive transitive closure of the union of the data dependency and program order relations.
given a it is easy to construct a program with an execution that satis es i the execution of the program has all actions in aand conforms to .
in the vertex cover problem we are given an undirected graph with vertices vand edgese.
the task is to select the minimum set of vertices w vsuch that every edge in the graph is adjacent to one of the vertices in w. the vertex cover problem is well known to be np complete.
we now reduce vertex cover to the trace simpli cation problem.
we assume we are given an arbitrary graph g v e on which we must nd the minimum vertex cover.
we now construct a trace simpli cation problem a whose solution would correspond to the minimum vertex cover.
for each vertex in v2v we create a unique thread tv.
for each vertexvwe then generate two actions tv i1 and tv i2 ina.
since in our problem setting we need a total order over all the actions from a given thread we add the relation tv i1 tv i2 to for each vertex v. for each edge uvin e we add tu i1 tv i2 and tv i1 tu i2 to .
let be a linear order on athat conforms to and minimizes the number of teis.
let tbe the set of threads such that for each t2t has two teis from the thread t. let wbe the set of the vertices that correspond to the threads int.
thenwis the minimum vertex cover for gbecause by construction each thread must have at least one tei in .
if there is an edge between two vertices in g at least one of the threads corresponding to the two vertices de ning the edge must have two teis in by the way we constructed the relation .
thus the set of vertices whose corresponding threads have more than one tei in is a vertex cover and it is minimal because has a minimal number of teis.
this shows that trace simpli cation problem is np hard.
.
tinertia algorithm given the problem of trace simpli cation is np hard we do not expect to nd an e cient algorithm for it.
therefore we propose tinertia a heuristic algorithm.
let us de ne three primitive operations on a trace remove i is the trace obtained by removing from .
for example if a1 a i 1aiai a n then remove i a1 a i 1ai a n. insert i a is the trace obtained by inserting the actionaimmediately after the action .
for example if a1 a iai a n then insert i a a1 a iaai a n. move i j is the trace insert remove j i note that the operations remove and move could be applied repeatedly to obtain any trace that is a permutation of a subset of the actions of the original trace.
we next de ne four composite operations that we will use to describe our algorithm.
.
operation move up tei i moves the next tei after the action of thread t immediately after the action.
formally move up tei i is valid i is the last action of a tei in and is the next tei of the thread t after the action .
then let j and l move l i l j l .
then move up tei i k. note that if move up tei i is valid and a variant trace of then cost cost move up tei i .
.
operation move up actions i m moves the pre x of the next tei after the action of threadt immediately after the action.
formally move up actions i j is valid i is the last action of a tei and is a pre x of the next tei of the thread t after the action .
then let j and l move l i l j l .
then move up actions i m. note that if move up actions i is valid and a variant trace of then cost cost move up actions i m .algorithm greedy simpli cation algorithm input a trace and a bug predicate cur repeat old cur fori j curjto 1do ifremove last tei cur i is a variant trace of then cur remove last tei cur i end if i minimum of i andj curj end for fori toj curjdo ifmove up tei cur i is a variant trace of then cur move up tei cur i else if move up actions cur i m is a variant trace of for some maximal mthen cur move up actions cur i m end if end for fori j curjto 1do ifmove down tei cur i is a variant trace of then cur move down tei cur i end if end for until cost old cost cur return cur .
operation move down tei i could be de ned symmetrically.
it moves the previous tei before the action of thread t immediately before the action.
formally move down tei i is valid i is the rst action of a tei and is the previous tei of the thread t before the action .
then let k and l move l i j .
then move down tei i j. note that if move down tei i is valid and a variant trace of then cost cost move down tei i .
.
operation remove last tei i removes the last tei of threadt if is the rst action of the last tei of the thread t .
formally remove last tei i is valid i is a tei for some jand is the last tei of the thread t .
then let j and l remove l l .
then de ne remove last tei i i. note that if remove last tei i is valid and a varianttrace of cost cost remove last tei i .
algorithm is a formal description of the tinertia algorithm.
tinertia takes as input a trace and a bug predicate which is satis ed by the state of the program after the execution of .
all simplifying operations are applied to cur and whenever the application of an operation produces a valid variant trace that trace is stored into cur.
tinertia begins by initializing curto the input trace .
the algorithm then enters the main loop.
in lines the algorithm does a reverse pass over trace cur applying the remove last tei operation to to each index of the trace.
this is equivalent to the reverse pass of the remove last simplifying operation described in section .
if the application of remove last tei cur i produces a valid variant trace of cur for some index i it is unnecessary to execute the last tei of threadt cur to produce the bug.
in lines tinertia does a forward pass over the variant trace generated by the previous pass.
this is a pass of the two stage consolidate up simplifying operation described in section .
for each action in the trace cur the algorithm rst performs the move up tei operation.
ifmove up tei cur i produces a valid variant trace two tei were successfully merged and the simpli ed variant trace is saved.
if the application of move up tei fails the algorithm then performs move up actions cur i m for some maximal m. that is the maximal potentially empty pre x of the tei following cur is merged with the tei of cur .
this operation can remove a preemptive context switch and replace it with a non preemptive context switch.
the nal pass of the main loop is performed in lines .
this is a reverse pass of the consolidate down simplifying operation over the variant trace generated by the previous two passes.
the operation move down tei is applied to each action in the trace.
if the application of move down tei creates a valid variant trace two tei were successfully merged.
tinertia executes the main loop until no composite operation applied to any action of the trace curcan produce a valid variant trace.
tinertia then terminates and returns curas the simpli ed trace.
theorem .
.
the worst case time complexity of algorithm iso j j3 .
proof.
sketch each of the forloops at line and has an upper bound of j jiterations.
cost decrements by at least one in each iteration of the outer loop at line so the outer loop can run for a maximum of j jiterations.
therefore o j j2 is an upper bound on the number of simplifying operations and variant trace validity checks which costo j j .
therefore the entire algorithm is o j j3 .
theorem .
.
the trace curreturned by algorithm is a local minimum in the following sense.
there exists noisuch that remove cur i is a variant trace of and cost remove cur i cost cur .
and there exists no i andjsuch that move i j is valid and a variant trace of and cost move cur i j cost cur .
.
implementation we have implemented the tinertia algorithm in a tool called thrille for c c programs that use pthreads.
our implementation is divided into two components trace transformation and trace validation.
the trace transformation component iteratively generates simpli ed traces the trace validation component determines if a generated trace is a valid variant trace.
thrille takes as input a program and a replayable buggy trace.
in general deterministic replay requires controlling all sources of non determinism in the program.
for our benchmarks it is su cient to x inputs control the scheduler and deterministically seed random number generators.
thrille controls scheduler non determinism by serializing program execution and selectively allowing threads to execute.
dynamic library interposition is used to intercept the synchronization events in a program.
when a synchronization call is made thrille takes over execution and decides which thread to schedule next.
in programs with data races bugs may manifest under ner grained interleavings than is possible to achieve while scheduling only at synchronization events.
to capture and reproduce these bugs we compile the target program or program module using the llvm tool chain .
during compilation we execute a pass which instruments all load and store instructions with a call into thrille .
for eachof our benchmarks we run race detection to identify potentially racing memory accesses and then during simpli cation thrille makes scheduling decisions at these accesses.
.
trace transformation the trace transformation component repeatedly applies the remove last two stage consolidate up and consolidate down simplifying operations to generate simpler intermediate traces.
if merging two teis fails in the rst stage of two stage consolidate up we then must nd the maximal pre x of the second tei that can be merged with the rst tei in stage two.
for e ciency we approximate this by automatically examining the trace of the failing execution and generating a new trace that merges all actions that were executed from the second tei in the failing trace.
.
trace validation the trace validation component executes a trace 0to determine if 0is a valid variant trace of the original buggy trace .
minimally this component must be able to replay a trace and detect any program errors.
inthrille a trace is simply a listing of which thread to execute at each synchronization or racing memory operation and not say a record of all memory reads and writes .
our implementation models pthread semantics to determine what executions are legal.
a trace is executed until an error is detected or the program terminates normally.
the trace validation component detects errors including deadlocks segmentation faults and assertion failures.
we note assertions allow for arbitrarily precise descriptions of bugs.
.
.
approximating variant trace validity in our initial experiments we observed that a strict variant trace validity check unnecessarily discards many intermediate simpli ed traces.
this is because reordering teis can reorder memory dependencies and change the control ow within a tei.
such reordering can result in a simpli ed trace which still exhibits the bug but is not necessarily a variant trace of the original trace i.e.
the modi ed trace is not a strict linear order of a subset of actions of the original trace.
thrille implements an approximation of the variant trace validity check which is designed to tolerate variations between a trace and the execution induced by the trace.
during execution thrille attempts to execute each tei in the order in which it appears in the trace.
the following inconsistencies can occur control flow changes a thread may deviate from its expected execution path.
if this occurs the thread is executed until its execution rejoins the expected path in which case the remaining actions of the tei are completed.
the thread may also block or enter livelock without rejoining the tei in which case the next tei in the trace is executed.
disabled threads a thread may block before executing its whole tei.
if this occurs the next tei in the trace is executed.
condition variables a previously missed signal may no longer be missed in which case a waiting thread is randomly chosen to signal.
no bug at the end of a trace if the program has not terminated but also does not exhibit the desiredbug we continue execution in a non preemptive fair way until a bug is found or execution terminates.
when execution terminates thrille performs an approximation of the variant trace validity check.
let actual be the trace of the actual execution induced by the trace 0after all inconsistencies are accounted for.
if actual exhibits the bug and cost actual cost then 0is considered a valid variant trace and simpli cation continues on actual .
if actual does not satisfy both of these properties 0is considered an invalid variant trace.
note this approximation guarantees termination of the algorithm and that any returned simplied trace will exhibit the same bug as the original trace.
.
experimental ev aluation we evaluated thrille on c and c multithreaded benchmarks.
our set of benchmarks consists of programs from the parsec benchmark suite and the inspect benchmark suite .
the following programs came from parsec blackscholes is an option pricing simulation canneal implements a simulated annealing algorithm to minimize the routing cost of a chip design dedup is a data stream compression program streamcluster is an online clustering kernel and x264 is a threaded video compression library.
the following programs came from the inspect benchmark suite bbuf is a toy implementation of a shared bu er bzip2 and pbzip2 are both multithreaded compression programs ctrace is a multithreaded tracing library pfscan is a parallel le scanner and swarm is a parallel sort implementation.
to generate the initial buggy traces we implemented a variant of race directed random testing where we considered both data races and lock contentions.
the benchmarks pbzip2 and swarm had bugs which we could reproduce in our trace generation step.
for the other programs we seeded bugs by modifying synchronization operations.
we chose this approach because we do not propose a novel way to discover bugs and thus the exact nature of the bug is less important.
we ensured that all seeded bugs were concurrency related i.e.
all programs with seeded bugs successfully ran under normal circumstances and the bugs manifested non deterministically under rare schedules.
all experiments were performed on a dual socket quadcore xeon server with 8gb of ram.
all results are averaged over runs.
each run consisted of generating a new buggy trace with our race directed random testing implementation and then applying thrille to the trace.
the goal of these experiments was to evaluate the following four hypotheses .
the locally optimal simpli ed traces generated by the tinertia algorithm are close to the global optimal in terms of number of context switches.
.
each simplifying operation performed by the tinertia algorithm contributes to the overall simpli cation.
.
remaining preemptions in simpli ed traces are useful for pinpointing concurrency bugs in the program.
.
a debugging tool like thrille can be useful even though context bounded model checking nds simplied buggy traces by default.
.
optimality of simplification table shows the results of the experiments.
the second column shows the size of each benchmark in lines of c and op mal experimental runs context switches op8mal number of context switches histogram of the context switch op8mality of simplified traces bzip2 dedup pbzip2 pfscan blackscholes figure optimality of simpli ed traces.
c code.
columns show the average characteristics of the start traces.
size is the number of synchronization and memory operations at which thrille made a scheduling choice.
thris the number of threads which execute at least one action in a trace and ctxt is the number of context switches in a trace.
the nonand precolumns further break down the number of context switches.
nonreports the number of non preemptive context switches in the trace pre reports the number of preemptive context switches.
columns report the averages of these characteristics for the simpli ed traces.
note that due to the varianttrace validity approximations described in section .
.
certain characteristics e.g.
size of a trace can actually increase.
for all benchmarks except for ctrace thrille generated simpli ed traces which averaged preemptive context switches.
because a program should behave correctly irrespective of whether a preemptive context switch is made we expect that any remaining preemptions in a simpli ed trace are necessary to cause the concurrency bug.
therefore a simpli ed trace with few preemptive context switches will signi cantly reduce the debugging e ort by reducing the number of places in the trace where we need to look for the cause of the bug.
columns report the average percent reduction of the di erent types of context switches due to simpli cation.
for all benchmarks thrille was able to generate simplied traces with or more of the preemptions removed column .
the percent reduction in overall number of context switches varies more widely column the maximum possible reduction is dependent on both the design of the benchmark program and how the bug manifests.
to validate our hypothesis that tinertia generates nearly optimal traces with respect to number of context switches we manually generated buggy traces with an optimal number of context switches for ve of our benchmarks.
note that we did not do this for all benchmarks because creating the optimal trace for each benchmark is a tedious and time consuming process.
for each simpli ed trace generated in our experiments from the examined benchmarks we binned the di erence between the number of context switches in the simpli ed trace and the number of context switches in the optimal traces.
figure shows a histogram of the results of this study.
for all the examined benchmarks over of the simpli ed traces were within context switches of optimal.
moreover the tinertia algorithm does nontrivial work in all cases.
average percentage reduction in context switches ranges from for blackscholes to over for all other examined benchmarks column in table .
these re program loc start trace simpli ed trace reduction name size thr ctxt non pre size thr ctxt non pre ctxt non pre bbuf .
.
.
.
.
.
.
.
.
.
.
.
.
blackscholes .
.
.
.
.
.
.
.
.
.
.
.
.
bzip2 .
.
.
.
.
.
.
.
.
.
.
.
.
canneal .
.
.
.
.
.
.
.
.
.
.
.
.
ctrace .
.
.
.
.
.
.
.
.
.
.
.
.
dedup .
.
.
.
.
.
.
.
.
.
.
.
.
pbzip2 .
.
.
.
.
.
.
.
.
.
.
.
.
pfscan .
.
.
.
.
.
.
.
.
.
.
.
.
streamcluster .
.
.
.
.
.
.
.
.
.
.
.
.
swarm .
.
.
.
.
.
.
.
.
.
.
.
.
x264 .
.
.
.
.
.
.
.
.
.
.
.
.
table experimental results.
data is averaged over runs for each benchmark.
pbzip2 .
cpp void consumer void q f i n i t i a l i z a t i o n for f pthread mutex lock f i f o mut check i f compression i s done pthread mutex unlock f i f o mut do compression work gg void queuedelete queue q f i f q null return i f q mut !
null f pthread mutex destroy q mut d e l e t e q mut q mut null gg figure real segmentation fault in pbzip2 .
sults suggest that the locally optimal traces calculated by thetinertia algorithm are nearly optimal in a global sense validating our rst hypothesis.
traces with a coarser thread interleaving granularity signi cantly reduce the number of potential thread interactions one must reason about when diagnosing a bug hence we believe these optimality results argue strongly for the tinertia algorithm.
.
contribution of simplifying operations during each run of thrille we recorded the contribution to simpli cation in terms of context switches removed attributable to each simplifying operation.
this data showed that two stage consolidate up was a major contributor to simpli cation in most of the benchmarks but both the remove last and consolidate down operations were responsible for greater than of the simpli cation of at least one benchmark.
we conclude that each of the simplifying operations performed in tinertia contributes to the overall calculation of the simpli ed trace.
.
pinpointing bugs with simplified traces our third hypothesis is that the preemptions in a simplied trace are useful for pinpointing the concurrency bug.
to validate this hypothesis we examined the results of several of our experimental runs.
we found that preemptions often pointed directly to the cause of the bug.
we illustrate this observation for one of our benchmarks.
figure shows the real bug in the pbzip2 benchmark.
improper synchronization can allow the main thread to execute clean up code before all worker threads have terminated.
if a worker thread attempts to grab a mutex that has been destroyed and set to null by the main thread the program will crash with a segmentation fault.in the run we examined the initial trace of the segmentation fault consisted of context switches of which were preemptive and of which were non preemptive.
given this trace thrille generated a simpli ed trace which had context switches of which was preemptive and of which were non preemptive.
in the simpli ed trace the main thread calls the queuedelete clean up method passing fifo as the argument.
the preemption occurs directly after the main thread sets q mut tonull in line .
a worker thread is then scheduled and attempts to lock the null mutex on line .
this results in a segmentation fault on our test server.
we note the preemptive context switch in the simpli ed trace occurs exactly in the buggy code.
.
performance table reports the runtime characteristics of the thrille tool.
all numbers are averaged over the runs for each benchmark.
bug type column is a description of how each bug manifests.
iters column reports the average number of iterations taken through the main loop of the tinertia algorithm.
execs column reports the number of times thrille re executes the program validating an intermediate trace.
time sec is the average time it takes in seconds to simplify a trace.
for all benchmarks average simpli cation time took less than minutes often much less .
the thrille implementation is unoptimized but given the average time spent debugging we believe that even in its current form the bene ts of debugging with a simpli ed trace outweigh the time costs of simpli cation.
we also note that similar running times have been reported by other e ective debugging tools in the literature .
further as traces grow longer the tinertia algorithm can be modi ed to operate on a xed size su x of the trace.
this would place an upper bound on the number of re executions while still allowing the programmer to reap most of the bene ts of debugging with a simpli ed trace.
.
comparison with context bounded model checking one could argue there is no need for a debugging tool like thrille because one could use a context bounded model checker such as chess to nd concurrency bugs.
when these model checkers nd a bug they return a simpli ed trace by default.
we now evaluate our hypothesis that the thrille tool can still be useful by comparing the e ciency of the combination of directed random testing and simpli cation with basic context bounded model checking.
to compare thrille with context bounded model checking we implemented the basic chess algorithm describedprogram bug type iters execs time name sec bbuf deadlock .
.
blackscholes deadlock .
.
bzip2 segfault .
.
canneal deadlock .
.
ctrace deadlock .
.
dedup segfault .
.
pbzip2 segfault .
.
pfscan segfault .
.
streamcluster segfault .
.
swarm assert fail .
.
x264 deadlock .
.
table thrille runtime statisticsprogram avg.
avg.
chess chess bug?
name execs time execs time bbuf .
.
yes blackscholes .
.
no bzip2 .
.
no canneal .
.
no ctrace .
.
yes dedup .
.
no pbzip2 .
.
yes pfscan .
.
no streamcluster .
.
yes swarm .
.
no x264 .
.
no table comparison between thrille and chess in .
we ran our chess implementation with a preemption bound of on all of our benchmarks until a bug was found or we had explored interleavings.
the basic chess algorithm is incomplete in programs with data races therefore we adopted a strategy similar to and allowed chess to schedule at the same potential data races at which our race directed random testing implementation could schedule.
this ensured our chess implementation could expose the same bugs as our race directed random testing implementation.
we also used a fair scheduling implementation to prevent divergence on our benchmarks .
table shows the results from the comparison.
column shows the average number of program executions to both nd a bug using race directed random testing and then simplify the bug using thrille .
column shows the average time in seconds to nd a bug and then simplify it.
column shows the number of program executions before our chess implementation found a bug or hit the execution cuto .
column shows the total time of the chess search and column reports whether our chess implementation found a bug before the execution cut o .
in of our benchmarks pbzip2 and streamcluster the basic chess algorithm was clearly the more e cient choice for nding simpli ed buggy traces.
on the ctrace benchmark thrille and chess were roughly tied.
in the other benchmarks our chess implementation was either unable to discover a bug within program executions or was not competitive with the combination of race directed random testing and simpli cation.
we feel these results argue that for certain types of programs and bugs randomized testing with simpli cation can be more e cient than systematic approaches like context bounded model checking.
.
other related work refer to the end of section for discussions of the two work most closely related to ours.
tzoref et al use machine learning techniques to automatically discover potentially buggy program locations in multithreaded programs .
other work show that perturbing the thread scheduler in a concurrent program can increase test coverage and nd bugs .
model checking is a promising technique to nd concurrency bugs in programs before they manifest in the wild however the cause of the bug can be di cult to pinpoint in an error trace returned by a model checker.
a number of research have tried to minimize an error trace and extract useful counterexamples when a bug is found .
statistical sampling techniques can nd bugs in the sequential setting and extensions have been proposed todiscover concurrency bugs .
program slicing is a popular debugging approach that determines which parts of a program are relevant to a particular statement e.g.
a bug .
precise slicing for concurrent programs is undecidable in general but a number of work have investigated e cient approximate approaches for debugging .
di erent trace simpli cation shrinking techniques have been shown useful in debugging functional concurrent languages like erlang .
a large body of research exists on record and replay systems for parallel software .
some of these systems make use of the specialized hardware to make record more e cient .
other systems lower record costs by probabilistically reproducing failures or recording a subset of information required to reproduce a multithreaded execution and o ine work .
.
conclusion debugging a concurrent program is a time consuming and frustrating process.
we believe that useful debugging techniques can be developed through the application of model checking and program analysis techniques.
our work is a small e ective step towards this goal.
thrille is open source and can be downloaded at .