feature maintenance with emergent interfaces m rcio ribeiro federal university of alagoas macei brazil marcio ic.ufal.brpaulo borba federal university of pernambuco recife brazil phmb cin.ufpe.brchristian k stner carnegie mellon university pittsburgh usa abstract hidden code dependencies are responsible for many complications in maintenance tasks.
with the introduction of variable features in configurable systems dependencies may even cross feature boundaries causing problems that are prone to be detected late.
many current implementation techniques for product lines lack proper interfaces which could make such dependencies explicit.
as alternative to changing the implementation approach we provide a tool based solution to support developers in recognizing and dealing with feature dependencies emergent interfaces.
emergent interfaces are inferred on demand based on feature sensitive intraprocedural andinterprocedural data flow analysis.
they emerge in the ide and emulate modularity benefits not available in the host language.
to evaluate the potential of emergent interfaces we conducted and replicated a controlled experiment and found in the studied context that emergent interfaces can improve performance of code change tasks by up to times while also reducing the number of errors.
categories and subject descriptors d. .
coding tools and techniques general terms experimentation keywords product lines interfaces preprocessors controlled experiments .
introduction during maintenance developers often introduce errors into software systems when they fail to recognize module and feature dependencies .
this problem is particularly critical for configurable systems in which features can be enabled and disabled at compile time or run time and market and technical needs constrain how features can be combined.
in this context features often crosscut each other and share program elements like variables and methods without proper modularity support from a notion of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.interface between features.
in such context developers can easily miss cross feature dependencies such as a feature assigning a value to a variable read by another feature.
as there is no mutual agreement between separate feature developers changing one feature might be the correct action for maintaining that feature but might bring undesirable consequences to the behavior of other features.
similar issues could also appear when developers assume invalid dependencies as would be the case if the just discussed features were mutually exclusive.
in a prior study collecting metrics of large scale open source implementations in which features were implemented using the c preprocessor we found that cross feature dependencies are frequent in practice .
to reduce this feature dependency problem we propose a technique called emergent interfaces introduced in a vision paper that establishes interfaces for feature code on demand and according to a given code change task.
an emergent interface is an abstraction of the data flow dependencies of a feature consisting of a set of provides and requires clauses that describe such dependencies.
we call our technique emergent because instead of writing interfaces developers request interfaces on demand that is interfaces emerge to support a specific code change task.
this way developers become aware of feature dependencies and may have a better chance of avoiding errors .
emergent interfaces may also reduce codechange effort instead of searching for dependencies throughout the code and reasoning about requirements level feature constraints developers can rely on proper tool support to infer interfaces.
we implemented emergent interfaces in a tool emergo available as an eclipse plug in for java.
emergo performs feature sensitive dataflow analysis to infer interfaces on demand both at intraprocedural and at interprocedural level.
a key novelty in this paper is an empirical evaluation of emergent interfaces as provided by emergo.
we conducted and replicated a controlled experiment on feature related code change tasks in two software product lines.
the studied product lines are implemented with preprocessor like variability mechanisms which are widely used to implement compile time variability in industrial practice despite their lack of modularity.
in particular we evaluate emergent interfaces by answering two research questions do emergent interfaces reduce effort during code change tasks involving featurecode dependencies in preprocessor based systems?
do emergent interfaces reduce the number of errors during code change tasks involving feature code dependencies in preprocessor based systems?
we consider tasks that involve both intraprocedural andinterprocedural feature dependencies.
we first conducted the experiment in one institution recruiting graduate students as subjects and then replicated it with undergraduate students in another institution.
our experiment reveals that in our settings emergent interfaces significantly reduce maintenance effort for tasks involving inter permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
procedural feature dependencies which cross method boundaries.
both experiment rounds reveal that developers were on average times faster completing our code change tasks when using emergent interfaces.
as for tasks involving only intraprocedural dependencies differences are statistically significant only in one round in which we on average observe a .
fold improvement in favor of emergent interfaces.
in line with recent research in both rounds we observe that presenting feature dependencies helps developers detecting and avoiding errors regardless of the kind of dependency.
in summary we make the following contributions an introduction to emergent interfaces and a complete implementation in emergo supporting not only intraprocedural analysis but also the more powerful interprocedural analysis.
an empirical evaluation assessing the potential of emergent interfaces.
we evaluate effort and error reduction when using emergent interfaces in a controlled and replicated experiment with in total participants in two product lines demonstrating significant potential.
the idea of emergent interfaces was first introduced in a vision paper with an early prototypical implementation approximating intraprocedural data flow analysis .
subsequently we statically analyzed the potential impact of emergent interfaces in open source projects and investigated feature sensitive data flow analyses .
this paper brings together these results and reports on a significantly revised and extended version of emergo that supports precise feature sensitive and interprocedural data flow analysis and complements them with a novel empirical evaluation.
.
maintaining product lines inadequate modularity mechanisms plague many languages and cause many implementation problems.
emergent interfaces are applicable to many situations where explicit interfaces between code fragments are lacking.
while we will hint at many other use cases to illustrate and explore the idea of emergent interfaces we look at a context that is especially challenging to developers due to non modular code fragments and variability preprocessor based software product lines.
configurable systems especially in the form of software product lines are challenging because code fragments are configurable and may not be included in all product configurations.
that is developers need to reason about potentially different control and data flows in different configurations.
at the same time when variability is implemented with preprocessor directives code fragments belonging to a feature are marked annotated but not encapsulated behind an interface.
therefore the control and data flow across feature boundaries is implicit but common as we found in a previous study .
industrial product lines can easily have hundreds of features with a large number of possible derivable products.
when maintaining a product line the developer must be sure not to break any of the possible products as we illustrate next with two scenarios but due to the sheer potential number of them rapid feedback by testing is often too expensive or even not possible for all products.
.
scenario implementing a new requirement the first scenario comes from the best lap commercial car racing game1that motivates players to achieve the best circuit lap time and therefore qualify for the pole position.
due to portability constraints the game is developed as a product line and is deployed on devices.
the game is written in java and uses the antenna c style preprocessor.
to compute the score developers implemented the method illustrated in figure variable totalscore stores the player s total score.
next to the common code non annotated code or annotated with mandatory features the method contains optional code that belongs to feature arena .
this feature publishes high scores on a network server and due to resource constraints is not available in all products.
public void computelevel totalscore perfectcurvescounter perfect curve bonus ... totalcrashes src time multiplier ... ifdef arena networkfacade.setscore totalscore networkfacade.setlevel getlevel public static void setscore int s score s ?
s figure code change only works for some products.
arena feature code in gray.
in this scenario consider the following planned change.
to add penalties in case the player often crashes the car let the game score be not only positive but also negative.
to accomplish the task a developer localizes the maintenance points in this case the totalscore assignment and changes the computation of scores see the bold line in figure .
products without the arena feature now enjoy the new functionality but unfortunately the change is incomplete for products with the arena feature.
in the implementation of feature arena method setscore checks for positive values and prevents submitting negative scores to the network server.
the cause of the problem is that the arena implementation extends the score behavior and is therefore affected by the change.
this was not however noticed by the developer who did not realize that she had to change code associated to other features.
in this case she would have to change part of the arena code to not enforce the invariant that scores are positive.
in the actual implementation featurearena is partially implemented inside method computelevel and guarded with ifdef directives so it might not be so difficult to notice the dependency if the method is small.
however in more complex code or even alternative implementation approaches that separate the feature implementation see section .
below the dependencies across feature boundaries might be harder to track.
in this context searching for cross feature dependencies might increase developers effort since they have to make sure that the modification does not impact other features.
further if they miss a dependency they can introduce errors that potentially only manifest in few variants by not properly completing the code change task for example.
.
scenario fixing an unused variable our second scenario is based on a bug report from glibc .3this project is structured with several preprocessor macros and conditional compilation constructs.
developers report that a variable statusin the common code is reported as unused.
in fact such warnings are commonly found in many bug reports of preprocessor based systems.4investigating the problem we find that status is declared in all configurations but only used when features chown or utimes are selected as shown in figure left hand side .
when and 401580990we compile the product line without either feature the compiler issues an unused variable warning.
gfilestatus status ... ifdef slink... ifdef chown... ifdef utimesstatus status ifdef chowngfilestatus status endif... ifdef slink... ifdef chown... ifdef utimes figure wrong fixing of an unused variable.
to fix the bug report a developer would typically look for uses of the variable.
if she does not carefully look across feature boundaries she can easily introduce an error.
the problem can even be worse when there are requirements level dependencies between features e.g.
that slink cannot be selected without chown .
in an unsuccessful attempt to fix the warning the developer might for example detect only the variable usage in feature chown and then guard the declaration correspondingly as shown in the righthand side of figure .
this would actually lead to a worse problem an undeclared variable compilation error for configurations with utimes but without chown .
the correct fix would require to guard the declaration with ifdef chown utimes .
again the initial problem and the incorrect fix are caused by the difficulty to follow dependencies across feature boundaries.
these are easy to detect in small and simple methods with little variability but might be complicated in larger code bases and when using other language mechanisms that separate feature code see section .
.
.
cross feature dependencies in the wild initially the previously shown examples seem pretty specific requiring preprocessor directives and data flow dependencies.
to quantify their frequency we have previously conducted a conservative study mechanically mining the code base of 43highly configurable software systems with a total of over million lines of code including linux freebsd postgres sendmail gcc and vim.
all these common open source systems make heavy use of preprocessor directives for configuration for features and portability .
even just looking conservatively at intraprocedural data flow within individual methods between and percent of all methods in the studied systems contain cross feature dependencies however typically more than half of the methods with ifdef directives also contain cross feature dependencies.
these numbers only serve as a lower bound since interprocedural data flow between methods was not measured but likely causes additional cross feature dependencies.
these results show that the problem even though quite specific is so common in practice that building dedicated tool support can be beneficial for a wide range of code change tasks.
.
beyond preprocessors we illustrate the problem for preprocessor based product lines but other implementation approaches suffer from limited modularity mechanisms especially implementation approaches supporting some form of crosscutting.
while variability can make cross feature dependencies harder to detect it is by no means necessary.
one of the well known and controversially discussed examples isaspect oriented programming in the style of aspectj.
with aspectj code of features or more generally concerns is separated into distinct code units and reintroduced in a weaving step.
the control flow or data flow between aspects and base code is not pro tected by explicit interfaces a fact for which aspectj was repeatedly criticized but which was also discussed as enabling flexibility .
to mitigate the problem several extensions to aspect oriented languages have been proposed to declare interfaces between concerns .
without such interfaces in aspectj our first example works just as well with an aspect injecting the arena code instead of an in place ifdef block.
other structure driven composition mechanisms such as feature oriented programming delta oriented programming or even just subclassing exhibit similar potential problems.
finally also in the context of preprocessor based implementations recent advances support some separation of feature code.
to deal with the scattering of feature code in preprocessor based implementations researchers have investigated virtual forms of separating concerns by helping developers to focus on relevant features .
for example in cide developers can create views on a specific feature selection hiding irrelevant files and irrelevant code fragments inside files with standard code folding techniques at the ide level.
code fragments are hidden if they do not belong to the selected feature set the developer has selected as relevant for a task.
in our examples we have already shown the collapsed versions of ifdef statements with a marker indicating additional code.
virtual separation in this form has been shown to allow significant understandability and productivity gains .
however hiding also has a similar effect as moving code into an aspect it is no longer visible locally except for a marker indicating hidden code and there is no interface describing the hidden code.
in this sense virtual separation makes the problem of cross feature dependencies even worse.
.
emergent interfaces the problems discussed so far occur when features share elements such as variables and methods raising cross feature dependencies.
for instance the common code might declare a variable subsequently used by an optional feature.
there are several paths to attack this problem of cross feature dependencies.
the typical language designer approach is to introduce additional modularity concepts into the programming language and make control flow and data flow explicit in interfaces .
with emergent interfaces we pursue an alternative tool based direction which works with existing languages and existing implementations and infers interfaces on demand.
an emergent interface is an abstraction of the data flow dependencies of a feature.
it consists of a set of provides and requires clauses that describe such dependencies.
in this work we consider crossfeature dependencies as data dependencies arising from definitions introduced by a feature and used in others and vice versa.
each provides and requires clause expresses data dependency information obtained through def use chains.
so an emergent interface states that features provide data to others and require data from others making explicit data dependencies between the involved features.
for example when considering feature copy in figure from themobilemedia product line the emergent interface at the bottom states that copy requires data from the common code the mandatory feature through the name variable and that copy provides data to the sms feature.
this way when maintaining a feature developers may ask for an emergent interface to be aware of cross feature dependencies.
now they can prevent situations where features would not work properly like when assigning a new controller to nextcontroller not suitable for the sms feature.
.
inferring emergent interfaces on demand like every ordinary interface an emergent interface abstracts991string name ... ... ifdef copypvc controller new pvc name nextcontroller controller endif... ifdef smssmsc.setnext nextcontroller endifnew pvc name copy featurerequires nameprovides nextcontrollersms featurerequires nextcontrollername ... mandatory featureprovides namesmsc.setnext nextcontroller nextcontroller figure emergent interface for the copy feature.
implementation details feature implementation details exposing only the data that features provide to and require from each other.
differently from ordinary interfaces an emergent interface does not need to be written manually by developers.
instead they are inferred and emerge on demand in the ide to improve feature understanding and give support for specific development tasks.
when analyzing the inferred interface developers become aware of cross feature dependencies and may have better chance of not introducing errors to other features.
despite improving feature understanding emergent interfaces do not provide guarantees such as stable contracts or means to detect violations as normal written interfaces do.
however we argue that writing and maintaining potentially large fine grained and low level interfaces between crosscutting features that may change frequently is a hard task.
with emergent interfaces developers get rid of this task because interfaces are inferred.
besides it is important to infer interfaces on demand .
as mentioned cross feature dependencies are common in practice so inferring interfaces in the first place for entire features will probably yield a large set of provides and requires clauses being difficult to read and understand.
in contrast inferring interfaces on demand from parts of a feature implementation improves readability and understandability and can help developers to focus on a specific local task.
to better illustrate how emergent interfaces are inferred from parts of a feature implementation we return to scenario from the previous section where the developer is supposed to change how the total score is computed.
before changing this computation the developer may ask for an emergent interface to support this particular code change task.
to ask for an interface developers select part of a feature implementation possibly consisting of non contiguous code blocks within a method that contains definitions or uses of variables.
interpreted as maintenance points the selection drives our tool see section .
to obtain cross feature dependencies between these points and the other features.
in this context emergent interfaces help developers to make code changes once they identify the maintenance points.
they do not contribute to finding the maintenance points in the first place though.
in our example the developer is only interested in changing the total score computation.
so she selects only part of the mandatory feature implementation see the dashed rectangle in figure .
then data flow analyses are performed to capture cross feature dependencies between the feature part she is maintaining and the other features.
finally the interface emerges stating that there is data provided by the common code the mandatory feature that is required by the arena feature the totalscore current s value.
figure illustrates the emergent interface for this scenario.
the interface is an abstraction of the data dependencies between part of the commoncode the totalscore assignment and arena containing two provides and requires clauses see the bottom of figure .
the first clause states that the mandatory feature provides data to the arena feature which uses the value of totalscore when calling thesetscore method.
the second clause states that this data also reaches a ternary statement which is inside the setscore method.
this happens due to the binding between totalscore ands according to figure .
thus the code change task may impact the behavior of products containing the arena feature.
the developer is now aware of cross feature dependencies.
when investigating them she is likely to discover she also needs to modify the arena code to avoid introducing an error.
finally note that there is no data from other features required by the totalscore assignment at the mandatory feature supporting hiding or separating those features.
public void computelevel totalscore ... ... ifdef arena networkfacade.setscore totalscore totalscore ...score s ?
stotalscore ...mandatory featureprovides totalscorearena featurerequires totalscore figure emergent interface for scenario .
.
abstracting feature code as mentioned emergent interfaces abstract feature implementation details.
for example although arena has many lines of code scattered throughout many files the emergent interface focuses only on the lines that indeed are data dependent on the totalscore value helping developers to abstract the remaining lines and files during this particular task.
in addition emergent interfaces can help to prevent developers from analyzing unnecessary features and their associated code which is important to decrease code change effort.
in particular we believe that our interfaces can help on making the idea of virtual separation of concerns see section .
realistic.
that is we can hide features and rely on emergent interfaces to only show the ones we need.
for instance consider scenario section .
.
here an emergent interface would show that only chown andutimes features require status .
so we could keep slink hidden since it is not related to the current task.
.
avoiding invalid dependencies product lines may establish explicit requirements level feature constraints in terms of variability models .
by using these models it is possible to evaluate whether a feature combination is valid or not.
emergent interfaces work both in the presence and in the absence of variability models.
if they are available emergent interfaces can take them into account preventing developers from reasoning about requirements level feature constraints and even from assuming invalid cross feature dependencies in case of mutually exclusive features which may cause potential errors .
for example with two mutually exclusive features aandb developers might assume that changing the x assignment in feature amay lead to problems in feature b which contains the m x statement.
however since the involved features are mutually exclusive we have an empty interface there is no data with respect to the x variable from feature athat reaches feature b and vice versa in any valid feature combination.
so code change tasks in the former feature do not impact the latter.
.
implementation emergo we implemented the idea of emergent interfaces in an eclipse plug in named emergo.
emergo computes emergent interfaces based on feature dependencies between methods or within a single method by using interprocedural orintraprocedural featuresensitive data flow analysis .
more specifically we use the reaching definitions analysis through def use chains.
the featuresensitive approach is capable of analyzing all configurations of a product line without having to generate all of them explicitly.
although our examples refer to code that implement features emergo is actually more general and considers code associated with int x ifdef a x endif ifdef b c m x endiffeature expressions such as b c .
also because we use the feature sensitive approach emergo analyzes the def use chains of each configuration.
so emergo seeks for definitions of a feature used by another for each configuration.
for example if int x is the maintenance point see the code snippet to the right there is a cross feature dependency when a b c since data is required by m x in such a configuration.
in case there is a variability model available emergo checks if this dependency is possible or not.
if yes it shows such a dependency at the tool ui.
the capacity of analyzing all products without the need to generate them in a brute force fashion increases performance which is important for interactive tools like ours that need to provide quick responses to developers requests.
to perform the feature sensitive analysis we annotate the control flow graph with feature information lift the lattice to contain a mapping of sets of configurations to lattice values and lift the transfer functions to compare whether or not apply the ordinary function.
the lifted function lazily splits the sets of configurations in two disjoint parts depending on the feature expression annotated with the statement being analyzed a set for which the function should be applied and a set for which it should not .
figure shows a screenshot of emergo.
after the developer found and selected the maintenance point in line the totalscore assignment emergo shows an emergent interface using a table view and a graph view.
we read the first row of the table as follows there is data the totalscore value provided by the common code that is required by the arena feature in line of the networkfacade class.
figure using emergo for scenario .
initially emergo shows all cross feature dependencies in both views.
to focus on a particular dependency the developer can click on the corresponding table row and then emergo shows the data path associated with the dependency of that row in the graph view.
maintenance point010010 code change task 010010001110maintenance point010010 code change task 010010001110find dependenciesfigure dashed rectangles represent the time we count with and without emergent interfaces .
in our example in figure the developer selected the first row of the table so the graph shows the path from the maintenance point to line of the networkfacade class.
emergo also provides navigation support either by clicking on the table rows or on the graph nodes enabling developers to quickly jump within in the ide.
.
experimental design in the previous section we suggest that emergent interfaces can make feature code change tasks such as scenario andscenario faster and less error prone.
to evaluate these hypotheses and to get a better understanding of the benefits and drawbacks of emergent interfaces we conducted and replicated a controlled experiment.
we investigate and compare code change effort and introduced errors when maintaining preprocessor based product lines with and without emergent interfaces in a setting that supports virtual separation allowing developers to hide feature code fragments.
.
goal questions and metrics our evaluation aims to compare maintenance of preprocessorbased product lines with and without emergent interfaces these are our treatments .
specifically we are interested in the interaction with the feature hiding facilities of virtual separation of concerns which we enable in both cases to aid comprehensibility.
we evaluate emergent interfaces from the developer s point of view and observe effort and number of errors they commit.
we investigate the following questions question do emergent interfaces reduce effort during code change tasks involving feature code dependencies in preprocessor based systems?
question do emergent interfaces reduce the number of errors during code change tasks involving feature code dependencies in preprocessor based systems?
to answer question effort we measure the time required to find cross feature dependencies and to change the impacted features to accomplish a code change task.
figure illustrates our setup with and without emergent interfaces.
note that we do not measure the time needed to find the maintenance point we actually provide the maintenance point with our task description as we describe later .
while finding the maintenance point may represent a significant part of a code change task in a real world setting emergent interfaces do not contribute to that part.
hence we measure only the part of the maintenance task after the maintenance point was identified eliminating noise that would not contribute to our analysis.
to answer question correctness we measure how many incorrect solutions a developer committed during a code change task number of errors .
we consider all human actions as an error that introduce one or more defects into the code.
as described later for some tasks we provide automated feedback to the experiment993participants so a participant can continue the task after an incorrect attempt.
other tasks are evaluated manually after the experiment so participants have only one attempt.
.
participants we performed the experiment three times.
in a first pilot study we tested the experimental design with a small group of six graduate students at the university of marburg germany.
next we performed the actual experiment with graduate students attendants of a course on experimental software engineering lead by an independent lecturer at federal university of pernambuco brazil round .
finally we replicated the experiment with urop undergraduate research opportunity program students at federal university of alagoas brazil round .
in both rounds around half of the participants were part time students with professional experience varying from few months to many years of experience.
all participants were informed they could stop participating at any time but nobody did.
.
material and code change tasks we use two preprocessor based product lines as experimental material best lap andmobilemedia .
the former is a highlyconfigurable commercial product line that has about kloc.
the latter which has about kloc is an academic product line for applications that manipulate photo music and video on mobile devices .
it contains feature restrictions and has been used in previous studies .
we ask participants to perform a number of code change tasks in each of the product lines.
we provide the product line s source code and corresponding tasks that the participants should perform by modifying the source code.
we selected tasks that are affected by cross feature dependencies since this is the kind of context where emergo can help.
note that emergent interfaces target a specific class of problems for other maintenance tasks we would not expect any benefit.
we argue that our task selection represents typical cross feature problems as outlined in section .
to cover different use cases we prepare two kinds of tasks.
in line with our motivating scenarios in section we have tasks that require participants to implement a new requirement requiring interprocedural analysis of the existing source code and tasks that require participants to fix an unused variable requiring only intraprocedural analysis .
we provide a task of each kind for each product line for a total of four distinct tasks as discussed next.
task new requirement for best lap.
the new requirement forbest lap is similar to our motivating scenario there are two methods of feature arena that contain conditional statements forbidding negative scores.
so to accomplish the task besides changing the totalscore assignment participants should remove or rewrite these conditional statements see one of them in method setscore of figure .
to reach them participants need to consider interprocedural dependencies.
that is there are cross feature dependencies from the maintenance point to two conditional statements each one in a different method.
in case emergo is available the participant should use it to identify the cross feature dependencies between totalscore and the rest of the code.
otherwise the participant is free to use standard tools like find replace and highlighting.
this setup also holds for the subsequent tasks.
task new requirement for mobilemedia.
the task for mobilemedia is conceptually similar in the sense that participants should change a variable assignment follow cross feature dependencies and update conditional statements here only one ifstatement .
however in contrast to task where the method call depth to reach the two conditional statements is here the call depth is .that is from the maintenance point we need to follow two method calls to reach the ifstatement.
task unused variable in best lap.
inbest lap we asked participants to fix unused variable warnings for two variables tires andxp.
we introduced the bugs ourself by removing correct ifdef directives around the variable declarations.
we can solve all unusedvariable tasks by following intraprocedural dependencies only but they typically require investigating code of different features.
to accomplish the tasks we ask participants to put a correct ifdef around the variable declarations.
the variables tires andxpare inside methods with and source lines of code respectively.
task unused variable in mobilemedia.
again the mobilemedia task is conceptually similar to the best lap task.
participants should fix the unused variable warning of numberofviews and albummusic .
the two variables are placed in shorter methods when compared to task they have and lines of code.
overall the tasks for both product lines have similarities but they are not equivalent.
actually these differences methods size method call depths to reach the impacted feature and number of conditionals to change between tasks for both product lines help us to better analyze the effects of our two treatments and is properly controlled by our experiment design as we shall see in section .
.
finally we designed warmup tasks on a toy product line so that participants could learn how to use emergo at the start of the experiment.
we performed warmup tasks together in a class context but did not evaluate their results.
.
hypotheses based on our goals and tasks we evaluate the following hypotheses h1 effort with emergent interfaces developers spend less time to complete code change tasks involving feature dependencies in both product lines.
h2 error introduction with emergent interfaces developers commit less errors in both product lines when performing code change tasks involving feature dependencies.
.
design to evaluate our hypotheses we distinguish between participants using our treatments independent variable with two levels with and without emergent interfaces .
additionally we distinguish between the tasks of both product lines as we cannot assume equivalence independent variable with two levels best lap andmobilemedia tasks .
we measure time and the number of errors dependent variables for new requirement tasks and unused variable tasks.
since we have two independent variables with two levels each we use a standard latin square design .
we randomly distribute participants in rows and product lines tasks in columns.
the treatments come inside each cell.
each treatment appears only no eis bestlaptaskseismmtasks1eisno eis once in every row and every column see figure to the right .
as a result each participant performs both kinds of tasks on each product line and has the opportunity to use emergent interfaces in one of the tasks.
no participant performs the same task twice which avoids corresponding carry over effects such as learning if we let one to use both treatments in the same task we would favor the second treatment since she already knows how to accomplish the task .
the design does not favor any treatment and blocks two factors participant and code change tasks.
as analysis procedure for this design we perform an anov a. to give relevance to the anov a we use the bartlett box cox and tukey tests to verify variance homogeneity normal distribution 994eclipse bestlap1 new requirement .............. totalscore .........b use emergo ... unused variables ..... xp and tiresb use emergo ... !
!
!
!eclipse bestlap1 new requirement ............... totalscore ......... unused variables .... xp and tires !
!
!
!eclipse mobilemedia1 new requirement ....................... server ..............b use emergo ... unused variables ........ albummusic and numofviewsb use emergo ... !
!
!
!eclipse mobilemedia1 new requirement ....................... server .............. unused variables ........ albummusic and numofviews !
!
!
!task description sheet 1task description sheet 2task description sheet 3task description sheet 4a c a c a c a c a b a b a b a b figure task description sheets we distributed.
and model additivity respectively.
we follow the convention of considering a factor as significant when p value .
.
procedure after randomly assigning each participant into our latin square design we distribute task description sheets accordingly.
each participant performs two tasks in two individually prepared installations of eclipse with emergo installed or not with best lap ormobilemedia prepared readily as a project each installation corresponds to a cell of our latin square design.
by preparing the eclipse installation we prevent participants from using emergo when they are not supposed to it is simply not installed in that case .
all eclipse installations support virtual separation where we leave the first line with the ifdef statement to inform the user of hidden code .
also for the warmup tasks we prepared a distinct eclipse installation.
all tasks focus around a specific maintenance point a variable assignment .
since we are not interested in the time needed to locate the variable we prepare the installations in such a way that the correct files are opened and the cursor is positioned exactly at the maintenance point.
we prepare all eclipse installations with an additional plug in to measure the times automatically.
the plug in adds two buttons a play pause button for participants to start stop the chronometer and afinish button to submit a solution.
we instruct the participants to press play when starting with the task after reading its description andfinish when done and to use pause for breaks for asking questions during the experiment for example .
to collect qualitative data in the pilot study we also recorded the screen.
to illustrate the tasks from the participant s perspective we summarize the task description sheets we distributed in figure .
we represent the steps that participants should follow as a b and c .
notice that we associate each sheet with a different eclipse.
we also partially automated measuring the number of errors.
for new requirements tasks tasks and presented in section .
the plug in automatically checks the submitted solution by compiling the code and running test cases require about second as soon as a participant presses finish .
if the test passes we stop and record the time otherwise we increase the error counter and let the participant continue until the test eventually passes.
the test cases are not accessible to the participants.
for unused variable tasks tasks and we do not provide immediate feedback but evaluate whether one or both variables are correctly fixed after the experiment.
this is because we learned when watching the pilot screen recordings that participants spend time dealing with compilation errors regarding missing endif statements and tokens like and .
because we do not want to measure this extra time we ask participants to write the ifdef feature expression in the task description sheets.
for example to fix the unused variable illustrated in section .
they can write chown utimes in the sheet.
all times using emergent interfaces include the time required by eis no eisnew requirement task techniquetime seconds eis no eisround round 2figure time results for the new requirement task.
emergo to compute these interfaces.
emergo takes on the used systems around 13seconds and 6seconds to generate emergent interfaces for tasks and respectively.
to compute interfaces for tasks and we only need intraprocedural analyses but to simplify execution instead of asking the developers to select the analysis to use we let emergo automatically apply interprocedural ones.
so instead of second or less intraprocedural it takes more time than needed around and seconds for the variables tires xp numberofviews and albummusic respectively.
to avoid the effect of software installed in different machines and related confounding parameters we conduct the experiment in a virtual machine executed on comparable hardware that provides the same environment to all participants.
in each round all participants worked at the same time in the same room under the supervision of two experimenters.
.
execution and deviations at the start of the experiment session we introduce preprocessors the hiding facilities of virtual separation of concerns and emergent interfaces.
together with the participants we perform a warmup task that uses emergo.
we introduce how to use the play pause and finish buttons.
for the entire experiment we scheduled .
hours training warmup and execution .
no deviations occurred.
.
results and discussion next we describe the results and test the hypotheses before discussing their implications all data materials tasks plug ins and r scripts are available at bin view spg emergentinterfaces .
we proceed separately with the two kinds of tasks reporting results from both rounds.
.
new requirement tasks we plot the times for both new requirement tasks and in figure .
here we use beanplot batches where each batch shows individual observations as small horizontal lines the longest represents the average of that batch and the density trace forms the batch shape.
in round see the legend in the figure the slowest time when using emergent interfaces is still faster than the fastest time without.
on average participants accomplished the task times faster with emergent interfaces.
according to an anov a test we obtain statistically significant evidence that our interfaces reduce effort in both new requirement tasks p value .237e .
the key results were confirmed in the replication participants with emergent interfaces were on average .
times faster p value .343e .
in figure we plot the number of errors results for both newrequirement tasks.
in round only one participant committed more errors when using emergent interfaces than without and all of them995abcdefghijklmnopqrstuvwxnumber of errors per participant participantsnumber of errors 8eis no eisfigure number of errors for the new requirement task in both rounds.
a j round k x round .
committed errors when not using emergent interfaces they thought they had finished the task but had not potentially because they missed a dependency .
the replication roughly confirms the results participants committed errors when not using emergent interfaces but only participants committed errors with emergent interfaces.
here we do not perform an anov a test on number of errors because we have many zero samples being hard to observe a tendency and draw statistically significant conclusions.
.
unused variable tasks differently from the new requirement task here we do not have a test case so we do not force participants to finish the task correctly.
we took this important decision after reviewing the screen recordings from the pilot study.
when fixing the unused variable problem participants spend time since they miss statements such as endif and tokens like and essential to compile the code and run the test but typically less common when somebody is more familiar with the used notation.
because including this time would introduce bias into our results we ask participants to write the ifdef feature expression in the task description sheets not in the source code.
thus all participants finished the unused variable task but some committed errors when writing the feature expressions which means we could have data of participants that for example did not try hard enough and consequently finished the task earlier.
regarding the measured time it actually only reflects the time participants need until they think they are done.
to reflect incorrect solutions in the time we also analyze measurements with an added time penalty for incorrect tasks that simulates the extra time participants would have needed if we mechanically reported the error or if they found the problem unfixed in practice.
we add half the standard deviation of all participants times.
we analyze both the original time time until they think they are done and the adjusted time with the penalty for incorrect tasks which can be seen as a form of sensitivity analysis .
we plot the adjusted times for both unused variable tasks tasks and in figure .
differently from the new requirement task here the use of emergent interfaces adds little the difference between the treatments is smaller.
in fact we obtain statistically significant evidence that our interfaces reduce effort only in the second round pvalue .
for the first round p value .
.
the statistical results are stable for the original time time until they think they are done and the adjusted time.
regarding the adjusted time in the second round participants were .
times faster on average.
when considering the product lines peculiarities the mobilemediamethods are simpler when compared to the best lap ones.
the adjusted time spent to accomplish the unused variable task for the eis no eisunused variable task techniquetime seconds eis no eisround round 2figure time results for the unused variable task.
!
!
.
!
.
.
.
?
!
!
abbaab cdeb daceee figure number of errors for the unused variable task.
mobilemedia variables is on average fairly similar when using and not using emergent interfaces.
however the difference is much greater for the best lap variables participants using emergent interfaces are 2and2.
times faster in the first and second rounds.
again notice that the results are similar in both rounds.
we plot the number of errors metric in figure .
the left hand side represents round the right hand side round .
the errors consist of wrongly submitted ifdef statements.
in general it turns out that participants commit less errors when using emergent interfaces.
the mobilemedia methods are simpler which might explain why participants commit less errors when performing the task in such product line.
.
meta analysis to identify other tendencies we also performed a meta analysis where we combine the results from both rounds.
the time differences are statistically significant for both kinds of tasks.
here we used the adjusted time for the unused variable task.
.
interpretation effort reduction.
regarding question effort reduction we found that emergent interfaces reduce the time spent to accomplish the new requirement tasks.
the difference is large with a three fold improvement and statistically significant.
despite different student levels graduate versus undergraduate the results are stable across both rounds.
we regard this as a confirmation that emergent interfaces make cross feature dependencies explicit and help our participants to concentrate on the task instead of navigating throughout the code to find and reason about cross feature dependencies.
additionally we can see a qualitative difference between newrequirement tasks that require interprocedural analysis across several methods and unused variable tasks that require to analyze only code of a single method where tasks involving interprocedural analysis show higher speedups.
we argue that the effect is general to tasks with interprocedural dependencies since they are more996difficult to follow without tool support.
in contrast emergent interfaces contribute comparably little over simple textual search tools when applied in the local context of a function especially small ones.
still we can carefully interpret our results as suggesting that the effort gains might depend on the method complexity and size in theintraprocedural context speedups were considerably higher in thebest lap task where variables were placed in longer methods.
in all cases the performance gained from emergent interfaces outperforms the extra overhead required to compute them.
our conclusion is that for code change tasks involving cross feature dependencies emergent interfaces can help to reduce effort while the actual effect size depends on the kind of task inter orintraprocedural method size complexity etc .
correctness.
regarding question reducing the number of errors made our experiment suggests that emergent interfaces can reduce errors.
the new requirement task fits into an incomplete fix that has been pointed as a type of mistake in bug fixing .
it is introduced by the fact that fixers may forget to fix all the buggy regions with the same root cause.
here the developer performs the code change in one feature but due to cross feature dependencies she needs to change some other feature as well.
if she does not change it she introduces an error.
to discover this kind of incomplete fix developers should compile and execute the problematic feature combination.
due to many potential product combinations they might discover the error too late.
given that emergent interfaces make developers aware of crossfeature dependencies the chances of changing the impacted features increases leading them to not press the finish button too rashly.
this is consistent with recent research if all such potential influenced code either through control or data dependency is clearly presented to developers they may have better chances to detect the errors.
our results suggest that participants tend to introduce more errors without emergent interfaces.
for unusedvariable tasks we observe again that the longer methods of best lap are more prone to errors than the shorter methods of mobilemedia .
outlook.
our experiment considered the influence of emergent interfaces in a specific scenario of preprocessor based product lines.
as we argued in section the idea can be generalized to enhance other implementation mechanisms with insufficient modularity mechanisms.
of course we cannot simply transfer our results to these settings but we are confident that in follow up experiments we could find similar improvements also for tasks involving crossfeature dependencies in aspect or feature oriented implementations.
also emergent interfaces have capabilities we did not explore in our experiment.
for instance product lines often make explicit requirements level feature constraints in terms of variability models.
to identify a cross feature dependency the underlying featuresensitive data flow analysis of emergo can take such constraints into account mechanically and automatically exclude infeasible paths whereas a developer needs to manually compare ifdef annotations on code statements with constraints specified in these models.
further even situations where emergo derives empty interfaces can provide valuable information to users indicating that they can stop their search a fact that we did not evaluate yet.
.
threats to validity first our experiment is limited to a specific implementation technique and specific code change scenarios generalization to aspect oriented languages and others requires further investigation generalization to arbitrary maintenance tasks is not intended.
second our code change tasks are relatively simple they take only few minutes to accomplish .
nevertheless we can often findbug reports5regarding undeclared uninitialized and unused problems of single variables as well as of their uses along the code in practice.
moreover we assume that many bigger tasks can be seen as a sequence of smaller tasks such as the ones we consider here.
so if we provide benefits for small tasks it is plausible to consider that we can sum up their times and observe benefits for the whole task.
thus we might carefully extrapolate our results to some kinds of bigger tasks as well.
also we analyze tasks on unfamiliar code whereas in practice developers might remember cross feature dependencies from knowledge gained in prior tasks.
third recruiting students instead of professional developers threats external validity.
though our students have some professional experience of our graduate students and of our undergraduate students reported industrial experience and researchers have shown that graduate students can perform similar to professional developers we cannot generalize the results to other populations.
the results are nevertheless relevant to emerging technology clusters especially the ones in developing countries like brazil which are based on a young workforce with a significant percentage of part time students and recently graduated professionals.
fourth mobilemedia is a small product line.
we minimize this threat by also considering a real and commercial product line with best lap .
the results for both are consistent but we still need to consider more product lines.
fifth emergent interfaces depend on data flow analysis which can be expensive to perform.
in our experiments we have included analysis time but analysis time may not scale sufficiently with larger projects.
in that case developers have to decide between imprecise results or advanced incremental computation strategies.
when using imprecise analysis the use of emergo could even lead developers to a dangerous sense of security.
in our experiment analysis could be performed precisely in the reported moderate times.
regarding construct validity the time penalty we add to wrong answers for the unused variable task might be controversial because the measured correctness influences the measured time.
we argue that to provide the correct answer participants would need more time and a test case so the adjustment seems realistic.
also we obtain similar statistical conclusions with both the original and adjusted data.
in addition not considering the time to find the maintenance points might raise a threat in the sense that developers could learn about feature dependencies in advance when finding these points.
finally regarding internal validity we control many confounding parameters by keeping them constant environment tasks domain knowledge and by randomization.
we reduce the influence of reading time by forcing participants to read the task before pressing theplay button and the influence of writing time by making the actual changes small and simple.
.
related work preprocessor based variability.
preprocessor based variability is common in industry even though its limitations regarding feature modularity are widely known and criticized .
in this implementation form no interfaces exist between features.
emergent interfaces follow a line of research that tries to provide tool based solutions to help practitioners cope with existing preprocessor infested code.
virtual separation was explored with the tool cide which can hide files and code fragments based on a given feature selection .
the version editor c clr and the leviathan file system show projections of variable source code along similar lines.
similar ideas have also been explored outside the product line and 461011997context most prominently in mylyn which learns from user behavior and creates task based views.
also in this context emergent interfaces can help to make dependencies visible.
along those lines researchers investigated close world wholeproduct line analysis techniques that can type check or model all configurations of a product line in an efficient way .
the underlying analysis of emergo follows the general idea of wholeproduct line analysis but extends prior work to data flow analysis.
in our evaluation we investigated only the influence of emergent interfaces but not of other facets of preprocessor usage or virtual separation which have been explored in prior complementary studies.
specifically feigenspan et al.
have shown in a series of controlled experiments that different representations of conditionalcompilation annotations can improve program comprehension .
further le et al.
have shown in a controlled experiment that hiding irrelevant code fragments can improve understanding of product lines a result that aligns with an ex post analysis of using the version editor showing productivity increases .
these results complement each other and help building a tool environment for efficient maintenance of preprocessor based implementations.
feature modularity.
separating concerns in the implementation and hiding their internals has a long history in software engineering research and programming language design .
the research field has received significant attention with the focus on crosscutting concerns in the context of aspect oriented programming .
early work on aspect oriented programming was often criticized for neglecting modularity with clear interfaces whereas more recently many researchers have investigated how to add additional interface mechanisms typically adding quite heavyweight language constructs.
in contrast our idea relies on tools to infer interfaces on demand.
so developers do not need to write them in advance.
conceptual modules support analyzing the interface of a specific module also using def use chains internally.
our idea extends conceptual modules by considering feature relationships.
where conceptual modules were evaluated regarding correctness in case studies we contribute a controlled experiment to evaluate correctness and reduced effort.
slicing also uses data flows but requires program transformations to yield a executable program not feature aware to support maintenance tasks.
emergent interfaces pursue an alternative tool based strategy with no program transformations leaving the languages as is at least until mainstream languages support modular crosscutting implementations but providing tool support for developers.
eventually both directions may converge by using emergent interfaces to infer interfaces similar to type inference with similar tradeoffs .
overall implicit and inferred interfaces as computed by emergo might provide an interesting new point to explore feature modularity.
similar to the idea of virtual separation of concerns where we have no real separation but only emulate some form of modularity at tool level with views emergent interfaces can emulate the benefits of real interfaces at a tool level.
it cannot and does not want to replace a proper module system with explicit machine checked interfaces but it can provide an interesting compromise between specification effort and usability .
hidden dependencies.
hidden dependencies are known to be problematic.
this can be traced back to avoiding global variables where developers have no information over who uses their variables since there is no mutual agreement between the creator and the accessor.
in this context developers are prone to introduce new errors during fixing activities since information about the agreement is not available.
emergent interfaces support developers maintaining variable systems written in languages thatdo not provide strong interface mechanisms between features .
current mainstream languages do not have such mechanisms for fine grained crosscutting features such as the ones we often find in product lines.
prior work on emergent interfaces.
we have first proposed emergent interfaces in a vision paper .
the prototype tool that we introduced was based on cide to annotate features and the reaching definition analysis was approximated and unsound.
it was neither interprocedural nor even feature sensitive checking only whether the maintenance point annotation was different of the reached statements annotation.
then we assessed how often cross feature dependencies occur in practice by mechanically mining software systems with preprocessor variability using an srcml based infrastructure conservatively approximating intraprocedural data flow using proxy metrics unsound but sufficient to approximate the frequency of the problem .
further we estimated potential effort reduction by a tool like emergo by simulating code change tasks we randomly selected variables from the 43systems and estimated developers effort by counting how many ifdef blocks they would analyze with and without emergent interfaces showing a potential for significant reduction.
in parallel we investigated precise and efficient mechanisms for feature sensitive data flow analyses .
these advances now form the technical infrastructure with which emergent interfaces are inferred precisely without unsound approximations of prior work .
in this paper we bring together these results and focus on the originally envisioned application emergent interfaces.
we present a significantly revised and extended version of emergo that uses intraprocedural andinterprocedural analysis and for the first time evaluate the actual benefit of our interfaces for code change tasks in a controlled experiment with human participants.
.
concluding remarks in this paper we present emergent interfaces that emulate missing interfaces in many product line implementations.
we provide emergo a complete version of a tool capable of inferring interfaces from data flow analysis on demand.
emergent interfaces raise awareness of cross feature dependencies that are critical for maintaining configurable software systems.
with a conducted and replicated controlled experiment we evaluate to what extent such tool support can help achieving better feature modularization.
our study focuses on feature code change tasks in product lines implemented with preprocessors since they are the prevalent way to implement variable software in industrial practice.
we observe a significant decrease in code change effort by emergent interfaces when faced with interprocedural dependencies.
similarly our study suggests a reduction in errors made during those code change tasks.
in future work we will focus on scaling the underlying data flow analysis by trading off performance and precision and investigating emergent interfaces for other implementation techniques.
.