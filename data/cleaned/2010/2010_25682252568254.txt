the strength of random search on automated program repair yuhua qi xiaoguang maoy y an lei ziying dai and chengsong wang college of computer national university of defense technology changsha china yuhua.qi xgmao yanlei nudt.edu.cn dzynudt jameschen186 gmail.com abstract automated program repair recently received considerable attentions and many techniques on this research area have been proposed.
among them two genetic programmingbased techniques genprog and par have shown the promising results.
in particular genprog has been used as the baseline technique to check the repair e ectiveness of new techniques in much literature.
although genprog and par have shown their strong ability of xing real life bugs in nontrivial programs to what extent genprog and par can bene t from genetic programming used by them to guide the patch search process is still unknown.
to address the question we present a new automated repair technique using random search which is commonly considered much simpler than genetic programming and implement a prototype tool called rsrepair.
experiment on programs with versions shipping with real life bugs suggests that rsrepair in most cases outperforms genprog in terms of both repair e ectiveness requiring fewer patch trials and e ciency requiring fewer test case executions justifying the stronger strength of random search over genetic programming.
according to experimental results we suggest that every proposed technique using optimization algorithm should check its e ectiveness by comparing it with random search.
categories and subject descriptors d. .
coding tools and techniques d. .
testing and debugging general terms experimentation algorithms measurement the author is currently a liated with the institute of measurement and communication beijing and can be reached atyuhua.qi outlook.com .
ythe corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.keywords automated program repair random search genetic programming search based software engineering .
introduction researchers have devoted considerable attentions to the area of automated program repair aiming at automatically generating patches for failure aware programs without the manual e orts.
with automated program repair much resource cost can be saved in the software maintenance activity for which patch generation is an essential task.
recently researchers have proposed several techniques to automate the process of patch generation .
of these techniques a particularly e ective approach is genetic programming based patch generation technique.
both genprog and par which won the distinguished awards in icse and icse respectively showed the very promising results by using the same genetic programming algorithm to guide the patch generation process.
to repair a faulty program genprog and its extension tries to produce a population of candidate patches in each generation by modifying source code according to mutation and crossover reuse structures i.e.
statement addition removal and replacement in other parts of the program.
once candidate patches are available genprog has to run xed size of test cases to evaluate the tness of each patch to facilitate the next patch generation.
genprog iterates the above steps until some valid patch passing all test cases is obtained or when some limit i.e.
too much time or too many generations elapse arrives.
par has the similar patch generation process but generates candidate patches via x patterns learned from human written patches rather than via code reuse used by genprog.
the two main contributions presented by genprog and par are e ective mutation operations i.e.
reuse structures for genprog and x patterns for par and using genetic programming to guide the patch generation process.
although the promising repair ability has been shown by genprog and par whether the repair ability is got based on the guidance of genetic programming or just because the mutation operations are powerful enough to tolerate the inaction of genetic programming has rarely been studied.
as described in we can consider genetic programming to be e ective at guiding the repair process if and only if genetic programming can guide the repair process to searchpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
valid patches much faster in terms of requiring fewer patch trials1 than random search.
in addition similar to other search based software engineering sbse approaches genetic programming often su ers from the computationally expensive cost caused by tness evaluation a necessary activity used to distinguish between better and worse solutions.
in most cases it is the computation of tness by running xed size of test cases for each candidate patch that occupies the largest part of the overall repair process .
hence we should investigate whether genetic programming used by genprog and par can guide the patch search fast enough to o set the cost of tness evaluation and thus speed up the repair process even if genetic programming has been nally proved to be e ective.
given the above issues we construct a new repair tool called rsrepair random search based repair which tries to repair faulty programs with the same mutation operations as genprog but uses random search rather than genetic programming to guide the patch generation process.
unlike genetic programming which requires tness evaluation in the sense that genprog has to run xed size of test cases to compute the tness of a candidate patch even if genprog has been aware that the patch is invalid i.e.
the patched program has ever failed to pass some test case random search has no such constraint.
that is rsrepair immediately discards one candidate patch once the patched program fails to pass some test case.
therefore for one concrete patch rsrepair can take much fewer test case executions to check its validity.
in addition one second advantage of rsrepair is that rsrepair can speed up the process of early invalid patch identi cation using classic test case prioritization techniques .
it however makes little sense to apply the prioritization techniques to genprog which still needs to compute the tness of each patch even if some patches are found to be invalid early.
experimental results show that rsrepair has much better performance than genprog.
in our experiment we compared rsrepair with genprog by running them to repair a set of nontrivial programs with real world faulty versions.
through the rigorous statistical analysis we observed that rsrepair in most cases has the better repair e ectiveness in terms of requiring the smaller number of candidate patches generated before a valid patch is found ncp which indicates that genetic programming algorithm used by genprog does not work well and even misleads the search process con rming the concern presented by andrea arcuri and lionel briand in their icse paper to genetic programming used by genprog rsrepair has the higher repair e ciency by requiring much fewer test case executions in the repair process.
in our early work we have presented our insight with limited experiment.
in this paper we will introduce our work in detail with the analysis to more experiment size.
in short this paper makes the following contributions using the simplest randomized algorithm i.e.
random search to implement a repair tool called rsrepair section which mostly has better performance over genprog a state of the art repair tool using genetic programming to guide the patch search.
1in this paper we regard the step of checking the validity of one candidate patch in the repair process as a patch trial in contrast one concrete repair process can be regarded as one repair trial.
analyzing the experimental results and discussing the implications of such results for future research in the area of automated program repair in general section and section .
presenting a baseline approach based on random search in the promising research area of automated program repair which is still in its infancy.
we suggest that an advanced repair approach should always be compared against at least the baseline approach to check the advantage of the new approach which is consistent with the declaration presented in .
.
background and related work .
automated program repair generally automated program repair consists of three steps fault localization patch generation and patch validation.
when a bug is reported we rst use fault localization techniques to identify suspicious faulty code snippet causing the bug.
once faulty code snippet has been located many candidate patches can be generated through the modi cation to that code snippet according to speci c repair rules based on either evolutionary computation or code based contracts .
when a candidate patch has been produced regression testing inclusive of negative test cases reproducing the fault and positive test cases characterizing the normal behaviors is commonly used to validate the correctness of produced candidate patch.
the above procedure can be iterated over and over again until some valid patch is found.
any patch passing all these test cases is considered valid.
automated repair techniques have received considerable recent research attentions.
guided by genetic programming genprog has the ability to repair programs without any speci cation and genprog is commonly considered to open a new research area of general automated program repair although there also exists earlier e.g.
and concurrent work on this topic .
autofix e can repair programs but requires for the contracts in terms of pre and post conditions.
jaff tries to automatically correct the faulty java programs using an evolutionary approach the repair e ectiveness of jaff were not reported on real world software with real bugs.
phprepair can automatically x html generation errors in php applications through string constraint solving.
according to x templates learned from human written patches par has xed successfully many bugs existing in real world java programs.
semfix tries to repair faulty c programs via semantic analysis based on symbolic execution constraint solving and program synthesis whether semfix scales well to large scale programs however is still unknown due to the possible expensive computation caused by semantic analysis.
of these techniques genprog and par the two awardwinning patch generation techniques presented the very promising results.
both genprog and par use the same fault localization technique to locate faulty statements and genetic programming to guide the patch search but di er in the concrete mutation operations.
although promising results have been shown in their work the problem of whether the promising results are caused by genetic programming or just because the used mutation operations are very e ective is still not be addressed.
.
genetic programming and random search genetic programming which is a variation of the wellknown genetic algorithm seeks to discover computer programs tailored to a particular task.
similar to traditional genetic algorithm genetic programming uses genetic operations such as selection crossover and mutation to evolve its populations to obtain some more adapted solutions .
in the research area of automated program repair genprog is the promising automatic solution designed to automatically and generically patching bugs in the software maintenance .
genprog uses genetic programming algorithm to guide the patch generation process.
as described in genprog needs to implement two key ingredients before the application of genetic programming the representation of the solution and the de nition of the tness function.
for the representation problem genprog represents each candidate patch as the abstract syntax tree ast of the patched program.
for tness function genprog uses test cases to evaluate the tness of each patch and the patches with high tness passing many test cases are selected for continued evolution in the next generation.
that is for each candidate patch genprog has to run xed size of test cases to compute the tness.
in contrast random search the simplest search algorithm that appears frequently in the sbse literature does not use a tness function and thus does not incur the cost of tness evaluation.
in fact genprog produces the rst population of candidate patches according to random search algorithm and genetic programming starts to work on genprog from the second generation.
however andrea arcuri and lionel briand found that genprog often searched valid patches in the random initialization of the rst population before the actual evolutionary search even starts to work.
they doubted that the promising results may not be brought by genetic programming used by genprog because the patch search problem can be easy when random search would have likely yielded similar results.
in this paper however we plan to further investigate whether genetic programming used by genprog has the better performance over random search when the actual evolutionary search has started to work.
.
test case prioritization as described earlier random search is unguided and thus requires no tness evaluation.
speci cally for automated repair for random search one candidate patch can be discarded immediately once the patch is regarded as invalid.
although we can check whether one patch is valid through either regression testing or formal speci cations regression testing is most often used because formal speci cations are rarely available in practice.
with no need for tness evaluation we can speed up the patch validation process by maximizing the rate of invalid patch detection which is well researched in the area of test case prioritization.
as described in by rothermel et al.
test case prioritization problem can be de ned as follows given t a test suite pt the set of permutations of t f a function from ptto the real numbers.
problem find t02ptsuch that 8t00 t002pt t006 t0 .
in the above context ptrepresents the set of all possible orderings of t fis a transition function used to evaluate an award value for any ordering of pt.
in fact fdescribes quantitatively the goal of prioritization such as increasingalgorithm the genprog algorithm input faulty program p input test cases t input mutation operator mutate input crossover operator crossover input full tness predicate fullfitness input sampled tness samplefit input parameter popsize output one valid patch ptpassing fullfitness 1csub faultlocalization p t 2pop mutate popsize p csub repeat fitnesses samplefit pop parents tournselect pop popsize fitnesses offsprings crossover parents p pop mutate parents offsprings until9pt2pop fullfitness pt passed return pt the rate of fault detection of a test suite or increasing the coverage of coverable code in the system under test at a faster rate.
techniques on test case prioritization are relatively mature and much work has been presented in .
according to di erent coverage criteria a family of prioritization techniques are presented in .
some research work evaluated traditional techniques on test case prioritization in context of time aware test case prioritization .
furthermore there also exists much work focusing on di erent granularity levels such as the function level system model block level and method level .
more details on prioritization techniques have been listed in .
.
implementation we have implemented a repair tool called rsrepair which can automatically generate patches for faulty programs by using purely random search algorithm.
rsrepair also comes with an adapted test case prioritization technique to speed up the patch validation process.
in this section we rst describe genprog a state of the art tool for automated c program repair on which we built rsrepair.
then we present the implementation details on rsrepair.
.
repair algorithm for genprog genprog2has the ability of xing bugs in deployed legacy c programs without formal speci cations.
with the hypothesis that some missed important functionalities may occur in another position in the same program genprog attempts to automatically repair defective program with genetic programming .
algorithm gives the process of patch generation of genprog.
consider a faulty program p shipping with a set of test cases t on line genprog rst localizes the faulty code area csubaccording to test case coverage information.
then line initializes the population pop by independently mutating the popsise copies of csubusing purely random search.
once pop is available the tness of each patch pt2pop is computed via samplefit resulting in the tness set fitnesses .
the patches with high tness 2available the rsrepair algorithm input faulty program p input test cases t input mutation operator mutate output one valid patch pt 1index initialize the index value 2fn0 t1 t2 t ng t 3t f n0 t1 index t2 index tn index g 4csub faultlocalization p t 5successflag false repeat pt mutate p c sub for i 0tondo check that whether ptis valid tindex index gettestcase t i if patchvalidation p pt t index truethen temp tindex index t prioritize t temp break else if i nthen successflag true else continue end end until successflag true return pt have more chances of being selected into the next generation line to continue evolution using crossover line and mutate line operations.
line is repeated until either a valid patch is found to pass successfully fullfitness or some predetermined limits has elapsed.
more details on genprog can be found in .
.
repair algorithm for rsrepair similar to our prior work we design the repair algorithm of rsrepair to generate automatically patches using purely random search algorithm combining with test case prioritization technique to improve the repair e ciency.
algorithm describes the repair algorithm in detail.
given a faulty program pand test cases t we reconstruct the test cases tto give tthe ability of mapping each test case t2tto the number of candidate patches having been killed byt.
the intuition behind this reconstruction is that the number of candidate patches killed by a test case tindicates at least partly the ability of tto detect invalid patches.
hence we should prioritize test cases having killed more invalid patches to maximize early invalid patch detection.
note that on line rsrepair initializes the index value of n0 one negative test case with due to its natural ability of fault reproduction.
to limit the search space for generating patches we localize the faulty code area csubofpin the same way like genprog.
the search begins by generating one patch ptthrough the mutate operation which can produce one concrete patch ptby modifying csub.
note that the patches produced by multiple calls to mutate are probably di erent due to the application of randomized algorithm.
lines run pagainst tin order and reorder test cases taccordingto the running result.
given that the ith test case for t line calls the function gettestcase to get the ith tuple tindex index oft then the function patchvalidation runs ppatched by ptagainst tindex line if a fault is detected by tindex then rsrepair records the fault by updating the tuple tindex index with tindex index for t line and reorders each test case t2tby calling the function prioritize line which reorders the test cases tin descending order of index .
if multiple test cases have the same index value rsrepair orders them randomly.
if psuccessfully passes all the test cases t line rsrepair considers that a valid patch is found line and terminates the repair process immediately with the output of valid patch line .
.
implementation of rsrepair according to algorithm we implemented rsrepair by modifying genprog which is written in ocaml language.
speci cally rsrepair uses the same implementation of functions including faultlocalization andmutate in algorithm as genprog in algorithm .
rsrepair uses one simple statistical fault localization having been implemented in genprog to determine fault localizations.
with the assumption that a statement visited by negative test cases is more likely to be faulty than other statements rsrepair computes the suspiciousness value sp of each statement in the way like that a statement never visited by any negative test case has the spvalue of a statement visited only by negative test case has the high value of .
a statement visited both by positive and negative test cases is given the moderate value of .
.
rsrepair determines the probability of each statement based on these suspiciousness values the bigger the suspiciousness value of a statement the more chances of the statement being selected for mutation in the patch generation process.
once some statements are selected for mutation rsrepair will generate one candidate patch by mutating randomly these statements according to mutate operations i.e.
statement addition removal and replacement.
this kind of mutation has been proved to be very e ective in terms of repairing successfully of faulty programs in .
in fact rsrepair produces candidate patches in the same way of generating randomly patches in the rst generation of genprog but without tness guidance and crossover in the subsequent generations.
for the process of patch validation rsrepair validates candidate patches in the way described in algorithm .
.
experimental design to check the performance of rsrepair we compare it with genprog a state of the art tool on automated program repair on subject programs with faulty versions.
we selected genprog for the reason that genprog is almost the only state of the art automated repair tool which can x bugs in real world large scale c programs.
although in the paper par had better performance than genprog in java benchmarks the paper also acknowledged the performance advantage may not hold in c benchmarks used by genprog.
what is more unlike par whose source code is not publicly available both source code and experimental benchmarks of genprog are publicly available facilitating the experiment reproduction and comparison between rsrepair and genprog.
in addition literature and our previous work also used genprog as the sole tool to conduct relevant experiments.
.
research questions our experimental evaluation seeks to address the following research questions rq1 whether can genprog search a valid patch with fewer patch trials compared to rsrepair?
intuitively genetic programming an advanced search algorithm should outperform purely random search the simplest form of search algorithm because higher quality solutions may be found faster with the aid of a tness function.
the intuition however is built on the assumption that tness function can at least partly distinguish between better and worse solutions and identify how close a candidate solution is to the optimal or near optimal solutions.
a poor tness function cannot bene t the search process and even has the negative e ectiveness.
speci cally for genprog the tness of each candidate patch is computed by counting the weighted number of passing test cases the number is used to measure how close a candidate patch is to the valid patch.
although some promising results for genprog have been presented in some recent serial papers the problem of whether the promising results are got based on the guidance of genetic programming or just because the mutation operations are powerful enough to tolerate the inaccuracy of used tness function has never been studied.
given the problem rq1 asks whether genetic programming used by genprog works well to bene t the generation of valid patches.
andrea arcuri and lionel briand pointed out that a search algorithm should always be compared against at least random search to check how well the search algorithm performs which can be measured by comparing the amount of e ort expended between the search algorithm and random search.
this e ort as described by mark harman in is commonly measured through counting the number of tness evaluations i.e.
patch trials that were performed in the search process the smaller the number is the better the search algorithm is.
however in most recent work on genprog and par published in icse and icse respectively we still do not nd the e ort comparison between genetic programming and random search.
in this sense rq1 is the supplement to these work.
rq2 does genprog nd a valid patch much faster than rsrepair in terms of requiring fewer number of test case executions ntce within a successful repair process?
like other heuristic algorithm of sbse such as hill climbing and simulated annealing the use of genetic programming has a bene t and a cost.
the bene t is fewer patch trials should be needed with the aid of a tness function if the used tness function works well .
the cost is that the trial and error nature of genetic programming requires a large number of tness evaluations during the search process tness evaluations may turn out to be computationally expensive and occupy the largest part of the overall computational cost of the search process .
an e ective implementation of genetic programming algorithm should enlarge e ectively the bene t to o set the evaluation cost and further reduce the whole time cost in the search process.table subject programs program loc test cases version lighttpd bug bug bug bug libtiff bug 01209c9 aaf9eb3 bug 0860361d 1ba75257 bug 0fb6cf7 b4158fa bug 10a4985 bug 4a24508 cc79c2b bug 5b02179 3dfb33b bug 6f9f4d7 73757f3 bug 829d8c4 036d7bb bug 8f6338a 4c5a9ec bug 90d136e4 4c66680f bug d39db2b 4cd598c bug ee2ce5b7 b5691a5a bug 0661f81 ac6a583 bug 3af26048 bug d13be72c ccadf48a gmp bug python bug gzip bug 3fe0caeada6aa3 39a362ae9d9b00 php bug wireshark bug speci cally for genprog which computes the tness of each candidate patch by counting the weighted number of passing test cases test case executions most often takes the largest part of time cost in the whole repair process especially for safety critical programs equipping with many test cases.
for simpli cation we can measure the e ciency of genprog using the ntce when a valid patch is found .
compared to random search genetic programming used by genprog can be regard as e cient only when the bene t in terms of early nding a valid patches with fewer number of patch trials brought by genetic programming has the ability of balancing the cost of tness evaluations caused by genetic programming itself.
however whether the balance can be achieved by genetic programming used by genprog has still been unknown so far.
rq2 is designed to answer the question.
.
subject programs we selected the subject c programs used in the most recent work on genprog as the experimental benchmarks3 each of which comes with real life bugs existing in history versions.
we conducted our experiment only on program versions which have ever successfully repaired by genprog in .
for the fbcprogram version we have the compilation trouble when we try to compile the program.
for simpli cation we also excluded the faulty versions including one lighttpd version and libtiff versions that can be repaired successfully by modifying not less than two source les i.e.
.c le because extra work has to be done to make cil a tool which can transform c program into ast used by both genprog and rsrepair work well to manipulate multi source les.
forphpprograms coming with over test cases validating only one patched program mostly takes several min3 resulting in time consuming repair process.
hence if we conduct experiment on all the phpprogram versions too much time used by experiment evaluation is unavoidable see in the paper amazon s ec2 cloud computing infrastructure including trials in parallel was used for experiment evaluation.
given the expensive testing computation we randomly selected one faulty phpversion although these phpversions shipping with many test cases which can cause expensive tness evaluation cost for genprog will give rsrepair more advantages.
for gmp python gzip and wireshark there exists only one version having ever been repaired successfully by genprog in we selected these versions in our subject programs.
table in total describes our subject programs with versions in detail.
the loc lines of code column lists the scale of each subject program and the last two columns give the size of positive test cases and the version information.
note that for all programs in table although there are more test cases listed in in practice the concrete number of test cases used for each bug version is similar but di erent because not all the test cases work well for every version.
in addition for each subject program we reproduced the bug by executing one negative test case in the repair process.
.
experimental setup for the purposes of comparison we separately ran rsrepair and genprog to repair all the faulty versions described in table .
all the experimental parameters for genprog in our experiment are similar to those settings in we limited the size of the population for each generation to and a maximum of generations for each repair process the global mute rate mute is set to .
.
in fact for all generations except the rst generation there are another candidate patches generated due to crossover.
that is for one concrete repair process genprog can iteratively produce no more than candidate patches.
for rsrepair we also limited the size of the population for each generation to and a maximum of generations for each repair process for each generation using random search without crossover total candidate patches are produced in the same way of the rst generation.
hence for fair comparison we considered that rsrepair genprog failed to repair one subject program in one repair process if the valid patch was not found within candidate patches.
as described in the tness function i.e.
samplefit function in algorithm samples a random of the positive tests to compute the tness when the programs equipping with many test cases genprog test one candidate patch against the full suite i the patch passes all the sampled test cases.
take python which has test cases in table for instance genprog has to run the patched python against the total test cases including sampled positive tests and negative tests to compute the tness of one candidate patches the patched python is then tested against the full test cases if it has passed all the above test cases.
in our experiment we ran genprog with the same tness evaluation mechanism as described above.
all the experiments ran on an ubuntu .
machine with .
ghz intel quad core cpu and gb of memory.
since randomized algorithm is applied in both rsrepair and genprog we statistically analyze the experimental results.speci cally for rsrepair and genprog we separately performed trials for each program with the seeds starting from and ending in and logged only the trials leading to successful repairs.
.
experimental results we rst present experimental results in table which reports the summary statistics of the extracted information.
the 3rd column and 4th column list the mean and median respectively of number of test case executions ntce for each program.
the 5th column gives the average time of repairing successfully each program.
the 6th column presents the success rate when using one repair tool to x each program.
recall that in our experiment we separately ran rsrepair and genprog times on each of the programs with versions.
hence the success rate is n if there are nsuccessful trials all the other statistics in table are computed according to the nsuccessful trials.
the 7th column reports the e ect size on the di erence between rsrepair and genprog on ntce with the p value presented in the 8th column.
next we use our study results to address the two research questions section .
.
.
rq1 to answer this question we need to describe the measurement of how well the search process performed when comparing genprog and rsrepair.
as described in to conduct a fair comparison it is important to establish the amount of e ort expended by each search algorithm to nd the optimal or near optimal solutions this e ort is commonly measured by logging the number of tness evaluations that were performed .
speci cally for genprog every candidate patch needs tness evaluation.
hence we can compute the number of tness evaluations by logging the number of candidate patches generated in the repair process ncp .
for genprog and rsrepair the one with smaller ncp when some valid patch is found is considered more e ective.
computing precisely ncp for genprog and rsrepair however is di cult due to the stochastic nature of randomized algorithms.
to mitigate against the e ects of random variation in our experiment both genprog and rsrepair are repeated times with di erent seeds.
normally the ncp of each repair trial should be logged for the subsequent statistic analysis.
however running each repair trial without terminal until some valid patch is found sometimes is too computationally expensive when searching a valid patch is a hard problem in term of requiring lots of ncp especially when the programs come with many or long running test cases.
for instance it may take several hours to search a valid patch for wireshark in table with genprog or rsrepair.
as such according to the work we limited the value of ncp within for each repair trial we consider it fails to repair one program if a valid patch is not found when the limitation arrives.
in the experiment it is unfair comparison if we directly analyze experimental results according to the ncp of only successful repair trials.
for example for two concrete repair trials on the same program rsrepair nds a valid patch with the ncp value of and for genprog the ncp value is .
although rsrepair has the better repair ability in term of smaller ncp value the logged value of has the negative e ect on the repair ability of rsrepair using statistic analysis because the value of on genprog259table experimental results by rsrepair and genprog mean median avg.
time s success a test program approach of ntce of ntce per repair rate on ntce p value lighttpd bug 1807rsrepair .
.
.
genprog .
lighttpd bug 1914rsrepair .
.
.
genprog .
lighttpd bug 2331rsrepair .
.
.
genprog .
lighttpd bug 2662rsrepair .
.
.
genprog .
libti bug 01209c9 aaf9eb3rsrepair .
.
.
genprog .
libti bug 0661f81 ac6a583rsrepair .
.
.
genprog .
libti bug 0860361d 1ba75257rsrepair .
.
.
genprog .
libti bug 0fb6cf7 b4158farsrepair .
.
.
genprog .
libti bug 10a4985 5362170rsrepair .
.
.
genprog .
libti bug 3af26048 72391804rsrepair .
.
.
genprog .
libti bug 4a24508 cc79c2brsrepair .
.
.
genprog .
libti bug 5b02179 3dfb33brsrepair .
.
.
genprog .
libti bug 6f9f4d7 73757f3rsrepair .
.
.
genprog .
libti bug 829d8c4 036d7bbrsrepair .
.
.
genprog .
libti bug 8f6338a 4c5a9ecrsrepair .
.
.
genprog .
libti bug 90d136e4 4c66680frsrepair .
.
.
genprog .
libti bug d13be72c ccadf48arsrepair .
.
.
genprog .
libti bug d39db2b 4cd598crsrepair .
.
.
genprog .
libti bug ee2ce5b7 b5691a5arsrepair .
.
.
genprog .
gmp bug 14167rsrepair .
.
.
genprog .
python bug 69784rsrepair .
.
.
genprog .
gzip bug 3fe0ca...rsrepair .
.
.
genprog .
php bug 309910rsrepair .
.
.
genprog .
wireshark bug 37111rsrepair .
.
.
genprog .
we separately ran rsrepair and genprog times on each of the subject programs and only recorded the trials leading to successful repair.260is not logged at all due to the limitation on the maximal ncp.
given this issue we conduct the comparison between genprog and rsrepair as follows.
first we measure how well each repair tool performs using success rate described in table .
the intuition behind this measurement is that an e ective repair tool which probably requires smaller ncp when nding a valid patch should have the higher success rate with the limitation on the maximal ncp in our experiment.
second if genprog and rsrepair for one program such as libtiff bug 4a24508 cc79c2b in table have the same success rate of we further compare the repair e ectiveness according to ncp measurement using rigorous statistic analysis.
speci cally when repairing one program genprog and rsrepair have the completely same patch generation process within the population in the rst generation recall that rsrepair is the modi cation version of genprog with the same patch generation process in the rst generation described in section .
with the same seed genprog and rsrepair should have the same ncp when the ncp value is not bigger than which has been con rmed in our experiment.
given that if genprog and rsrepair have the same success rate of for one program we exclude the repair trials whose ncp are not bigger than the population size of the rst generation because genetic programming used in genprog just starts to work from the second generation.
after the exclusion process we can check whether genetic programming perform well to guide the patch generation process when it does start to work.
as described in table in most cases rsrepair has the higher of or equal success rate of over genprog.
the higher success rate indicates that rsrepair has the higher repair e ectiveness in term of requiring probably fewer ncp in the repair process.
the only exception is onwireshark for which genprog outperforms rsrepair in terms of higher success rate.
having analyzed the repair process we nd that the patched programs are more likely to fail to be compiled in the initial phase of repair process compared to other programs.
thus we suspect the reason for the exception to be that genprog is good at eliminating the bad patches which fails to be compiled and can produce more compilation able candidate patches in the sequent repair process.
to further con rm the advantage of rsrepair we statistically analyze the ncp on the programs for which genprog and rsrepair have the success rate of .
statistic results are presented in figure .
in the analysis process we exclude the repair trials whose ncp is not bigger than note that lighttpd bug is excluded from this table because there exists no repair trials whose ncp is bigger than for this program and statistically analyze the remaining trials with the sizes listed in the 3rd list of figure b on ncp.
the 4th and 5th column report the mean and median values on ncp respectively.
the 6th column gives the statistical signi cance by using mann whitney wilcoxon test to analyze the di erence between the two tools on ncp with the pvalue listed in the last column.
figure suggests that for all the programs rsrepair has the smaller ncp over genprog even if genetic programming starts to guide the patch generation from the 2th generation.
for the last programs in figure b the advantage of rsrepair is statistical signi cance although there exists no signi cant di erence for the remaining programs due to 50100150200250300ncp libtiff bug 01209c9 aaf9eb3 libtiff bug 4a24508 cc79c2b libtiff bug 6f9f4d7 73757f3 libtiff bug 8f6338a 4c5a9ec libtiff bug 90d136e4 4c66680f libtiff bug ee2ce5b7 b5691a5arsrepair genprog a boxplots on ncp of programs.
program approach size mean median sig.
p value libti bug .rsrepair .053632genprog libti bug 4a2.rsrepair .937685genprog libti bug 6f9.rsrepair .479761genprog libti bug 8f6.rsrepair .055556genprog libti bug 90d.rsrepair .000106genprog libti bug ee2.rsrepair .031763genprog b statistical results.
figure the statistical comparison on ncp of programs for which genprog and rsrepair have the success rate .
too small sample sizes no more than in the size column of figure b rsrepair has the smaller ncp in terms of mean and median.
answer for rq1 in our experiment for most programs random search used by rsrepair performs better in terms of requiring fewer patch trials to search a valid patch than genetic programming used by genprog regardless of whether genetic programming really starts to work see figure or not.
we defer discussing the possible reason to section .
.
rq2 as presented in rq1 to nd a valid patch genprog in most cases requires not fewer ncp than rsrepair.
that is compared to random search genetic programming does not bring bene ts in term of fewer ncp in this case to balance the cost caused by tness evaluations.
hence it is not surprising that genprog most often took more time to repair successfully faulty programs on average in table .
then in this subsection we plan to investigate to what extent genetic programming used by genprog worsens the repair e ciency over random search used by rsrepair.
running test cases typically dominated genprog s runtime which is also suitable for rsrepair so we use the measurement of ntce to compare the repair e ciency between genprog and rsrepair which is also consistent with traditional test case prioritization techniques aiming at early nding software bugs with fewer ntce.
an e cient repair tool should nd a valid patch with fewer ntce.
like the evaluation of ncp in rq1 it is di cult to compute precisely the value of ntce due to the stochastic nature of randomized algorithms used by genprog and rsrepair.261020040060080010001200140016001800test case executions lighttpd bug lighttpd bug lighttpd bug lighttpd bug libtiff bug 01209c9 aaf9eb3 libtiff bug 0661f81 ac6a583 libtiff bug 0860361d 1ba75257 libtiff bug 0fb6cf7 b4158fa libtiff bug 10a4985 libtiff bug 3af26048 libtiff bug 4a24508 cc79c2b libtiff bug 5b02179 3dfb33b libtiff bug 6f9f4d7 73757f3 libtiff bug 829d8c4 036d7bb libtiff bug 8f6338a 4c5a9ec libtiff bug 90d136e4 4c66680f libtiff bug d13be72c ccadf48a libtiff bug d39db2b 4cd598c libtiff bug ee2ce5b7 b5691a5a gmp bug python bug gzip bug 3fe0caeada6aa3 39a362ae9d9b00 php bug wireshark bug 37111rsrepair genprogfigure ntce boxplots for experiments.
note that for the python and php which give too large ntce over other programs for the ease of presentation we narrowed down the ntce values with linear scale for the two programs.
as such we use statistical analysis to compare qualitatively and quantitatively the ntce between the two tools.
we rst summarize the ntce value of each tool using the mean because the mean may perform better over median when the result data are constructed from similarly sized clusters around more than two widely separated values .
then we use mann whitney wilcoxon test and a test the two nonparametric approaches to qualitatively and quantitatively analyze the di erence signi cance.
for nonparametric mann whitney wilcoxon test the null hypothesis is that result data from the studied two groups share the same distribution the alternate hypothesis is that the two group data have di erent distributions.
in this case we say the di erence is statistical signi cance when we reject the null hypothesis at a percent signi cance level.
to further assess the di erence quantitatively we use the nonparametric vargha delaney a test which is recommended in and was also used in to evaluate the magnitude of the di erence by measuring e ect size scienti c signi cance on ntce.
for a test the bigger deviation of a statistic from the value of .
the greater di erence of the two studied groups.
in vargha and delaney suggest that a test of greater than .
or less than .
is indicative of medium e ect size and of greater than .
or less than .
can be indicative of a promising large e ect size.
both figure and table suggest that rsrepair has much fewer ntce compared to genprog.
figure presents the boxplots on ntce when running the two tools to x bugs existing in the subject programs.
table reports the detailed statistical result on the measurement of ntce.
obviously for most programs of in our experiment ntce of rsrepair is much smaller than that of genprog in terms of mean the di erence can be statistically signi cance using mann whitney wilcoxon test p value .
in most cases of .
what is more it is reasonable to consider that rsrepair reduces the ntce e ciently in term of often arriving at the promising large e ect size a test .
or a test .
.
answer for rq2 genprog does not nd a valid patch faster than rsrepair.
oppositely in most cases genprog requires much more ntce to repair faulty programs leading to the lower repair e ciency than rsrepair.
.
discussion intuitively genetic programming which uses tness values to guide the patch search process should perform better at least not worse compared to random search.
our experiment results however suggest that genetic programming used by genprog in most cases does not perform better and even worsens the search process with bigger ncp in the repair process.
then why does genetic programming a tness evaluation directed search perform worse than a purely random search in our experiment?
we are not surprised for this experimental results.
in fact andrea arcuri and lionel briand has presented their concern to the e ectiveness of genetic programming used by genprog and considered that genetic programming should be compared against random search to check the ef 262fectiveness although it is mentioned that for many programs random search is as e ective as genetic programming .
the reason for the worse repair e ectiveness by genprog may be tracked down from the paper current tness functions including that used by genprog are either overly simplistic or likely to exhibit all or nothing behavior and thus are not well correlated with true distance between an individual and the global optimum.
in our experiment we found that for genprog most candidate patches have the same or similar tness values even if some ones are very close to valid patches.
furthermore the fact of overwhelming majority of valid patches are generated by the nearest mutate operation rather than combined action of multi operations in terms of patch evolution further presents the evidences that genetic programming does not work as well as we think in the patch search process.
since imprecise tness functions have the chance of misleading the search process in our experimental evaluation it should not be surprising that genprog has the worse repair e ectiveness on many programs than rsrepair for which random search is used.
implication before applying some optimization algorithm in search based research area we should ensure that the tness function used by this algorithm should have the ability of computing at least partly the distance between candidate solutions and optimal solutions.
.
threats to validity the main threats to the validity of our result belong to the internal external and construct validity threat categories.
internal validity threats correspond to the relationship between the independent and dependent variables in the study.
one such threat is on the selection of subject programs in our experiment.
to save the time resource and simplify the implementation of rsrepair we excluded the programs for which xing bugs requires either too many test cases or the modi cation of multi source les.
in fact the more test cases shipped with subject programs the more expensive computational resource often required by tness evaluations because the tness values are computed by sampling these test cases according to a xed rate for genprog more expensive evaluations will reduce the bene t brought by genetic programming because no evidence indicates that tness evaluation based on more test cases can provide some more accurate guidance for patch search in our experiment.
in addition in the future we will investigate whether genetic programming has the advantage over random search on xing bugs existing in multi les.
external validity is concerned with generalization.
since we conducted our experiment only on programs each of which comes with one bug conclusions drawn from our paper may not hold when some subject programs with multi bugs are included in our experiment.
to our knowledge there exists little work on xing automatically faulty programs shipping with multi bugs because automated program repair is generally considered to be a hard work .
when xing multi bugs in one program the success rate can be too low making little sense for statistic analysis.
in addition in this paper we focus only on the comparison between random search and genetic programming in our future work we plan to study random search with the comparison on other repair techniques such as .construct validity threats concern the appropriateness of the evaluation measurement.
we rst use ncp as the measurement to investigate whether genetic programming has a good work at guiding the patch search process with fewer repair trials.
then we measure the repair e ciency of genetic programming by the comparison between genprog and rsrepair according to ntce.
for the analysis to experimental results rigorously statistical analysis including mann whitney wilcoxon test and a test is used.
.
conclusions as an important optimization algorithm in the area of sbse genetic programming has been applied successfully to many elds within the general area of software engineering.
recently in the paper genetic programming is proposed to x automatically the general bugs and a prototype tool called genprog based on this technique is implemented.
after that general automated program repair has gone from being entirely unheard of to having its own multi paper sessions such as program repair session in icse in many top tier conferences and many researchers justify the advantage of their techniques such as par and semfix via the comparison with genprog.
furthermore a ected by genprog par also uses genetic programming to guide the patch search in the way like genprog.
although genprog and par have presented their promising results to what extent the patch search process bene ts from genetic programming is still unknown.
furthermore the question of whether the bene t brought by genetic programming can balance the cost caused by tness evaluations is not addressed.
in this paper we try to investigate the two questions via the performance comparison between genetic programming and random search.
experiment on programs with versions shipping with real life eld failures suggest that random search used by rsrepair in most cases nds valid patches faster i.e.
requiring fewer patch trials to nd a valid patch over genetic programming used by genprog and for most programs genprog requires much more test case executions to nd a valid patch over rsrepair which indicates that the bene t brought by genetic programming cannot balance the cost caused by tness evaluations and thus worsens the patch search process.
complete experimental results in this paper are available at based on experimental results we challenge the research community to develop novel repair techniques using optimization algorithm to defeat the random search algorithm presented in algorithm in terms of ncp and ntce.
.