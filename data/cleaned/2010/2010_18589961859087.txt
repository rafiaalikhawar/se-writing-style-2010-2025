apt pbo solving the software dependency problem using pseudo boolean optimization paulo trezentos iscte adetti caixa magica av.for as armadas lisbon portugal prrt iscte.ptin s lynce inesc id ist tu lisbon av.
rovisco pais lisbon portugal ines sat.inesc id.ptarlindo l. oliveira inesc id ist tu lisbon av.
rovisco pais lisbon portugal aml inesc id.pt abstract the installation of software packages depends on the correct resolution of dependencies and con icts between packages.
this problem is np complete and as expected is a hard task.
moreover today s technology still does not address this problem in an acceptable way.
this paper introduces a new approach to solving the software dependency problem in a linux environment devising a way for solving dependencies according to available packages and user preferences.
this work introduces the apt pbo tool the rst publicly available tool that solves dependencies in a complete and optimal way.
categories and subject descriptors d. .
general terms algorithms reliability .
introduction software installation is the process of installing programs assuring that speci cally required software is pre installed and that de ned actions are taken before or after the copy of the les into the le system .
although this is a common problem among microsoft and free open source operating systems linux bsd ... we will focus on the later ones since a progress in this eld would be applicable to all environments including applications like eclipse or firefox .
the installation process comprises retrieving the package solving the software dependency tree retrieving and installing the software dependencies and nally installing the package and executing the associated install scripts .
the dependency graph represents the software dependencies and sub dependencies needed for a package to work properly after installation .
the restrictions imposed by permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.the graph may have no solution for instance due to broken dependencies only one solution or several solutions.
criteria such as the minimum number of packages or up todate packages can be de ned to rank the solutions in terms of their quality.
finding a solution consists in de ning the sub set of packages that meets the dependency requirements.
this process is called dependency solving.
there are three main contributions in this paper.
first our main nding is an e cient encoding of the dependencies and con icts as a pseudo boolean optimization problem without the need for integer linear programming ilp or satis ability sat extra steps thus providing a tool capable of nding a solution in every possible case.
second we achieve this goal by proposing a exible algorithm that can be adjusted to user preferences without sacri cing performance a critical issue for a tool with user interaction.
finally the developed tool is available under a free license allowing enhancements and benchmarking by the research community.
this paper is organized as follows.
in the next section we review the basic principles of the dependency solving problem as well as an introduction to pseudo boolean optimization.
section describes the methodology used providing a system overview and discussing di erent optimization criteria.
section presents experimental results and section describes related work.
finally section presents the concluding remarks.
.
background .
dependency solving problem the dependency solving was proved to be np complete .
this con rms a well known relationship an increase in the number of packages causes a rapid increase in the complexity of the problem for which no e cient solutions are known.
finding a solution becomes rapidly more di cult as the number of available packages grows and the number of versions of each package increases .
existing installers like apt yum smart or urpmi are known to report no solution even if one exists since the search performed is incomplete.
.
.
problem definition a package is installable if all of its package dependencies can be satis ed using packages in active repositories repositories being a collection of packages that are commonly stored remotely .
the number of dependencies and con icts between packages can become very high in the scope of open source repositories of software .
although open source systems oss and namely linux distributions share the basic software components glibc gcc ... the packaging system is slightly di erent amongst them.
some distributions use the rpm format red hat package management system others use the deb format debian system and a minority use the almost deprecated tarball system.
the dependency solving problem applies equally to rpm and deb given that the existing di erences are in format speci cation and do not compromise a universal de nition of the problem.
the following de nitions are needed to de ne the dependency solving problem package a package pis a pair u v whereuis a unit andvis a version.
units are represented by strings and versions are represented by non negative numbers.
the set of all packages in a repository is denoted by p. dependencies a dependency1of a package pis a set of sets of packages d1 d k. a dependency may include a package version constraint de ned by one of the following binary operators or .
such a dependency corresponds to a set of dependencies each of which is called sub dependency.
if pis to be installed then each dependency dineeds to be satised i.e.
at least one package in each set of packages dimust be installed.
con icts a con ict is a symmetric relation between two packages.
two packages con ict with each other if that is stated in their metadata information if they have an element ewith exactly the same location in the le system or if they are di erent versions of the same package2.
repository a repository can be represented as a tupler p d c wherepis the set of all packages d p!
p is the dependency function with x representing the set of subsets of x and c p p is the con ict relation.
dependency tree a dependency tree dtof a packagepis an and or graph gwhere each node corresponds to a package or a set of packages and the edges correspond to the sub dependencies.
the root of the tree corresponds to package p. the dependencies are represented with and edges and the sub dependencies are represented with or edges.
moreover con icts may also be represented.
31px y1 figure generic dependency tree 1dependencies are de ned as requires in rpm terminology.
2by de nition in deb and by practice with exceptions in rpm.figure depicts a set of packages pthat under repository rhas dependencies sub dependencies and con icts3.
the partial representation of repository rin this gure may by de ned by the tuple p d c with p f p x x y y y g d p ff x x g f y y y gg d x d x d y d y d y fg c y x empty sub sets for the dependencies mean that the package itself meets the dependency requirements.
this concept can be applied to a speci c example of a package installation.
for this purpose we present the dependency tree for the carpackage in figure .
the carpackage depends on packages engine wheel and door.
doorengine 3tyre window 221conflicts glassglasswheelcar 221turbo figure dependency tree for the carpackage a successful dependency solving algorithm for package p should derive the correct set of packages from the corresponding dependency tree dtp.
since in most cases several solutions can be found the algorithm should derive the solution that best meets user preferences.
in section .
we introduce criteria for solution assessment.
.
boolean satisfiability and pseudo boolean optimization the dependency solving problem can be easily encoded into boolean satis ability sat using the conjunctive normal form cnf where a cnf formula is a conjunction of clauses a clause is a disjunction of literals and a literal is a boolean variable x or its negation x .
each package is represented by a boolean variable and therefore a variable assigned value true corresponds to an installed package whereas a variable assigned value false corresponds to a package that is not installed.
in addition dependencies and con icts are represented by clauses.
for each package pand its dependencies d1 d k are created kclauses p d1 ... p dk .
moreover a binary clause p p0 is created for each con ict between two packages p andp0.
for example the dependency tree in figure is represented by the following cnf formula p1 x1 x2 p1 y1 y2 y3 x1 y3 3for simplicity the tuple representation of a package as p will be now represented as p2 428however it should be noted that sat is a decision problem and any solution to the problem is equally valid.
in case some solutions are better than the others we move to an optimization problem and a extension of the sat formulation called pseudo boolean optimization pbo should be used instead.
in a pseudo boolean formula variables have boolean domains and constraints called pb constraints are linear inequalities with integer coe cients x ici li nwithi2n ci n2zandli2f0 1g whereciandnare integer constants and liare literals.
the operator may be replaced by other operators such as .
from an integer linear programming ilp point of view pb constraints can be seen as a specialization of ilp where all variables are boolean which explains why this formulation is also known as ilp.
from a sat point of view pb constraints can be seen as a generalization of clauses.
for example clause p1 x1 x2 is translated to the pbconstraint p1 x1 x2 .
if one considers that p1can be replaced by p1 then we obtain the equivalent pbconstraintx1 x2 p1 a pseudo boolean formula can be extended with an optimization function in which case the resulting formula is called a pbo formula.
in the context of the dependency solving problem the optimization function can be used to establish preferences between packages.
clearly some installed packages are more important than others and therefore guaranteeing that these packages are not uninstalled should be a priority.
.
methodology in this section we present our methodology for using pseudoboolean optimization for solving dependencies and con icts in a package installation.
.
system overview figure depicts a typical installation ow of apt pbo.
the core of the system is the apt pbo application that has di erent hooks to integrate modules.
however in the tests performed the overhead of the external calls is not signi cant since the number of iterations is extremely low.
note that this architecture allows the exchange of modules.
for example changing the pbo solver is an extremely easy task.
solutionapt get pbo install problem.pboparsing solutionapt get install solverpboapt pbo install car installed packages1 figure high level apt pbo processing ow the apt pbo application is called with the operation install and the desired package as arguments which map the usage ofapt get .
the components of the gure have the following role require package to install p1 pol repeat f c pboinstall p1 pc pol r pi s solver f c pc fg for allpi2ssuch thatpi 0do pc checkrdeps pi end for for allpj2ssuch thatpj 1do pc checkrconfs pj end for untilpc fg figure iterative apt pbo solving algorithm for package installation problem apt get pbo install we have a modi ed version of apt get installation software.
apt is one of the most used meta installers and is adopted by di erent linux distributions like debian ubuntu and caixa m agica.
our modi cations created a new method called pboinstall which given a speci c package calculates the dependency tree and writes the pbo encoding.
the pbo encoding is composed of pb constraints and an objective function.
pbo solver the problem.pbo formula is solved by the pbo solver.
we have used and tested di erent solvers to be introduced in section .
.
parsing solution apt pbo has a module that parses the solver solution and if necessary establishes a new iteration with apt get pbo install .
apt get install solution when the nal package set solution is reached the user is asked for permission and the removal and installation of the packages are performed using apt and dpkg rpm.
the apt pbo algorithm in figure describes the proposed approach to the process of nding the solution taking into account the available set of packages and the user de ned policy regarding installation.
the solution is the set of packages that change status due to the install transaction.
a change of status occur when a package is marked to be removed or to be installed.
given a package to install p1 the universe of available packagesr repositories the installed set of packages pi and the user policy regarding installation polwe start by encoding the problem as pbo calling pboinstall .
this procedure returns fas the cost function that minimizes the problem having the user policy poland returns cas the pseudo boolean constraints that must be obeyed during the optimization process.
constraints crepresent a directed acyclic graph that aggregates all the packages upon which p1depends on or conicts with as well as their own dependencies and con icts.
the installation problem encoded in pbo is passed to the solver that returns the best solutions line .
after having a possible solution returned by the solver we will check all elements in sthat have a reverse relation 429outsidec.
recall that sonly contains packages that changed status.
if package piis proposed to be removed we will check forpireverse dependencies4and add them to pc line .
the same is done to pj a new package that will be installed but with its reverse con icts.
we continue until the solution does not hold any reverse dependency not yet added to pc.
in the next sections we will discuss criteria that will be used to de ne the objective function and present our proposals.
.
optimization of the criteria although di erent sets of dependency packages can be found for installing a speci c package it is possible to rank solutions as more or less desirable.
the best solution may not be the same for every user as it depends on how the packages wil be use the nature of the system development production home pc critical data server ... and the limitations of the resources.
user preferences are ultimately encoded as pbo although they can be expressed initially in formats like cudf common upgradeability description format and then encoded into pbo.
a number of policies can be used to optimize the resulting installation .
three of them were implemented in aptpbo aremoval policy number of installed packages that will be removed less is better .
bnumber policy number of total packages that will be installed less is better .
cfreshness policy number of packages in the system that are not the newer ones less is better .
other policies could be easily considered such as the total download size the nal install size or the popularity.
from our empirical experience with users in the scope of the deployment of a linux distribution present in more than computers we found the criteria a b and c as preferable.
although heuristics can and have been used in the past to optimize a single criterion that approach does not allow hybrid solutions or exible changes on the relative values of each factor in run time.
optimization of only one criterion leads in most cases to a loss of quality with respect to other criteria.
this happens since some of them are correlated and have con icting objectives.
for instance getting a fresher package will typically lead to a larger one since new features are introduced and size tends to increase.
this is also true for removal and freshness .
if we want to avoid removing packages this will most probably compromise the freshness approach.
in the next section we will formulate the installation problem as a pseudo boolean optimization problem.
the goal is to obtain the solution that best ts the user preferences expressed as multi dimensional criteria.
4a dependency of p1is a package pdthat must be installed in order to install p1.
ap1reverse dependency is a package prdthat depends on p1.car2 engine2 engine1 car2 engine2 engine1 wheel2 wheel3 car2 wheel2 wheel3 door1 door2 car2 door1 door2 turbo1 engine1 tyre1 tyre2 wheel3 tyre1 tyre2 window0 window1 window2 door2 window0 window1 window2 glass1 window1 glass2 window2 glass2 tyre2 glass1 glass2 figure car problem constraints de nition .
.
pbo encoding for dependency solving the pbo encoding is done in two steps.
first the constraints are de ned using the dependency tree graph.
second the objective function is de ned by weighting di erent criteria.
constraints de nition in a pseudo boolean formula variables have boolean domains and constraints are linear inequalities with integer coe cients.
encoding relations of the dependency tree as constraints is a straightforward task.
the following translations will be used installation p1is the package that we want to install p1 .
in the context of pb constraints saying variablep1has to be assigned value implies having a greater or equal constraint.
dependency p1depends on x1should be represented asx1 p1 .
this means that installing p1implies installing x1as well although x1may be installed withoutp1.
ifp1also depends of y1 we should add y1 p1 .
multiple versions if a package p1requires the installation of a package xhaving di erent versions for examplex1andx2 then we should encode the requirement that installing package p1requires installing either package x1or package x2.
hence such requirement may be encoded with constraint x1 x2 p1 .
con icts if a package has an explicit con ict with other package for instance if y3con icts with x1 then this con ict is encoded as x1 y3 .
remember that each pair of di erent versions of the same package is considered a con ict.
for the example given in gure the constraints would be de ned as presented in gure .
objective function de nition the quality of the solution relies on the de nition of the objective function.
the policies proposed in section .
can be easily translated into pbo encoding.
minimizing package removal to minimize the number of removed packages even if newer packages exist one should use the following objective function wherepi0 pi0 nare the packages already installed 430f1 p min pi0 pi0 n in order to minimize the objective function the solver will try to set variable piito which will imply not removing installed packages.
minimizing the number of installed packages in this case the total number of packages installed in the system is to be minimized.
having p1 pn as the new packages targeted to be installed either existent or new the objective function will be f2 p min p1 ... pn maximizing the freshness of packages if the user wants the most recent version of the packages then the objective function should make the system install the most recent versions independently of what is already installed.
considerp11 p1k1to be di erent package versions or releases of package p1.
also consider v p11 to be the normalized distance a constant for the purposes of the pbo problem between the package p11and the newest version present in repository r. then the optimization function is f3 p min p11 v p11 p1k1 v p1k1 p21 v p21 p2kn v p2kn the value of v piki is zero if the package is the newest in the repository.
optimization of only one criterion leads in most cases to a loss of quality with respect to other criteria.
this happens since some of the criteria are correlated.
for instance getting a fresher package will typically lead to a larger one since new features are introduced and size tends to increase.
this is also true for removal and freshness .
if we want to avoid removing packages this will most probably compromise the freshness approach.
in the next section we propose an approach to overcome this problem.
.
multicriteria optimization trying to satisfy di erent criteria when nding the set of packages for a software installation falls in the multicriteria decision making mcdm set of problems and there is previous work on applying pbo to this research area .
apt pbo integrates the di erent objective functions of the previous section as a multiobjective problem mop seeking the e cient solutions in the sense of pareto optimality min f1 p f2 p f3 p withpas the available packages and f1 f2andf3as the existent objective functions.
the multiobjective problem is solved transforming it into a single objective problem through weighted sum scalarizationof the form min3x k k fk p where we minimize an additive function of the scalar product of that denotes the user de ned coe cients and fk p i.e.
the objective functions de ned before.apt pbo uses the following coe cients representing the overall utility for the user removal cost wr weight given to the cost of a removal of a package.
this coe cient is typically large when applied to a server in a critical environment.
presence cost wp weight given to the presence of a new or an already installed package in the solution.
version cost wv weight representing the cost of having an older version in the solution when a newer one exists.
the objective function is then de ned as min wr f1 p wp f2 p wv f3 p instead of a weighted sum scalarization transformation we could easily compare the criterion vectors f1 p f2 p f3 p in lexicographic order but then would loose some of the exibility introduced by the multiobjective approach.
.
experimental results we performed experiments on a large set of di erent repositories packages and systems hosted at o2h lab cluster of xeon cpu cores5with linux installed in xen virtual system machines and inside a chroot environment.
in the next sections we report the results of this evaluation.
.
experimental methodology the goal of the experiments performed was to simulate the installation of software in a linux environment and test the various criteria under di erent environments.
we performed two groups of tests one more oriented towards the nding of a solution and another more focused on the characterization of the solution itself.
the tested applications were apt get the most used meta installer among linux distributions.
apt get was called with no install recommends to assure that the goal was exactly the same for all tested applications.
apt pbo the tool proposed in this paper and tested with three di erent policies freshness removal and number .
each policy has a multicriteria function de ned and is given a higher weight to the corresponding focus.
smart a meta installer developed in python with heuristics to solve complex cases .
aptitude meta installer with its own engine for dependencies solving .
.
experimental data the data was generated using linux debian lenny release as the operating system.
lenny is considered to be a stable version of debian and is widely used.
this lenny installation has the following characteristics 5the infra structure is integrated in the adetti iscte centre of rng grid.
the base system is a linux debian lenny system with lenny o cial updates backports and debian multimedia repositories active which account for distinct versions of packages normal packages and dependencies.
as a common basis for all the tests we use a typical linux installation without x11 graphical interface and comprising base packages.
some of the installed packages are from debian sid the development version.
all tests were performed using a batery of installation transactions of the most popular packages.
this information was provided by the debian popularity contest .
using the popularity ranking contributes to assure that the tests are representative.
for this purpose a scheduler job manager was developed in perl which was responsible for scheduling the installation jobs in the cluster process the outputs store the logs with the results of the installation and control the timeouts6.
.
comparing meta installer performance the rst phase of benchmarks consisted in analysing the main existent linux meta installers apt get smart and aptitude against apt pbo .
the time measured refers to the time between the call of the application and the return of the solution.
retrieval of packages and installation was not measured because network latency might introduce spurious noise.
the time spending on building the cache apt get update smart update was not taken into account since it is performed in the same way by all meta installers.
table benchmarking of meta installers results in seconds meta installer average time standard deviation apt get .
.
aptitude .
.
smart .
.
apt pbo .
.
the results presented in table re ect the comparison of apt pbo and other used meta installers.
in this test for aptpbowas chosen removal user policy as it is eventually the default of a normal user and it is the one which is closer to other meta installers solution.
although apt pbo takes longer than the other tools it still provides a solution in a reasonable time .
seconds on average that does not compromise the user s experience of a package installation.
figure presents the time taken by each meta installer to solve a package installation problem varying the size of the problem measured in terms of installed packages .
as expected with apt pbo the time of the execution grows with the size of the problem but the increasing is progressive.
this fact is replicated with the standard deviation results depicted in table which shows a low standard deviation.
apt pbo allows the use of di erent user policies for the selection of the packages to install section .
.
.
each user policy has di erent weights mapping the importance of number removal or freshness of packages.
6the time limit was set to seconds.
after seconds the job was killed.
140execution time seconds problem size installed packages apt get aptitude smart apt pbofigure execution time of meta installers 120execution time seconds problem size installed packages removal number freshness figure execution time of apt pbo according to di erent user policies in gure and table we analyse the apt pbo execution time for di erent size problems when changing the userpolicy removal number and freshness .
the freshness policy involves the installation of a large number of packages which requires more time not only in the solving part but also in parsing the solution.
table benchmarking of apt pbo user policies results in seconds meta installer average time standard deviation removal .
.
number .
.
freshness .
.
.
comparing different pbo solvers a comparison of sat solvers has been done intensively in the past through international competitions and benchmarks .
since the solving algorithm can bene t greatly from the structure of the problem it was considered important to test di erent pbo solvers in this problem.
432as mentioned in section .
apt pbo is structured in modular form allowing the replacement of one solver instance by another compatible solver.
for testing purposes four solvers were considered minisat based on minisat a well known sat solver minisat encodes pb contraints into sat.
bsolo bsolo is a pbo solver which was rst designed to solve instances of the unate and binate covering problems ucp bcp and later updated with pseudo boolean constraints support.
wbo participated in pb competition this solver uses weighted boolean optimization which aggregates and extends pbo and maxsat.
opbdp an implementation in c of an implicit enumeration algorithm for solving pbo.
besides the solvers mentioned above pueblo was also considered but not included since the only available version is dynamically linked and the libraries needed are old and not available in the testing infra structure.
nevertheless an old linux system was installed debian etch and some adhoc tests were performed with pueblo.
these tests revealed that pueblo has in general a bad performance for this speci c type of problems and no further e orts to port pueblo were made.
table summarizes the results.
as can be veri ed both wboandbsolo are able to solve all the instances but wbohas a better performance .
seconds on average per transaction .
minisat comes in third place not only with a low number of instances solved but also with a poorer performance taking on average more than two minutes to solve a problem.
table pbo solvers benchmarking wbo bsolo minisat opbdp solved timeouts average time .
.
.
.
figure compares wboand bsolo varying the number of the installed packages.
there is a smooth growth by wbo and a more unstable line of growth in a much more unpredictabile fashion by bsolo .
.
unmet dependencies analysis the unmet dependencies are reported by apt and other meta installers when a required dependency is not found.
this could be either the result of a broken dependency in the repository or the solver just being unable to nd it in a proper way.
the rst topic has been investigated by di erent groups and has registered a signi cant progress.
in this section we present the results that demonstrate the inability of today s meta installers namely apt get to nd a solution in every case and on the other hand the encouraging results of apt pbo .
a speci c example of a unmet dependency is presented in gure .
in gure the package ksplash is represented with multiple dependencies.
one of them is kdebase data that is available under two versions .
.
and .
.
.dsfg.
.
the 120execution time seconds problem size installed packages bsolo wbofigure pbo solvers graph ksplash kdelibs4c2a libc6libgcc1libstdc 6kdebase data libx11 6libxext6 .
.
.dfsg.
.
.
figure example of an unmet dependency ksplash package.
ksplash package has two constraints that say that it requires kdebase data .
.
.dfsg.
and kdebase data .
.
.dfsg.
which match with existent package .
.
.dsfg.
.
apt get is only able to backtrack into the newest version and unable to nd the solution.
this is the simplest category of problems but over a large group of relations presents a hard problem.
recall that package dependencies can have version comparison operators as well as boolean operators depends on debconf or debconf .
.
the second group of unmet dependencies problems are related with con icts.
a package might con ict with another package which results in the need to install another version.
for the assessment of unmet dependencies extension we performed tests over a universe of the top packages ofpopcon list.
apt get reported the inability to install packages due to unmet dependencies.
these packages correspond to .
of the total packages not being available to the user which is an unusual high rate.
this high rate is justi ed by a base system that contains a mixture of packages from both lenny and sid.
table metainstallers and solution characterization meta installer possible no wrong solutions solutions solutions apt get aptitude smart apt pbo apt pbo as well as smart was able to nd a solution to 433every case of the packages.
aptitude performed also well with the exception of a false positive of a package that was not installable and was reported as so.
.
package installation solutions assessment the nding of a solution by apt pbo is important only if it is as good or even better than solutions returned by existent tools and techniques.
in what follows we show that theapt pbo solutions are equivalent and sometimes better fewer packages newer packages installed or few packages removed.
this varies according to the policy de ned.
table refers to tests with lenny as characterized before.
the tests generated the transaction install upgrade ... of packages in the de ned environment.
in each column is presented the sum of packages for the .
installation transactions that changed status.
table total package transactions by metainstaller packages tool installed updated removed downgraded apt get aptitude smart pbo freshness pbo removal pbo number as we can con rm analysing table the results are very di erent between meta installers.
apt pbo with freshness policy proposes a lot more updates which is a critical point for users that want to have their system updated.
this ability to update the system even further than the direct dependencies tree as also an impact on the removed factor being the lowest of all benchmarks.
apt pbo removal will need to have its weighting tweaked to get better results than freshness.
apt get aptitude smart pbo freshness pbo removal pbo number of totalinstallupdatesremovedowngrade figure relative transaction distribution by meta installer the graph in gure provides a global overview of the data in table and shows that the structures of the solutions are very di erent.
in what concerns apt pbo di erent policies table presents the average number of each transaction per installed pack table average package transactions for apt policies tool installed update remove downgrade pbo freshness .
.
.
.
pbo removal .
.
.
.
pbo number .
.
.
.
age.
apt pbo with the removal policy performed under expectations .
seconds for the removal criterion on average per package installation .
hence in the future the weights should be rebalanced to obtain better results in terms of removed packages.
on the other hand apt pbo with number policy outperforms smart and aptitude with respect to removal factor compensating it with the downgrade which could be a good trade o for critical servers.
the experimental results are very encouraging and apt pbo is starting to be tested by real users.
on the other hand the pbo approach was able to nd a solution to every installation problem even when the original apt installer was not capable of so.
the solver nds rapidly a solution for the instances presented and the package selection problem is not only manageable but also very e cient when using the pbo approach.
the freshness cost function gets not only the solution with newer packages but also the minimal number of installed packages.
the time consumed is very acceptable for a user interactive application.
.
multi criteria analysis in section .
we presented the theory behind the multicriteria approach of apt pbo and in the previous section we presented a pre de ned set of weights for di erent user proles freshness removal and number .
focusing on freshness policy and xing the other weights we will now analyse the variation of version cost wv with two values.
in the rst scenario that we call conservative freshness wvis set to .
in the second scenario that we call aggressive freshness wvis set to .. table varying weights in freshness policy average aggressive conservative install .
.
updates .
.
remove .
.
downgrade .
.
time .
.
timeouts from table we conclude that although on average the changes are not so signi cant they have important di erences.
for instance the removal time doubles in the aggressive freshness because we are strongly interested in having updates and so the compromise is to allow some packages to be removed.
in the installation of packages packages have been removed against just packages removed in conservative freshness.
the best way to check di erences is by analysing a real case the installation of the at spi package with di erent weights.
at spi is an assistant interface that provides ac434cessibility to gnome graphical environment and therefore exhibits several gnome package dependencies.
table installing at spi package with conservative and aggressive freshness weights aggressive conservative install updates remove downgrade time .
.
the conservative freshness pro le avoids the removal of packages as can be seen in table .
however the trade o is extra packages for install and downgrade.
libgnomevfs2 .
libhal1 .5libgconf2 .
.22libbonobo2 .22conflicts .
at spi .
libnautilus extension1 .
.20file roller .
.22breaks .
... .. 2breaks .
figure package at spi installation with conservative freshness figure presents a graph of a sub set of at spi dependencies.
in order to install at spi we need to install the package containing libbonobo2 library.
this package is only available in version .
which con icts with libgconf2 package thus resulting in the proposal of downgrade of this package from .
to .
.
however package le roller depends on the previous libgconf2 version.
in the conservative freshness le roller is downgraded causing the installation of new packages and the downgrade of packages.
libgconf2 .
.22libbonobo2 .22conflicts .
at spi .
file roller .
.22libnautilus extension1 .
breaks .
figure package at spi installation with aggressive freshness the aggressive freshness see gure is more tolerant to removals.
the removal of the le roller package proposed in this pro le avoids the massive installation of packages and downgrade of a few other.
having that le roller is not a critical package but rather a graphical frontend for commandline compressing tools this may be the best solution for a large group of users.
observe that the simple lexicographical ordering of objective functions has this exact problem in package installationrealm we lose by independently optimizing a single criterion over all the others.
.
related work in the eld of component based systems the use of pbo was proposed generically for the assembly of components in .
the use of boolean satis ability sat for solving the dependency problem has rst been proposed in the context of the edos fp6 project which had impact in other research e orts .
an alternative formulation using constraint programming techniques has been described in including the use of di erent heuristics for improving the quality of the solution found.
later on the use of pbo has been independently proposed by two di erent research teams .
the opium tool presents some drawbacks which in our opinion can invalidate the approach.
first it encodes the whole package universe as constraints which requires extra computation in opposition to a selective and incremental choice of the packages as presented in the algorithm of gure .
finally it does not provide a formal description for the pbo encoding and the optimization function which is a critical part of a meta installer proposal.
.
conclusions in this work we formulated the installability problem as a pseudo boolean optimization problem in order to be able to encode not only the constraints implied by the package dependencies but also the optimization criteria chosen by the user that characterize each installation.
an open implementation based on apt has shown that the developed tool can be easily recon gured to use this method which can be e ectively used for real installation problems.
after the intensive testing in debian deb and caixa magica rpm distributions we propose to continue developing the current approach to further extend the tool and to port it to other distributions.
the enhancement of cost functions for the di erent criteria will be pursued with the goal of better performance and improvement of the solutions provided.
given the complexity of the problem some techniques will have to be devised to abort the search process if in some instances it is taking too long to nd a particular solution.
however we believe that such behavior will be more the exception than the rule and that this method vastly improves the actual state of the art where installers fail with relatively trivial problem sets and obtained solutions are far from perfect.