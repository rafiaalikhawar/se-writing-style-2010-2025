a study of equivalent and stubborn mutation operators using human analysis of equivalence xiangjuan y ao college of science china university of mining and technology chinamark harman crest centre university college london ukyue jia crest centre university college london uk abstract though mutation testing has been widely studied for more than thirty years the prevalence and properties of equivalent mutants remain largely unknown.
we report on the causes and prevalence of equivalent mutants and their relationship to stubborn mutants those that remain undetected by a high quality test suite yet are non equivalent .
our results based on manual analysis of mutants from programs reveal a highly uneven distribution of equivalence and stubbornness.
for example the abs class and half uoi class generate many equivalent and almost no stubborn mutants while the lcr class generates many stubborn and few equivalent mutants.
we conclude that previous test effectiveness studies based on fault seeding could be skewed while developers of mutation testing tools should prioritise those operators that we found generate disproportionately many stubborn and few equivalent mutants.
categories and subject descriptors d. .
testing and debugging general terms reliability veri cation keywords mutation testing equivalent mutant stubborn mutant .
introduction in mutation testing faults are deliberately inserted into a program to create a mutant version the mutant simulates the e ect of a real fault .
mutation testing has been widely studied as a means of validating the fault nding ability of test suites by seeding faults .
mutation testing has also been used as a means of generating test suites that nd these seeded faults .
we believe that this paper s ndings have implications for both mutation based test assessment and test data generation.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.a test input that reveals a di erence between the bahaviour of a mutant and the original program from which it is constructed is said to kill the mutant.
the motivation for all approaches to mutation testing is that test data that kills mutants should hopefully also detect real faults thereby making mutation testing useful for both test e ectiveness measurement and test data generation.
the two problems that have traditionally inhibited wider application of mutation testing are the equivalent mutant problem and the large number of possible mutants that might need to be considered.
the problems posed by the large number of mutants have been partly dealt with through selection mutant schema and search but the problem of mutant equivalence remains unsolved.
for some mutations the semantics of the mutant and original will turn out to be equivalent even though their syntax is di erent.
it is undecidable whether a mutant is equivalent to the program from which it is constructed .
this is the equivalent mutant problem a tester is never sure whether unkilled mutants are merely hard to kill more test e ort is required or equivalent attempts to kill them are futile .
mutation operators that tend to generate disproportionate numbers of equivalent mutants will thus bias results and much e ort will be wasted trying to kill them.
in this paper we want to better understand the relationship between equivalent mutants and so called stubborn aka super hero mutants.
that is assuming testing has been reasonably thorough then the set of mutants that remain unkilled will fall into one of two categories .equivalent the mutants in this set cannot be killed because they are equivalent to the original program.
no possible test input exists that can distinguish their behaviour from that of the original program.
.stubborn the mutants in this set canbe killed.
each stubborn mutant does have a test input that distinguishes its behaviour from that of the original program.
however none of these distinguishing test inputs has yet been found.
naturally the de nition of a stubborn mutant depends upon the de nition of reasonably thorough testing.
as we increase the fault revealing power of the testing process there will be consequently fewer stubborn mutants.
in the limit if we de ne reasonably thorough testing to be exhaustive testing then no mutant will be stubborn since any unkilled mutant must be equivalent.
however exhaustive testing is just as infeasible as the equivalent mutant problem itself.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
in this paper we de ne a mutant to be stubborn if it remains unkilled by a test suite that covers all feasible branches.
like the equivalent mutant problem branch feasibility is also undecidable.
therefore for each of the programs we study we also use human e ort and ingenuity to generate a test suite that covers all feasible branches.
we believe this to be reasonably thorough because branch coverage is the ultimate goal as yet not fully realised of many test data generation systems .
we present the results of a study of equivalent and stubborn mutants for the selective set of mutation operators.
this is a widely used category of mutation operators identi ed by previous work on selective mutation .
the set consists of ve collections of mutation operators each of which involves di erent numbers of speci c mutation operators.
in total our study considers mutation operators to provide the following primary contributions .
distributions we report on the numbers and distributions of equivalent and stubborn mutants over the set of operators and programs ranging from previously studied tiny programs through to medium sized real world programs.
we nd that the equivalent mutant problem a ects programs of all sizes.
.
stubbornness and equivalence relationship we study the relationship between equivalence and stubbornness identifying operators that create high numbers of equivalent yet few stubborn mutants.
such operators are less effective in test assessment and generation and so their continued use is called into question by our ndings.
our results also provide evidence that some operators generate many stubborn yet few equivalent mutants.
these might be prioritised in future work on mutation testing.
.
causes of equivalence we report on the causes of equivalent mutants and their distribution over the consequent categories of equivalence.
we nd that surprisingly few equivalent mutants are caused by dead code.
we also nd that the largest single cause of equivalence is mutants that cannot even be killed by weak mutation testing.
furthermore those that cannot be killed even by strong mutation testing are largely the result internal state changes of little consequence i.e.
never output rather than those that fail to propagate to an output.
.
size e ects we report on the relationship between program size and the numbers of equivalent and stubborn mutants and the statistical correlations observed between mutant equivalence and stubbornness.
we nd that size and numbers of mutants are strongly correlated with equivalence expected but not with stubbornness unexpected .
we also found that the operators of the ror class exhibit a moderately strong correlation between equivalence and stubbornness but no other class did .
the rest of this paper is organised as follows.
section motivates the research questions that we investigate while section explains in detail the manual decision procedures used to answer them.
section provides the results of the study answering the research questions while section draws out the actionable ndings and recommendations for mutation testing that accrue as a result of our study.
section considers the threats to the validity of our ndings and to those of previous studies revealed by our work.
section describes related work on equivalent mutants while section concludes with a summary of our ndings.
.
research questions this section presents the research questions concerning equivalent and stubborn mutants and the relationship between them for which section provides the answers.
all mutation testing is a ected by the possible distorting e ects that the presence of equivalent mutants can have on the mutation score reported.
therefore the natural rst research question we consider concerns the prevalence of equivalent and stubborn mutants over the programs considered rq1 what are the numbers and proportions of equivalent and stubborn mutants found overall and per program studied?
rq2 what is the contribution of each mutant operator to the proportion of equivalent mutants found and the relationship between equivalent and stubborn mutants?
the relationship between equivalent mutants and stubborn mutants is interesting because they may be connected.
in all mutation testing it is natural to include as many stubborn mutants as possible since these drive testing hardest while also hoping to exclude as many equivalent mutants as possible.
a stubborn mutant is very hard to kill while an equivalent mutant is impossible to kill.
perhaps all mutants lie on a spectrum of killability from easy to kill to impossible to kill.
alternatively perhaps some mutation operators generate more stubborn mutants than equivalent mutants or vice versa.
knowing about these properties of mutation operators will be useful in the design of mutation testing systems and choices of operators to be used.
we examine the contribution of each mutation operator and class of operators and report on a statistical analysis of the correlations between stubborn and equivalent mutants.
rq3 what are the causes of mutant equivalence?
we need to study the causes of equivalence because not all equivalent mutants are equal.
for example those that are caused by the inability of any test case to even execute the mutated code are merely a manifestation of dead code in the program studied.
they can be regarded as entirely a property of the program studied rather than the mutation operator concerned all mutation operators applied at the same unreachable point would yield equivalent mutants.
if we had a better understanding of the causes of mutant equivalence then this may help us to design mutation tools that can ameliorate their pernicious e ects.
finally we ask whether there are any di erences in equivalent and stubborn mutants based on the sizes of the programs studied rq4 does program size or the number of mutants correlate to the number of equivalent and number of stubborn mutants found?
we might expect that the more mutants we generate the more stubborn and equivalent mutants we will nd.
we might also expect that larger programs which tend to have more possible mutants would also tend to have more equivalent and stubborn mutants.920table subject programs ordered by size in lines of code loc .
the bran column shows the number of branches in each program.
name loc bran.
description min 2minimum of two integers bubble sort 6sorting routine profit salesperson s commission mid median of three integers prime num prime number listing triangle widely studied program insert insertion sort day day order for given year calendar calendar for given year carsim driving simulator tcas aircraft collision avoidance defroster car defroster controller schedule priority scheduler hashmap information management replace pattern matching space array language interpreter flex unix lexer utility make unix compilation utility .
manual analysis of stubborn equivalent mutants this section explains how we set up and carried out the procedures required to determine equivalence and stubbornness of mutants so that we can answer the four research questions set out in the previous section.
section .
describes the programs used in the study while section .
describes the mutation operations applied to these programs.
section .
explains in detail the procedure we adopted for determining whether a mutant is equivalent.
finally section .
describes the procedure used to construct branch adequate test suites for each of the programs studied and how this determines whether a mutant is stubborn.
.
subjects eighteen c programs were chosen for the investigation of equivalence and stubbornness.
information about each program including name size number of branches and a simple description of its functionality are presented in table .
this table is sorted by the sizes of the programs measured in lines of code.
the programs min bubble sort profit mid prime num triangle insert and dayare eight trivial programs studied in previous work on equivalent mutants .
their inclusion allows us to investigate whether the size of a program in uences the prevalence of equivalent mutants or their relationship to stubborn mutants.
the three programs tcas schedule andreplace are part of the siemens suite available from sir .
these programs come with existing test suites.
however we did not use these existing suites because they do not yield coverage of feasible branches and we wanted the same test suite construction method for all subjects.
finally we also include six real world programs that vary in size from tiny to relatively more substantial.
calendar is the simple unix utility program and carsim car cruisecontrol simulation component used by mouchawrab et al.
.
though real both are relatively small.
the program defroster is an embedded system that im plements the controller for the rear window defroster of an automobile.
it is closed source production software from daimlerchrysler generated as c code from a state based model.
the program hashmap is an open source program for managing a hash table.
the program space is the widelystudied european space agency program also available from sir .
the programs flex and make are the well known unix utilities.
the size data types and functionality of these programs are wide and varied.
we conduct mutation testing by applying mutants to the whole program at every point at which a mutation operator applies in all but the largest three cases space flex and make .
it is infeasible to consider every possible mutant of these largest three programs.
instead we adopted the following process for determining the parts of the program to be studied starting with the top level procedure m we include all procedures transitively called from each of the procedures called bym terminating when we have accrued at least procedures.
using this selection procedure we identi ed procedures from space loc procedures from flex loc and procedures from make loc .
in order to understand whether or not a mutant is equivalent and to construct test cases we consider the entire program but only these selected procedures are actually mutated.
.
mutation operators studied a program can be mutated by applying a set of mutation operators to it.
king and o utt presented the rst set of proposed mutation operators each of which is represented by a three letter acronym .
however subsequent work on selective mutation by o utt and lee resulted in the identi cation of ve classes of operators abs aor lcr ror and uoi which were deemed to be su cient to achieve almost full mutation coverage .
many subsequent authors have used only operators from these ve classes called the ve selective mutation operators .
therefore we only use these ve operator classes for our experiments too.
a full description of each class of operators and the speci c mutations that they involve can be found in table .
in total we consider speci c mutation operators covering all those found in these ve classes.
to aid replication we state exactly how the operators were applied to the program since these details can vary from one approach to another the mutation operators from the class lcr ror and aor were applied to every expression and predicate.
the abs and uoi class of operators were applied only to the variables that occurred in expressions and predicates.
no mutation operators were applied to lvalue uses of variables so for example the lefthand side of an assignment statement is not mutated but the expression on the righthand side is.
operators are applied recursively to all sub expressions.
.
manual equivalent mutant decision procedure since the determination of whether a mutant is equivalent is undecidable we used a manual decision procedure in order to decide the answer to this question.
our decision procedure implemented by purely manual inspection of code is outlined in figure and de ned in more detail below.921table the five mutant operator classes and the speci c mutation operators they contain mutationdescription speci c mutation operatorsnumber of operator class operators abs absolute value insertion f e abs e e abs e g aor arithmetic operator replacement f x y jx y2f g x6 yg lcr logical connector replacement f x y jx y2f g x6 yg ror relational operator replacement f x y jx y2f !
g x6 yg uoi unary operator insertion f v v v v v v v v g total though our process is entirely manual it is not arbitrary we followed a set procedure for identi cation of equivalent mutants and this allowed us to categorise the reason for equivalence.
it is well known that there are three necessary criteria for a mutant to be killed reachability infection and propagation rip each of which subsumes the preceding condition s .reachability r the mutation must be executed by a test case the mutant is reached .
for non equivalent mutants the reachability criterion can be achieved by any branch adequate test set.
.infection i immediately after the execution of the mutant the state must be infected.
that is the state after the execution of the mutation and the corresponding state in the original program must di er.
a test case that achieves infection is said to weakly kill the mutant .
.propagation p the infected state must propagate to some point in the program at which it can be observed such as an output or return statement.
a test case that achieves propagation is said to strongly kill the mutant .
this rip framework de nes the three necessary conditions for killing a mutant and implicitly it also de nes the conditions for a mutant to be equivalent one or more of the necessary conditions must fail for a mutant to be equivalent.
this gives us three broad categories of equivalent mutant depending on whether they are equivalent because they cannot be reached cannot infect the state or cannot propagate an infection to an output.
a mutant that cannot be reached by any possible test input also by de nition cannot infect and also cannot propagate so we denote this case r i p .
a mutant that can be reached by at least one test input but subsequently fails to infect the state for any reaching input cannot by de nition propagate so we denote this case r i p .
a mutant that can be reached and can infect the state for at least one test input but cannot propagate the infection to an output will be denoted ri p. within these three broad categories of reasons for equivalence we distinguish sub categories which capture in more detail the reason for the failure of the necessary killing condition.
this allows us to report in more detail the distribution of reasons for mutant equivalence.
we adopted the human evaluated decision procedure for mutant equivalence outlined in figure .
each of the seven categories of equivalence is de ned as follows case .
r i p normal the mutated predicate or statement is unreachable.
such a statement of predicate is dead code and so no test case can even executed the mutant.
the number of mutants in this category is thus partly related to the amount of dead code present in the programs under investigation.
previous work indicates that we might expect a small amount of dead code perhaps about .
case .
r i p short circuit we expected that most of the non reaching mutants would fall into the category de ned by case .
.
however there is a special case which applies to predicates only the predicate is reached and evaluated but the mutated part of the predicate is never evaluated due to short circuit evaluation of predicate subexpressions.
that is in c the boolean operators and are evaluated using short circuit evaluation.
this introduces a sequence point such that the righthand side of the boolean expression is not evaluated when the outcome of the overall expression can be determined from the lefthand side evaluation alone.
for example in the expression p q supposepturns out to be false then q and any mutant it might contain will not be evaluated.
therefore should it turn out that all reaching inputs cause pto evaluate to false then any mutation to qwill be equivalent.
case .
r i p context free in this situation the mutated expression is always equivalent to the unmutated expression no matter what the program context in which the expression occurs.
for example if we mutate abs x to abs abs x then this will result in an equivalent mutant regardless of the program context in which it occurs.
it is useful to distinguish this sub case because it is far simpler to detect by manual inspection since it is context free we need not be concerned with the state on each path that reaches the mutant.
case .
r i p context sensitive in this situation the mutant is executed but for each test input that reaches and executes the mutant it so happens that the state is always one in which the mutant and the original yield identical results.
for example if we mutate x 2tox xthis is not equivalent according to case .
above.
however suppose it turns out that all reaching inputs arrive at the mutant in a state in which the value of xhappens to be .
in this execution context the mutant will be equivalent we say that the equivalence is context sensitive .
case .
r i p subpath equivalence there is a special case of r i p that applies only to predicates a mutated predicate is evaluated and yields a di erent result in the mutant and the original.
however all paths from the predicate yield identical states.922case r i pmutant cannot be reached by any test input case .
normal mutated statement or predicate cannot be reached case .
short circuit mutated sub expression never evaluated though its containing predicate is case r i pmutant is reached by at least one test input but no test causes state infection case .
context free infection can never occur in any state case .
context sensitive not context free but infection cannot occur in any reaching state case .
subpath equivalence mutation changes path executed but all paths are equivalent case ri p mutant is reached and infects the state but no infection propagates to an output case .
unobservable no output statement mentions an infected variable case .
observable outputs mention infected variable s but infection fails to reach any figure a summary of the human evaluated decision procedure for mutant equivalence case .
ri p unobservable in this case the mutant is executed and infects the state but there simply is no output statement that mentions any infected part of the state.
in this situation the infection may reach the end of the program execution but remains unobserved and so the mutant is not strongly killed.
case .
ri p observable in this case there is an output statement that yields the result of a variable infected by the mutant.
however all paths to all such statements also contain an assignment statement that squeezes the state so that any di erences in the infected state and the original state are removed before they reach the output statement.
such a squeezing statement could be a killing assignment like x in the sense of killing assignment used in the literature on compilers .
that is a statement that always assigns a constant and so kills the value of the variable to which it assigns.
however an assignment need not be a killing assignment to squeeze out the value of the infected variable.
for example suppose the mutant a ects only the least signi cant bit of the value of the variable x. for this mutant the assignment x x which shifts the contents of xone bit left is one that removes all trace of the infection yet it is not a killing assignment.
.
.
manual analysis the seven classes de ned above were used to categorise equivalent mutants according to the reason for their equivalence.
we devoted person months continuous e ort to the determination of equivalence according to our humanevaluated decision procedure.
that is one of the authors xiangjuan yao was devoted to this task exclusively for months.
in order to retain consistency we did not use any automated tools to determine equivalence other than running the test suite.
all mutants which were not killed by the test suite were checked manually for equivalence.
in total mutants were generated.
of these were unkilled by our branch adequate test suites and were thus manually checked using the decision procedure speci ed above.
of those manually checked were found to be equivalent and stubborn according to the decision procedure.
the manual nature of our analysis renders it subject to human error.
of course where we nd that a mutant is not equivalent we can be sure that we are correct in this assertion because each such non equivalence claim is accompanied by a test case that distinguishes between the mutant and the original program.
however for all cases where we declare a mutant to be equivalent we cannot be completely sure.indeed for these mutants the undecidability of equivalence makes it unlikely that anyone could ever be completely sure no matter how well examined.
we therefore treat our scores for equivalent mutants as upper bounds and make all data available to support wider scrutiny for complete details about the outputs selected the mutants seeded the test cases we constructed and the determination of which test kills which mutants and the mutants we believe to be equivalent the reader is refereed to this website.
we hope that this website will be a useful resource for testing.
other researchers are welcome to use the test suites mutants and other information in their research so long as they acknowledge this paper as the source.
.
.
determining what constitutes an output for our study we regarded an output to be any changes to the console or a le that can be observed as having occurred as the result of execution of any statement that produces such output .
however some of the programs have no such output.
clearly it would be unreasonable to regard all mutants in these programs as equivalent simply because they fail to contain output statements.
therefore we also deem any statement that returns values to the operating system through a return statement to be an output statement .
furthermore for the tiny programs used in some previous studies the programs contained neither an output statement nor any return statement.
this issue is reminiscent of the problem of determining the principal variables in slice based measurement of cohesion and coupling .
more precisely the ten programs min bubble sort pro t mid prime num triangle insert day calendar and tcas all have either output or return statements.
for carsim and defroster we identi ed key state variables and regarded these as output.
for the other six programs schedule hashmap replace space flex and make we compare the output les screen error log etc.
for each task carried out by the system.
.
semi manual generation of branch adequate test suite in order to construct a branch adequate test suite for each program studied we could have used sophisticated automated test data generation techniques .
however though great advances have been achieved in automated test input generation no tools can generate branch adequate test data this is theoretically impossible and practically such tools remain limited .923we therefore constructed test suites using pure random testing to nd those branches that can be easily covered and then augment the test suite with human generated test case design.
we then manually constructed test cases speci cally designed to execute any remaining uncovered branches until all branches were covered.
this means that there is one test case per branch uncovered by random testing.
a smaller test suite could be found with equivalent coverage but we are not presently concerned with e ciency of testing only its e ectiveness.
that is none of the results reported in this paper depend upon the e ciency of the testing process but the determination of stubbornness rests of the e ectiveness of our test suites.
we choose branch coverage as a measure of test e ectiveness because this is a criterion widely studied by many authors .
branch adequacy also corresponds to a well de ned lower bound for mutation killability it ensures that the necessary reachability criterion is met by at least one test case for every possible reachable mutant.
we de ne a mutant to be a stubborn mutant if it is not equivalent but it is not killed by the branch adequate test suite for the program that has been mutated.
.
results answers to research questions this section reports results that provide the answer to each of the research questions.
section draws actionable conclusions from these ndings for mutation based test suite assessment and test data generation.
section considers threats to the validity of our ndings and also potential new threats to validity of previous studies that use fault seeding to assess test technique e ectiveness .
.
rq1 prevalence of equivalent and stubborn mutants table shows the total number of mutants and proportions of equivalent and stubborn mutants per program studied over each of the ve classes of mutation operator.
from this table we see that equivalent mutants which account for of all mutants are more prevalent than stubborn mutants which account for only of all mutants.
we also immediately notice some startling disparities in the numbers of equivalent and stubborn mutants generated by each operator class.
for example while almost half of all abs mutants are equivalent none are stubborn whereas just over a quarter of all lcr mutants are stubborn while very few are equivalent only .
we can see that almost all programs no matter how small do possess equivalent and stubborn mutants.
figure shows the proportionate contribution of the mutants from each program to the total number of all equivalent and all stubborn mutants as a percentage of all mutants drawn from all programs .
we can see that almost a quarter of the equivalent mutants come from the program replace while tcas contributes most stubborn mutants.
however there is no obvious relationship between the contribution of equivalent and stubborn mutants made by each of the programs.
we can see no obvious trend in figure and found no high spearman rank correlations between the two.
minbub.sortprimenumdaymidinsertcalendartriangleflexprofitcarsimschedulehashmapmaketcasspacedefrosterreplac eproportion of mutantsequivalent stubbornfigure the proportionate contribution of the mutants from each program to the total number of all equivalent and all stubborn mutants as a percentage of all mutants .
rq2 relationship of equivalent and stubborn mutants for each operator from figure we can see that there does not appear to be a relationship between overall numbers of mutants and the proportion which are equivalent or stubborn for each program.
however consider figure which shows the proportion of equivalent and stubborn mutants over all mutation operator classes thereby visualising the summary data for each operator class from table .
this gure reveals some interesting ndings it is very clear that the abs operators are problematic for mutation testing they generate a great many equivalent mutants and no stubborn mutants.
by contrast the lcr operators generate stubborn mutants but very few equivalent mutants.
abs aor lcr ror uoiproportion of mutants operator classesequivalent stubborn figure proportion of equivalent and stubborn mutants for each of the ve operator classes the other three classes of mutants generate both equivalent and stubborn mutants so we analyse these in more detail figure shows the contribution of each operator to the overall number of equivalent and stubborn mutants as proportions for each operator.
we can see that post increment decrement operators are problematic they generate a preponderance of the equivalent mutants and fewer stubborn mutants while pre increment decrement operators behave in exactly the opposite manner and may be thus much more practical.
in figure operators are ordered in descending order of their contribution to the number of equivalent mutants overall.
notice that ror operators show some degree of correlation between equivalent and stubborn mutants which is not present in the aor category.
we used a spearman rank correlation test to explore this correlation further.924table total mutants t proportion of equivalent mutant e and stubborn mutants s mutation operator class programabs aor lcr ror uoi totals t es t e s te s t e s t e s t e s age age age age age age min bubble sort profit mid prime num triangle insert day calendar carsim tcas defroster schedule hashmap replace space flex make grand total ordering the operators in the ror class by proportion of equivalent and stubborn mutants exhibits a rank correlation whereas ranking the operators of the aor class in the same way yields no such correlation .
over all mutation operators there is also no correlation between the ranking of operators by their contribution to equivalence and stubbornness .
we conclude that one cannot have stubborn mutants without equivalent mutants in the ror class and that there is a tendency for the ror operators that generate high numbers of stubborn mutants to also generate high numbers of equivalent mutants.
by contrast we nd that some of the aor operators f g are perhaps surprisingly good at generating stubborn mutants but no equivalent mutants while others are unfortunately good at generating equivalent mutants.
that is the four aor operators that replace with one off ggenerate about half of all aor s equivalent mutants.
finally checked the correlation between the numbers of equivalent and stubborn mutants overall and within each operator class.
we speculated that equivalence might be merely an extreme form of stubbornness and we believed other researchers may have made the same implicit assumption.
our results surprised us and challenged this assumption they revealed no evidence for any such correlation.
the strongest correlations were for the operator !
for which and for v v for which neither of which is particularly strong.
it should be noted that for many of the operators there were simply too few mutants to compute a meaningful value while for those with su ciently many data points these two reported above were the only results that indicated even a mild correlation.
we conclude that we can nd little evidence of any noticeable correlation between equivalence and stubbornness.
v v v v v v v v proportion of mutantsequivalent stubborn a uoi operator class proportion of mutantsequivalent stubborn b aor operator class !
!
!
!
!
!
!
!
!
proportion of mutantsequivalent stubborn c ror operator class figure stubbornness and equivalence for the aor ror and uoi classes.
aor and ror operators not listed in this gure generate no stubborn and no equivalent mutants.
.
rq3 causes of equivalent mutants figure shows the proportion of each category of equivalent mutants over all equivalent mutants.
this reveals a number of interesting observations about the causes of equivalence.
we see that there are no equivalent mutants due to unreachable code.
this is not because our programs contain no unreachable statements there were unreachable statements in tcas and defroster for example.
however the unreachable branches contain few statements and those that they do contain attract no mutation operators because their expressions were merely constants.
for example in the defroster program there is an unreachable branch if we1 ba def ev ctr0 signed short error e confirmation e au8.we11 blink out the right hand side of the unreachable assignment to au8.we11 blink out is a constant and so it is not mutated.
similarly case .
context free contains no equivalent mutants revealing another interesting property of the programs under study though they contain redundant unreachable code none of them contains the kind of redundant expression that would lead to a context free equivalent mutant.
the mutation operators studied in this paper are able to generate such equivalent mutants in principle.
for example should the expression x 0occur in the program then it would be equivalently replaced by x .
however no such trivially equivalent code was present in any of the subjects studied.
we found that there are cases where the predicate is infected and causes execution to follow a di erent path yet no state infection occurs case .
of mutant equivalence .
this surprised us it seems that programmers do write programs which when mutated can have disrupted control ow but that this disruption does not a ect the state.
we observed this behaviour in of the programs profit mid carsim and space .
the most common cause of equivalence is case .
which accounts for of all equivalent mutants.
these mutants will be equivalent even under weak mutation testing because they fail to infect the state.
this is an interesting nding because weak mutation testing was introduced as a weaker alternative to strong mutation testing in the hope that it might overcome some of strong mutation s di culties .
mutants that are equivalent due to cases .
.
and .
will also be equivalent under weak mutation.
our results thus suggest that many of the overall population of equivalent mutants will still be equivalent even for weak mutation testing.
mutants that are equivalent because of cases .
and .
can be killed by weak mutation testing but will be equivalent for strong mutation testing.
considering these strongly equivalent mutants it is striking to note how many of them occur due to case .
unobservable .
this means that the mutants have a ected the state but the e ect is not important to the computation.
that is the program never externalises the corrupted part of the state using an output statement even given our broad interpretation of the notion of output .
case .
case .
case .
case .
case .
case .
case .2proportion of mutants figure proportion of all equivalent mutants that result from each of the seven causes of equivalence had the oracle exposed more of the internal state then more of these mutants would be equivalent.
this nding may also have a bearing on the work on fault tolerant computing it suggests that many faults can be tolerated.
that is case .
faults are those that corrupt the state but for which this corruption does not matter .
.
rq4 the effect of size on mutant equivalence and stubbornness we found a strong correlation between the overall number of mutants and the numbers of these that are equivalent .
this was expected because more mutants should surely mean more equivalent mutants .
we also expected a similar correlation for stubborn mutants more mutants should surely also mean more stubborn mutants ?
.
however there was no such correlation indicating that stubbornness appears to be more related to special program circumstances than equivalence.
we also investigated the correlation between the size of the program and the number of equivalent mutants.
for this correlation test we ranked only the programs for which we constructed all possible mutants and for which it is therefore meaningful to consider such a correlation .
once again we found some degree of spearman rank correlation between the size of the program and the number of equivalent mutants but not between the program size and the number of stubborn mutants .
we already found that for the most operators and operators classes there is little connection between equivalence and stubbornness ror being the exception .
we now also conclude that there is also no correlation between size and stubbornness though there is for equivalence further highlighting their di erent character.
these di erences between equivalence and stubbornness are optimistic ndings because they indicate that mutation testing systems might be redesigned to reduce the generation of equivalent mutants as we discuss in the next section.
.
actionable findings our results suggest that mutation testing tools should drop or de emphasise operators that create many equivalent but few stubborn mutants unless there is some other reason to retain these .
for instance inclusion of the abs class of operators would require some careful justi cation since these operators seem to be responsible for large number of equivalent mutants yet very few stubborn mutants.926by contrast the lcr class of mutant operators may be more valuable than previously realised.
our results suggest that its two logical operators tend to create a relatively large number of stubborn mutants yet mercifully few equivalent mutants.
designers of mutation testing tools might want to favour the inclusion of this operator over others provided this does not a ect mutation e ectiveness.
the ror operators generate many stubborn and also many equivalent mutants.
indeed our results indicate that there is some correlation between the two.
as such this operator should be retained for thorough testing since it creates stubborn mutants .
however it might be dropped if the test scenario is particularly sensitive to the pernicious e ects of the equivalent mutant problem.
work on equivalent mutant detection should focus on the ror class of operators since the prevalence of equivalent and stubborn mutants appears to be correlated in this class.
this correlation may make equivalent mutants unavoidable without some form of detection technique.
that is when we seek to retain the e ectiveness that accrues from stubborn mutants we may encounter the associated equivalent mutants which will harm the accuracy of the assessment of test e ectiveness.
our results also indicate that the current widely used categorisation of mutants into the ve classes abs aor ror lcr uoi needs to be re ned.
the sub categories of operator are important in their own right we found noticeable di erences in their behaviours.
for example not all aor operators are equal we found that replacing with any of the other four arithmetic operators tended to generate a disproportionately high number of equivalent mutants with the bene t of comparatively few stubborn mutants .
more work is required to determine whether this is a more generalisable phenomenon in which case some of the aor class of operators might be prioritised over others.
finally in the uoi category there is a clear distinction in the behaviour of the pre increment and decrement operators compared to their post increment and decrement counterparts.
while the post operators tend to create both equivalent and stubborn mutants the pre operators tend to create proportionately more stubborn mutants than the post operators and very few if any equivalent mutants.
this suggest that the tester might want to favour pre operators over post operators.
.
threats to validity the most glaring threat to the validity of the ndings reported in this paper is the inherent undecidability of the equivalent mutant problem and by extension the stubborn mutant problem.
no approach to this problem can be free from threats to validity.
despite these threats we believe it necessary to address the equivalent mutant problem more thoroughly than has been achieved in the literature.
without a better understanding of the properties of mutation operators with regard to equivalence we cannot design reliable mutation testing systems.
our results may also be a ected by our test suite.
further work is required in different test suites since these will a ect the determination of whether a mutant is stubborn.
however as our results indicate previous test e ectiveness studies that used fault seeding may be the subject of previously under appreciated threats to the validity of their ndings.for example previous work on mutation testing in which the abs operator is used may su er disproportionately from threats to the validity of their ndings due to the unusually high prevalence of abs created equivalent mutants.
also suppose there are two studies of testing techniques study a and study b. in study a the programs just so happened to contain proportionately more relational operators and fewer arithmetic operators compared to study b. even if the researchers control for size and use the same set of mutation operators and the same testing tools we can expect from our ndings that study a will report much lower mutation scores than study b. these threats to validity a ect previous work that has attempted to use operators from the ve selective set to assess testing techniques based on fault seeding.
however our own study is also the subject of threats to validity from the equivalent mutant problem.
our claims about equivalence need to be treated cautiously since they are the result of human analysis and not automated and proven correct algorithms.
while humans are error prone no automated solution can be complete due to undecidability.
in order to ameliorate the e ects of this inherent threat we seek to be cautious in our ndings paying attention only to strongly observed e ects.
such stronger e ects are less likely to be a ected by changes in the details regarding the numbers of equivalent mutants.
we also used a statistical analysis of the correlations between stubborn and equivalent mutants since we can hope that such statistical techniques may prove to yield reliable ndings even in the presence of human error noise .
finally we make our programs mutants test suites and all data about equivalence and stubbornness available online to support wider analysis scrutiny and replication.
all test data mutants and programs can be found on the web at the project website.
naturally results also depend on the choice of subject programs as they do with any study.
we partly address this threat by studying a relatively large and varied set of programs.
the programs studied are also of di erent sizes and come from many di erent domains.
however all our programs are c language programs.
further generalisability requires additional replication studies as always with this kind of empirical study.
.
related work there has been much work on techniques to reduce the number of equivalent mutants either by detecting them or preventing their creation.
these approaches have used a variety of techniques including constraint solving slicing compiler optimisation impact analysis and search based software engineering .
of course the undeciability of equivalence means that such approaches must be inherently partial and their true performance remains unknown.
baldwin and sayward proposed an approach that used compiler optimisation techniques to detect equivalent mutants.
their approach uses six types of compiler optimisation rule.
the compiler optimisations were implemented and empirically studied by o utt and craft who reported that of all mutants were equivalent mutants for the subject programs they studied.
however the programs were small and the results only applied to mutants that could be detected by the compiler optimisations used.927o utt and pan introduced a constraint based equivalent mutant detection approach.
they evaluated it on small programs and found that their approach could nd approximately half of the equivalent mutants present.
the results were reported to be superior to those achieved using the previously formulated compiler optimisation approach .
program slicing has also been proposed as a way to detect equivalent mutants .
voas and mcgraw were the rst to suggest that slicing may be helpful while hierons et al.
were the rst to formulate such an approach which they did in terms of both dependence analysis and amorphous program slicing .
their approach was evaluated using only case studies and remains unimplemented.
adamopoulos et al.
proposed a co evolutionary approach to detect possible equivalent mutants but this was only evaluated on simulations and not real mutants.
more recently gr un et al.
proposed to measure the impact of a mutant on execution postulating that the greater the impact the greater the killability.
by extension their work could be thought of a means of approximating the likelihood of equivalence rather than seeking to provide a partial but exact decision procedure as had been attempted in previous work.
schuler and zeller studied the correlation between the impact of various mutations including impacts on coverage return values and invariants.
this approach can also be used as an approximate estimate of the likelihood of mutant equivalence.
few authors have attempted to speci cally and comprehensively determine which mutants are and which are not equivalent for a set of programs studied.
such an approach requires manual analysis and is tedious and time consuming.
we found ten previous papers in which some form of manual analysis is used to con rm results.
a summary of this literature is presented in table .
in table the rst two columns give a reference to the previous work authors and year while the nal two columns list the number of mutants that were manually examined1 and the number reported to be equivalent.
in the studies from before the year the programs were tiny.
this observation is not intended as a criticism of this foundational work available human and computing resources of the time did not permit anything else.
the purpose of these studies was speci cally to examine the prevalence of equivalent mutants and the e ectiveness of techniques for detecting them automatically.
the more recent studies were able to include much larger programs but only a tiny sample of mutants was examined manually.
the purpose of this manual analysis was not to answer questions about equivalent mutants but rather to assess the possible impact that their presence might have on the results reported.
none of the previous studies reports on the relationship between equivalent and stubborn mutants according to any de nition of stubbornness .
it is this examination of relationships between stubborn and equivalent mutants that is the primary novelty of the present paper and from which we draw most of our actionable conclusions.
1the two approximated entries indicated with a symbol in table were provided by a private communication with one of the authors of each of the two papers in question o utt and patrick .table comparison to previous manual studies author s year stu equidied valent acree o utt craft o utt pan gr un schuler zeller schuler zeller patrick oriol clark kintis papadakis malevris just ernst fraser this paper .
conclusions we have presented a detailed manual study of equivalent mutants and their relationship to stubborn mutants.
equivalent mutants are those that are impossible to kill while stubborn mutants are those that are killable but prove hard to kill in practice.
it might therefore be natural to assume that equivalence is merely an extreme case of stubbornness.
however our results contradict this assumption.
we found that though equivalence is correlated with program size and number of mutants created stubbornness is not.
we also found a correlation between the tendency for operators to generate equivalent and stubborn mutants only for the ror operator class for other operators there was no such correlation .
in conclusion though there is clearly some relationship between equivalence and stubbornness the relationship is more subtle than might previously have been assumed.
our ndings also indicated that some mutation operators for example abs and post increment operators should be used with caution or discarded.
they appear to generate many equivalent and few stubborn mutants.
we found that other operator classes such as lcr are more valuable.
they tend to produce proportionately more stubborn yet fewer equivalent mutants.
these ndings also applied to sub classes of operators within the ve categories indicating that tool designers cannot a ord to treat operator class members identically.
we believe that our ndings may bene t the design of mutation testing tools mutants that generate many stubborn but few equivalent mutants can be prioritised for selection and generation based on our ndings.
we also believe that our ndings have implications for the validity of empirical and experimental studies of testing techniques that use fault seeding.
the mutation scores reported in all such studies may have been adversely a ected by the uneven distorting e ects of equivalent mutants.
.