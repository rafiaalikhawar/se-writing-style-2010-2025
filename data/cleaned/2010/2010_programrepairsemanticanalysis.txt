semfix program repair via semantic analysis hoang d. t. nguyen dawei qi abhik roychoudhury school of computing national university of singapore fhoangdtn dawei abhik g comp.nus.edu.sgsatish chandra ibm research satishchandra us.ibm.com abstract debugging consumes significant time and effort in any major software development project.
moreover even after the root cause of a bug is identified fixing the bug is non trivial.
given this situation automated program repair methods are of value.
in this paper we present an automated repair method based on symbolic execution constraint solving and program synthesis.
in our approach the requirement on the repaired code to pass a given set of tests is formulated as a constraint.
such a constraint is then solved by iterating over a layered space of repair expressions layered by the complexity of the repair code.
we compare our method with recently proposed genetic programming based repair on sir programs with seeded bugs as well as fragments of gnu coreutils with real bugs.
on these subjects our approach reports a higher success rate than genetic programming based repair and produces a repair faster.
i. i ntroduction bug fixing continues to be a mostly manual time consuming and therefore expensive activity in software development.
therefore automated techniques to repair buggy programs can be of tremendous value.
in particular given that compute cycles are cheap and abundant it makes sense to investigate techniques that help shift the heavy lifting of program repair from the human to the computer.
while a programmer might not blindly trust a computer generated fix to her code her task can become considerably easier rather than figure out a fix just verify that an automatically generated fix is correct.
not surprisingly researchers have recently started looking into automated program repair tools .
we focus on general purpose programs for which a test suite is available as a way to tell whether the program is working correctly i.e.
it passes all the tests or not i.e.
there exists a failing test but otherwise no formal specification of correct behavior is available this is generally the case in practice by contrast kernels that manipulate data structures often do have specifications and automatic repair on data structure programs have been well studied for example see .
a successful repair would be a modification of the program such that it passes all the tests in the test suite.
one of the most successful techniques in recent work that works on general programs is based on syntactic search.
the premise behind this technique is that once we know where the defective expression is in the program a correct expression may be present syntactically at another place in the program so it is a matter of searching over a space of replacements from among existing expressions.1the technique uses genetic programming technique for searching over this space and has 1this is an oversimplification but broadly speaking this is the idea.been shown to work for large programs .
the limitation of this technique is that the correct expression should be present in the program the technique cannot synthesize an appropriate expression from variables and constants.
an obvious response to the limitation would be a search over a space of syntactic expressions without consideration of whether those expressions appear elsewhere in the program.
such an approach would be more in the flavor of sketching .
however unless the space of repair expression is fixed upfront possibly as a set of templates such a technique will not work.
furthermore as our experiments show enumerating over the set of possible repair templates is inefficient.
in this paper we explore a constraint based semantic approach towards program repair.
the repair constraints are generated by our desire to have the repaired program pass the given test cases.
thus given a program location to be fixed we derive constraints on the expression to appear in the program location in order to have the changed program pass all the given tests.
the repair constraints are generated via controlled symbolic execution and the expression to be repaired is obtained via program synthesis.
we report that for certain kinds of program and bugs the semantics based approach can not only have a higher success rate than a syntactic search based approach but also be able to produce a repair faster.
at the same time we do believe that symbolic execution imposes certain scalability limitations on the size of programs we can handle.
our approach is a combination of three existing techniques.
fault isolation i.e.
where to fix the problem.
the technique uses the ranking produced by a statistical fault isolation tool it shares this step with the search based techniques.
our approach examines one buggy statement at a time from a ranked suspicion report of statements.
statement level specification inference .
we automatically discover the correct specification of the buggy statement.
we use an idea similar to the one used in angelic debugging in converting an expression to a nondeterministic expression.
this step allows us to create for each input to the buggy statement the output that would have resulted in the test passing.
program synthesis .
the third idea is to use componentbased synthesis idea to synthesize an expression that conforms to the specification discovered before.
the inter play of the second and third steps is the primary novelty of our repair tool.
the statement level specification narrows the search space significantly and sets up the problemfor component based synthesis that is based on constraint solving.
we also apply two other important performance optimizations.
first instead of creating a constraint over the entire test suite we create it using a subset of tests adding tests incrementally to the mix.
second among the set of possible expressions that can be synthesized we explore in order of increasing complexity so the tool can find simple fixes quicker.
we have experimentally evaluated our method as well as genetic programming on sir subjects with seeded bugs as well as fragments of gnu coreutils with real bugs.
the use of state of the art smt solvers and program synthesis engines allow our repair timings to be less than that of genetic programming based repair on these subjects.
for the programs with seeded bugs our repair method can repair three times as many buggy versions as compared to genetic programming.
for the coreutils programs with real bugs our repair method took an average of .
minutes while genetic programming took an average of minutes.
ii.
o verview given a buggy program pand a test suite tcontaining at least one failing test case our program repair technique works as follows.
first we employ statistical fault localization to generate a list lof program statements ranked by their suspiciousness of being the bug.
our core program repair method then scans through the statement list from the most suspicious one to the least suspicious one until a successful repair is generated.
for each scanned statement s our core program repair method tries to repair the program by altering statements.
assuming that statement sis the root cause of the failure our core repair method consists of two major steps i we first generate the repair constraint that has to be satisfied by a successful repair on sand ii we try to solve the repair constraint using program synthesis.
1int is upward preferred int inhibit int up sep int down sep int bias if inhibit bias down sep fix bias up sep else bias up sep if bias down sep return else return fig.
.
code excerpt from tcas we illustrate our technique using the sample program in fig.
.
it is a code excerpt taken from tcas traffic collision avoidance system .
suppose inhibit has only two allowable values f0 1g .
the intended behavior of this program is described as follows is upward preferred inhibit up sep down sep .
a test suite for checking the correctness of the program is presented in table i. the testing result shows that the implementation is buggy as two tests are failed.
to repair this program we first employtable i atest suite for the program in fig.
testinputs expected observedstatusinhibit upsep down sep output output pass fail pass fail pass table ii tarantula fault localization result on the program in fig.
line score rank .
.
.
.
tarantula fault localization for the buggy program using the given test suite.
tarantula is a statistical fault localization technique that is explained in details in section iii a. basically it ranks program statements in a descending order of their suspiciousness.
a statement exercised by more failing tests and fewer passing tests will have a higher suspiciousness score.
the result of tarantula shown in table ii is a list of statements ranked by their suspiciousness score.
since line is ranked at the top we start investigating whether the program can be repaired by changing line .
suppose we want to replace line with bias f wheref is to be figured out by our method.
there are four accessible variables at line inhibit up sep down sep andbias .
since variable bias is not initialized we assume that it cannot be used by f .
let us now assume the signature of function fto be int f int inhibit int up sep int down sep we then find the constraint that has to be satisfied by f to pass all the test cases in the test suite.
this is achieved through symbolic execution.
for each test exercising line we generate one constraint onf whose satisfaction guarantees that the fixed program produces the expected output.
we use the second test in table i to explain how such a constraint is generated.
fig.
presents the symbolic execution tree for test with input vectorh1 110i.
note that our symbolic execution does not start with program input.
instead the program is executed concretely with input h1 110iuntil it reaches line .
then the value of variable bias is replaced with a symbolic value xand the execution continues symbolically.
on executing the branch at line the execution is faced with two choices and both paths are executed as shown in the symbolic execution tree.
as we know the expected return value for inputh1 110ishould be only the path through line should be followed to make the program pass.
to follow this path the path condition x should be satisfied.
given that the program state at line is finhibit up sep down sep g we know that fhas to satisfy f .
similarly we getinhibit up sep 11down sep 110bias xpc true inhibit 1up sep 11down sep 110bias xpc x 110return inhibit 1up sep 11down sep 110bias xpc x return fail pass4 10fig.
.
symbolic execution tree for test case in table i when trying to fix line of the program in fig.
.
each box denotes a program state at the line annotated in the superscript.
the program state includes all values of program variables as well as the path condition pc.
f from test and f 60from test .
therefore the constraint that fneeds to satisfy is f f f .
we employ program synthesis to solve the constraint for fin order to get a concrete function.
program synthesis requires basic components e.g.
constants as ingredients to construct the function f. in our technique these components are incrementally provided to program synthesis.
in the first trial only a constant is allowed.
however no constant function can satisfy the above constraint.
we then allow function fto use one i.e.fcan take either the form of var1 cor var1 var2 wherevar1andvar2are infinhibit up sep down sepgandcis an integer constant.
the synthesis procedure can find a solution f inhibit up sep downsep upsep which is a successful repair to the program in fig.
.
note that if is used instead of we will get f inhibit up sep downsep upsep as repair.
iii.
b ackground a. statistical fault localization statistical fault localization aims to localize the root cause of a program failure by exploiting the correlation between execution of the faulty statements and program failure.
a suspiciousness score is computed for each program statement based on its frequency of occurrence in passing and failing executions.
based on the suspiciousness score a ranked list of statements is given to users.
users can then examine the ranked list from the most suspicious statement to the least suspicious statement until the failure root cause is found.
in this paper we adopt the suspiciousness score from tarantula technique .
for a statement s its suspiciousness scoresusp s is computed as susp s failed s totalfailed passed s totalpassed failed s totalfailed wherefailed s denotes the number of failing executions in whichsoccurs andpassed s denotes the number of passingexecutions in which soccurs.
the variable totalfailed denotes the total number of failing executions and totalpassed denotes the total number of passing executions.
b. component based program synthesis we briefly introduce the recent advance in component based program synthesis .
given a set of input output pairs component based program synthesis generates a program that satisfies all the given input output pairs.
more specifically if h iis one of the input output pairs then the synthesized program must produce output when its input is .
in component based program synthesis we provide a set of basic components that the to be synthesized function fis allowed to use.
for example to synthesize a program with linear expressions fconstant minus plus gare given as the basic components.
a set of location variables are defined for each component and the synthesis process is reduced to finding values for these location variables.
the constraint over the location variables is in first order logic and solved by an smt solver.
if it has a solution a unique program can be constructed based on the values of location variables.
we now explain the encoding method.
suppose we provide ncomponentsff1 fngto synthesize function f. without losing generality we assume each component only has one output.
for the ithcomponent we denote its input as !
iand its output as ri.
we useqto denote the set of all input variables from all components and rto denote the set of output variables from all components.
q n i !
ir n i 1frig we use !
to denote the input variables for function fand userto denote the output variable of f. the set of location variables is defined as l flxjx2q r !
frgg a location variable lxdenotes where variable xis defined.
given a valuation of l a program can be constructed using the following procedure lval2prog l .
here theithline of the constructed program is rj fj r r whenlrj iand k l k j lr k where is the number of inputs for component fjand k jdenotes the kthinput parameter of componentfj.
the program output is produced in line lr.
we use one example below to explain the meaning of location variable.
suppose we only provide one component whose inputs are .
since there is only one component we use instead of its component number as the subscript for clarity.
the output variable for isr .
suppose there is only one input for the synthesized program.
let the value of location variables be flr l l lr l 0g.
given that lr r is defined in line and thus component is placed in line .
if the location variables l l then both and are the same as the variable defined in line which means that they are the same as the output of line .
since lrequals the value defined at line r is the output of the program.
from the valuation of the location variables we can construct the following program0 r input0 r r r return r where input0denotes the first input parameter of the synthesized program.
the location variables have to satisfy certain constraints so that the corresponding program can pass on all given inputoutput pairs.
we first give the well formedness constraint wfp.
letm j !
j n wherenis the number of components provided to the program synthesis procedure.
wfp l q r def x2q lx m x2r j !
j lx m cons l r acyc l q r cons l r def x y2r x6 y lx6 ly acyc l q r def n i x2 !
i y rilx ly the constraint cons dictates that there is only one component in each line and acyc encodes that inputs of each component are defined before they are used.
the constraint wfponly guarantees that lcorresponds to a well formed program f. we use the following constraint to guarantee that the solution fsatisfies all the given input output pairs.
func l def conn l !
r q r lib q r !
r lib q r def n i i !
i ri conn l !
r q r def x y2q r !
frg lx ly x y the semantics of each basic component is encoded into lib with irepresenting the specification of component fiand the relation between location variables and program variables is encoded in conn. collectively func l i i represents that when executing the synthesized function fwith input i the output should be i. def n i func l i i wfp l q r finally given ninput output pairs fh i iij1 i ng the constraint represents that the synthesized function f should satisfy all input output pairs and the function has to be well formed.
given a solution l0to the constraint we can construct a program that satisfies all the i o pairs h i ii using the aforementioned procedure lval2prog .
iv.
d etailed methodology we only generate repairs by altering one statement.
the generated fix is always with respect to a given test suite.
if allthe tests in the given test suite pass after the repair is applied we consider the repair to be successful.
we now elaborate on the different steps of our method.
a. generating repair constraint in this paper we focus on repairs that change the right hand side of assignments or branch predicates.
we do not generate any repair that require changing the left hand side of an assignment statement.
albeit simple we will show how common programming bugs can be fixed by altering only branch predicates or the right hand side of assignments.
the repair generated by our method has one of the following two forms x fbuggy .
.
.
!x f if fbuggy .
.
.
!if f in either case we generate an expression f that is used to replace either the right hand side of an assignment or a branch predicate.
we require the expression f to be side effect free.
that is no program variable is modified when f is evaluated.
in the remainder of this paper we do not distinguish between these two cases unless necessary.
an expression is in essence a function.
for example the expression x y can be treated as the function f x y x y. for ease of presentation we use function instead of expression in the rest of this paper.
definition repair constraint given a program p a test suitet a repair constraint cof a function fbuggy in programpis a constraint over function fsuch that iffj c p passes all tests in t. given a suspicious statement sthat contains a buggy functionfbuggy we now explain how to generate the repair constraintcsuch that if a function fsatisfiesc the program can be repaired by replacing fbuggy withf.
as mentioned the concept of repair is with respect to the given test suite t. the repair constraint cis a conjunction of constraints that are derived from t. suppose the test suite has ntests t ftij1 i ng which essentially are different input vectors for running p. the repair constraint is c vn i 1ci.
for each test ti we show in the rest of this section how to generate a constraint cisuch that if the function fsatisfies ci the program generated by replacing fbuggy withfpasses for testti.
eachciis a second order predicate over the function f. to generateci we use symbolic execution in a novel fashion.
before we elaborate our special symbolic execution let us briefly recap normal symbolic execution .
traditionally symbolic execution executes a program by considering all input variables as symbolic.
the state of each variable during symbolic execution is represented as an expression of the symbolic inputs.
when a branch is executed if both directions of the branch are feasible both paths are executed by the symbolic execution.
for each executed path a path condition is collected.
the path condition of a path is a predicate on the program inputs and any input satisfying the path condition of path follows path .
the output of the symbolic execution is a set of feasible paths and the corresponding path conditionsof these paths.
for each path we can also get the symbolic representation of the program output in terms of the program input variables.
different from traditional symbolic execution our symbolic execution starts with a concrete input ti.
suppose the program statement we try to fix is s. let us assume that sis executed at most once during one execution for the moment.
we execute the program concretely with inputtito statement s without executing statement s .
we denote the program state before executing statement sas i. then we set the result of function f as symbolic and continue symbolic execution from statements.
we use ito denote the symbolic value assigned to the result of function f .
suppose the symbolic execution exploresmpaths.
for each explored path j j m we denote the associated path condition as pcjand the symbolic expression of the output as oj.
we useo ti to denote the expected output of program pwith inputti.
the constraint ciis ci m j pcj oj o ti f i i the first part of ci wm j pcj oj o ti dictates that there is at least one feasible path as guaranteed by the satisfiability of path condition along which the output of program pis the same as the expected output o ti .
the second part ofci f i i builds up the input output relationship of function f. with program state ias input the output of functionf i has to satisfywm j pcj oj o ti .
when statementsis not exercised during executing program pwith inputti ciistrue if the execution passes and false if the execution fails.
we use the same example in section ii to explain the generation of ci.
take the second test from table i for the program in fig.
.
the symbolic execution tree for this test case has been given in fig.
.
we use xto denote the symbolic variable to be consistent with section ii.
the symbolic execution explores two paths i path condition is x 110and output is and ii path condition is x and output is .
given the output of expected output of the test is the first part of ciis then x x which can be simplified to x .
given the program state at the fix location is finhibit up sep down sep g the second part of the ciisf x. therefore the constraint ciis f .
after generating the constraint cifrom each test ti the full constraint to be solved is c n i m j pcj oj o ti f i i the solution of cis a function fwhich can be used to repair the program so that all the test cases in the test suite t pass.
note thatcis a constraint over function f. current offthe shelf smt solvers cannot directly solve such a formula.
we will explain in section iv b how we solve cindirectlythrough program synthesis.
one special case is when function fis a constant function.
in this case we can replace f with a free variable and constraint cbecomes a first order constraint that can be solved by current smt solvers.
repair a statement that is executed multiple times if the repaired statement is executed more than once either inside a loop or inside a function that is called multiple times during the execution of test ti we use k ito represent the value produced by f in thekthtime it is executed.
we use k ito represent the program state before the kthtimefis executed when executing program pwith inputti.
note that the variable values in k icould be symbolic in terms of f i k ig.
suppose statement sis executed wtimes during symbolic execution.
we have ci m j pcj oj o ti w k 1f k i k i c n i 1ci now each symbolic output ojis an expression in terms of i w i. the second part of cibecomes vw k 1f k i k i which means that the input output relationship of function fhas to be satisfied each time fis executed.
during the kth timefis executed with program state k i the output of the functionfis k i. infinite loop in symbolic execution if the termination condition of a loop is an expression over our introduced symbolic variables the symbolic execution may never terminate exploring infinite number of loop iterations.
suppose we have while i x fx buggy expression g. each time the buggy statement is executed we will assign a new symbolic value to variable x. on checking the loop condition i x for the next iteration both directions are feasible since the new symbolic value of xis unbounded.
thus symbolic execution continues to explore more and more loop iterations and never terminates.
to avoid such infinite loop exploration we set a loop boundbfor all loops in symbolic execution.
after a loop is iteratedbtimes the symbolic execution stops exploring the path that leads to the next iteration.
note that this does not break the validity of repair constraint.
if the repair constraint c has a solution f for the sub constraint ci one of the constraint pcj oj o ti is satisfied in ci.
it is guaranteed that when applying the repair f the repaired program with input tiwill follow the path jwhose path condition is pcjand generate the correct output.
on the other hand if the loop bound b is too small we may miss repairs that drive the program to follow paths containing larger number of loop iterations.
b. generating a fix after generating the repair constraint using symbolic execution we elaborate how to solve the repair constraint in this section.
recall that the repair constraint is c n i m j pcj oj o ti w k 1f k i k i to solve the repair constraint c we leverage the recent advance in component based program synthesis .
we have reviewed the core method of component based program synthesis in section iii b. the input output pairs of the to be synthesized program are encoded into constraints on a set of location variables l a valuation of which leads to a program that satisfies the given input output pairs.
more specifically the constraint func l dictates that the synthesized program must produce output when given input .
in our repair constraint we also have input output pair h k i k iithat is generated when fis hit at the kthtime in the execution of program pwith inputti.
however h k i k iiis symbolic in terms of f k ij1 k wg wherewis the number of timesfis executed with input ti.
moreover the variables f k ij1 k wghave to satisfy wm j pcj oj o ti to make the execution pass i.e.
program output is as expected.
therefore the constraint to be satisfied by fduring the execution of input tiis idef !
i w k func l k i k i m j pcj oj o ti where i f k ij1 k wg.
conjoining the constraints from all tests together with the well formedness constraint wfp we get the following constraint a solution to which corresponds to a function f that is a valid repair.
def n i i wfp l it is worth noting that program synthesis is not the only way to solve the repair constraint.
given a set of components an enumeration on all possible compositions of components could also be used.
for example given f gas the components we could enumerate all possible expressions that can be constructed using f gand accessible program variables at the repair location.
through enumeration we try to find a function that satisfies the repair constraint.
as shown by gulwani et.
al.
program synthesis is more efficient than enumeration on all possible compositions of the components.
c. putting it all together our repair algorithm is presented in algorithm .
the algorithm takes as inputs a buggy program p a test suite t and a ranked list of suspicious program statements rc.
when successful our algorithm produces a repair applying which on pmakesppass all tests in the test suite t. our algorithm scans though rciteratively until a successful repair can be generated.
in each iteration it first takes the most suspicious statement that has not been tried out using shift rc .
shift rc returns the first element from list rc and removes that element from the list.
ideally given a repair candidate and the test suite t we can directly apply the technique presented in previous sections to generate a repair.
however we notice that the test suite could be large and thus affect the scalability of our technique.
we present inalgorithm a technique to select a subset of the entire test suite for repair generation.
the selection of tests is driven by testing.
we use the set sto maintain the tests used in generating the repair constraint.
initially set sonly contains the failing tests in t. after a repair is generated we test whether any test that is not in sfails in the repaired program.
if a testt0fails in the repaired program p0 we addt0into set sand re generate the repair with the augmented set s. note that this augmentation process is guaranteed to terminate as the maximum size of sis limited by the test suite t. in the worst case we may need to add all tests in tintos.
nevertheless as evidenced by our experiments usually a small number of test cases is sufficient compared to the test suite size.
algorithm repair algorithm input p the buggy program t a test suite rc a ranked list of potential bug root cause output r a repair for p while rc is not empty and not timeout do rc shift rc a repair candidate s a test suite for repair generation tf extractfailedtests t p while tf6 do s s tf new repair repair p s rc ifnew repair null then break end if p0 applyrepair p new repair tf extractfailedtests t p0 end while ifnew repair not null then return new repair end if end while function repair p s rc c generaterepairconstraint p s rc level the complexity of a repair new repair synthesize c level while new repair null and level max level do level level new repair synthesize c level end while return new repair end function therepair function in algorithm tries to generate a repair with a program p a set of tests sand a repair candidate rc.
it first uses symbolic execution to generate the repair constraint using the method presented in section iv a. it then employs program synthesis to solve the repair constraint.
during program synthesis we need to provide the set of components that can be used by the repair.
in order to reduce the complexity of the generated repair as well as increase the scalability of program synthesis we categorize common components according to their complexity level and feed them incrementally to the program synthesis procedure.
the categorization of basic components is shown in table iii.
the synthesis procedure starts with level which meanstable iii the categorization of basic components level conditional statement assign statement constants constants comparison arithmetic logic comparison ite arithmetic logic ite array access array access arithmetic arithmetic that only constants are allowed in the constructed repair.
if it fails more components are provided gradually based on their complexity level.
when at level level all the components whose level is less than or equal to level are provided to program synthesis.
this process continues until a repair is generated or the max level is reached.
v. i mplementation we introduce s emfix semantic based program fixing tool as an implementation of our technique.
the architecture of our tool is presented in fig.
.
s emfixreceives a buggy program and a test suite as inputs.
as the result it generates a repair for the buggy program.
s emfixis the synergy of fault localization symbolic execution and program synthesis.
we adapted the tarantula technique as mentioned in section iii a to provide a ranked list of statements according to their suspiciousness score.
klee is employed for generating repair constraints.
klee is a static symbolic execution engine which is mainly used for generating high coverage test suites and finding bugs.
by default it uses depth first search to explore all program behaviors w.r.t.
predefined symbolic variables.
in our program repair context the variable that is directly affected by a potential defect is treated as a symbolic variable.
to avoid changing and recompiling program s source code whenever a new potential defect is selected symbolic variables are instrumented at runtime.
at the program location where a new symbolic variable is introduced the values of all accessible variables are also gathered.
to generate the repair constraint for each explored path we collect the path condition as well as the symbolic output.
the program synthesis module is implemented in perl and z3 smt solver is used to solve a repair constraint.
after a fix is constructed it is simplified and transformed to make it more readable.
for instance c is transformed into c a cis in char type anda ais transformed into a. we use the following optimization to avoid program synthesis whenever we can.
suppose we try to generate a repair by modifying statement s. recall that our repair constraint c is a conjunction of each basic constraint ci where ci m j pcj oj o ti w k 1f k i k i letc0 ibe wm j pcj oj o ti which is a first order constraint over the symbolic variables f k ij1 k wg where wis the number of symbolic variables.
we check whether eachc0 iis satisfiable using z3.
if any c0 iis not satisfiable clearlyciis unsatisfiable and hence the repair constraint c repair buggy program test suite tarantula klee statement ranking repair constraint program synthesis fig.
.
architecture of s emfixtool.
table iv subject programs from sir repository .
subject prog.
size loc versions description tcas air traffic control program schedule process scheduler schedule2 process scheduler replace text processor grep text search engine total is unsatisfiable.
in that case we quickly conclude that the statement is not fixable and avoid program synthesis.
vi.
e mpirical evaluation to assess the efficiency and effectiveness of our technique we employed s emfixtool to repair seeded defects as well as real defects in an open source software.
we also compared our method with genetic programming based repair techniques.
all the experiments were conducted on a core quad .83ghz cpu 3gb memory computer with ubuntu .
os.
a. experience with sir programs subject programs used in this experiment see table iv are from software artifact infrastructure repository sir .
they represent different kind of applications ranging from a air traffic control system tcas scheduling utilities schedule schedule2 to strings and files manipulation programs replace grep .
each subject program comes with a test suite and has multiple buggy versions as shown in versions column.
each buggy version has one or many seeded defects that represent common programming errors.
program versions that pass all tests are excluded as there is no witness of failure.
each sir program has thousands of tests.
normally a program of similar size to sir programs does not have this enormous number of tests.
hence a given test suite is minimized to a set of tests that achieves a maximum line coverage.
for s emfix the maximum level max level is set to .
this level is chosen to keep search space within a reasonable size.
higher levels are only allowed when buggy locations are provided by users.
in trying to fix each buggy program we set the time bound for s emfixto minutes.
all subject programs but tcas use only local variables to construct a repair.
global variables are used to construct a repair in tcas because they appear in most of tcas computations.
the result of s emfix on sir programs are presented in table v. the time taken for semfixis shown in fig.
.
the numbers under gp genprog are explained later in section vi c. we have experimented with different test suite sizes.
the success rate decreases with more number of tests.
intuitively it is more difficult to generate a repair to pass more tests.
it alsotable v comparing the success rate between semfix sf and genprog gp .
x in on the top of each column denotes the number of tests .
program sf gp sf gp sf gp sf gp sf gp tcas schedule schedule2 replace grep total semfix genprog tcas schedule schedule2 replace grep time s test cases fig.
.
comparing the running time between s emfixand genprog.
shows that the repairs generated with small number of tests may not be valid for some other tests that are not in the test suite.
we note that this weakness is inherent in any test suite based program repair since no formal program specification is given and repairs can only be generated with respect to limited number of given tests.
out of the buggy programs with a test suite size of s emfixrepaired buggy programs while genetic programming repaired only .
the average time required by s emfixfor each repair is less than seconds.
repairs generated by semfix semfixwas able to correct various types of bugs.
table vi shows the number of successful cases for each type of bug.
the number of total bugs of a particular type is specified in the second row of table vi.
const refers to bugs that use the wrong constant.
arith refers to using wrong arithmetic expression and comp refers to using the wrong comparison operators.
logic refers to using wrong logic operators.
programs with code missing bugs lack some statements and programs with redundant code contain some statements that are not supposed to exist.
repairs that semfixcould not generate we have manually looked into the cases where s emfixfailed to repair the buggy programs.
out of the buggy program versions semfixfailed in of them.
the reasons include i the repairs require a larger loop bound than the bound used in our experiment versions ii the repairs require precise modeling of array which is not fully supported by our current implementation versions iii the repairs require symbolic execution with floating point variables which is not supported by klee versions iv the repairs versions require more than one line fix of them are from code missingtable vi semfix sf vs. genprog gp in repairing different class of bugs with 50tests .
bug type const arith comp logiccode redundantallmissing code total semfix genprog table vii coreutils subject programs subject prog.
failure description loc mknod segmentation fault.
mkdir segmentation fault.
mkfifo segmentation fault.
cp failed to copy a file a named pipe .
bugs.
v other reasons that we failed to identify versions .
b. experience with coreutils in this section we present our experience in repairing gnu core utilities coreutils.
in total we were able to locate buggy programs among the ones reported in earlier research .
tests available in coreutils .
are utilized to encode the desired functionality of each utility.
s emfixwas able to repair out of these buggy programs.
table vii shows the bugs that s emfixwas able to repair.
three utilities mkdir mknod and mkfifo have similar defects.
in each utility a null pointer access caused by wrong variable usage makes the program crash.
s emfixfound one variable as a replacement that let the program produce expected output.
for cp the condition guarding a file deleting operation is wrong.
because of the bug the file deleting operation was not executed when it should be in the failing test.
the status of the file is checked later.
s emfixsuggested the function checking the file status to return true indicating that the file is already deleted.
for the remaining buggy programs s emfixcould not find any statement transformation to repair the buggy programs.
c. comparison with genprog on sir and coreutils genprog is a genetic programming based repair tool.
it uses mutation i.e.
delete insert replace and crossover operators to search for a program variant that passes all tests.
by applying these stochastic search operators genprog has been successful in repairing a variety of applications.
we compare the success rate table v and running time of genprog and s emfix.
the test suites used for running genprog are the same as the ones used in section vi a. we take the implementation of genprog from the configuration used to run genprog is taken from i.e.
popsize and a maximum of generations .
the time bound for each repair trial of genprog is set the same as that of s emfix which is minutes.
as shown in table v s emfixoutperforms genprog in all subject programs but schedule2.
most of the bugs in schedule2 are code missing bugs.
our tool could not find any statement transformation to repair these bugs.
with regard to running times s emfixis strictly faster than genprog seefigure .
since genprog suffers from the burden of compiling and testing program variants it takes longer for genprog to find a repair when the size of test suite increases.
we also compare the results of s emfixand genprog on different classes of bugs table vi .
s emfixhas a higher success rate than genprog for each type of bugs.
for code missing bugs neither s emfixnor genprog has a high success rate.
we also notice that genprog failed for all arithmetic bugs.
this confirms that if the repair expression does not exist in other places of the program genetic programming based approaches have rather low chance of synthesizing the repair.
we also employed genprog to repair the bugs in coreutils.
out of the buggy programs genprog repaired the same number of bugs as s emfix.
regarding the running time genprog took an average of minutes while s emx fixtook an average of only .
minutes.
d. comparison with expression enumeration our approach employs program synthesis to solve the repair constraint in order to find a successful repair.
program synthesis essentially searches among the set of possible expressions that can be constructed using the provided basic components and program variables.
we conducted the following experiments to examine whether program synthesis is more favorable than explicit enumerating possible expressions.
the enumeration based program repair that we compare with proceeds as follows i it uses statistical debugging to generate a ranked list of repair candidates.
ii it scans through the result of statistical debugging.
for each scanned repair candidate it enumerates all possible expressions that can be constructed based on a given set of components and program variables.
thus given variables fx y zgand operator it tries outfx y x z y z x x y y z zgto see if any of them is a successful repair.
the enumeration terminates until a successful repair is generated which is confirmed by running all tests on the repaired program.
we use the same set of components and variables as in our program synthesis step.
following the layers in table iii we enumerate from simple expressions to more complex expressions.
we have also tried to avoid redundant enumeration.
only one of x yandy x is tried out and expressions like x xare not tried out at all.
one of the problem with enumeration is the handling of constants in expressions.
enumeration based method is unlikely to figure out the desired value of constant unless it falls within the commonly used ones e.g.
f 1g.
therefore we use symbolic execution to figure out the value of constant when an enumerated expression contains unknown constant variables.
suppose we want to see whether any expression of the form x con could be a valid repair where x is a program variable andcon is some unknown constant.
we first replace the repair candidate with x con and then mark con as symbolic and use the method in section iv a to generate a constraint over the symbolic value of con solving which gives us a concrete value of con.
we use the same set of sir programs as in table iv in this comparison.
for each buggy program version thetable viii average ratio of running time over all versions of a subject program time taken by enumeration based repair vs .time taken by semfix .
subject tcas schedule schedule2 replace grep all ratio .
.
.
.
.
.
same set of tests are used as in section vi a. the enumeration based program repair was successful for out of program versions and all these versions are contained in the versions that s emfixwas able to repair.
for each of the cases that s emfixsucceeded but enumeration method failed enumeration had to examine more than expressions and timed out after minutes.
in contrast synthesis based repair took only seconds on average for these cases to produce a repair.
as an example in one version of tcas s emfixgenerated tmp other capability alt layer value ?
two of three reports valid cur vertical sep as a replacement for tmp up separation .
this is a non trivial fix generated which the program synthesis allows semfix to generate and this could not be generated by the enumeration method even when it was augmented with symbolic execution to solve for constants.
table viii compares the running time of s emfixand enumeration based repair.
on average the time taken for the enumeration method is .
times of the time taken by semfix.
vii.
t hreats to validity a generalization of the fix the repair generated by semfixmay not be generalized to test cases that are not in the given test suite.
this is inherently due to the fact that our repair is guided by a given test suite not a formal specification.
to minimize the effort required from users we choose to extract intended program semantics from a given test suite via symbolic execution.
b other statistical debugging metrics the choice of statistical debugging metrics could potentially affect the effectiveness of our technique.
on this front we have also tested semfixwith another popular statistical debugging metric ochiai .
we found that using ochiai instead of tarantula has negligible impact on our experiment results.
for example using ochiai instead of tarantula s emfixwas able to fix two more versions of tcas but one less version of schedule.
viii.
r elated work recently there has been a growing interest in automated program repair.
we have compared our technique with genetic programming .
several program repair approaches assume the existence of program specification.
autofix e and autofix e2 are based on the program contracts in eiffel programs.
fixes are generated following predefined schema so that the fixed programs satisfy the corresponding program contracts.
jobstmann et.
al.
uses ltl specifications for finite state programs.
the process of finding a repair is reduced to a game a winning strategy of which correspondsto a successful repair.
gopinath et.
al.
use behavioral specifications and encode the specification constraint on the buggy program into sat constraint a solution of which leads to a repair.
fixes are only generated by replacing variables used in assignments.
robert and roderick employ template based repair for linear expressions.
template parameters are figured out through symbolic execution.
in contrast to symbolic execution in our approach their symbolic execution considers all program inputs and template parameters as symbolic.
he and gupta compute weakest pre condition along an execution trace to infer the desired program state.
a repair is generated based on the difference between the actual program state during the failing execution and the desired program state.
dallmeier et.
al.
try to generate fixes from object behavior anomalies.
normal program properties are mined from successful executions and fixes are generated so that previous failing executions can also satisfy the mined properties.
clearview follows a similar scheme but works on deployed binary program when high availability is required.
learning from history repair data bugfix suggests bugfix that has been used in a similar debugging situation.
the debugging situation captures both static and dynamic information to increase accuracy.
debroy and wong propose to use mutation for program repair.
a number of mutated program versions are generated and tested in a trial and error fashion.
phprepair focuses on html generation errors in php programs.
constraints on string literals are collected from test executions and solved through string solver.
the derived string literals from string constraint solving are then used to repair the php programs.
instead of fixing a buggy program program sketching allows a programmer to write a sketch of the implementation idea while leaving the low level details omitted as holes to be automatically filled up by the sketch compiler.
the programmer is also required to provide the program specification in the form of a reference program.
in contrast semfixrequires neither the sketch nor the program specification.
instead s emfixtries to synthesize a glimpse of the intended program specification through symbolic execution of the given test suite.
our usage of symbolic execution is similar to that of angelic debugging .
for each expression in a buggy program angelic debugging uses symbolic execution to check whether it is possible to modify the expression to fix the failing tests without breaking any passing tests.
ix.
conclusion we propose s emfixas a semantics based program repair tool.
s emfixderives repair constraint from a set of tests and solves the repair constraint to generate a valid repair.
s emfix is able to synthesize a repair even if the repair code does not exist anywhere in the program.
our experimental resultsdemonstrate that s emfixis able to fix various types of bugs and outperforms search based program repair technique.