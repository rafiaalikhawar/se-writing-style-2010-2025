vejovis suggesting fixes for javascript faults frolin s. ocariza jr. karthik pattabiraman ali mesbah electrical and computer engineering university of british columbia vancouver bc canada frolino karthikp amesbah ece.ubc.ca abstract javascript is used in web applications for achieving rich user interfaces and implementing core functionality.
unfortunately javascript code is known to be prone to faults.
in an earlier study we found that over of such faults are caused by the interaction of javascript code with the dom at runtime dom related faults .
in this paper we first perform an analysis of bug reports to understand fixes commonly applied by programmers to these domrelated faults we observe that parameter replacements and dom element validations are common fix categories.
based on these findings we propose an automated technique and tool called v ejovis for suggesting repairs for dom based javascript faults.
to evaluate v ejovis we conduct a case study in which we subject vejovis to real world bugs across applications.
we find that v ejovis accurately suggests repairs for out of the bugs and in of the cases the correct fix was the top ranked one.
categories and subject descriptors d. .
testing and debugging testing tools general terms design algorithms experimentation keywords javascript fault repair document object model dom .
introduction javascript is used extensively in modern web applications to manipulate the contents of the webpage displayed on the browser and to retrieve information from the server by using http requests.
to alter the contents of the webpage javascript code manipulates a data structure known as the document object model dom .
the dom contains all the webpage elements e.g.
div table etc.
hierarchically ordered as a tree where each element contains specific properties such as styling information.
through the use of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.dom api methods the javascript code is capable of retrieving elements from the dom as well as changing the dom by modifying element properties adding elements and deleting elements.
due to the dynamic nature of the javascript language and the interaction with the dom javascript based web applications are prone to errors.
in a recent empirical study we conducted on javascript bug reports we found that around of javascript faults are dom related meaning the error leading to the fault eventually propagates into a parameter value of a dom api method call or to the assignment value of a dom element property assignment before causing the failure.
in addition we found that of the highest impact javascript faults i.e.
those that cause data loss hangs and or security vulnerabilities are dom related.
finally we found that dom related faults require more time to fix than other javascript faults.
these results point to the prevalence impact and complexity of dom related javascript faults in web applications.
in this paper our goal is to facilitate the process of fixing domrelated javascript faults by providing suggestions to the programmer during web application testing and debugging tasks.
to this end we first perform a study of real world javascript faults to understand the common patterns in how programmers fix such faults.
then based on these common fix patterns we propose an automatic approach for suggesting repairs.
in this paper we use the term repair to encompass both fixes and workarounds for the fault similar to other related work .
our approach starts from the wrong dom api method property and uses a combination of static and dynamic analysis to identify the lines of code in the backward slice of the parameters or assignment values of dom methods properties.
once these lines are localized it uses a string solver to find candidate replacement dom elements and propagates the candidate values along the backward slice to find the fix.
we implement our approach in an open source tool called v ejovis .1vejovis is deployed on a web application after the occurrence and subsequent localization of a javascript fault .
it requires neither specifications annotations from the programmer nor any changes to the javascript dom interaction model and can hence be deployed on unmodified web applications.
prior work on suggesting repairs for web application faults has focused on server side code e.g.
php including workarounds for web api calls .
other work automatically transforms unsafe eval calls in javascript code to safe alternatives.
none of these techniques however deal with dom related javascript faults.
to the best of our knowledge vejovis is the first technique to automatically suggest repairs for dom related javascript faults in web applications .
1vejovis is the roman god of healing.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
we make the following contributions in this paper we categorize common fixes applied by web developers to dom related javascript faults based on an analysis of online bug reports.
we find that fixes involving modifications of dom method property parameters or assignment values into valid replacement values i.e.
values consistent with the dom are the most common followed by those involving validation of dom elements before their use based on the above study we present an algorithm for findingvalid replacement parameters passed to dom api methods which can potentially be used to replace the original and possibly erroneous parameter used to retrieve elements from the dom.
the replacements are found based on the css selector grammar and using information on the dom state at the time the javascript code executed.
the aim is to suggest replacements that are valid in the current dom and to suggest as few replacements as possible we present an algorithm for suggesting repairs in the form ofactionable messages to the programmer based on codecontext.
the actionable messages contain detailed directions prompting the programmer to make modifications to the code so as to eliminate the symptoms observed during the program s failure run we describe the implementation called v ejovis which integrates the previous two contributions.
we evaluate our technique on real world javascript bugs from web applications.
in our case study v ejovis was able to provide correct repair suggestions for of the bugs.
further the correct fix was ranked first in the list of repairs for of the bugs.
we also found that limiting the suggestions to those that are within an edit distance of relative to the original selector can decrease the number of suggestions in the other bugs to per bug while reducing the number of correct fixes to from .
.
background and challenges the dom is a standard object model used internally by web browsers to represent the html state of a webpage at runtime.
changes made to the structure contents or styles of the dom elements are directly manifested in the browser s display.
client side javascript2is used primarily to interact with i.e.
to access traverse or manipulate the dom.
in most modern web applications these interactions are used to incrementally update the browser display with client side state changes without initiating a page load.
note that this is different from what happens during url based page transitions where the entire dom is repopulated with a new html page from the server.
javascript provides dom api methods and properties that allow direct and easy retrieval of dom elements.
for instance elements can be accessed based on their tag name id and class names and the dom can be traversed using the parentnode andchildnodes properties.
in addition modern browsers provide apis such as queryselector for retrieving dom elements using patterns called css selectors .
css selectors follow a well defined grammar and serve as a unified way of retrieving dom elements for example retrieving a div dom element with id news translates to div news in css selector syntax.
table shows some of the commonly used components that make up a css selector.
once an element is retrieved using the css selector javascript code can use the reference to that element to access its properties 2for simplicity we refer to client side javascript as javascript.table list of commonly used css selector components.
component description tag name the name of the tag associated with an element.
examples div span table etc.
id the id associated with an element.
this is prefixed with the symbol.
example if a divelement has an id of myid a css selector that can retrieve this element is div myid .
class name the name of a class to which an element belongs.
this is prefixed with a period.
example if a span element belongs to the myclass class a css selector that can retrieve this element is span.myclass .
is descendant a space character indicating that the element described by the right selector is a descendant of the element described by the left selector.
example to find all table elements belonging to class myclass that are descendants of a divelement we use the selector div table.myclass .
is child the character which indicates that the element described by the right selector is a child of the element described by the left selector.
example to find all trelements that are children of the table element with id myid we use the selector table myid tr .
is next sibling the character which indicates that the element described by the right selector is the next sibling of the element described by the left selector.
example to find all trelements that follow another trelement we use the selector tr tr .
1function pagersetup 2var display catalog view 3var content p.pages span appendto display content 7function appendto display content 8var view selector div view display id display 9var content selector view selector content var pagetoadd div new content div var pages content selector var oldcontent pages .
innerhtml pages .
innerhtml oldcontent pagetoadd figure javascript code of the running example.
add new or remove modify existing properties or add remove elements to from the dom tree.
running example.
here we describe the running example that we will be using throughout this paper to simplify the description of our design.
the running example is based on a bug in drupal involving jquery s autopager extension which automatically appends new page content to a programmer specified dom element a snippet of the simplified javascript code is shown in figure .
in thepagersetup function the programmer has set the display id suffix to catalog view line and the dom element where the page is added as p.pages span line .
these inputs are passed to the appendto function which sets up the full css selector describing where to add the new page through a series of string concatenations lines .
in this case the full css selector ends up being div view display id catalog view p.pages span .
the above javascript code runs when the dom state is as shown in figure .
note that in this case the css selector will notmatch any element in the dom state.
as a result returns an empty set in line hence when retrieving the old content of the first matching element via innerhtml line an undefined exception is thrown.
the undefined exception prevents the autopager to successfully append the contents of the new page line to the specified element in line .
for this particular bug the fix applied by the programmer was to change the string literal div view display id to div view id in line .
this in turn changes the full css selector to div view 838bodydivid view id catalog view pclass pages h1divid view display id catalog page pclass pages divclass container spanh1divclass container spanfigure the dom state during execution of the javascript code in the running example.
for simplicity only the elements under body are shown.
id catalog view p.pages span which is valid in the dom in figure .
challenges.
the interaction between two separate languages i.e.
the dom and the javascript code makes web applications highly error prone.
javascript errors are prominent and can lead to the impairment of major functionalities of a webpage even in the case of popular and well engineered production web applications .
in a recent empirical study of over javascript bug reports we found that approximately of javascript faults are domrelated .
this means that the majority of javascript faults originate from errors that eventually propagate into the parameter or assignment value of a dom method property.
the running example provides an example of a dom related fault as the error present in the example eventually propagates into the dom method which retrieves dom elements through css selectors.
dom related faults by definition involve the propagation of the error to a dom method property s parameter or assignment value.
therefore the fix likely involves altering the code responsible for setting up this parameter or assignment value.
the challenge of course is in answering the following question how should the code be modified to repair the fault?
answering this question requires knowledge of the location in the code that needs to be altered and the specific modification that needs to be applied to that location.
for the first task the origins i.e.
the backward slice of the parameter or assignment value must be traced.
for the second task the specific replacement parameter or replacement assignment value must be inferred and the way in which this replacement should be incorporated into the code must be determined.
while these challenges are difficult and sometimes impossible to tackle with arbitrary method parameters or assignment values because they require programmer intent to be inferred parameters and assignment values to dom methods properties as well as the dom itself are more structured.
hence for these kinds of parameters or assignment values the problem of inferring programmer intent reduces to finding replacements that satisfy this structure.
therefore we study common patterns in how programmers fix dom related faults to prioritize the fix suggestions we infer.
this study is presented in the next section.
.
common developer fixes to better understand how programmers implement fixes to domrelated javascript faults we analyze fixed bug reports repre table list of applications used in our study of common fixes.
application description moodle learning management system joomla content management system wordpress blogging drupal content management system roundcube webmail wikimedia wiki software typo3 content management system taskfreak task organizer jquery javascript library prototype.js javascript library mootools javascript library ember.js javascript library senting dom related faults and analyze the developer fixes applied to them.
our goal is to answer the following research questions rq1 fix categories what are the common fix types applied by programmers to fix dom related javascript faults?
rq2 application of fixes what modifications do programmers make to javascript code to implement a fix and eliminate dom related faults?
the above questions will help us determine how programmers typically deal with dom related faults.
this understanding will guide us to design our automated repair algorithm.
.
methodology we perform our analysis on fixed javascript bug reports from eight web applications and four javascript libraries see table .
note that these bug reports are a subset of the bug reports we explored in a recent empirical study .
however the analysis conducted here is new and is not part of our previous study.
in our earlier study we analyzed a total of fixed javascript bug reports.
of these about or of the bugs were domrelated javascript faults.
further we found that in of these dom related javascript faults or bugs the fix involved a modification of the client side javascript code.
we consider only these bugs in this study as our goal is to find repairs for domrelated javascript faults that involve the javascript code.
to answer the research questions we perform a qualitative analysis of the fixes applied by the programmers to each bug report.
to do so we manually read the portions of each bug report documenting the fix applied e.g.
developer comments discussions initial report descriptions fix descriptions patches etc.
.
based on this analysis we devise a classification scheme for the bug report fixes so that we can group the fixes into different well defined categories to answer rq1.
our analysis of the code patches and or fix descriptions helps us answer rq2.
.
results fix categories.
we found that the fixes that programmers apply to dom related javascript faults fall into the following categories.
parameter modification where a value that is eventually used in the concatenation of a dom method property parameter or assignment value is modified.
this is done either by directly modifying the value in the code or by adding calls to modifier methods e.g.
adding a call to replace so that the string value of a variable gets modified .
this category makes up .
of the fixes.
dom element validation where a check is added so that the value of a dom element or its property is compared with an expected value before being used.
this category makes up .
of the fixes.839method property modification where a call to a dom api method or property is either added removed or modified in the javascript code.
here modification refers to changing themethod or property originally called not the parameter e.g.
instead of calling getelementsbyclassname the method getelementsbytagname is called instead .
this category makes up .
of the fixes.
major refactoring where significantly large portions of the javascript code are modified and restructured to implement the fix.
this category makes up .
of the fixes.
other uncategorized which make up of the fixes.
as seen in the above fix categories the most prominent categories are parameter modification and dom element validation which make up over half .
of the fixes.
therefore we focus on these categories in our work.
although we do not consider method property modifications in our repair approach our algorithm can be adapted to include this class of errors at the cost of increasing its complexity see section .
application of fixes.
we next describe how programmers modify the javascript code to apply the fixes.
we discuss our findings for the three most prominent fix categories parameter modification dom element validation and method property modification.
parameter modification we found that .
of fixes belonging to the parameter modification fix category involve the modification of string values.
the vast majority around of these string value modifications were direct modifications of string literals in the javascript code.
however we also found cases where the string value modification was applied by adding a call to string modification methods such as replace .
we also analyzed the dom methods properties whose parameters are affected by the modified values.
for string value modifications the methods properties involved in multiple bug report fixes aregetelementbyid andjquery together fixes involving these methods comprise .
of all string value modifications.
for non string value modifications fixes involved modification of the numerical values assigned to elements style properties particularly their alignment and scroll position.
dom element validation .
of fixes belonging to this category are applied by simply wrapping the code using the pertinent dom element within an ifstatement that performs the necessary validation so that the code only executes if the check passes .
other modifications include adding a check before the dom element is used so that the method returns if the check fails adding a check before the dom element is used such that the value of the dom element or its property is updated if the check fails encapsulating the code using the dom element in an if else statement so that a backup value can be used in case the check fails and finally encapsulating the code in a try catch statement.
the most prevalent checks are null undefined checks i.e.
the code has been modified to check if the dom element is null or undefined before it is used which constitutes .
of the fixes in the dom element validation category.
method property modification .
of these fixes involve changing the dom method or property being called assigned the rest involve either the removal of the method call or the property assignment e.g.
remove a setattribute call that changes the class to which an element belongs or the inclusion of such a call or assignment e.g.
add a call to blur to unfocus a particular dom element .
of the fixes where the dom method property was changed around involve changing the event handler to which a function is being assigned e.g.
instead of assigning a particular method to onsubmit it is assigned to onclick instead .
data collector box a direct dom accessweb application urlsymptom analyzer box b treatmentsuggester box c supplementaryinformationsymptomsdatapossible sicknesses list of workaroundsuggestionsfigure high level block diagram of our design.
summary of findings.
our study shows that the most prominent fix categories are parameter modification and dom element validation.
our analysis also shows the prevalence of string value modifications and null undefined checks when applying fixes.
in addition most parameter modifications are for values eventually used in dom methods that retrieve elements from the dom particularly the jquery andgetelementbyid methods.
these results motivate our fault model choice in section as well as our choice of possible sickness classes in section .
.
.
fault model in this work we focus on dom api methods that retrieve an element from the dom using css selectors ids tag names or class names as we found that these were the common sources of mistakes made by programmers section .
these dom api methods include getelementbyid getelementsbytagname getelementsbyclassname queryselector and queryselectorall .
we also support dom api wrapper methods made available by commonly used javascript libraries including those in jquery e.g.
andjquery prototype e.g.
and and tinymce e.g.
get among others.
for simplicity we will refer to all these dom api methods as the direct dom access .
we further focus on code terminating dom related faults which means the dom api method returns null undefined or an empty set of elements eventually leading to a null or an undefined exception thereby terminating javascript execution .
however our design can also be extended to apply to output related dom related faults i.e.
those that lead to incorrect output manifested on the dom.
such faults would require the programmer to manually specify the direct dom access.
in contrast with code terminating domrelated faults the direct dom access can be determined automatically using the a utofloxtool proposed in our prior work .
thus we focus on this category of faults in this work.
the running example introduced in section is an example of a fault that is encompassed by the fault model described above.
here the direct dom access is the call to the method in line which returns an empty set of elements.
it is code terminating because the fault leads to an undefined exception in line .
.
approach in this section we describe our approach for assisting web developers in repairing dom related faults satisfying the fault model described in the previous section.
figure shows a block diagram840of our design which consists of three main components the data collector the symptom analyzer and the treatment suggester .
these components are described in sections .
.
.
our approach assumes the parameter or the array index of the direct dom access is incorrect.
this is inspired by the results presented in section which demonstrated the prevalence of parameter modification fixes.
as such our approach attempts to find valid replacements for the original parameter or array index where a valid replacement is a parameter that matches at least one element in the dom.
once the valid replacements are found our approach analyzes the code context to determine what actionable message to suggest as a potential repair to the programmer.
.
data collector the main purpose of the data collector module is to gather dynamic data that may reveal the symptoms present in the web application.
in general symptoms are defined as any indications of abnormalities in the intended behaviour of the program with regard to dom accesses.
we consider the following as symptoms in our design based on our fault model symptom the direct dom access is returning null undefined or an empty set of elements.
this leads to a null or undefined exception eventually.
symptom the index used to access an element in the list of elements returned by the direct dom access is out of bounds.
this is only applicable to dom methods that retrieve a list of elements e.g.
getelementsbytagname etc.
.
this eventually leads to an undefined exception.
the data collector collects the direct dom access line number and the name of the function containing it.
this data is provided by the user manually or gathered automatically using a tool such as autoflox .
the data collector module also collects the following supplementary information which can help infer the context under which a particular symptom is appearing the dynamic execution trace of the javascript program with each trace item containing the line number of the executed line the name of the function containing the line and the names and values of all in scope variables at that line.
it also includes the lines in the body of a loop and a list of forloop iterator variables if any .
the data describing which lines are part of a loop are used by the treatment suggester to infer code context to determine what actionable repair message to provide to the programmer more details are in section .
.
the state of the dom when the direct dom access line is executed.
for instance in the running example the dom state in figure is retrieved the dom state will be used by the symptom analyzer to determine possible replacements for the direct dom access parameter if any in particular if the direct dom access is returning null orundefined i.e.
symptom this means that the parameter to the direct dom access does not correspond to any element in the current dom state so our technique can look at the current dom state to see if there are any reasonable replacements thatdomatch an element or a set of elements in the dom.
.
analyzing symptoms thesymptom analyzer figure box b uses the data gathered by the data collector to come up with a list of possible sicknesses that the web application may have.
each possible sickness belongs to one of the following classes string a has a string value of x but it should probably have string value y. this sickness triggers symptom .
index an array index has a numerical value of x but it should fall within the allowed range .
this sickness triggers symptom .
null undefined a line of code xaccessing a property method of the dom element returned by the direct dom access should not execute if the dom element is .
this sickness can trigger both symptoms and .
these classes are based on the results of our study of common bug report fixes.
in particular the string and null undefined classes account for parameter modification and dom element validation fixes respectively.
the index class is included because in some cases an undefined exception occurs not because of retrieving the incorrect element but because of using an out of bounds index on the returned array of dom elements.
the symptom analyzer takes different actions depending on the symptom in section .
as follows .string replacement assume that the program suffers from symptom .
this implies that the string parameter being passed to the direct dom access does notmatch any element in the dom i.e.
the program may be suffering from the string sickness class as described above.
our design will look for potential replacements for these parameters where the replacements are determined based on the current dom state.
each potential replacement represents a possible sickness belonging to the string class.
.index replacement assume that the program suffers from symptom .
this implies that the program may be suffering from the index sickness class as described above.
this step is only taken if the direct dom access corresponds to a method that returns a setof dom elements.
our approach will determine the allowed range of indices representing a possible sickness belonging to the index class.
.null undefined checks by default our design additionally assumes a possible sickness belonging to the null undefined class.
each of the above cases will be described in detail.
because css selectors provide a unified way of retrieving elements from the dom we will only describe how the possible sicknesses are determined for the case where the parameter to the direct dom access is a css selector as in the case of the running example .
case string replacement.
the main assumption here is that the string parameter passed to the direct dom access is incorrect we call this parameter the erroneous selector .
hence the goal is to look for potential replacement parameters that match an element or a set of elements in the current dom state i.e.
are valid replacements and suggest only the most viable replacements so as to not overwhelm the programmer therefore our approach assumes that the replacement will be relatively close to the original erroneous selector i.e.
only one component of the original selector is assumed incorrect by any given replacement .
algorithm shows the pseudocode for this step.
the sub steps are described below in more detail.
dividing components the first step is to divide the erroneous selector into its constituent components represented by c line .
in essence cis an ordered set where each element cicorresponds to a selector component ci comp its matching component type ci type see table and its level in the selector where each level is separated by a white space or a character ci level .
the841algorithm parameter replacement input trace the dynamic execution trace input dda the direct dom access input dom the current dom state output listofpossiblesicknesses a list of possible sicknesses 1c c1 c2 ... cn 2gss s1 l1 s2 l2 ... sk lk 3foreach ci2cdo lss i match ci gss 5end 6vs 7foreach ci2cdo pve dom.root forj to c i level do nextelems foreach e2pve do all e.getelementsbytagname foreach f2alldo iffmatches level jof erroneous selector then nextelems .add f end end end pve nextelems end foreach e2pve do newelems iflevel after c i level is the descendant then newelems getalldescendants e end else if level after c i level is the child then newelems getallchildren e end else if level after c i level is the next sibling then newelems getnextsibling e end foreach f2newelems do iffhas c i type then newselector dda.erroneousselector .replace ci comp ci type off vs.add newselector end end end foreach selector2vsdo ife selector dom 2dom then vs.remove selector end end 44end 45pr replacementsfinder vs lss lss ... lss n 46foreach rep2prdo possiblesickness craftpossiblesickness rep listofpossiblesicknesses .add possiblesickness 49end erroneous selector itself is retrieved from the direct dom access dda which is input to the algorithm.
for example consider the erroneous selector in the running example div view display idcatalog view p.pages span .
this selector contains the following components the tag name div the has id identifier the id name view display id catalog view a character indicating that the next component is a child of the previous the tag name p the has class identifier .
i.e.
a dot character the class name pages whitespace indicating that the next component is a descendant of the previous one and the tag name span .
finding the global string set the next step is to determine thestring set corresponding to each component lines .
the string set refers to the list of locations in the javascript code of the origins of all the parts that make up a particular string value.
for instance consider the erroneous selector in the running example whose final string value is div view display id catalog view p.pages span .
this entire string is made up of a concatenation of the following strings div view display id in figure line catalog view in line in line and p.pages span in line .
the algorithm first determines the global string set which refers to the string set of the entire erroneous selector in algorithm this is represented by gss line .
the global string set is found by recursively extracting the dynamic backward slice of each concatenated string value that makes up the erroneous selector using the dynamic execution trace until all the string literals that make up the erroneous selector have been included in the string set.
note that the slice extraction process is a dynamic one and is hence precise.
however it may be unable to resolve the origin of every variable in the code e.g.
because a variable gets its value from an external xml file.
unresolved portions of the erroneous selector are left as gaps in the string set.
thegss consists of an ordered set of tuples of the form si li where siis a string value and liis the location in the javascript code where that value originated i.e.
line number and enclosing function .
each tuple represents an element in the string set.
in the running example given the string set of the erroneous selector just described above the ordered set of tuples will be as follows div view display id catalog view p.pages span .3note that a gap in the string set is likewise represented as a tuple the string value siis retained but the location liis left undefined and a special variable is used to store the earliest expression from which the unresolved string value originated.
finding the local string sets once the global string set is found the local string set of each component represented by lss i is inferred lines .
in essence this procedure matches each erroneous selector component ciwith the corresponding elements in the global string set line .
for example consider the id name component view display id catalog view in the running example.
if startindex andendindex refer to the index range of the characters from the global string set element that belong to the local string set then the string set of this component is div view display id startindex endindex catalog view startindex endindex .
finding valid selectors lines of algorithm looks for valid selectors vs in the current dom state.
this portion of the algorithm iterates through each component ciof the erroneous selector and assumes that ciis incorrect it then traverses the current dom state s tree to see if it can find new css selectors i.e.
those in which the component assumed to be erroneous is replaced by a different value that match an element in the current dom state.
this procedure is carried out for each component of the erroneous selector hence by the end of this procedure each component will have a corresponding set of css selectors may be empty .
precisely to find the valid selectors the algorithm first looks for possibly valid elements represented by pve lines .
these are the elements that match the original selector up to and includingthe the selector level ci level neglecting the component being assumed erroneous.
for instance suppose in the running example the tag component p of the erroneous selector is assumed as incorrect by our design.
this component is found in level of the erroneous selector.
hence our design traverses the dom to look for elements that match the selector up to level neglecting p i.e.
elements that match div view display id catalog view .pages .
once pve is found the algorithm lines checks if the element does indeed contain a corresponding replacement for the 3due to space constraints we omit the enclosing functions.842component that was assumed to be incorrect e.g.
if an id is being replaced the element must have an id line .
in our example p which is a tag component was assumed incorrect so the verification will pass for all elements in pve because every element has a tag name.
it also checks if the element contains any descendants children or siblings depending on the structure of the erroneous selector lines .
again in the running example the next level level of the erroneous selector must be the descendant of the first two levels because of the whitespace between the level components and the level components hence the check will pass for an element if it contains any descendants.
if both checks pass the corresponding component is used to create a new selector each new selector is stored in vs. finally for each new selector a final verification step is carried out to ensure that the new selector is indeed valid in dom lines .
in summary for the running example our design looks for matching selectors of the form div view display id catalog view new tag .pages span .
similarly if the id component viewdisplay id catalog view were assumed incorrect the algorithm looks for matching selectors of the form div new id p.pages span .
in the latter case two matching valid selectors are found div view id catalog view p.pages span and div view displayid catalog page p.pages span inferring possible replacements to determine the possible sickness our design determines if any element of the local string set of each component lss lss ... lss n can be replaced to match one of the valid selectors in vs. this is accomplished by the replacementsfinder function line .
the basic idea is as follows for each component string set element assume that this element is incorrect then determine if any of the valid selectors can provide a replacement string value for that element.
we accomplish this matching with the valid selectors through the use of a string constraint solver see section .
.
let us go back to the running example.
suppose the design is currently considering the view display id catalog view component whose local string set was found earlier.
also as mentioned two valid replacement selectors were found for this component.
our design goes through each element in the local string set to look for possible replacements.
first it assumes that the first string set element namely div view display id startindex endindex is incorrect hence it checks if any of the valid selectors is of the form div new string catalog view p.pages span i.e.
the erroneous selector with the string viewdisplay id replaced.
in this case the constraint solver will find one matching selector div view id catalog view p.pages span .
next our design will move on to the second local string set element and perform the same procedure to find the following matching selector div view display id catalog page p.pages span .
case index replacement.
in this step our design assumes that the index used to access the list of elements returned by the direct dom access is incorrect.
to check whether this assumption holds our approach records the size of the array returned by the direct dom access this is determined based on the value of an instrumented variable added to the javascript code to keep track of the size.
the erroneous array index used if any is also recorded.
the erroneous array index is compared with the size to see if it falls within the allowed range of indices i.e.
.
if not our approach will package the following as a possible sickness belonging to the index sickness class to be added to the list of possible sicknesses an array index has a numerical value of x that does not fall within the range here xis the erroneous array index and zissize .case null undefined checks.
by default our design packages a possible sickness belonging to the null undefined class to account for cases where the repair is a dom element validation.
in essence this means the line of code must be wrapped in an ifstatement that checks whether the dom element being used is null or undefined .
if code termination was caused by a null exception or undefined exception the following is packaged and added to the list of possible sicknesses a line of code x accessing a property method of the dom element returned by the direct dom access should probably not execute if the dom element is null or undefined .
.
suggesting treatments once the symptom analyzer has found a list of possible sicknesses each of these possible sicknesses is examined by the treatment suggester figure box c .
the goal of the treatment suggester is as follows given a possible sickness create an actionable repair message that would prompt the programmer to modify the javascript code in such a way that the symptom represented by the possible sickness would disappear.
in order to accomplish this the code context as inferred from the supplementary information retrieved by the data collector is analyzed.
this module handles each possible sickness class separately as described below.
string class.
possible sicknesses belonging to the string class require the string value xat some line in the javascript code to be replaced by another string value y. if applied correctly this would cause the parameter at the direct dom access to be valid so the direct dom access would no longer output null undefined nor an empty set of elements i.e.
symptom disappears .
as we discovered in section .
most parameter replacement fixes are direct string literal replacements hence at first it may seem straightforward to simply output a message prompting the programmer to directly perform the replacement.
however there are several cases that may make this suggestion invalid for example .
the string value is not represented by a string literal but rather by a variable or an expression.
recall that when calculating the string set gaps may exist in this string set due to string values originating from sources external to the javascript code or due to values not originating from string literals.
hence a simple replace message would be inappropriate to give out as a suggested repair .
the string value may be in a line that is part of a loop.
here a replace message may also be inappropriate since the replacement would affect other possibly unrelated iterations of the loop thereby possibly causing unwanted side effects.
to account for these cases before outputting a repair message our approach first examines a the string set element type i.e.
is it a variable expression or string literal?
and b the location i.e.
inside a loop?
.
through this analysis the treatment suggester can provide a suggested repair message.
the algorithm essentially performs a background check on the code suffering from the bug to determine what message to output.
for example if our design finds that a string set element is in a line inside a loop and this line executed multiple times a message such as replace at iteration or off by one will be given.
the complete list of messages is presented in table .
when the running example is subjected to the treatment suggester algorithm the possible sicknesses found by the symptom analyzer will lead to two replace messages being suggested one of which is the fix described in section replace the string literal div view display id with div view id in line .
the843table list of output messages.
type description replace replace the string literal x with y in line l replace at iterationwrap line l in an if statement so that the string literal x instead has value y at iteration i off by one at beginningchange the lower bound of the for loop containing line l so that the original first iteration does not execute off by one at end change the upper bound of the for loop containing line l so that the original last iteration does not execute modify upper boundchange the upper bound of the for loop containing line l so that the loop only iterates up to iteration i inclusive exclude iteration skip iteration i of the for loop containing line l by adding a continue ensure ensure that the string value at line l has value y instead of x .
this is a fall back message which is given if a precise modification to the code cannot be inferred by the suggester.
thus our suggester is conservative in that it only provides a particular suggestion if it is certain that the suggestion will lead to a correct replacement.
other message is a spurious suggestion replace the string literal catalog view with catalog page in line .
index and null undefined class.
for the index class the suggestion is always as follows modify the array index in line l to some number within the range .
for the null undefined class the suggestion depends on whether the exception was a null exception or an undefined exception.
if the exception is a null exception the following message is given wrap line l in an if statement that checks if expression e is null .
here the expression e is inferred directly from the error message which specifies which expression caused the null exception.
an analogous message is given if the exception is undefined .
.
implementation vejovis we implemented our approach in a tool called v ejovis which is freely available for download .
the data collector is implemented by instrumenting the javascript code using r hino and running the instrumented application using c rawljax .
for the symptom analyzer we use the string constraint solver h ampi for replacementfinder see algorithm line which looks for viable replacements among the valid parameters found.
the symptom analyzer treats the valid parameters found as defining the context free grammar cfg .
in keeping with our goal of providing as few suggestions as possible v ejovis allows the users to modify a parameter called the edit distance bound .
the edit distance bound is a cutoff value that limits the suggested replacement strings to only those whose edit distance with the original string is within the specified value.
we use berico s implementation of the damerau levenshtein algorithm to calculate the edit distance.
.
ev aluation to evaluate the efficacy of v ejovis in suggesting repairs for dom related faults we answer the following research questions.
rq3 accuracy what is the accuracy of v ejovis in suggesting a correct repair?
rq4 performance how quickly can v ejovis determine possible replacements?
what is its performance overhead?
we perform a case study in which we run v ejovis on real world bugs from eleven web applications.
to determine accuracy rq3 we measure both the precision and recall of our tool.
to calculatethe performance rq4 we compare the runtimes of v ejovis with and without instrumentation.
.
subject systems the bugs to which we subject v ejovis come from eleven opensource web applications studied also in section hence these bugs represent real world dom related faults that occurred in the subject systems.
we choose two bug reports randomly from the set of bugs that satisfy our fault model for each of the eleven web applications for a total of bugs.
note that taskfreak is not included among the applications studied as we only found javascript bugs from that application none of which fit the fault model described in section .
descriptions of the bugs and their corresponding fixes henceforth called the actual fixes can be found online .
it took programmers an average of days to repair these bugs after being triaged indicating that they are not trivial to fix.
we had to restrict the number of bugs to two per application as the process of deploying the applications and replicating the bugs was a time and effort intensive one.
in particular most of the bugs were present in older versions of the web applications.
this presented difficulties in installation and deployment as some of these earlier versions are no longer supported.
.
methodology accuracy.
we measure accuracy based on both recall andprecision.
in the context of this experiment recall refers to whether our tool was able to suggest the correct fix that is whether one of the suggestions provided by v ejovis matches the actual developer fix described in the corresponding bug report.
hence in this case recall is a binary metric i.e.
either or because the actual fix either appears in the list of suggestions or it does not.
note that in some cases the suggested fix is not an exact match of the applied fix but is semantically equivalent to it and is considered a match.
precision refers to the number of suggestions that match the actual fix divided by the number of suggestions provided by v ejovis .
again since there is only one matching fix precision will be either if the correct fix is not suggested or1 suggestions.
this metric is a measure of how well v ejovis prunes out irrelevant incorrect fixes.
to measure the above metrics we first replicated the bug and ran v ejovis with the url of the buggy application and the direct dom access information i.e.
line number and enclosing function as input for the libraries the bugs are replicated by using the test applications described in the bug reports.
v ejovis outputs a list of suggestions for the bug which we compare with the actual developer fix to see if there is a match.
based on this comparison we calculated the recall and precision for that particular attempt.
in our experimental setup the suggestions are sorted according to the edit distance of the replacement string with respect to the original string where replacements with smaller edit distances are ranked higher.
suggestions for null or undefined checks are placed between suggestions with edit distance and those with edit distance .
in the event of a tie we assume the worst case i.e.
the correct fix is ranked lowest among the suggestions with the same edit distance.
to test our assumption that the replacement parameter closely resembles the original parameter we control the edit distance bound defined in section .
for v ejovis .
we first run our experiments with an edit distance bound of infinity which means the suggestions given do not have to be within any particular edit distance relative to the original string being replaced i.e.
no edit distance bound assigned .
then to observe how this bound affects v ejo 844table accuracy results with edit distance bound set to infinity i.e.
no bound assigned.
br1 refers to the first bug report and br2 the second bug report from each application .
data in parentheses are the results for when the edit distance bound is set to .
application accurate?
precision br1 br2 br1 br2 drupal ember.js joomla jquery moodle mootools prototype roundcube typo3 wikimedia wordpress vis accuracy we re run our experiments with a smaller edit distance bound of .
we choose the value based on a pilot study.
performance.
for each bug we measure the performance overhead introduced by v ejovis instrumentation by comparing the corresponding web application with and without instrumentation.
this evaluates the performance of the data collection phase of v ejovis .
we also measure the time it takes for v ejovis to generate the repair suggestions.
this evaluates the performance of the symptom analysis and treatment suggestion phases of v ejovis .
.
results accuracy.
table shows the results of our experiments when the edit distance bound is set to infinity i.e.
no bound is assigned numbers outside parentheses .
the accurate column of table indicates for each bug whether the actual fix appears among the list of repairs suggested by v ejovis i.e.
the recall was .
as the results show assigning no bound causes v ejovis to accurately suggest repairs for out of the bugs for an overall recall of .
the only unsuccessful cases are the second bugs in roundcube where the correct replacement selector is focus not body and jquery where the correct replacement selector is vejovis does not currently support these css selector syntax .
note that in three of the successful cases the repair suggestion does not exactly match the actual fix but rather is equivalent to or close to the actual fix.
first in the second typo3 bug the actual fix documented in the bug report is to add a check to ensure that the nodelist valueobj which is populated by a direct dom access call to getelementsbyname has a length greater than thereby preventing the use of valueobj .value from throwing an undefined exception.
v ejovis in contrast suggested an alternate but equivalent fix with no side effects namely adding a check to see if the expression valueobj is undefined before trying to access one of its properties.
second in both the first moodle bug and the second prototype bug v ejovis provides the fallback ensure suggestion.
in the moodle bug v ejovis suggests the following ensure the value of variable itemid is id itemname instead of itemname this is because the string literal itemname originated from an anonymous function which our implementation currently does not support leaving a gap in the string set.
nonetheless this simplifies the debugging task for the programmer as it points her directly to the problem i.e.
the string itemname located somewhere in the javascript code needs to be changed to id itemname .
similarly in the prototype bug v ejovis suggests the following en table rank of the correct fix when suggestions are sorted by edit distance.
the denominator refers to the total number of suggestions.
top ranked suggestions are in bold.
application rank br1 br2 drupal ember.js joomla jquery moodle moodle prototype roundcube typo3 wikimedia wordpress sure the expression id.replace g has value outer.div instead of outer 0div .
again while v ejovisis not able to provide the exact fix it points the programmer to the relevance of the replace method in the fix.
these results show that even in cases when v ejovis is unable to fully resolve the origins of the erroneous selector s string values it still provides meaningful suggestions that facilitate debugging and are hence useful to the programmer.
among the successful cases the average precision precision column of table is approximately on average this translates to v ejovis providing suggestions for each bug with a maximum of total suggestions for the first typo3 bug.
the high number of suggestions motivated us to implement the simple ranking scheme based on edit distance section .
.
table shows for each bug the rank of the actual fix among the list of suggestions provided by v ejovis only the cases where the actual fix appears among the list of suggestions are considered.
as shown in the table the correct fix appears as the first suggestion in out of the cases and as the second suggestion in three more cases.
in fact for the wordpress bug the correct fix is tied for first place among bugs we listed its rank as because we consider the worst case.
hence despite providing a large number of suggestions on average when the edit distance bound is set to infinity our simple ranking scheme based on edit distance ranked most of the actual fixes near the top of the list of suggestions .
as mentioned the above results were obtained with an edit distance bound of infinity.
to quantify the effects of using a finite bound we re ran the above accuracy experiment with an edit distance bound of .
the results are shown in parentheses in table .
as the results show assigning a bound of decreases the number of successful cases from to where four additional cases became unsuccessful because the actual fix required replacing the original parameter with another parameter that is more than an edit distance of away.
however the precision jumps dramatically to with this bound which translates to around suggestions given for each bug on average.
hence assigning a finite edit distance bound can significantly decrease the number of suggestions which makes the list of suggestions more manageable however this comes at the cost of lower recall of as compared to .
performance.
there are two sources of performance overhead in vejovis instrumentation overhead and symptom analysis and treatment suggestion overhead.
table shows the results.
the time taken with and without instrumentation during the data collection phase of v ejovis are shown in the second and third columns of the table.
the time varies per application ranging from .
to .
seconds for an average of .
seconds.
the time in the symptom analysis and treatment suggestion phases is shown in the last845table performance results.
application crawl crawl average time w o time with treatment instrumentation s instrumentation s time s drupal .
.
.
ember.js .
.
.
joomla .
.
.
jquery .
.
.
moodle .
.
.
mootools .
.
.
prototype .
.
.
roundcube .
.
.
typo3 .
.
.
wikimedia .
.
.
wordpress .
.
.
average .
.
column.
the average time for these phases is .
seconds ranging from .
to seconds.
thus on average v ejovis takes less than one minute seconds to find the correct fix with a worst case time of .
seconds for joomla.
.
discussion extensions.
first v ejovis suggests treatments belonging to the parameter modification and dom element validation categories as mentioned in our empirical study of common fixes in section .
while these together constitute more than half of the fix types we found in the study another common fix category is method property modification in which a dom api method or property is added removed or replaced with another method property.
we do not incorporate this fix category in our design however v ejovis can be extended to account for this category.
for instance it is possible in some cases to reduce the problem of replacing dom methods to replacing css selectors.
as an example replacing getelementbyid str with getelementsbyclassname str can be thought of as replacing the css selector str with .str .
second the results of our evaluation show that while v ejovis accurately predicts the actual fix in almost all of the bug reports analyzed the number of suggestions provided can be large thereby lowering its precision.
in our evaluation we showed that ranking the fixes based on edit distance makes the actual fix rank high in many cases.
we are currently exploring more intelligent ways to perform this ranking for example based on the textual patterns of the strings.
threats to validity.
anexternal validity threat is that the bugs we analyzed come from only web applications.
however the systems considered were developed for different purposes and hence represent a reasonable variety.
further the corresponding bug reports have been fixed by the developers and are therefore representative of the issues encountered in practice.
aninternal threat to validity is that we have assumed the fixes described in the bug reports are correct as many experienced developers are typically involved with providing patches for these bugs.
nonetheless to mitigate this threat we carefully analyzed the patches provided in the bug reports and have tested the fixes on our own platforms to see if they are sound.
additionally the bugs we considered in our evaluation were taken from the bug report study in section which may be a potential source of bias.
this threat can be mitigated by considering other applications which we plan to do in the future.
as for repeatability v ejovis is available and the experimental subjects are open source making our case study fully repeatable.
.
related work program repair.
program repair refers to the act of fixing bugs through automated techniques.
perhaps the best known application of program repair is to data structures.
demsky et al.
use formal specifications to suggest fixes for data structures.
elkareblieh et al.
use programmer specified assertions for data structure repair.
however these techniques are limited to repairing data structures and do not fix the underlying defect that produced the erroneous structure.
while the dom can be considered a data structure v ejovis goes beyond the dom and actually can suggest ways to modify the javascript code based on the defective dom access.
generating fixes at the source code level has gained attention recently .
weimer et al.
propose the use of genetic algorithms for repairing c programs.
the main idea is to copy other parts of the program to the faulty portion of the program and check if the modified program passes the existing test cases.
however it is not clear how this technique could be applied to web applications where the code base includes different languages such as javascript and html dom.
in recent work zhang et al.
propose flowfixer a technique to repair broken workflows in java based gui applications.
similar to v ejovis flowfixer attempts to find repairs for errors that arise due to a mismatch between the code and the gui state.
however there are two main differences between v ejovis and flowfixer.
first flowfixer is concerned with correcting the sequence of user actions applied to the gui in contrast v ejovis is concerned with correcting the code that drives the functionality of the application.
second flowfixer uses random testing to find replacements v ejovis is different in that it performs a systematic traversal of the dom to find valid replacement selectors.
web application repair.
there has been limited work on exploring fault repair for web applications.
carzaniga et al.
propose automatic workarounds for web applications that experience errors in using apis by replacing the buggy api call sequence with a functionally equivalent but correct sequence.
samimi et al.
have proposed a technique for php code to fix errors that result in the generation of webpages with malformed html similar work has been done by zheng et al.
.
neither of these techniques consider javascript code nor do they apply to dom related javascript faults.
in recent work jensen et al.
and meawad et al.
introduce techniques to transform unsafe evalcalls in javascript code to functionally equivalent but safe constructs.
this is more of a prevention than repair technique.
however they do not consider javascript errors and in particular dom related errors.
.
conclusion javascript interacts extensively with the dom to create responsive applications yet such interactions are prone to faults.
in this paper we attempt to understand common fixes applied by programmers to dom related faults.
based on these findings we propose an automated technique for providing repair suggestions for domrelated javascript faults.
our technique implemented in a tool called v ejovis is evaluated through a case study of bugs based on real life bug reports.
we find that v ejovis can accurately predict the repair in out of the bugs and that the correct fix appears first in the list of fix suggestions for of the bugs.
.