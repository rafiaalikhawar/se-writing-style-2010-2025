proving mcapi executions are correct using smt yu huang eric mercer and jay mccarthy department of computer science brigham young university provo ut usa email fyuhuang egm jayg byu.edu abstract asynchronous message passing is an important paradigm in writing applications for embedded heterogeneous multicore systems.
the multicore association mca an industry consortium promoting multicore technology is working to standardize message passing into a single api mcapi for bare metal implementation and portability across platforms.
correctness in such an api is difficult to reason about manually and testing against reference solutions is equally difficult as reference solutions implement an unknown set of allowed behaviors and programmers have no way to directly control api internals to expose or reproduce errors.
this paper provides a way to encode an mcapi execution as a satisfiability modulo theories smt problem which if satisfiable yields a feasible execution schedule on the same trace such that it resolves non determinism in the mcapi runtime in a way that it now fails user provided assertions.
the paper proves the problem is np complete.
the encoding is useful for test debug and verification of mcapi program execution.
the novelty in the encoding is the direct use of match pairs potential send and receive couplings .
matchpair encoding for mcapi executions when compared to other encoding strategies is simpler to reason about results in significantly fewer terms in the smt problem and captures feasible behaviors that are ignored in previously published techniques.
further to our knowledge this is the first smt encoding that is able to run in infinite buffer semantics meaning the runtime has unlimited internal buffering as opposed to no internal buffering.
results demonstrate that the smt encoding restricted to zerobuffer semantics uses fewer clauses when compared to another zero buffer technique and it runs faster and uses less memory.
as a result the encoding scales well for programs with high levels of non determinism in how sends and receives may potentially match.
index terms abstraction refinement smt message passing i. i ntroduction embedded devices fill all sorts of crucial roles in our lives.
they exist as medical devices as network infrastructure and they control our automobiles.
embedded devices continue to become more powerful as computing hardware becomes smaller and more modular.
it is now becoming commonplace to find multiple processing units inside a single device.
the multicore association mca is an industry group that has formed to define specifications for low level communication resource management and task management for embedded heterogeneous multicore devices .
one specification that the mca has released is the multicore association communications api mcapi .
the specification defines types and functions for simple message passing operations between different computing entities withina device.
messages can be passed across persistent channels that force an ordering of the messages or they can be passed to specific endpoints within the system.
the specification places few ordering constraints on messages passed from one endpoint to another.
this freedom introduces the possibility of a race between multiple messages to common endpoints thus giving rise to non deterministic behavior in the runtime .
if an application has non determinism it is not possible to test and debug such an application without a way to directly or indirectly control the mcapi runtime.
there are two ways to implement the mcapi semantics infinite buffer semantics the message is copied into a runtime buffer on the api call and zero buffer semantics the message has no buffering .
an infinite buffer semantics provides more non deterministic behaviors in matching send and receives because the runtime can arbitrarily delay a send to create interesting and unexpected send reorderings.
the zero buffer semantics follow intuitive message orderings as a send and receive essentially rendezvous.
sharma et al.
propose a method to indirectly control the mcapi runtime to verify mcapi programs under zero buffer semantics .
as the work does not address infinite buffer semantics it is somewhat limited in its application.
the work does provide a dynamic partial order reduction for the model checker but such a reduction is not sufficient to control state space explosion in the presence of even moderate nondeterminism between message sends and receives.
a key insight from the approach is its direct use of match pairs couplings for potential sends and receives.
wang et al.
propose an alternative method for resolving nondeterminism for program verification using symbolic methods in the context of shared memory systems .
the work observes a program trace builds a partial order from that trace called a concurrent trace program ctp and then creates an smt problem from the ctp that if satisfied indicates a property violation.
elwakil et al.
extend the work of wang et al.
to message passing and claim the encoding supports both infinite and zero buffer semantics.
a careful analysis of the encoding however shows it to not work under infinite buffer semantics and to miss behaviors under zero buffer semantics .
interestingly the encoding assumes the user provides a precise set of match pairs as input with the program trace and it then uses those match pairs in a non obvious way to constrain the happensbefore relation in the encoding.
the work does not discuss978 .
c ieee ase palo alto usa26 task task task initialize node 0 v s e0 create endpoint port 0 s msg recv i e0 a sizeof a h1 s wait h1 size s mcapi inf a atoi a msg recv i e0 b sizeof b h2 s wait h2 size s mcapi inf b atoi b if b assert a 0a finalize s initialize node 1 v s e1 create endpoint port 1 s e0 get endpoint node 0 port 0 s msg recv i e1 c sizeof c h3 s wait h3 size s mcapi inf msg send i e1 e0 n h4 s wait h4 size s mcapi inf finalize s initialize node 2 v s e2 create endpoint port 2 s e0 get endpoint node 0 port 0 s e1 get endpoint node 1 port 1 s msg send i e2 e0 n h5 s wait h5 size s mcapi inf msg send i e2 e1 go n h6 s wait h6 size s mcapi inf finalize s fig.
.
an mcapi concurrent program execution how to generate the match pairs which is a non trivial input to manually generate for large or complex program traces.
an early proof claims that the problem of finding a precise set of match pairs given a program trace is np complete .
this paper presents a proof that resolving non determinism in message passing programs in a way that meets all assertions is np complete.
the paper then presents an smt encoding for mcapi program executions that works for both zero and infinite buffer semantics.
the encoding does require an input set of match pairs as in prior work but unlike prior work the match set can be over approximated and the encoding is still sound and complete.
the encoding requires fewer terms to capture all possible program behavior when compared to other proposed methods making it more efficient in the smt solver.
to address the problem of generating match pairs an algorithm to generate the over approximated set is given.
to summarize the main contributions in this paper are a proof that the problem of matching sends to receives in a way that meets assertions is np complete a correct and efficient smt encoding of an mcapi program execution that detects all program errors under zero or infinite buffer semantics given the input set of potential match pairs contains at least the precise set of match pairs and ano n2 algorithm to generate an over approximation of possible match pairs where nis the size of the execution trace in lines of code.
organization section gives an example.
section shows the np completeness reduction.
section gives the encoding.
section shows how to generate match pairs.
section presents the results.
section discusses related work.
and section is conclusions and future work.
ii.
e xample it is a challenge to explain intended behavior in simple scenarios consisting of a handful of calls when dealing with concurrency.
consider the mcapi program execution in figure that includes three tasks that use send mcapi msg sen d i and receive mcapi msg recv i calls to communicate with each other.
line numbers appear in the first columnfor each task with the first digit being the task id.
the declarations of the local variables are omitted for space.
picking up the scenario just after the endpoints are defined lines 02and05receive two messages on the endpoint e0 in variables aandbwhich are converted to integer values and stored in variables aandbon lines 04and07 task receives one message on endpoint e1in variable con line 13and then sends the message on line 15toe0 and finally task sends messages and go on lines 24and 26to endpoints e0ande1respectively.
the additional code lines asserts properties of the values in aandb.
the mcapi wait calls block until the associated send or receive buffer is able to be used.
given the scenario a developer might ask the question what are the possible values of aandb after the scenario completes?
the intuitive trace is shown in figure using a shorthand notation for the mcapi commands send denoted as s receive denoted as r or wait denoted as w .
the shorthand notation further preserves the thread id and line number as follows for each command oi j k h o2fs rgorw h irepresents the task id jrepresents the source line number krepresents the destination endpoint and hrepresents the command handler.
a specific destination task id is in the notation when a trace is fully resolved otherwise indicates that a receive has yet to be matched to a send.
the lines in the trace indicate the context switch where a new task executes.
24s2 h5 25w h5 02r0 h1 03w h1 26s2 h6 27w h6 04a atoi a 13r1 h3 14w h3 15s1 h4 16w h4 05r0 h2 06w h2 07b atoi b 08assume b 09assert a fig.
.
a feasible execution traces of the mcapi program execution in figure 12724s2 h5 25w h5 26s2 h6 27w h6 13r1 h3 14w h3 15s1 h4 16w h4 02r0 h1 03w h1 04a atoi a 05r0 h2 06w h2 07b atoi b 08assume b 09assert a fig.
.
a second feasible execution traces of the mcapi program in figure from the trace variable ashould contain 4and variable b should contain 1since task must first send message to e0before it can send message go toe1 consequently task is then able to send message toe0.
the assume notation asserts the control flow taken by the program execution.
in this example the program takes the true branch of the condition on line .
at the end of execution the assertion on line holds and no error is found.
there is another feasible trace shown in figure which is reachable under the infinite buffer semantics.
in this trace the variable acontains 1instead of since the message is sent to e0after sending the message go toe1as it is possible for the send on line 24to be buffered in transit.
the mcapi specification indicates that the wait on line 25returns once the buffer is available.
that only means the message is somewhere in the runtime and not that the message is delivered.
as such it is possible for the message to be buffered in transit allowing the send on line 15to arrive at e0first and be received in variable a .
such a scenario is a program execution that results in an assertion failure at line .
from the discussion above it is important to consider nondeterminism in the mcapi runtime when testing or debugging an mcapi program execution.
the next section presents a proof that the problem of matching sends to receives in a way that meets all assertions is np complete.
the proof justifies the encoding and smt solver.
following the proof the algorithm to generate the encoding is presented.
it takes an mcapi program execution with a set of possible send receive match pairs and generates an smt problem that if satisfied proves that non determinism can be resolved in a way that violates a user provided assertion the assertions are negated in the encoding and if unsatisfiable proves the trace correct meaning the user assertions hold on the given execution under all possible runtime behaviors .
the encoding can be solved by an smt solver such as yices or z3 .
iii.
np c ompleteness proof the complexity proof is inspired by the np completeness proof for memory coherence and consistency by cantin et al.
that uses a similar reduction from sat only in the context of shared memory .
the complexity proof is on a new decision problem verifying assertions in message passing v amp .definition .
verifying assertions in message passing .
instance a set of constants d a set of variables x and a finite sethof task histories consisting of send receive and assert operations over xandd.
question is there a feasible schedule sfor the operations ofhthat satisfy all the assertions?
the v amp problem is np complete.
the proof is a reduction from sat.
given an instance qof sat consisting of a set of variables uand set of clauses coveru an instance v of v amp is constructed such that vhas a feasible schedule s that meets all the assertions if and only if there is a satisfying truth assignment for q. feasible in this context means the schedule is allowed by the mcapi semantics.
the reduction is illustrated in figure .
the figure elides the explicit calls to wait which directly follow each send and receive operation and it elides the subscript notation as it is redundant in the figure.
the figure also adds the value sent and the variable that receives the value to the notation as that information is pertinent to the reduction.
the reduction relies on non determinism in the message passing to decide the value of each variable in u. the taskshd0 andhd1repeatedly send the constant value d0 false valuation ord1 true valuation to task hc.
the key intuition is that these tasks are synchronized with hcso they essentially wait to send the value until asked.
the taskhcsequentially requests and receives d0andd1 values for each variable in the sat instance q. it does not request values for a new variable until the current variable is resolved.
as the values come from two separate tasks upon request the messages race in the runtime and may arrive in either order at hc.
as a result the value in each variable is non deterministically d0ord1.
after the value of each variable uiis resolved the hctask asserts the truth of each clause in the problem instance.
as the clauses are conjunctive the assertions are sequentially evaluated.
if a satisfying assignment exists for q then a feasible schedule exists that resolves the values of each variable in such a way that every assert holds.
lemma .
sis a feasible schedule for hthat satisfies all assertions if and only if qis satisfiable.
proof.
feasible schedule for v implies q is satisfiable proof by contradiction.
assume that qis unsatisfiable even though there is a feasible schedule sforvthat meets all the assertions.
the reduction in figure considers all truth values of the variables in q over every combination by virtue of the non determinism and then asserts the truth of each of the clauses inq.
the complete set of possibilities is realized by sending in parallel from hd0andhd1the two truth valuations for a given variable to hc.
as these messages may be received in any order each variable may assume either truth value.
further each variable resolved is an independent choice so all combinations of variable valuations must be considered.
this fact is a contradiction to the assumption of qbeing unsatisfiable as the same truth values that meet the assertions28sat u fu0 u1 umg c fc0 c1 cng q fc0 c1 cng v ampi h fhd0 hd1 hcg x fu0 um g0 g1g d fd0 d1g hd0hd1hc r g0 r g1 s d0 hd0 s d0 hc s d1 hc s d0 hd1 r u0 r u0 r g0 r g1 s d0 hd0 s d0 hc s d1 hc s d0 hd1 r u1 r u1 assert c0 assert c1 fig.
.
general sat to v ampi reduction would be a satisfying assignment in q. q is satisfiable implies feasible schedule for v the proof is symmetric to the previous case and proceeds in a like manner.
theorem np complete .vamp is np complete.
proof.
membership in np a certificate is a schedule matching send and receives in each of the histories.
the schedule is linearly scanned with the histories and checked that it does not violate mcapi semantics.
our extended version constructs an operational model of mcapi semantics that does just such a check given a schedule .
the complexity is linear in the size of the schedule.
np hard polynomial reduction from sat.
the correctness of the reduction is established by lemma .
the remainder of the proof is the complexity of the reduction.
there are two tasks to send values d0andd1upon request.
for each variable ui2u each of these tasks d0andd1 needs two operations one to synchronize with hcand another to send the value o juj .
the taskhcmust request values from hd0and hd1and then receive both those values it must do this for each variable o juj .
once all the values are collected it must them assert each clause o jcj .
as every term is linear the reduction is linear.
iv.
smt e ncoding the new smt encoding is based on a trace of events during an execution of an mcapi program including controlflow assumptions and property assertions such as figure and a set of possible match pairs.
a match pair is the coupling of a receive to a particular send.
in the running example the set admits for example that r0 2can be matched with either s1 5ors2 .
this direct use of match pairs ratherthan a state based or indirect use of match pairs in an orderbased encoding and is novel.
the purpose of the smt encoding is to force the smt solver to resolve the match pairs for the system in such a way that the final values of program variables meet the assumptions on control flow but violate some assertion.
in essence the smt solver completes a partial order on operations into a total order that determines the final match pair relationships.
a. definitions the encoding needs to express the partial order imposed by the mcapi semantics as smt constraints.
the partial order is based on a happens before relation over operations such as send receive wait or assert definition happens before .the happens before hb relation denoted as hb is a partial order over operations.
given two operations aandb ifamust complete before bin a valid program execution then a hbbwill be an smt constraint.
the relation is derived from the program source and potential match pairs.
in order to specify the constraints from the program source each program operation is mapped to a set of variables that can be manipulated by the smt solver.
definition wait .the occurrence of a wait operation w is captured by a single variable order w that constrains when the wait occurs.
it is not enough to represent all events as simple numbers that will be ordered in this way.
such an encoding would not allow the solver to discover what values would flow across communication primitives.
instead some events in the trace are modeled as a set of smt variables that record the pertinent information about the event.
for example definition send .a send operation s is a four tuple of variables ms the order of the matching receive event order s the order of the send es the endpoint and value s the transmitted value.
the endpoints do not change and the transmitted values are constants in an smt encoding mainly because this static topology has already been evaluated in an existing execution trace once the trace was obtained.
the most complex operation in mcapi is a receive.
since receives are inherently asynchronous it is not possible to represent them atomically.
instead we need to associate each receive with a wait that marks where in the program the receive operation is guaranteed to be complete.
the mcapi runtime semantics allow a single wait to witness the completion of many receives due to the message non overtaking property .
a wait that witnesses the completion of one or more receives is the nearest enclosing wait.
definition nearest enclosing wait .a wait that witnesses the completion of a receive by indicating that the message is29task task r0 h1 s1 h3 r0 h2 w h3 w h2 s1 h4 w h1 w h4 fig.
.
nearest enclosing wait example delivered and that all the previous receives in the same task issued earlier are complete as well.
figure shows that the wait w h2 witnesses the completion of the receive r0 1andr0 2in task .
thus w h2 is their nearest enclosing wait.
the encoding requires that every receive operation have a nearest enclosing wait as it makes match pair decisions at the wait operation.
the requirement is not a limitation of the encoding as accessing a buffer from a receive that does not have a nearest enclosing wait is an error.
rather the wait is a convenience in the encoding to mark where a receive actually takes place.
the same requirement can be made for sends for correctness but is not required for the encoding as send buffering is handled differently than receive buffering.
the encoding effectively ignores wait operations for sends as will be seen.
definition receive .a receive operation ris modeled by a five tuple of variables mr the order of the matching send event order r the order of the receive er the endpoint value r the received value and nwr the order of the nearest enclosing wait.
b. assumptions assertions and match pairs the definitions so far merely establish the pertinent information about each event in the trace as smt variables.
it is necessary to now express constraints on those variables.
the most trivial kind of constraints are those for controlflow assumptions.
definition assumption .every assumption ais added as an smt assertion.
it may seem strange to turn assumptions into assertions but from a constraint perspective the assumption that we have already observed some property during control flow is equivalent to instructing the smt solver to treat it as inviolate truth or an assertion.
the next level of constraint complexity comes from property assertions.
these correspond to the invariants of the program.
the goal is to discover if they can be violated so we instruct the smt solver to seek for a way to satisfy their negation given all the other constraints.
definition property assertion .for every property assertionp pis added as an smt assertion.finally we must express the relation in a given match pair as a set of smt constraints.
informally a match pair equates the shared components of a send and receive and constrains the send to occur before the nearest enclosing wait of the receive.
formally definition match pair .a match pair hr si for a receive rand a send scorresponds to the constraints mr order s ms order r er es value r value sand order s hbnwr the encoding is given a set of potential match pairs over all the sends and receives in the program trace.
the constraints from these match pairs are not simply joined in a conjunctions.
if we were to do that then we would be constraining the system such that a single receive must be paired with all possible sends in a feasible execution rather than a single send.
therefore we combine all the constraints for a given receive with all possible sends as specified by the input match pairs into a single disjunction definition receive matches .for each receive r ifhr s0i throughhr sniare match pairs thenwn ihr siiis used as an smt constraint.
this encoding of the input ensures that the smt solver can only use compatible send receive pairs and ensures that sends happen before nearest enclosing waits on receives.
c. program order constraints the encoding thus far is missing additional constraints on thehappens before relation stemming from program order.
these constraints are added in four steps we must ensure that sends to common endpoints occur in program order in a single task step similarly for receives step receives occur before their nearest enclosing wait step and that sends are received in the order they are sent step .
step for each task if there are sequential send operations say sands0 from that task to a common endpoint es es0 then those sends must follow program order order s hborder s0.
step for each task if there are sequential receive operations say randr0 in that task on a common endpoint er er0 then those receives must follow program order order r hborder r0.
step for every receive rand its nearest enclosing wait w order r hborder w. step for any pair of sends sand s0on common endpoints es es0 such that order s hborder s0 then those sends must be received in the same order ms hbms0.
for example consider two tasks where task sends two messages to task as shown in figure .
the msvariables from the sends will be assigned to the orders for r1 1andr1 by the match pairs selected by the smt solver.
the constraints added in this step force the send to be received in program30task task s0 h1 r1 h3 s0 h2 r1 h4 w h1 w h3 w h2 w h4 fig.
.
send ordering example ... 01order r0 hborder w h1 02order r0 hborder w h2 03order r0 hborder r0 04order r1 hborder w h3 b not a 07hr0 s2 4i hr0 s1 5i 08hr0 s2 4i hr0 s1 5i 09hr1 s2 7i fig.
.
smt encoding order using the hbrelation which for this example yields ms0 hbms0 .
d. zero buffer semantics the constraints presented so far correspond to an infinitebuffer semantics because we do not constrain how many messages may be in transit at once.
we can add additional orthogonal constraints to further restrict behavior and enforce a zero buffer semantics.
there are two kinds of such constraints.
first for each task if there are two sends sands0such that order s hborder s0 and sands0can both match a receive r then we add the following constraint to the encoding order w hborder s0where wis the nearest enclosing wait that witnesses the completion of rin execution.
the second constraint relies on a dependence relation between two match pairs.
definition .
to match pairs are dependent denoted as hr si hr0 s0i if and only if the nearest enclosing wait wofr0issues before son an identical endpoint or 9hr00s00isuch thathr si hr00 s00i hr00 s00i hr0 s0i.
with the dependence relation the second set of constraints for the zero buffer semantics is given as for each pair of sends sands0that can both match a receive r if there is a send s00issued after the issuing of s0by an identical endpoint and a receive r0such thathr si hr0 s00i then we add the following constraint to the encoding order w hborder s where wis the nearest enclosing wait that witnesses the completion of r. e. example figure shows the encoding of figure as an smt problem.
we elide the basic definition of the variables discussedin section iv a. lines 05through 09give the assumptions assertions and match pairs.
the first four lines reflect the program order constraints receives happen before corresponding wait operations and receives from a common endpoint follow program order.
there are no constraints between sends because there are no sequential sends from a common endpoint to a common endpoint.
to encode the zero buffer semantics the constraint order w h1 hborder s1 5would need to be added to force the receive to complete before another send is issued.
f .
correctness before we can state our correctness theorem we must define a few terms.
we define our encoder as a function from programs and match pair sets to smt problems definition encoder .for all programs p and match pair setsm letsmt p m be our encoding as an smt problem.
we assume that an smt solver can be represented as a function that takes a problem and returns a satisfying assignment of variables or an unsatisfiable flag definition smt solver .for all smt problems s let sol s be in unsat where is a satisfying assignment of variables to values.
we assume that from a satisfying assignment to one of our smt problems we can derive an execution trace by observing the values given to each of the order evariables.
in other words we can view the smt solver as returning traces and not assignments.
we assume a semantics for traces that gives their behavior as either having an assertion violation or being correct definition semantics .for all programs p and traces t sem p t is either bad orok.
given this framework our smt encoding technique is sound if theorem soundness .for all programs p and match pair sets m sol smt p m t sem p t bad .
our soundness proof relies on the following lemma lemma .
any match pairhr siused in a satisfying assignment of an smt encoding is a valid match pair and reflects an actual possible mcapi program execution.
proof.
we prove this by contradiction.
first assume that hr si is an invalid match pair i.e.
one that is not valid in an actual mcapi execution .
second assume that the smt solver finds a satisfying assignment.
sincehr siis not a valid match pair match randsrequires program order message non overtaking or no multiple match to be violated.
in other words the happens before constraints encoded in the smt problem are not satisfied.
this is a contradiction either the smt solver would not return an assignment or the match pair was actually valid.
1in fact our extended technical report gives such a semantics.31the correctness of our technique relies on completeness theorem completeness .for all programs p and traces t sem p t bad 9m sol smt p m t. we prove completeness in our extended version by designing our semantics sem such that it simulates the solving of the smt problem during its operation to ensure that the two make identical conclusions.
however these theorems obscure an important problem how do we know which match pair set to use?
soundness assumes we have one while completeness merely asserts that one exists.
although section v discusses our generation algorithm we prove here an additional theorem that asserts that any conservative over approximation of match pair sets is safe.
theorem approximation .give two match pair sets mand m0 m m0 sol smt p m vsol smt p m0 where unsatv .
informally this is true because larger match pair sets only allow more behavior which means that the smt solver has more freedom to find violations but that all prior violations are still present.
however because of soundness it is not possible that using a larger match pair set will discover false violations.
the formal proof in our extended version relies on a match set combination operator that we prove distributes over an essential part of the semantics.
v. g enerating match pairs the exact set of match pairs can be generated by simulating the program trace and using a depth first search to enumerate non determinism arising from concurrent sends and receives.
such an effort however solves the entire problem at once because if you simulate the program trace exploring all nondeterminism then you may as well verify all runtime choices for property violations at the same time.
in this section we present an algorithm that does not require an exhaustive enumeration of runtime behavior in simulation.
our algorithm over approximates the match pairs such that match pairs that can exist in the runtime are all included and some bogus match pairs that cannot exist in the runtime may or may not be included.
this algorithm does well in restricting the size of bogus match pairs where each one is a nondeterministic choice that costs an smt solver more runtime and system memory.
generating a precise set of match pairs is np complete .
the algorithm generates the over approximated match pair set by matching each pair of the send and receive commands at common endpoints and then pruning obvious matches that cannot exist in any runtime implementation of the specification.
figure presents the major steps of the algorithm.
the algorithm proceeds by first linearly traversing each task of the program storing each receive and send command into two distinct structured lists.
the receive list list r is structured initialization input an mcapi program initialize list r initialize list s check each receive and send with the same endpoint for r in list r for s in list s let dest destination endpoint s let src source endpoint s check matching criteria for r and s if .
endpoint r dest .
index r index s .
index r index s count sends dest dest count sends src src dest dest then add pair r s to match set else continue end if end for end for output match set fig.
.
pseudocode for generating over approximated match pairs task task task r0 h1 s1 h5 s2 h8 w h1 w h5 w h8 r0 h2 r1 h6 w h2 w h6 s0 h3 s1 h7 w h3 w h7 r0 h4 w h4 fig.
.
another mcapi concurrent program as in and the send list list s is structured as in .
e0!
r0 r0 e1!
r1 r1 en!
rn rn the list list r groups receives by the issuing endpoint.
the integer field merely records the order in which the receives are issued and increases by one on each receive.
similarly the list list s groups sends first by the destination endpoint and then by the source endpoint.
like list r an index increases by one to track the issue order.
as the input is a program execution trace any sends or receives in loops already have unique identifiers.
dest src src e0!
e1!
s1 s1 e2!
e1!
e0!
s0 s0 e2!
en!
e0!
s0 s0 e1!
consider the program in figure .
the lists list r and list s for the program are !
r0 r0 r0 !
r1 !
!
s1 s1 !
s2 !
!
s0 the sends s1 s1 and s2 1have task as an identical destination endpoint.
the send s0 3has task as the destination endpoint.
the list list s in reflects this partition.
receive r0 1is the first receive operation in endpoint .
this fact is again reflected in list r in .
the algorithm traverses the two lists in a nested loop to generate match pairs between send and receive commands.
the function index r takes the endpoint of the receive and returns the issue order of that receive in the list r structure.
similarly the function index s takes the destination and source endpoints in the send and returns the issue order of that send in the list s structure.
these indexes help track message non overtaking.
the criteria to generate a match pair first requires the send and receive to be compatible check consistent with message non overtaking check and that message nonovertaking does not preclude the match check .
a match is precluded by message non overtaking when a receive cannot possibly match a send because by the time the program issues the receive the send must have already been matched somewhere else.
the function count gives the number of sends to a specific destination or the number of sends to a specific source and destination.
as long as a receive is issued early enough to still match the send given the message nonovertaking rule then the match is possible.
in our concrete example r0 1is matched with s1 1ors2 but it cannot be matched with s1 3since the second rule is not satisfied such that the order of r0 1is less than the order ofs1 i.e.
s1 3would have to overtake s1 1to satisfy the rule .
the match between r0 4ands1 1is also precluded by check as s1 1must have already matched an earlier receive by message non overtaking.
the generated set of match pairs for our example in figure is over approximated by the algorithm because it includes pairs that cannot exist in any feasible execution.
for example the match pair s2 1r0 is not feasible because it is not possible to order s1 3before r0 2since r1 2can only match with s0 3that must occur after r0 .
fortunately a satisfying solution is only possible using feasible match pairs.
nonfeasible match pairs merely result in extra clauses in the encoding and potentially slow down the smt solver.
the complexity of the algorithm is quadratic.
traversing the tasks to initialize the lists is o n wherenis the total lines of code of the program.
traversing the list of receives and the list of sends takes o mn to complete where mis the total number of sends and nis the total number of receives.
as m n n the algorithm takes o n mn o n n2 o n2 to complete.
vi.
e xperiments and results to assess the new encoding in this paper three experiments with results are presented a comparison to prior smt encodings on a zero buffer semantics a scalability study on the effects of non determinism in the execution time on infinitebuffer semantics and an evaluation on typical benchmark programs again with infinite buffer semantics.
all of the experiments use the z3 smt solver and are measured on a .
ghz intel quad core processor with gb memory running windows .
the initial program trace for the experiments is generated using the mca provided reference solution with fixed input.
in other words the only non determinism in the programs is that allowed by the mcapi specification.
as such the experiments only consider one path of control flow through the program.
complete coverage of the program for verification purposes would need to generate input to exercise different control flow paths.
where appropriate the time to generate the match pair sets from the input trace is reported separately.
a. comparison to prior smt encoding to our best knowledge the current most effective smt encoding for verification of message passing program traces is the order based encoding that describes the happens before relation directly in the encoding and is only functional for zero buffer semantics in its current form .
the order based encoding is more complex than the encoding in this paper and generates more clauses for the smt solver.
although the tool to generate the encoding is not publicly available the authors of the order based encoding graciously encoded several contrived benchmarks used for correctness testing.
these benchmarks are best understood as toyexamples that plumb the mcapi semantics to clarify intuition on expected behavior.
the zero buffer encoding in this paper is compared directly to the order based encoding on the contrived benchmarks.
the order based encoding yields incorrect answers for several programs.
where the order based encoding returns correct answers the new encoding on average requires fewer clauses uses half the memory as reported by the smt solver and runs eight times faster.
the dramatic improvement of the new encoding over the order based encoding is a direct result of the match pairs that simplify the happens before constraints and avoids redundant constraints in the transitive closure of the happens before relation.
b. scalability study the intent of the scalability study is to understand how performance is affected by the number of messages in the program trace and the level of non determinism in choosing match pairs where multiple sends are able to match to multiple receives.
the programs for this study consist of a simple pattern of a single thread to receive messages and nthreads to send messages.
the single thread sequentially receives n messages containing integer values and then asserts that every message did not receive a specific value.
in other words a violation is one where each message has a specific value.
the remaining nthreads send a message each containing a different unique integer value to the single thread that receives.
these programs represent the worst case scenario for non determinism in a message passing program as any send is33table i scaling as a function of non determinism test programs performance n feasible sets time hh mm ss memory mb !
3e32 .
!
8e47 .
!
3e64 .
!
8e81 .
!
1e100 .
able to match with any receive in the runtime and the assertion is only violated when each send is paired with a specific receive.
the smt solver must search through the multitude of match pairs n n to find the single precise subset of match pairs that triggers the violation.
in this program structure there aren!feasible ways to match nsends tonreceives.
the study takes an initial program of n so threads and variesnto see how the smt solver scales.
a small nis an easy program while a large nis a hard program.
table i shows how the new encoding scales with hardness.
the first column is the number of messages or n and the second column is the number of feasible match pair subsets that correctly match every receive to a unique send.
as expected running time and memory consumption increase non linearly with hardness.
the case where n represents having concurrent messages in flight from different threads of execution.
such a scenario is not entirely uncommon in a high performance computing application and it appears the new encoding is able to reasonably scale to such a level of concurrency.
the result provides a bound on expected cost for analysis given the message passing behavior in a program.
it is expected that the analysis of any program with fewer than !possible choices of feasible match pair resolutions will complete in a reasonable amount of time.
regardless such a high level concurrency seems unlikely in the embedded space to which mcapi is targeted.
c. typical benchmark programs the results in the prior section suggest that the number of messages is not the deciding factor in hardness for the new encoding rather hardness is measured by the number of feasible match pair sets.
this section further explores the observation to show that some programs are easy even if there are many messages while other programs are hard even though there are only a few messages.
the goal of these experiments is to measure the new encoding on several benchmark programs.
mcapi is a new interface and to date the authors are not aware of publicly available programs written against the interface aside from the few toy programs that come with the library distribution.
as such the benchmarks in the experiments come from a variety of sources.
leis the leader election problem and is common to benchmarking verification algorithms.
router is an algorithm to update routing tables.
each router node is in a ring and communicates only withtable ii performance on selected benchmarks test programs performance name mesg feasible sets eg s mg s time hh mm ss memory mb le .
.
.
router 6e2 .
.
.
multim 1e40 .
.
.
pktuse 1e81 .
.
.
immediate neighbors to update the tables.
the program ends when all the routing tables are updated.
multim is an extension to a program in the mcapi library distribution and is similar to the program in figure .
the extension adds extra iterations to the original program execution to generate longer execution trace.
pktuse is a benchmark from the mpi test suite .
the program creates tasks each of which randomly sends several messages to the other tasks.
the benchmark programs are intended to cover a spectrum of program properties.
as before the primary measure of hardness in the programs in not the number of messages but rather the size of the match pair set and the number of feasible subsets.
the leprogram is the easiest program in the suite.
although it sends messages there is only a single feasible match pair set.
the programs router multim and pktuse respectively increase in hardness which again is not related to the total number of messages but rather the total number of feasible match sets that must be considered.
for example even though router has messages it is an easier problem thatmultim that has messages.
the pktuse program does have the most number of messages and in this case the largest number of feasible match pair sets.
table ii shows the results for the benchmark suite.
other than the metrics used in table i the time of generating the encoding and the match pairs is included in the third and fourth columns respectively.
note that the time shown in the third column includes the time in the fourth column.
as before the running time tracks hardness and not the total number of messages.
the table also shows the cost of match pair generation as it dominates the encoding time for the pktuse program an item for future work .
the benchmark suite demonstrates that a message passing program may have a large degree of non determinism in the runtime that is prohibitive to verification approaches that directly enumerate non determinism such as a model checker.
the smt encoding however pushes the problem to the smt solver by generating the possible match pairs and then relying on advances in smt technology to resolve the nondeterminism in a way that violates the assertion.
of course the smt problem itself is np complete so performance is only reasonable for small problem instances.
the benchmark suite suggests that problem instances with astonishingly large numbers of feasible match pair sets are able to complete in a reasonable amount of time using the new encoding in this paper though the time to generate the match pairs may quickly become prohibitive.34vii.
r elated work morse et al.
provided a formal modeling paradigm that is callable from the c language for the mcapi interface .
this model correctly captures the behavior of the interface and can be applied to model checking c programs that use the api.
the work is a direct application of model checking and directly enumerates the non determinism in the runtime to construct an exhaustive proof.
the smt encoding in this paper pushes that complexity to the smt solver and leverages recent advances in smt technology to find a satisfying assignment.
sharma et al.
present an dynamic model checker for mcapi programs built on top of the mca provided mcapi runtime .
mcc systematically enumerates all non determinism in the mcapi runtime under zero buffer semantics.
it employs a novel dynamic partial order reduction to avoid enumerating redundant message orders.
this work claims smt technology is more efficient in practice in resolving non determinism in a away to violate correctness properties.
wang et al.
present an smt encoding for shared memory semantics for a given input trace from a multi threaded program .
as mentioned previously the program is partitioned into several concurrent trace programs and the encoding for each program is verified using smt technology.
elwakil et al.
extend the encoding to message passing programs using the mcapi semantics .
the comparison to the encoding in this work is already discussed previously.
an important body of work is being pursued for mpi program verification .
highlights include an extension to the spin model checker for mpi programs symbolic execution tools for mpi programs including new approaches to computing loop invariants and various dynamic verification tools for mpi programs.
although mpi is more expressive than mcapi the correctness properties in mcapi are similar to those in mpi.
more importantly the encoding in this work should be applicable to mpi programs that do not include collective operations.
an important aspect of future work is to extend the encoding to collectives.
there is a rich body of literature for smt sat based bounded model checking.
burckhardt et al.
exhaustively check all executions of a test program by translating the program implementation into sat formulas .
the approach relies on counter examples from the solvers the refine the encoding.
the smt encoding in this work is able to directly resolve the match pair set over approximation directly without needing to check a counter example.
dubrovin et al.
give a method to translate an asynchronous system into a transition formula over three partial order semantics .
the encoding adds constraints to compress the search space and decrease the bound on the program unwinding.
the encoding in this paper operates on a program execution and does not need to resolve a bound.
kahlon et al.
presented a partial order reduction mpor that operates in the bounded model checking space .
it guarantees that exactly one execution is calculated per eachmazurkiewicz trace to reduce the search space.
it would be interesting to see if mpor is able to extend to message passing semantics.
other work in bounded model checking explores heap manipulating programs and challenges in sequential systems code .
the application of static analysis is another interesting thread of research to test or debug message passing programs with some work in the mpi domain .
the work is important as it lays the foundation for refining match pair sets to only include those that cannot be statically pruned.
viii.
c onclusions and future work this paper presents a proof that the problem of resolving non determinism in message passing in a way that meets asserts is np complete.
the paper then presents an smt encoding of an mcapi program execution that uses match pairs directly rather than the state based or order based encoding in the prior work.
the encoding is generated from a given execution trace and a set of potential match pairs that can be over approximated.
the encoding takes extra care in forming the smt problem to preclude bogus match pairs in any overapproximation of the match pair input set.
critically the encoding is the first to correctly capture the non deterministic behaviors of an mcapi program execution under infinitebuffer semantics.
this paper further defines an algorithm with o n2 time complexity to over approximate the true set of match pairs wherenis the total number of code lines of the program.
a comparison to prior work for a set of toy examples under zero buffer semanics shows the new encoding capable and efficient in capturing correct behaviors of an mcapi program execution.
experiments further show that the encoding scales to programs with significant levels of non determinism in how sends match to receives.
the results show that a large match pair set does affect the runtime performance of the encoding in the smt problem even if the encoding is sound under an over approximation.
future work explores new methods for generating a much more precise set of match pairs.
the encoding is dependent on an input execution trace of the program.
future work explores integrating the encoding into a model checker.
the model checker generates a program trace that is encoded and verified.
the result is then used to inform the model checker as to where it needs to backtrack to generate a new execution trace.
the goal is to use the trace verification to construct a better partial order reduction in the model checker.
finally given the importance of high performance computing future work looks to extend the encoding to account for mpi collective operations.
this direction is motivated by the results where the encoding seems to scale to significant levels of concurrency.
it should be possible to express mpi collectives as additional constraints in the encoding and apply the technique to mpi programs directly.35references bronevetsky g. communication sensitive static dataflow for parallel message passing applications.
in cgo.
ieee computer society burckhardt s. alur r. martin m.m.k.
checkfence checking consistency of concurrent data types on relaxed memory models.
in acm sigplan pldi.
san diego california usa june cantin j.f.
lipasti m.h.
smith j.e.
the complexity of verifying memory coherence and consistency.
ieee trans.
parallel distrib.
syst.
jul dubrovin j. junttila t. heljanko k. exploiting step semantics for efficient bounded model checking of asynchronous systems.
in science of computer programming.
pp.
dutertre b. de moura leonardo a fast linear arithmetic solver for dpll t .
in ca v .
vol.
of lncs pp.
.
springer verlag elwakil m. yang z. cri symbolic debugger for mcapi applications.
in automated technology for verification and analysis elwakil m. yang z. debugging support tool for mcapi applications.
in padtad proceedings of the 8th workshop on parallel and distributed systems flanagan c. godefroid p. dynamic partial order reduction for modeling checking software.
in popl.
pp.
.
acm press new york ny usa gray i. audsley n. targeting complex embedded architectures by combining the multicore communications api mcapi with compiletime virtualisation.
in lctes.
acm chicago illinois usa huang y .
mercer e. mccarthy j. proving mcapi executions are correct using smt extended yhuang2 downloads paper.pdf kahlon v .
wang c. gupta a. monotonic partial order reduction an optimal symbolic partial order reduction technique.
in acm ca v .
pp.
.
springer berlin heidelberg grenoble france june july lahiri s. smt based modular analysis of sequential systems code.
in ca v .
springer verlag lahiri s. qadeer s. back to the future revisiting precise program verification using smt solvers.
in popl.
acm san francisco california usa mca the multicore association mca the multicore association resource management api mcapi.php morse e. vrvilo n. mercer e. mccarthy j. modeling asynchronous message passing for c program.
in verification model checking and abstract interpretation.
vol.
of lncs pp.
.
springerverlag de moura l. bj rner n. z3 an efficient smt solver.
in tacas.
vol.
pp.
.
springer heidelberg mpptest mpptest benchmark research projects mpi mpptest netzer r. brennan t. damodaran kamal s. debugging race conditions in message passing programs.
in acm sigmetrics symposium on parallel and distributed tools.
pp.
.
philadelphia pa usa sharma s. private conversation on active research.
sharma s. gopalakrishanan g. mercer e. holt j. mcc a runtime verification tool for mcapi user applications.
in fmcad siegel s.f.
verifying parallel programs with mpi spin.
in cappello f. h erault t. dongarra j. eds.
recent advances in parallel virtual machine and message passing interface 14th european pvm mpi user s group meeting paris france september october proceedings.
lecture notes in computer science vol.
pp.
.
springer siegel s.f.
gopalakrishnan g. formal analysis of message passing.
in jhala r. schmidt d. eds.
verification model checking and abstract interpretation 12th international conference vmcai austin tx january proceedings.
lecture notes in computer science vol.
pp.
siegel s.f.
zirkel t.k.
automatic formal verification of mpi based parallel programs.
in cascaval c. yew p.c.
eds.
proceedings of the 16th acm sigplan annual symposium on principles and practices of parallel programming ppopp .
pp.
.
acm siegel s.f.
zirkel t.k.
loop invariant symbolic execution for parallel program.
in kuncak v .
rybalchenko a. eds.
verification model checking and abstract interpretation 13th international conference vmcai .
lecture notes in computer science vol.
pp.
.
springer vakkalanka s. v o a. gopalakrishnan g. kirby r. reduced execution semantics of mpi from theory to pratice.
in fm.
pp.
v o a. vakkalanka s.s. gopalakrishnan g. isp tool update scalable mpi verification.
in m uller m.s.
resch m.m.
schulz a. nagel w.e.
eds.
parallel tools workshop.
pp.
.
springer wang c. chaudhuri s. gupta a. yang y .
symbolic pruning of concurrent program executions.
in esec fse.
pp.
.
acm new york ny usa zhang y .
evelyn d. barrier matching for programs with textually unaligned barriers.
in ppopp.
pp.
.
acm san jose california usa