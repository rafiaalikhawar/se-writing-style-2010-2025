seeds a software engineer s energy optimization decision support framework irene manotas computer science university of delaware newark de usa imanotas udel.edulori pollock computer science university of delaware newark de usa pollock udel.edujames clause computer science university of delaware newark de usa clause udel.edu abstract reducing the energy usage of software is becoming more important in many environments in particular batterypowered mobile devices embedded systems and data centers.
recent empirical studies indicate that software engineers can support the goal of reducing energy usage by making design and implementation decisions in ways that take into consideration how such decisions impact the energy usage of an application.
however the large number of possible choices and the lack of feedback and information available to software engineers necessitates some form of automated decision making support.
this paper describes the first known automated support for systematically optimizing the energy usage of applications by making code level changes.
it is e ective at reducing energy usage while freeing developers from needing to deal with the low level tedious tasks of applying changes and monitoring the resulting impacts to the energy usage of their application.
we present a general framework seeds as well as an instantiation of the framework that automatically optimizes java applications by selecting the most energye cient library implementations for java s collections api.
our empirical evaluation of the framework and instantiation show that it is possible to improve the energy usage of an application in a fully automated manner for a reasonable cost.
categories and subject descriptors d. .
restructuring reverse engineering and reengineering d. .
integrated environments general terms theory measurement keywords energy usage software optimization analysis framework permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction inherent in today s computing environments are concerns about battery life heat creation fan noise and overall potentially high energy costs.
research has shown that power consumption can be reduced through designing computer architectures that are more energy e cient e.g.
developing compiler optimizations targeting energy usage e.g.
improving operating systems to help manage energy usage e.g.
and designing hardware and batteries with power consumption in mind e.g.
.
we believe that similar to other optimization targets such as execution time or memory usage not all improvements can be achieved automatically by lower level systems and hardware.
unfortunately few software developers design and implement applications with consideration for their energy usage.
our recent interviews with 18professional software developers revealed that this is due to two primary reasons developers do not understand how the software engineering decisions they make a ect the energy consumption of their applications and lack the tool support to help them make decisions or change their code to improve its energy usage.
most existing research into helping software engineers reduce energy usage is empirically based and has the goal of understanding how di erent types of changes impact the overall energy usage of applications.
in particular there have been studies of how design patterns method inlining choosing web servers selecting among web browsers and using various implementations of an algorithm can each impact energy usage.
the results of these studies support our belief that software engineers can indeed help reduce energy consumption by considering the energy impacts of the decisions they make on a daily basis.
although the knowledge gained from empirical studies can increase our understanding of potential energy related bugs we believe that simply providing such knowledge is unlikely to be e ective at reducing energy usage in practice for several reasons.
first the many layers of abstraction in typical applications combined with subtle interactions between both hardware and software components suggests that it is di cult if not impossible for developers to predict how the changes they make will impact the energy consumption of their applications.
second the energy consumption of an application or software component can vary depending on where it is executed i.e.
hardware architecture or operating system .
a recent survey on android fragmentation showed that there are over 000possible combinations of hardwarepermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm and software that can run android applications .
in practice there are far fewer combinations that are commonly used but there are still too many to expect developers to maintain separate versions of their applications for each possibility.
finally it is unlikely that a single action will always result in the best outcome.
in many cases additional factors e.g.
the context of where a change will be made can a ect the impact of a change.
this means that developers need to have essentially perfect knowledge about their systems to be able to make a good decision.
this paper describes the software engineer s energy optimization decision support framework seeds a novel framework to help software engineers develop energy e cient applications without having to address the low level tedious work of applying changes and monitoring the resulting impacts to the energy usage of their application.
seeds provides automated analysis decision making and implementation of decisions towards optimizing a given targeted software engineering decision with regard to energy usage of the entire application.
seeds also takes into account the execution context i.e.
platform and expected inputs where the application will be deployed.
in this paper we present how seeds can be instantiated by describing how we used it to create the seeds apiimplementation selector seeds api a tool that optimizes java applications that use the java collections framework jcf .
seeds apiautomatically selects the most energy e cient implementations of the collections application programming interface api to use at each location where a collection object is allocated.
in short seeds apiautomatically generates application versions implementing many di erent alternative combinations of api implementation choices for all the object instantiation locations in the application performs power monitored executions for a given test suite on all the generated versions analyzes the collected energy usage data to identify the best combination of api implementation choices per object allocation location and generates an optimized version of the application based on api implementation decision making.
an evaluation comparing the energy usage of 7unmodified applications and the corresponding optimized versions created by seeds apireveals that the framework is able to e ectively improve the energy usage of applications without requiring the software engineer to provide more than the application api implementations and test suite.
the main contributions described in this paper are a fully automated framework seeds to support developers in the task of improving the energy usage of their applications for a given platform by making decisions about which source level changes to apply.
seeds api an instantiation of seeds to improve the energy usage of an application by selecting the most e cient implementations of the collection api.
an evaluation of the e ectiveness and cost of seeds through the use of seeds apion a set of open source projects.
a case of study of how seeds can be used to expand the current body of knowledge on designing and implementing energy e cient applications by enabling researchers to answer questions that they would otherwise not be able to answer.the remainder of this paper is organized as follows section describes seeds our framework for optimizing energy usage.
section presents seeds api our instantiation ofseeds .
section presents our empirical evaluation of seeds and seeds apiincluding our methodology data and analysis.
finally sections and discuss related work and present our conclusions and future work.
.
the seeds framework we designed seeds to support three primary goals automate the entire process of optimizing the application with respect to potential code changes to save developers from performing tedious error prone tasks.
abstract away the systems and hardware platform interactions from developer concern.
be general enough to support di erent types of decisions commonly made by software engineers including optimization goals filtering mechanisms search strategies energy profiling approaches and hardware platforms.
figure provides a high level overview of seeds .
in the remainder of this section we provide a detailed discussion of each of the framework s main components.
.
inputs as the figure shows seeds requires four inputs the application code as e to f potential changes the developer s chosen optimization parameters and additional context information .
theapplication code is the code of the application that the software engineer wants to optimize.
the set of potential changes includes all of the changes that the developer is deciding whether or not to make.
for example the set of potential changes could include decisions such as which library implementation to use whether to perform refactoring whether to replace an algorithm with a di erent algorithm whether to cache the result of a computation etc.
note that the transformations specified in the set of potential changes are abstract rather than concrete e.g.
inline a method vs. inline method fooin method barat line .
this allows sets of changes to be reused and frees developers from the task of recomputing them for each new application that they want to improve.
the method for transforming abstract potential changes into concrete changes for the given application is described in section .
.
theoptimization parameters are constraints on where seeds should consider making potential changes.
for example a developer could restrict the application of a refactoring to only a certain subset of the application or only allow switching algorithms if the algorithm s inputs are larger than a given threshold.
in addition the optimization parameters can also include guidance about how changes should be applied.
this allows software engineers to encode their domain specific knowledge and intuition into the framework.
for example the software engineer could provide a ranking of alternative library implementations for a given api based on their intuition about the performance of one implementation over another.
or they may be considering applying various refactorings based on recommendations from a tool or documentation that indicates that applying that refactoring improves code readability and maintainability.504applicationcodepotentialchangesoptimizationparameterscontextinformationoptimizedapplication codedefineapplication specific search spacesearchtransformapplicationprofile energyusageselectsolutionseeds optimization resultsfigure overview of seeds.
finally the context information indicates the platform where the application will be executed the expected inputs or workload that will be used to drive the application and other relevant data about the application needed by the optimization strategy.
the strategy used for energy profiling see section .
dictates the specific information that needs to be provided.
for example if energy profiling is to be done using a hardware based platform then the platform itself and a set of suitable concrete inputs are needed.
however if energy profiling is to be done using a dynamic analysis based estimation approach then execution traces and a model of the platform are required.
finally if a static estimation approach is used a developer may not have to provide any context information at all.
the ability to provide context information can be especially useful if a developer does not have easy access to a target system.
essentially they can cross optimize in the same spirit as cross compilation their application to a wide range of target platforms.
given these inputs the key tasks of seeds are then to define the application specific search space that is the space of concrete changes that seeds will consider and search through the application specific search space to find an optimized version of the application that reduces energy usage as much as possible.
each of these tasks is described in more detail in the following subsections.
.
creating application specific search space as we mentioned previously the changes in the set of potential changes are abstract rather than concrete.
seeds first task then is to determine the application specific search space by concretizing these abstract changes with respect to the given application and optimization parameters.
in essence the application specific search space is the set of all possible versions of the given application that could be created by seeds .
to calculate the application specific search space seeds considers each potential change and scans the application s code to identify the locations where the change could be applied.
for example if a potential change is to inline a method seeds will identify all of the locations in the application where a method is invoked.
this initial list of concrete changes is then filtered based on both explicit and implicit constraints.
explicit constraints are generally based on the type system of the programming language used to implement the application.
for example implementations of an api can only be swapped if both implementations exposethe same interface.
implicit constraints are most commonly provided by the optimization parameters.
.
search select transform profile depending on the given set of potential changes and number of locations in the application where those changes can be correctly applied the application specific search space could be very large.
manually exploring such a space would be a tedious error prone task for a software engineer and furthermore such a space may actually be too large to search exhaustively and would require some kind of sampling as in search based software engineering.
seeds search task is responsible for navigating the application specific search space to find versions of the application that consume less energy than the original version and ultimately choose the optimized version of the application that results in the greatest amount of energy savings.
at a high level the task of searching the applicationspecific search space is divided into three steps select a solution from the application specific search space i.e.
a concretized change or set of changes transform the original application by applying the chosen solution and profile the energy usage of the transformed version.
the search process begins by selecting a solution from the search space.
in practice essentially any selection strategy could be employed.
for example the selection strategy could be to select a solution in a random manner based on a heuristic using a genetic algorithm etc.
in section .
we describe the selection strategy implemented for an instantiation of the seeds framework.
one of the main benefits of defining seeds in this way is that software engineers can tailor the selection component to their specific applications and sets of potential changes.
essentially the selection component is a fifth input to the framework.
the second step of the search task is to transform the application by applying the chosen solution.
often such transformations will be done using support provided by an integrated development environment ide or other stand alone tools.
although seeds attempts to filter out invalid concrete changes when creating the application specific search space it is possible that unknown implicit constraints are broken by applying the changes.
for example the application may assume but not document that the iteration order of a collection must be fixed or that elements are returned in sorted order.
if concrete inputs or an explicit test suite is provided as part of the context information seeds can perform regression testing to address this possibility.
regression testing ensures that with respect to the provided inputs a modified version of an application is semantically505identical to its original version.
transformed application versions that fail regression testing are simply discarded and a new solution is chosen.
the third step of the search task is to profile the transformed version of the application to calculate its energy usage.
this could be achieved through existing techniques including hardware based approaches using physical instrumentation and monitoring e.g.
simulation based approaches that replicate the actions of a processor and estimate energy consumption of each executed cycle by using a cycle accurate simulator e.g.
or estimationbased approaches that model energy influencing features to estimate energy usage e.g.
.
after calculating the energy usage of the transformed version the search process begins again.
the selection step incorporates the new information about how the selected solution impacts energy usage and chooses a new solution.
the transform step applies the new solution and if possible checks whether it produces a valid application.
and the profile step calculates the energy consumption of the new transformed application version.
the search process iterates in this fashion until a stopping point is reached.
similar to how any selection strategy can be used any stopping criterion can be used.
the search could stop when the energy usage of the application has been reduced by a certain percentage or is less than a given threshold.
it could stop after a specified number of iterations or when energy usage does not improve for a given number of iterations.
the stopping criterion could also halt the search after a set amount of time or when the application specific search space has been completely explored.
.
output the output of seeds includes the optimized application code and the optimization results.
the optimized application code generally is an optimized version of the given application where the energy usage is reduced as much as possible with respect to the given set of potential changes optimization parameters and context information.
note that the optimized version is not guaranteed to be optimal with respect to all possible versions i.e.
there may be another version of the application that uses less energy when di erent given parameters .
when given a specific combination of inputs the application may not be improved in terms of energy usage if then seeds returns the original application version as output .
in our evaluation this situation occurred once.
although this is not our desired outcome knowing that an application can not be improved by seeds is useful information.
it indicates that the developer is free to make any of the considered changes without needing to consider how they would impact energy usage and also informs the developer that other di erent strategies may be tested in order to possibly reduce the energy usage of the application.
the optimization results presented to the developer include by how much the energy consumption of the application is decreased when comparing the optimized version versus the original application.
.
instantiating seeds to evaluate seeds it is necessary to create an instantiation.
as we mentioned in section there are many common decisions that software engineers make that could be the target of an instantiation of seeds .
we createdan implementation of seeds called seeds apithat supports software engineers as they make decisions about which library implementations they should use to optimize the overall energy usage of their applications.
more specifically seeds apioptimizes java applications by identifying implementations of the java collections api that are more energy e cient if any than the implementations currently used by the application.
we chose to target the choice of the collections api implementation for several reasons.
first choosing a collection implementation is a common decision that is faced by developers.
second in many cases developers are choosing api implementations based on familiarity or execution time concerns.
this means that applications are unlikely to have optimized their choice of collection implementation to energy usage.
finally the impact of collections api choice has not been investigated by researchers.
as such investigating their impacts supports our goal of using the framework to explore the energy optimization space and enable researchers to answer questions that they could not previously ask.
because we are the first to look at the choice of api implementations we conducted an initial feasibility study to determine whether the choice of api implementations does in fact impact the energy usage of an application before actually implementing seeds api.
the remainder of this section discusses our preliminary study and how we instantiated seeds to create seeds api.
.
preliminary study the goal of our preliminary study was to determine if changing implementations of the collections api can impact the energy usage of an application.
to answer this question we created 13versions of a publicly available micro benchmark.1at a high level this benchmark creates an instance of a class that implements the collection interface and then performs a large number of operations on the instance e.g.
adding single elements adding another collection of elements removing some elements removing all elements etc.
.
we chose to use this benchmark for two reasons.
first it has previously been used to evaluate the runtime performance of implementations of the collections api.
second it is a micro benchmark the majority of its execution is spent in the code of the collections implementations.
this allows us to focus directly on our area of interest i.e.
the collections implementations .
each of the 13versions of the benchmark we created uses a di erent concrete implementation of the collection interface.
the first column of table current choice shows the13concrete implementations of the collection interface that we considered.
we then executed each version of the benchmark 10times and profiled its energy usage.
see section .
for a detailed explanation of how we profile energy usage.
we then conducted pair wise statistical analysis of the versions energy usage using the kruskal wallis test.
essentially we determined given a current implementation choice whether switching to another implementation decreases increases or has no e ect on energy usage.
in table the second and fourth columns b e t t e r and w o r s e show given the current implementation in the first column the number of times switching to an another implementation improves energy usage .
and the number of times switching to another concrete implementation wors1 potential improvement or degradation in energy usage from switching collection implementations.
potential gain from switching potential loss from switching current choice better max improvement worse max degradation arraylist concurrentlinkedqueue linkedhashset hashset linkedlist treeset priorityqueue concurrentlinkeddeque copyonwritearraylist concurrentskiplistset linkedblockingdeque linkedtransferqueue copyonwritearrayset ens energy usage .
respectively.
for example if the currently selected implementation is arraylist there are two implementations that will decrease the benchmark s energy usage and no implementations that will increase the benchmark s energy usage.
as the table shows for 7of the13cases energy usage can be statistically improved by switching implementations and for 6of the 13cases energy usage can be statistically worsened.
these results show that indeed switching implementations of the collections api can in fact impact the energy usage of an application.
to gain some additional insight into the e ects of switching implementations we investigated the magnitude of the increases and decreases.
for the cases where there is a statistically better or worse alternative implementation we calculated the percentage di erence in the mean energy usage of the 10runs for the current version and the mean energy usage of the 10runs of the best alternative and the worst alternative.
note that for this benchmark hashset is the most energy e cient implementation and linkedblockingdeque is the most ine cient implementation.
in table the third column max improvement and the fifth column max degradation show the percentage change from switching from the current version to the best version and from the current version to the worst version respectively.
a dash indicates a case where there was not a statistically better or worse choice than the current implementation.
for example switching from arraylist tohashset results in nearly a improvement in energy usage while switching from linkedhashset tolinkedblockingdeque increases energy usage by over .
not only does switching implementations of the collections api statistically significantly impact energy usage but the magnitude of the impact can be quite large.
these empirical results quantify the potential impact of a framework such as seeds .
.
seeds api based on the results from our preliminary study on the impact of switching implementations of the collections api w e went forward with creating seeds api.
a high level overview ofseeds apiis shown in figure and the remainder of this subsection describes how each of the components of seeds was instantiated in seeds api.
components that are not specifically mentioned were implemented as described insection .
application code.
seeds apiis designed to optimize java applications.
therefore it accepts as input java applications that use the collections api.
potential changes.
the set of potential changes indicates which implementations of the collections api can be substituted for one another.
for example a potential change would be to substitute hashset for a treeset or vice versa orlinkedlist forarraylist .
note that seeds apican consider changes between any implementations that implement the same collections api.
currently the tool includes all implementations from the jcf as well as all implementations of collection from javolution 2fastutil 3apache commons collections 4goldman sachs collections 5and google s guava libraries.
we have also built an automated tool that automatically extracts potential changes from the set of libraries.
if developers would want to consider additional potential changes e.g.
implementations from another library they can simply provide the library s jar file to our tool.
context information.
to use seeds api developers must provide a test suite as part of the context information.
the test suite is used to perform regression testing to ensure that all considered transformations are valid and to execute the transformed applications during profiling.
define application specific search space .
we observed that in many cases developers do not program to the interface rather they specify a concrete type for their variables e.g.
arraylist l vs.list l .
unfortunately forseeds api this practice can unnecessarily constrain the size of the application specific search space and hinder the optimization process.
to address the problem seeds api generalizes the application s code by changing the type of each variable for which original type is a subclass of collection to the most general supertype.
for example the type of a variable that was declared as a linkedlist could be generalized to collection if only methods declared in the collections interface are used list if methods implementationalternativesoptimizationparameterstest suiteoptimizedapplicationseedsapidefineapplication specificsearch spaceapplicationgeneralizationidentify collectionsallocation locationsfilter based onoptimization parameterssearch transformapplicationprofile energyusage select implementation for location filter invalid transformationsoptimization resultsfigure overview of seeds api.
declared in list but not in collection are used e.g.
get or linkedlist if methods declared by linkedlist but notlist are used e.g.
addlast .
in practice seeds api uses the eclipse ide s refactoring tools to automatically apply the generalize type refactoring to every variable where the type is a subclass of collection .
after generalization seeds apianalyzes the application to identify the locations where instances of the collections api are created.
although this may seem like a trivial task in java object allocation is actually a two step process.
first a new instance of the desired type is created using the newbytecode.
then at some point later one of the type s constructors is invoked on the new object using theinvokespecial bytecode.
identifying both bytecodes is necessary to be able to transform the application because the type of the object created by the newmust be the same as the declaring type of the constructor that is invoked by theinvokespecial .
unfortunately there is no guarantee that the newandinvokespecial are easy to match.
in fact depending on the structure of the code there can be an arbitrary number of intervening instructions.
in order to identify pairs of newandinvokespecial bytecodes that constitute an object allocation seeds apiuses the t.j. watson libraries for analysis wala to implement a def use analysis that tracks backwards from the target object of the invokespecial to the newwhere it was created.
after identifying the locations in an application where collection objects are allocated seeds api determines how many potential changes could be applied at each location.
for example if an instance of the set interface is being created seeds apiidentifies all potential changes that switch implementation to an implementation of the set api.
the combination of all allocation locations and possible changes away from the generic type of the object being created constitues seeds api s application specific search space.
select solution.
because there has been no prior investigation into the impacts of switching implementations of the collections api on energy usage we have no intuition or information on the shape of the application specific search space or how to search through it e ectively.
for example we have no idea if there are likely to be many local minima if the e ects of multiple changes are likely to be additive or independent or even if the search space is di erentiable.
as aresult we implement one of the simplest search strategies possible an exhaustive exploration of all possible applications on a single concrete change.
our search strategy starts by identifying the most energy e cient implementation choice at each location in the program where an object that implements the collections api is created.
seeds apiidentifies the most e cient implementation choice at each location by applying each concrete change to the program running the resulting version multiple times comparing the means of the energy usages to find the change that results in the least amount of energy consumption.
note that we are considering each location separately.
after identifying the most e cient implementation at each object allocation location seeds apicreates one additional version where the most e cient change at each location is applied.
finally the selection strategy used by seeds api compares the energy impacts of all of the versions executed during the search process and then it selects as the output of the tool the version that results in the largest decrease in energy usage.
if none of the changed versions is a statistical improvement over the original unmodified application the original version is returned instead.
in this way seeds api is guaranteed to never produce an optimized version that performs worse than the original application.
although this strategy is simple it results in optimized applications that are more energy e cient than the original applications.
in our experiments seeds apiimproved the energy usage of 6of our 7subject applications by between and .
moreover as we explained before this search strategy is meant to be a starting point for future research rather than the best way of creating optimized applications.
transform application.
to apply the selected changes seeds apiuses objectweb s asm bytecode rewriting library7to change the types of newandinvokespecial bytecodes that correspond to the locations of the selected changes.
we chose to directly modify the application s bytecode rather than its source code so that seeds apidoes not have to recompile the application each time a change is applied.
after each time the application is transformed the test suite provided as input is used to ensure that the transfor7 subject applications.
application version loc tests coverage change sites barbecue .
jdepend .
.
.
apache xml security .
.
joda time .
.
commons lang .
.
commons beanutils .
.
.
commons cli .
.
mation has not broken the functionality of the application.
profile energy usage.
to profile the amount of energy consumed when executing an application we used a low power energy aware processing leap node .
our leap node is an x86 platform based on an intel atom motherboard d945gclf2 .
it is currently configured with 1g b of ddr2 ram a gb rpm sata disk drive wd3200 bekt and runs xubuntu .
.
each component in the leap system e.g.
cpu disk drives memory etc.
is connected to an analog to digital data acquisition daq card national instruments usb that samples the amount of power consumed by the component at a rate of10 khz samples per second .
the leap also provides running applications with the ability to trigger a synchronization signal.
this allows for synchronizing the recorded power samples with the portions of the execution that are of interest.
note that while the original leap specification calls for using the same computer to both run an application of interest and collect power samples we have modified the design to use dedicated hardware for each of these roles.
using separate machines prevents the introduction of any unwanted measurement overheads.
the only remaining source of unwanted overhead is the collection of synchronization information.
it is possible to account for this cost by profiling the energy cost of recording synchronization information and subtracting it from the reported energy numbers.
however because we are concerned with energy consumption relative to a base line i.e.
the original application and the energy cost of recording synchronization information is essentially constant we have not taken this step.
.
empirical evaluation our evaluation of seeds focuses on evaluating the e ectiveness of using an instantiation namely seeds api on real applications and examining the associated costs.
specifically we designed our evaluation to answer the following questions rq1 e ectiveness.
isseeds e ective at automatically optimizing an application with respect to potential code changes?
rq2 exploration capability.
canseeds be used to e ectively explore the search space of the energy impacts of a software engineer s decisions?
rq3 cost.
can seeds provide decision making support to the software engineer with regard to energy consumption implications at a reasonable cost?
.
experimental subjects the primary goal of seeds apiis to help software developers choose implementations of the collections api to reducethe amount of energy consumed by their java applications.
to suitably evaluate the tool with respect to this goal we selected 7java applications that use the collections api.w e also selected these programs because they have been used by many researchers and they are representative of applications that use the jcf.
in addition because seeds apirequires a test suite we needed to select applications that have an associated test suite.
table describes the seven applications.
in the table the first and second columns application andversion together identify the application version.
the third column loc provides the number of lines of code.
the fourth and fifth columns t e s t s andcoverage reports the number of tests in the associated test suite provided with each subject and the percentage of the statements in application that are covered by the test suite respectively.
the last column reports the number of possible sites in the application code for the program changes of interest based on the input parameters .
we obtained the subjects from the three di erent public repositories software artifact infrastructure repository sir 8which provides a variety of open source projects for empirical software engineering sourceforge 9a popular repository for open source projects and apache commons 10a collection of reusable components.
.
rq1 effectiveness in our preliminary study see section .
we observed that switching implementations of the collections api can improve the energy usage of an application.
the goal of our first research question is to determine whether we can achieve the same type of improvements in real applications in a fully automatic manner.
to answer this question we created 2optimized versions of each of our subjects using seeds api one where seeds api was allowed to use only collections implementations from the jcf and one where seeds apiwas allowed to use collections implementations from all of its included libraries.
for the cases where seeds apiwas able to optimize the applications i.e.
it returned a version di erent than the original we ran the original and optimized versions on the leap node times.
then we used the kruskal wallis test to determine whether there is a statistically significant di erence in the amount of energy usage consumed by the versions.
we chose to use the kruskal wallis test because we have one nominal variable whether or not the change is applied one measurement value the amount of energy consumed and we do not seeds apie ectiveness in improving energy usage.
improvement application jcf only all barbecue jdepend apache xml security joda time commons lang commons beanutils commons cli indicates situations where a single concrete change was most e ective.
indicates situations where a concrete change at more than one location was most e ective.
know whether our data are normally distributed.
for all of our tests we chose an alpha o f0.
.
for the cases where there was a significant di erence in energy consumption we computed the percentage change in the means of the energy usages of the original and optimized versions to determine how e ective seeds apiwas at improving the energy usage of the applications.
table shows the data we generated to investigate the e ectiveness of seeds api.
in the table the first column application shows the name of each subject.
the remaining columns show the percentage improvement in energy usage of the optimized version produced by seeds apiwhen using only implementations provided by the jcf jcf only and when using the implementation provided by jcf as well as the implementations provided by the other libraries included in the tool see section .
all.
note that a dash indicates that seeds apiwas unable to optimize the application.
a indicates that the optimized version was constructed using only one concrete change and a indicates that the optimized version was constructed by applying the best individual change at each location.
there are several interesting observations that we can make from this data.
first seeds apiwas e ective at automatically improving the energy usage of our subjects.
for all but one application it was able to decrease energy usage by a statistically significant amount.
moreover the magnitudes of the changes in energy usage are encouraging as they range from to17 and were accomplished using a simple search strategy that only considered changes applied in isolation.
second the optimized versions produced by seeds api include versions that contain only one change 7cases and versions where the most e cient change was made at each location 5cases .
before running this experiment we expected the most e cient version to be the version composed of the most e cient change at each location.
the fact that approximately of the time the most e cient version contains only a single change suggests that there are complicated interactions among the changes that are canceling out the expected benefits and that more advanced search strategies should attempt to understand and potentially exploit such interactions.
.
rq2 exploration capability we posed several questions to examine how well the framework could be used to explore the search space of the energy impacts of a software engineer s decisions to help the software engineer learn more about energy implications of their choices.
specifically we used the seeds apito explore the questions rq2a.
how does the e ectiveness of the energy optimization change with more choices?
rq2b.
how often do developers choose the most energye cient implementation without knowing the energy e ciency capability of the selection?
rq2c.
how often is each implementation the most energy e cient?
rq2a we can use our results to also answer the question how does the e ectiveness of the energy optimization change with more choices?
as table shows the e ectiveness of seeds apionly slightly increases when considering all possible implementations of the collections api rather than just the implementations from the jcf.f o r 4subjects adding the additional implementations had no impact on the performance of the seeds api.
for the remaining 3subjects energy usage was improved but the magnitude of the improvement was or less.
this was especially surprising as many of the additional implementations are specifically designed to be fast execute quickly and compact use less memory traits that are commonly thought to be strongly correlated with energy usage .
the fact that switching to such implementations does not drastically improve energy usage suggests that the correlation may not be as strong as was previously suspected.
rq2b to answer the question of how often developers choose the most energy e cient option without knowing the energy e ciency capability of the selection we used seeds apito determine how often the most e cient implementation choice is di erent than the implementation used in the original application.
in our subjects there are total locations where an instance of the collections api is allocated.
when only implementations from the jcf are considered of the time 69cases switching away from the original implementation resulted in a decrease in energy usage.
similarly when all possible implementations were considered of the time 89cases switching away from the original implementation improved energy usage.
these results motivate the need for seeds as they show that developers are only infrequently choosing the most energy e cient collections api implementations.
rq2c the final supplemental question we answered is how often each implementation of the collections api is the most energy e cient.
essentially we wanted to know if there is a single implementation that is always the most energy e cient.
when including all libraries seeds apichooses among 157distinct implementations of the collections api.
figure shows how often each implementation is the most e cient choice.
in the figure the x axis includes a tick mark for each implementation and is sorted by how often each implementation is the most e cient.
the y axis shows the percentage of times each implementation was most e cient.
in our experiments arraylist vector and hashset all from the jcf are the implementations that were most frequently the most e cient.
qxphudwhg collections ap implementationvselectionfrequencyfigure percentage of time each collection api implementation was selected as the most energy e cient.
as figure shows there is not a single implementation that is always the most energy e cient.
moreover it shows that there are 35implementations that were the most energy e cient at least one time.
this information further motivates the need for seeds .
it is unlikely that software engineers would be willing or able to manually investigate tens of possibilities to find the most e cient implementation.
this information is also potentially useful for future work in designing better search strategies.
while there were implementations that were the best at least once there were far more implementations that were never the most energy e cient.
this information could be used to help direct a search strategy.
.
rq3 cost the question can seeds provide decision making support to the software engineer with regard to energy consumption implications at a reasonable cost?
was addressed by recording the times to perform each step of the framework for each of the subject applications.
table presents the estimated costs in terms of wall clock time for optimizing applications.
in the table the first column application shows the name of each application.
the second column exe.
shows the amount of time necessary to execute each application using its test suite once.
the third column r e p s .
shows the number of times each changed version was run to gather enough data to compute the percentage di erence in the means of the energy usage of the original and changed versions.
the fourth column shows the cardinality of the search space i.e.
the number of changes explored by seeds api search .
the fifth column analysis shows the time to analyze the energy usage of the search space.
the sixth column shows the cost in hours cost when optimizing the applications considering only implementations from the jcf jcf only .
finally the seventh eighth and ninth columns show the search space and analysis andcost respectively when considering all implementations included inseeds api all .
as shown in the table the total cost ranges from 3hto64 hfor jcf only and from 4hto175 h hours for all.
by far the largest portion of the cost of using seeds apiis collecting and processing the power samples collected when running each changed version.
the other parts of the process i.e.
generalizing the application identifying collections allocation locations in the application filtering based on optimization parameters and applying the selected changes required only a few minutes in total.
although the overall costs are high we believe that they are reasonable for two primary reasons.
first optimizing the energy usage of an application is a task that will onlybe carried out infrequently most likely as part of the final release process.
in this context even a wait of a few days is likely acceptable as the tool is completely automated and could be run in parallel with other pre release tasks such as integration testing and other forms of quality assurance.
second the costs of using seeds apican easily be tailored to fit a software engineer s specific circumstances.
as table shows the overall cost of the technique is determined by4factors the amount of time it takes to execute the application s test suite the number of repetitions that are run the time to analyze energy usage data and the size of the application specific search space and how thoroughly the search strategy expores the search space all of which are easily controllable by software engineers.
reducing any of these factors will also decrease the cost of using the tool.
for example in our evaluation we used an exhaustive search strategy and ran the entire test suite.
instead we could have used a non exhaustive strategy and only executed part of test suite in order to reduce the cost of using seeds api.
.
threats to validity we evaluated seeds by creating one instantiation.
it is possible that other instantiations will not lead to improved energy usage of the user s application.
for instance there are many possible search strategies that may provide better energy usage and although our strategy is simple it does indeed show that seeds can result in optimized applications that are more energy e cient than the original applications.
in addition our study shows that the framework can provide useful information to help understand their energy usage.
we also demonstrate that useful instantiations can be created as choosing a collection implementation is a common decision that is faced by developers and our results show that indeed seeds can automatically make decisions and build optimized versions based on those decisions with regard to energy usage.
for our evaluation we selected 7java applications used their associated test suites and chose 6libraries as the source of our considered potential choices.
it is possible that conclusions drawn from this set may not generalize to all applications or other libraries or test suites.
to minimize the threat the applications we considered were selected because they have been used by many researchers and they are representative of applications using the jcf.
the test suites are provided by the applications and should thus test typical expected inputs and operations.
the libraries all comply with the jcf are publicly available and are commonly used.
we included libraries that were designed to be fast and compact as well as others designed with a focus on other nonfunctional attributes.511table cost to automatically optimize an application.
jcf only all application exe.
s reps. search analysis hrs cost hrs search analysis hrs cost hrs barbecue jdepend apache xml security joda time commons lang commons beanutils commons cli finally the energy profiling system used in this experiment could be considered a threat to validity.
in order to minimize the threat we used the leap monitoring system used by others which is able to measure the energy of several components e.g.
cpu and memory and the direct energy of discrete events in kernel and user space systems.
.
related work the most closely related work is the one presented in where the design of an autotuning energy model and runtime environment for distributed systems is described.
however the presented model is not evaluated and their implementation requires that developers have knowledge of the hardware components their interactions and the energy usage for each di erent target platform which is not required by seeds .
autotuning optimization is another related area of work.
in autotuning optimization the goal is to automatically improve the performance of applications.
in contrast to common compiler optimizations autotuning approaches often take into account details about the specific application being optimized and the environment where it will execute.
such approaches have been applied to specific types of software e.g.
computer algebra libraries and high performance computing as well as for general purpose languages and platforms e.g.
.
of the existing body of autotuning work chameleon is most similar to our work.
chameleon is a tool for automatically tuning the collection implementations used by an application .
the most significant di erence from our work is that chameleon is focused on runtime performance and memory usage rather than energy e ciency.
in addition chameleon is a dynamic technique that relies on collecting deep context based information about how specific collection instances are used during an execution.
in contrast our approach does not rely on such runtime monitoring as such monitoring is likely to impact the precision of our energy measurements.
unlike for performance tools the precision of power monitoring tools is insu cient for fine instructionlevel accounting.
second there is a group of work that has attempted to identify the underlying causes of energy consumption by empirically investigating the impact of various software development decisions.
more specifically researchers have investigated the impacts of refactorings design patterns sorting algorithms web servers programming models and lock free data structures within a single application in addition to investigating trends in an application s energy consumption among versions and among separate implementations of the same specification .insights gained from these and similar studies could be integrated into the search component of seeds to help it identify more energy e cient changes more quickly.
third there is a significant amount of work focused on accurately measuring energy consumption.
work in this area has been conducted at various levels.
hardware instrumentation based approaches e.g.
use physical instrumentation e.g.
soldering wires to power leads to measure the actual power usage of a system.
simulation based approaches e.g.
use a cycle accurate simulator to replicate the actions of a processor at the architecture level and estimate energy consumption of each executed cycle.
finally estimation based approaches e.g.
build models of energy influencing features and use such models to estimate energy usage.
finally researchers have begun to build on the accurate measurement work mentioned above to provide source codelevel feedback on energy consumption to developers .
although this work is promising it requires developers to be able to understand the information and manually make any necessary changes.
in contrast seeds automatically explores many options without developer involvement.
.
conclusions and future work seeds is the first known framework for helping software engineering make decisions with regard to energy usage of their application.
our empirical results show that using such automation can indeed improve energy usage of real applications without requiring the software engineer to deal with low level energy profiling tools and analyses.
instantiating seeds to make decisions about which library to choose showed up to energy usage improvement.
while the tedious work is hidden from the developer the collecting and processing of power samples can take many hours depending on the test suite execution time number of repetitions and the search space.
however optimizing the energy usage will likely be done infrequently and these costs can be tailored to the software engineer s specific circumstances.
we plan to investigate more advanced search strategies and other instantiations of seeds .
specifically we will investigate using seeds to make other kinds of software engineering decisions.
.