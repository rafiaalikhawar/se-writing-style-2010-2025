views object inspired concurrency control brian demsky university of california irvine bdemsky uci.edupatrick lam university of waterloo p.lam ece.uwaterloo.ca abstract we present views a new approach to controlling concurrency.
fine grained locking is often necessary to increase concurrency.
correctly implementing fine grained locking with today s concurrency primitives can be challenging race conditions often plague programs with sophisticated locking schemes.
views ease the task of implementing sophisticated locking schemes and provide static checks to automatically detect many data races.
views consist of view declarations that describe which views of an object may be simultaneously held by different threads which object fields may be accessed through a given view and which methods can be called through a given view.
a set of view annotations specify which code regions hold a view of an object.
our view compiler performs simple static checks which eliminate many data races.
we have ported three benchmark applications to use views portions of vuze a bittorrent client mailpuccino a graphical e mail client and tuplesoup a database.
our experience indicates that views are easy to use make implementing sophisticated locking schemes simple and can help eliminate concurrency bugs.
categories and subject descriptors d. .
language constructs and features concurrent programming structures d. .
concurrent programming parallel programming d. .
software program verification reliability general terms languages design reliability keywords concurrency language design static verification .
introduction with the wide scale deployment of multi core processors developers must write parallel software to realize the benefits of continued improvements in microprocessors.
using permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.existing concurrency primitives such as locks can be difficult and error prone since these primitives force developers to specify implementation not policy.
currently developers must manually and painstakingly state how locking is to be implemented in a software system not why locks exist.
this paper presents a new approach to concurrency control.
instead of providing low level concurrency primitives our approach raises the abstraction level of concurrency control to the level of object interfaces.
a view specifies both a partial object interface and a list of incompatible object views.
a partial object interface lists a subset of the object s methods and fields a thread must hold the given view to access the part of the object s interface protected by the view.
additionally the view mechanism provides concurrency control by enforcing incompatibility of views two views are incompatible if two different threads cannot simultaneously hold the two views on the same object.
views have two primary benefits.
first views enable developers to easily implement sophisticated concurrency control mechanisms which can maximize an application s concurrency.
views accomplish this goal by providing a simple language mechanism which allows developers to protect subsets of an object s fields and methods.
they also provide a uniform mechanism which supports advanced concurrency primitives such as read write locks.
second views can statically detect many data races.
our view compiler can analyze view specifications and objects uses of views to detect and warn about possible race conditions and unprotected field and method accesses.
.
contributions this paper makes the following contributions view concept it presents a new concurrency primitive that expresses concurrency control as acquisition of partial object interfaces or views.
views provide a simple natural abstraction that support a wide range of advanced locking approaches.
views make the connection between the concurrency primitive and the data it protects explicit.
automatic lock synthesis it presents an algorithm that uses standard locks to implement views.
our compiler uses a greedy algorithm to synthesize an optimized implementation of views using locks.
static checking it presents several static checks that automatically detect possible concurrency bugs.
these checks can detect view specifications that allow race conditions on data.
these checks can also detect field and method accesses in which the developer neglected to acquire the proper object view.
experience with views it presents our experience porting three significant benchmarks to use views.
this experience indicates that it is relatively simple to use views that views make supporting advanced locking straightforward and that views can help to statically detect potential concurrency bugs.
the remainder of the paper is structured as follows.
section presents an example to illustrate our approach.
section presents the view extensions to java.
section describes how we compile views.
section presents our experience using views with three existing applications.
section discusses related work.
finally section concludes.
.
example we present an example that illustrates the use of views.
figure presents a single threaded implementation of the vector class.
this vector class contains a set method to set elements of the vector a get method which returns the current value of an element and a resize method which resizes the vector .
we omit remove for space reasons its implementation would mirror that of resize .
views consist of two parts view declarations which identify the members of each view and view annotations to java source code which acquire views as needed throughout the implementation.
figure presents modifications to lines through of the existing vector code to support views.
figure presents view declarations for vector .
.
view annotations our system allows threads to acquire views in two ways a thread may explicitly acquire a view using the acquire statement and a thread may implicitly acquire a view by calling a preferred method.
the statement acquire this resize in figure causes the thread to acquire the resize view of the object referenced by this before executing lines and then to release this view in line .
note how acquire generalizes java s synchronized construct.
the relevant view declaration see below explains what the view protects.
when a thread makes a call to a preferred method such asget for theread view without already holding a view that provides access to that method the thread will automatically acquire the appropriate view and then execute the method.
a non preferred method is only callable by threads that already hold a view that contains the method.
.
view declarations figure declares five views read write xclread resize andcapacity .
each view except resize and xclread corresponds to a method of vector and states the fields and methods required to execute that method.
the views xclread andresize support the resize operation s two phases an exclusive read phase in which resize copies the vector s contents followed by the resize phase which atomically writes to the vector .
view declarations include a view s name and its body.
figure begins with the read view.
a view body first lists views that are incompatible with the current view.
for1public class vector 2intsize 3intcapacity 4object array 6publicvector 7size capacity 8array new object 11public object get inti 12if i size returnarray 13else return null 16public void set inti objecto 17if i capacity 18array o 19size i size ?
i size 23public void resize intnewcapacity 24object newarray new object 25for inti i newcapacity i size i 26newarray array 29array newarray capacity newcapacity 30size size newcapacity ?
size newcapacity 34public int capacity 35returncapacity figure sequential vector example.
28acquire this resize 29array newarray capacity newcapacity 30size size newcapacity ?
size newcapacity figure changes to vector to support views.
example line declares that the read view is incompatible with the write andresize views no thread may acquire an object s read view while any other thread holds thewrite orresize views of that object.
the view s body also contains the view s field and method declarations.
a field declaration begins with a commaseparated list of fields followed by an access description.
field access descriptions are one of none readonly or readwrite .
line declares that threads holding the read view of avector object may read its size capacity and array fields.
note that the readonly declaration ensures read only access to the field in the same sense as the java final modifier it does not prevent line of vector from writing to the vector s underlying array object but only prevents writes of the array field itself.
a method declaration gives the method s name and the types of its parameters optionally followed by the keyword preferred .
line declares that the read view contains the get method with an integer parameter as a preferred member.1viewread 2incompatible write resize 3size capacity array readonly 4get inti preferred 5capacity 8viewwrite 9incompatible read write resize xclread 10size readwrite 11capacity array readonly 12set inti objecto preferred 13capacity 16viewxclread 17incompatible write resize xclread 18size capacity array readonly 19capacity 20resize inti preferred 23viewresize 24incompatible read write resize capacity xclread 25size capacity array readwrite 28viewcapacity 29incompatible resize 30capacity readonly 31capacity preferred figure view declarations for vector example.
all classes contain a base view which is usually implicit.
thebase view contains methods and fields which may be accessed without acquiring any view.
an implicit base view contains all methods and fields not declared in other views.
however developers may also explicitly declare a base view in which case the compiler includes only fields and methods declared to belong to the base view.
the base view is important for supporting object inheritance see section .
.
.
checking views we have implemented an extension to the polyglot extensible compiler framework to support view annotations prevent incorrect accesses to view protected object interfaces and generate executable code from the view annotated sources.
the compilation process proceeds in three steps.
first the compiler verifies that a program properly uses view declarations as described below.
next it uses the view declarations to synthesize a lock allocation the acquisition of each view corresponds to the acquisition of a set of locks.
finally it uses the lock allocation to generate code.
we next describe how our view compiler works on our vector example on a method by method basis.
the compiler grants constructors full access to objects.
we expect developers to follow the standard practice of not exposing the object being constructed in the constructor.
the compiler next verifies that the get andset methods respect the view declaration.
the compiler observes that the get method accesses the size andarray fields of the this object.
both of the fields have readonly access in the read view.
because the get method be read write resize xclread capacity figure incompatibility graph gforvector .
longs only to the read view this must have the read view insideget so the compiler accepts these reads of size andarray .
the fact that get is a preferred method is irrelevant to checking the implementation of get it only affects callers to get which will automatically acquire theread view if they do not already possess it.
the verification ofset proceeds similarly.
however the compiler also checks that the write view possesses write permissions for thesize field.
recall that set does not require write permissions to array because it is not assigning to the array field itself only to the array object.
additionally becauseset calls thecapacity method the compiler checks that the write view contains the capacity method.
all checks succeed in our example.
we finally discuss how the compiler verifies the resize method.
note that we chose not to add the resize method to theresize view.
because resize belongs to the xclread view the compiler permits the read of field array on line .
the method then explicitly acquires the resize view on line of the modified version of vector granting it permission to write to the array capacity andsize fields.
no other thread may execute any method of vector in parallel with the resize view a thread attempting to access the vector must wait until the resize completes.
.
code generation to generate code the compiler must be able to reason about relationships between views since these relationships determine the set of locks that it must create.
it therefore starts by generating a view incompatibility graph.
figure presents the incompatibility graph gfor our running example.
graph vertices represent views while edges between two views indicate that they are incompatible.
the edge in gbetween the read vertex and the write vertex implies incompatibility of the read andwrite views.
given an incompatibility graph the lock synthesis algorithm allocates locks by finding a clique covering of the graph we will associate a lock with each clique.
to acquire a view a thread must acquire locks for all cliques that the view belongs to.
the compiler uses read write locks2 when a clique has exactly one view vwhich is compatible 1the compiler correctly displays an error message if resize does not belong to any view granting access to array as in an earlier version of this paper.
2a read write lock can be held by any number of threads in read mode but by only one thread in write mode.with itself.
such a situation indicates that vallows concurrent access to the resource being protected corresponding to the read mode of the read write lock while any views v in the same clique require exclusive access to the resource write mode .
if no views in a clique are compatible with themselves the compiler uses an ordinary exclusive lock.
in our example the three cliques c1 read write resize c2 write resize xclread andc3 capacity resize cover the graph g. the compiler therefore generates three locks l1 l2 and l3 one per clique.
cliques c1andc3contain exactly one view which is compatible with itself so the compiler uses read write locks for them.
a thread may acquire the capacity view by acquiring l3in read mode since capacity is compatible with itself similarly it may acquire read by acquiring l1 in read mode.
a thread may acquire write by acquiring l1 in write mode since write is incompatible with itself as well as the ordinary lock l2.
to acquire the resize view a thread must acquire write locks on both l1andl3 plus l2.
the compiler generates code by applying the lock allocation to the view acquisition statements.
intuitively the compiler will translate a statement like acquire this resize into a virtual call to a method onthis which acquires the resize view by requesting the proper locks as per the lock allocation the virtual call ensures that the thread gets the appropriate locks for the runtime type of this in the presence of inheritance.
to handle preferred methods the compiler generates a wrapper for the method which requests the view and delegates to the original implementation.
in our example the compiler renames the preferred method get to get view and generates a new wrapper get which will hold the read view for the duration of the call to get view .
should a caller to get already hold the read view the compiler simply generates a call to the original method get view instead of calling the wrapper.
.
view language extensions figure presents the grammar for view declarations while figure presents the syntax extensions to java for view annotations.
as seen in section view declarations contain a list of incompatible views followed by a list of view members which may be fields or methods.
field members have associated access descriptions none readonly orreadwrite .
developers must unambiguously identify methods which belong to a view and may optionally specify that a method is preferred for a view.
we support two kinds of view annotations in java code types may be decorated with views i.e.vector get and our new acquire statement generalizes java s synchronized statement.
.
compiling views we next describe in detail how we type check views check consistent use of views and automatically generate a locking strategy that enforces view incompatibility constraints.
.
view types we have extended the java type system to support viewviewdecl viewname incompdecl fieldmethoddecls incompdecl incompatible fieldlist fieldlist fieldlist field field fieldmethoddecls fieldmethoddecls fieldmethoddecl fieldmethoddecl fieldmethoddecl fielddecl methoddecl fielddecl fieldlist accessdesc accessdesc none readonly readwrite methoddecl name formallist optpreferred optpreferred preferred figure view declaration.
viewtype typename viewname formal .
.
.
viewtype varname vardecl .
.
.
viewtype varname statement .
.
.
acquire varname viewname block figure view annotations.
types for method parameters and local variable declarations.
a view type consists of a pair of a reference type and view.
for example the view type vector write indicates a reference to a vector object for which the executing thread holds the write view.
the type checker does not allow a local variable or a method parameter with a non base view type to be re assigned to reference a different object.
the view type of the this variable of a virtual method m is equal to the set of views that contain the method m. the type checker must ensure that fields and methods accessed through the this variable are permitted by all views that declare the method.
both the left and right hand sides of assignments to local variables or method formal parameters with view types must have the exact same view type.
new views of an object can only be acquired through an explicit acquire or through an implicit acquisition via a call to a preferred method of a view.
a method may not have a view type as its return type nor may fields or arrays have view types.
collectively these constraints ensure that threads cannot hold a view reference to an object after the release of a view acquired through an acquire statement or a preferred method.
.
static checks compilation begins with several static checks on the view specifications field accesses and method calls.
our compiler performs the following checks on the view declarations read write hazards on fields for each pair of compatible views v1 v2 and each field f the compiler flags the field fifv1has write access to the field fandv2has read or write access to f. if a view is compatible with itself this check flags all fields thatare declared readwrite.
uncontrolled access to flagged fields may lead to race conditions.
however we anticipate that developers may choose to use external locks or other mechanisms to protect such fields.
the compiler therefore only produces warning messages for the read write hazards that it detects.
field read checks for each field read x.f the compiler checks that all possible views of the receiver expression xallow reads of field f. field write checks for each field write x.f y the compiler checks that all possible views of the receiver expression xallow writes of field f. method call checks for each method call site x.m a ... a n to method m f1 ... f n the compiler checks that each argument aiat the call site matches the view type of the corresponding method formal parameter fi iffihas a view type.
the compiler also checks that the view of the reference to the receiver object xcontainsmor thatmhas a preferred view.
assignments the compiler checks that the program does not make assignments to local variables or method formal parameters with view types other than at their initial declarations.
field inheritance check the compiler ensures that an object s fields cannot be accessed through upcasts in violation of view constraints.
to ensure field access safety the compiler checks that if a field fis declared in a super class of cand is a member of a view vin the super class then field fmust be a member of viewvin class c with at least as permissive access.
method inheritance check the compiler must ensure that methods cannot be accessed through upcasts in violation of view constraints.
to ensure method invocation safety the compiler checks that if a method mis declared in a super class of cand is a member of a view vin the super class then method m must also be a member of view vin class c with at least as permissive access.
we make an exception to this check when vis the base view if mhas a preferred view in class c. note that if a method mis declared in an interface that class cimplements the method mmust either be in the base view of class cor have a preferred view in class c. it is possible that a call to method o.m may occur such that the declared type of owould require acquiring a preferred view to call m but the run time type ofoindicates that the executing thread must already hold the appropriate view.
in this case a dynamic check would avoid needlessly acquiring the preferred view.
.
lock synthesis we next describe how we synthesize a locking strategy that enforces the view incompatibility specification.
for each class the lock synthesis algorithm begins by constructing an undirected view incompatibility graph g. the graphgcontains a vertex vfor each view in c. for each pair of views viandvj ifvilistsvjas incompatible or vilistsvj as incompatible gcontains an edge between viandvj.
consider a subgraph gcofgthat is a clique that is gccontains edges between every pair of vertices in gc.
one lock can enforce all of the view incompatibility constraints between views in gc.
because views can be incompatible with themselves self edges may occur in the view incompatibility graph.
we handle self edges by using different kinds of locks.
if all views but one in the clique have self edges we use an implementation of a reentrant readwrite lock for the clique we identify the read mode of the read write lock with the view with no self edges and the write mode with all other views in the clique.
this corresponds to the situation where any number of threads may hold view vwith no self edges but only one thread may hold a view v with self edges or any of the views v that are incompatible with v .
if all views in the clique contain self edges then we use the normal reentrant lock class from java.util.concurrent.locks .
if more than one view in the same clique lacks a self edge which we expect to be rare in practice views without self edges typically only read data so two views without self edges should typically not conflict with each other we would use a generalized implementation of a read write lock which would permit multiple mutually incompatible read locks and a single write lock.
the lock synthesis algorithm computes a clique cover of g. minimizing the number of cliques in the cover minimizes the number of locks we must generate and the number of locks that must be acquired in a view.
however finding a minimum clique covering for a graph is an np complete problem .
we therefore use a greedy algorithm to compute a non minimal clique covering in polynomial time.
our greedy algorithm selects an uncovered edge to cover to start the clique and adds vertices that will cover other uncovered edges.
we expect that in practice many view incompatibility specifications will be simple enough that our greedy algorithm will generate a minimal covering.
.
acquiring views we next describe how the compiled application acquires and releases views at runtime.
for each view the compiler generates three view acquisition methods thetryacquireview method tries to acquire the view theacquireview method acquires the view and the releaseview method releases the view.
to acquire view v a thread must acquire all of the locks forv.
ifvhas a self edge in the incompatibility graph the thread must acquire all readwrite locks in write mode and lock the normal reentrant locks.
if vdoes not have a self edge the thread must acquire all locks which will be readwrite locks in read mode.
the tryacquireview method tries to acquire each lock.
if it successfully acquires all locks it returns true.
if it fails to acquire any of the locks it releases the locks it has already acquired and returns false .
theacquireview method must block until it can acquire a view.
to avoid the potential for internal deadlocks the thread cannot hold any of the component locks while blocking.
figure presents an example of an acquire method that our compiler generates for ncomponent locks.
conceptually the acquireview method arranges the locks in a circular list.
it locks the first component lock in the list 1public void acquireview 2intstartindex 3while true block on the first lock 5switch startindex 6case0 lock0.lock break ... 10casen lock n .lock break try to acquire the rest of the locks 15inti 16loop 17for i i n i if startindex n startindex switch startindex case0 if !lock0.trylock breakloop break ... casen if !lock n .trylock breakloop break return if we hold all locks 33if i n return release locks if we failed to get one 36intunlockindex startindex 37for i i if unlockindex unlockindex n switch unlockindex case0 lock0.unlock break ... casen lock n .unlock break repeat trying to first blocking acquire the lock that we failed to get this time.
figure locking code to acquire a view.
waiting until this lock becomes available.
it then tries to lock the remaining component locks without blocking.
if it fails to acquire any of these locks it releases all of the locks and then repeats the process starting with the lock it failed on.
once it acquires all of the locks it has acquired the view and returns to the caller.
of course our compiler generates optimized methods for the single lock case.
releasing views is straightforward the releaseview methods simply releases all locks corresponding to a view.
.
simultaneously acquiring multiple views our language supports simultaneously acquiring multi ple views.
we expect that developers will find this mechanism useful for locking multiple shared data structures while avoiding the possibility of deadlock.
the generated code for acquiring multiple views would use the same basic strategy as the code in figure does on component locks but instead uses this strategy on views.
.
defaults we have carefully designed the defaults for views to minimize instrumentation overhead.
our compiler automatically generates the base view if the developer does not explicitly declare a base view according to the following rules .
a field is present in the base view with readwrite access if no other view declares that field.
.
a method is present in the base view if no other view declares that method.
object constructors often write to many object fields that would be protected by views and call methods that require access to views.
if treated like other methods object constructors would have to acquire a number of views to access these fields.
however it is relatively rare for object constructors to make the object being constructed accessible to other threads before the constructor exits.
our implementation therefore allows the constructor to access fields and methods of the object being constructed without holding the necessary views.
we believe that this is a reasonable tradeoff between usability and detecting possible races.
.
experience we next discuss our experience adding views to several applications vuze a file sharing bittorrent client mailpuccino a graphical e mail client and tuplesoup a database.
.
methodology we have developed a prototype implementation of views as an extension to the polyglot extensible compiler infrastructure .
the source code for our extension is available at .
.
vuze buddy plugin our first benchmark is a subsystem of the open source vuze file sharing client.
the source distribution of vuze is available at .
while vuze contains lines of code in all we chose to concentrate on the buddy plugin of vuze which consists of lines of code.
this plugin is implemented in the com.aelitis.azureus.plugins.net.buddy package.
parts of the buddy plugin contain a rich locking structure.
after inspecting the code we chose to annotate the buddyplugintracker andbuddyplugin classes.
the other classes in the plugin use locking solely to protect data structure accesses before an access to a non thread safe data structure typically a maporlist vuze acquires the lock on that data structure.
views interoperate smoothly with ordinary java synchronized statements implementing such simple locking strategies.1viewread state 2incompatible write state 3current publish latest publish buddies 4buddies map config dirty 5republish delay event last publish start 6unauth bloom ygm unauth bloom 7bogus ygm written write bogus ygm readonly 10viewwrite state 11incompatible read state write state 12current publish latest publish buddies 13buddies map republish delay event 14last publish start unauth bloom 15ygm unauth bloom config dirty 16bogus ygm written write bogus ygm readwrite 19viewpd queue 20incompatible pd queue 21pd queue readwrite 24viewpublish write contacts 25incompatible publish write contacts 26publish write contacts readwrite figure views for buddyplugin class.
buddyplugin annotations.
we added views to buddyplugin general read and write views read state andwrite state for mutable fields previously protected by the lock on the buddyplugin object itself i.e.
synchronized this as well as views to protect the pd queue andpublish write contacts data structures.
our compiler found a few field reads that were inconsistently unprotected in the original code.
our change preserves the existing lock structure and also provides static guarantees that the program doesn t attempt to access protected state without the protecting lock.
buddyplugintracker annotations.
we found that the tracker.buddyplugintracker class contained the most interesting locking structure in the buddy plugin.
this class contains different locks online buddies actively tracking tracked downloads buddy peers and on the this object.
we carefully studied the fields that the class accessed under each lock and encoded this information in our view declarations.
figure presents the view declarations for the tracker.buddyplugintracker class.
we converted the locks into views splitting accesses to this into readonly and read write views read internal state and write internal state respectively and changing the other locks into views.
theactively tracking view protects accesses to the actively tracking set .
its access pattern is similar to that of the other data structures in the buddy plugin.
theonline buddies view protects two correlated data structures the online buddies set and the online buddy ips map .
our view annotations therefore express the formerly implicit connection between the online buddies lock and the online buddy ips data structure and statically ensure that the program always fol 1viewactively tracking 2incompatible actively tracking 3actively tracking readwrite 6viewonline buddies 7incompatible online buddies 8online buddies online buddy ips 9readwrite 12viewtracked downloads 13incompatible tracked downloads 14tracked downloads last processed download set id 15last processed download set download set id 16full id map short id map readwrite 19viewread internal state 20incompatible write internal state buddy peers 21online enabled old plugin enabled 22plugin enabled old tracker enabled 23tracker enabled old seeding only seeding only 24consecutive fails last fail network status 25buddy send speed buddy receive speed readonly 28viewwrite internal state 29incompatible read internal state 30write internal state buddy peers 31online enabled old plugin enabled 32plugin enabled old tracker enabled 33tracker enabled old seeding only seeding only 34consecutive fails last fail readwrite 37viewbuddy peers 38incompatible read internal state buddy peers 39write internal state 40seeding only readonly 41buddy peers buddy stats timer network status 42buddy send speed buddy receive speed 43readwrite figure views for buddyplugintracker class.
lows the proper locking discipline.
thetracked downloads field protects six related fields including two sets and two maps.
in the original version of the buddyplugintracker the application always acquired the tracked downloads lock before accessing any of these fields.
finally the three views read internal state write internal state andbuddy peers all protect miscellaneous internal state of the buddyplugintracker .
both the write internal state andbuddy peers views provide write access to different parts of the tracker.
theread internal state view is not incompatible with itself so multiple threads may simultaneously read internal state.
each of the write views is incompatible with itself and with the read internal state view.
we found that views enable developers to confidently use fine grained concurrency patterns.
using the view declarations our compiler statically verifies that the code always acquires the appropriate locks.1viewlookup 2incompatible modify 3keyvalues readonly 4getasbytearray objectkey preferred 5get objectkey preferred 6flush preferred 7getkeys preferred 8close preferred 11viewmodify 12incompatible modify lookup 13keyvalues readwrite 14put objectkey objectvalue preferred 15remove objectkey preferred 16keeponlythese vector keys preferred 17compact preferred 18getasbytearray objectkey 21viewfile 22incompatible file 23data readwrite 24datafile readonly 27viewindexfile 28incompatible indexfile 29indexfile readonly figure mailpuccino cache views .
mailpuccino mailpuccino is an open source graphical mail client written in java that supports the pop3 and imap protocols.
mailpuccino is available at org mailpuccino .
it contains over lines of code.
mailpuccino maintains separate cache data structures for the message headers message flags message parts and the message structure.
the locking for the original cache objects used synchronized methods.
the original coarse grained locking structure only allowed one thread to read from the message cache at a time.
figure presents the views that we wrote for mailpuccino scache object.
we created four views in all belonging to two sets of two views each.
the first set of views includes the lookup view and modify view for the mailpuccino cache.
the lookup view provides read only access enabling methods to safely read the cache while the modify view provides read write access allowing methods to safely modify the cache.
multiple threads may simultaneously read from cache objects so the lookup view is compatible with itself.
however while any thread is modifying the cache object no other threads can safely access that cache object at the same time.
therefore themodify view is incompatible with both itself and thelookup view.
note that our use of views enables the cache object to potentially support multiple simultaneous lookup operations.
the second set of views includes the file and indexfile views.
each cache is backed by two files the datafile file and its index indexfile .
cache misses are served from these files.
while the lookup view conceptually protects these accesses and prevents simultaneous writes java s randomaccessfile object does not supportatomic reads from a specific file offset so mailpuccino performs a seek followed by a read.
we must therefore ensure that no other thread accesses the file object between the seek and the read operations.
to do so we created two more views to protect the file objects.
only threads which have acquired these self incompatible views may access the fields that reference the corresponding files.
this ensures that only one thread may seek and read from a file at a time.
while we have described our changes to cache we also modified the msgpartscache class in a similar fashion.
we next modified the synchronized methods in the monitoredinputstream class to use views.
this class contained two synchronized methods the mark method and thereset method.
the synchronized annotations led us to believe at first that the class was designed to be safely shared between threads.
the mark andreset methods access only two fields markedbytesread andbytesread .
we wrote a view that allowed access to these fields and added the mark andreset methods to the view.
at this point we believed that we had distilled monitorinputstream s old synchronization pattern into views.
we therefore attempted to compile the modified class.
surprisingly the compiler threw error messages warning thatmonitorinputstream sread method accesses thebyteread field without holding an appropriate view.
however the read method contained no synchronization!
closer examination revealed that the monitoredinputstream class is not thread safe and itsmark andreset methods are never called.
we modified the class to remove these methods and added comments to make it clear that the class is not thread safe.
.
tuplesoup tuplesoup is an open source database library written in java.
tuplesoup is available at net projects tuplesoup .
tuplesoup contains over lines of code.
we rewrote all of the synchronization in tuplesoup to use views.
tuplesoup contains three index classes a memoryindex class apageindex class and a flatindex class.
the original index classes only permitted one thread to search the index at a time.
we created two views per index class anaccess view and a modifying view.
multiple threads can simultaneously hold the access view.
if one thread holds themodifying view of an index no other thread can hold themodifying oraccess views of the index.
thedualfiletable class implements a cached table backed by two separate files.
the original version of dualfiletable contained four separate locks one lock for each of the two data files a lock for the cache and a lock for the statistics counters.
we first examined the code to see if we could modify the class to allow multiple simultaneous calls to the getcacheentry cache lookup method.
unfortunately this method actually mutates a list of leastrecently used cache entries that is used to determine which entries to evict.
therefore it is not safe to allow multiple threads to simultaneously call the getcacheentry method.
we finally used a straightforward translation to views shown in figure which replaces each lock with a corresponding view and synchronized methods with preferred views for methods.
such a translation is quite straightforward to carry out and enables developers to explicitly ex 1viewfilea 2incompatible filea 3fileastream filearandom 4fca fileaposition readwrite 5updaterowa row row preferred 6addrowa row row preferred 8viewfileb 9incompatible fileb 10filebstream filebrandom fcb filebposition 11readwrite 12updaterowb row row preferred 13addrowb row row preferred 16viewindexcache 17incompatible indexcache 18indexcache indexcacheusage indexcachefirst 19indexcachelast readwrite 20addcacheentry tableindexentry entry preferred 21updatecacheentry tableindexentry entry 22preferred 23removecacheentry string id preferred 24getcacheentry string id preferred 27viewstat 28incompatible stat 29stat add stat update stat delete 30stat add size stat update size 31state read stat read size 32stat cache hit stat cache miss 33stat cache drop readwrite 34readstatistics figure tuplesoup dualfiletable views press the correlations between fields that the locking structure implicitly encoded.
in other words the views explicitly label the data that each lock protects and our view compiler provides static assurances that the code never accesses protected fields without holding an appropriate view.
.
discussion we used the following process for annotating an existing class with views.
first we studied an existing class s locking structure.
next we proposed a view structure which would protect a related group of fields and methods typically with a read only view for accessing state and a read write view for updating state.
we fed this view structure to our compiler which guaranteed that accesses to protected fields and methods only occur when holding appropriate views.
we found that it was straightforward to replace the traditional java locking structure with view acquisitions it sufficed to replace synchronized x withacquire x v and synchronized methods with preferred view methods.
each benchmark took a couple of hours to annotate the crux was in understanding the existing locking structures.
our process typically results in an application with increased potential for concurrency.
many of our annotated benchmarks allow multiple threads to simultaneously read state while ensuring that only one thread can write state.
.
related work we discuss three threads of work related to expressing java concurrency patterns type systems which ensure the absence of races static and dynamic race detection tools and automatic generation of locking schemes.
many teams have developed different type systems which ensure that well typed programs are free of data races.
boyapati lee and rinard have developed type systems which ensure the absence of data races by tracking object ownership .
abadi flanagan and freund have developed racefreejava where developers associate a lock with each shared field and express this information via the type system the compiler infers additional type annotations and verifies that programs conform to the specified type based discipline.
bacon strom and tarafdar propose the guava race free dialect of java which forces all members of shared objects to synchronized.
views generalize racefreejava by allowing developers to specify the locking policy for a set of related fields and methods not just for one field at a time as in the racefreejava case.
that is views allow developers to explicitly express in one place the state and methods protected by each lock.
moreover unlike previous approaches views are not limited to using simple java locks to guarantee race freedom they can leverage readwrite locks and other more sophisticated approaches to concurrency control.
views provide developers with a flexible mechanism that can be used to implement sophisticated approaches to concurrency control.
an alternate approach to statically ensuring that programs are free of races is to detect these races either statically or dynamically.
the eraser dynamic race detection tool computes lock sets for memory locations and warns if a memory location is not protected by a lock .
choi et al.
have developed a runtime approach that records access events and uses several optimizations to minimize overheads .
marino et al s literace tool uses sampling to minimize overheads .
other dynamic approaches use static analysis to lower the instrumentation overhead .
while dynamic race detection is useful it requires adequate test suites to detect bugs.
racerx instead uses interprocedural static analysis to detect race conditions and deadlocks .
other static analysis include warlock and sema .
race detection tools are in general useful for detecting bugs in programs.
however they provide developers with little guidance about which fields need to be protected by locks.
any solution requires developers to formulate a suitable concurrency control policy for their system.
views enable developers to express concurrency control policies the compiler then automatically computes a mechanism for implementing the policy.
views therefore differ from race detection and race free type systems approaches because those approaches only verify that implemented solutions are free of races.
another technique related to ours is that of automatically generating locking schemes for critical regions .
typically such approaches allow developers to specify critical or atomic sections of their programs.
zhang et al.
state a minimal lock assignment problem that is similar to the problem of lock synthesis for views but differs in that it contains information about non conflicting critical sections that are never executed concurrently and therefore can share locks without limiting concurrency .
this body of work must rely on static analysis to generate locks and therefore maygenerate overly conservative locking schemes.
furthermore this work does not attempt to detect possible data races arising from accessing shared state outside of critical regions.
views instead start with a data centric approach developers declare certain fields and methods as belonging to a view and specify when threads acquire views the compiler then ensures that the program always acquires appropriate views and synthesizes a locking strategy which respects the view annotations.
.
conclusion views can be an effective tool for implementing sophisticated concurrency control and statically detecting possible concurrency bugs.
a developer using views writes a set of view declarations and annotates code with view acquisitions.
a view declaration describes which views of an object may be simultaneously held by different threads and the parts of the object interface that the view controls.
the partial object interface specifies which fields can be read which fields can be written and which methods can be called through the view.
our compiler performs static checks of the view specifications and the program s use of views to detect many concurrency bugs.
our compiler automatically synthesizes a locking scheme that enforces the view compatibility constraints.
our experience indicates that views are simple to program with support sophisticated fine grained access control and can detect concurrency bugs.
our approach promises to ease the difficult task of implementing locking schemes for fine grained concurrency.