automatically synthesizing sql queries from input output examples sai zhang yuyin sun computer science engineering university of washington usa fszhang sunyuying cs.washington.edu abstract many computer end users such as research scientists and business analysts need to frequently query a database yet lack enough programming knowledge to write a correct sql query.
to alleviate this problem we present a programming by example technique and its tool implementation called sqlsynthesizer to help end users automate such query tasks.
sqlsynthesizer takes from users an example input and output of how the database should be queried and then synthesizes a sql query that reproduces the example output from the example input.
if the synthesized sql query is applied to another potentially larger database with a similar schema the synthesized sql query produces a corresponding result that is similar to the example output.
we evaluated sqlsynthesizer on exercises from a classic database textbook and forum questions about writing sql queries.
sqlsynthesizer synthesized correct answers for textbook exercises and all forum questions and it did so from relatively small examples.
i. i ntroduction the big data revolution has resulted in digitization of massive amounts of data.
there is a growing population of non expert database end users who need to perform analysis on their databases but have limited programming knowledge.
although relational database management systems rdbms and the de facto standard query language sql are perfectly adequate for most end users needs the costs associated with use of database and sql are non trivial .
the problem is exacerbated by the fact that end users have diverse backgrounds and include business analysts commodity traders finance professionals and marketing managers.
they are not professional programmers.
they need to retrieve information from their databases and use the information to support their business decisions.
although most end users can clearly describe what the task is they are often stuck with the process ofhow to write a correct database query i.e.
a sql query .
thus non expert end users often need to seek information from online help forums or sql experts.
this process can be laborious and frustrating.
non expert end users need a tool that can be used to describe their needs and connect their intentions to executable sql queries.
existing solutions.
graphical user interfaces guis and programming languages are two state of the art approaches to help end users perform database queries.
however both approaches have limitations.
many rdbmses come with a well designed gui with lots of features.
however a gui is often fixed and does not permitusers to personalize a database s functionality for their query tasks.
on the other hand as a gui supports more and more customization features users may struggle to discover those features which can significantly degrade its usability.
programming languages such as sql and other domainspecific query languages e.g.
java with jdbc are a fully expressive medium for communicating a user s intention to a database.
however general programming languages have never been easy for end users who are not professional programmers.
learning a practical programming language even a simplified domain specific language such as mdx often requires a substantial amount of time and energy that a typical end user would not prefer to invest.
our solution synthesizing sql queries from input output examples.
this paper presents a technique and its tool implementation called sqlsynthesizer to automatically synthesize sql queries1from input output examples.
although inputoutput examples may lead to underspecification writing them as opposed to writing declarative specifications or imperative code of any form is one of the easiest ways for end users to describe what the task is.
if the synthesized sql query is applied to the example input then it produces the example output and if the synthesized sql query is applied to other similar input potentially much larger database tables then it produces a corresponding output.
sqlsynthesizer is designed to be used by non expert database end users when they do not know how to write a correct sql query.
end users can use sqlsynthesizer to obtain a sql query to transform multiple huge database tables by constructing small representative input and output example tables.
we also envision sqlsynthesizer to be useful in an online education setting i.e.
an online database course .
education initiatives such as udacity and coursera are teaming up with experts to provide high quality online courses to thousands of students worldwide.
one challenge which is not present in a traditional classroom setting is to provide answers to questions raised by a large number of students.
a tool like sqlsynthesizer that has the potential of answering sql query related questions would be useful.
inferring sql queries from examples is challenging primarily for two reasons.
first the standard sql language is 1all queries mentioned in this paper refer to sql queries that retrieve data from a database but do not update the database.
.
c ieee ase palo alto usa224inherently complex a sql query can consist of many parts such as joins aggregates the group by clause and the order by clause.
searching for a sql query to satisfy a given example input and output pair as proved by sarma et al.
is a pspace hard problem.
thus a brute force approach such as exhaustively enumerating all syntactically valid sql queries and then filtering away those do not satisfy the examples becomes intractable in practice.
second a sql query has a rich set of operations it needs to be evaluated on multiple input tables it needs to perform data grouping selection and ordering operations and it needs to project data on certain columns to form the output.
all such operations must be inferred properly and efficiently.
to address these challenges and make example based sql query synthesis feasible in practice sqlsynthesizer focuses on a widely used sql subset section iii and uses three steps to link a user s intention to a sql query section iv skeleton creation.
sqlsynthesizer scans the given inputoutput examples and heuristically determines table joins and projection columns in the result query.
then it creates an incomplete sql query called a query skeleton to capture the basic structure of the result query.
query completion.
sqlsynthesizer uses a machine learning algorithm to infer a set of accurate and expressive rules which transforms the input example into the output example.
then it searches for other missing parts in a query skeleton and builds a list of candidate queries.
candidate ranking.
if multiple sql queries satisfy the given input output examples sqlsynthesizer employs the occam s razor principle to rank simpler queries higher in the output.
compared to previous approaches sqlsynthesizer has two notable features it is fully automated.
besides an example input and output pair sqlsynthesizer does not require users to provide annotations or hints of any form.
this distinguishes our work from competing techniques such as specificationbased query inference and query synthesis from imperative code .
it supports a wide range of sql queries.
similar approaches in the literature support a small subset of the sql language and most of them can only infer simple select from where queries on a single table .
by contrast sqlsynthesizer significantly enriches the supported sql subset.
besides supporting standard select from where queries sqlsynthesizer also supports many useful sql features such as table joins aggregates e.g.
max min sum and count the group by clause the order by clause and the having clause.
evaluation .
we evaluated sqlsynthesizer s generality and accuracy in two aspects.
first we used sqlsynthesizer to solve sql exercises from a classic database textbook .
we used textbook exercises because they are often designed to cover a wide range of sql features.
some exercises are even designed on purpose to be challenging and to coversome less realistic corner cases in using sql.
second we evaluated sqlsynthesizer on sql query related questions collected from popular online help forums and tested whether sqlsynthesizer can synthesize correct sql queries for them.
as a result sqlsynthesizer successfully synthesized queries for out of textbook exercises and all forum problems within a very small amount of time seconds per exercise or problem on average .
sqlsynthesizer s accuracy and speed make it an attractive tool for end users to use.
contributions.
this paper makes the following contributions technique.
we present a technique that automatically synthesizes sql queries from input output examples section iv .
implementation.
we implemented our technique in a tool called sqlsynthesizer section v .
it is available at evaluation.
we applied sqlsynthesizer to textbook exercises and forum questions.
the experimental results show that sqlsynthesizer is useful in synthesizing sql queries with small examples section vi .
ii.
i llustrating example we use an example described below to illustrate the use of sqlsynthesizer.
the example is taken from a classic database textbook chapter exercise and has been simplified for illustration purposes.
find the name and the maximum course score of each senior student enrolled in more than courses.
despite the simplicity of the problem description writing a correct sql query can be non trivial for a typical end user.
an end user must carefully choose the right sql features and use them correctly to fulfill the described task.
as an alternative users can use sqlsynthesizer to obtain the desired query.
to use sqlsynthesizer an end user only needs to provide it with some small representative example input and output tables figures a and c .
then sqlsynthesizer works in a fully automatic push button way to infer a sql query that satisfies the given example input and output.
the sql query shown in figure b first joins two tables on the common student id column and then groups the joined results by the student id column.
further the query selects all senior students using a query condition in the where clause who are enrolled in more than courses using a condition in thehaving clause .
finally the query projects the result on the student.name column and uses the maxaggregate to compute the maximum course score.
to the best of our knowledge none of the existing techniques can infer this query from the given examples.
iii.
a sql s ubset supported in sqls ynthesizer sqlsynthesizer focuses on a widely used sql subset using which a large class of query tasks can be performed.
unfortunately when designing the sql subset we found that no empirical study has ever been conducted to this end and 2this exercise defines tables whose schemas are shown in figure a .
student id name level adam senior bob junior erin senior rob junior dan senior peter senior sai senior student id course id score name max score dan sai a two input tables student left and enrolled right c an output table select student.name max enrolled.score from student enrolled where student.student id enrolled.student id and student.level senior group by student.student id having count enrolled.course id b a sql query inferred by sqlsynthesizer fig.
.
illustration of how to use sqlsynthesizer to solve the problem in section ii.
the user provides sqlsynthesizer with two input tables shown in a and an output table shown in c .
sqlsynthesizer automatically synthesizes a sql query shown in b that transforms the two input tables into the output table.
12right joinnot existunionnot nulllikebetweenleft joinhavinginner joinfull joinminmaxinsumavgdistinctcountorder bygroup byselect... from.. fig.
.
survey results of the most widely used sql features in writing a database query.
each participant selected the most widely used sql features.
sql features with no vote are omitted for brevity.
little evidence has ever been provided on which sql features are widely used in practice.
without such knowledge deciding which sql subset to support remains difficult.
to address this challenge and reduce our personal bias in designing the language subset we first conducted an online survey to ask experienced it professionals about the most widely used sql features in writing database queries section iii a .
then based on the survey results we designed a sql subset section iii b .
later we sent the designed sql subset to the survey participants and conducted a series of follow up interviews to confirm whether our design would be sufficient in practice.
a. online survey eliciting design requirements our online survey consists of questions that can be divided into two parts.
the first part includes demographic information including experience in using sql.
in the secondhqueryi selecthexpri fromhtablei wherehcondi group byhcolumni havinghcondi order byhcolumni htablei atom hcolumni htablei atom hcondi hcondi hcondi jhcondi hcondi j hcondi jhcexprihopihcexpri hopi j j hcexpri constjhcolumni hexpri hcexprijcount hcolumni jcount distincthcolumni jmin hcolumni jmax hcolumni jsum hcolumni javg hcolumni fig.
.
syntax of the supported sql subset in sqlsynthesizer const is a constant value and atom is a string value representing a table name or a column name.
part participants were asked to select the most widelyused sql features in their minds.
instead of directly asking participants about the sql features which might be vague and difficult to respond we present them a list of standard sql features in writing a query.
we posted our survey on professional online forums e.g.
stackoverflow and sent to graduate students at the university of washington.
we received responses.
on average the respondents had .
years of experience in software development max min and .
years of experience in using databases max min .
in addition two participants identified themselves as database professionals.
figure summaries the survey results.
b. language syntax based on the survey results we designed a subset of the standard sql language whose syntax is shown in figure .226select student.name max enrolled.score from student enrolled where student.student id enrolled.student id and student.level senior group by student.student id having count enrolled.course id order by student.name projection column aggregate join conditions query conditions group by clause having clause order by clause query tables fig.
.
an example query using the sql subset defined in figure .
the supported sql subset covers all top most widelyused sql features as voted by the survey participants in figure except for the inkeyword.
in addition the sql subset supports the having keyword since having is often used together with the group by clause.
our sql subset though by no means complete in writing all possible queries has significantly enriched the sql subsets supported by the existing query inference work .
besides being able to write standard select from where queries as in our sql subset also supports table joins aggregates e.g.
count max min and avg the group by clause the order by clause and thehaving clause.
for readers who are not familiar with the basic sql idioms figure shows an example query using our sql subset.
when designing the sql subset we focused on standard sql features and excluded user defined functions and vendorspecific features such as the topkeyword supported in microsoft sqlserver.
we discarded some standard sql features primarily for three reasons.
first some features are designed as syntactic sugar to make a sql query easier to write and thus can be safely removed without affecting a language s expressiveness.
for example the between keyword checks whether a given value is within a specific range or not and can be simply replaced by two query conditions.
similarly the not null keyword is also omitted.
second some features such as full join left join and right join provide special ways to join tables and are less likely to be used by non expert endusers.
third other features such as inandnot exist are used to write sub queries or nested queries which can significantly increase the complexity in query inference .
related the like keyword is designed for string wildcard matching determining its matching patterns requires systematic search and can be expensive in practice.
thus for the sake of inference efficiency we excluded these keywords.
c. follow up interviews feedback about the sql subset after proposing the sql subset in figure we performed follow up email interviews to gain participants feedback.
participants were first asked to rate the sufficiency of the sql subset in figure in writing real world database queries on a point scale completely sufficient not sufficient at all and in between values indicating intermediate sufficiency and then to provide their comments.
among the received responses the average rating of the proposed sql subset is .
.
most of the participants rated it or .
only one participant rated it because this participantmisinterpreted the language syntax and thought it does not support table joins.
overall based on the feedback by experienced it professionals we believe our sql subset is usable for end users in writing common database queries.
iv.
t echnique this section first gives an overview of sqlsynthesizer s workflow and high level algorithm in section iv a and then explains sqlsynthesizer s three steps in details section iv b section iv c and section iv d .
a. overview figure illustrates sqlsynthesizer s workflow.
sqlsynthesizer consists of three steps the skeleton creation step section iv b creates a set of query skeletons from the given examples the query completion step section iv c infers the missing parts in each query skeleton and outputs a list of queries that satisfy the provided example input and output and the candidate ranking step section iv d uses the occam s razor principle to rank simpler queries higher in the output.
users can inspect sqlsynthesizer s output to select a desired query.
if the synthesized sql queries satisfy the example input and output but do not address the user s intention the user can provide sqlsynthesizer with more informative examples and re apply sqlsynthesizer to the new examples.
figure sketches sqlsynthesizer s high level algorithm.
line corresponds to the first query skeleton creation step.
lines correspond to the second query completion step in which sqlsynthesizer searches for the query conditions line aggregates line and columns in the order by clause line .
sqlsynthesizer then builds a list of candidate queries line and validates their correctness on the examples lines .
line corresponds to the candidate ranking step.
b. skeleton creation a query skeleton is an incomplete sql query that captures the basic structure of the result query.
it consists of three parts query tables join conditions and projection columns.
to create it sqlsynthesizer performs a simple scan over the examples and uses several heuristics to determine each part.
determining query tables.
a typical end user is often unwilling to provide more than enough example input.
based on this observation we assume every example input table is used at least once in the result query.
by default the query tables are all example input tables.
yet it is possible that one input table will be used multiple times in a query.
sqlsynthesizer does not forbid this case it uses a heuristic to estimate the query tables.
if the same column from an input table appears n n times in the output table it is highly likely that the input table will be used multiple times in the query such as being joined with different tables.
thus sqlsynthesizer replicates the input table ntimes in the query table set.
3including conditions in the having clause and columns in the group byclause.
skeleton creation query completion candidate ranking query skeleton s candidate queries ranked queries input output examples expected queries select provide more input output examples fig.
.
illustration of sqlsynthesizer s workflow of synthesizing sql queries from input output examples.
input example input table s ti an example output table to output a ranked list of sql queries synthesizesqlqueries ti to querylist an empty list skeletons createqueryskeletons ti to foreach skeleton inskeletons do conds inferconditions ti to skeleton aggs searchforaggregates ti to skeleton conds columns searchfororderbys to skeleton aggs queries buildqueries skeleton conds aggs columns foreach query inqueries do ifsatisfyexamples query ti to then querylist .add query end if end for end for rankqueries querylist return querylist fig.
.
algorithm for synthesizing sql queries from input output examples.
determining join conditions.
instead of enumerating all possible ways to join query tables which may lead to a large number of join conditions sqlsynthesizer uses two rules below to identify the most likely join conditions.
sqlsynthesizer repeatedly applies these two rules to join two different tables from the query tables until all tables get joined.
first sqlsynthesizer seeks to join tables on columns with the same name and the same data type.
for example in figure the student table is joined with the enrolled table on the student id column which exists in both tables and has the same data type.
if such columns do not exist sqlsynthesizer uses the second rule to join tables on columns with the same data type but with different names .
for example suppose the student id column in thestudent table of figure a is renamed to student key sqlsynthesizer will no longer find a column with the same name and data type in table student and table enrolled .
if so sqlsynthesizer will identify three possible join conditions by only considering columns with the same data type student key student id student key course id and student key score and create three skeletons each of which uses one join condition.
determining projection columns.
sqlsynthesizer scans each column in the output table and checks whether a column with the same name exists in an input table.
if so sqlsynthesizer uses the first matched column from the input table as the projection column.
otherwise the column in the select student.name aggregate from student enrolled where student.s tudent id enrolled.student id and query condition group by column name s having query condition order by column name s ame core bob an im ame bob an ent name bob or name dan fig.
.
a query skeleton created for the motivating example in figure .
the missing parts between and will be completed in section iv c. output table must be created by using an aggregate.
take the output table in figure as an example sqlsynthesizer determines that the name column is from the student table and themax score column is created by using an aggregate.
given an example input and output pair depending on the number of join conditions sqlsynthesizer may create multiple skeletons which share the same query tables and projection columns but differ in the join condition.
for the example in figure sqlsynthesizer creates one query skeleton shown in figure .
c. query completion in this step sqlsynthesizer completes the missing parts in each query skeleton and outputs a list of sql queries that satisfy the given input output examples.
inferring query conditions sqlsynthesizer casts the problem of inferring query conditions aslearning appropriate rules that can perfectly divide a search space into a positive part and a negative part.
in our context the search space is all result tuples created by joining query tables the positive part includes all result tuples that contain the output table and the negative part includes the remaining tuples.
the standard way for rule learning is using a decision treebased algorithm.
however a key challenge is how to design a sufficient set of features to capture relevant relations between the example input and output.
existing approaches simply use tuple values in the input table s as features and thus limit their abilities in inferring non trivial conditions.
in particular merely using tuple values as features can only infer conditions comparing a column value with a constant e.g.
student.level senior but fails to infer conditions using aggregates e.g.
count enrolled.course id or conditions comparing values of two table columns e.g.
enrolled.course id enrolled.score .
this is primarily because tuple values from the input table s do not include enough knowledge about the consequence of applying an aggregate and the potential relations between table columns.
to address this challenge sqlsynthesizer adds two new types of features to each tuple and uses them together with228 an input table aggregation features comparison features group by c1 group by c2 c1 c2 count c2 count distinct c2 min c2 max c2 sum c2 avg c2 count c1 count distinct c1 min c1 max c1 sum c1 avg c1 c1 c2 c1 c2 c1 c2 fig.
.
illustration of two new types of features added by sqlsynthesizer.
left an example input table with two columns c1 and c2.
center the aggregation features added by sqlsynthesizer for the input table.
right the comparison features added by sqlsynthesizer for the input table.
when grouping all tuples in the input table by column c1 there will be two groups the first group includes the first tuples with value in the c1 column and the second group includes the last tuple with value in the c1 column.
for example the first half of the first row in the aggregation feature table shows the results of applying different aggregates to the first group the number of c2 values is i.e.
count c2 the number of distinct c2 values is i.e.
count distinct c2 the minimal c2 value is i.e.
min c2 the maximal c2 value is i.e.
max c2 the sum of c2 values is i.e.
sum c2 and the average c2 value is i.e.
avg c2 .
the existing tuple values for rule learning.
the new features explicitly encode useful information about sql aggregates and table column relations.
aggregation features .
for each column in the joined table sqlsynthesizer groups all tuples by each tuple s value and then applies every applicable aggregate4to each of the remaining columns to compute the corresponding aggregation result.
the aggregation features part in figure shows an example.
comparison features .
for each tuple sqlsynthesizer compares the values of every two type compatible columns and records the comparison results 1or0 as features.
the comparison features part in figure shows an example.
sqlsynthesizer employs a variant of the decision tree algorithm called part to learn a set of rules as query conditions.
we chose part because it uses a divide andconquer strategy to build rules incrementally and thus is faster and consumes less memory than the original decision tree algorithm .
using the new features added by sqlsynthesizer the part algorithm is able to discover rules that are hard to identify by only using the original tuple values as features.
figure shows an example.
sqlsynthesizer splits the learned conditions into two disjoint parts and places each part to the appropriate clause.
specifically sqlsynthesizer places conditions using aggregates to thehaving clause and places other conditions to the where clause.
this is based on the sql language specification query conditions using aggregates are valid only when they are used together with the group by clause and are used in thehaving clause.
take the conditions inferred in figure as an example sqlsynthesizer puts the query condition student.level senior to the where clause puts condition count enrolled.course id to the having clause and puts column student id to the group by clause.
searching for aggregates for every column in the output table that has no matched column in the input table s sqlsynthesizer searches for the desired aggregate by repeatedly applying each aggregate on every input table column and checks whether the aggregate produces the same 4count count distinct max min sum and avg for a column of numeric type and count and count distinct for a column of string typeoutput as in the output table.
to speed up the exhaustive search sqlsynthesizer uses two sound heuristics to filter away infeasible combinations.
sqlsynthesizer only applies an aggregate to its typecompatible table columns.
specifically the value type of an output column must be compatible with an aggregate s return type.
for instance if an output column contains string values it cannot be produced by applying the count orcount distinct aggregate or applying the max aggregate to a column of integer type.
further some aggregates have restrictive usages.
for example the avg andsumaggregates cannot be applied to columns of string type.
sqlsynthesizer encodes such knowledge to prune the search space.
sqlsynthesizer checks whether each value in the output column exists in the input table.
if not the output column cannot be produced by using the maxorminaggregate.
for the example in figure sqlsynthesizer determines themax score column in the output table is produced by using themax score aggregate.
searching for columns in the order by clause sqlsynthesizer scans the values of each column in the output table.
if the data values in a column are sorted sqlsynthesizer appends the column name to the order by clause.
for the output table in figure sqlsynthesizer determines no column should be added to the order by clause since neither output column is sorted.
d. candidate ranking it is possible that multiple sql queries satisfying the given input output examples will be returned.
sqlsynthesizer employs the occam s razor principle which states that the simplest explanation is usually the correct one to rank simpler queries higher in the output.
a simpler query is less likely to overfit the given examples than a complex one even when both of them satisfy the example input and output.
a sql query is simpler than another one if it uses fewer query conditions including conditions in the having andwhere clauses or the expressions including aggregates in each query condition or clause are pairwise simpler.
for example expression count student id is simpler than count distinct student id .
simpler query conditions and expressions often suggest the logics are more common and general.
group by student id student id course id score name level count course id max score adam senior adam senior bob junior bob junior bob junior erin senior rob junior rob junior dan senior dan senior dan senior peter senior peter senior sai senior sai senior sai senior student id course id score name level dan senior dan senior dan senior sai senior sai senior sai senior student id course id score name level dan senior dan senior dan senior sai senior sai senior sai senior student id course id score name level bob junior bob junior bob junior dan senior dan senior dan senior sai senior sai senior sai senior name max score dan sai level senior group by student id a b c d e count course id aggregation features project tuples on column name and aggregate max score ... the table created by joining table student with table enrolled on column student id fig.
.
illustration of how the new features added by sqlsynthesizer help in inferring query conditions for the example in figure .
a shows sqlsynthesizer enriches the original tuple values left with new features right .
for brevity only relevant aggregation features are shown.
using the added aggregation features sqlsynthesizer observes that tuples whose feature values satisfy count course id andlevel senior appear in the output table and thus infers a query condition that transforms the original table into the table shown in b which contains the output table shown in c .
such query condition is difficult to discover without using the aggregation features.
c shows the output table which is produced by projecting the table in b on the name column and the max score aggregate.
name score bob dan jim name bob dan a an input table student b an output table .
select name from student where score .
select name from student where name bob or name dan fig.
.
illustration of sqlsynthesizer s query ranking heuristic.
sqlsynthesizer produces two queries for the given examples.
the first query differs from the second query in using a simpler condition and thus is ranked higher.
sqlsynthesizer computes a cost for each query and prefers queries with lower costs.
the cost for a sql query is computed by summarizing the costs of all conditions aggregates and expressions appearing in each clause.
the cost of each condition aggregate and expression is approximated by its length.
figure shows an example.
e. discussion soundness and completeness.
sqlsynthesizer is neither sound nor complete.
the primary reason is that several steps e.g.
the query skeleton creation step in section iv b use heuristics to infer query tables join conditions and projection columns.
such heuristics are necessary since they provide a good approximate solution to the problem of finding sql queries from examples.
although sqlsynthesizer cannot guarantee to infer correct sql queries for all cases as demonstrated in section vi we find sqlsynthesizer is useful in synthesizing a wide variety of queries in practice.
v. i mplementation we implemented the proposed technique in a tool called sqlsynthesizer.
sqlsynthesizer supports integer and string data types.
sqlsynthesizer uses the built in part algorithm in the weka toolkit to learn query conditions section iv c .sqlsynthesizer also uses mysql as the backend database to validate the correctness of each synthesized sql query.
specifically sqlsynthesizer populates the backend database with the given input tables.
when a sql query is synthesized sqlsynthesizer executes the query on the database to observe whether the query result matches the given output.
vi.
e valuation we evaluated four aspects of sqlsynthesizer s effectiveness answering the following research questions what is the success ratio of sqlsynthesizer in synthesizing sql queries?
section vi c1 .
how long does it take for sqlsynthesizer to synthesize a sql query?
section vi c2 .
how much human effort is needed to write sufficient inputoutput examples for sql synthesis?
section vi c3 .
how does sqlsynthesizer s effectiveness compare to existing sql query inference techniques?
section vi c .
a. benchmarks our benchmarks are shown in figure .
we used sql query related exercises from a classic database textbook .
these exercises are from chapter which systematically introduces the sql language.
we chose textbook exercises because they are designed to cover a wide range of sql features.
some exercises are even designed on purpose to be challenging and to cover some less realistic corner cases in using sql.
we used exercises that can be answered using standard sql language features without any vendor specific features or user defined numeric functions.
as shown in figure many textbook exercises involve at least tables.
it was unintuitive for us to write the correct query by simply looking at the problem description.
we searched sql query related questions raised by realworld database users from popular online forums 230benchmarks sqlsynthesizer query by id source input tables example size rank time cost s cost in writing examples m iterations output 1textbook ex .
.
y 2textbook ex .
.
x n 3textbook ex .
.
n 4textbook ex .
.
x n 5textbook ex .
.
n 6textbook ex .
.
n 7textbook ex .
.
n 8textbook ex .
.
n 9textbook ex .
.
n 10textbook ex .
.
y 11textbook ex .
.
x n 12textbook ex .
.
x n 13textbook ex .
.
n 14textbook ex .
.
n 15textbook ex .
.
x n 16textbook ex .
.
n 17textbook ex .
.
x n 18textbook ex .
.
n 19textbook ex .
.
n 20textbook ex .
.
x n 21textbook ex .
.
n 22textbook ex .
.
n 23textbook ex .
.
x n 24forum question n 25forum question n 26forum question n 27forum question n 28forum question n fig.
.
experimental results.
column benchmarks describes the characteristics of our benchmarks.
column input tables shows the number of input tables used in each benchmark.
column sqlsynthesizer shows sqlsynthesizer s results.
column example size shows the number of tuples i.e.
rows in all user written example input and output tables.
column rank shows the absolute rank of the correct sql query in sqlsynthesizer s output.
x means sqlsynthesizer fails to produce a correct answer.
column time cost s shows the total time in seconds used in synthesizing queries by sqlsynthesizer.
column cost in writing examples m shows the total time in minutes used in writing examples by the sqlsynthesizer user.
column iterations shows the number of interactive rounds in using sqlsynthesizer.
column query by output shows the results of the existing query by output qbo technique.
in this column y means qbo produces the correct sql query and n means qbo fails to produce the correct query.
the time cost of qbo is comparable to sqlsynthesizer and is omitted for brevity.
.
we focused on questions about how to write queries using standard sql features.
we excluded questions that were vaguely described or were obviously wrong and discarded questions that had been proved to be unsolvable by using sql e.g.
computing a transitive closure .
we collected non trivial forum questions all questions are available at among which two questions even did not receive any reply on the forum.
writing a good forum post is often harder than seeking information from internet or asking a sql expert since the post has to clearly describe the problem and these end users had already tried but failed to find the correct sql query before they wrote the post.
b. evaluation procedure we used sqlsynthesizer to solve each textbook exercise and forum question.
if an exercise or problem was associated with example input and output we directly applied sqlsynthesizer on those examples.
otherwise we manually wrote someexamples.
all examples are written by the second author of this paper who is not sqlsynthesizer s major developer.
in the evaluation the sqlsynthesizer user wrote examples in plain text files using csv format.
sqlsynthesizer parses the files and automatically infers the data type of each column based on the provided values.
we checked sqlsynthesizer s correctness by comparing its output with the expected sql queries.
for textbook exercises we compared sqlsynthesizer s output with their correct answers.
for forum questions we first checked sqlsynthesizer s output with the confirmed answer in the same post if there is any.
otherwise we manually wrote the correct sql query and compared it with sqlsynthesizer s output.
for some textbook exercises and forum questions if sqlsynthesizer inferred a sql query that satisfied the input output examples but did not behave as expected we manually found an input on which the sql query mis behaved and re applied sqlsynthesizer to the new input.
we repeated this process231and recorded the total number of interactions.
our experiments were run on a .5ghz intel core i5 mac mini with 4gb physical memory running os x version .
.
.
c. results figure summarizes our experimental results.
success ratio sqlsynthesizer synthesized correct sql queries for out of the textbook exercises and all forum questions.
we did not come across any benchmark that can be expressed in our sql subset but our algorithm failed to infer the correct query.
sqlsynthesizer failed to solve textbook exercises because these exercises required to write complex existential sub queries in the join conditions using the inand not exist keywords which are not currently supported by sqlsynthesizer.
compared to the textbook exercises the forum questions come from more realistic use cases and can be expressed in our sql subset and answered by sqlsynthesizer.
we also observed that our ranking strategy section iv d was surprisingly effective for all benchmarks where sqlsynthesizer produced a correct answer it always ranked the correct sql query as the first suggestion.
performance as shown in figure sqlsynthesizer is very efficient.
on average including benchmarks that sqlsynthesizer failed to produce a correct answer sqlsynthesizer took less than seconds in total to produce the results min max .
for benchmarks on which sqlsynthesizer succeeded the average time cost was only seconds min max .
among them in the worst case sqlsynthesizer took seconds to synthesize a correct sql query for a complex forum question which includes tables and columns.
sqlsynthesizer searched over possible queries and validated each of them on the examples before getting the correct answer.
even so sqlsynthesizer s speed is still acceptable for most practical use case scenarios.
human effort we measured the human effort required to use sqlsynthesizer in two ways.
first the time cost to write sufficient input output examples.
second the number of interactive rounds in invoking sqlsynthesizer to synthesize the correct sql queries.
the human effort required in writing input output examples is reasonable.
for the successful benchmarks it took the user less than .
minutes on average to write sufficient examples per benchmark min max .
the average example size is min max .
to produce the correct sql query sqlsynthesizer requires just .
rounds of interaction on average min max .
for successful benchmarks the number of interaction rounds is to .
in general the user spent slightly more time on benchmarks involving more tables or requiring more complex query conditions.
we also observed that for of the failed benchmarks the user gave up after spending minutes adding examples and interaction rounds invoking sqlsynthesizer since the synthesized sql queries in each round seemed to get closer to the expected query but still differed in some parts.
for the remaining failed benchmarks the user immediately concluded that sqlsynthesizer could not produce a correct answer after and rounds respectively because the synthesizedsql query is significantly different than expected.
such observation is driving us to improve sqlsynthesizer s user experience.
for example as our future work we plan to enhance sqlsynthesizer to inform users about the solvability of a problem earlier .
comparison with an existing technique we compared sqlsynthesizer with query by output qbo a technique to infer sql queries from query output.
we chose qbo because it is the most recent technique and also one of the most accurate sql query inference techniques in the literature.
qbo requires an example input output pair and uses the decision tree algorithm to infer a query.
however qbo has three limitations.
first it can only join two tables on their key columns annotated by users and requires users to specify how to project the results by annotating the projection columns.
second it uses the original tuple values from the input tables as learning features and can only infer simple query conditions.
third qbo does not support many useful sql features such as aggregates the group by clause and the having clause.
we implemented qbo annotated each example table as it required and ran it on the same benchmarks.
the results are shown in figure .
qbo produced correct answers for only textbook exercises and none of the forum questions.
benchmarks solved by qbo were also solved by sqlsynthesizer.
qbo s poor performance is primarily caused by its limited support for learning join conditions query conditions and many other sql features.
we did not compare sqlsynthesizer with other techniques because these techniques either require different input e.g.
a query log or a snippet of java code or produce completely different output e.g.
an excel macro or a text editing script than sqlsynthesizer.
thus it is hard to conduct a meaningful comparison.
d. experimental discussion limitations.
the experiments indicate four major limitations of sqlsynthesizer.
first some queries cannot be formulated by our sql subset due to unsupported features.
this limitation is expected.
our future work should address it by including more sql features in sqlsynthesizer.
second sqlsynthesizer requires users to provide noise free input output examples.
even in the presence of a small amount of noises e.g.
a typo sqlsynthesizer will declare failure.
third sqlsynthesizer does not provide any guidance regarding when the user should give up on sqlsynthesizer and assume the sql cannot be synthesized by sqlsynthesizer.
fourth sqlsynthesizer assumes the database schema is known by the user.
sqlsynthesizer may not be helpful to infer sql queries for a complex database whose schema is unclear to its users.
threats to validity.
there are two major threats to validity in our evaluation.
first the textbook exercises and forum questions though covering a wide range of sql features may not be representative enough.
thus we cannot claim the results can be generalized to an arbitrary scenario.
second our experiments evaluate sqlsynthesizer s accuracy.
a user study is needed to further investigate sqlsynthesizer s usefulness.232experimental conclusions.
we have three chief findings sqlsynthesizer is effective in synthesizing sql queries from relatively small examples.
sqlsynthesizer is fast enough for practical use and it only needs a small amount of human effort in writing examples sqlsynthesizer produces significantly better results than an existing technique .
vii.
r elated work we next discuss two categories of related work on reverse engineering sql queries and automated program synthesis.
reverse engineering sql queries.
reverse engineering sql queries is a technique to improve a database s usability.
zloof s work on query by example qbe provided a high level query language and a form based graphical user interface gui for writing database queries.
to use the qbe system users need to learn its query language formulate a query with the language and fill in the appropriate skeleton tables on the gui.
by contrast sqlsynthesizer mitigates such learning curves by only requiring users to provide some representative examples to describe their intentions.
tran et al.
proposed a technique called query by output qbo to infer sql queries from examples.
as we have discussed thoroughly in section vi c qbo excludes many useful sql features and can only infer simple select projectjoin queries.
our experiments demonstrated that qbo failed to infer queries for many use case scenarios.
recently sarma et al.
studied the view definitions problem vdp .
vdp aims to find the most succinct and accurate view definition when the view query is restricted to a specific family of queries.
vdp can be solved as a special case in sqlsynthesizer where there is only one input table and one output table.
furthermore the main contribution of sarma et al s work is the complexity analysis of three variants of the view definitions problem there is no tool implementation or empirical studies to evaluate the proposed technique.
automated program synthesis.
program synthesis is a useful technique to create an executable program in some underlying language from specifications that can range from logical declarative specifications to examples or demonstrations .
it has been used recently for many applications.
the pads system takes a large sample of unstructured data and infers a format that describes the data.
related the wrangler tool developed in the hci community provides a visual interface for table transformation and data cleaning .
these two techniques though well suited for tasks like text extraction cannot be used to synthesize a database query.
this is because text extraction tasks use completely different abstractions than a database query task and the existing tools like pads and wrangler lack the support for many database operations such as joins and aggregation.
harris and gulwani described a system for learning excel spreadsheet transformation macros from an example inputoutput pair .
given one input table and one output table their system can infer an excel macro that filters duplicates and or re organizes table cells to generate the output table.sqlsynthesizer differs in multiple respects.
first excel macros have significantly different semantics than sql queries.
an excel macro can express a variety of table transformation operations e.g.
table re shaping but may not be able to formulate database queries.
second harris and gulwani s approach treats table cells as atomic units and thus has different expressiveness than sqlsynthesizer.
for instance their technique can generate macros to transform one table to another but cannot join multiple tables or aggregate query results by certain table columns.
some recent work proposed query recommendations systems to enhance a database s usability .
sqlshare is a web service that allows users to upload their data and sql queries permitting other users to compose and reuse.
snipsuggest is a sql autocompletion system.
as a user types a query snipsuggest mines existing query logs to recommend relevant clauses or sql snippets e.g.
the table names for the from clause based on the partial query that the user has typed so far.
compared to sqlsynthesizer both sqlshare and snipsuggest assume the existence of a query log that contains valuable information.
however such assumption often does not hold for many database end users in practice.
sqlsynthesizer eliminates this assumption and infers sql queries using user provided examples.
cheung et al.
presented a technique to infer sql queries from imperative code.
their technique transforms fragments of application logic written in an imperative language like java into sql queries.
compared to sqlsynthesizer their work aims to help developers improve a database application s performance rather than helping non expert end users write correct sql queries from scratch.
if an end user wishes to use their technique to synthesize a sql query she must write a snippet of imperative code to describe the query task.
compared to providing examples writing correct imperative code is challenging for a typical end user and thus may degrade the technique s usability.
viii.
c onclusion and future work this paper studied the problem of automated sql query synthesis from simple input output examples and presented a practical technique and its tool implementation called sqlsynthesizer .
we have shown that sqlsynthesizer is able to synthesize a variety of sql queries and it does so from relatively small examples.
for future work we plan to conduct a user study to evaluate sqlsynthesizer s usefulness.
we are also interested in developing techniques to help users debug their sql queries by leveraging the recent advance in automated test generation and failure explanation .
ix.
a cknowledgement we thank dan suciu michael ernst yingyi bu and hao l u for their insightful comments on an initial draft.
this work was supported in part by nsf grants ccf and ccf0963757.233references arvind arasu surajit chaudhuri and raghav kaushik.
learning string transformations from examples.
proc.
vldb endow.
august .
davi m.j. barbosa julien cretin nate foster michael greenberg and benjamin c. pierce.
matching lenses alignment and view update.
in icfp pages .
alvin cheung armando solar lezama and samuel madden.
optimizing database backed applications with query synthesis.
in pldi pages .
coursera.
anish das sarma aditya parameswaran hector garcia molina and jennifer widom.
synthesizing view definitions from data.
in icdt pages .
database journal.
kathleen fisher.
learnpads automatic tool generation from ad hoc data.
in sigmod .
kathleen fisher david walker kenny q. zhu and peter white.
from dirt to shovels fully automatic tool generation from ad hoc data.
in popl pages .
sqlsynthesizer.
eibe frank and ian h. witten.
generating accurate rule sets without global optimization.
in icml pages .
sumit gulwani.
dimensions in program synthesis.
in ppdp pages .
sumit gulwani.
automating string processing in spreadsheets using input output examples.
in popl pages .
mark hall eibe frank geoffrey holmes bernhard pfahringer peter reutemann and ian h. witten.
the weka data mining software an update.
sigkdd explor.
newsl.
november .
william r. harris and sumit gulwani.
spreadsheet table transformations from examples.
in pldi pages .
bill howe garret cole nodira khoussainova and leilani battle.
automatic example queries for ad hoc databases.
in sigmod pages .
sean kandel andreas paepcke joseph hellerstein and jeffrey heer.
wrangler interactive visual specification of data transformation scripts.
inchi pages .
nodira khoussainova yongchul kwon magdalena balazinska and dan suciu.
snipsuggest context aware autocompletion for sql.
proc.
vldb endow.
october .
tessa lau steven a. wolfman pedro domingos and daniel s. weld.
programming by demonstration using version space algebra.
mach.
learn.
october .
tessa a. lau pedro domingos and daniel s. weld.
version space algebra and its application to programming by demonstration.
in icml pages .
mdx a query language for olap databases.
com en us library gg492188.aspx.
mysql.
j. r. quinlan.
induction of decision trees.
mach.
learn.
march .
raghu ramakrishnan and johannes gehrke.
database management systems .
addison wesley 3rd edition .
rishabh singh and sumit gulwani.
learning semantic string transformations from examples.
in vldb .
stackoverflow.
quoc trung tran chee yong chan and srinivasan parthasarathy.
query by output.
in sigmod pages .
tutorialized forums.
udacity.
lingming zhang miryung kim and sarfraz khurshid.
localizing failureinducing program edits based on spectrum information.
in icsm pages .
lingming zhang tao xie lu zhang nikolai tillmann jonathan de halleux and hong mei.
test generation via dynamic symbolic execution for mutation testing.
in icsm pages .
sai zhang.
practical semantic test simplification.
in icse nier track .
sai zhang yu lin zhongxian gu and jianjun zhao.
effective identification of failure inducing changes a hybrid approach.
in paste pages .
sai zhang david saff yingyi bu and michael d. ernst.
combined static and dynamic automated test generation.
in issta pages july .
sai zhang cheng zhang and michael d. ernst.
automated documentation inference to explain failed tests.
in ase november .
mosh e m. zloof.
query by example the invocation and definition of tables and forms.
in vldb pages .