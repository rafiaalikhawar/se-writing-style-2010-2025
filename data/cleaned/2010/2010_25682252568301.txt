asdroid detecting stealthy behaviors in android applications by user interface and program behavior contradiction jianjun huang department of computer science purdue university usa huang427 cs.purdue.eduxiangyu zhang department of computer science purdue university usa xyzhang cs.purdue.edulin tan electrical and computer engineering university of waterloo canada lintan uwaterloo.ca peng wang school of information renmin university of china china pengwang ruc.edu.cnbin liang school of information renmin university of china china liangb ruc.edu.cn abstract android smartphones are becoming increasingly popular.
the open nature of android allows users to install miscellaneous applications including the malicious ones from third party marketplaces without rigorous sanity checks.
a large portion of existing malwares perform stealthy operations such as sending short messages making phone calls and http connections and installing additional malicious components.
in this paper we propose a novel technique to detect such stealthy behavior.
we model stealthy behavior as the program behavior that mismatches with user interface which denotes the user s expectation of program behavior.
we use static program analysis to attribute a top level function that is usually a user interaction function with the behavior it performs.
then we analyze the text extracted from the user interface component associated with the top level function.
semantic mismatch of the two indicates stealthy behavior.
to evaluate asdroid we download a pool of apps that are potentially problematic by looking at their permissions.
among the apps asdroid reports stealthy behaviors in apps with false positives and false negatives.
categories and subject descriptors d2.
software program veri cation validation d2.
testing and debugging code inspection and walk throughs permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse june hyderabad india copyright acm ... .
.
terms security keywords android stealthy behaviors user interface program behavior contradiction .
introduction android smartphones are becoming increasingly popular.
gartner s analysis shows that .
of smartphones are based on android .
a prominent characteristic of android phones is that users can easily install miscellaneous apps downloaded from third party marketplaces without jailbreaking.
however the downside is that google and other vendors can hardly control the quality of apps on third party marketplaces.
adversaries can submit their malicious apps and tempt users to install with various lures.
juniper networks mobile threat center reported a dramatic growth in android malware population from roughly samples in june to in the third quarter of .
most are present on third party marketplaces.
a very popular category of android malware features stealthy malicious operations such as making phone calls sending sms messages to premium rate numbers making undesirable http connections and installing other malicious components.
it was reported by three recent studies that of existing malwares send stealthy premiumrate sms messages or make phone calls.
note that these actions cause unexpected charges to phone bills .
it was observed that stealthy http requests are also very common undesirable behavior in malwares .
besides leaking user information they could also cause unexpected data plan consumption.
in china it was reported in march that more than chinese mobile devices were a ected by a kind of malwares that could make stealthy http connections inducing charges.
they caused around million dollars loss .
despite the pressing need detecting such malware is challenging as the malicious behavior appears to be indistin permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm guishable from that of benign apps.
for example an online shopping app usually provides operation interfaces to help users conveniently call a service number or send a query sms message.
apps providing travel aid and adult content often allow users to make phone calls or send messages.
many benign apps allow establishing background http connections e.g.
weather stock trading and gaming apps .
many also allow users to install additional components.
existing techniques are insu cient in detecting preventing stealthy malicious behaviors.
a very important protection mechanism on android is to allow users to perform access control by setting application privileges.
however the access control is very coarse grained.
for example the sms messaging capability can either be enabled or completely disabled.
it is hard to decide if we should disable for a given app as many benign apps do send sms messages.
taint analysis allows detecting information leak in apps.
but the stealthy behavior in malwares may not leak any private information.
recently google provides the capability of blacklisting certain premium rate phone numbers which provides a potential way of preventing stealthy sms messages or phone calls.
however keeping such a blacklist up to date is a non trivial challenge.
in some countries such as china there is no di erence between a premium rate number and a regular phone number.
in this paper we propose a novel technique to detect stealthy malicious behaviors in android apps.
we model stealthy behavior as the program behavior mismatches with user interface .
the intuition is that user interface ui represents the user s expectation of program behavior.
hence it can naturally serve as an oracle to detect behind the scene behavior.
for example an sms message send triggered by a user interaction that is supposed to set the background color should be considered malicious.
the technique consists of two components.
one is the static program analysis component that attributes the behavior of interest e.g.
sms send and http connection to a top level function with associated ui e.g.
the onclick function of a button .
the other is the ui analysis component that makes use of text analysis to analyze the intent described by the corresponding interface artifacts e.g.
the text associated with the button .
any mismatch will be reported as potentially malicious.
in the program analysis component we classify android apis into di erent groups.
each group is assigned an intent type such as sms send and phone calls.
reachability analysis is performed on control ow graph cfg and call graph cg to propagate such intents from the api call sites to top level functions.
note that in event driven programming an invocation of a top level function usually denotes an action or a task that can be considered as a natural unit to reason about stealthiness.
the interface analysis component identi es the text of the ui artifact associated with a top level function.
then compatibility check is performed between the intents from program analysis and those extracted from the interface text.
our contributions are summarized as follows.
we propose a method to detect android malware that performs stealthy operations including sms message send phone calls http connections and component installations.
it is based on the novel idea of detecting mismatches between program behavior and user interface.
we found that in many cases even though there is nodirect match between an api intent e.g.
sms send and the ui text the api may be correlated with other apis that explicitly expose the behavior e.g.
an api call that logs the sms send to the mail box .
in such cases the behavior should not be considered stealthy.
we propose an in depth analysis that considers program dependences between apis to identify their correlations and hence improve precision.
we formally present our design using datalog rules.
the design handles a number of android speci c challenges.
we implement a prototype called asdroid anti stealth droid .
we collect a pool of apps that have the permissions to perform the malicious operations of interest.
asdroid reports that of them have stealthy behaviors with false positives and false negatives.
.
motivating example we use a real application qiyu to motivate our technique.
it is a location based social networking service application on android.
some relevant code snippets are shown in fig.
a and part of the corresponding call graph is in fig.
b .
the entry function onclick at line is the handler of a button with text one click register login .
the scenario is as follows.
when the user clicks the button the app checks the current environmental settings.
in most cases the true branch is taken in which an asynchronous task is appended to the task queue and executed line .
this causes an indirect invocation to a prede ned handler at line which is always implicitly called by the android runtime to perform some background processing when a task starts to execute.
the function transitively calls method a in class woa.ba at line .
the method connects to a website through httpclient.execute at line to perform registration or login.
the chain of function calls is also shown on the left of fig.
b .
when the test at line fails the else branch line is taken.
a di erent chain of function invocations are made eventually leading to an sms message being sent inside method c in class woa.ak at line without the user s awareness.
the chain is shown on the right of fig.
b .
note that we omit three function calls between the asynchronous task execution at line and method c for brevity.
to detect stealthy behaviors our program analysis component rst attributes top level functions with intents by analyzing the operations of interest directly or transitively performed by such functions.
we classify android apis to a few pre de ned intent types.
in this example httpclient.execute at line denotes the httpaccess intent and smsmanager.sendtextmessage at line denotes thesendsms intent.
the intents get propagated upward along the call edges see fig.
b and eventually aggregated on the top level node onclick which is a user interaction function suggesting the operations performed by this function should re ect what the ui states.
the ui analysis component identi es the ui artifacts corresponding to theonclick function i.e.
the button and its residence dialog.
it further extracts the text on these interface artifacts and performs text analysis to identify a set of keywords.
in this example they are register and login .
asdroid1037 in class qiyu.startpageactivity public void onclick view v if test environment woa.f f new woa.f v this f.execute new string trigger line else ... woa.ag.b invoke line in class woa.f public object objs transitively calls woa.ba.a at line in class woa.ba private org.apache.http.client.httpclient h private org.apache.http.client.methods.httpget d public void a this.h.execute this.d httpclient.execute ... in class woa.ag public static void b woa.u u new woa.u u.execute ... transitively calls c at line in class woa.ak public static boolean c context c string s1 string s2 smsmanager sm smsmanager.getdefault sm.sendtextmessage s1 null s2 null null a simpli ed code snippet qiyu.startpageactivity.onclick a httpclient .
execute b c smsmanager .
sendtextmessage indirect call calls omitteddirect call calls omitted via line 19httpaccesssendsms b call graph and intent propagation figure motivating example in app qiyu.
looks up the compatibility of the keywords and the intents identi ed by the program analysis component from a dictionary generated before hand in a training phase.
in this case the httpaccess intent is compatible but sendsms is not.
our tool hence reports the contradiction.
there are cases that multiple intents of a top level function are correlated.
for example a dialog may be popped up after a sms message send to indicate the success of the send even though the button that initiates the send does not have any textual hint about sending messages.
in this case the sms send is not stealthy.
the display of a dialog has the uioperation intent.
both the uioperation and sendsms intents reach the top level function.
we hence analyze if the intents are correlated by analyzing their program dependences.
since uioperation is not stealthy the correlation between the uioperation andsendsms intents suggests the sanity of the sms send behavior.
.
design in this section we rst de ne six types of intents that are of our interest.
the corresponding apis are commonly used in android apps.
sendsms.
this intent corresponds to sms send apis including sendtextmessage senddatamessage andsendmultiparttextmessage declared in class smsmanager .
theseapi functions are usually executed in the background.
an sms send through a separated messaging app is not taken into consideration in this paper because it requires the user to explicitly interact with the messaging app to nish the process and hence is not stealthy.
phonecall.
it corresponds to a direct phone call namely invoking startactivity with action android.intent.ac tion.call .
malware can leverage the automated calling mechanism to dial a number without the user s awareness.
phone calls can also be made through startactivity with an action android.intent.action.dial .
however we do not model this api because explicit user approval is needed when the api is used.
httpaccess.
this intent describes http access apis.
it includes url.openconnection url.openstream abstracthttpclient.execute and so on.
http access is commonly used in android apps for a wide range of purposes.
install.
it describes api functions that are for installing other components or applications.
many android malwares have their payload as installing another piece of malicious code.
benign apps may also need to perform installation which is however usually authorized or explicitly guided by the user.
modeled functions include runtime.exec with pm install as the argument and processbuilder.start using pm and install to build a new process.
smsnotify.
in some cases the user does not need to or cannot authorize a message send operation.
but after the operation the app may automatically notify the user that there was an sms send.
in this case we should not consider the message send as a stealthy action even though the user interface that leads to the sms send operation does not have any textual implication of the operation.
one typical example is that a copy of the message is saved to the user s mail box to record what just happened.
hence we model the following api to the smsnotify intent contentresolver.insert and the destination table is given by a url content sms .
it means inserting data into the preloaded database for short messages.
uioperation .
a top level user interaction function may display more user interface elements to allow further interactions with the user.
in some cases ui display operations may be correlated to some of the aforementioned intents.
for example a dialog may be popped up after an sms send to notify the user about the send.
in such cases the sms send is not stealthy.
to reason about these cases we associate the ui display api functions such as alertdialog builder.setmessage imageview.setimagebitmap and view.setbackgrounddrawable with the uioperation intent.
.
intent propagation in this section we describe how intents are propagated to top level functions such that we can check compatibility with the corresponding ui text.
we also describe how to detect correlation between intents.
intent propagation is based on call graph.
the calling convention of android apps has its unique features which need to be properly handled.
intent correlation analysis is mainly based on program dependences.
however correlated intents do not simply mean there are transitive dependences between them.
the analysis is formally described in the datalog language1038atoms apiintent l t api call at program point lhas intent type t. def l x variable xis de ned at program point l. use l x variable xis used at program point l. actual l m x variable xis themthactual argument at call site l. formal f m x variable xis themthformal argument of function f .
infunction f l program point lis in function f .
funentry f l program point lis the entry of function f .
hasdeffreepath l1 l2 x there is a path from l1tol2along which xmay not be de ned.
componententry x f f is the entry of android component x. e.g.
oncreate of an activity or aservice component.
immediatecd l1 l2 program point l2is immediately control dependent on l1in the same function.
directinvoke f1 f2 l f1invokesf2at program point l indirectinvoke f1 f2 f2is the actual destination of f1 in event driven circumstances e.g.
thread.start !
runnable.run handler.sendmessage !handler.handlemessage .
iccinvoke f1 f2 l f1invokes a function f2for inter component communication purpose at l.f2should be apis like startactivity startservice .
rules invoke f1 f2 l f1invokesf2at program point l. invoke f1 f2 l directinvoke f1 f2 l invoke f1 f2 l iccinvoke f1 f3 l actual l x l1 x.setclass ... actual l1 y componententry y f2 invoke f1 f2 l invoke f1 f3 l indirectinvoke f3 f2 invoke f1 f2 l invoke f1 f3 l invoke f3 f2 l hasintent f t l f has intent typetand the corresponding api call is at l. hasintent f t l invoke f a l apiintent l t hasintent f t l1 hasintent f1 t l1 invoke f f1 l2 controldep l1 l2 program point l2is control dependent on l1.
controldep l1 l2 immediatecd l1 l2 controldep l1 l2 infunction f1 l1 infunction f2 l2 invoke f1 f2 l3 controldep l1 l3 defuse l1 l2 useuse l1 l2 data atl1andl2are data correlated.
defuse l1 l2 def l1 x use l2 x hasdeffreepath l1 l2 x defuse l1 l2 invoke f1 f2 l1 actual l1 m x formal f2 m y funentry f2 l3 hasdeffreepath l3 l2 y use l2 y useuse l1 l2 defuse l3 l1 defuse l3 l2 useuse l2 l1 defuse l3 l1 defuse l3 l2 correlated l1 l2 l1andl2are data control correlated.
correlated l1 l2 controldep l1 l2 correlated l1 l2 defuse l1 l2 correlated l1 l2 useuse l1 l2 correlated l1 l2 correlated l1 l3 correlated l3 l2 correlatedintent f t1 l1 t2 l2 in function f intentt1atl1is correlated to t2atl2 correlatedintent f t1 l1 t2 l2 hasintent f t1 l1 hasintent f t2 l2 correlated l1 l2 figure datalog rules for intent propagation and correlations which is a prolog like notation for relation computation.
it provides a representation for data ow analysis in the form of formulated relations.
the inference rules on these relations are shown in fig.
.
relations are in the form p x1 x2 ... xn with pbeing a predicate.
x1 x2 ... xnare terms of variables or constants.
in our context variables are essentially program artifacts such as statements program variables and function calls.
a predicate is a declarative statement on the variables.
for example infunction f l denotes if a statement with label lis in function f. rules express logic inferences with the following form.
h b1 b2 ... bn handb1 b2 ...bnare either relations or negated relations.
we should read the symbol as if .
the meaning of a rule is if b1 b2 ...bnare true then his true.
relations can be either inferred or atoms.
we often start with a set of atoms that are basic facts derived from the compiler and then infer the other more interesting relations through our analysis.
we use wala as the underlying analysis infrastructure.
we leverage its single static assignment ssa representation control ow graph part of call graph and the may points to analysis to provide the atoms.atom apiintent l t denotes an intent tis associated with an api call at l re ecting our api classi cation.
atom hasdeffreepath l1 l2 x indicates there is a program path from program point l1tol2and along the path not including l1orl2 variable xmay not be de ned.
this is to compute the defuse l1 l2 relation that denotes if a variable is de ned at l1and used at l2.
to generate the atom relation we leverage the ssa form and the points to analysis.
the analysis is conservative.
if we are not sure x must be re de ned along the path we assume the path is de nition free.
the paths we are considering include both intra and inter procedural paths.
android apps are component based.
generally there are four types of basic components activity service broadcast receiver and content provider .
activity component is for a single ui screen.
service component is for longrunning operations in the background without any ui .
broadcast receiver responds to system wide broadcast announcements.
content provider is used for application data management .
inter component communication icc is used to deliver data between components which is similar to traditional function invocations.
we have to model1039 in method zjreceiver.onreceive f1 intent intent new intent android.intent.action.run l1intent.setclass context zjservice.class y l startservice intent f3 x in class zjservice y public void onstart intent intent int i f2 figure icc call chain example in golddream .
such communication as a function may transitively invoke api functions with intent of interest through icc.
however the calling convention of icc is so unique that the underlying wala infrastructure cannot recognize icc invocations.
fig.
shows an example from a real world app golddream .
inside the zjreceiver.onreceive function there is an icc call to the onstart function of the zjservice component.
observe that the invocation is performed by creating an android intent object1 which can be considered as a request that gets sent to other components to perform certain actions.
the target component is set by explicitly calling setclass of the android intent object.
the request is sent by calling startservice with the android intent object.
the android runtime properly forwards the request to the onstart function of the zjservice component.
to capture such call relation we introduce the componententry x f atom with xa subclass of service activity orbroadcastreceiver .
the entry point fdenotes oncreate onstart and onreceive which are also called lifecycle methods by android developers.
we introduce atom iccinvoke f1 f2 l with f2denoting special icc functions such as startactivity startservice and sendbroadcast .
the second inference rule of the invoke f1 f2 l relation describes how we model icc as a kind of function invocation.
let s use the example in fig.
to illustrate the rule.
it allows us capture the call chain zjreceiver.onreceive !startservice !zjservice.
onstart .
labels l l1 f1 f3 and yin fig.
correspond to those in the second invoke rule.
atom directinvoke f1 f2 l denotes regular function calls including virtual calls leveraging wala.
atom indirectinvoke f1 f2 denotes another special kind of function invocations in android apps namely implicit calls in thread execution and event handling.
a typical indirect call is a thread related invocation e.g.
actual call destination of thread.start is the run method of the corresponding class.
the function call f.execute !
in fig.
i.e.
line !line is an example for event handling indirect invocation.
we detect these implicit calls through pre de ned patterns.
relation hasintent f t l denotes function fis tagged with an intent tinitiated by the api call at program point l. for example in fig.
we can infer the following hasintent f startpageactivity.onclick t sendsms sm.sendtextmessage ... true .
observe that the rst hasintent rule tags the enclosing 1intent is a standard class in android.
we call it android intent in order to distinguish with the intents we associate with api functions.function of an api call.
the second rule propagates a tag from a callee to the caller.
note that a function may have multiple intents.
these intents may be of the same type but initiated at di erent api call locations .
the remaining relations and rules are for intent correlations.
relation correlated l1 l2 determines if two program points l1andl2are correlated.
correlation can be induced by de nition use use use and control dependence relations described by relations defuse useuse and controldep respectively.
the fourth correlated rule suggests that the relation is transitive.
the rst rule of defuse l1 l2 is standard.
in our implementation we leverage ssa form to derive de nition use relation for local and global variables.
we leverage pointsto relation to reason about de nition use relation for object elds.
the second rule is to capture de nition use relation by parameter passing including those through android speci c calling conventions.
the basic idea is that we consider a formal argument yused inside the callee at l2is de ned at the call site l1 in the caller if it is not re de ned along the path from the callee entry to the use site.
the relation useuse l1 l2 denotes that there are uses atl1andl2coming from the same de nition point.
for example l1andl2could be the two uses of the same variable in the two branches of a predicate.
considering use use relation in the correlated relation is the key di erence from standard program dependence analysis that considers only de nition use and control dependence relations.
computation of controldep l1 l2 is standard except that it also models inter procedural control dependence.
particularly all statements in a callee have control dependence with a predicate in the caller that guards the call site.
finally the relation correlatedintent f t1 l1 t2 l2 denotes if two intents t1andt2at function fare correlated.
example.
fig.
shows a correlation analysis example in app shanghai .contentresolver.insert at line stores the sent text message into the mail box and it hence has intent type smsnotify .
it is determined to be correlated to the sms sending operation with sendsms intent at line .
according to the de nition use graph in fig.
b line is correlated with line both use cvde ned at line by the useuse rules.
line is further correlated with line because of variables v8 again by the useuse rules.
hence we have correlatedintent paysmsactivity.a send sms smsnotify true .
intuitively the two intents are correlated because the same content is being sent over a short message and written to the mail box.
thus the message send is not stealthy.
.
ui compatibility check after intents are propagated to top level functions the next step is to check their compatibility with the text of the corresponding user interface artifacts.
acquiring user interface text .
given a top level function we need to rst extract the corresponding text.
user interface components in an android app are organized in a view tree.
a view is an object that renders the screen that the user can interact with.
views can be organized as a tree to re ect the layout of interface.
there are two ways to construct the layout statically through an xml resource le dynamically by constructing the view tree at runtime.
with the static layout construction upon the creation1040 in class paysmsactivity void a string v8 string v9 string v10 smsmanager sm smsmanager.getdefault arraylist al smsmanager.dividemessage v10 iterator string ite al.iterator while ite.hasnext string s ite.next sm.sendtextmessage v8 v9 s null null contentvalues cv new contentvalues cv.put address v8 cv.put body v10 cv.put type contentresolver cr getcontentresolver uri uri uri.parse content sms cr.insert uri cv a code snippet l1 l3 l4 l6 l7l9 l10 l11 l15v10 al ite sv8v8 v10cv cv cv correlated b part of de nition use relations.
solid arrows labeled with variable names indicate def use relation.
figure intent correlation example in app shanghai .
of an activity the corresponding user interface is instantiated by associating the activity with the corresponding xml le by calling setcontentview .
the android core renders the interface accordingly.
a ui object has a unique id.
the id is often speci ed in the xml le.
inside the app code the handle to a ui object is acquired by calling findviewbyid .
for example the following text de nes a button in the xml le.
note that the button text is also speci ed.
button android id id my button ... android text string my button text its handle can be acquired as follows.
note that the lookup id matches with that in the xml le.
button btn button findviewbyid r.id.my button the event handler for an ui object is registered as a listener.
for example one can set the listener class for the previous button by making the following call.
btn.setonclicklistener new mylistener ... in this case the onclick method of the mylistener class becomes the top level user interaction function associated with the button.
next we describe how we extract text for di erent kinds of functions.
for a top level interactive function f e.g.
onclick asdroid identi es the corresponding ui text as follows.
it rst identi es the registration point of the listener class of f. from the point asdroid acquires the ui object handle whose id can be acquired by nding the corresponding findviewbyid function.
the id is then used to scan the layout xml le to extract the corresponding text.
asdroidalgorithm generating keyword cover set.
train s f kwd the keyword cover set whilef6 do sortsby keyword or keyword pair frequency k the top ranked keyword or pair in s x the functions in which koccurs kwd kwd k f f x s s fall the keywords pairs in xg end while also extracts the text in the parent layout.
for example the parent layout of a button may be a dialog.
important information may be displayed in the dialog and the button may have only some simple text such as ok .
we currently cannot handle cases in which the text is dynamically generated.
we found such cases are relatively rare.
some non interactive top level functions also have associated uis for instance the lifecycle methods oncreate and onstart of activity components.
these methods are invoked when the screen of an activity is rst displayed.
while no user interactions are allowed when executing these methods the displayed screen may have enough information to indicate the expected behavior of these methods such as loading data from a remote server.
hence for an activity lifecycle method asdroid extracts the text in the xml layout le associated with the activity.
text analysis.
once we have the text we build a dictionary that associates a type of intent to a set of keywords through training.
we use half of the apps from the benign sources2as the training subjects which account for about of all the apps we study.
during evaluation we use the dictionary generated from the apps to scan over the entire set of apps.
here we assume the training apps are mostly benign.
if an intent appears together with some text in a benign case then the intent and the text are compatible.
we use keywords to represent text and build compatible keyword cover set for each intent.
in particular for each intent type tof interest we identify all the top level functions fthat have tannotated and collect their corresponding texts.
we then use stanford parser to parse the text to keywords.
we populate a universal set sto include all individual keywords and keyword pairs that appear in these functions.
we then use algorithm to identify the smallest set of keywords or pairs that have the highest frequency and cover all the top level functions tagged with t. the algorithm is similar to the greedy set cover algorithm .
it picks the most frequently occurring keyword kat a time and adds it to the keyword set.
then it removes all the keywords that appear in the top level functions in which koccurs as they can be covered by k. it repeats until the set of functions are covered.
we consider keyword pairs are semantically more predictive.
hence we rst apply the algorithm to keyword pairs and keep the pairs that can uniquely cover at least of functions.
then we apply the algorithm to singleton keywords on the remaining functions.
fig.
shows the generated keyword cover set for the send sms intent.
observe some keywords are semantically re2we collect apps from both benign and malicious sources as shown in section .
.
.
.
.
.
.
.
send sms invite friend send ok buy text number register figure the keyword cover set for the sendsms intent.
the yaxis denotes the percentage of top level functions that can be uniquely covered by a keyword pair .
lated to the intent but some are not e.g.
ok and register which occur rarely but do uniquely cover some functions.
further inspection shows that it is due to the malwares in the training pool.
hence we also use human semantic analysis to prune the keyword set e.g.
ltering out ok and register .
the keyword set of httpaccess is similarly constructed containing keywords download login load register and so on.
the cover set of phonecall is much simpler containing only one keyword call .
once we get the keyword cover set we further populate it with its synonyms using chinese wordnet to have the nal dictionary.
compatibility check.
the compatibility check is performed as follows.
given a top level function fwith ui text sand an intent t ifsis incompatible with tand all the intents correlated with t it is considered a mismatch.
note that we consider empty text is incompatible with any intent.
iftis asendsms intent and has a correlated smsnotify intent.
it is not a mismatch regardless of the ui text.
iftishttpaccess the technique checks if the corresponding ui text is compatible.
if not it further checks if tis correlated to any uioperation intent.
if not the intent is consider stealthy.
intuitively it suggests that even an http access is not explicit from the gui text if the data acquired through the http connection are used in some ui component e.g.
fetching and then displaying advertisements from a remote server the http access is not considered stealthy.
.
evaluation we implement a prototype called asdroid anti stealth droid .
we transform the dex le of an app to a jar le with dex2jar and then use wala as the analysis engine.
our implementation is mainly on top of wala.
we have collected apps from three di erent sources.
we aim to detect those with the following stealthy behavior sms sends phone calls http connections and component installations.
hence we only focus on those having the permissions for such behaviors.
particularly since almost all apps have the http permission we select those that have at least one of the other three permissions.
note that despite we introduce six intents in section smsnotify and uioperation do not describe stealthy behavior but rather suppress false alarms.
the sources are the following.
contagio mini dump .
it collects a large pool of potential malware reported by users and existing security .
.
.
.
onclick activity lifecycle methods onreceive others figure breakdown of the top level functions with intents.
activity lifecycle methods include oncreate and onstart of an activity.
onreceive and the other categories do not have associated ui.
tools.
these malicious apps may perform stealthy operations leak user private information or compromise the operating system like a rootkit.
we acquired apps holding the needed permissions.
google play .
this is the o cial apps market holding a lot of android games.
we checked the top free game apps and only of them satisfy our selection criteria.
wandoujia .
this is a popular general android app market in china.
we have checked the most popular game apps on the market and downloaded of them with the needed permissions.
all experiments are performed on an intel core i7 .4ghz machine with 12gb memory.
the os is ubuntu .
.
the detection results are shown in table .
in the table app in the second column denotes the number of tested apps from a speci c source.
intent is the number of api invocations with one of the four kinds of potential stealthy intents.
rep is the number of intent points reported by asdroid as stealthy.
fp is the number of false positives and fn is the number of false negatives.
the corresponding app in parentheses denotes the number of apps in which these intents appear.
note that one app may have multiple intents.
the last three columns show the total numbers.
app in the last three columns is not the simple sum of the app in the corresponding preceding columns.
for example the number of total reported apps is for the contagio source.
it is not the sum of the reported apps in the four categories as one app may be reported in multiple categories.
we make the following observations.
asdroid is able to detect a lot of stealthy behaviors in these apps.
totally asdroid detects that apps perform stealthy operations with true positives i.e.
having at least one true stealthy api call.
note that there are some apps that do not have the intents i.e.
api calls of interest even though they hold the permissions.
since there are no existing oracles to determine stealthy behavior we identify true positives by manually inspecting the results in two ways.
for those api calls that can be reached by testing we determine their stealthiness by executing the apps.
many of the api calls are di cult to reach without a complex sequence of user actions.
since we lack automatic test generation support we perform code inspection instead.
asdroid detects a lot of stealthy behavior in the apps from contagio which is supposed to be a source hosting highly likely malwares.
most of the detected stealthy sms sends and phone calls may cause unexpected charges.
most of the stealthy http accesses are to notify the remote servers the status of device or the app e.g.
a mobile device becomes online .
some of them also leak critical user information.1042table experiment result apphttp sms call install intent rep fp fn intent rep fp fn intent rep fp fn intent rep fp fn intent rep fp fn app app app app app app app app app app app app app app app contagio google play wandoujia total asdroid produces some false positives out of the reported apps .
they are induced by the following reasons asdroid cannot analyze dynamically generated text associated with a ui component the dictionary we use is incomplete some reported intents are along infeasible paths but asdroid does not reason about path feasibility.
the detection outcome for individual apps is denoted by the symbols on top of the bars and their colors in fig.
.
also observe that most false positives belong to the category of http accesses.
some of them are due to the incompleteness of our keyword dictionary.
however most of them are essentially http accesses in advertisement libraries.
these accesses often download advertisement materials and store them to external les that are later read and displayed.
ideally they are not stealthy as the materials are displayed.
however asdroid currently cannot reason about correlations through external resources leading to false positives.
note that most existing static data ow analysis engines on android have the same limitation.
it should be easy to have an additional post processing phase to suppress warnings from advertisement libraries.
the number of false negatives is small apps total .
we manually inspect the apps that are not reported by asdroid to determine false negatives.
in particular we use wala to report all the api calls of interest and then we inspect them one by one manually.
there are such apps.
we found that asdroid missed malicious apps.
most of them are in the category of stealthy install.
as such the detection rate of asdroid is .
the main reason for false negatives is that the current implementation cannot model some of the implicit call edges.
there are also cases that native libraries are used to perform stealthy behavior which is not handled by asdroid.
the false negative http accesses mainly result from the in accuracy of the text analysis.
while asdroid extracted keywords such as download and login that make the stealthy http accesses compatible and thus not being reported these accesses doesn t match the textual semantics.
stealthy http connections are very common although many of them may not be as harmful as the other stealthy behaviors please refer to our case study .
sms sends are another dominant category of stealthy behaviors which echoes the recent studies .
comparison with flowdroid.
flowdroid is a stateof the art open source static taint analysis for android apps.
we ran it on the apps from contagio .
we use the default taint sources e.g.
methods retrieving private information .
for the taint sinks we only keep the sms send and http access methods.
flowdroid ran out of memory for of the apps hence we compare the results for the remaining41.
flowdroid reports sms sends in apps and http access in app that have information leak.
in contrast in the apps asdroid reports stealthy http connections in apps including the one reported by flowdroid with false positive in app and false negatives in apps.
it also reports sms sends in apps including sms sends reported by flowdroid.
for the other sms sends by flowdroid the uis explicitly indicate the behavior.
hence they are not stealthy although they do leak information.
from the comparison we clearly see that flowdroid and asdroid focus on problems with di erent natures.
fig.
shows the breakdown of the top level functions that are attributed with intents.
there are totally such functions.
observe that of such functions are the interactive onclick function and almost of them are activity lifecycle methods that are not interactive but nonetheless have associated ui.
about of them are onreceive of external events and .
of other functions such as the timer handler function timertask.run .
these functions are often not associated with any ui.
we present the analysis time for the apps in fig.
.
most apps about can be detected in mins and a few in mins.
three apps require more than mins.
human inspection disclosed that that they are very complex apps such that asdroid consumes exceptionally large amount of memory which slows down the analysis signi cantly.
we plan to further look into this issue.
.
case studies next we present two more cases.
icalendar is a calendar app infected by malicious code that sends a sms message subscribing to a premium rate service.
the malicious operation is triggered by user interaction in a stealthy way.
the user clicks the app to change a background image and the app increases a counter.
when the counter gets to a message is sent.
fig.
shows a simpli ed code snippet of the process.
variable main represents the main interface layout.
as soon as the app is launched it registers a click listener in oncreate .
when the user clicks the interface showimg is invoked in onclick to reset the background image.
in the mean time the app checks the counter to see if sendsms should be called to send a premium rate sms.
in our analysis two intents uioperation andsendsms are associated with l1and l2in fig.
respectively.
the intents are propagated to the top level function onclick through the call graph.
the ui component associated with the function is the background image without any text which does not imply the sendsms indent.
the correlation analysis also determines that these two intents are not correlated.
it is hence reported as a mismatch.
note that taint analysis tools cannot report the problem because the data involved in the sms send are hardcoded.
hitpp is a game app downloaded from google play.
fig.
shows the code snippet in which a stealthy http access is1043 x x x x n x x x time second x n x x x x n x time second x n n n x x n x x x n x n n x x x x x n x x x time second figure analysis time.
the detection results are also annotated on top of each bar with denoting true positive red x false positive black and n false negative yellow .
since an app may have multiple intents it may be annotated with multiple labels.
the last apps exceeded the max timeout mins.
in class icalendar public void oncreate bundle bundle main.setonclicklistener this public void onclick view view showimg private void showimg if index sendsms l1main.setbackgrounddrawable drawable1 public void sendsms l2smsmanager.sendtextmessage 106xxxx null 921x1 p p figure icalendar example.
in class hitpp extends activity void oncreate bundle bundle initialization ... wigame.init this f11947a... df6mby... true true in class wigame static void init context ctx string s1 string s2 ... b.a ctx s1 in class b static void a context ctx string str new b. str ctx .start !b .run at line in class b extends thread void run string str wigame.getdeviceid httpget httpget new httpget str httpaccess httpclient.execute httpget without a lhs variable httpclient.getconnectionmanager .shutdown figure hitpp example.
made when the app is initialized.
the initialization at line transitively starts a thread at line .
the thread entryis at line .
the thread starts an http connection at line and then shuts it o right after at line .
the app does not receive or display any data from the remote server.
we suspect the http access is to inform the remote server about the start of the app.
since there is no ui text associated with the top level oncreate method and there are no correlated intents the http access is reported by asdroid.
this is a very typical kind of stealthy http access reported by asdroid.
.
limitations asdroid has the following limitations.
the current ui analysis is simply based on textual keywords which may be insu cient.
it is possible that apps use images or obfuscated texts e.g.
text containing keyword send but having no relation with sending a message .
asdroid will have di culty in catching the intention of the ui.
we will study applying more advanced text analysis or image analysis.
currently to avoid false positives asdroid relies on certain rules in detecting intent correlation and avoids reporting some intents incompatible with ui if their correlated intents are compatible.
this seems to be working ne given that android malwares are still in their early stage.
in the future if an adversary has the prior knowledge of asdroid he could obfuscate a malicious app to induce bogus correlations to avoid being reported.
we envision a more sophisticated program analysis component will be needed which may leverage testing or symbolic analysis e.g.
use symbolic analysis to determine if two intents are truely correlated .
asdroid currently cannot reason about correlations through external resources leading to false positives.
note that most existing static data ow analysis engines on android have1044the same limitation.
it could be mitigated by modeling external accesses.
currently asdroid does not support native code or re ection.
asdroid misses some intercomponent communication correlations.
we could leverage epicc to get better coverage in our future work.
.
related work taintdroid applies dynamic taint analysis to android apps to prevent information leak.
gilbert et al.
extended the technique to track implicit ows .
hornyack et al.
developed appfench to impose privacy control on android applications .
arzt et al.
investigated the limitations of using runtime monitoring for securing android apps .
they used unintended sms sending as an example.
the essence of the technique is information ow tracking.
flowdroid is a very recent static taint analysis tool.
these techniques cannot detect stealthy behavior as such operations may not leak information as evidenced by the comparison with flowdroid in section .
enck et al.
developed a simple static analysis that can detect sms sends with hardcoded sms numbers and phone calls such as pre x tel and substring .
however these patterns are very limited and not all such operations are malicious.
elish et al.
proposed to detect malicious android apps by determining the absence of data dependence path between user input action and a sensitive function.
however dependence is not the key characteristic of stealthy behavior.
in our experience sms sends triggered by user inputs can be malicious.
furthermore many benign http accesses are not triggered by any user action e.g.
an email app might connect to the server frequently to check new emails in background.
droidranger developed by zhou et al.
employs both static and dynamic techniques to detect malware based on signatures derived from known malware such as premiumrate numbers and content of sms messages.
hence droidranger has to maintain a signature database that may change signi cantly overtime.
and it also has runtime overhead.
some existing work tries to capture android gui errors or improve privacy control via gui testing .
gross et al.
developed exsyst that uses search based testing to improve gui testing coverage.
mirzaei et al.
applied symbolic execution to generate test cases for android apps .
asdroid could potentially leverage these techniques to generate test cases for bug report validation.
recently pandita et al.
proposed whyper to analyze an app s text description and then determine if the app should be granted certain permissions .
both whyper and asdroid leverage text analysis.
however they have di erent goals and asdroid works by analyzing both apps and uis.
.
conclusion we propose asdroid a technique to detect stealthy malicious behavior in android apps.
the key idea is to identify contradiction between program behavior and user interface text.
we associate intents to a set of api s of interest.
we then propagate these intents through call graphs and eventually attribute them to top level functions that usually have associated uis.
by checking the compatibility between the intents and the text of the ui artifacts we can detect stealthy operations.
we test asdroid on apps that are potentially problematic by looking at their permissions.
as droid reports apps that have stealthy behaviors with false positives and false negatives.
.