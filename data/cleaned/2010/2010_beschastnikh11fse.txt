leveraging existing instrumentation to automatically infer invariant constrained models ivan beschastnikh yuriy brun sigurd schneider michael sloan michael d. ernst computer science engineering computer science university of washington saarland university ivan brun mgsloan mernst cs.washington.edu sigurd ps.uni saarland.de abstract computer systems are often difficult to debug and understand.
a common way of gaining insight into system behavior is to inspect execution logs and documentation.
unfortunately manual inspection of logs is an arduous process and documentation is often incomplete and out of sync with the implementation.
this paper presents synoptic a tool that helps developers by inferring a concise and accurate system model.
unlike most related work synoptic does not require developer written scenarios specifications negative execution examples or other complex user input.
synoptic processes the logs most systems already produce and requires developers only to specify a set of regular expressions for parsing the logs.
synoptic has two unique features.
first the model it produces satisfies three kinds of temporal invariants mined from the logs improving accuracy over related approaches.
second synoptic uses refinement and coarsening to explore the space of models.
this improves model efficiency and precision compared to using just one approach.
in this paper we formally prove that synoptic always produces a model that satisfies exactly the temporal invariants mined from the log and we argue that it does so efficiently.
we empirically evaluate synoptic through two user experience studies one with a developer of a large real world system and another with students in a distributed systems course.
developers used synoptic generated models to verify known bugs diagnose new bugs and increase their confidence in the correctness of their systems.
none of the developers in our evaluation had a background in formal methods but were able to easily use synoptic and detect implementation bugs in as little as a few minutes.
categories and subject descriptors d. .
debugging aids general terms algorithms reliability keywords log analysis temporal invariant mining model inference synoptic .
introduction application of formal methods such as specification and verification of systems during the design stage is a promising means of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.
.
.
.
get http .
check out.php .
.
.
get http .
check out.php .
.
.
get http .
invalid coupon.php .
.
.
get http .
valid coupon.php .
.
.
get http .
check out.php .
.
.
get http .
reduce price.php .
.
.
get http .
get credit card.php .
.
.
get http .
reduce price.php .
.
.
get http .
check out.php .
.
.
get http .
check out.php .
.
.
get http .
get credit card.php .
.
.
get http .
get credit card.php line parsing ?
ip .
?
type .
.php execution mapping k ip log regularexpressions check outcheck outget credit cardvalid couponinvalid couponreduce price1 3111generated model 8synopticfigure top a log with line numbers for an online shopping cart and two complete regular expressions for processing this log with synoptic.
bottom the generated synoptic model.
in the model rectangular diamond oval nodes indicate initial terminal intermediate nodes.
edge labels indicate transition probabilities.
the subscript to the right of each node lists the log line numbers corresponding to the partition.
this application contains a bug that is easily noticed in the generated model processing an invalid coupon incorrectly reduces the shopping cart s total price.
preventing implementation bugs.
although such formal methods are popular in limited domains e.g.
avionics only rarely do tools from the formal methods community get used by everyday developers.
more commonly developers rely on debugging.
logging system behavior is one of the most ubiquitous simple and effective debugging tools.
developers instrument key locations in the code to gain insight into the state of a process the execution sequence and the presence or absence of certain events.
logging is so important that production systems at companies like google are instrumented to generate billions of log events each day.
these events are stored for weeks to help diagnose bugs .
however logs are analyzed primarily by hand or with ad hoc tools.
the goal of our work is to infer concise accurate models of system behavior from logs.
the inferred models aim to help developers in three ways help find bugs increase developers confidence in the absence of certain bugs and improve developers understanding of their systems.
we present the design and evaluation of a tool called synoptic which processes the logs most systemsalready produce and requires developers only to specify a set of regular expressions for parsing the logs.
synoptic generates a model similar to a finite state machine that satisfies the temporal invariants mined from the logs.
by leveraging existing logs synoptic produces models with details the developer already considers to be helpful in aiding understanding.
more generally synoptic offers developers who have little expertise in formal methods a means to consider their systems more formally.
synoptic bridges the gap between the culture of the average developer who practices logging for debugging with advanced techniques developed by the formal methods community.
synoptic differs from prior model generation tools by its versatility and by imposing few requirements on the developer.
to use the tool developers neither need to specify their systems as part of the design identify properties for the tool to verify nor modify their code.
instead synoptic mines three kinds of temporal invariants from existing logs and uses these to generate a concise model satisfying the invariants.
developers only provide a set of regular expressions to parse events from the logs.
with this approach synoptic does not restrict developers to a particular log format and allows developers to specify the events to include in the model.
figure shows a web server log for a shopping cart application.
using the two listed regular expressions synoptic parses the log into three traces one for each of the three user ip addresses accessing the server figure .
synoptic then mines temporal invariants that hold in those traces and uses the invariants to infer a model of the system bottom of figure .
the model clearly illustrates a bug that would be difficult to find by examining the log directly applying an invalid coupon allows the user to reduce the price.
not only can synoptic help a developer find this bug it can also increase the developer s confidence that the bug has been successfully removed.
for example the developer can run synoptic on logs generated by a new version of the system and compare the new model with the prior model.
we evaluated synoptic both theoretically and experimentally.
section formally proves that synoptic produces a model that satisfies all the true temporal invariants mined from the log and none of the invariants that are not satisfied by the log.
further we argue that synoptic s exploration of the model space is efficient and produces concise models.
additionally to demonstrate synoptic s ability to produce useful representations in practice we evaluated it in two user experience studies section .
we first report on a study with a developer working on reverse traceroute a distributed system that determines the likely reverse internet route between two hosts.
reverse traceroute has been in deployment for over months has handled a total of .
million requests to date and has been recently internally deployed by a large popular and ubiquitous internet company.
second we report on the experiences of undergraduate students who used synoptic in a distributed systems course.
the students applied synoptic to logs generated by their implementations of a distributed version of a cache coherence protocol .
in our evaluation synoptic generated models on logs up to events that represent over unique system executions.
most developers in our studies found the generated models helpful in understanding their systems.
synoptic models increased developer confidence in the correctness of their implementations helped identify previously unknown bugs and confirmed the existence of known bugs.
next we motivate and explain how synoptic works by describing bisimh the central algorithm synoptic uses.
.
bisimh generating models from logs synoptic uses a hybrid refinement and coarsening algorithm called bisimh.
our prior workshop paper proposed this algorithm without1 input log l regular expressions regexps let tracegraph extract l regexps let i mineinvariants tracegraph let v e partition tracegraph while v e does not satisfy invariants i p event!boolean p partition that will be split let p p selectsplit v e i let p1 fevent2pjp event g let p2 fevent2pj p event g v v fpg fp1 p2g e f p3 p4 r 2v v rj9event 12p3 9event 22p4 event 1revent 22tracegraphg end while v e ktail v e i output v e figure the bisimh algorithm.
section describes the extract mineinvariants partition selectsplit and ktail procedures.
providing a formal analysis or reporting on user experience with the tool .
the rest of this section explains the algorithm in detail by walking through its pseudo code listed in figure and by illustrating how synoptic would process the log in figure .
for a more formal treatment see section .
.
log parsing synoptic constructs a system model from a set of observed system execution traces.
it takes as input a log file containing the execution traces and a set of user defined regular expressions.
synoptic uses the regular expressions to parse the log file and extract from some of the log lines an event instance a triplet containing a trace identifier a timestamp and an event type .
trace identifiers are used to group together event instances from the same trace .
synoptic requires that the event instances in a trace be totally ordered using their timestamps.
therefore no two event instances in a trace may have identical timestamps.
an event type can be an arbitrary string and is usually defined by the developer as something that conveys important information about the system.
for example section presents two synoptic generated models in which an event type represents an executed method s name and the state of a node in a distributed system.
a trace can be considered to be a linear graph each vertex is an event instance and the edges represent the total ordering.
we term the union of such graphs a trace graph .
the trace graph is built from the log using the provided regular expressions line in figure .
recall the shopping cart application.
figure shows the log and the two complete regular expressions that synoptic uses to parse the log into three traces one per unique ip in the log the php script names denote the trace event types.
figure shows the three traces parsed from the log.
for example the trace corresponding to the ip .
.
.
ish0 check outi h1 valid couponi h2 reduce pricei h3 check outi h4 get credit cardi.
here the integer timestamp is derived implicitly from the order of lines in the log.
.
mining invariants from the trace graph to guide model generation synoptic mines three kinds of temporal invariants relating event types from the trace graph line in figure a always followed by b written a!b .
whenever the event type aappears the event type balways appears later in the same trace.
a never followed by b written a6!b .
whenever the eventcheck outcheck out get credit cardvalid couponinvalid couponreduce pricecheck outcheck out get credit cardreduce pricecheck out get credit card74.
.
.
.
.
.
.
.
.
7figure trace graph parsed from the log in figure .
each execution corresponds to an ip address that accessed the web application.
the subscript to the right of each node lists the line number of the log line from which the event instance was extracted.
type aappears the event type bnever appears later in the same trace.
a always precedes b written a b .
whenever the event type bappears the event type aalways appears before bin the same trace.
the missing symmetrical invariant never precedes defined as a never precedes biffbcan be generated only when no awas yet generated is equivalent to the never followed by invariant.
we term these relations invariants because they succinctly capture temporal event type relationships that must hold true over all the input traces.
the trace graph in figure yields such invariants.
two examples are reduce price6!valid coupon and invalid coupon !check out .
section .
justifies our use of these particular invariant types and section .
explains how these invariants are mined.
next we introduce synoptic models.
.
synoptic models and the initial model the synoptic model is a partition graph of the trace graph.
given a partitioning of the original vertices each vertex in the model is one partition.
directed edges in the model are formed through existential abstraction.
that is a directed edge between two vertices indicates that there exists a pair of event instances in the corresponding partitions that are connected by an edge in the trace graph.
a further constraint is that each partition contains event instances of only one particular event type.
the resulting relational model makes minimal assumptions about the underlying process that produced the logged event instances.
for a more complete discussion concerning our model choice see .
an important property of synoptic models is that each trace in the input log is accepted by a model constructed from the corresponding event instances in the sense that each trace maps to a valid path in the model .
however a synoptic model is also generative it may accept traces that were not present in the log.
the bisimh algorithm starts with an initial model constructed using partition on line of figure .
in this model there is one partition per event type containing all the event instances of that type.
figure shows the initial model for the trace graph in figure .
by construction the initial synoptic model captures two important kinds of temporal properties for any two adjacent event instances in a trace in the log.
first if an event instance of type ais at some point immediately followed by an event instance of type bin the log then there must be an edge from atob.
second if an event instance of type ais never immediately followed by an event instance of type bin the log then there is no edge from atob.
check outget credit cardvalid couponinvalid couponreduce price3 1043figure initial model corresponding to the trace graph in figure .
the initial model is therefore the most compact or abstract model plausible based on the logged traces.
the least compact and most concrete model is the trace graph in which each partition contains a single event instance.
this model makes no generalizations and overfits to the input traces.
.
refinement and coarsening coarsening and refinement are dual operations on a synoptic model.
starting with the initial model synoptic first performs model refinement shown as an iterative process in lines of figure .
this algorithm is a modification of a partition refinement algorithm introduced by elomaa .
synoptic refines i.e.
splits partitions until it reaches a model that satisfies all the mined invariants.
next synoptic uses coarsening to merge those partitions that were needlessly refined due to an imperfect splitting heuristic line in figure .
the coarsening step is constrained to not violate the mined invariants satisfied during refinement.
synoptic outputs the model when it is unable to coarsen it any further.
.
.
refinement the refinement goal of bisimh is to pick a minimal sequence of splits so that the resulting graph is the coarsest graph that satisfies a set of invariants.
this problem is np hard so an efficient algorithm might not yield the optimal result.
for an example illustrating refinement suboptimality see .
bisimh performs splits as long as there exists some mined invariant that is not satisfied.
bisimh uses an fsm based model checker to check whether a model satisfies a mined invariant.
it converts each invariant into a small fsm that accepts traces satisfying the invariant.
it then updates the fsms as it traverses the model graph.
if the model does not satisfy an invariant the model checker outputs a counterexample path.
for example the invariant valid coupon !invalid coupon mined from the log in figure is not true in the model in figure figure shows a counterexample path.
having identified a set of counterexamples that violate the mined invariants bisimh follows the counterexample guided abstraction refinement cegar approach to determine a set of candidate partitions for each of which there exists a split that removes at least one of the counterexamples.
bisimh identifies these partitions heuristically by tracing each counterexample stepwise in parallel in the input traces and in the model.
in the traces only a prefix of the counterexample path will be present otherwise the counterexample would not violate an invariant .
bisimh finds the longest such prefix and the last partition of this prefix in the model becomes a candidate for refinement this partition allows a spurious transition in the model that allows for the counterexample path to exist.
for example the longest such prefix for the counterexample path in figure ends in the check out partitions.
this is because checkoutstitches together two traces from the log two left most traces in figure into a trace that violates the valid coupon6!invalidcoupon invariant.
to refine a candidate partition i.e.
to eliminate the counterex check outcheck outvalid couponreduce priceinvalid couponreduce pricecheck outget credit card14623810 11figure a path through the initial model in figure that violates the mined valid coupon6!invalid coupon invariant.
ample path the event instances in this partition are divided into two sets based on whether they can or cannot be reached from the partition immediately preceding the candidate partition in the prefix.
in line of figure selectsplit obtains a predicate pthat distinguishes these two event instance sets and lines and introduce two new partitions p1andp2 corresponding to these two sets.
figure illustrates a refinement of the initial model in figure to eliminate the counterexample in figure .
in this case the predicate pseparates the event instances in the check out partition into those that can or cannot be reached from the reduce price partition.
we experimented with two kinds of predicates.
synoptic uses the one described above it separates event instances in the candidate partition based on an incoming edge from a partition that immediately precedes the candidate partition.
we also tried a predicate that separates event instances in the candidate partition based on an outgoing edge representing the spurious transition it separates event instances in the candidate partition into sets based on whether they can or cannot make the spurious transition.
though we did not show this formally in practice we found the second strategy to be less optimal than the first.
it is also possible to split the candidate partition simultaneously on an incoming and on an outgoing edge.
though we have not tried this we think this may work best.
in our future work we intend to further study the splitting predicate s impact on the algorithm.
typically the refined model violates several invariants and candidate partitions must be ranked to decide which one to split first.
synoptic employs a two class ranking it examines all counterexamples in an arbitrary order and performs the first split that validates an invariant i.e.
eliminates the last counterexample for that invariant .
if no such split is available because more counterexamples exist for each invariant bisimh picks a split nondeterministically.
this ranking introduces nondeterminism and bisimh might perform unnecessary splits.
.
.
coarsening bisimh may end up refining more than it needs to.
when this happens the model will contain partitions that can be merged without violating the satisfied invariants.
after refinement bisimh coarsens the model to merge such partitions line in figure .
for coarsening bisimh uses ktail equivalence .
ktail is a coarsening algorithm that starts with the most fine grained model.
it stops once there is no pair of k equivalent partitions i.e.
no two partitions that are roots of sub graphs identical up to depth k. at each step the algorithm merges one pair of ktail equivalent partitions chosen nondeterministically.
bisimh runs ktail with k label equivalence to produce the most concise models.
it starts with the final refined graph under the extra constraint that all merges do not unsatisfy any invariants.
the resulting merged model is locally minimal merging any two partitions will violate some invariant.
.
the impact of mined invariants on bisimh bisimh uses the mined invariants to establish a well defined get credit cardvalid couponinvalid couponreduce pricecheck out check outcheck outcheck outcheck out125436 12910figure a refinement of the model in figure that eliminates the counterexample path in figure .
the edge between the reduce price partition and the check out partition induces a split of check out thecheck out event instances reachable from reduce price are split out.
the two new check out partitions with the contained check out event instances are shown in bold.
this model is equivalent to the final model shown at the bottom of figure .
termination criterion for refinement and also to guide refinement in its choice of partition to refine.
this use of invariants is an important feature of bisimh.
to see this suppose the set of invariants is empty.
in this case refinement would terminate with a model that is the quotient under label equivalence i.e.
the initial model.
this model is often too compact to capture key properties of the log and is overly generative.
on the other hand suppose that the invariant set includes all possible temporal log invariants expressible in ltl.
then the algorithm will terminate when for all partitions a if an event instance in ahas a successor event instance in a partition b then every event instance in ahas a successor event instance in b in the model.
in this case the final model is the quotient under bisimulation i.e.
a graph that satisfies the same set of ltl formulae as the trace graph.
in our experience the bisimulation quotient is usually too similar to the trace graph and thus too fine grained to be considered concise.
our choice of the three invariant types is a compromise between the above two extremes.
in our experience the models derived using this set of invariants are accurate yet sufficiently generative for the kinds of applications we are considering e.g.
improving developer understanding of how the system operates .
these invariant types are also exactly the most frequently observed specification patterns formulated by dwyer et al.
with scope constrained to a trace i.e.
global scope .
the translation is not one to one a!bis dwyer s existence pattern when aisstart see definition below and is otherwise dwyer s response pattern.
another example is 8b a b which is dwyer s universality pattern.
in our experience these invariants were sufficient for capturing key temporal properties of the systems that produced the logs we considered.
users can write java code to define custom synoptic invariants.
however all of the users in our case studies section successfully used synoptic without even knowing about its use of invariants.
in the next section we define log and model formalism and prove important positive results about the bisimh algorithm.
.
formal evaluation this section proves the correctness of our algorithm and explains why it is efficient and is able to infer concise models in practice.
sections .
and .
define the formalisms.
section .
proves that bisimh always halts and that the final model satisfies exactly the invariants mined from the input log.
section .
proves an important result for improving model search efficiency and section .
deals with model size.
.
definitions two special event types start andend are added inter nally by synoptic to keep track of initial and terminal events in the traces.
definition event types .a set of event types is a finite set alphabet e fstart endg.
definition trace .letebe a set of event types.
then for all n2n a finite trace is an ordered sequence of event types l2en such that the first element of lisstart and the last element is end .
the length of lisn .
definition log .a log lis a set of traces.
the set of event instances in a log is the collection of elements in the traces in that log.
each trace element is a unique event instance indexed by its trace and position within that trace.
definition event instances .letebe a set of event types.
let l be a log over e. then an event instance is a triplethe l iisuch that e2eoccurs in the log trace l2lat position i2n.
edenotes the set of all such event instances for l. an event instance relation is a set of pairs of elements of e. for example one representation using to represent the event instanceh0 l 1i etc.
of the event instance relation next on the log trace l h0 4iisfh0 1i h1 2i h2 3i h3 4ig.
this paper s examples only use this next relation although all the results generalize to arbitrary relations.
definition event instance relation .let ebe a set of event instances.
then r e2is an event instance relation.
a partitioning of a finite set of event instances eis a finite set of disjoint exhaustive subsets of e. each subset is called a partition and contains event instances of the same event type.
definition partitioning .let ebe a set of event instances.
then p p e is a partitioning of eif8distinct p q2p p q and e s p2pp and8p2p all e2pare of the same event type.
each p2pis called a partition.
we enforce the condition that for a valid partitioning all instances of the start event type are in a single partition and all instances of the end event type are in a single partition.
that is for all e12p1 e22p2 e1 e2instances of start p1 p2and e1 e2instances of end p1 p2.
a relational model is a partition graph.
the largest most nodes relational model for a log lis the trace graph the set of disconnected subgraphs one for each trace l2l with a vertex for each event instance and edges only between consecutive event instances in l. other relational models can be generated by merging vertices that represent event instances of the same event type and removing redundant edges .
definition relational model .let ebe the set of event instances in a log.
let rrbe a family of relations over eindexed by r. then the relational model is a directed graph m hmv mai such that mvis a partitioning of eanda hp1 p2 ri2ma mv mv rr iffp1 p22mvand9 e1 e22 esuch that e12p1 e22p2 and h e1 e2i2rr.
definition complete path .a path in a model is complete if it starts at the start partition and ends at the end partition.
a relational model maccepts a trace if the event instances of the trace form a complete path in m. 1when viewing a model the user can optionally hide these nodes and instead have synoptic specially mark the partitions containing any initial and terminal events as rectangles and rhombuses respectively.
the models pictured in this paper were all generated in this way.definition trace acceptance .letn2nand let l hstart e1 en endibe a trace of length n. then a relational model m accepts liff9p hpstart p1 pn pendisuch that81 i n ei2piandpis a complete path in m. note that by construction a relational model mfor a log laccepts all traces in l. to see this consider a trace l hstart e1 en endi2l.
the next relation corresponding to rnext holds for all pairs of adjacent event instances that is i n h ei ei 1i2rnext as well ashstart e1i2rnextandh en endi2rnext.
this means thatlmaps to a complete path in mand therefore maccepts l. .
invariants we consider three invariants that relate pairs of event types definition event invariant .letaandbbe two event types.
then an event invariant is a property that relates aandbin one of the following three ways a!b in a model if some partition on a complete path contains an event instance of type a then at least one later partition along that path contains an event instance of type b. a6!b in a model if some partition on a complete path contains an event instance of type a no later partition along that path contains an event instance of type b. a b in a model if some partition on a complete path contains an event instance of type b at least one earlier partition along that path contains an event instance of type a. definition invariant satisfiability .letmbe a relational model and let ibe an event invariant.
msatisfies iiff8p a complete path inm iis true of p. each of the three event invariants may relate any pair of event types.
thus for a set of event types ethere can be at most 3jej2 invariants.
synoptic mines the above invariants by collecting three kinds of counts across all the traces.
each trace is traversed once in the forward and once in the reverse direction to count 8a occurrences the number of event instances of type a 8a bfollows the number of event instances of type a that are followed by at least one event instance of type b and 8a bprecedes the number of event instances of type b that are preceded by at least one event instance of type a. the invariants are then determined by using the following equivalences a!b follows occurrences a6!b follows a b precedes occurrences .
bisimh termination this section proves that bisimh terminates theorem and that the final model satisfies all the event invariants in the log theorem and no others theorem .
theorem bisimh terminates .bisimh makes a finite number of iterations no more than the number of event instances .
proof of theorem .after every bisimh iteration the model has more partitions than the model before the iteration as some partition is split into two new partitions.
the maximal model has a finite number of partitions each event instance is in its own partition except the start andend instances and satisfies all the mined invariants.
therefore bisimh can make no more iterations than there are event instances.theorem true invariant satisfiability .bisimh produces a final model that satisfies all the event invariants that are true for a log.
proof of theorem .the termination condition for bisimh is that the final model satisfies all the invariants mined from the log.
the maximal model trivially satisfies all those invariants.
therefore bisimh either terminates with that model or a smaller model that also satisfies the invariants.
theorem false invariant unsatisfiability .letlbe a log with event instances eand event types e. let m hmv maibe a relational model over ewith a family of relations rr.
let ibe an event invariant that is not true of l. then m does not satisfy i. proof of theorem .since iis not true for l there must be a trace l2lfor which iis not true.
since there exists a path in mcorresponding to l that path must start with start and end with end and must not satisfy i. therefore mdoes not satisfy i. .
improving model search efficiency the previous section proved that regardless of which partitions bisimh splits the algorithm always finds a model that satisfies exactly the log invariants.
this is an important theoretical result but a splitting strategy must be efficient in practice since refinement is expensive a log with dozens of event types will generally satisfy hundreds of invariants of the types we are considering.
checking these invariants is costly especially when the model grows to a large size.
in this section we prove that once bisimh satisfies an invariant it never again violates it theorem .
therefore invariants that have been satisfied do not need to be re checked in finer models.
this reduces the number of model checking runs bisimh needs to perform making it more efficient.
theorem invariant preservation .letlbe a log with event instances eand event types e. let m hmv maibe a relational model over ewith a family of relations rr.
construct a new relational model m0 hm0 v m0 aias follows .
select one partition p 2mv jpj .
.
split p into two nonempty partitions p0and p00.
.
let m0 v mvnfpg fp0 p00g.
.
compute m0 ausing the family of relations r r. for all event invariants i m0satisfies i. it is an immediate corollary that m0satisfies all invariants that m does and that are true in the log.
proof sketch the proof considers the differences between mand m0 and relies on the fact that these differences are confined to the region around the refined partition p. consider some path p0inm0 that might violate invariant i. that path is made up of edges each of which comes from some trace which means for each edge there is a corresponding edge in m. therefore there is a corresponding path pinmthat goes through partitions of the same event types.
since the event types along both paths are identical then either both or none of the paths satisfy i. but since msatisfies i so must m0.
proof of theorem .without loss of generality let ha bibe the pair of event types that irelates.
we will now show that all paths in m0must satisfy i. consider a complete path p0inm0.
for any two partitions connected by an edge in p0there must exist at least one pair of event instances one in each partition that is related by some relation insome trace.
for each edge in p0choose such a pair of event instances to construct a sequence of event instances s. now consider the unique path pinmthat corresponds to s. every partition in pcontains event instances of the same type as the corresponding partition in p0 in fact p s partition is a superset ofp0 s .
assume p0violates i. consider three cases case iisa!b.
there must be some partition in p0with an event instance of type asuch that no subsequent partition in p0contains an event instance of type b. therefore no subsequent partition in pcontains an event instance of type b. but msatisfies i. contradiction.
case iisa6!b.
there must be some partition in p0with an event instance of type bthat follows a partition with an event instance of type a. then pmust also violate i. contradiction.
case iisa b. there must be some partition in p0with an event instance of type bsuch that no earlier partition in p0contains an event instance of type a. then no earlier partition in pcontains an event instance of type a. but msatisfies i. contradiction.
.
maintaining a small model size synoptic s aim is to present to a developer the smallest model fewest nodes satisfying the mined invariants.
large models are often too complex and no better than the raw log.
in this section we explain how the cegar approach leads bisimh towards concise models.
we argue that refinement always makes provable progress towards satisfying an invariant.
therefore bisimh rarely performs splits that make the model larger than it needs to be.
as a reminder the cegar approach detailed in section .
.
works as follows.
first bisimh generates a counterexample trace e.g.
figure that is accepted by the model and violates a mined invariant valid coupon6!invalid coupon .
bisimh then traces along the counterexample trace in the model and in the input traces to find the longest prefix of partitions that exists as a sequence of corresponding event type instances in at least one input trace.
the last partition in this prefix is refined figure .
two cases are possible case the refined model does not accept the counterexample trace.
consider the set of trace equivalence classes two traces are in the same class if the paths of the two traces in the model are equivalent after removing all iterations through loops in the model.
a split that eliminates one loop free trace from an equivalence class eliminates all traces in that class.
thus eliminating a counterexample always eliminates an entire class of counterexamples that violate the invariant.
since there are a finite number of loop free paths in a model eliminating a class makes progress toward satisfying the invariant.
case the refined model accepts the counterexample trace.
consider the prefix corresponding to the counterexample trace in the refined model.
this prefix is shorter than the previous prefix by at least one partition the partition that was refined .
because any prefix must be finite the refinement makes progress toward eliminating the counterexample trace from the model towards case .
because bisimh considers one counterexample at a time a refinement may split a partition suboptimally.
that is a split partition may need to be split again to help eliminate another counterexample even though a single split might suffice to help eliminate both counterexamples.
to counteract such suboptimal splits bisimh uses coarsening section .
.
.
.
experience with synoptic we performed two case studies to evaluate synoptic s ability to produce concise and useful representations in practice.
first wecarried out a user study with a developer working on the reverse traceroute system that determines the likely reverse route from an arbitrary destination on the internet to a source host section .
.
synoptic analyzed the coordinator node logs that contained debugging event instances generated by the system.
second we introduced synoptic as a tool for use in an undergraduate distributed systems class of students section .
.
the students were tasked with designing and implementing a cache coherence protocol and had to draw a finite state machine of their design run synoptic on their implementation and explain any observed differences.
the students used synoptic during development and testing while the reverse traceroute developer used synoptic on logs generated in production.
we therefore believe that synoptic can be helpful during all stages of a typical software engineering process.
overall we found that synoptic was useful for finding new bugs section .
for increasing developer confidence section .
and for building understanding section .
.
.
reverse traceroute study reverse traceroute is a distributed system that determines the likely reverse traceroute from an arbitrary destination on the internet to a source host.
reverse traceroute relies on a distributed set of internet vantage points hosted by planetlab and uses a variety of methods to find each segment of the reverse route such as ip record route and timestamp options and relies on ip spoofing from planetlab hosts.
reverse traceroute has been in live deployment for over months and since that time it has had hundreds of distinct users and has handled a total of .
million requests.
today it gets tens of thousands of requests per day.
recently a large popular and ubiquitous internet company has deployed the system internally.
we carried out a user study with a developer working on the system to study a log of event instances.
to generate this log the developer spent a total of minutes to add a total of lines of logging code to the system.
we then wrote four regular expressions to process the log.
the log was divided into traces by measurement based method names a single trace corresponded to a sequence of method calls made to determine the reverse route for a particularhsource destinationipair.
synoptic took .
minutes to generate the final graph from the input log on an intel i7 .
ghz os x machine with 8gb of ram.
because this graph contained many rare edges i.e.
edges with low transition probabilities we showed the developer both the full graph as well as a graph that omitted edges with low transition probability.
the second type of graph is shown in figure .
we then performed a talk aloud user study with the developer by showing him synoptic derived graphs explaining to him what they represent and asking him to talk through his observations.
.
distributed systems course assignment in the university of washington undergraduate distributed systems course2 groups of students designed and implemented a peer to peer facebook like social network.
the project was divided into multiple assignments one of which was to implement the distributed version of a cache coherence protocol between a single master node and some number of replica clients.
for this assignment the students were to record their design as a fsm diagram implement their design apply synoptic to logs generated by their implementation and observe and explain any differences between the synoptic output and their initial fsm diagram.
for testing the students used a simulated environment in which nodes executed in a single process and communicated via a centralized simulator manager.
the simulator provides the option of reordering losing and duplicating messages as well as randomly failing and restarting nodes.
the simulator logged common event types like message sent received and lost and file read and written and also allowed student node code to log user defined event types.
although the simulated system was distributed the simulator produced totally ordered logs event instances were serialized through the central simulator manager.
the students were also given a set of synoptic regular expressions for processing logs generated by the simulator.
all groups completed the assignment.
due to space constraints sections .
.
showcase just a few of the synoptic diagrams generated by the students and quotes just a few of their reports on their experiences with synoptic.
.
finding bugs in code synoptic models capture event type orderings and co occurrence frequencies among event types.
the absence of an edge could indicate that the log is incomplete.
however if the behavior is supposed to occur at all times or with high frequency an unexpected graph topology can be an indicator of a latent bug.
reverse traceroute study.
the reverse traceroute developer identified one new and important bug using the synoptic model within the first two minutes of seeing the model.
all measurements made by the system must eventually terminate in either the do reach callback or the do fail callback methods.
the developer thought that all traces reaching these methods terminated.
the graph showed otherwise some of the traces continued past these callbacks.
the model in figure illustrates these buggy transitions with bold dashed emphasis.
the developer hypothesized that this bug is caused by concurrency in the measurement code.
the developer also observed that the tool offers a light weight means of verifying that some previously observed buggy behavior is not present after a bug fix and that it may help to rule out bug fixes that fail to eliminate buggy behavior.
distributed systems course.
of the groups groups found bugs in their implementations with synoptic.
synoptic models effectively capture event type orderings and all three of the bugs had to do with illegal message orderings.
one group observed that a transition that was expected never occurred the node seemed to never execute the write command after processing it.
they then fixed the bug and used synoptic to confirm that it did not appear in the traces we did find a bug in the graph.
if you follow the append path in the final graph you can see that it goes from append !send!write.
in the old graph the append !send but dies instead of passing it onto write.
a different group found a bug in which they mistakenly sent the wrong type of packet we had few places where we sent the wrong type of packet in the code.
for example we sent rdc when we had to send wdc.
when looking at the synoptic diagram these kinds of mistakes were easy to find.
.
increasing developer confidence synoptic models can succinctly represent thousands of execution traces with a few nodes in a graph.
a single compact diagram that consolidates many executions gives developers confidence that they will not overlook any behaviors present in the log.
moreover do measurementsdo fail callbackget next hopreverse hops assume symmetric do measurementsreverse hops assume symmetric peekreverse hops tr to src do measurementsget next hopcheck cache reverse hops assume symmetric peekreverse hops tr to srcdo reach callbackdo fail callbackget next hopdo reach callbackreverse hops ts reverse hops rrreverse hops assume symmetric0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.01figure synoptic model for a reverse traceroute input log of event instances.
rectangular nodes are start nodes and diamond nodes are terminal nodes.
edge labels indicate transition probability.
for clarity certain edges and nodes are omitted.
the manually bold dashed lines indicate a new bug that was discovered by the developer.
the manually shaded terminal nodes make up the set of methods exhibiting a bug known to the developer.
before viewing the synoptic graph the developer thought the bug affected only two of these eight nodes.
developers often recognized expected patterns and considered them to be important evidence that the system worked as expected.
reverse traceroute study.
the reverse traceroute developer was often prompted by the model to try to explain various patterns.
patterns that were simpler and more noticeable like self loops on nodes elicited more attention.
for example upon noticing a self loop on one of the nodes the developer mentioned that this indicated that a specific type of measurement was re tried and that this was correct behavior.
distributed systems course.
of the groups in the class reported that synoptic increased their confidence in their implementations.
in many cases the students recognized expected patterns.
figure illustrates two sets of diagrams generated by a group that felt that they acquired additional confidence in their system by using synoptic.
the figure shows four models with each pair corresponding to a client andserver processes in the system.
the group decided to use a combination of messages and states for their event types e.g.
create is a file create request message sent by the client to the server while e.g.
readonly state is the state of the client when it holds a shared read lock on the file.
to more easily follow the sequence of event types the students generated two sets of models for two distinct scenarios see figure .
by inspecting these models the group confirmed that the messages were exchanged in the appropriate order and that the nodes transitioned between states correctly.
the following are some student quotes that indicate that synoptic increased developers confidence in their systems definitely let us know for sure that our code was functioning correctly.
using synoptic did not help us find any bugs with our code but it did help us to clarify that our code is what it should.
we can confidently say that synoptic helped confirm the correct behavior of our program and certainly made us feel better about our code.
.
building system understanding using the synoptic model the reverse traceroute developer was able to solidify his understanding about the system.
for example he knew that the system had a bug in which a reverse traceroute measurement terminates prematurely.
using the model he was able to verify that this bug occurred methods terminating prematurely appeared as terminal nodes in the model.
however as it turned out the developer did not understand the full extent of this bug.
he assumed that it affected only two methods.
by inspecting the model he found out that other methods were impacted as well.
the model in figure illustrates the set of all the methods impacted by this known bug with a darker shading.
this experience solidified the developer s understanding of where the bug manifested and he felt better prepared to resolve it.
overall we found that synoptic was useful for finding new bugs for increasing developer confidence and for building systems understanding.
.
threats to validity our two user studies are limited in scope and have a number of inherent biases for which we were unable to control.
the reverse traceroute system has been developed by about five developers all of whom understand the entire system.
consequently synoptic models are straightforward for them to interpret.
developers who are new to a project or are working on a larger project may find itinvalid stateread write statedelete cached write stateinvalid state1.
.
.
.
.00createinvalid stateread write statecached write statedeletegetcached read statereadonly state1.
.
.
.
.
.
.
.
.
.50wait write confirmwaitwait wait read data1.
.
.
.00wait write confirmwaitwait write data0.
.
.
.
.
.
waitgetinvalid stateread only statecached read state a client b server d server c client 2figure two pairs of synoptic models generated by a group of students in the distributed systems class for a distributed cache coherence assignment.
each pair of models has a server model and a client model.
the client1 andserver1 models correspond to a scenario in which the client host starts and then deletes the file if it exists.
alternatively the client creates the file and then either deletes it or reads from it.
the client2 andserver2 models correspond to the simpler scenario in which the client reads a file that is not currently accessed by any other client.
difficult to interpret synoptic models which may be larger and more complex.
however we believe that synoptic may also be used to gain insight into components of larger systems and because most sizable systems are developed in a modular fashion there may still be value in using synoptic in large projects.
lastly our study with the developer implicitly emphasized bug findings which may have primed the developer into thinking more about bugs.
in a different context he might have been less successful in identifying bugs.
because the students in the distributed systems course were required to use synoptic as part of the assignment it is unknown whether they would have been motivated enough to learn about and use the tool without a mandate.
students might have also been attempting to please us and thereby reported only positive experiences with the tool.
finally students are not representative of experienced developers and we do not know whether the bugs they found using synoptic are problems for expert developers.
.
related work work related to synoptic falls into three main categories tools to mine logs generated by systems algorithms to create concise models of system executions and the study of bisimulations which motivated our development of bisimh.
mining systems logs this paper extends our previous work with a formal analysis of the bisimh algorithm and a report on user experiences with thesynoptic tool.
an overview of the synoptic tool from a user s perspective is given in .
other prior work on mining systems logs focused on detecting dependencies anomalies and performance debugging .
that work does not target the problem of finding a concise model for an arbitrary system generating the log.
for instance salsa and mochi extract and visualize node behavior of hadoop node logs to support performance debugging.
this line of work is mapreduce specific.
perracotta mines and visualizes temporal properties of event traces and it has been used to study program evolution .
unlike synoptic perracotta does not use the mined temporal properties to infer a model of the system.
inferring models the problem of automata inference from positive examples of executions is computable but is np complete and the fsa cannot be approximated by any polynomial time algorithm .
the ktail algorithm used extensively in related work takes a finite state model and produces a more compact one by recursively merging states whose root subgraphs are identical up to a depth of k. approaches that leverage ktail to infer models without developer supervision can produce precise models for small and simple systems but when complexity of the system increases the precision of the inferred models decreases dramatically .
lorenzoli et al.
developed gk tail a variant of ktail and applied it to logged sequences of methodcall invocations.
unlike bisimh the gk tail algorithm does not preserve trace invariants.
lo et al.
augment the ktail algorithm by using temporal properties mined from execution traces to guide state merging while ensuring that the final model satisfies temporal constraints.
temporal invariant consistency greatly increases the model s precision.
synoptic produces similar high precision models while leveraging refinement as opposed to coarsening to greatly increase the efficiency and scalability of the approach .
krka et al.
have proposed though have not yet implemented using refinement and mined invariants to improve precision of inferred models beyond that of lo et al.
s approach.
numerous techniques leverage developer written specifications to infer system models.
whittle and schumann generate component statecharts from scenarios and properties.
damas et al.
inductively infer labeled transition system lts models from scenarios interactively provided by the developer.
a later extension of this approach reduces the number of questions to the developer by incorporating fltl properties .
however these techniques can synthesize overspecified models and require significant human input.
uchitel et al.
proposed using message sequence charts to infer lts models and discover implied scenarios.
harel et al.
synthesize statecharts from live sequence charts .
ltss can also be constructed based on pre and postcondition specifications .
de caso et al.
generate abstract models to support validation of the specifications.
alarjeh et al.
s technique facilitates refinement of pre and postconditions based on system goals and execution scenarios.
similarly krka et al.
s algorithm synthesizes behavioral models from pre and postcondition specifications and execution scenarios and can synthesize component level models from systemlevel specification.
uchitel et al.
argued that it is crucial to consider the specifications partiality when using developer written specifications to infer models.
in contrast to all these approaches synoptic requires much less input from the developer the logs that are usually already generated by systems and a small set of regular expressions.
however systems that are not instrumented to generate logs may require developers to change the implementation.
however logging is considered to be generally useful and adding such instrumentation leads to better software.
further we hope that synoptic s utility will motivate developers to increase their systems logging capabilities.
bisimulation a bisimulation is a simulation relation that provides a strong notion of similarity for relational structures .
its key feature is to preserve certain properties of the relational structure for example two strongly bisimilar transition systems are guaranteed to satisfy the same set of ltl formulae.
an important application in model checking is model minimization .
our bisimh algorithm is a modification of a partition refinement algorithm which uses invariants to determine which state to split next and when to stop splitting resulting in a coarser representation that is not bisimilar to the input structure.
our bisimh algorithm is also related to the partition refinement algorithms in but bisimh uses invariants to guide exploration and termination.
.
limitations and future work while working on synoptic we observed a number of its limitations.
here we detail the most important of these and connect some of them to our future work.
applicability.
synoptic models capture ordering relationships between events observed in a log.
it does not handle algebraic and logical relationships that may also be useful in modeling software e.g.
this.next6 this.prev .
synoptic is therefore best suited forstudying logs of systems whose execution can be modeled as a sequence of elements with the ordering the presence and absence of elements encoding some useful semantics about the system.
we have observed that synoptic can help with problems whose root causes can be deciphered using such semantic information.
more advanced issues however would require richer and more complex models than synoptic currently provides.
invariants.
synoptic relies on three temporal invariants to determine when to terminate and how to proceed during refinement.
a rigorous evaluation of the limitations and advantages of these invariant types is necessary.
for example we know that the invariants constrain synoptic models in ways that are sometimes undesirable.
for instance the6!invariant constrains synoptic models to be less generative e.g.
if a6!bis true then the model is restricted from generating a path between aandb even though this behavior might be valid and can appear in an execution that is not present in the input log.
however we do not know what kinds of systems or uses these invariants favor and whether we should expand this set or make it smaller.
synoptic invariants are temporal.
they do not involve the data values that are often present in logs.
extending synoptic to mine and then preserve value based invariants is a part of our future work.
reliance on logs.
to work well synoptic needs the input log to include as many different system executions as possible.
this is because synoptic models are at most as detailed as the input logs.
if the user failed to log an important behavior then this behavior will usually not be present in the synoptic generated model.
however generating all possible system behaviors is notoriously difficult and may be infeasible as illustrated by the following student quote however we had to run specific simulation cases in order to produce the log so while synoptic was very useful most of the debugging process involved trying commands in the simulator.
we knew what cases we were testing so running them through the terminal was an easier way to test for the bug.
but synoptic did confirm that we have the right message flows.
handling concurrency.
synoptic cannot handle traces of concurrent systems as it assumes a totally ordered relation for ordering event instances in a trace.
concurrent systems may be modeled by synoptic with explicit concurrency e.g.
by listing all possible event instance permutations but this results in highly connected models that are difficult to interpret.
another alternative which we are currently pursuing is to extend synoptic models and the semantics of the three invariants types to accommodate partially ordered traces.
fault localization interactive tool support.
the feasibility of fault localization using synoptic generated models depends on the density and quality of the logging statements.
reconstructing execution paths based on logs is an active research area e.g.
sherlog and we hope to leverage this existing work in developing more automated fault localization techniques.
however fault localization fundamentally requires human insight.
to this end we are working on a synoptic gui that will support developers in this task.
this gui will allow developers to explore query and interact with the synoptic models in real time.
for example developers will be able to find out which of the logged traces pass through a set of partitions in the model and which event instances belong to a partition as well as other information.
.
conclusion logging is a popular debugging methodology.
unfortunately large logs are often complex and difficult to analyze manually.
this paper presented the design and evaluation of a tool called synoptic which builds a system model from its execution logs.
unlike othertools synoptic requires few inputs from the developer and can be applied to pre existing logs.
the key to synoptic s algorithm is its use of three types of mined temporal invariants to guide the model space exploration.
our formal evaluation showed that synoptic s algorithm always makes progress and always finds a model that satisfies the mined invariants.
our case studies showed that synoptic graphs improved developer confidence in the correctness of their systems and were useful for finding bugs.
we believe that synoptic bridges the gap between systems developed by developers with little to no training in formal methods and a suite of methods developed by the formal methods community.
synoptic is an open source tool and has met the expectations of fse artifact evaluation committee.