improving feature location practice with multi faceted interactive exploration jinshui wang xin peng zhenchang xingy and wenyun zhao school of computer science fudan university shanghai china fudan.edu.cn pengxin fudan.edu.cn wyzhao fudan.edu.cn yschool of computer engineering nanyang technological university singapore zcxing ntu.edu.sg abstract feature location is a human oriented and information intensive process.
when performing feature location tasks with existing tools developers often feel it difficult to formulate an accurate feature query e.g.
keywords and determine the relevance of returned results.
in this paper we propose a feature location approach that supports multi faceted interactive program exploration.
our approach automatically extracts and mines multiple syntactic and semantic facets from candidate program elements.
furthermore it allows developers to interactively group sort and filter feature location results in a centralized multi faceted and intelligent search user interface ui .
we have implemented our approach as a web based tool mfie and conducted an experimental study.
the results show that the developers using mfie can accomplish their feature location tasks faster and the quality of their feature location results in terms of f measure is higher than that of the developers using regular eclipse ide.
i. i ntroduction when performing software maintenance tasks developers often need to investigate the system s code base to find and understand program elements e.g.
classes methods that are pertinent to a specific feature.
such program comprehension activity often termed as feature location orconcept location in the literature is a human oriented and informationintensive process .
to help developers accomplish feature location tasks various feature location approaches have been proposed including ones based on lexical information e.g.
identifiers and comments in the code on structural dependencies e.g.
call graph of the program on dynamic traces as the program executes and on the hybrid of several information sources .
the output of these approaches is a ranked list of program elements that are pertinent to the task at hand.
researchers have also applied techniques such as formal concept analysis fca pagerank to better filter or rank the relevance of program elements in the result list.
the recent developer oriented study by wang et al.
suggests that feature location is a human oriented information seeking process during which developers must interactively search browse and navigate a multi dimensional information space .
each dimension describes program elements from a specific syntactic or semantic facet.
however existing feature location approaches simply consider feature location as anone shot activity of search!results .
thus these approaches focus on technology oriented issues such as searching algorithms and ranking strategies.
when performing feature location tasks with these approaches developers often feel it difficult to formulate an accurate feature query e.g.
feature descriptions or keywords .
furthermore it is hard for them to determine the relevance of returned results especially when a large number of results are returned.
therefore an intuitive interactive exploration approach is required to better support the human oriented and information intensive process of feature location.
the approach should meet the information needs of developers for efficiently exploring and understanding the multi faceted information space of the feature location results.
moreover the approach should allow developers to begin with a rough query and gradually refine and adjust it based on previous feedbacks i.e.
returned results .
in this paper we present an approach that supports multifaceted interactive exploration for feature location.
the goal of our approach is to ease the exploration and understanding of potentially relevant program elements by allowing developers to interactively group sort and filter feature location results in a centralized multi faceted and intelligent search user interface ui .
our approach begins with an initial feature query provided by a developer and proceeds with an iterative process.
in each step it automatically extracts or mines multiple syntactic and semantic facets from returned program elements by leveraging static program analysis and data mining techniques.
these syntactic and semantic facets include package structure inheritance hierarchy usage dependencies and intent.
then it presents the extracted and mined facets in a multi faceted search ui .
based on dynamically generated facets and grouping and sorting of search results a developer can make quick and accurate decisions about the relevance of candidate program elements to a feature and determine whether to further refine the feature query or return to a previous search step.
we have implemented our approach as a web based tool mfie short for multi faceted interactive explorer which can be provided as a web based service or integrated with integrated development environments ides like eclipse.
to evaluate if developers can use mfie to accomplish their feature location tasks more efficiently and effectively we conducted978 c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.762an experimental study in which developers performed four feature location tasks on an open source system jedit using mfie .
we compared the performance of developers i.e.
the experimental group against the performance of the other developers using the eclipse ide i.e.
the control group on the same feature location tasks.
we found that the developers were able to effectively explore mined multi facets in multi faceted search ui to locate program elements pertinent to the given feature location tasks.
we also found that using mined multi facets and multifaceted search ui the developers found it easier to perform the assigned tasks and were more confident in their success in completing the tasks.
in fact the developers with mfie support completed the tasks faster than those without the support.
furthermore the quality of feature location results in terms of f measure of the developers with mfie support is higher than that of the developers without the support.
the remainder of the paper is organized as follows.
section ii reviews related work.
section iii describes the proposed approach.
section iv introduces the implementation of the proposed approach in mfie .
section v presents the results of an experimental study and discusses some threats to our study.
section vi discusses the advantages and possible improvement of our approach.
section vii concludes the paper with a summary of our findings.
ii.
r elated work related work of our research spans three aspects i.e.
feature location techniques information seeking and program exploration data summarization and abstraction.
a. feature location many semi automatic techniques have been proposed in the area of feature location or concept location .
these techniques use information retrieval ir static analysis dynamic analysis or a hybrid of several analysis techniques to improve developers efficiency and performance in feature location tasks.
a systematic literature survey of feature location techniques has been presented in .
moreover some researchers also use ir static or dynamic analysis techniques to recover traceability links between different kinds of artifacts e.g.
between documents and source code or duplicated bug reports .
these technology oriented approaches perform matching between features and program elements in a non interactive way.
in contrast some research on feature location has been focused on better supporting interactive exploration by an iterative incremental process or improved organization of search results.
lucia et al.
proposed an incremental process for ir based traceability recovery which allows software engineer to control the number of validated correct links and the number of discarded false positives by incrementally decreasing the similarity threshold.
in lucia et al.
empirically compared tracing performances achieved by participants using the oneshot process and the incremental process.
their study indicated that incremental process can improve tracing accuracyand reduce effort to analyze the inferred links.
poshyvanyk et al.
proposed an approach that can provide additional structure among the results of feature location by generating a concept lattice using fca formal concept analysis .
developers can determine whether a category in the concept lattice is relevant by examining its label and their search effort thus can be reduced by exploring only relevant categories in the lattice.
compared with existing interactive feature location techniques our approach supports a more systematic exploration process by providing multi faceted categories in each search step and a complete record of exploration history for navigating exploration paths back and forth.
b. information seeking and program exploration jquery is a source code browser that combines the advantages of a hierarchical browser with the flexibility of a query tool.
its hierarchical browser supports navigation among program elements based on particular kinds of relationships such as supertype subtype and caller callee.
ferret supports program exploration by answering conceptual queries such as what calls this method?
and what transactions changed this element?
.
the answers are based on the integration of different sources of information such as static relationships dynamic calls and revision history.
suade recommends additional program elements for investigation based on their estimated structural relevance to a previouslyidentified set of program elements.
alwis et al.
conducted a comparative study with three exploration tools jquery ferret and suade and reported that these tools had little apparent effect.
these tools support program exploration by a pre defined question answer process or an incremental navigation process from previously identified program elements.
in contrast our approach allows developers to provide a rough query in the beginning and incrementally refine it with automatically generated multi faceted categories.
faceted search as an information exploration technique has been widely applied in a number of domains such as ecommerce and digital library.
faceted search allows a user to explore desired information from search results organized according to a set of category hierarchies each of which corresponds to a different facet dimension or feature type relevant to the targeted domain .
thus the facets provided can be seen as a set of filters for the user.
a faceted search interface allows the user to progressively narrow down the choices by choosing from a list of suggested query refinements .
in existing applications of faceted search multi faceted categories are usually created manually although assignment of documents to categories can be automated to a certain degree of accuracy .
in contrast in our approach the facets in each step are automatically extracted or mined from source code.
a main challenge here is how to generate meaningful labels for users to understand and choose relevant facets.
our approach addresses this challenge by grouping763fig.
.
process overview candidate program elements using semantic clustering and abstracting descriptive labels for each generated cluster.
c. data summarization and abstraction rastkar et al.
proposed an automated approach that produces a natural language summary for crosscutting source code concerns which describes both what a concern is and how the concern is implemented.
kim et al.
proposed a rule based program differencing approach that automatically discovers and summarizes systematic code change as logic rule.
sridhara et al.
presented an automatic technique for identifying code fragments that implement high level abstractions of actions and generating natural language description for them.
the objectives of these approaches are to ease developers program comprehension.
in contrast our approach generates multi faceted categories that can be used to classify program elements for developers to explore feature search results and refine their feature queries.
iii.
t heapproach in this section we first give an overview of the exploration process supported by our approach.
we then detail the underlying techniques.
a. overview to implement multi faceted and interactive feature location our approach employs an incremental and iterative exploration process starting with an initial search based query.
figure presents an overview of our approach showing the main steps and input output in the process.
the four gray rectangles in the figure represent steps involving human interaction.
to locate program elements e.g.
methods classes relevant to a feature a developer first specifies a query consisting of a set of keywords.
as the initial search results will be iteratively refined in the following steps it is not necessary for the developer to come up with a perfect query initially.
in other words for this initial step recall is much more important than precision.
based on the keywords specified by the developer an initial set of candidate program elements can be obtained by using techniques such as regular expression matching and ir.
then our approach automatically extracts or mines multiple syntactic and semantic facets from candidate program elements.
each facet provides a category hierarchy for exploring candidate program elements.
based on multi faceted categories the search results can be sorted and grouped accordingly.
the mined extracted facets and the sorted grouped search results help the developer betterunderstand what choices he has so that he can determine what to do next after investigating the results.
the developer can finish feature location process when he successfully identifies relevant program elements.
or he may choose to retry i.e.
start a new exploration process .
the developer can also continue the exploration process by asking smarter questions.
this will increase the likelihood of success on feature location tasks.
there are two alternatives for the developer to ask smarter questions.
he can choose to refine the initial search based query by issuing queries with more precise keywords based on the current result set and the multiple facets generated.
our approach searches in the current result set with the refined keywords and narrow down search results.
alternatively he can choose to select combine categories in one or more facets.
although the developer does not explicitly issue new queries in the second way he essentially refines his query by using additional information of multi faceted categories to filter the current search results.
based on the filtered set of candidate program elements a new iteration of exploration can be started.
to better support the interactive exploration our approach allows a developer to roll back to a previous search step in the exploration process.
a developer may find that the exploration process has deviated from his expectation when he realizes that the desired results may have been filtered out from the result set.
therefore it is helpful to allow a developer to roll back to a previous step and try other exploration pathes from there.
in our current implementation see section iv the exploration history of a feature location process is recorded in a tree like structure with descriptive labels for each step.
with history explorer a developer can roll back to a previous step by selecting corresponding node and then click navigate button to roll back to the step.
b. multi faceted filters the multi faceted categories in our approach are automatically mined or extracted from candidate program elements and dynamically updated during the iterative exploration process.
currently our approach supports the following five facets for result filtering package structure .
this structure facet reflects package structure extracted from candidate program elements showing how they are structured in different packages.
inheritance hierarchy .
this structure facet reflects type hierarchy extracted from candidate program elements.
intent .
this intent facet categorizes candidate program elements by semantic clusters mined from their source code.
it reflects concerns or topics of program elements.
use.
this dependency facet categorizes candidate program elements by the modules on which they depend for implementation.
usedby .
this dependency facet categorizes candidate program elements by the modules that use them for implementation.
these above five facets can be categorized in three aspects i.e.
hierarchical structure program intent and usage764dependency.
hierarchical structure facets reflect how program elements are intentionally structured in packages or type hierarchy similar to package explorer or type hierarchy views of modern ides e.g.
eclipse .
program intent facet categorizes program elements by relevant topics and concerns involved in program elements.
usage dependency facets differentiate program elements by the modules using them or used by them.
it should be noted that these five facets are not completely orthogonal.
for example topic and concern information may also be reflected by package structure and type hierarchy in structure facets.
we now introduce how each facet is extracted or mined from candidate program elements and how it is used for result filtering.
structure facets the extraction of the two structure facets is straightforward.
the package structure is extracted from the package structure of candidate program elements in search results.
similarly the inheritance hierarchy is extracted from the inheritance relations of classes interfaces declared in candidate program elements.
when a package in package structure facet is selected all the program elements that are contained in the package are selected from the current result set.
when a class or interface ininheritance hierarchy facet is selected all the program elements that are declared in the class and its subclasses are selected from the current result set.
intent facet categories in intent facet are mined from the source code of candidate program elements in the current result set.
to reflect the intent of program elements at a higher level of abstraction we group candidate program elements using semantic clustering technique and abstract descriptive labels for each generated cluster see section iii c .
the generated clusters thus construct the categories in intent facet and are displayed by their descriptive labels.
when a category in intent facet is selected all the program elements that are contained in corresponding semantic cluster are selected from the current result set.
dependency facets categories in the two dependency facets are mined from the dependency context of candidate program elements in the current result set see figure .
for use facet we group all the program elements that candidate program elements in the current result set depend on by semantic clustering and use the generated clusters as categories.
forusedby facet we group all the program elements that depend on candidate program elements in the current result set by semantic clustering and use the generated clusters as categories.
for example in the example shown in figure program elements that candidate elements in the current result set depend on are grouped into semantic clusters u1touj that constitute categories in use facet program elements that depend on candidate elements in the current result are grouped into clusters g1togkthat constitute categories in usedby facet.
similar to intent facet descriptive labels are generated for each cluster and displayed in corresponding facets for developers to investigate.
fig.
.
categories in use usedby facets when a category in use facet is selected all the program elements that depend on elements in the corresponding cluster are selected from the current result set.
when a category in usedby facet is selected all the program elements that are used by elements in the corresponding cluster are selected.
for example in the example shown in figure if u1is selected inusefacet m1 m3andm4will be selected from the current result set if g1is selected in usedby facet m1 m2andm3 will be selected.
c. semantic clustering and labeling semantic clustering reveals concerns and topics of source code by grouping source artifacts that use similar vocabulary .
in our approach semantic clustering is used to mine categories for intent facet and two dependency facets.
to that end clustering algorithm need to first group relevant program elements into meaningful clusters and then generate descriptive labels for developers to investigate the relevance of program elements.
given candidate program elements or their dependent elements our approach first transforms a set of program elements into documents for clustering.
the identifier names and comments of each program element method or class are transformed into a document by standard ir pre processing steps i.e.
tokenization filtering out stop words and word stemming.
then the produced documents are grouped into clusters with labels indicating their intent.
in our current implementation see section iv we apply the lingo algorithm provided by carrot21 an open source search results clustering engine for the purpose of semantic clustering.
lingo reverses the traditional order of cluster discovery by first finding good conceptually varied cluster labels and then assigning documents to the labels to form clusters .
it can generate longer often more descriptive labels than other clustering algorithms.
this characteristic greatly helps developers to understand and select categories in intent use andusedby facets.
d. search result grouping and sorting in addition to being used as result filters multi faceted categories generated in each step can also be used to group candidate program elements.
each facet groups program elements from a different dimension.
for example intent facet groups program elements by concerns or topics implemented by them and use facet and usedby facet group program by their usage dependencies.
with these groups from different dimensions and their descriptive labels developers can have an overview about the distribution of search results in a short time.
they can thus examine a group of search results from a specific dimension.
for example from intent facet a developer can find that current candidate program elements are distributed in a set of modules implementing different concerns.
he can then select a group with the most relevant concerns and investigate candidate elements in this group.
in addition to grouping search results can also be sorted by their relevance to the feature query to facilitate the navigation and examination of search results.
the relevance of a program element usually a method is estimated by the weighted occurrence count of the keywords given in the query.
keywords in class name have the highest weight method name the second method body the third.
categories in each facet are also sorted.
for the three facets generated by semantic clustering i.e.
intent use usedby categories are sorted by the number of results involved in each category.
the categories in the other two facets i.e.
package structure and inheritance hierarchy are sorted by package or class name.
with sorted categories in each facet developers can quickly find categories with desired number of results.
iv.
t ool implementation we have implemented our approach in a web based tool mfie with a multi faceted search ui.
mfie provides mechanisms to facilitate developers to investigate returned search results of a feature query and select combine facets.
furthermore mfie keeps track of a complete exploration history and allows developers to navigate back and forth among exploration steps.
in the current implementation mfie supports feature location of java programs at method level.
a. layout mfie has a typical multi faceted search ui as shown in figure .
the four areas in the ui are search panel result list facet panel and history explorer.
a developer can enter multiple keywords in search panel as a feature query.
he can start a new feature location process click search button or click search in results button to refine current search results.
the candidate program elements returned in each step are sorted and displayed in the result list.
in this area each result java method is sorted and displayed with its package name method name and a snippet of statements involving one or more keywords given in the query.
mfie also generates tags for each result method for quick understanding of the result method see section iv b for tag generation .
a developer can examine detailed descriptions e.g.
source code of a result method by clicking the link on the method name.
the five facets generated from the current search results are organized in facet panel.
categories of a facet are displayed as a tree with descriptive labels and the number of candidate program elements involved in a category.mfie keeps track of a complete exploration history of a feature location process.
this exploration history is displayed in history explorer using a tree like structure describing exploration paths see figure for an example and section iv c for explanation .
b. result investigation and facet selection the search results returned and facets mined in each step are organized and displayed in a way that developers can easily investigate the relevance and distribution of returned results and make informed decisions about query refinement or restarting a new search.
candidate program elements are sorted in the result list by their estimated relevance to the query.
as the method body of a result method may be too long to be fully displayed in the result list mfie generates a small snippet for each result.
the snippet is generated by locating the first occurrence of the searched keywords in the method body and excerpting a fragment of about words around that location.
when shown in the result list searched keywords in the snippet are highlighted and special code elements such as java keywords numbers and comments are displayed in different colors in a similar style to modern ides such as eclipse.
to allow a developer to have a quick understanding of the search results mfie generates a set of tags for each result method.
the tags are generated by selecting the five highest weighted terms for each search result java method using term frequency inverse document frequency tf idf metric.
tf idf is commonly used in information retrieval techniques such as vector space model vsm .
the weight of a term in a method is calculated as f np knk where nis the number of occurrences of the term in a method andp knkis the sum of the number of occurrences of the term in all methods.
mfie also provides a detailed information window not shown in this paper for developers to examine complete information about a result method including source code caller and callee methods and fields accessed by the method.
to facilitate developers examining search results by facets mfie provides an instant search preview feature.
this feature allows a developer to preview filtered results by choosing a category in a facet.
filtered search results that are involved in the chosen category are immediately displayed in the result list for the developer to examine.
the developer can quickly preview different categories in the same or different facets.
note that categories chosen in instant search preview will not be used to refine the feature query immediately.
if the developer decides to refine his feature query with the chosen categories he can click the update button.
then the chosen category will be incorporated into the feature query and the search results will be further filtered with the refined query.
at the same time all the categories in each facet are updated for the new search results.
c. exploration history to support developers to navigate back and forth through the exploration history of a feature location process mfie766fig.
.
mfie layout fig.
.
history explorer provides a history explorer as shown in figure .
the exploration history of a feature location process is represented as a tree.
each node in the tree represents a step in the process and records the relevant exploration information including the refined facet or keywords and the number of results returned in the step.
the root of the tree denotes the beginning of the process.
when a developer refines his feature query by refining keywords or selecting combining facets a new child node is created under the node of current search step.
therefore each path in the tree represents a continuous refinement from the initial feature query.
for example to locate the feature highlight terms in hypersearch results a developer starts an exploration process with the initial query highlight and gets results.
and then he identifies three relevant categories inintent facet e.g.
update highlight .
he chooses these categories for further refinement and gets results.
as he still feels that the returned results include some irrelevant methods he chooses two categories in package structure facet e.g.
jedit.search and finally gets results.
v. e valuation our approach to multi faceted interactive exploration for feature location is intended to help developers better perform feature location tasks.
to evaluate if our mfie tool meets thisgoal we conducted a user study to investigate the following three questions q1 how does a developer use mined multi facets when they are available?
q2 can our mfie tool help a developer achieve better performance in feature location tasks?
q3 can our mfie tool help a developer perform a feature location task more easily?
a. design our study involved participants graduate students and seven senior undergraduate students from our school of computer science.
these participants were divided into two equivalent groups g1andg2 based on our pre experiment survey on their capability including software development experience familiarity with java familiarity with eclipse.
this allows us to perform a fair comparison of their performance on the same set of tasks.
group g1was the experimental group that used mfie to perform their feature location tasks.
group g2was the control group that used eclipse ide to perform the same set of tasks.
the tasks used in our study were selected from the benchmarks2provided in .
for each task the participants were requested to find the program elements methods in this study that are specifically relevant to a given feature i.e.
the program elements where the initial changes need to be made in order to fix a bug in a relevant feature .
based on an overall consideration of the complexity of the subject system participants familiarity with the system the number of documented features we chose jedit among the five projects provided in the benchmarks as the subject system.
we further selected the following four features from the features provided by the benchmarks as the task set of our study.
these four features 2available at moderate difficulty and can be well understood by the participants.
autosave turned off for untitled documents text block selection via gutter right click highlight terms in hypersearch results window color for type customize tool bar and context menu reset button the participants were requested to accomplish their tasks with mfie or eclipse ide.
they were given two hours to accomplish their tasks but can submit their results earlier if they thought that they had finished the tasks.
as mfie is a static approach the control group using eclipse ide was allowed to use all the search and exploration features provided by the ide but not allowed to run and debug the subject system.
before each experiment we provided a halfhour tutorial and training on using mfie and eclipse ide.
because we need to analyze the actions and processes of each participant in completing the assigned tasks we required the participants to run a full screen recorder once they started working on the tasks.
furthermore all the participants were asked to fill in a post study questionnaire to provide feedback about the perceived difficulty of their tasks challenges or difficulties in the process and their experience on tool usage.
we evaluated participants performance on all the tasks by precision recall and f measure.
given a feature f letpfbe the percentage of correctly reported links between features and program elements i.e.
precision and rfbe the percentage of actual links between features and program elements reported i.e.
recall .
given a set of feature location tasks tconsisting of a set of features f we computed the overall precision pt and recall rtfortas follows pt p f2fpf jfj rt p f2frf jfj.
f measure for tis then computed as ft b2 pt b2 rt to reflect a weighted average of the precision and recall.
in our study following the treatment in we set bto i.e.
recall is considered four times as important as precision because we deem that finding missing links is more difficult than removing incorrect links.
b. results use of multi facets q1 by analyzing the screen recorded videos we obtained the number of times that participants used different facets during their feature location processes see table i .
the intent facet has the highest usage frequency and every participant used intent facet at least once during the whole experiment.
our analysis of the videos and post study questionnaires and interviews suggests that participants used intent facet more frequently because high readability.
by reading the descriptive labels of categories in intent facet participants can roughly infer whether a category is relevant to the given task.
reducing mental demand of participants.
participants may not only be able to obtain good enough result by selecting categories from intent facet they may also derive appropriate keywords from descriptive labels of categories listed in intent facet.
reducing the high dependance on good keywords.
depending on only keywords may filter out many methods that are relevant but do not contain the given keywords.
easy to understand.
although use and usedby facets also provide descriptive labels participants still need to distinguish use and used by dependencies between search results and categories.
this incurs a certain amount of overhead.
do not need to interpret the location of method.
when using facet such as package structure participants have to infer the relevance of packages to a given task by interpreting package name.
in contrast intent facet is much simpler to use.
next to intent facet package structure facet has been used times in total much more than the use of inheritance hierarchy facet.
this result matches our expectation.
the granularity of the categories in package structure facet is more coarse grained than that of the categories of inheritance hierarchy facets.
participants thus usually feel it easier to determine the relevance of candidate program elements by package.
furthermore participants are generally more familiar with the ui of package structure facet because it simulates package explorer view commonly found in modern ides.
table i usage of multi facets keyword facet refinement retryrefinement intent use usedby package inheritance history p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 total c. results improvement on performance q2 we evaluate the performance improvement of mfie by comparing the precision recall and f measure of the experimental group g1 and the equivalent control group g2 .
hypotheses we introduce the following null and alternative hypotheses to evaluate how different the performance of the experimental and control groups is.
h0 the primary null hypothesis is that there is no difference between the performance of participants who use mfie and eclipse.
h1 an alternative hypothesis to h0 is that there is significant difference between the performance of participants who usemfie and eclipse.
results of individual participants the participants provided to methods for each task and none of them provided empty result list for a task.
table ii and table iii present the participants performance in terms of precision recall and fmeasure the number of results submitted for each task and the time used for completing the four tasks in the experimental group and the control group respectively.
results of hypotheses testing we use paired sample ttests to evaluate the null hypothesis h0 in terms of precision recall and f measure.
we evaluate the hypotheses at a .
level of significance.
the results of these three tests are shown in table iv.
based on the results we reject the null hypothesis h0 for all the measures of precision recall and fmeasure.
therefore we accept the alternative hypothesis h1 i.e.
there is significant difference between the performance of participants who use mfie and eclipse.
our further analysis of the feature location results indicates that compared with eclipse ide using mfie can significantly improve the recall of feature location results but may decrease the precision.
our inspection suggests that this decrease was due to the fact that with multi faceted categories participants tend to be aware of much more methods that could be potentially relevant to a given feature.
this often made the participants in g1submit more results than those in g2 which resulted in the decrease on precision.
in terms of the significant improvement on f measure i.e.
the weighted average of precision and recall our data shows thatmfie did help developers achieve better performance in feature location tasks.
d. results ease of feature location tasks q3 in the post experiment questionnaires all participants were requested to rate the difficulty of our feature location tasks being very easy and being very hard .
from the results in table v we can see that participants who used eclipse rated the difficulty at .
.
on average and those who used mfie rated the difficulty at .
.
on average.
table ii performance of the experimental group using mfie g1 participant recall precision f measure results time p1 .
.
.
.
42m46s p2 .
.
.
.
40m12s p3 .
.
.
.
18m07s p4 .
.
.
.
22m24s p5 .
.
.
.
49m29s p6 .
.
.
.
71m03s p7 .
.
.
.
68m59s p8 .
.
.
.
61m03s p9 .
.
.
.
45m45s p10 .
.
.
57m01s average .
.
.
.
47m41s std.
dev.
.
.
.
.
17m50s table iii performance of the control group using eclipse g2 participant recall precision f measure results time p11 .
.
.
.
60m51s p12 .
.
.
.
107m07s p13 .
.
.
84m53s p14 .
.
.
.
87m54s p15 .
.
.
.
51m56s p16 .
.
.
55m27s p17 .
.
.
.
86m21s p18 .
.
.
.
39m16s p19 .
.
.
.
64m27s p20 .
.
.
.
62m49s average .
.
.
.
70m06s std.
dev.
.
.
.
.
20m38sall the participants in g1rated the difficulty to be easy to medium and half of them rated the difficulty to be easy.
one of the participants p7 commented that with mfie he was not that afraid of the large number of results returned by the initial queries.
in many cases he was able to find proper keywords or categories to refine his queries by investigating the generated categories in different facets especially intent facet and the code snippets of several result methods ranked at the top of the result list.
furthermore although it is sometimes hard for participants to determine relevant categories or keywords for query refinement with multi faceted search ui they can often easily exclude obviously irrelevant categories.
in contrast to g1 half of the participants in g2rated the difficulty to be hard.
they often felt helpless when a large number of results were returned.
however if they used more specific keywords it was often the case that only few results were returned.
in such situation they usually had no idea about how to refine their queries.
in addition we can see from table ii and table iii the average time used to complete all tasks using mfie is about 22m less than that of using eclipse.
therefore our data suggests that our mfie tool did help developers perform a feature location task more easily.
table v rated difficulty of feature location tasks p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 avg .
p11 p12 p13 p14 p15 p16 p17 p18 p19 p20 avg .
e. threats to validity a major threat to the internal validity of the experimental study is the differences in the capabilities of the two groups of participants.
this may threaten our assumption of the equivalence between the experimental group and the control group for the comparison between mfie and eclipse ide.
to address this threat we had tried our best to allocate participants with comparative capabilities into different groups based on the pre study survey of the participants capabilities and our evaluation of their capabilities.
the other major threat to the internal validity of the study is the likely insufficient training of the tools mfie and eclipse ide used in the study.
we believe this factor has much greater influence on the experimental group using mfie since most of the participants use eclipse ide regularly while mfie is a completely new tool for the participants.
even in such a disadvantage situation the participants using mfie still significantly outperformed those using eclipse.
we believe that if the participants were given more systematic training onmfie they could make even better use of multi facets and multi faceted search ui e.g.
history explorer and then achieve even better performance.
major threats to the external validity of the study lie in the fact that we only conducted one experimental study on a relatively small java system.
all our findings may not be applicable to systems with millions lines of code that are maintained by teams of professional developers.
in the study 769table iv results of t t ests of hypotheses for the variable precision recall and f measure .
measurements are reported in the following columns minimum value maximum value median means variance the degrees of freedom df the pearson correlation coefficient pc statistical significance p tcrit and the tstatistics .
h var approach samples min max median 2df pc ttcrit p decision recalleclipse .
.
.
.
.
.
.
.
.
rejectmfie .
.
.
.
.
h0 precisioneclipse .
.
.
.
.
.
.
.
.
rejectmfie .
.
.
.
.
f measureeclipse .
.
.
.
.
.
.
.
.
rejectmfie .
.
.
.
.
we considered only one programming language java and compared with one development environment eclipse .
other development environments with more advanced search and exploration mechanisms such as intellij idea may weaken the advantage of mfie over traditional ides.
further studies are required to generalize our findings in large scale industrial projects and with developers who have sufficient domain knowledge and familiarity with the subject systems.
vi.
d iscussion our initial study indicates that multi faceted interactive exploration can help developers perform their feature location tasks more efficiently because it allows developer to ask smarter questions during feature location.
furthermore our study also reveals opportunities to further improve our approach for example by providing more comprehensible facets and supporting guided exploration and navigation.
a. helping developers ask smarter questions feature location tasks can be accomplished only when a developer knows what he want and how to ask for it.
feature location often fails when a developer does not know which choices he has and he does not know what he does not know.
according to our earlier study when using eclipse experienced developers usually can get familiar with the program more easily and faster than less experienced developers.
thus experienced developers may specify proper queries explore proper program elements and properly adjust their queries and strategies based on the investigation of returned search results usually by reading code .
in contrast less experienced developers may feel it difficult to specify proper queries and cannot effectively collect hints from returned search results.
furthermore they were more likely to get lost in exploration for example when they explore program by usage dependencies.
by using mined multi facets and multi faceted search ui provided by mfie the gaps between experienced and less experienced developers were significantly reduced.
this is indicated by the reduced standard deviation of all the individual measures of the participants in our study i.e.
recall precision f measure the number of submitted results time to complete the tasks see table ii and table iii .
different from most existing tools that require a developer to formulate feature queries explicitly the navigable facets generated by mfie help a developer who are not familiar with the program to ask smarter questions because thesefacets expose all the choices available to him.
furthermore the grouping of search results by different facets provides the developer more abstract and structured feedbacks about the search results.
as a result the developer even less experienced can better refine their feature queries based on the hints that he observe from different facets.
finally multi faceted query refinement result grouping together with history exploration allow the developer to explore valid paths to reach relevant program elements in a way that he is familiar with and may be more suitable to the task rather than to be limited by pre defined paths offered by the tools.
this greatly increases the likelihood that a developer may find relevant program elements.
b. providing more comprehensible facets in our approach categories in all the facets are automatically extracted or mined from candidate program elements returned by a feature query.
these categories aim to group search results for examination and provide means for query refinement.
therefore the label and description of a category needs to provide an accurate and abstract summary of program elements involved in the category.
this summary serves as hints so that developers can easily decide the relevance of program elements to the feature.
the readability of these labels and descriptions thus becomes a key for the effectiveness of multi faceted categories.
currently our approach provides package names in package structure facet class names in inheritance hierarchy facet and descriptive labels generated by semantic clustering algorithm in intent use and usedby facets.
in the future we will apply more sophisticated techniques such as natural language summaries and tag cloud to generate more comprehensible descriptions for multi faceted categories.
it would also be useful to experimentally compare different techniques to evaluate their effectiveness in generating comprehensible descriptions for extracted or mined facets.
c. supporting guided exploration and navigation the interactive exploration process provided by our approach allows a developer to explore along and switch among different exploration paths.
in this process the challenge lies in how to provide flexible exploration options for developers without making them lost.
the history explorer currently provided by mfie supports the navigation through exploration history with a tree like structure.
this history explorer may be improved with more intuitive and interactive visualization770techniques e.g.
3d visualization used in codecity .
such improved history explorer would help to better answer a set of questions during feature location process such as how did i reach the current situation?
and what have been filtered out in the past steps?
.
furthermore our multi faceted and interactive approach to feature location can be further improved by providing guided navigation.
a system employing guided navigation would assist the developer in achieving their goals by suggesting likely lines of enquiry at critical points.
it can update all navigation options at each click showing only the valid next questions a developer can ask and eliminating possible dead end paths.
this kind of guided navigation possibly implemented by intelligent wizards can be a useful complement to our current strategy of multi faceted query plus interactive exploration .
vii.
c onclusion and future work in this paper we have presented a multi faceted interactive approach for feature location.
our approach begins with an initial feature query and proceeds with a highly interactive exploration process.
during the exploration process our approach automatically extracts or mines multiple syntactic and semantic facets from candidate program elements and allows developers to interactively group sort and filter feature location results in a multi faceted and intelligent search ui.
the approach has been implemented as a web based tool mfie and evaluated with an experimental study involving gradate and senior undergraduate students.
the results indicate that the developers were able to effectively explore mined multi facets in multi faceted search ui to accomplish their feature location tasks.
our comparative study shows that the developers with mfie support completed the tasks faster less time with much better results higher by f measure .
our approach and experimental study have provided initial evidence that feature location practice can be improved with a multi faceted interactive exploration process.
our future work will experimentally investigate more sophisticated techniques for generating more comprehensible facets.
we will also provide more intuitive history navigation for better support interactive exploration process during feature location.
we are also interested in deploying our mfie tool as a cloud service.
this will allows us to collect exploration paths of a community of developers who use mfie to locate feature in a subject system.
these exploration paths can be mined to discover wisdom of crowds that can then be used to support intelligent guided exploration and navigation.
acknowledgment this work is supported by national high technology development program of china under grant no.2012aa011202.