permission to make digital or hard copies of all or part of this work for personal o r classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa.
copyright acm ... .
refactoring to role objects friedrich steimann lehrgebiet programmiersysteme fernuniversit t in hagen d hagen steimann acm.org fabian urs stolz volkswohl bund versicherungen s dwall d dortmund fabian.stolz volkswohl bund.de abstract role objects are a widely recogni zed design pattern for representing objects that expose different properties in different contexts.
by developing a tool that automati cally refactors legacy code towards this pattern and by applying this tool to several programs we have found not only that refactoring to role objects as currently defined produces code that is hard to read and to maintain but also that the refactoring has preconditions so strong that it is rarely applicable in practice.
we have therefore taken a fresh look at role objects and devised an alternative form that solves the exact same design problems yet is much simpler to introduce and to maintain.
we describe refactoring to this new lightweight form of role objects in informal terms and report on the implementation of our refactoring tool for the j ava programming language presenting evidence of the refactoring s increased applicability in several sample programs.
categories and subject descriptors d. .
coding tools and techniques object oriented programming.
general terms design languages keywords refactoring to patterns roles delegation objec t schizophrenia .
introduction subclassing is a key feature of many object oriented programming languages in widespread use.
it allows it that different classes share specification and behaviour by way of inheritance from a common superclass.
on the class level subclassing establishes a strong coupling in the sense that changes to a superclass likely have an effect on its subclasses.
while this strong coupling is known to cause problems e.g.
th e fragile base class problem it is usually intentional sharing implies that changes to the shared specification affect all that share.
on the instance level however objects of a subclass are completely independent of the objects of its superclass in the sense that changing the state of one object does not change the state of the other.
this independence is usually also intentional since ob jects represent individuals their state should change individually.
there are however situations in which the combination of sharing of specification and separation of state turns out to be inadequate.
these situations usually aris e when it is discovered that instances of sibling subclasses or of a superclass and a subclass do not represent different individuals but one logical entity.
in these cases not only the specification of state i.e.
the declaration of fields is to be shared but also the state itself i.e.
the values of the fields .
while such sharing of state is natural for prototypebased languages such as s elf it is foreign to the standard class based langua ges including j ava c and c and has to be emulated with some effort.
the notion of role objects captures one such effort.
in this paper we report on our findings in devising a fully automated refactoring tool that aids the introduction of role objects.
for this we briefly recapitulate in section the notion of role objects in class based object oriented programming languages and revisit the r ole object pattern rop as a standard solution elaborating on its intrinsic problems and on refactoring legacy code towards using it.
particularly the latter although reducible to a series of st andard refactorings seriously questions the utility of the rop as it has some very strong preconditions and leads to unsatisfactory results.
to address these problems section pr esents a new lightweight version of role objects that evolved out of our attempts to improve refactor the code resulting from refactoring to the original rop and that is much easier to refact or to.
sections and describe the implementation of tw o refactoring tools one for each form of role objects and provide some details of their applicability as derived from a comparative evaluation.
a discussion of related work concludes our contribution.
.
role objects today it is widely recognized that many types found in objectoriented systems represent roles not entities.
for instance employee employer customer etc.
are all different role types associated with the same entity type person just as product stock and asset are different role types associated with the entity type thing .
while entity types naturally corres pond to classes role types have rather different properties so that representing them with classes must be expected to cause problems.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
as types roles differ from classes in that the same object can have many roles even at the sa me time and can pick up and drop roles dynamically whereas an object can have only one class namely the one it is an instance of and keeps this class for its whole lifetime.
while depending on author there are many more distinguishing properties associated with roles their ability to extend objects with properties offe red and required in certain contexts only is central to all of them and in any case the one we are focusing on here .
there are several competing approaches to implementing roles in object oriented programs .
the simplest is implementing roles as subclasses for instance employee as a subclass of person .
however while this implementation may seem plausible at first glance employee adds certain employee specific properties to person it does not scale as soon as a second role is added to person as a second subclass and as s oon as the same entity must assume both roles e.g.
a person is both an employee and a cus tomer this approach hits the wall since an object cannot be an instance of two sibling classes.
when this happens the code is usually refactored to role objec ts more specifically to adopting the r ole object pattern rop .
entity class person private string name address person string n string a name n address a string getaddress return address string getcontactinfo return name getaddress void join organization org org.addmember this class organization set person members new hashset person void addmember person p members.add p boolean hasmember person p return members.contains p role class employee extends person employer employer employee string n string a employer e super n a employer e override string getaddress return employer.getaddress class employer string address employer string a address a string getaddress return address role class agent extends person agent string n string a super n a class main static void main string... args employer gvnmt new employer london employee bond new employee bond secret gvnmt assert bond.getcontactinfo .equals bond london assertion agent doubleo7 new agent bond secret organization mi6 new organization doubleo7.join mi6 assert mi6.hasmember doubleo7 assertn assert mi6.hasmember bond assertion figure a running example with two role classes implemented as subclasses of an entity class public modifiers have been omitted to avoid clutter .
interface person string getaddress string getcontactinfo void join organization org r extends personrole r addrole class r spec object... arguments ... class personcore implements person private string name address private collection personrole roles new hashset personrole personcore string n string a name n address a string getaddress return address string getcontactinfo return name getaddress void join organization org org.addmember this r extends personrole r addrole class r spec object... arguments r role ... roles.add role role.core this return role ... abstract class personrole implements person personcore core string getaddress return core.getaddress string getcontactinfo return core.getcontactinfo void join organization org core.join org r extends personrole r addrole class r spec object... arguments return core.addrole spec arguments ... class employee extends personrole ... employee employer e employer e class agent extends personrole agent class main static void main string... args person james new personcore bond secret employer gvnmt new employer london employee bond james.addrole employee.
class gvnmt assert bond.getcontactinfo .equals bond london assertion agent doubleo7 james.addrole agent.
class organization mi6 new organization doubleo7.join mi6 assert mi6.hasmember doubleo7 assertn assert mi6.hasmember bond assertion figure adoption of the rop as defined in for the code of figure only changes are shown.
.
the r ole object pattern figure gives an impression of the problem.
in the current design of a j ava program a class employee derives from a class person and adds to it a relationship to class employer modelled as a field of the same name .
employee also overrides the method getaddress inherited from person returning the address of the employer.
getaddress in person is complemented by a method getcontactinfo containing an invocation of the former which depending on the receiver the value of this may bind to the implementation in person or employee .
employee which represents a role of person has a sibling class agent adding no state or behaviour to person .
all three classes share the fields name and address defined in person .
the example is completed by a class organization whose instances maintain a set of person objects representing the members of an organization.
persons can be made to join organizations by invoking a method join .
on them which passes this to the addmember .
method of organization figure line .
the main.main ... method creates two instan ces one of role class employee one of role class agent which are to represent the same person in different roles a s expressed by assigning them the same name and address and lets the latter join mi6 an instance of class organization .
the intended meaning of the program is expressed by three assertions placed in its main method.
quite obviously this sample pr ogram contains a logical bug although the instances named bond and doubleo7 are meant to represent the same entity they are actually different and totally unrelated objects.
this is evidenced by the failure of assertion testing for the membership of bond in mi6 to which doubleo7 had just been added.
it is these situ ations in which the rop is usually adopted.
figure shows the code changes implied by a naive adoption of the rop.
except for the omission of the remaining methods implementing role management c f. figure it corresponds precisely to the implementation specified in .
the general class structure of the rop also adopted from is shown in figure .
the main difference between the original design and the rop is that the original person class is now an interface serving as a common abstraction supertype of a new personcore class and a new abstract personrole class.
the two new classes form a composition in the sense that a core and its role objects together represent one logical entity the so called subject .
since both classes implement the person interface instances of either can represent the subject in a context in which an instance of person is expected maintaining the subtyping relations hips of the original program.
note that the fields representing the state of the former class person which are now defined in personcore are no longer inherited by the role classes their instances share state with the core object that is stored in a field named core.
for this purpose access requests to the shared state are redirected to the fields of the core through corresponding accessor methods which must be introduced if not already present.
as before the role classes which must be subclasses of personrole can add their own state and behaviour complementing those of personcore .
using the rop it is now possible to express that the objects named bond and doubleo7 are two roles of the same object james which is itself an instance of class personcore lines and in figure .
note that the rop mandates that role objects here instances of subclasses of personrole are not created directly by clients rather clients are to invoke the factory method of the core here addrole ... of class personcore note that it is called addrole since it creates the role and adds it to the core in one step .
executing the so changed code one might expect assertion to hold since the method personcore.join .
adds this to the organization line where this points to an instance of the core which is the same object namely james for both bond and doubleo7 .
however instead of correcting the bug of the original program in figure all three assert ions now fail!
what went wrong?
.
problems of the r ole object pattern the adoption of the rop performed in the previous subsection is naive because it introduces a change of binding that is revealed by the failure of assertion line in figure instead of returning the address of the employer as specified in class employee line getcontactinfo called on an employee now returns the private address from class personcore line in figure .
why is that?
the problem is that personrole.getcontactinfo line uses forwarding where it should have used delegation .
with delegation this in the delegated method here personcore.getcontactinfo would refer to the instance of the delegator here bond an instance of class employee rather than to an instance of the delegatee here james instance of personcore and calling a method on this would invoke its im plementation in the delegator if it exists rather than in the delegatee.
while delegation is the native inheritance m echanism of prototype based languages such as s elf it is not directly available for instances in most mainstream object orie nted programming languages including j ava c and c .
to fix this problem which exists in many design patterns suggest adding a parameter to the delegated method that refers back to the delegator.
in the above example this would translate to the method public string getcontactinfo return core.getcontactinfo this replacing the original method in personrole figure lines and the methods public string getcontactinfo return getcontactinfo this public string getcontactinfo person del return name del.getaddress behaviour addrole spec hasrole spec removerole spec getrole spec component behaviour addrole spec hasrole spec removerole spec getrole spec component behaviour addrole spec hasrole spec removerole spec getrole spec componentrole behaviour addrole spec hasrole spec removerole spec getrole spec componentrole behaviour addrole spec hasrole spec removerole spec getrole spec componentcore statebehaviour addrole spec hasrole spec removerole spec getrole spec componentcore statecoreroles addedbehavioura concreterolea addedstateaaddedbehavioura concreterolea addedstateaaddedbehaviourb concreteroleb addedstatebaddedbehaviourb concreteroleb addedstatebcore.behaviour core.addrole aspec clienta clientb figure structure of the rop adopted from .
443replacing getcontactinfo in personcore lines .
however this fix requires the core class to know whether the delegating role class here employee overrode a method called on this in the core class before the refactoring here getaddress in personcore line since only then can the call be forwarded back to the delegator.
in fact if there are several role classes here employee and agent some of which overrode the called method employee some of which did not agent a case analysis is needed to decide dynamically whether the delegator or the delegatee is the receiver of met hod calls that are dispatched on this.
fortunately this case analysis can be trusted to dynamic binding by providing a default imp lementation of all methods in question in the abstract role class here personrole to which calls are forwarded and which i nvokes the implementation in the core unless overridden in a concrete role subclass.
in the case of our example the method public string getaddress return core.getaddress note that whether there was an overriding method to be called cannot generally be coded in the delegated method call either for instance by calling the method accepting the delegator as parameter if there is one and the original method if there is not because the delegated method may call ar bitrarily many other methods some of which may have been overridden some not.
must be added to class personrole .
figure shows the resulting somewhat convoluted control flow using sequence diagrams for the different cases a the original program of figure fails because getcontactinfo in personcore calls getaddress of the same class and not the formerly overriding version in employee .
b supplied with it as a delegation parameter getcontactinfo .
in personcore can invoke getaddress on the delegator leading to the desired result here eventually leading to the invocation of getaddress on the employer .
c if supplied with an instance of a class that does not provide its own implementation of getaddress getcontactinfo .
invokes the default implementation inherited from the abstract role superclass personrole which forwards the request back to the core.
as was to be expected the described changes restore the status of assertion .
however assert ion still fails when the invocation of join organization on doubleo7 line in figure is forwarded to personcore line the object this that is to join the organization line changes from the delegator doubleo7 an instance of agent to the delegatee james an instance of personcore .
thus when the organization is checked for the membership of the newly joined agent instance doubleo7 the answer is no since it was the personcore instance james that joined.
the problem here is that the identity of the agent is split among two objects a phenomenon commonly referred to as object schizophrenia .
note that as far as the failure of assertion is concerned the problem can be fixed by passing doubleo7 as an additional delegator parameter to the personcore.join .
method and by replacing this in its body with delegator however this leaves the failure of assertion which is also caused by object schizophrenia unaddressed.
object schizophrenia is a known problem of the rop.
since an object playing a role is split into two instances one of the role class and one of the core class tests for identity of two