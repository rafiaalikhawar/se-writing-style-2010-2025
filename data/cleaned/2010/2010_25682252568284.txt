transition from cen tralized to decentralized version control systems a case study on reasons barriers and outcomes k van mu lu university of washington seattle wa usa kivanc cs.washington.edu christian bird nachi appan nagappan microsoft research redmond wa usa cbird nachin microsoft.com jacek czerwonka microsoft redmond wa usa jacekcz microsoft.com abstract in recent years software development has started to transition from centralized version control systems cvcss to decentralized version control systems dvcss .
although cvcss and dvcss have been studied extensively there has been little research on the transition across these systems .
this paper investigates the transition process from the developer s view in a large company.
the paper c aptures the transition reasons barriers and outcomes through developer interviews and investigates these findings th rough a survey participated by developers.
the paper identifi es that the majority of the developers need to work incrementally and offline and manage multiple contexts efficiently.
dvcss fulfill these developer needs however the transition comes with a cost depending on the previous development workflow.
the paper discusses the transition reasons barriers and outcomes and provides recommendations for teams planning such a transition.
the paper shows that lightweight branches and local and incremental commits were the main reasons for developers wanting to move t o a dvcs.
further the paper identifies the main problem s with the transition process as steep dvcs learning curve incomplete dvcs integration with the rest of the development workflow and dvcs scaling issues.
categories and subject descriptors d. .
distribution maintenance and enhancement version control general terms measurement human factors.
keywords version control system dvcs cvcs distributed centralized productivity barriers empirical transition .
.
introduction version control systems vcs s help developers to implement and maintain large systems by letting them collaborate and work on the same project at the same time.
a centralized vcs cvcs keeps all development history in a central server whereas a decentralized vcs dvcs keeps the development history on each development machine locally .
historically dvcs s came later than cvcs s try ing to address the limitations of cvcs s such as enabling lightweight branching local vcs operations and easier collaboration between developers .
although cvcs s and dvcs s have been available for quite a while to the best of our knowledge there is little research on why developers transition from a cvcs to a dvcs.
for a developer who is already proficient with a cvcs transitioning to an unknown dvcs would require considerable effort which would only make sense if the benefits of using the dvcs would eventually out weigh this transition effort .
barr et al.
investigated how the transition affects the project branching structure and the way the developers use branches in open source software oss .
de alwis and sillito investigated the transition process challenges and anticipated benefits for four oss.
to our best knowledge there is no study that investigates the transition process from the developer s view in a large commercial company .
this paper aims to understand transition reasons barriers and outcomes from a qualitative perspective to expand the scientific knowledge for the whole transition process.
to identify the transition reasons barriers and outcomes this paper uses interviews of developers who transitioned from a cvcs to a dvcs within the same project .
the paper also investigates and quantifies the findings through a comprehensive survey participated by developers.
the paper identified that at microsoft dvcss are preferred for some simple but key operations such as incremental workflow through small and local commits and efficient context switching through lightweight branches .
this raises the q uestion whether all dvcs features and specifically being distributed are essential for large commercial companies.
section discusses this question in depth .
the paper makes the following contributions a novel qualitative study with professional developers who transitioned from a cvcs to a dvcs within the same project section identification of the key c oncepts for transition reasons barriers and outcomes through semi structured developer interviews and quantification of these findings through a comprehens ive survey participated by developers sections and in depth discussion of the dvcs features that are favored by the developers to understand whether these feat ures are essential to dvcss.
this discussion concludes with guidelines to people who consider transitioning section .
the reminder of the paper is organized as follows section defines vcs termi nology.
section explains the methodology.
section s and explain transition reasons barriers and outcomes respectively.
section discusses some of our finding in depth and provides guidance to people who consider transitioning .
section discusses threats to validity in the findings .
section puts the paper in the context of the related work.
section concludes.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india .
copyright acm ... .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
.
definitions this section defines vcs terminology used throughout the paper.
a version control system vcs is a tool that helps the developers manage the source code and the development history of a product with the following core functionality backing up the source code seamlessly and letting multiple developers collaborate effic iently .
a repository is the combination of the source code and metadata including all previous version s stored in a vcs.
to work on the source code the developer check s out a version of the history from a repository to a local workspace .
the developer makes changes to the workspace and checks in these changes to the vcs to make the changes accessible to other developers .
during a check in the developer s changes might conflict with changes check ed in by other developers .
all vcss provide a textual merge algorithm that finds the closest common ancestor for conflicting changes and show s the conflicts as a way diff.
a vcs branch is a systematic way to provide isolation by diverging from the development hi story at a specific point.
by default the development in a vcs starts in a branch called trunk .
later the developers can create other branches from existing branches.
a centralized vcs cvcs e.g.
cvs svn is a vcs that stores the development history in a central server.
most cvcs s only store one snapshot typically the latest of the repository locally at any given time .
consequently cvcss scale well regardless of the development history .
however vcs operations that need access to history that is not available locally such as merge must execute on the server.
a distributed vcs dvcs e.g.
mercurial git is a vcs that stores the whole development history as a local repository.
a commit is a ch eck in to this local repository which i s not accessible to other developers by default.
dvcss execute most vcs operations except synchronization with another repository locally.
a bridg e is some tooling between a cvcs and a dvcs that lets the developers use the dvcs but stores the history in the cvcs.
the bridge offers bidirectional synchronization between the cvcs and the dvcs .
figure depicts the ar chitectural diagram of a bridged vcs bvcs which consists of one cvcs one dvcs and a bridge implementation .
this paper uses the terms bridge and bvcs interchangeably.
the re st of the paper does not distinguish between the paper uses the terms check in and check out instead of commit and clone which have different meaning for dvcss and cvcss.
a bvcs and a dvcs since a developer uses only dvcs operations in both.
the term b dvcs stands for bvcs or dvcs.
the term transition stands for the transition from a cvcs to a b dvcs.
.
methodology to understand the transition reasons barriers and outcomes we conducted semi structured developer interviews and a survey participated by developers .
this section explains the methodology for the interviews and the survey .
the results are presented in sections and .
the results are based on our interviews only we use d the survey to quantify and generalize these results .
we only report the survey results for the whole developer po pulation since two tailed heteroscedastic student s t test based on factors such as age and experience showed no statistical significance between sub populations with p .
.
for the interviews we selected developers who transitioned within the same project as they have a better chance to c ompare a cvcs to a b dvcs.
we sent a preliminary questionnaire to two internal b dvcs mailing lists to find candidates .
depending on the questionnaire results we sent individual e mails to recruit developers .
each developer went through a semi structured interview as described in where the interviewer had several questions that tried to capture the developer s familiarity and workflow patterns with different vcs s and the transition reasons barriers and outcomes.
the questions were general to prevent introducing bias .
for example instead of asking whether the developer likes lightweight dvcs bra nches we asked which dvcs aspects th e developers likes and dislikes .
the developers were encouraged to talk in detail for any question or any part of the transition that the questions did not cover .
each interview lasted about an hour and was recorded .
after the last interview was completed we coded the re cordings.
for each coded interview we generated to cards containing the key points .
at the end we printed a total of cards.
w e sorted these cards to categorize the responses for thematic similarity as illustrated in latoza et al.
s study .
the se themes that emerged during the sort were not chosen beforehand .
finally we went over each theme and categorized the cards in that theme into sub themes .
figure shows the cards with themes and sub themes written on yellow stickers.
figure card sorting.
yellow stickers represent a sub theme.
figure the architectural diagram for git p4.
the developers on the left use git.
they synchronize with either the main git repository git logo at the top left or their peer s private git repositories small git logo s at the bottom left .
the developers on the right use perforce a nd only interact with the main perforce repository .
git p4 synchronizes the main git and perforce repositor ies in both directions.
335we designed a survey to quantify our findi ngs from the interviews.
kitchenham and pfleeger discuss the design and construction of personal opinion surveys using the following steps searching the relevant literature construct an instrument evaluate the i nstrument document the instrument.
in our survey as suggested by kitchenham and pfleeger we use f ormal notations limit our res pondents responses to numerical yes no type likert scale and short free form answ ers.
respondents were anonymous.
we f ollowed kitchenham and pflee ger s advice on the need to understand whether the respondents had enough knowledge to answer the questions in an appropriate manner.
for this we restricted the people invited to partic ipate in the survey to people who had registered in the b dvcs mailing lists .
additionally even if the developers had never used a cvcs or a b dvcs they could skip the related parts of the survey and still be included in the drawing2 ensuring that no one felt compelled to take the survey for the chance to win the gift.
we piloted our survey within researchers before making it available to candidate developers in microsoft .
developer took and completed the survey.
participants and all participants used a b dvcs and a cvcs at microsoft respectively.
participants continue using a b dvcs.
table summarizes the remaining demographical properties for the survey participants.
.
transition reasons this section focuses on the following four main transition reasons the ability to work offline work incrementally context switc h efficiently and do exploratory coding efficiently .
figure summarizes the related survey results.
i the ability to work offline all developers we interviewed focus on the importance of being able to work offline.
the majority of the survey partici pants vs. agree with this observation.
some cvcss require the developer to be connected to the server before editing a file for the first time which makes it more difficult to work offline .
the manual workaround s are tedious.
for example the developer could ignore this requirement start editing survey respondents could e mail us separately outside of their survey responses to enter a drawing for four rewards .
the file and attempt to check in changes when s he is connected to the serve r in the future .
at this point the cvcs would attempt to replay developer s actions .
if any step fails due to other check ins developer s c heck in fails.
moreover developers cannot work easily when the central server is down or having bandwidth problems .
the developers believe that with a b dvcs they can work offline.
when using a b dvcs the developers need to interact with the central server only when they need to check in their changes to or check out new changes from the server.
ii the ability to w ork incrementally in our interviews all developers except one focus on the importance of incremental and frequent commits .
of the survey participants support this observation by favori ng small frequent commits to one large check in.
cvcss do not support commits .
the moment a developer checks in to the server the changes are accessible to everyone.
some development practices suggest that the developers should check in complete and working code which makes it more difficult for the developer s to create checkpoints for their current work .
these check points are useful for understand ing how a recent code has evolved in time and return ing back to a previous version quickly.
microsoft p roducts use continuous integration checked in changes go through quality gates where they are built and tested .
before checking in most developers also go through a simplified quality gate called check in wizard which builds and tests the modified components locally to get an early assessment of software quality .
one execution of the check in wizard can occasionally take a long time which discourages the developers to do frequent check ins.
the survey participants have mixed feelings agree vs. disagree on whether the quality gates affect the development workflow negatively or not.
nonetheless t he developers believe that dvcs s would let them work incrementally and go through the check in wizard less frequently via commits .
iii the ability to context switch efficiently all developers we interviewed focus on the fact that cvcss make it very difficult to work on multiple tasks simultaneously .
working on multiple tasks such as developing a new feature or fixing a bug is common for the developers.
figure summarizes the most popular cvcs techniques for context switching.
top two of these techniques is to check out the code multiple times on different file system locations multiple enlistments and create a delta for each different change and manually manage these deltas patches .
checking out the code multiple times increase the storage space needed for development cvcs workflow is non optimal as i have to be online.
cvcs workflow is non optimal as quality gates are too slow.
cvcs workflow is non optimal as context switching is hard.
i prefer frequent and small check ins to one large check in.
at microsoft creating a branch is an organizational decision.
i would prefer using vcs branches for context switching.
strongly agree agree neutral disagree strongly disagree n afigure survey results related to transition reasons colored .
the second and last questions are answered by and qualifying developers.
more than of the developers agree that they cannot work efficiently with the current cvcss at microsoft becaus e they have to be online and cannot context switch easily.
most developers prefer to work with small incremental commits and u se vcs branches for context switching.
of the developers agree that creating and deleting branches is an organizational decision at microsoft.
finally the developers have mixed feelings agree vs. disagree on whether quality gates affect their development workflow neg atively.
table survey demographics demographic property average value development experience .
years experience at microsoft .
years experience with cvcss at microsoft .
years experience with dvcss at microsoft .
years 336linearly .
more importantly each time the developer checks out new changes from the server every code location needs to be rebuilt even if their content s are mostly the same .
when using patches the developer needs to create and manually maintain these patches.
one developer mentions i use other tools beside to s ave bits and pie ces of my work.
u sing one of these i can take a snapshot of ... i try naming meaningfully e.g.
bugid 1 bugid 2 but i don t do a good job.
of t he survey participants agree that cvcs s they use do not provide efficient ways to context switch.
the fact that all of the survey participants except one do not use private branches as a standalone technique was surprising for us.
however at microsoft the branches for a product is often an organizational decision.
of the survey participants agree with this observation.
all check ins need to go through quality gates which means that all branches need infrastructure support such as build and test labs.
therefore it is not easy for a developer to create and delete private branches as s he sees fit.
on the other hand with dvcs s a developer could create a pri vate branch do changes check in locally merge her his branch to one of the organizational branches and check in the changes on the organizational branch.
for other developers and for the central server it is as if the private branch never existed.
ther efore t he developers believe that they can context s witch efficiently using dvcs branches.
iv the ability to do exploratory coding efficiently half of the developers we interviewed mentioned that cvcs s limit their ability to do exploratory coding .
exploratory coding is when developers pursue a new feature protot ype development to explore its feasibility without complete knowledge of its ability to be successful or not.
exploratory coding can be seen as a task that requires a new context however differs from the usual context switches in two aspects explorat ory coding might take a long time before it becomes a prototype that can be checked in and some exploratory coding never make s to the product.
therefore exploratory coding might be viewed as a longer and potentially disposable context switch.
with st rict and pre defined branches the developer has to manually manage any exploratory coding which makes it more difficult and not worthwhile.
the developers believe that dvcs branches will let them do exploratory coding efficiently.
this section identifie d four important cvcs drawbacks.
we discuss how a dvcs can remove these drawbacks in section .
.
.
transition barriers this section focuses on three major problems faced by the developers during the transition.
section .
discusses the steep dvcs learning curve section .
discusses incomplete dvcs integration with the rest of the development workflow and section .
discusses the dvcs scalin g issues with huge products with long histories.
these barriers can be viewed as downsides of dvcss since workarounds require developer effort learning curve and incomplete integration and changes in the development workflow scaling issues .
figure summarizes the survey results .
.
learning curve most dvcss have higher learning curves compared to cvcss because of three reasons the centralized model where all development goes through a central repos itory is easier conceptually dvcss have advanced concepts such as rebasing and transplanting which have no cvcs correspondence and the conflicting terminology between cvcss and dvcss .
of the survey participants agree that dvcss have h igher learning curve .
i centralized vs. decentralized model in cvcss the developers interacts with one central repository.
all developers synchronize through this central repository .
on the other hand in dvcss developer s have local repositories .
the developers commits their changes to their local reposito ries first and then check in to a globally accessible repository .
the content of the global repository can be different than the content of the developers local repositories which can be different than the content of the developers workspaces.
although not frequently used in big projects the developers can directly synchronize through another developer s local repository.
with increased number of repositories and multiplied possibilities for sharing code dvcss are harder to reason about .
ii advanced dvcs concepts cvcss do not let developers modify the development history easily.
once a change is checked in to the central server it is remembered indefinitely.
dvcss give more control to the develo pers in terms of history management.
however with great power comes great responsibility a developer can modify the development history in an irrevocable way us ing advanced dvcs commands.
a developer mentions so open ended ... if people do wh atever the y want can irrevocably lose data .
iii conflicting terminology another difficultly in learning a dvcs for a developer who already knows a cvcs is the conflicting terminology.
dvcss have some commands that have the same name as a cvc s command but have a different meaning.
for example in cvcss when a developer commits her his changes are checked in to the central repository.
however in dvcss when a developer commits her his changes are only stored in her his private local reposit ory.
unless the developer shares her his local repository with other developers these changes are not accessible until the developer pushes them to a globally accessible repository .
learning curve due to conflicting terminology is bidirectional the developers who learn a dvcs first might also experience similar problems.
for the same example the developer who switches from a dvcs to a cvcs would be surprised that her his changes are accessible to other developers when s he commits .
in addition to the higher dvcs learning curve three developers we interviewed mentioned that the bvcs increases the learning curve since the developers need to understand how the bridge interacts with bo th vcs s and learn brid ge specific commands.
the t ransition process requires the developers to change their perception of how vcss work learn a new vcs and potentially learn a bridge tooling .
a part of dvcs learning curve is non essential since any new te chnology has some learning curve.
three developers we interviewed mentioned that the internet contains tremendous figure cvcs techniques that are used for context switching colored .
most of the other techniques boil down to careful management of multiple changes manually.
337amount of docu mentation for the popular dvcss which might mitigate the le arning curve.
one developer notes another thing i like about is there is so much documentation available online.
.
incomplete integrati on the developer s might not fully appreciate the b dvcs features due to two major reasons incomplete bridge implementation and missing tooling around the b dvcs s. this section focuses on the bridge s bvcs s between dvcss and the cvcss in microsoft and discusses these problems in detail.
although of the survey participants do not think th at b dvcs s are missing important features the participants have mixed feelings agree disagree on whether b dvcs s are integrated well with the rest of the development workflow.
i incomplete bridge implementation some bvcss at microsoft do not support all feat ures available in the surrounding vcss they bridge .
a developer states and have power individually howe ver these powers are not exposed by .
a particular bvcs uses the same file system location as a dvcs and a cvcs repository at the same time which causes interaction problems between vcss .
a develope r mentions looked like something between two worlds.
some tools would a in the workspace sometimes operations would not work .
ii missing tooling around b dvcs for developers in large companies the code involves in additional steps before it is shipped in a p roduct.
for example the developer s run tests and do code reviews before the code is shipped .
these s teps may require additional tooling such as vcs integration with code reviews.
cvcss at microsoft are integrated very tightly and seamless ly with the whole development process from implementation to shipping .
there are teams whose main responsibility is to create and maintain cvcs integration tools .
when a developer uses a cvcs all stages of the development workflow just works.
however the same is not true for some bvcss yet.
some bvcss are maintained only by a sub team and are integrated to the particular development flow of that sub team wh ich may be different from the other teams.
if a developer from a nother team wants to use this bvcs s he sacrifices existing tooling for the rest of the development workflow and needs to do these steps manually.
for example some bvcss are not integrated wit h the check in wizard.
for some teams it is required to commit the code through the check in wizard which means that the deve lopers who use such bvcss cannot check in their changes directly .
these developers c reate a patch for the changes apply this patch to and check in from another cvcs repository .
in other words the development is done on bvcs however the code is checked in through cvcs .
a developer mentions i cannot use to check in changes to because we use c heck in wizard a nd does not support it.
i create and apply it on a repository to check in.
using existing mature open source bvcss do not solve the tooling problem .
the se bvcss have no knowledge of the development workflows and additional tools use d by microsoft .
tool immaturity is non essential to dvcss since any new technology will lack tool support for an existing development workflow.
still we believe that bvcss will be useful only when the bvcs is integrated with the rest of the development workflow as well as they are integrated with the cvcs and dvcs they bridge .
all developers we interviewed felt that the bvcss in microsoft were missing important features and external tool support which makes it too early to su ggest for a team wise adoption .
.
scaling at microsoft there are large codebase s that have been developed for more than a decade .
dvcss check out the complete history all source code and every change that has been happened to every development machine by default.
for a product that is tens of gb s in size and has been developed for many years using a dvcs can cause scaling problems.
this section focuses on three main causes of the scaling problems checked in large binaries composite products and long development histo ry.
only of the survey participants agree that their product scales to b dvcss by default whereas the agreement increases to after an initial setup see figure .
i checked in large binaries one of the major causes of the scaling problem is the large binaries checked in to the vcs.
ten survey participants believe that dvcs scaling can be achieved if the binary dependencies were not checked in to the vcs.
vcss only record the difference with respect to the latest version in the history.
for text files the overhead of recording this difference is very low.
on the contrary vcs s record all versions of a binary file.
deleting the previous version s does not solve the problem since the vcs has b dvcss have high learning curve.
b dvcss are missing important features.
b dvcss are integrated well with the dev.
workflow.
b dvcss scale to our product by default.
after an initial setup b dvcss scale to our product.
b dvcss let me work offline.
b dvcss let me work incrementally with local commits.
b dvcss let me context switch efficiently with branches.
strongly agree agree neutral disagree strongly disagree n afigure survey results related to transition barriers and outcomes colored .
these questions were answered by participants who have used a b dvcs at microsoft.
of t he participants note the learning curve with b dvcss.
of the participants do not believe that b dvcss are missing important features.
participants have mixed feelings agree disagree on whether b dvcss are not integrated well with the rest of the development workflow.
only of the participants agree that their product scales to b dvcss by default whereas the agreement increases to if the participants are permitted to do an initial setup.
more than of the participants agree that b dvcss let them work more efficiently using local commits and l ightweight branches.
338to keep the previous version s just in case a developer needs to access some previous version.
dvcss check out the whole development history which causes scaling issues for binary files.
on the other hand cvcss check out the latest version and therefore do not experience similar scaling issues .
at microsoft developers mainly check in binaries to the repository so that external dependencies required to build and test the product from the compiler to the external libraries are available when a developer checks out the repository .
this workflow is convenient for the developer s as they can start working immediately without any product specific setup .
a developer confirms this observation but questions whether the binaries really belong in the vcs at microsoft the entire tool chain in the repository.
this is very useful becau se has all dependencies .
however i wonder if really belong to the ?
it may be better to configure and version the dependency without checking it in.
ii composite products another cause for dvcs scaling p roblem is large composite products.
seven survey participants agree that composite products affect dvcs scaling negatively.
some microsoft products contains multiple sub products .
for example microsoft office contains microsoft word excel powerpoint an d onenote in all versions.
storing all these products inside one repository makes it easier to share code and dependencies between these products.
on the downside the repository contains the development history for four products instead of one which caus es a scaling problem when dvcss check out the whole history.
cvcss do not suffer from the same overhead as whole history is stored on the server only which scale s better than development machines.
iii long development history the final scaling problem is due to the long development history for the product s. four survey participants believe that scaling can be achieved by limiting the local history checked out from the repository .
some microsoft products are developed longer than a decade .
it is very rare that a developer needs the history from a decade ago to understand or resolve a problem.
most of the time the develop ers use very recent history maybe from a miles tone back.
dvcss check out the whole development history by default which increases the initial check out time.
in general developers seem to start experiencing scaling issues when the repository is larger than a few gb s and has a history longer than several years.
considering that this is a one time cost the developers generally tolerate it as long as the process completes overnight.
a developer states in my case was ten hours with one interruption and that was okay for me.
since dvcss check out and maintain the complete development history the problems described in this section are essential to dvcss.
figure shows that survey part icipants believe that dvcs scaling can be achieved for microsoft products by solving some of these issues.
section .
will discuss alternative workflows and advanc ed dvcs operations that help with mitigation .
.
transition outcomes this section discusses the transition outcomes.
section .
revisits the transition expectations and problems with cvcss and discusses how dvcss meet these expectations.
section .
discusses the transition s effect on developers perception for p roductivity.
for the survey figure we asked the developers to limit their answer only to their experience at microsoft.
.
reality meets expectations this section re visits the transition expectations described in section and discusses which dvcs features are used to meet these expectations.
i ability to work offline dvcss check out the whole history which makes it possible to execute all operations except synchronization with another repository offline .
the developers can checkpoint their work with commits create a private local branch for another ta sk or learn who modified some file recently .
figure shows that of the survey participants agre e that b dvcss let them work offline.
ii incremental workflow figure shows that of the survey participants agree that using b dvcss let them work in crementally though commits .
commits act as checkpoints the developer can revert back to a recent version if some c hange causes a problem .
the ability to create checkpoints makes debugging ea sier.
for example a developer states frequent you want to see your recent ... with it is likely that i had several commits in the morning and i can go back to see what is broken.
incremental workflow with frequent commits raises a de bate on whether the developer s should check in these commits directly or transform t hese commits into a few larger and logical commits first and check in these logical commits .
most dvcss provide advanced history manipulation commands such as rebasing to squash multiple commits into one.
one developer states i use rebase often.
i think th e history is a code deliverable.
although the developers change the history to replace many small commits with one larger logical c ommit s ome developers we interviewed felt that changing history is wrong.
one alternative approach would abstract the visualization of the development hist ory rather then re write it.
another developer agrees with this observation rebasing should not be used for making more r eadable .
the vcs should know about the deltas the is just a representation problem.
iii fast and easy context switches figure shows that of the survey participants agree that lightweight branches in b dvcss let them context switch efficient ly.
unlike most cvcss dvcs branches record deltas with respect to an ancestor in the history.
so switching to a branch brn requires the dvcs to check out the ancestor of brn and apply the deltas.
when the developer completes the task s he can merge brn to dev a globally accessible develfigure major reasons for dvcs scaling issues for microsoft products colored .
no issues represents the case where dvcs scales by default.
the survey also had options other reasons and impossible to scale which are selected by and participants respec tively.
339opment branch and check in the changes from dev.
for other developers brn has negligible overhead and does not matter it is a s if the developer worked on dev the whole time.
all developers we interviewed except one confirmed that dvcs branches provide fast and easy context switching in large products at microsoft.
one developer points the following quirk benefit of using multiple branches were detrimental because of the long build times between branch switching .
this developer points out the following problem when a developer switches to a branch the code changes and needs to be rebuilt .
for incremental builds assuming that the difference betwee n two branches is small this is not an issue.
however if the build is not incremental and a full build requires several minutes then the developer cannot switch branches very frequently.
in such cases having one repository for each task and manually managing these repositories might be more efficient.
iv fast and easy exploratory coding similar to context switching the developers can do exploratory coding efficiently using dvcs branches.
when the developer has an idea s he creates a private branch exp and commits a few changes .
then the developer switches back to other branches to work on other issues and forgets exp.
if the work in exp becomes important in the future the developer switches back to exp merges it with the trunk and continue s the implementation from where s he left.
dvcs branches encourage the developers to try out difficult and complex tasks that might not ship immediately without the fear of failure.
a developer confirms this observation logistics of was effortless.
i create a branch ... i can make changes without wo rrying.
a b dvcs can improve a developer s workflow with local history and lightweight branching.
however these advantages will be useful only if the developer s project scales to the b dvcs and the developer can use the existing external tools in her his workf low.
if the obstacles overweigh the benefits it is less likely that the developer will be willing to change her his current workflow.
the survey shows that out of participants who transitio ned of them are no longer using a b dvcs .
the most popular reasons for returning to cvcss are limited integration with the rest of the development workflow scaling issues and the fact that the rest of the team uses a cvcs.
being offline and working on a private branch could diverge the developer from the trunk and cause severe conflicts when the developer merges the se changes into the trunk .
in our interviews only one developer raised this concern.
microsoft developers synchronize with each other frequent ly which might mitigate the severity of future merge conflicts.
we leave in depth investigation of transition s effects on the severity of merge conflicts as future work.
.
perception for productivity during developer interviews we specifically asked the developer s whether their perception for the following productivity metrics have changed after the transition code volume produced daily implementation speed code velocity and code quality .
figure summaries the survey results .
i code volume half of the developers we interviewed and of the survey participants felt producing more code after the transition whereas the other half felt no difference in terms of the code volume produced daily our question was used as a measure to identify developer s perception towards code volume and had no implications on develope r productivity .
the most popular explanation for the increase in volume is commits in b dvcss.
the developers could produce more code because they were able work more offline and they could commit frequently without worrying about going through quality gates each time.
ii implementation speed six developers we interviewed and of the survey participants felt faster after the transition whereas four developers we interviewed and of the survey participants felt no difference in terms of implementation speed.
the most popular explanation for the increase in implementation speed is using lightweight b dvcs branches for context switching .
the developers spent less time on manually managing the context for each task which lets them do the same work faster .
iii code velocity transit time code velocity is the time that it takes for an edit to reach to one of the main branch es from the branch it was checked into .
although the developers we interviewed felt no difference of the survey participants felt that their code vel ocity has increased after the transition.
most developers we interviewed made a transition to a bvcs.
therefore once the developers synchronize with the cvcs their check ins would still go through the same integration process to reach to one of the main branch es.
a developer states is a team process it does not change with the vcs you use.
iv code quality all developers we interviewed except one felt no difference in terms of code correctness after the transition.
similarly only of the survey participants agreed that their code correctness increased after the transition.
similar to code velocity the developers seems to believe that the code correctness depends on personal practices and the q uality gates used by the team rather than the vcs used during the development .
regardless of the vcs used to store the product using a dvcs seems to make the developers write more code faster without reducing the qu ality of the code or the frequency of deployment .
the developers get more productive because the dvcs s support some development workflows better such as frequent and incremental commits and efficient context switching which leaves the developers more time to work on the actual implementation.
.
discussion this section discusses the findings in depth.
section .
investigates whether the benefits provided by the dvcss are e ssential .
section .
revisits the dv cs scaling issues and presents alternative workflows and advanced dvcs features to mitigate these issues.
section .
discusses the importance of a fine grained se curity model for commercial companies.
section .
discusses a b dvcs workflow for incubation projects that can be adopted by existin g cvcs products immediately .
section .
concludes the discussion with recommendations for the people who consider transitioning .
figure presents the re lated s urvey results .
i implement more code.
i implement code faster.
my code velocity is faster.
my code is more correct.
s. agree agree neutral disagree s. disagree n afigure transition s effect on developer s perception of code quality colored .
half of the developers agree that after the transition they implement more code faster and their code has higher velocity.
however for code correctness the developers have mixed feelings agree vs. disagree .
.
essential versus non essential section .
identified two dvcs features that let the developer s meet the expectations outlined in section o ffline commits that enable incremental workflow and l ightweight branches that enable efficient context sw itching and exploratory coding.
this section investigates whether these fea tures are essential to dvcss or not.
i offline commits dvcss offer offline commits easily because each developer has access to a local private repository which records all information s uch as commit s parent and branch required to check in this comm it to a another repository .
we believe that cvcss could offer ad hoc offline commits where the developers can only commit on top of the existing checked out versions most of the time only the latest version .
however we also believe that the cvcss are bu ilt on the philosophy where a change in the repository should be accessible to othe r developers immediately .
therefore we identify incremental workflow via offline commits as essential to dvcss.
ii lightweight branches most cvcss use file system based heavyweight branches compared to pointer based lightweight dvcs branches.
for example when a new branch is created perforce creates a symbolic link from each file in the new branch to the actual files .
using symbolic links is quite efficient in general since perforce only materialize s the files that are modified in the new branch.
however if a product has a very large number of files creating lots of symbolic links might take considerable amount of time and introduce substantial overhead to the server where all met adata is stored.
conversely most dvcs branches are pointers to specific points in the development history which makes branch creation instant.
we believe that cvcs branch creation deletion and switching would have been equivalently efficient if cvcss implemented pointer based branches .
consequently we identify lightweight branches as non essential to dvcss.
.
revisiting dvcs scaling issues section .
explained three major causes for dvcs scaling issues that the developers face .
this section discuss es alternative workflows and dvcs operations that can mitigate these issues .
i checked in binary dependencies one way to resolve dvcs scaling issues due to checked in binary dependencies is to use a project manager similar to maven .
with a project manager the developers can specify the product dependencies using a declarative language.
to use a project manager microsoft would setup an internal server that contains and serves product dependencie s. now the developers can update the product specification instead of checking in the dependent binaries.
when a developer checks out the product s he will not immediately have all the dependencies to build and test the product.
however most project managers integrate with the build and test systems seamlessly so the moment the developer wants to build the product the project manager would download or update all dependencies and then build the product .
a project manager can purge binary dependencies from the product repository without changing the development workflow drastically.
ii composite products to resolve the composite products problem the product needs to be re architected which requires considerable work.
dvcss encourage the developers to store each product even each module in a separate repository and share code between these repositories.
for example git provides submodules a systematic way to create a dependency to a particular point in another git repository s history.
using code sharing between dvcs repositories the developers could re architect the product so that the common code is stored in one dvcs repository and the top level products are stored in other dvcs repositories.
then the common repository would code share with each top level product repositories .
after this re architect ure a developer who needs to work on a product checks out the complete history for that product which contains only one version of the common code .
decomposition solves the scaling issues due to composite product s. iii long development history dvcs scaling issues for products with very long histories can be mitigated by check ing out the history partially.
for example git allows shallow clones where the developer limits the number of versions checked out by a depth.
one big disadvantage of checking out a partial history is that the developer might not be able to check in her his changes back to another reposito ry if the local repository cannot perform the check in operation due to missing history .
in this case the developer might try to check out more of the history and retry which is a manual and tedious process .
thus checking out the history partially is not ideal and we do not recommend it unless the scaling issue becomes unbearable.
it is possible to solve most of the scaling problems by following some dvcs workflows and using advanced dvcs operations.
however applying thes e solutions takes time and lengthens the transition period d epending on the previous development workflow.
therefore we suggest the people to consider about the changes that needs to be done for mitigating the scaling problems and account for this cost b efore the transition.
.
fine grained security in cvcs four developers we interviewed mentioned for lar ge commercial companies it is mandatory for the vcs to provide a finer grained security model.
currently dvcss provide security only at the repository level.
if a developer has access to a repository then s he has access to all files in that repository.
commercial software companies sometime s have sensitive features in their products where only a limited number of developer should ha ve access to.
these features are generally stor ed inside an existing product repository where other developers have access to.
cvcss let the administrators update the access rules at file level granularity so that the files related to the sensitive feature are only accessible by the d evelopers who are working on that feature .
providing the same finer grained security model in a dvcs is more difficult as dvcss check out the whole development history.
to provide the finer grained security model the dvcs s should strip a if supported properly i would use a b dvcs at microsoft.
advanced b dvcs features are critical for dev.
workflow.
b dvcss are good for incubation as sharing code is easier.
strongly agree agree neutral disagree strongly disagree n afigure remaining survey results colored .
of the developers agree that they would prefer to use a b dvcs at microsoft if it was fully supported.
of the developers agree that b dvcss are good for incubation since they make code sharing between developers easier.
developers have mixed feelings agree neutral disagree whether advanced dvcs features are non critical for their workflow at microsoft or not.
341portion of the history depending on the access rights of the developer before checking out.
stripping the history similar to checking out the history partially might create problems with some of the operations.
alternatively t he finer grained security model would also work with dvcss if the sensitive feature could be stored in a new repository which would use the main product repository via dvcs code sharing .
then t he repository for the sensitive feature would be accessible by the de velopers working on that feature only.
.
incubation with b dvcs four developers we interviewed suggested that a b dvcs can be used immediately for incubation in an existing product that uses a cvcs.
figure shows that of the survey participants agree with this suggestion.
during the incubation of a new feature several developers work in an agile fashion to quickly prototype and test the new feature.
dvcs workflow practices such as small and frequent commits and lightweight branches work well with a gile development .
usin g a b dvcs help s these developer implement the prototype quickly and go through the quality gates only once at the end when the prototype is complete.
finally the feature can be integrated into the product s cvcs repository through bvcs mirroring or transferring the dvcs history manually .
one particular aspect that dvcss shine for incubation is the ability to share code between developers private local repositories.
while developing a new feature i n an agile fashion most of the time the developer s changes are not ready to be checked in to a globally accessible repository.
h owever the developer s might need other developer s changes .
sharing these incomplete changes through a globally accessible repository would pollute the development history with incomplete and possibly non building versions.
therefore the developers prefer to synchronize with another developer s private repository directly.
seven developers we interviewed confirmed that dvcs s peer to peer sharin g works seamlessly and efficiently for sharing non building and incomplete changes between developers.
.
recommendations we conclude the section by providing some recommendations for the developers teams and managers who consider transition ing.
identify the product and developer needs carefully for large products in large companies it is rare to use advanced dvcs operations such a s modifying a globally accessible history or transplanting a portion of the history from one branch to another.
almost all developers mentioned that dvcss provide advanced operations and give more power to the developer s compared to cvcss however during the interviews only a few developers stress ed that these advanced operations are critical for their workflow .
figure summarizes the related survey results.
survey participants confirmed that extendin g the existing cvcss with some offline operations and lightweight branches would make the transition for their workflow at microsoft unnecessary.
if most developers are interested in only lightweight branches cvcs s might be modified to provide lightweight branches.
if the developers a re interested in the offline commits then a bvcs could be as good as a dvcs .
as most of the products are already stored in a cvcs transitioning to a bvcs should be less expensive than transitioning to a dvcs.
if the developers want to use agile p rogramming for a particular feature then using b dvcs temporarily for the development of this feature might be easier than a complete transition .
we would like to remind the reader that w e are not suggesting that the transition is inevitable or unnecessary rather we stress that the transition comes with a cost.
thus we hope that the benefits of dvcs s alternative solutions and the transition cost is weighed correctly and in depth before the transition.
consider the tooling around vcs carefully section .
identified incomplete bridge implementations as one of the biggest barriers for the transition.
software in large compani es are not limited to programming.
the development process contains external tools for code reviews quality controls and packaging before a piece of code gets shipped in a product.
considering the external tools integration with the new dvcs and making sure that the new dvcs can interact with the existing tools in a similar fashion the old cvcs did will increase the chance of the transition by reducing the problems faced by the developers during the transition.
figure shows that of the survey participants agree with this observation and would switch to a b dvcs if there were proper support.
transition on a team basis when transitioning to a new tool for an existing product it is generally a good idea to let a few developers early adopte rs do this transition first to ensure that the existing development workflow does not change considerably with the new tool.
teams an d managers might have the same intuition for the transition to a dvcs where only a few developers use the dvcs in the team whereas the rest continue to use the existing cvcs.
although the intuition is correct this strategy creates an unseen barrier for th e early adopters .
the developers within the same team share code and interact with each other frequently.
being an early adopter makes it more difficult to intera ct and share code with the rest of the team.
consequently the early adopters might perceive the transition negat ively.
therefore we suggest that all developers in a team should make the transition simultaneously .
a developer confirms this observation while using i still need to use because i have to apply other developer s which cannot be done with .
.
threats to validity this section outlines the internal and external threats to validity in the study and discusses how these threats might affect the findings and their generalizability.
internal validity this study conducted a semi structure d interview with the developers.
the interview questions could have biased the developers to focus on some topics more than the others.
we prepared the interview questions as general as possible hoping that the develope rs would focus on the parts that they cared most.
figure survey results for the question which of the following would make the transition unnecessary for your work at microsoft?
colored .
no change is the developers who are already satisfied with cvcss for their work at microsoft .
342since the interviews were recorded the developers might have behaved differently.
we made the recording optional no one declined to reduce any behavioral change .
finally the card conten ts were created f rom our notes and recordi ngs which might be subjective .
to reduce biasing our results in one way non authors helped during card sorting.
external validity this study summarizes the findings at microsoft using developers across interviews and surveys .
o ur findings might not generalize outside of microsoft.
however during the interviews we realized that the developers were focusing on the same high level topics and had very similar conc erns and comments .
therefore we believe that our findings should generalize to other developers and products at microsoft.
to mitigate the low number of interviews we have conducted a web survey to a larger developer audience to quantify our findings fro m the interviews.
this paper focuses on the developers and products at microsoft.
the developers were selected from multiple teams and had varying levels of familiarity with cvcss and dvcss.
therefore we believe that our findings will partially general ize to the developers and products in large companies similar to microsoft .
we think that the extend of this generalization will depend on the particulars of the team and the product .
the findings might not generalize to open source software start ups or smaller products.
it is future work to expand our study to other development settings to generalize the findings.
we plan to use the diversity me trics introduced by nagappan et al.
to expand the results as much as possible.
in general for empirical studies it is necessary to build an empirical body of knowledge .
towards this end we hope that our study helps to contribute to this body of knowledge on vcs s. .
related work to the best of our knowledge the closest work that compares cvcss and dvcss is barr et al.
s investigation on how the use of branches and development history change after the transition of large open source software oss .
they combine the interviews with the lead devel opers in oss projects with mined data from oss projects and find that the developers started using vcs branches more frequently and effectively after the transition to dvcs specific ally for collaborating on the same task .
de alwis and sillito summarize s the transition challenges and anticipated benefits for four oss projects using the developer notes and documentation related to the transit ion.
our work focuses on the transition process at a large commercial company from the developer s point of view and tries to identify the transition reasons barriers and outcomes .
o sullivan discusses the advantages and disadvantages of dvcss to help developers make an informed choice of vcs.
o sullivan stresses offline commits and ease of branching as some of the dvcs advantages and scaling issues with large binary files as a dvcs disadvantage .
our work qualifies so me of o sullivan s claims via professional developers experience on the transition process.
simultaneous to our study brindescu et al.
investigated how a vcs type affects the developer behavior and the development proce ss through a survey on developers and mined data on oss repositories.
they identify offline commits and low learning curve as the top reasons to prefer dvcss and cvcss respectively .
our work investigates the transition process with a focus on developers experience in a large commercial company.
vcs s the idea to store the development history in a structured way for future access and creating back ups have been used for a long time.
rochkind proposed source code control system sccs as one of the earliest vcss .
initial vcss including sccs revision control system clearcase and concurrent version system versioned each file separately .
aide de camp introduced the change set notion that bundles all changes into an atomic entity .
consecutive cvcss such as subversion including the commercial ones such as perforce and team foundation server continued using change set notion.
bitkeeper and bazaar were two of the earliest dvcs s. dvcss including git and mercurial aimed to impr ove the limited branching and merging capabilities offered by cvcss and offer an easier development workflow for collaboration especially in oss projects where developers join to and leave from periodically .
existing research investigated the effects of branching and merging on software development.
this paper investigates the importance of the new features added by dvcss in large commercial products that have been using cvcss for a long time.
previous research showed that software quality can be improved by mining software repositories and vcs histo ry to predict files that have higher chance of generating defects .
this papers investigates transition reasons barriers and outcomes.
.
conclusions this paper is one of the first attempts to understand the transition costs and benefits to a dvcs in a large company.
this paper presents a study investigating such a transition based on qualitative interviews and survey data .
this paper identifies ability to work offline and incrementally and managing multiple contexts efficiently as the major transition expectations .
these expectations are satisfied by commits and lightweight branches available on most dvcss .
however the transition comes with so me barriers due to steep dvcs learning curve limited dvcs integration with the rest of the development workflow and dvcs scaling issues.
an in depth investigation of the dvcs scaling issues identifies checked in binary dependencies composite products a nd long development history as the major reasons.
the paper discusses how these scaling issues can be mitigated with alternative development workflows and advanced dvcs commands.
we conclude this discussion by providing some guidelines for the developers teams and managers who consider transitioning .
we hope that our findings and gui delines will help those people to make a better decision and if they decide to transition plan for the transition better and face fewer problems.
additionally we hope that our findings for transition expectations and barriers will help researchers to i dentify future research areas on vcss that address these problems and shape the future vcs design .
in future we plan to perform controlled studies where a reasonably sized pr oject is developed concurrently using dvcs and cvcs in order to compare and contrast productivity and quality metrics in a comparable experimental scenario.
.
ackowledgements we thank the anonymous reviewers and caius brindescu and oregon state seupl lab for their feedback on the initial submission.
we thank the developers at microsoft for their interest input and help with the study.
thomas zimmermann helped us with the design distribution and the analysis of the survey.
emerson murphy hill thomas zi mmermann gifford cheung and thomas debeauvais helped during the card sorting.
emerson murphy hill provided insight for section .
.