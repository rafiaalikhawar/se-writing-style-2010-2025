property differencing for incremental checking guowei y ang1 sarfraz khurshid2 suzette person3 neha rungta4 1department of computer science texas state university san marcos tx usa 2department of electrical and computer engineering university of texas austin tx usa 3nasa langley research center hampton va usa 4nasa ames research center moffett field ca usa 1gyang txstate.edu 2khurshid utexas.edu 3suzette.person nasa.gov 4neha.s.rungta nasa.gov abstract this paper introduces iproperty a novel approach that facilitates incremental checking of programs based on a property di erencing technique.
speci cally iproperty aims to reduce the cost of checking properties as they are initially developed and as they co evolve with the program.
the key novelty of iproperty is to compute the di erences between the new and old versions of expected properties to reduce the number and size of the properties that need to be checked during the initial development of the properties.
furthermore property di erencing is used in synergy with program behavior di erencing techniques to optimize common regression scenarios such as detecting regression errors or checking feature additions for conformance to new expected properties.
experimental results in the context of symbolic execution of java programs annotated with properties written as assertions show the e ectiveness of iproperty in utilizing change information to enable more e cient checking.
categories and subject descriptors d. .
software program verication assertion checkers d. .
testing and debugging symbolic execution testing tools f. .
specifying and verifying and reasoning about programs assertions invariants general terms veri cation algorithms keywords incremental symbolic execution assertions change impact analysis symbolic pathfinder daikon permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
.
introduction annotating functional correctness properties of code e.g.
using assertions or executable contracts such as those supported by the java modeling language or ei el o ers a number of bene ts in automated conformance checking of program behaviors to expected properties to support bug nding .
e ectively utilizing such properties in practice is complicated by two basic factors.
one it requires the properties to be written and maintained meticulously so they correctly re ect the expected behaviors of the code even as it evolves.
two it requires e cient and cost e ective techniques to check the actual behaviors of the code with respect to the given properties.
we believe an approach that integrates automated program analyses with the development and maintenance of code annotated with properties allows us to address both factors by making it possible for developers to e ciently check and correct the properties and the code they write.
our focus in this paper is on reducing the computational cost of such analyses speci cally in the context of change to properties or to code due to bugs xes or feature additions i.e.
addition of new functionality .
in this work we introduce iproperty a novel approach to compute di erences between properties of related programs in a manner that facilitates more e cient incremental checking of conformance of programs to properties.
the key novelty of iproperty is to compute logical di erences between old and new versions of properties that undergo change and facilitate the two development scenarios that form our focus writing properties correctly for an existing program where the developer writes partial correctness properties checks them and then iteratively re nes and re checks them and checking changes to code and properties as they co evolve to for example check feature additions for conformance to new expected properties or to check bug xes for regression errors.
in a program annotated with properties that was checked previously but has since undergone change iproperty utilizes the results of the previous analysis and information about the change to the properties to reduce the number of properties that need to be checked.
our insight is that if a property about program pholds at a control point l inpand implies another property 0also holds at l inp.
this simple observation forms the basis of our algorithm for computing property di erences which checks for implications between corresponding old and new properties to minimize the set of properties that must be checked afterpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
a property change is made and hence reduce the overall cost of checking.
to improve incremental property checking we leverage the distinction between changes to properties i.e.
assertions and changes to the code that implements the program functionality.
iproperty uses the property di erences in conjunction with code based change impact analysis techniques todirect checking onto relevant parts of code and properties thereby removing much of the redundancy otherwise present in re applying the checking technique.
iproperty uses the property di erencing algorithm together with a previously developed behavioral di erencing technique .
iproperty supports incremental checking of properties written as assertions or that can be mechanically transformed into assertions.the assert statements in the source code are de sugared into if then statements in the object code which allows the use of traditional code change impact analyses e.g.
to compute behavioral di erences .
change impact analysis techniques do not distinguish between code that implements functionality and code that represents expected behaviors and thus are unable to characterize whether an assertion violation represents a regression error incorrect update to the property or non conformance between addition of new features and properties.
to evaluate the e cacy of iproperty we apply it in the context of symbolic execution of java programs annotated with assertions to check for assertion violations.
we use subject programs from recent work on incremental symbolic execution which focused on changes to the code .
to annotate these subjects with assertions and to simulate assertion changes we a write some assertions manually and b synthesize some assertions automatically using the daikon tool .
while our application of daikon for assertion synthesis was inspired by daikon s spirit of discovering likely invariants our speci c context of symbolic execution enabled us to systematically validate the output generated by daikon and make its output more precise thereby laying the foundation of a future approach for more accurate discovery of likely invariants .
this paper makes the following contributions property di erencing.
we introduce the idea of incremental checking driven by property di erencing.
iproperty.
we present algorithms to compute logical differences between old and new properties and utilize checking results from the previous analysis assertion driven incremental checking.
assertion di erences are combined with a change impact analysis technique to detect regression errors and check conformance of new functionality to new expected properties.
experimental evaluation.
the experimental results show that iproperty can provide a reduction in the number of smt solver calls and total analysis time required for symbolic execution of java programs compared to the conventional approach of using the symbolic pathfinder tool and enable veri cation of properties that could not be veri ed in a non incremental manner.
.
motivating example this section presents a motivating example to illustrate iproperty and how it is applied in the context of symbolic ex 1int median int x int y int z int m z if y z if x y m y else if x z m x else if x y m y else if x z m x assert x y x z ?
m x true assert y z ?
m y true assert x z z y ?
m z true assert y z z x ?
m z true return m figure method to compute the middle value of three input numbers and expected properties lines .
ecution .
symbolic execution uses symbolic values in lieu of concrete values for program inputs and builds a path condition along feasible execution paths.
a path condition consists of a set of constraints over the symbolic input values and constants.
satis ability of the constraints is checked using o the shelf smt solvers.
in this work we use symbolic pathfinder spf an open source tool for symbolic execution of java programs built on top of the java pathfinder jpf model checker .
figure shows the java implementation of median which computes the middle value of its three integer inputs the code for median appears in previous work but without property annotations.
we manually add partial correctness properties speci cally post conditions to this example in the form of assertions just before the method exit.
version .
assume the user writes four assertions to check expected properties.
the two assertions on lines check median when at least two inputs are equal i.e.
x y x z m x andy z m y. the two assertions on lines check median when the de nition ofmat line reaches the return statement i.e.
the program behaves correctly when zis the middle value specifically the user asserts x z z y m z and y z z x m z. symbolically executing this method using spf checks the given properties lines and reports no assertion failures after seconds.
spf explores states and makes calls to the underlying smt solver.
version property modi cation and addition .having gained some con dence in the implementation assume now the user decides to check the program after editing some assertions and adding new assertions that check more program behaviors.
speci cally the user modi es the third and fourth assertions to use instead of e.g.
to reduce the overlap between the di erent sets of inputs each assertion checks and adds four new assertions to check cases previously unchecked.
the following sequence of assertions replaces the assertions in version lines .
23assert x y x z ?
m x true 24assert y z ?
m y true 25assert x z z y ?
m z true 26assert y z z x ?
m z true 106027assert x y y z ?
m y true 28assert z y y x ?
m y true 29assert y x x z ?
m x true 30assert z x x y ?
m x true applying the conventional symbolic execution approach to check the median program we invoke spf once which reports no assertion failures after seconds for this check spf explores states and makes smt solver calls.
in contrast applying iproperty to check the median program with this modi ed sequence of assertions we invoke spf three times.
two of these invocations focus on the modi ed assertions lines and the third invocation focuses on the new assertions that were added lines .
none of the invocations involve previously checked assertions that were not modi ed lines .
the rst invocation directly checks whether the version assertion line implies the version assertion line by checking if the following method causes an assertion failure void checkimplies int x int y int z int m if x z z y ?
m z true assert x z z y ?
m z true this spf invocation takes less than second and reports no assertion failure i.e.
the implication holds.
thus the validity of version assertion guarantees the validity of version assertion 30so it is not necessary to check it against the implementation of median .
in this case spf explores states and invokes the cvc3 solver times.
the second invocation of spf similarly checks that version assertion line implies version assertion line and hence version assertion 40is also valid and does not need to be checked explicitly against the implementation of median .
spf takes less than second explores states and makes cvc3 solver calls to perform the check.
the third invocation of spf checks only the version assertions against the implementation of median .
this invocation takes less than second and reports no assertion failure.
in this invocation spf explores states and makes calls to the cvc3 solver.
overall using iproperty to check the version properties makes three invocations of spf taking a total of seconds versus seconds in the conventional approach requires spf to explore states versus states in conventional approach and makes solver calls to cvc3 versus calls in conventional approach .
thus iproperty provides a reduction in smt solver calls compared to the conventional approach using spf for this small example.
.
approach in this section we present the details of the iproperty approach that computes property di erences for more e cient incremental checking of evolving programs.
iproperty operates on two program versions pandp0 leverages the results from checking pin order to compute the logical di erences in evolving properties.
iproperty then combines the property di erences and a code change impact analysis to enable e cient incremental property checking of p0.
given two related program versions pandp0 wherepis annotated with one or more properties and the properties inp0are changed with respect to p for example properties are added deleted or modi ed in p0.
moreover p0may contain changes to the code that result in functional di erences e.g.
added changed or removed program behaviors.
assumepwas previously checked for property failures and the results from checking pare available.
then the basic problem addressed by our technique is how to e ciently check the properties in p0.
our technique addresses this problem in two ways by de ning a mechanism to compute property di erences betweenpandp0that leverages the results from checking pto automatically re write the properties in p0 retaining only the necessary parts of the properties and by checking p0incrementally with respect to the impact of the code changes along with the property di erences.
section .
describes the initial property checking.
section .
describes the algorithmic details of computing differences in properties speci ed as assert statements in java source code.
section .
describes three checks that can be performed using the property di erences and the results of a change impact analysis to e ciently check for regression errors and conformance of new features in the code to the additional properties.
.
initial property checking in this work we analyze properties speci ed as java assert statements.
we assume the speci ed properties are side e ect free.
definition .
.ais a set of assertions in a java programpsuch that each a2ais an java assertion assert where speci es one or more properties as a conjunction of clauses a m m .
each clause in a conjunction can be an arbitrarily complex boolean expression and may include one or more invocations of pure functions side e ect free .
iproperty uses the results from checking the previous version of the properties in the property di erencing algorithm presented in section .
.
the results from analyzing a program p with a given set of initial properties a are stored for re use by iproperty.
during the initial analysis of the program we record the outcome from checking a property whether the property passed or failed.
in the case a property fails program analysis techniques such as symbolic execution generate a counterexample to show how the property failed.
we rst de ne two data structures to store the analysis results outcome andcounterexample .
definition .
.outcome is a map out p a7!ffail not fail unknowngthat returns one of three possible outcomes of checking an assertion awith respect to a program p fail indicates that a violation of awas detected not fail indicates no failure of awas found and unknown indicates that the results of checking aare not known.
definition .
.counterexample is a map cex p a7!
2tracesthat returns a set of traces where each trace represents a feasible execution path from the start of the program pto the violation of an assertion aand outp a fail .
theoutcome map forpis populated with the outcomes generated when checking the corresponding assertions in a against program p while the counterexample map is populated with assertions which have the fail outcome.
definition .
.transform is a map transform a7!
2clausesthat returns the set of clauses contained in the conjunction a m for the assertion a2a.1061procedure propertydifferencing a0 cexp outp 8a02a0 cexp0 a0 for eacha02a0do ifmatchedasserts a0 ?then houtcome adi i assertdiff a a0 elsehoutcome adi i hunknown transform a0 i outp0 a0 outcome a0 a a0 adi ifoutcome failthen cexp0 a0 cexp a procedure assertdiff a0 a ifoutp a unknown then returnhunknown transform a0 i iflogicaldifference a0 a then returnhoutp a i ifoutp a not fail then returnhunknown flogicaldifference a0 a gi else ifoutp a failthen returnhunknown transform a0 i figure the property di erencing algorithm.
.
property differencing no code changes the key idea our approach is to automatically re write assertions in p0 based on the logical di erences between assertions in pandp0.
the logical di erences are combined with the information gathered from the previous analysis of p in order to reduce the number of properties that need to be checked in p0.
in this section we assume that there are no code changes between programs pandp0 i.e.
they are syntactically the same andsemantically equivalent when assertions are turned o .
in section .
we take into account code changes.
at the heart of computing property di erences is the notion of logical di erence between two properties.
in this work we de ne logical di erence between two java assertions as follows definition .
.logicaldi erence is a function that takes as input two assertions a0anda and returns the set of clauses in a0wheref 02transform a0 j a6 0g.
the logical di erence function returns the set of clauses ina0that are not subsumed i.e.
logically implied by the clauses ina.
moreover if the logical di erence function returns the empty set it follows that a a0 i.e.
all of the clauses in the conjunction of a0are subsumed by those in a indicating there is no functional change going from atoa0.
lemma .
.
assume checking pwithaat locationlshows that assertion aholds.
let logicaldi erence a0 a .
then checking pwith conjunctionvj j i iat control point lis equivalent to checking pwith assertion a0atl i.e.
the set of executions of pthat violate a0atlequals the set of executions of pthat violatevj j i iatl.
lemma .
.
if checking pwithaat locationlresults in a violation of aanda0 a thena0is also violated at linp.
the propertydifferencing algorithm is shown in figure .
the inputs to the algorithm are the set of all assertion statements in p0 a0 and the outcome andcounterexample maps from checking p outp and cexp respectively.
as the propertydifferencing algorithm iterates over each assertion in p0 it computes the logical di erence between matching assertions in pandp0and uses the results from analyzing pto update i the outcome map of p0 outp0 ii the counter example map cexp0 and iii the map of assertions di erences a0 a that contains for each assertion inp0 the set of clauses in a0that need to be checked againstp0.
the entries in outp0andcexp0are initialized to unknown and respectively for each assertion at line during the initialization of the propertydifferencing algorithm.
the algorithm checks if a0is a new assertion added to p0 by calling the function matchedasserts at line in figure .
this function takes as input an assert statement in p0and returns the corresponding assert statement in p when no corresponding assert statement is found it returns ?.
assert statements can be matched using various techniques such as an ast matching algorithm or an ide monitor that tracks the changes to the code.
when no matching assert statement in present in p then the analysis concludes that a0 is a new assertion added to p0.
in this case the outcome for a0is set to unknown lines and and the set of clauses in a0 is added to a0 ain order to be checked against p0 line .
when the matchedasserts function returns a matching assert statement a at line the propertydifferencing algorithm computes the di erences between aanda0by invoking theassertdiff function.
the assertdiff procedure shown at lines in figure computes and returns the outcome and the logical di erence of a0with respect to the matched assertion in p. when the outcome of the matched assertion a isunknown with respect to pthena0is treated as a new assertion by setting its outcome to unknown lines and adding it to the set of assertions to be checked in p0 lines .
when there is no logical di erence between assertions a anda0 and the outcome of ais either fail ornot fail then the outcome of ais returned as the outcome of a0at lines in figure .
there are two cases to consider when however there is a logical di erence between assertionsaanda0.
first consider the not fail case at lines and .
in the absence of code changes the logical di erence between the assertions is added to the di erence map a0 a to be checked for failures and its outcome is set to unknown .
next consider the fail case at lines and .
since there is a di erence between the two assertions we cannot reason about whether the new assertion a0will fail or not.
hence the outcome for a0is set to unknown and the set of clauses ina0is added to a0 a. we also use previously generated counterexamples to potentially reduce the number of properties that need to be checked using an an expensive analysis technique such as symbolic execution.
often a program execution that is successful in eliciting a violation of one property may be able to detect a violation of another property as well.
in order to leverage this we concretely execute inputs of the program that lead to the counter examples in cexpand check for all assertions a0 f such that outp0 a0 f unknown if a violation of the assertion is detected.
for these additional failing assertions their corresponding entries in the a outcome map are marked as fail b di erence map are marked as empty i.e.
a0 a a0 f and c counterexample map are updated with the error trace.
the algorithm in figure computes the map of assertion di erences a0 a. for every assertion a0 the map contains a set of clauses conjunction of clauses that we need to check with respect to program p0.
each entry in the map a0 ais mapped into assert statement assert at the location of a0 inp0.
the clauses set is re written as a java expression.
we1062analyze program p0with re written assertions using symbolic execution for more e cient checking of the properties.
.
property checking with code changes in this section we present our incremental property checking approach in the presence of code changes .
recall that earlier while computing the property di erences we assumed there are no code changes between pandp0 only property changes.
our goal is to partition the incremental property checking in a manner that allows more e cient detection of regression errors introduced during bug xes and checking conformance of feature additions to new properties.
the incremental property checking algorithm combines in a novel way results computed by the property di erencing algorithm in section .
and our previous work on directed incremental symbolic execution dise that generates the set of program behaviors impacted by the code changes.
the combination of the property di erences with dise allows us to partition the incremental analysis into three di erent checks i check i analyzes the changed or impacted program behaviors with respect to the assertion di erences ii check ii analyzes the changed or impacted behaviors with respect to the original preserved assertions and iii check iii analyzes the unchanged program behaviors with respect to the assertion di erences.
the three checks can be performed independent of each other.
the partitioning also provides insight into whether the property violation was caused by the property di erences incorrect update of properties code changes regression errors or a combination of property di erences and code changes new feature additions do not conform to the new properties .
.
.
directed incremental symbolic execution we rst present a brief overview of the dise methodology.
given two related program versions pandp0 dise constructs the change set c which contains the set of program statements that are syntactically di erent between p andp0 dise then uses the change set cas the slicing criterion to statically compute the impact set i the set of program statements that may be impacted by the changes inp0 and symbolic execution of p0is then directed along the program locations in the impact set i in order to generate the program behaviors impacted by the changes in c. 1int a b 2public int test int x int y if x a x else a x if y b y else b y change the simple program shown above contains two global variablesaandb and two input parameters xandy.
updates to the global variables are made based on the values of the input variables.
suppose the assignment b y is changed tob y line .
the program statement impacted by this change is the conditional statement y .
the execution of the changed statement is control dependent on the false branch of the conditional statement.
dise uses this impact information to direct symbolic execution.
there are four possible paths through the program de ned by these path constraints a x y b x y6 c x y and d x y6 .
dise however generates only two paths out of the four.
in its default1 input assertion free p7!pf assertions a assertion free p07!p0 f assertions a0 c0 p syntaticdiff pf p0 f i0 p impactanalyis c0 p p0 f check i impacted behaviors assertion di s directedsymbolicexecution p0 f a0 a ip0 check ii impacted behaviors original assertions oldassertions for eacha2a matchedasserts a ?do oldassertions oldassertions fag directedsymbolicexecution p0 f oldassertions ip0 check iii unchanged behaviors assertion di s up0 statements p0 f nip0 directedsymbolicexecution p0 f a0 a up0 figure three cases for incremental property checking.
search strategy dise will explore paths a and b and then prune the other paths since all the impacted program behaviors operations on yandb have been explored in paths a and b .
dise has been shown to be an e cient technique for characterizing evolving program behaviors.
.
.
.
three types of property checks the three types of property checks in our incremental analysis are shown in figure check i analyze the impacted program behaviors with respect to the property differences check ii analyze the impacted program behaviors with respect to the preserved properties and check iii analyze unchanged program behaviors with respect to the property di erences.
programs pfandp0 fare assertionfree program versions of pandp0respectively aandap0are the sets of assertions in pandp0respectively and a0 ais the set of assertion di erences computed by the algorithm in figure .
we leverage the conservative approximation of impacted behaviors computed by dise in the checks in figure .
at lines and in figure the change and impact sets cp0and ip0 are computed from the assertion free program versions pfandp0 f. this generates the set of program statements in the code that may be impacted by changes to only the code and not to the assertions.
the impactanalysis computes the set of program statements within the program slice using the change set as a slicing criterion.
a forward as well as a backward slice is computed in order to account for all program statements that may impact the program behavior.
control and data dependence information is used by the impact analysis to construct the program slice.
this is a conservative analysis any program statement that may be dependent on a program statement in the change set is included in the impact set.
the forward slice computes the ow of impact from the change set to the other statements while the backward slice accounts for control and data ow from program statements to those in the change set.
a violation of an assertion during check i indicates that a new feature addition or modi cation does not conform to the new properties.
in check i we check the assertion di erences with respect to the changed behaviors in p0 f shown at line in figure .
a safe approximation of the impacted behaviors is generated by the symbolic execution performed by dise the directedsymbolicexecution procedure .
symbolic execution is directed along the program statements in1063the impact set ip0 to generate the set of impacted behaviors inp0.
the assertion di erences a0 a which have been rewritten as assertions in p0are checked on they as the search is directed along the impacted program executions bydirectedsymbolicexecution .
a violation of an assertion during check ii indicates a regression error.
in check ii we analyze the original preserved assertions with respect to the changed behaviors at lines through .
the set oldassertions is initialized as empty at line .
we add to this set all assertions in athat have a matched assertion in p0.
this check ensures that assertions removed in a0are not added to the oldassertions set.
we check the assertions in the oldassertions set with respect to the changed behaviors in p0.
check ii serves as a regression metric where the analysis ensures that changes to the code do not violate the preserved properties.
a violation of an assertion during check iii indicates a potential incorrect update to the property.
in check iii we analyze the assertion di erences with respect to the behaviors that are unchanged between pandp0.
in order to explore the preserved behaviors we generate the set of program statements that are not impacted by the code changes.
at line in figure the set up0 contains any program statement that is notin the impact set ip0 .
now we direct symbolic execution along program statements in up0to generate the set of unchanged behaviors.
we check the assertion di erences with respect to these unchanged behaviors.
.
evaluation we empirically evaluate the e ectiveness of our technique for incremental property di erencing and checking.
our evaluation addresses the following research questions rq1 how does the e ciency of checking assertion di erences compare with checking the full assertions using symbolic execution?
rq2 how does the cost of checking an implication between an old assertion and a clause in a new assertion compare with checking the clause against the program?
rq3 how does the performance of the incremental property checking in the presence of code changes compare with full symbolic execution in detecting a regression errors and b conformance of new features to additional properties?
for the rst two research questions we restrict the program di erences to assertion changes only for the third research question we analyze programs with changes to both the code and the assertions.
.
tool support we implement our approach using symbolic pathfinder spf the symbolic execution extension to the java pathfinder jpf model checker for analyzing java programs.
spf uses lazy initialization to handle symbolic inputs of complex user de ned types.
we use cvc3 as the backend solver for all subjects except apollo which contains non linear constraints.
we use the coral solver for apollo.
we use the dise extension to jpf to perform incremental property checking .
checking assertions with spf when checking assertions with spf we use an interactive approach stopping at the rst violation of an assertion.
we then remove thefailing assertion and recheck the program until the next assertion fails or spf completes e.g.
reaches a depth bound.
spf supports nding multiple assertion violations in a single invocation however this approach would also nd all possible ways of violating each assertion and result in unnecessary overhead particularly when our goal is simply to determine for each assertion if there exists anyfeasible execution that violates it.
.
.
property differencing checking implications to check if the property ain assertion aimplies a clause rq2 we create a symbolic driver method with body if a assert where ais the conjunction of clauses ina and the formal parameters are based on the free variables of aand and symbolically execute the driver.
if symbolic execution does not lead to an assertion violation the implication holds otherwise it may not hold.
conceptually symbolic execution of the driver checks the formula 8v0 vkj a wherev0 vkare the free variables in aand .
if this formula holds then the clauses inaimplyc0since the formula checks the implication for all possible values for v0 vkand only a subset of these values can reach the control point of a. if aor 0invoke other method s symbolic execution dynamically traces through the bodies of the invoked methods.
however the cost of implication checking then depends on the number of bounded paths in the methods invoked by assertions.
to optimize implication checking we overapproximate the outcome of the calls to boolean methods by introducing non deterministic boolean variables to conservatively model the results of method invocation .
speci cally for each unique boolean method invocation m ... based on method name and arguments in if a assert declare a fresh boolean variable and initialize it using a non deterministic choice i.e.
verify.getboolean in spf insert these variable declarations before the implication check and replace all occurrences of boolean method invocations in the implication check by the corresponding boolean variables.
thus we conservatively capture the behavior of the boolean methods invoked if no assertion violation is found in the generated program then the original implication holds.
recall we assume the assertions are without side e ects.
.
artifacts in our evaluation we use four artifacts with manually created assertions and three artifacts with dynamically inferred invariants that we transform into java assert statements.
.
.
triangle classification artifact the artifacts with manually created assertions include a java version of the classic triangle classi cation program by ammann and o utt annotated with assertions.
the triangle classi cation program trityp takes as inputs three numbers and outputs whether they represent sides of a valid scalene isosceles orequilateral triangle or an invalid triangle.
the classi cation logic of the trityp program is implemented by the triang method using lines of java code1 which seem deceptively simple but are non trivial to reason about.
the assertions for this artifact were developed following an evolutionary process.
1in the textbook by ammann and o utt figures .
.
lines 1064table data structure subjects.
subject versions invariants sortedlist acyclicity first element is smallest last element is largest list is sorted list has unique elements if unique inserts heaparray root is largest max heap property reverse sorted array is max heap bst acyclicity left most leaf is smallest right most leaf is largest binary search constraints assertions for trityp .
we consider three versions of assertions for trityp based on the actual experiences of one of the authors .
let a b andcbe the three input numbers andtrepresent the output where t means scalene t means isosceles t means equilateral and t means invalid .
version v1 .
the initial set of the trityp assertions includes the following assertions a0 assert t !
a1 assert a b c ?
t true a2 assert a b c ?
t true a3 assert a c b ?
t true a4 assert b c a ?
t true a5 assert a b b c ?
t true a6 assert a b c a b ?
t true a7 assert a c b a c ?
t true a8 assert b c a b c ?
t true a9 assert a !
b a !
c b !
c a b c a c b b c a ?
t true version v2 .
analysis of the trityp example revealed that assertionsa2 a8 are invalid in the initial version and are therefore edited to a2 assert a b c ?
t true a3 assert a c b ?
t true a4 assert b c a ?
t true a5 assert a b b c a ?
t true a6 assert a b c a b c ?
t true a7 assert a c b a c b ?
t true a8 assert b c a b c a ?
t true v2 of the assertions thus includes the following assertions in order a0 a1 a20 a80 a9.
version .
after checking version v2 assertions a60 a80in v2 are still invalid and edited to a6 assert a b a !
c c a b c ?
t true a7 assert a c a !
b b a c b ?
t true a8 assert b c b !
a a b c a ?
t true v3 of the assertions thus includes the following ten assertions in order a0 a1 a20 a50 a600 a800 a9.
.
.
data structure artifacts three artifacts with manually created assertions are data structure subjects with assertions based on structural representation invariants.
some of the data structure invariants were developed in previous work we adapt and augment them in this work to create multiple assertion versions.
assertions for data structure artifacts .
table summarizes the data structure artifacts.
for each artifact we create a symbolic execution driver which is commontable results for checking the tritype assertions.
version checkfull checkdi smt states t smt red.
states t conc.
v1 v2 .
v3 .
across all versions t o newt o add x1 o add x5 for symbolic variables x1 x 5and data structure type t. next we create kversions where kis the number of invariants for the subject.
let the invariants be i1 ikand versions bev1 vk.
each version consists of the symbolic execution driver followed by a sequence of assert statements wherev1contains assert i and version vi i k contains assert i assert ii .
thus each new version adds the corresponding new assertion.
.
.
artifacts with synthesized assertions we also use three subject programs wbs tcas and apollo with mechanically synthesized assertions.
these artifacts were used in two recent papers on incremental symbolic execution.
the focus of these papers was on changes to code in general and these artifacts did not contain assertions.
to synthesize assertions for our experiments we use the daikon tool for invariant discovery .
speci cally we apply daikon on each subject to discover relevant valid invariants which we transform to assertions.
our speci c focus is the method pre conditions and post conditions generated by daikon in java.
daikon requires a test suite to execute the program under analysis and detect its likely invariants.
among the artifacts only tcas had a test suite available in the software infrastructure repository .
we used this test suite containing tests for tcas.
for wbs and apollo we wrote a random test generator to create a test suite with tests for each artifact.
our goal is to use daikon to generate relevant valid invariants.
however dynamic invariant discovery can generate invariants which are irrelevant or invalid .
to lter such invariants we remove any invariant that does not mention some method input or the return value or is invalidated by symbolic execution.
.
results and analysis .
.
rq1 checking assertion differences we check the trityp program with respect to each of the three assertion versions comparing checking assertion di erences with checking the full assertions using symbolic execution.
the results are shown in table .
for each artifact and its versions we show the results for checking full assertions checkfull and the results for checking assertions di erences that are computed by our property di erencing algorithm checkdi .
smt is the number of smt calls made states is the number of states explored during symbolic execution t is the wall clock time in seconds for symbolic execution and red.
is the reduction in smt calls achieved by checking only the assertion di erences.
the conc.
column indicates the number of concrete executions used to check the counterexamples from the previous version.
the results in table show the cumulative results for all invocations of spf.
for the trityp artifact our property di erencing algorithm reduces the number of assertions that need to be checked by symbolic execution consequently it reduces the smt calls by .
for v2 and .
for v3.1065table subjects with mechanically synthesized assertions using daikon.
subject method daikon application version generation tests invariants versions invariants in each version wbs update 4v1 v2 v3 v4 tcas alt sep test 5v1 v2 v3 v4 v5 non crossing biased climb 5v1 v2 v3 v4 v5 non crossing biased descend 5v1 v2 v3 v4 v5 apollo reaction jet control0.main1 5v1 v2 v3 v4 v5 table results for checking data structure assertions.
subject version checkfull checkdi smt states t smt red.
states t sortedlist v1 v2 v3 .
v4 .
v5 .
heaparray v1 v2 .
v3 .
bst v1 v2 v3 .
v4 .
in table we present the results of checking full assertions and checking assertion di erences on the data structure artifacts.
versions v1 andv2 of sortedlist and binarysearchtree bst artifacts contain properties that assert acyclicity.
these assertions are checked using lazy initialization that concretizes complex data structures and does not require any constraint solving during symbolic execution.
currently our reductions are targeted for programs and properties that do use constraint solving hence the number of states generated and the number of smt calls in the checkfull and checkdi columns for version v2 of sortedlist and binarysearchtree bst artifacts are the same.
checking assertion di erences in other versions requires fewer smt calls than checking all assertions and costs less in time and states visited.
checking assertion di erences in the sortedlist example provides up to .
reduction in the number of smt calls compared to checking full assertions.
in the heaparray artifact we observe up to .
reduction in the number of smt calls compared to checking full assertions.
whereas in the binarysearchtree example checking assertion di erences provides up to .
reduction in the number of smt calls compared to checking full assertions.
overall experiments with trityp sortedlist heaparray and binarysearchtree show that checking assertion di erences based on the property di erencing algorithm outperforms checking full assertions in terms of the number of smt solver calls number of states explored and the time taken for symbolic execution.
table summarizes the artifacts with mechanically synthesized assertions and lists the methods we consider the number of tests used to run daikon the relevant valid invariants reported by daikon the number of assertion versions we create using those invariants and the number of assertions in each version.
we create four and ve versions of the wbs and apollo artifacts respectively using the relevant and valid invariants generated by daikon.
the rst version consists of one randomly selected invariant and each subsequent version contains all the invariants from the previous version and one additional invariant also selected attable results for checking wbs tcas and apollo.
subject version checkfull checkdi smt states t smt red.
states t wbs v1 v2 .
v3 v4 .
tcas 1v1 v2 .
v3 .
v4 .
v5 .
tcas 2v1 v2 .
v3 .
v4 .
v5 .
tcas 3v1 v2 .
v3 .
v4 .
v5 .
apollo v1 v2 .
v3 .
v4 .
v5 to to n a random.
daikon s invariant generation is particularly e ective for tcas so we are able to create versions with larger numbers of relevant valid invariants.
we create ve versions for each chosen method in tcas where the rst version consists of randomly selected invariants and each subsequent version contains a number of additional invariants also selected at random.
in all the versions each assertion contains a single clause that corresponds to one relevant valid invariant.
we use information about how the di erent versions are constructed in order to manually mark the changed and added assertions between consecutive versions.
however a unix di could be used to compute the changes and it only takes a few milliseconds to run unix di for any two consecutive versions.
table presents the results of checking full assertions and checking assertion di erences on wbs tcas and apollo.
tcas 1refers to rst tcas method listed in table i.e tcas.alt sep test tcas 2refers the second etc.
checking full assertions in v5 of apollo times out to after hours whereas checking assertion di erences based on property di erencing successfully completes for all artifacts.
moreover checking assertion di erences outperforms checking full assertions in terms of states visited and time taken for symbolic execution and provides between .
and .
reduction in smt calls across the di erent versions.
while these results show the bene t of using iproperty for more e cient checking of these subjects the underlying cost of symbolic execution still is a considerable factor in the scalability of the overall incremental approach.1066table implication checking results using symbolic execution.
exp is the rst experiment.
exp is the second experiment.
subject check implication a a0 check assert a0 in code smt states t smt states t min max ave min max ave min max ave min max ave min max ave min max ave exp wbs exp wbs exp tcas exp tcas exp tcas exp tcas exp tcas exp tcas exp apollo exp apollo table results for checking regression errors.
version spf dise smt states t smt red.
states t wbs tcas tcas .
tcas .
apollo .
.
.
rq2 implication checking to address rq2 we analyzed assertion pairs a a0 where assertionais in program pand its matching assertion a0is in program p0.
in our experiments aand a0each contain a single clause aand a0respectively.
hence for each assertion pair we symbolically execute if a assert a0 to check if the implication holds as described in section .
.
we compare the cost of checking the implication with the cost of checking assert a0 in the relevant method body at the corresponding exit point.
we conduct two di erent experiments each with ve assertion pairs.
in the rst experiment we create assertion pairs by selecting an invariant a at random from the set of relevant valid invariants.
in the second experiment we create pairs by applying mechanical transformations for invariant aselected at random if acontains the comparison operator we create a0by mutating to to form assertion pair ha a0i if acontains the comparison operator we create a0by mutating to to form assertion pair ha a0i if acontains a numeric expression of the form l op r we generate a0by adding a constantc2f 100g selected at random to both sides of the expression in ato form assertion pair ha a0i and if ainvokes a daikon library method we select an invariant a0 a at random to create assertion pair h a a0 a a0 ai.
table shows experimental results for implication checking for the two experiments.
all implications for the rst experiment were false as expected since implication is unlikely to hold between two invariants selected at random all implications for the second experiment were true as expected given the design of the transformations .
thus the two experiments together cover both possible outcomes for implication checking.
some invariants including all of the apollo invariants invoke daikon library methods e.g.
daikon.quant.memberof this.numeratorterms 5557 arg1 and therefore the resulting implication check is handled by our implication check optimization which uses non deterministic choice to model boolean method invocations section .
.
.
thus some cells have smt calls spf state explorationtable results for checking conformance between code change and property change.
version spf dise smt states t smt red.
states t wbs tcas tcas .
tcas .
apollo .
does not require smt if the implication only consists of boolean methods and boolean operators.
the results show that the number of smt calls for the implication check a a0is at most and for wbs tcas and apollo respectively of the cost to check assert a0 in the code.
overall the cost of checking an implication between an assertion in pand a new clause in the assertion a0is substantially less than the cost of checking the clause against p0.
.
.
rq3 incremental assertion checking to address rq3 we analyze programs that contain changes to both code and properties.
we compare the performance of incremental property checking with full symbolic execution in a detecting regression errors and b checking conformance of new features to additional properties.
we create the version pairs by manually making changes to the code that were annotated with relevant and valid daikon invariants we then also make changes to the properties by adding additional daikon invariants.
we choose to make manual changes to the code in order to simulate potential regression errors and non conformance between code and properties.
we create one version for each subject listed in table .
to compare the performance in nding regression errors we perform dise and full symbolic execution as implemented in spf on the program p0annotated with the oldassertions as de ned in check ii figure of section .
.
an assertion violation in p0is indicative of a regression error.
table shows the experimental results for this experiment.
dise and spf make the same number of smt calls for wbs and tcas .
for tcas all the paths in the code are marked impacted by the code changes thus dise explores all the paths for wbs both spf and dise detect an assertion violation.
while in other versions dise achieves substantial reduction for example there is reduction in the number of smt calls in apollo .
the same pattern of results is seen in the the number of states explored by symbolic execution in spf and dise and also total wall clock time taken in seconds.
due to the overhead of static analysis performed by dise for tcas dise takes a small amount of1067additional analysis time compared to symbolic execution in spf however even when reductions are not possible the overhead is very small.
in order to check conformance between code changes and properties changes we perform dise and full symbolic execution as implemented in spf on p0with the annotated property di erences a0 aas described in check i of figure .
we compare the cost of performing dise with the cost of performing symbolic execution in spf in each experiment.
table shows the results.
in a manner similar to the results observed in table for some versions e.g.
wbs and tcas dise and symbolic execution in spf explore the same number of states and make the same number of smt calls.
for some versions however such tcas dise makes fewer smt calls explores fewer states and takes less time compared to symbolic execution in spf.
.
threats to validity the primary threats to external validity in our study are the use of spf and dise the selection of artifacts and properties and the changes made to create versions of the code and properties.
although our observations may not generalize to other artifacts properties and changes we attempted to mitigate these threats by analyzing multiple artifacts all of which have been used in previous studies of symbolic execution based techniques with respect to properties assertions that were both manually developed and mechanically synthesized.
further evaluation of our technique on a broader range of program types property speci cations and change types would address this threat.
the primary threats to internal validity are the potential faults in the implementation of our algorithms and in spf and dise.
we controlled for this threat by testing the tools and implementations of the algorithms on examples that could be manually veri ed.
with respect to threats to construct validity the metrics we selected to evaluate the cost of our algorithms are commonly used to measure the cost of symbolic execution based techniques.
.
related work incremental program analysis techniques which leverage change impact analysis results have been widely studied to help reduce the cost of program analysis by enabling incremental analysis of previously checked programs.
recent work has also focused on techniques which reuse veri cation results to help reduce the cost of program analysis and reuse of reachability information through similarity checking of test goals represented as automata to reduce the cost of test input generation .
iproperty partitions the analysis of code and property speci cations leveraging the results of a change impact analysis and reusing the veri cation results from checking the previous version of the program against the property speci cations to reduce the cost of property checking.
a number of recent techniques optimize symbolic execution for one program version using compositional analysis abstraction and partitioning .
the idea of optimizing symbolic execution in the context of code that undergoes change was introduced by dise which rst uses a static analysis as we describe and utilize in this paper.
an alternative optimization of storing results of symbolic execution and re using them is taken by green and memoise .
since property di erencing likely reducesthe number of paths to explore using symbolic execution we expect it to o er a reduction in the exploration space for memoise and green similar to dise.
recent work explores program di erencing in the context of assertions .
lahiri et al.
present di erential contract checking which uses static analysis to determine possible inputs that will cause a contract to evaluate di erently between two versions.
joshi et al.
employ assertion checking to limit false alarms during static concurrency analysis of open systems .
in more recent work lahiri et al.
present a di erential assertion checking technique dac for comparing relative correctness of the program do the two programs versions perform consistent memory accesses?
at a cost that is lower than absolute correctness.
we believe that core algorithms in iproperty can be extended to handle other lightweight speci cations as well e.g.
jml ei el and spec .
these speci cation languages provide developers the ability to specify properties at a component module or method level in a manner very similar to assertions.
there is a large body of the work on property based slicing and property aware testing and veri cation of programs as well as on change impact analysis e.g.
for regression test selection .
the key di erence between iproperty and previous work is our property di erencing technique and its synergistic application with changeimpact analysis that characterizes impacted behaviors to enable more e cient checking of code conformance to behavioral properties.
property di erencing as a stand alone problem has also been addressed by a number of previous projects e.g.
in the context of uml models and object z however previous work on property di erencing has not considered using the di erences to optimize checking of code.
.
conclusion this paper introduced iproperty a novel approach to compute di erences between properties of related programs in a manner that facilitates more e cient incremental checking of conformance of programs to properties.
the key novelty of iproperty is to compute logical di erences between old and new versions of properties that undergo change and facilitate two development scenarios that form our focus writing properties correctly for an existing program and checking changes to code and properties as they coevolve.
we evaluate iproperty on java programs with manually written and mechanically synthesized assertions.
the experimental results show that iproperty reduces the number of smt solver calls a key metric for the cost of symbolic execution in comparison with the conventional approach.
we believe iproperty provides a promising approach to not only reduce the cost of checking properties but also to make it easier to formulate correct properties manually or mechanically.
while our focus in this paper was on symbolic execution we believe property di erencing can enable scalable incremental checking using other software analyses such as model checking and static analysis.
.