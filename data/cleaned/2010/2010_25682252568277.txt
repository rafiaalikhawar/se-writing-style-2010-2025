unleashing concurrency for irregular data structures peng liu y lpxz ust.hkcharles zhangy charlesz cse.ust.hk state key laboratory of software engineeringyhong kong university of science and technology wuhan university china china abstract to implement the atomicity in accessing the irregular data structure developers often use the coarse grained locking because the hierarchical nature of the data structure makes the reasoning of ne grained locking di cult and error prone for the update of an ancestor eld in the data structure may a ect its descendants.
the coarse grained locking disallows the concurrent accesses to the entire data structure and leads to a low degree of concurrency.
we propose an approach built upon the multiple granularity lock mgl that replaces the coarse grained locks to unleash more concurrency for irregular data structures.
our approach is widely applicable and does not require the data structures to have special shapes.
we produce the mgl locks through reasoning about the hierarchy of the data structure and the accesses to it.
according to the evaluation results on widely used applications our optimization brings the signi cant speedup e.g.
at least speedup and up to 2x speedup.
categories and subject descriptors d. .
optimization general terms reliability performance design keywords synchronization ne grained locking data structure library .
introduction irregular data structures such as graphs sets and lists use pointers to dynamically adapt to the computation needs of many applications.
they are typically provided as libraries and hidden behind apis.
when they are used in multi threaded programs developers commonly use locks to achieve the correctness properties such as atomicity which requires a group of accesses to the data structure be completed permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
figure .
concurrent update of disjoint parts of the data structure from the stmbench7 benchmark.
in the object graph each circle stands for an object labeled with type identifier and each edge stands for a eld reference labeled with the eld name .
without interruption.
at the same time the developers also face tough challenges when specifying the locks in balancing between correctness and performance.
we illustrate this problem with an example.
figure depicts the object graph of a tree like data structure where the objects connect to each other via the eld reference.
to guarantee the atomicity of the methods that access the data structure developers often specify coarsegrained locks that disallow the concurrent accesses to the data structure.
for example with the coarse grained locking all threads that access the object graph of the data structure in figure are synchronized on the same object e.g.
the root of the graph.
the coarse grained locking drastically limits the concurrency as it denies the concurrent updates of the disjoint parts of the object graph highlighted as grey in figure and therefore leads to the poor scalability with respect to the number of threads and the unsatisfactory performance.
in figure we could allow the concurrent updates of the disjoint parts if we use the ne grained locking e.g.
one lock for synchronizing the accesses to the subgraph rooted atmanual 2and the other for the accesses to the subgraph rooted at complexassembly .
however it is generally challenging to reason about and implement the ne grained locking for the data structure due to its hierarchical nature.
on the one hand the insu cient synchronization would cause the atomicity violation.
consider the data structure in figure 2b the update ancestor update of an ancestor eld a ects the accesses descendant accesses to its descendant elds as they belong to the subgraph rooted at the ancestor.
following the atomicity the accesses to the descendant eld title by a thread as shown in fig permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
ure 2a should return the consistent values.
however they may lead to inconsistent values if they are interleaved by another thread that misses the synchronization and updates the ancestor eld man leading to atomicity violation.
on the other hand the overly restrictive synchronization may drastically limit the concurrency.
speci cally one way to achieve the atomicity in the above case is to ask the threads to acquire the ne grained locks for all elds involved which include both the eld that contains the intended value e.g.
the eld title and the elds on the reference path from the root to it e.g.
the eld man.
however the concurrency is limited in this way.
if two threads update two elds e.g.
the elds title and text highlighted in figure 3a respectively of which the reference paths share some common eld e.g.
the eld man the threads cannot run concurrently as they contend for the lock protecting the common eld.
to summarize we encounter the conundrum i.e.
the insu cient synchronization causes the atomicity violation while the overly restrictive synchronization limits the concurrency.
ideally we want to simultaneously guarantee the atomicity and allow a high degree of concurrency e.g.
enabling the concurrent updates in figure 3a.
in this paper we present an automated approach that replaces the coarse grained locks to allow the concurrent accesses to disjoint parts of data structures as illustrated in figure and figure 3a while preserving the atomicity as shown figure 2a.
di erent from the techniques that take advantage of the special properties of the data structure as explained in section our approach is generally applicable e.g.
it is even applicable to irregular data structures that contain cycles or collections.
our optimization is built upon themultiple granularity lock mgl of which the high level idea is borrowed from the database community .
technique summary the input to our technique is the concurrent library that encapsulates the data structure with the atomic methods apis implemented using the coarse grained locks the output is the optimized library that uses the ne grained locks i.e.
mgl locks .
we rst reason about the data structure with the abstract object graph aog built by leveraging the pointer analysis.
given each atomic method we collect the object elds of the data structure that it accesses using the side e ect analysis.
our technique then tags each eld in the aog with the mgl locks according to the access type of the eld.
under the hood the mgl supports multiple kinds of locks which correspond to di erent levels of restriction.
our optimization chooses the least restrictive lock whenever possible.
speci cally if a eld is accessed each of its ancestor elds is protected by the intention lock in the mgl which prevents the concurrent update of the ancestor eld that leads to the atomicity violation.
meanwhile the intention lock is least restrictive and can be granted to multiple threads concurrently which allows the concurrent updates of the object graph in figure 3a.
challenges there are many challenges in generating the good placement of mgl.
first the static analyses cannot distinguish di erent objects created at the same allocation site due to the conservativeness nature and consequently produce a single lock to protect all of them.
existing static lock inference approaches su er from this problem.
we observe that the library developers usually treat the root of the object graph of data structure as its owner and apply the lock onto the owner object to enforce atomicity.
di erentowner objects distinguish di erent data structure instances.
our optimization starts with such owner locks which encode the developers knowledge and ne tunes them by pinpointing the parts accessed by each atomic method using the static analysis.
second the mgl from the database community does not support cycles while the data structures in general programs often contain cycles.
third naively applying our technique to the collection would produce the conservative locking that denies the concurrent accesses to it because the static analyses cannot distinguish di erent entries of the collection.
instead we propose an e cient mgl locking design for collections that leverages the commutativity property .
finally we apply a set of reduction rules when the approach introduces too many locks.
we implement our approach and evaluate it against ve widely used concurrent applications which are built upon the cache the database and the graph libraries.
the results show that our optimization produces the libraries that are more scalable more concurrent and more performant.
speci cally we observe the consistent speedup when the number of threads increases.
the optimized version outperforms the original version by at least and up to 2x which we believe is a signi cant improvement.
we make the following contributions in this paper.
.we propose an automated and systematic optimization that unleashes more concurrency for irregular data structures by leveraging both the concept of multiple granularity locks mgl and the developers knowledge encoded in the original locking.
.we design the mgl framework that is applicable to general purpose programs.
the framework allows the data structures to contain the cycles or use the collections.
besides it provides the systematic techniques for reducing the number of locks.
.we implement our approach and conduct the in depth case studies on the widely used applications.
.
motivation example we demonstrate how our optimization simultaneously guarantees the atomicity in the case in figure 2a and allows the concurrent updates of disjoint elds in figure 3a and figure .
the data structure and the operations are adapted from the benchmark stmbench7 a well designed benchmark for studying various synchronization mechanisms.
we rst brie y introduce the multiple granularity lock mgl which is designed by gray et al.
and originally applied to the database systems.
mgl primer each eld f i.e.
the edge in the object graph of the data structure is associated with the locks in di erent modes xlock slock islock and ixlock.
these modes correspond to di erent levels of restriction according to the mgl design.
for example the xlock exclusively protects the subgraph rooted at the eld f including f disallowing any concurrent accesses to the subgraph the s lock similar to the xlock disallows any concurrent updates of the subgraph the islock and the ixlock which are in general called the intention lock are designed to facilitate the restriction of the xorslock.
two locks are compatible if they can be held by two threads concurrently.
the locks associated with di erent elds are by default compatible while the compatibility between any two locks associated481t t atomic atomic atomic atomic o perationa operationb t1 man.title t1 man.title man new manual t2 man.title assert t1 t2 a b c figure .
the update of a eld a ects the accesses to the descendant elds.
a the code b the object graph c the tagged object graph with the same eld is listed in figure 4a.
for instance the xlock and the intention lock for the same eld cannot be concurrently held.
once a thread tholds the xlock for a eld f it should prevent the access to any eld f0in the subgraph referenced byf by another thread t0.
the synchronization is realized in the cooperative way.
the thread t0that intends to access the descendant eld f0needs to acquire the intention lock for each of the ancestor elds e.g.
the eld f. the lock will not be granted to the thread t0because the thread tholds the incompatible xlock for f. in short the intention lock for the ancestor eld indicates the intended access to some descendant eld which coordinates the threads accessing at di erent levels.
the core of our optimization is to tag each eld in the object graph with some mgl locks according to the type of the eld access.
as the runtime object graph is not available during the static analysis we approximate section .
it with the abstract object graph aog .
if the access to a eld is the read operation we tag the eld with the islock.
if a eld is updated we tag it with the xlock.
the x lock associated with the updated eld fshould disallow any concurrent access to the subgraph referenced by f as the update attaches a new object subgraph to the eld f implicitly a ecting all descendant elds.
besides we tag each eld on the reference path to a eld fwith the intention lock i.e.
with the ixlock if the eld fis tagged with the xlock or with islock if the eld fis tagged with the islock.
we defer the explanation of slock to section .
.
.
the locks in thetagged aog taog guarantee the atomicity and allow a high degree of concurrency.
preventing the atomicity violation given the example in figure 2a the update of the ancestor eld manis protected by the xlock for man while the accesses to the descendant eld title by another thread are protected by both the islock for title and the islock for the ancestor eld man manis on the reference path from root to title .
speci cally the former islock is used to protect the eld read and the latter islock is used as the intention lock.
the ancestor update and the descendant accesses are not allowed to run concurrently due to the incompatibility between the xlock and the intention lock for the eld man.
hence the atomicity violation is avoided.
allowing the concurrent update the locks in the taog allow the concurrent updates of the elds title and text in figure 3a.
both updates are protected by the ix lock for the common ancestor eld man as well as by the x lock for each updated eld.
the updates can be executed a b figure .
the accesses to the elds which share the common eld on the reference paths.
a the object graph b the tagged object graph concurrently because the ixlock can be held by two threads concurrently.
besides our optimization allows the concurrent updates of the elds title and subassemblies in figure .
comparison with the fine grained locking the developers of the benchmark stmbench7 also build the negrained locking by leveraging their domain expertise to allow more concurrency.
the ne grained locking assigns a readerswriter lock to protect all the complexassembly objects and a di erent lock to protect all the manual objects therefore it allows the concurrent updates of the elds title and id which are protected by di erent locks.
however as compared to our approach their ne grained locking allows much less concurrency in the presence of the structural modi cation i.e.
when the non primitive elds e.g.
manorsubassemblies that form the structure are updated.
speci cally to guarantee the atomicity the ne grained locking introduces a global readers writer lock to protect the structure and requires the structural modi cation to be protected by the lock in the writer mode and other operations in the reader mode.
therefore the locking disallows any concurrent operations if a thread conducts the structural modi cation.
for example it disallows the concurrent updates of the non primitive elds manand subassemblies even if they refer to disjoint parts of the structure.
comparatively our approach leverages the static analysis to nd that the concurrent updates involve disjoint parts and produces the locking that allows the concurrent updates.
in the rest of the paper section presents our technique in details.
section and section present the evaluation and related work respectively.
.
optimization of locks at the high level our optimization rst inspects the side e ects of the eld accesses in the atomic method and maps482them to the object graph of the data structure.
then depending on what parts of the data structure are accessed it decides what locks to use.
speci cally our optimization statically constructs section .
the abstract object graph aog to approximate the runtime object graph.
we then map the side e ects to it and and apply the mgl tags section .
.
given the tagged aog taog we produce section .
the optimized locking.
.
construction of abstract object graph abstract object graph aog is statically constructed to approximate the runtime object graph.
an object graph is a graph with a single root where each vertex represents the object or the primitive value and each edge labeled with the eld name represents the eld reference between the vertices.
the root object that we are interested in is the object referenced by the thisvariable of the library class that encapsulates the data structure.
the object graph as shown in figure represents the layout of the root object in the heap that complies to the type de nition.
in the rest of the paper we do not distinguish the vertex and the object that it represents and similarly the edge and the eld.
in addition we refer to the path from the root to an edge that consists of the edges as the reference path of the edge.
multiple reference paths for an edge may exist indicating the object graph is not a tree.
de nition abstract object graph .the abstract object graph aog is a graph with a single root where each edge similar to the edge in the object graph represents the eld reference between two vertices and each vertex is a points to set computed by the pointer analysis to represent the possible objects referenced by the eld.
the points to set is a set of allocation nodes anodes each of which represents a unique allocation site where the runtime objects are created.
we construct the aog recursively using the pointer analysis by rst computing the root pointsto set s i.e.
pointto this where this isthisvariable of the library class and then computing each of its children points to sets i.e.
pointto s f where the eld fis a eld possibly referenced by anodes in the set s. the constructed aog is a static summary of the runtime object graphs during the program execution.
the main di erence with the object graph is that the objects created at the same site represented by di erent vertices in the runtime object graph are represented by the same vertex in the aog.
they are represented as an anode in a points to set.
.
tagging the abstract object graph tagging the aog is the core of our approach.
given an atomic method we tag each eld edge in the aog with di erent mgl locks based on how the eld is accessed in the atomic method.
the mgl locks need to coordinate the ancestor update and the descendant accesses to avoid the atomicity violation figure 2a .
meanwhile the mgl locks need to allow the concurrent updates of the disjoint parts figure and figure 3a even if they share the common ancestor eld.
in the following we present the tagging rules rule and rule which we design to achieve the above goals.
we rst compute how the elds are accessed in the atomic method using the standard side e ect analysis which is well implemented in open source compiler frameworks such as is ix x s is ix x s a is ix x s is ix x s b figure .
a compatibility matrix and b its numeric form soot1.
given a statement o.f i the analysis records that the eld fof the objects or anodes we may use the two terms interchangeably in pointto o are accessed2and the access type is update .
we are only interested in the shared objects in pointto o identi ed by the thread escape analysis insoot.
note that the side e ect analysis does not record the elds accessed within the collection invocations which we handle separately section .
.
rule .
if a eld is updated the edge that represents it in the aog is tagged with the xlock and each edge on the reference paths is tagged with the ixlock.
if a eld is read the corresponding edge is tagged with the islock and each edge on the reference paths is tagged with the islock.
the edge that represents a eld o fin the aog is an edge that satis es the following conditions it is labeled with the eld name f and the source of it is a points to set which contains the object o. besides the compatibility between the locks as explained in section is speci ed in figure 4a and implemented by the locking primitives section .
.
following rule the intention lock i.e.
the ixor the is lock placed on the ancestor eld o fon the reference paths indicates that the thread intends to access a descendant eldod fd.
as explained in section .
to access the eld od fd a thread needs to acquire both the associated lock and the intention lock for the ancestor eld o f. therefore the thread that updates the ancestor eld o fneeds to acquire thexlock for the eld o f and the thread that accesses the descendant eld od fdneeds to acquire the intention lock for o f. the two threads are coordinated because they acquire the incompatible locks i.e.
the xlock and the intention lock for o f which cannot be granted concurrently.
with the intention lock we avoid the large amount of runtime searching and analysis needed to decide whether the thread is eligible for holding the lock.
let us apply the tagging rule to the example in figure 2a to see how it prevents the atomicity violation.
in the atomic method operationb the eld manis updated.
therefore we tag the eld in the aog with the xlock as shown in figure 2c.
in the atomic method operationa the eld title is read.
therefore we tag the eld with the islock and the ancestor eld manwith the intention lock is as also shown 1soot 2there is a special eld arrayelement for denoting all elements in the array and there is a special anode for denoting each class.483in figure 2c.
note that in practice we tag the aog for di erent methods independently.
here due to the space limit we put all tags for the methods in one taog.
as a result the threads t1andt2are synchronized as t1acquires the intention lock isfor the eld man in addition to the is lock for the eld title and t2acquires the xlock for the same eld man which are incompatible with each other.
for the example in figure 3a the thread that updates the eld title acquires its xlock and the intention lock for the ancestor eld man the other thread that updates the eld text acquires its xlock and the intention lock for the ancestor eld man.
therefore both threads can run concurrently as the locks that they acquire are compatible with each other.
in addition we reduce the number of tags i.e.
the number of locks associated with each eld.
the underlying intuition is that if a thread acquires a lock for the eld e.g.
the x lock it does not need to acquire the less restrictive lock for the eld e.g.
the islock as the former lock is more general in the thread coordination.
intuitively the less restrictive lock is incompatible with fewer locks.
formally we say the lockl1is less restrictive than the lock l2 denoted as l1 l2 if and only if m l1 m l2 .
here mis the incompatibility matrix in figure 4b where denotes the incompatibility and denotes the compatibility and m l1 is a row vector.
speci cally we have is ix xandis s x where sandixare incomparable the usage of the slock is explained later in section .
.
.
rule formalizes the reduction based on the relation.
rule .
given an edge tagged with the a set of locks in the taog the lock lcan be removed if it is less restrictive than some other lock in the set without a ecting the concurrency allowed by the set of locks.
.
.
aogs that contain cycles the aogs constructed for real world programs are likely to be complex e.g.
they contain the cycles in which case we cannot apply rule since in nite number of reference paths may exist.
in nite number of reference paths consider the aog in figure which contains the cycle a!b!root there are in nite number of reference paths for the edge b in which the cycle appears di erent times.
according to the reduction in rule tagging an edge with multiple locks in the same mode has the same e ect as tagging it with only one lock in that mode.
therefore we do not consider the reference paths where the cycle appears more than once.
super uous reference paths in figure a reference path of the edge bis c!d!root!a.
following rule if the eld bis updated each ancestor edge e.g.
the edge d on the reference path needs to be tagged with the ixlock in order to prevent the concurrent update of the ancestor edge.
however in this example the update of the eld d does not a ect the eld b because the path from dtob includes the root object e.g.
the thisobject of the library class which remains unchanged throughout the execution of library methods.
as the root object remains unchanged the elds on the left cycle are not a ected by the update of the eld d. in other words the e ects of the update of a eld cannot propagate beyond the root object as long as the root is unchanged.
therefore when applying rule we do not consider the super uous reference path i.e.
the reference path that includes the thisobject of the library figure .
aog that contains the cycles class.
back to our example when the eld bis updated we only need to tag the elds on the reference path aonly we do not need to tag the elds on the super uous reference path c!d!root!aora!b!root!a both including the object this.
.
.
reduction of the number of tags in addition to the reduction rule rule we apply two reduction techniques to further reduce the number of tags in order to reduce the number of locks to be acquired.
cost bene t model for reduction a basic reduction step is given an edge e we remove all the tags in the subgraph referenced by eand tag the edge ewith the slock or thexlock.
the slock similar to the xlock protects all edges in the subgraph in the shared mode and disallows any concurrent update of them.
its compatibility with other lock modes is shown in figure 4a.
we tag the edge ewith the slock only if all the tags in the subgraph are isorslocks otherwise we tag it with the xlock.
however we need to decide which subgraph we apply the basic reduction step to.
we propose the cost bene t model to decide that.
the cost is computed as the number of tags in the subgraph i.e.
the number of locks to be acquired the bene t is computed as the number of elds in the subgraph that are not tagged and not reachable from any eld with thex slock tag.
as these elds are not accessed and not protected some other threads that access them are allowed to run concurrently.
after the reduction these elds would be protected which disables the concurrency.
we then compute the bene t cost ratio utility for the subgraph referenced by each edge.
we repeatedly nd the subgraph with the lowest utility and apply the above basic reduction step until the total number of tags is less than a threshold n we set n as in our evaluation or no subgraph can be chosen for the reduction e.g.
all tagged elds are directly referenced by the root object.
representative lock if multiple locks are used together or abandoned together in each atomic method we select one representative from them and replace the use of other locks to the use of the representative lock.
this reduces the number of locks to be used.
the mode of the representative lock is the strictest mode among the multiple locks.
this reduction method applies well in the presence of a cycle as all the edges from the cycle often appear together on the reference path and the locks protecting them are used together.
.
producing the lock operations after we construct the taog for an atomic method we remove the original synchronization from the source code and insert the lock acquisitions or releases that acquire484 or release the locks according to the tags in the taog.
we follow the non strict two phase locking which allows the lazy acquisition and early release i.e.
the acquisition of a lock is placed just before the shared access that the lock protects and the release is placed immediately after the shared access.
speci cally our static analysis keeps track of the accesses that each lock protects.
the analysis rst nds the minimal code block that is not in any loop body to enclose the accesses3.
it then places the acquisition at the beginning of the block and the release at the end.
the code block should not be in any loop body otherwise we may break the atomicity across iterations.
the lock regions computed in a method may violate the two phase locking e.g.
one lock region is placed after the other so that the acquisition may occur after the release.
we resolve the problem by merging4the lock regions as a new lock region and moving the acquisitions or releases accordingly.
after computing the lock regions we synthesize the lock operations.
the library developers often refer to the root of the irregular data structure as this and use it to protect the data structure.
the underlying assumption or rationale is that all accessed elds are descendants of the root of runtime data structure instance.
the assumption allows us to distinguish di erent data structure instances created at the same site.
speci cally we maintain a unique aog in each runtime data structure which coordinates only the accesses to that runtime data structure instance.
the lock operation is in the form of g lock e x acquire where lock e x returns the xlock associated with the edge ein the aog g andeis an edge tagged in the taog which is constructed during the static analysis.
more implementation details are presented in section .
.
our generated locking can be viewed as the ne tuned version of the original lock which relies on the taog to pinpoint the parts to be protected.
for the cases the assumption does not hold e.g.
the library developers use a static lock the lock referenced by a static eld to protect the entire data structure our above approach does not apply.
however we do not nd such cases in our evaluation.
deadlock freeness the acquisitions may lead to deadlocks when the locks are acquired in the reversed order or cyclic order.
to avoid the deadlocks we make sure the locks are acquired following the xed orders.
first the locks for the same runtime data structure are acquired following the topological order among the edges which is determined statically and embeded in the code.
second the locks for di erent runtime data structure instances or the locks for di erent keys section .
need to be sorted at runtime before they are acquired.
in practice each library method typically involves only one runtime data structure instance and one key during each execution for which the sorting overhead vanishes.
.
collection the collections such as map and set are heavily used in real world applications and impose special challenges to our optimization.
consider a map our static analysis cannot distinguish its di erent entries and therefore produce a single lock to protect the atomic methods such as putand 3finding the minimal block is a standard compiler analysis of which the details can be found in our technical report 4the details are also in our technical report.get.
therefore given two atomic methods that contain the invocations upon the same collection they cannot be executed concurrently.
herlihy et al.
exploit the linearizability and commutativity properties of the collection to draw the conclusion in lemma .
they prove lemma and design the software transactional memory mechanism to increase the concurrency degree for collections.
instead we design the mgl locking for collections to achieve the same goal.
in the following we rst brie y explain the linearizability and the commutativity.
lemma .
if the collection apis are linearizable and invoked in two atomic methods the two atomic methods can be executed concurrently without breaking the atomicity if and only if the invocations in one atomic method are commutative with those in the other.
linearizability the linearizability speci es the atomicity in terms of the return values.
speci cally the apis from a linearizable collection implementation if invoked concurrently return the values equivalent to those returned in some serial execution of the invocations.
the linearizable collection is often implemented in the non blocking way and allows high concurrency.
in the following we assume the collection is linearizable by default unless otherwise specied.
in our evaluation we replace5the collection with the linearizable version from the java.util.concurrent package in jdk by default.
commutativity two invocations e.g.
the invocations ofmap.put andmap.put are commutative if applying them in either order returns the same response and leaves the collection in the same abstract state e.g.
the state in which the map contains both and .
di erent from the concrete heap state the abstract state speci ed by developers captures only the information that the developers are interested in.
herlihy et al.
have speci ed the abstract state for the collections such as map set queue and others that have the standard semantics.
they have also summarized the commutativity among the invocations.
in our work we only optimize the uses of map and set which are heavily used in real world code.
speci cally the invocations upon a collection are commutative if they operate on di erent keys e.g.
the invocations of put andput they are not commutative if they operate on the same key or either of them does not require a key e.g.
the invocation of keyset .
lemma states that the interleavings by the commutative invocations do not break the atomicity as the interleaved execution can be transformed to some sequential execution through the equivalence preserving commutation.
therefore to ensure the atomicity of an atomic method we only need to prevent the interleaving by non commutative invocations.
one natural way is to apply the key based locking.
that is one unique lock protects each key.
in this way the noncommutative invocations that share the common keys are synchronized as they are protected by the same lock for the same key.
however the key based locking requires the key or its equivalent6to be available at the beginning of the lock region we compute the lock region following the lock placement in section .
.
where the lock acquisition happens.
however the key may not be available at the beginning of the lock region or the invocation simply does 5the replacement can be realized automatically .
6the local must alias analysis in soot computes the variables that are the must alias of the key.
a b figure .
a taog for the collection b a new level of edges for representing the partitions not require any key.
in either case the key based locking is not applicable.
the coarse locking should be applied instead to prevent any concurrent invocations upon the collection.
it is important to coordinate the threads that use the ne key based locking and the threads that use the coarse locking.
we design a variant of mgl for the collection to achieve the goal.
figure 6a shows the taog for a collection where the second level edge represents each key and the rst level edge allkeys represents the whole collection or all the keys .
if a thread resolves at the beginning of the lock region the key to be involved in the invocation it acquires the xlock for the key and the ixlock for the edge allkeys .
otherwise the thread simply locks the whole collection by acquiring thexlock for the edge allkeys .
in this way the invocations with common keys are coordinated by the xlocks for the common keys while the invocations with di erent keys can run concurrently.
besides the thread that carries out the invocations without a key or the invocations of which the keys cannot be resolved at the lock acquisition prevents any concurrent invocations by acquiring the xlock for the edge allkeys and locking the whole collection.
partition as expected the above mgl protocol would involve many locks at runtime which may cause the memory problems in practice.
we reduce the number of locks needed by rst mapping the keys to npartitions7and then replacing the locks for keys to the locks for partitions.
in particular we insert an additional level of edges each representing a partition as shown in figure 6b.
at runtime instead of acquiring the lock for a key the thread acquires the lock for the partition that contains the key which is determined based on the hashing function hashcode key n. in addition the thread also needs to acquire the lock for the edge allkeys in the same way as discussed above.
as a result we reduce the total number of locks to a small number.
note that we reduce the concurrency at the same time e.g.
the invocations upon two di erent keys may be unnecessarily synchronized because the keys are mapped to the same partition.
in practice we do not maintain the level of keys dotted edges in figure 6b in the taog for the collection as we can nd the partition that contains the key through the calculation of the hashing value.
7similar to the implementation of the class concurrenthashmap in jdk we use partitions by default.
.
implementation our implementation is built upon the static analysis e.g.
thespark pointer analysis and the side e ect analysis provided by the soot compiler framework.
our approach does not support the atomicity among the atomic set currently.
however it is not hard to extend our approach to support the atomic set we just need to treat the elds in the same atomic set as one eld and protect them with the same lock.
the implementation of the mgl locking primitives e.g.
lock.x .acquire orlock.ix .acquire is similar to the implementation of the readers writer primitives in the java.util.concurrent package which is built with the extensible synchronizer framework in the same package.
the main di erence is that the mgl supports four modes while the readers writer locking supports only two modes.
we build the mgl locking on the same framework by supporting four modes.
besides the compatibility among the four modes is hardcoded as the code logic.
.
evaluation in our evaluation we focus on the following aspects the metrics of the static analysis.
the performance comparison between the optimized version and the original version.
our evaluation uses ve applications cache4j jgrapht tomcat tuplesoup and stmbench7 of which the rst four are widely used in practice while stmbench7 is designed for evaluating various synchronization approaches.
all studies are performed on a x86 dell workstation with cores.
the server has 16gb of ram and runs on a linux .
.
kernel.
.
cache4j cache4j implements the memory based caching capability for java objects.
the synchronizedcachetest class in the benchmark measures the performance of the concurrent cache library i.e.
the synchronizedcache class.
the performance test code starts multiple threads each of which invokes the putand getmethods from the synchronizedcache class.
the methods are originally atomic as their bodies are wrapped by the synchronized block synchronized this .
speci cally each thread executes invocations of which invoke the getmethod and the rest invoke the putmethod.
our analysis takes milliseconds.
the aog constructed to represent the data structure is acyclic and contains nodes and edges in total.
the aog is tagged di erently in the methods.
figure 7a and figure 7b show the tagged aogs taogs for the methods getand put respectively.
due to the limit of space we omit the edges involving collections and those never tagged.
some eld names are also abbreviated.
we observe that the xlock for the eld memorysize in figure 7a is incompatible with the xlock for the same eld in figure 7b while the locks for each of the other elds in both taogs are mutually compatible and can be held by two threads concurrently e.g.
the ixlock associated with the eld cacheinfo in figure 7a is compatible with the ixlock for the same eld in figure 7b.
as for the eld memorysize it is updated by a single statement in both methods.
our lock placement section .
places the lock operations closely around the statement leading to a very small lock region.
given the threads that invoke the methods getand put486x x x x ix is is is a x x ix is is is is b figure .
a tagged aog produced for the method get the number in each node denotes the hashcode of the points to set represented by the node.
b tagged aog for the method put.
concurrently they are coordinated by the xlock for the eld memorysize only when both of them want to enter the small lock regions.
the reduction using the cost bene t model section .
.
does not apply because the number of tags is less than the threshold while the reduction using the representative lock section .
.
applies.
given the elds miss remove andhit which are all used in the method getand all unused in the method put we select the lock for the eld miss as the representative and remove the locks for the other two elds by replacing the use of them to the use of the representative lock.
besides the root object has two elds of the map type map and tmap .
following the optimization in section .
we replace the map with the linearizable implementation in jdk e.g.
the class concurrenthashmap and synchronize the operations on the keys whenever possible.
speci cally we synchronize the operations on map using the key based lock because the key is resolved as a method parameter.
however we have to synchronize the operations on tmap using the coarse lock that protects the whole collection because the key cannot be resolved at the lock acquisition as it is computed after the lock acquisition.
figure shows the performance comparison between our optimized version optand the original version orig.
our optimized version scales well when the number of threads increases e.g.
the optimized version outperforms the original version by when the number of threads is greater than .
however when the number of threads is smaller than e.g.
when only one thread is used the optimized version msecs is slower than the original version msecs .
the result is consistent with our expectation the original version performs well when the number of threads is small because it incurs fewer locking operations and the optimized version performs well when the number of threads is large because it allows greater concurrency.
we believe orig opt 16figure .
performance comparison for cache4j .
the x axis denotes the number of threads and the y axis denotes the running time msec .
allowing greater concurrency is of critical importance as multiple or even many threads are often used in the real world applications to exploit the power of the multi core machine.
.
jgrapht the benchmark jgrapht is a commonly used graph library.
the class performancedemo shipped with the library measures the performance of the library.
speci cally the performance test code runs several threads each manipulating the graph gby invoking the methods addvertex oraddedge .
to achieve the atomicity of each method the developers wrap the method body with the synchronized block that uses the graph object gas the lock.
as a result all the invocations are executed sequentially.
the jgrapht library heavily uses the map collection e.g.
it stores the vertices in a map and the edges in the other map.
our optimization replaces the maps with the concurrenthashmap implementation and successfully synchronizes each of the methods on the key passed as the method parameter.
with our optimization the invocations of the methods addvertex oraddedge can be executed concurrently if they involve di erent keys i.e.
the di erent vertices or di erent edges.
figure 9a shows the performance comparison between the optimized version optand the original version orig.
the optimized version nishes faster when the number of threads increases because the total workload i.e.
adding vertices and edges for each vertex is shared among threads and these threads can run concurrently.
comparatively the original version runs the invocations sequentially even in the presence of multiple threads and the synchronization incurs extra overhead which becomes very high when the contention becomes erce as the interaction with os is involved therefore it requires even longer execution time when the number of threads increases.
our optimized version is 2x faster as compared to the original version when there are more than threads.
we also notice that our optimized version does not perform well in the single threaded setting e.g.
it is slower than the original version.
the possible explanation is that the original map implementation introduces only one instruction compare and set instruction while the concurrenthashmap implementation adopts the non trivial synchronization which introduces more instructions.
.
stmbench7 stmbench7 is an application specially designed to measure the e ects of di erent synchronizations on the performance.
orig opt a throughput transactions per second coarse manual opt throughput transactions per second b orig opt c orig opt d figure .
performance comparison for a jgrapht b stmbench7 c tomcat d tuplesoup .
the x axis represents the number of threads and the y axis represents the running time msec .
specially the y axis for stmbench7 represents the throughput transactions per second .
the core data structure is encapsulated in the library class module which