always available static and dynamic feedback michael bayne richard cook michael d. ernst university of washington mdb rcook mernst cs.washington.edu abstract developers who write code in a statically typed language are denied the ability to obtain dynamic feedback by executing their code during periods when it fails the static type checker.
they are further confined to the static typing discipline during times in the development process where it does not yield the highest productivity.
if they opt instead to use a dynamic language they forgo the many benefits of static typing including machine checked documentation improved correctness and reliability tool support such as for refactoring and better runtime performance.
we present a novel approach to giving developers the benefits of both static and dynamic typing throughout the development process and without the burden of manually separating their program into staticallyand dynamically typed parts.
our approach which is intended for temporary use during the development process relaxes the static type system and provides a semantics for many type incorrect programs.
it defers type errors to run time or suppresses them if they do not affect runtime semantics.
we implemented our approach in a publicly available tool ductilej for the java language.
in case studies ductilej conferred benefits both during prototyping and during the evolution of existing code.
categories and subject descriptors d. software engineering d. .
language constructs and features general terms design languages experimentation keywords dynamic typing gradual typing hybrid typing productivity prototyping refactoring static typing type error .
introduction developers rely on both static and dynamic feedback when creating software.
they obtain static feedback in the form of syntax and type checking by running the compiler.
they obtain dynamic feedback by executing the software and its tests.
only the developer knows what form of feedback is most useful at any given moment during software development yet the developer is constrained by current tools and cannot always get the feedback they need.
a developer who chooses a dynamically typed language forgoes the many benefits of static types entirely.
a developer who chooses a statically typed language is denied the ability to obtain dynamic feedback during the periods when their program fails to type check.
most statically typed languages embody the philosophy that an ill typed program is of zero value the compiler simply rejects it.
we consider such programs to have value in that a developer may be interested in execution paths that do not traverse the type incorrect code or that are not affected by the inaccuracies in the source code s type annotations.
for what are sometimes technical and sometimes ideological reasons programmers are denied the benefits of having static and dynamic feedback any time they deem it useful.
this state of affairs leads to frustration this research was supported by nsf grant ccf .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.and wasted effort.
we believe that the programmer should be in charge and should be able to do either form of checking at any time during the development process and with minimal extra effort on their part .
we posit that a developer should write code in a statically typed language making a best faith effort to get the types right and obtaining sound feedback from the type checker.
but even at moments when the program is not globally type correct the developer should be able to run the code to test it or to increase insight.
we seek to streamline the process of creating code that will ultimately be type correct while recognizing that type correctness is not always the developer s highest priority.
during development code often temporarily exists in a state of partial type correctness while the developer focuses on non type related aspects of the code.
eventually the code will be made type correct but in the order deemed most efficient by the developer.
in our system type annotations are not optional in the source code so it is unlikely that a user will ignore them or think in a non typed mindset during development.
furthermore at any moment the developer can obtain complete sound type checking feedback by running the standard compiler.
developers can switch seamlessly between the typed and untyped views of their program since sometimes it is best to fix compiler errors and sometimes it is best to run the program.
ductilej does not provide all the benefits of a dynamically typed language it focuses on the ability to execute the code at any time.
our goals and approach differ from research that aims to mix static and dynamic types in the same program.
the two main approaches are adding optional static type checking to a dynamically typed language or relaxing the type system of a statically typed language.
we briefly describe each in turn also see the related work in section .
using a dynamically typed language with an added static type checker the developer can obtain dynamic feedback at any time per usual for a dynamic language and can obtain static feedback when desired by running the type checker.
however most dynamically typed languages do not afford the easy addition of a static type system.
dynamicallytyped programs tend to explicitly leverage highly dynamic features like late binding of names meta programming and monkey patching the ability to arbitrarily modify the program s ast.
most attempts to layer a static type system atop a dynamic language support only a subset of the language excluding many dynamic features and compromising the programming model and or the type checking guarantee.
the most common approach to relaxing a static type system is to introduce some form of dynamic type also known as object any void etc.
allowing the developer to mix statically typed and dynamically typed code in the same program.
such an approach does not meet our goals of providing always available static and dynamic feedback.
such a program can have static type errors and be rejected by the compiler thereby preventing the programmer from executing the program.
even if the type checker passes the program may still fail at runtime because dynamic was used to mask behavior from the type checker the user did not get comprehensive effective static feedback.
another disadvantage of this approach is programmer effort the programmer must explicitly specify which parts of the program are to be statically typed and which are to be dynamically typed.
we propose a new approach to relaxing a static type system.
rather than extend an existing language with dynamic elements we provide an alternative semantics for the language in which the compiler warns about errors in the declared types but always generates code which performs all type checking at runtime.
by providing a semantics that defers statictype errors until runtime and masks them whenever possible we allow the developer to obtain dynamic feedback on part of their program even if other parts contain type errors.
our semantics for the java programming language which allows for the execution of many type incorrect programs adheres to the following principles .where correct static types exist use them to provide behavior equivalent to the original semantics.
in java static types affect runtime semantics such as resolution of overloading.
.where correct static types are lacking use runtime type information to resolve ambiguity in the same manner that static types would be used.
.where correct static types are lacking and runtime type information is either incorrect or insufficient to resolve ambiguity terminate execution with a runtime error.
we implemented this semantics in a tool called ductilej.
it uses a detyping transformation section to convert a potentially type incorrect program into one that is trivially statically type correct and which performs all type checking at runtime.
section evaluates ductilej the correctness of its transformation its usefulness during prototyping and refactoring and its runtime performance.
in summary our contributions are a new perspective on delivering the benefits of both static and dynamic typing which focuses on temporary relaxation of static types.
an informal semantics and publicly available tool for the execution of type incorrect java programs based on a detyping transformation.
an evaluation of the benefits conferred by our approach in both prototyping and software evolution scenarios.
.
motiv ation our proposal is motivated by a simple idea a developer should always be able to execute their code regardless of whether the code type checks.
this section describes scenarios where such a capability is useful.
section .
describes case studies that evaluate each of the two scenarios.
.
software evolution during the evolution of a software system global enforcement of static type correctness can be burdensome to a programmer.
it forces changes to be made in an order preferred by the type checker rather than the order preferred by the programmer.
often the programmer would benefit from the ability to incrementally test changes as they are made when feedback on changed behavior is most useful but the programmer is prevented from executing those tests until the entire program is type correct.
delaying discovery of a failed test until long after a change has been made forces the programmer to page in the code again when investigating the failure increasing the effort needed to fix the error.
furthermore if the test failure shows that the change needs to be implemented differently the developer may have wasted effort performing similar changes in the same inappropriate way elsewhere in the codebase.
by testing as they go the developer can repair errors while the failing code is fresh in their mind and they can leverage knowledge gained from validating earlier changes to avoid repeating the same mistakes when making later changes.
representation or interface changes one common evolution task is to change the data representation or interface of a program component.
take as a concrete example an instant messenger im program that initially supports only a single network and is now being expanded to support multiple networks.
a user was initially identified by a string their user name on the single supported im network.
now the programmer needs to replace all uses of the string type in this context with a record or object type that additionally indicates their network.such a transformation identifying particular uses of a general purpose type like string and converting them to a user defined type cannot easily be automated with refactoring tools.
the developer must make the change manually and would prefer to make and test the change incrementally for the reasons stated above.
unfortunately in a staticallytyped language this is often not possible.
one must transform the whole program before type correctness and hence testability is restored.
even in a well modularized program where one might hope to transform and test one module at a time such changes can impact the interfaces between modules.
once the changes are begun on one module the other modules are type incorrect for as long as they reference the old representation.
this is true even if they do not depend on the representation such as a data structure that stores user information.
the programmer must either expend effort to specialize their build system to isolate one module at a time for compilation and testing or concede to the demands of the type system and reinstate total type correctness before testing.
exploratory changes when making exploratory changes that include changes to types a developer will often make the type changes first preserving the original behavior of the program and stubbing out new functionality.
they then go back and make the behavioral changes.
this minimizes the period during which they are unable to execute and test their program.
however this also results in a greater time investment in exploratory changes before they are evaluated for viability.
the programmer may discover shortly after beginning the behavioral changes that their approach is infeasible.
the time spent making the upfront type changes was wasted.
with always available static and dynamic feedback they can implement and test their type and behavior changes simultaneously.
if they determine that they need to take a different approach they will have done so sooner and with less effort.
ad hoc testing not every aspect of a software system is amenable to automated testing.
in some cases developers opt not to use automated testing even where it is possible for reasons of expedience.
for example a developer may choose to test their user interface by interacting with it directly.
our approach can benefit these developers by enabling them to perform ad hoc tests as they make changes.
in cases where the type checker forces them to delay this ad hoc testing until the software is totally type correct they may forget exactly which parts of the program s functionality were impacted by their changes and omit ad hoc tests that are needed.
.
software creation prototyping creating a rough first draft of functionality is a lowcost way to evaluate the feasibility of a design or approach.
it can reveal hidden assumptions and it permits rapid iteration and experimentation to hone in on desired behavior.
a certain amount of static typing is beneficial during prototyping.
thinking about types up front and having them automatically checked helps the developer to organize the code and the design.
this is especially important during prototyping when a system s foundations are put in place.
but too much static typing can be detrimental.
during prototyping the structure of the program changes rapidly and code may be quickly written and thrown away.
expending the extra effort to add type annotations or to create abstractions with separate interfaces and implementations can be wasteful given the transient nature of the code.
because of this dynamically typed languages are considered to be very effective for prototyping.
prototypes often contain temporary or partially implemented functionality that falls out of date with the rest of the program.
if the code is statically typed the programmer has two undesirable and wasteful options.
one option is to expend effort to keep the unused and possibly irrelevant code type consistent with the rest of the program.
another option is to comment out the code which forces the developer to chase down any other bits of code that reference the commented code and painstakingly identify the precise boundary between what code is usedand what code must be commented out.
in a language that distinguishes between static and dynamic constructs such as the dynamic type the static parts of the code may fall out of date as the prototype rapidly evolves.
these parts of the code then cause the program to fail to compile and require the developer to fix them before they can once again execute their code just as they would in a completely statically typed language.
furthermore any use of the dynamic type requires the programmer to later revisit the code perhaps having forgotten their precise intentions in the meantime.
recalling those intentions particularly in the absence of the helpful documentation of type declarations then manually updating the types is a time consuming process.
a developer should be able to write down the types they think are appropriate but should not be required to maintain perfect type correctness while they are prototyping.
by having both static and dynamic feedback available at all times the developer can focus on type correctness or behavioral correctness as they see fit and not be forced to prioritize one over the other.
by using the types they think are appropriate they express their intentions concretely in the code and reduce the effort needed to later make the code type correct.
prototypes eventually give way to production code where static typing can help greatly with code evolution and maintenance.
it is possible for developers to create a prototype in a dynamically typed language and then rewrite everything in a statically typed language once the exploratory prototyping phase is complete.
fred brooks once said to plan to throw one away you will anyhow .
but he now acknowledges that a better practice is to build a minimal thing get it out in the field and start getting feedback .
it is quite common for prototypes to evolve into production systems.
in such circumstances there is no good point at which to rewrite the entire project in a new language.
the language chosen for the prototype is often the one that is used for the final product.
it should be one that supports the dual benefits of dynamic and static typing during prototyping.
.
implementation we have implemented our approach for the java language in a tool called ductilej .
ductilej consists of a plugin to the java compiler and a run time library.
the compiler plugin performs a detyping transformation that converts a normal java program to one in which type checking is deferred until runtime.
the plugin operates on the abstract syntax tree ast during compilation before generation of java bytecodes.
the runtime library uses java s runtime type information and its reflection mechanism for dynamically accessing object fields and invoking methods.
for nearly all well typed programs the detyping transformation yields code with semantically equivalent runtime behavior specific deviations are described in section .
.
for type incorrect programs execution will terminate with a runtime type error roughly only when the program executes a statement that performs a dynamic cast to an incompatible value calls a method not supported by the receiver accesses a non existent field or performs a built in operation like arithmetic multiplication on a value of invalid type.
further details on execution terminating runtime errors are provided in the detailed explanation of the transform that follows.
an inconsistency between a declared type and a runtime value does not terminate the program because the runtime value might provide all the methods and fields that are necessary for this particular execution.
if the execution completes normally then the type inconsistency was not important.
recall that the programmer only runs the code at moments when they have decided that observing a test execution is more valuable than reviewing type checker warnings.
if the execution fails then the type inconsistency may yield insight into the failure.
therefore we propose that the declared types be checked at each pseudo assignment and any inconsistencies be logged.
if the program fails with a runtime type error then it is reported along with relevant declared type inconsistencies.
these could be determined for example via dynamic slicing from theruntime type error.
this approach contrasts with other approaches that halt the program as soon as a declared type is inconsistent with a runtime value.
the error logging and slicing are not yet supported in our ductilej implementation.
space limitations prevent us from providing complete details of the transformation in this paper so we describe the basic transformation and a few language constructs and summarize the remainder in section .
.
space limitations also prevent us from describing the prototype implementations of the ductile approach for c p ductilesharp and for scala education courses cse501 10au ductilescala.pdf languages that present a different set of design challenges.
.
basic transformation variable declarations the transformation replaces all declared types with object .
this includes local variables method parameters and class fields.
an example of such a transformation follows class foo int bar int compute int baz string qux ... class foo object bar object compute object baz object qux ... in certain circumstances variable declarations are not transformed.
the exception declaration in a catch clause is not transformed.
the declared type of the exception defines the runtime semantics of the program and thus must be preserved.
however catch clauses that reference an unknown type which would result in compilation failure if preserved in detyped code are removed as they cannot impact the behavior of the program.
variables that are declared as final and are initialized by a constant expression are not transformed.
such constant declarations must remain typed to preserve correct use in annotations and in situations where constant boolean expressions impact definite assignment analysis.
method invocation and field access object construction method invocation and field reads and updates are transformed into calls to the ductilej runtime library which performs these actions via reflection.
such calls in the example code take the form rt.action .
the behavior of the rtcalls is generally a runtime equivalent of the pre transformed static code along with more informative error handling than that provided by java s reflection library.
the following example shows object construction field read and update and method invocation foo foo new foo foo.bar int r foo.compute foo.bar object foo rt.newinstance foo rt.assign foo bar object r rt.invoke compute foo rt.select foo bar thert.newinstance call raises an error at runtime if the supplied class does not exist or lacks a public constructor that accepts the appropriate number of arguments.
similarly rt.invoke raises an error if the receiver lacks a method of the specified name and arity.
rt.select andrt.assign raise an error if the supplied object lacks a field of the specified name.
note that the types of the arguments to constructors and methods and the types of the values stored in object fields need not be compatible with the declared types in the original code.
while method invocation andfield access may raise message not understood errors runtime type errors are generally only raised when a value of incorrect type is used as an operand of an arithmetic or boolean operator or in language constructs likeiforwhile statements which require a specific primitive type.
section .
discusses the interaction between detyped and undetyped code and describes how method invocation and field assignment can result in runtime type errors in those cases.
operators built in unary and binary operators are transformed into calls into the runtime library that check the types of the operator arguments and then perform the appropriate computation.
numeric promotion is performed by rt.binop at runtime per the rules described in java language specification .
.
if either operand is of incompatible type a runtime exception will be raised.
.
exception wrapping when method invocations are converted into reflective calls information about checked exceptions is lost.
the following transformation results in invalid java code int readchar inputstream in try return in.read catch ioexception e return object readchar object in try return rt.invoke read in catch ioexception e return the call to in.read is declared to throw an ioexception but the call to rt.invoke is declared to throw no checked exceptions.
the java compiler rejects any catch clause for a checked exception that cannot be thrown in the enclosed code.
furthermore when invoking a method via reflection java wraps any exceptions thrown by the invoked method in invocationtargetexception instances.
thus even if the compiler did not reject the transformed code above it would have a semantics that differs from the original code the ioexception would not be correctly caught if thrown.
to ensure both a correct semantics and legal java code the runtime library catches and re wraps any exceptions thrown as a result of its reflective calls into the new exception type wrappedexception .
this new exception type is used in lieu of invocationtargetexception to avoid conflicting with direct uses of reflection by the untransformed code.
alltry catch blocks are then transformed as follows object readchar object in try try return rt.invoke read in catch wrappedexception e w if e w.getcause instanceof ioexception throw ioexception e w.getcause else throw e w catch ioexception e return this ensures that checked and unchecked exceptions are caught in the same manner as the untransformed code and that the java compiler sees the static possibility that the appropriate checked exception is thrown inside a given try catch block.
note that this transformation is done regardless of whether the try catch block originally contained code that threw the exception in question.
we see this as another beneficial relaxation of the static type system.
a programmer can remove a checked exception from the throws clause of a method and defer the additional effort of removing any try catch blocks that would normally become invalid as a result of that method no longer throwing the checked exception.
.
method overloading java allows multiple methods with the same name and arity to be declared as long as they differ in their argument types.
at compilation time the static types of the arguments are used to select the appropriate overloaded method.
as the detyping transformation converts the types of all method arguments to object this can result in collisions in overloaded method declarations.
in addition to the need to prevent these collisions transformed well typed code must make the same choice in resolving overloaded methods dynamically at run time as would have been made statically at compile time.
name mangling cannot be used in this circumstance as constructors cannot be name mangled.
instead we use signature mangling .
a method s arguments are replicated into value carrying arguments and type carrying arguments.
the value carrying arguments have type object and are used at runtime to pass values to the method.
the typecarrying arguments have the original declared types and their values are not used at runtime.
this ensures that every method has a unique non colliding signature.
an example of signature mangling is class printer void print string value ... void print int value ... printer p new printer int val p.print val class printer void print object value string value t ... void print object value int value t ... object p new printer object val 2nd argument is declared type of argument expressions rt.invoke print new class ?
int.class p val during the transformation of call sites overloaded methods are resolved based on the declared types of their arguments.
if sufficient compile time type information exists to unambiguously select a mostspecific overloaded method the argument types identifying that method are injected into the program to communicate to the runtime which method to execute.
if no most specific overload can be determined no type information is injected.
in that case rt.invoke will attempt to resolve the overload using the runtime type of the method arguments.
if that type information is also insufficient to resolve the overload a runtime error is raised.
during runtime method invocation rt.invoke inserts default values null boolean or the appropriate 0value into the argument array at the type carrying positions.
.
library code ductilej s transformation differentiates between code that is being transformed and code that remains statically typed.
the user can make this choice by default ductilej detypes all source code available to it but not binaries such as platform code and third party libraries.
we refer to untransformed code as library code .
while a bytecode transformation approach could allow third party libraries to be detyped even without access to their source code we expect detyping to be most useful on code that the developer is actively changing.
besides only type correct code can be compiled into bytecodes and ductilej is intended to help programmers to run type incorrect code.
detyped code need not use libraries in a type checkable manner.
at run time when detyped code makes a call into library code if the arguments do not have the parameter types required by the library call a type error is raised.
this is analogous to ductilej s handling of primitive operations.
type signatures are preserved for any method in detyped code that overrides implements a method defined in a library class interface.
this ensures that if a reference to a detyped instance is passed into librarycode the untransformed library code will operate correctly.
an example of a detyped library overrider is shown below class person implements comparable person public int compareto person p1 person p2 int rv ... return rv class person implements comparable person type signature unchanged public int compareto person p1 p person p2 p object p1 p1 p p2 p2 p object rv ... return rt.cast int.class rv detyped local variables use the same names as the original parameters.
this allows the detyped method bodies to use the arguments as l values in assignments whose r values are themselves detyped.
also the return value of the method is dynamically cast back to the declared return type of the method.
if the body of the method computes a return value of the wrong type a type error will be raised by rt.cast .
this signature preservation reduces in a small way the flexibility of the detyped code.
normal detyped methods can accept any argument type and return a value of any type regardless of their declared types.
only if the bodies of those methods make use of the values in a manner incompatible with their runtime types will an error be raised.
library overriders must be called with type correct arguments and return typecorrect values regardless of whether those arguments are used in the method body or the return value is used by the caller.
.
type resolution part of the detyping transformation is purely syntactic and part requires type resolution for names and expressions such as when disambiguating overloaded methods section .
.
even in non overloaded method invocations the detyping transformation must distinguish between static and non static receivers to correctly transform the code.
ductilej implements a relaxed type resolver that performs normal type resolution using the types declared in the code and falls back to object for expressions that cannot be resolved.
for a type correct expression the resolver obtains the same type as the standard java compiler and for type incorrect expressions the resolver can proceed in cases where the java compiler would terminate with a type error by substituting object for the types of unresolvable sub expressions.
.
other transformations the java language has grown large in its maturity and achieving a correct semantics for detyped code required substantial effort.
some other interesting challenges handled by ductilej s detyping transformation include handling of arrays final fields and variables arithmetic and logical operators control flow constructs widening and narrowing conversions annotation and enum classes anonymous inner classes definite assignment analysis variable arity methods partially implemented interfaces super and chained constructor calls use of explicit outer this pointers in inner class construction security manager restrictions and primitive vs. object equality.
.
debugging the detyped code that is executed differs from the source code that the user views in their ide.
this did not decrease productivity when debugging in our case studies.
the stack trace is identical even down to line numbers except that between every pair of stack frames is a new stack frame for the ductilej runtime library s rt.invoke call.
users should ignore those frames.
all debugger features such as breakpoints and watched variables work.
the changed variable types and the extra method arguments are visible.software sloc cloc tests clot google collections .
hsqldb .
.
.
joda time .
figure correctness tests.
sloc is non comment lines of code.
cloc is changed lines of non test code.
tests is the number reported by the test framework e.g.
junit plus the number of sql commands for hsqldb .
clot is changed lines of test code.
.
limitations this section describes two java language features that ductilej does not yet support and our plans for supporting them.
ductilej does not currently support separate compilation but we do not have space to explain our design.
reflection the detyping transformation changes both the arity and type signature of methods including constructors .
ductilej does not yet support code that uses reflection to inspect or call methods that take arguments.
one approach to supporting reflection is to intercept calls to java s reflection routines and translate them such that they report metadata that matches the original undetyped code.
ductilej would also transparently insert appropriate values for type carrying arguments to method and constructor calls made via reflection.
this can be done by transparently rewriting bytecode as it is loaded into the vm which will ensure that reflection use in both detyped and library code functions properly.
the feasibility of such an approach has been established by the empl and ruggedj tools which hide program transformations from java reflection.
serialization java provides built in support for converting objects to and from a binary representation for network transmission or persistent storage.
like reflection this facility relies on metadata that is modified by the detyping transformation.
the java serialization framework provides hooks for custom object serialization which can be used to automatically generate custom serialization and deserialization routines that read and write the standard serialized representation of the untransformed class.
.
ev aluation the goals of our evaluation are threefold.
first we wish to demonstrate that our tool ductilej correctly performs the detyping transformation on a sufficiently large subset of the java language in order to render it usable on real world programs.
second we wish to understand the benefits of always available static and dynamic feedback during prototyping and software evolution tasks.
third we characterize the performance of ductilej.
.
semantic correctness much of the challenge in implementing the detyping transformation in java stems from handling the complicated interplay of language features like inner classes variable arity methods generics and autoboxing.
because such features not to mention their interactions are generally omitted from formalizations of the java language we chose an informal approach to demonstrating the semantic equivalence of detyped to undetyped code.
we used ductilej to compile and run the unit test suites of a variety of java libraries and applications and confirmed that the suites reported no failures.
while this does not establish that there are no differences between the detyped and standard java semantics indeed section .
lists some it does build confidence that there are no commonly used language features or interactions thereof that are not handled correctly by the detyping transformation.
figure summarizes the largest of the projects that we used in our evaluation.
all tests passed when run in detyped form.
we made minor modifications to work around the limitations described in section .
.
reflection the google collections test suite uses reflection to succinctly express tests parameterized over all methods of a class and over individ ual parameters to those methods.
we modified the test drivers to ignore the type carrying parameter positions and to obtain the types of the valuecarrying positions from the type carrying positions.
these modifications did not change the conditions for correctness.
the joda time test suite uses reflection to invoke the constructors of two classes which do not provide public constructors.
hsqldb uses reflection to fall back to a simpler database metadata class if the construction of the newer class results in failure.
we manually inserted type carrying arguments into these calls.
section .
describes an approach to handling reflection in detyped code which would eliminate the need for these changes.
serialization the detyping transformation inserts initializers for detyped primitive fields to emulate the initialization of said fields to their default values e.g.
0for an intfield .
these injected initializers are run as a part of an object s constructor but an object s constructor is not invoked during deserialization which circumvents normal constructor invocation.
we manually inserted into google collections custom readobject methods that initialize detyped primitive fields to their default values before triggering the normal deserialization process.
ductilej should synthesize this readobject method automatically during the detyping process but this is not yet implemented.
in the joda time test suite tests consisted solely of deserializing objects from binary data stored with the project and validating the resulting objects.
because detyping changes the serialized form of the objects in question we used detyped instances to regenerate the binary data against which the tests were run.
ductilej should synthesize readobject andwriteobject methods to overcome this incompatibility but this is not yet implemented.
.
case studies to evaluate the benefits of always available static and dynamic feedback we used ductilej to prototype new programs as well as to evolve existing type correct programs.
we were specifically interested in learning which of the many benefits conferred by the use of dynamically typed languages could be obtained by using ductilej.
we also wished to investigate the benefits of fluidly switching between static and dynamic views of the same code.
the developers were two of this paper s authors.
one has developed commercial software for years chiefly in statically typed languages like java and c though many smaller projects in scripting languages perl php ruby and python .
the other is a senior engineer at microsoft with years of professional software engineering experience of which one year was using dynamically typed languages such as ruby and python.
based on their experiences both developers have a preference for static typing.
thus they began with skepticism about ductilej but strove to maintain an unbiased and objective viewpoint.
these initial studies are limited so the conclusions might not generalize to other developers or tasks future work should extend them.
.
.
prototyping two developers each implemented a contact management application.
it was specified as follows create a simple program for managing an e mail address book.
each entry in the address book has fields for first and last name e mail address and birthday.
the software must support entry creation editing browsing and lookup via a gui or a commandline tool.
structure the program in two parts a database that stores address book entries with separate interface and implementation and the application built atop that library.
the two completed applications were and lines long including test code and took and .
hours to write respectively.
we next describe the benefits of the ductile approach that the developers leveraged.
they worked independently but their experiences were similar so the following text reports the experience of the first developer described above.
in each case statements reflect the developer s self reported beliefs while performing the case study.duck typing duck typing checks each individual field access or method invocation at runtime and succeeds or fails based on whether the required field or method is defined for the object.
it is akin to structural typing where structural conformance is checked at runtime.
in the prototype the interface portion of the application made use of a database interface which evolved as the prototype was developed.
the developer used the database type name in code that he knew would operate on the database abstraction but he did not explicitly declare which methods would be exported by the database interface.
instead he developed a concrete implementation of the interface and deferred decisions about which methods in the concrete implementation would be exported via the interface and which would not.
once the prototype was complete he examined the type checking output which had been available all along but which he had been temporarily disregarding.
he immediately saw which implementation methods were needed in the interface all other methods could remain hidden as implementation details.
this saved him the effort of keeping interface declarations up to date with the appropriate implementation definitions as the prototype evolved.
checked exceptions java distinguishes between checked and unchecked exceptions.
for calls that might generate a checked exception either the call must occur in a try catch block that handles the exception or the enclosing method must declare that it allows the exception to propagate.
the developer was able to defer the handling of checked exceptions until his design had reached a point of stability.
this conferred multiple benefits.
the main benefit was that as the design took shape he was able to focus on whether the code effectively provided the desired functionality rather than be distracted by the minutiae of failure handling.
some aspects of failure handling are important but if a potential design is deemed to be inappropriate effort put into handling specific error cases while prototyping that design is most likely wasted.
the developer reported that he was able to more cheaply experiment with alternative designs and only invest the effort in proper error handling once he had reached a final design.
this saved the developer from the temptation of inserting placeholder error handling code which he might have easily overlooked when later finalizing the design.
he did not want to insert dummy try catch blocks just to get his prototype working because he would have had to later manually find and repair all such temporary code without the help of the compiler.
further he feared that he may have placed his temporary error handling at places that after finalizing his design he decided were not appropriate.
this would have added to his workload to remove the temporary error handling code from those locations add the necessary throws clauses and then add the real error handling code in the desired locations.
finally by delaying the declaration of the checked exceptions propagated by a method he was confident that he avoided polluting his method signatures with vestigial exception declarations.
given the inability to defer checked exception handling developers often choose to propagate checked exceptions while prototyping to avoid having to decide how and where to handle errors.
these exceptions then end up in method signatures.
the developer may subsequently change the implementation such that it throws a different set of checked exceptions.
the compiler unfortunately does not report that he now has unnecessary checked exception declarations in his methods since it is perfectly legal in java to declare that a method may throw checked exceptions that it does not actually throw.
thus these checked exceptions often linger in the method declarations complicating client code which must now handle these phantom error conditions.
by delaying the declaration and handling of checked exceptions until the end of the prototyping process the developer reduced the likelihood of such signature pollution.
access control an unexpected benefit the developer encountered was the ability to defer the enforcement of access control.
in converting his prototypes to type correct code the developer discovered that he had unintentionally called private or protected methods from code that didnot have access to those methods.
he was glad that he was not using the stock java compiler which he felt would have distracted him from his prototyping task to determine the correct way to accomplish the desired functionality.
honoring access control restrictions is clearly something that should be done eventually but he felt it was beneficial to defer that effort until after he knew that the code in question would make it into the final design.
earlier versions of his code that he later discarded called other inaccessible methods.
he felt that in such cases he was able to avoid wasting effort determining how to properly access functionality that was eventually not needed.
negatives the developer encountered some annoyances while performing the case study but none of them delayed him more than a moment.
one was that he once mistyped a field name and he discovered this fact via testing rather than at compile time when he would have preferred.
the other negatives have to do with limitations of our prototype implementation.
the developer tried to use reflection to obtain the return type of a method but it returned object instead see section .
.
the developer was happy not to have to write import statements but the import statements were necessary to resolve certain constructor calls which was a surprise when he had been using the type in other contexts in the same file.
finally because he was using an early version of ductilej he encountered some bugs in it which have since been fixed interrupting his thought process to report and work around these was his biggest annoyance in the study.
comparison with automated refactoring modern ides support certain type related code changes.
to call these automatic fixes however would be a misnomer.
in our study the developer recognized that changing access modifiers adding thrown exceptions adding methods to interfaces etc.
just to satisfy the compiler at an intermediate point in the program s evolution would degrade his design.
it would require human effort in the future to find places that needed to be corrected and to correct them.
the eclipse fix would make a developer more likely to introduce undesired dependences that would linger unnoticed and be difficult to fix later with the ductile approach the regular compiler can still find them.
eclipse s refactorings are useful in certain circumstances but in this case eclipse would have automated the code transformations that the developer had already decided were ill advised.
.
.
software evolution evaluating a refactoring we hypothesize that our approach confers benefit for software evolution tasks by allowing design alternatives to be explored with less effort.
to investigate this hypothesis the first developer described in section .
.
refactored jhotdraw a gui framework for technical and structured graphics.
jhotdraw defines a figure interface which serves as the root of a rich hierarchy of classes that model geometric figures.
figure defines a method containspoint int x int y which the developer wished to refactor to containspoint point p .
the developer s goal was to expend as little effort as possible evaluating whether this refactoring was feasible and appropriate.
one way to make that evaluation is to perform a vertical slice of the refactoring change the interface any necessary implementations and one or more test cases that invoke the refactored code.
the developer selected one concrete implementation trianglefigure and its associated test case trianglefiguretest .
thus the goal was to get trianglefiguretest running against the refactored interface.
because he may determine at that time that the refactoring is inappropriate he would like to expend as little effort as possible in so.
after evaluating the refactoring the developer would either undo the changes or complete the refactoring.
the heart of the refactoring is three key changes change the containspoint method signature in the figure interface update the trianglefigure .containspoint implementation accordingly and change thetrianglefiguretest code to supply point arguments instead of x and y coordinates.the developer investigated three approaches.
a type driven manual refactoring required code changes to make the test case pass.
a typedriven refactoring with eclipse support required one eclipse refactoring then manual edits a few of them tricky as described below to make the test case pass.
a manual refactoring using ductilej required only the key changes before the test case passed.
we now discuss each of the approaches in turn.
type driven manual refactoring the type checker can guide a developer through a refactoring.
the programmer performed the three key changes then ran the compiler which reported errors.
of the errors stemmed from calls to containspoint that had not yet been updated to supply a point instead of separate x and y coordinates.
the other errors stemmed from concrete implementations of figure that lacked an implementation of the new containspoint point as their containspoint int int method had not yet been converted.
the programmer performed minimal fixes for the remaining errors so that he could compile and execute trianglefiguretest .
this required only changes to the source because updating the implementation of containspoint in some abstract base classes resolved errors for all of their children.
after making those changes he was able to execute trianglefiguretest and evaluate his refactoring.
those changes represent substantial effort beyond the changes that were directly related to his evaluation.
eclipse supported semi automated refactoring eclipse provides a change method signature automated refactoring to assist with refactorings like the one in this case study.
the developer instructed eclipse to change the signature of the figure.containspoint method by removing the xandyparameters adding a java.awt.point p parameter and using new java.awt.point x y as the default argument for calls.
he would have preferred a default of new point x y and in fact tried that first but eclipse fails to insert necessary import statements.
though the final eclipse refactoring littered the code with undesirable fully qualified class names which must be manually fixed later it allowed him to defer that effort until after he had evaluated his refactoring by executing his desired tests.
after automated refactoring the compiler reported errors.
of these errors stemmed from implementations of containspoint that were referencing the old formal parameters xandyrather than the new parameter p. the other errors resulted from eclipse s verbatim insertion of new java.awt.point x y as the argument to existing calls to containspoint .
eclipse made transformations like the following public boolean test figure fig int x1 int y2 return fig.containspoint x1 y1 public boolean test figure fig int x1 int y2 return fig.containspoint new point x y the refactoring ought to substitute the previous actual arguments forxandyin the default expression.
only a few calls to containspoint happened to use precisely the arguments xandy and were correspondingly correct after the naive verbatim text replacement.
manually repairing the resulting errors required changes to source files.
most of those changes were straightforward but two types of changes presented more difficulty.
first because the automated refactoring erased the old parameters to the containspoint call there were several situations where he had to make use of the version control system to inspect the prior arguments to determine the correct values to use in constructing the new point .
second in cases the original arguments were notthe variables xandy yet other variables named xand y with correct types happened to be in scope at the call.
the verbatim default argument insertion thus resulted in code that compiled but whose behavior was inconsistent with the behavior prior to the refactoring.
ductilej supported manual refactoring when using ductilej the developer made the desired change to figure.containspoint andsoftware stock s detyped s slowdown google collections .
.
.
hsqldb .
.
.
joda time .
.
.
figure average execution time of test suites.
updated the code in trianglefiguretest .
after just these changes he was able execute the refactored code.
ductilej reported that a runtime type error was encountered in the trianglefigure.containspoint implementation.
he then converted that method to the new signature and updated its body.
at this point he executed the unit test successfully and was able to evaluate his refactoring.
ductilej allowed him to execute the desired tests without making any changes unrelated to his immediate goal.
it also guided him toward exactly the changes that were needed to bridge the gap between the updated figure.containspoint method and the updated trianglefiguretest class which made calls using the new signature.
while this case study is simple and could be better supported by improved refactoring tools in the eclipse ide developers frequently perform refactorings that are even more complex and must be done with limited or no automated refactoring support .
it is impossible to predict every kind of refactoring a developer may wish to perform and support it with special purpose machinery in the ide.
however the ductile approach can simplify the process of evaluating any refactoring increasing confidence that it is appropriate before the developer commits to the potentially substantial effort of applying that refactoring to the entire codebase.
.
performance the detyping transformation degrades execution performance.
our focus so far has been to establish the feasibility and utility of our approach without undue concern for performance.
in the case studies the developers observed no slowdown perhaps because gui applications are not compute bound untransformed libraries often dominate execution time and test cases tend to execute quickly.
figure summarizes the slowdown exhibited on the unit test suites we used to evaluate semantic correctness in section .
.
we have found the performance to be acceptable for a development time tool.
there are two major sources of slowdown in detyped code.
the first is the dynamic lookup and reflective invocation of methods and the second is the dynamic execution of arithmetic and logical operations.
dynamic method dispatch dynamic method dispatch incurs performance penalties in two ways the correct method to be called must be resolved and the method must then be invoked via java s reflection mechanism.
ductilej caches method resolution results.
performance for calls with dynamically correct type information could be improved by inserting a type check on the receiver then performing a normal inline method call if the type check succeeds.
performance for calls without correct type information could be improved by generating and loading shim classes then invoking them through a standard invokeinterface bytecode instruction as in jruby .
an even more appealing approach uses the forthcoming invokedynamic support in the java vm .
arithmetic and logical operations normal compiled java code uses special bytecode instructions for operations on primitives.
in detyped code ductilej incurs the overheads from boxing unboxing dynamic type tests promotions and conversions.
one approach to improving the performance of such operations is to avoid detyping variables declared with primitive types.
this would improve runtime performance at the expense of reducing the flexibility of detyped code it would no longer be possible to carry arbitrary values in variables declared with primitive types.
the approach could be taken further by not applying the detyping transformation to any code that type checks.
however if ductilej did so then a type check and a cast would be required whenever calling suchcode just as with undetyped libraries section .
.
it would no longer be possible to run code in which a client passes an object that contains all the methods that will ever be called at run time and this is a major feature of ductilej.
our goal in this research was to maximize development time flexibility but it is possible that greater productivity may be achieved via different performance flexibility tradeoffs in different development scenarios.
future work should investigate these tradeoffs.
.
related work and discussion our work aims to integrate dynamic and static type systems in a single language.
previous work on this topic generally falls into two categories strengthening a dynamic type system without losing the feel or expressiveness of the dynamic language and adding a dynamic type to a statically typed language while retaining as many guarantees as possible about the statically typed portion of a program.
there is significant variation within the two categories and also some notable outliers.
our approach differs from all of this previous work both in motivation and in technical details.
this section provides an overview of related work and then highlights differences.
.
strengthening a dynamic type system adding types to a dynamically typed language can improve performance and detect some errors at compile time.
in order to retain the feel of the language programmers are not required to write type annotations instead type inference is used.
this general approach is often called soft typing .
first applied to scheme it has since been extended to other languages .
soft typing never rejects a program but it does issue warnings.
the program can still fail due to a type mismatch at runtime.
such errors do not corrupt the underlying runtime system because a dynamicallytyped program performs checks before each operation that requires a given type such as primitive operations or field accesses.
in addition to issuing warnings soft typing also improves efficiency by optimizing away unnecessary runtime checks when the type inference can statically prove that the check is guaranteed to succeed at runtime.
this approach has also been applied in a more practical setting in the rpython for reduced python language .
rpython eliminates enough of the dynamism of the full python language that type inference always succeeds if the program has no errors.
its goal is to achieve higher performance enabled by type guarantees.
druby follows this approach but is focused on discovering type errors in existing ruby programs.
the pruby extension gathers dynamic profiles in order to reduce programmer annotation burden and it also replaces untypable dynamic features with statically analyzable alternatives.
researchers report that many programs written in dynamic languages are nearly typable because they don t use much dynamism in practice .
however practitioners have not adopted these restricted dialects or type inference mechanisms.
in practice it is difficult to increase the amount of static typing in any language.
the largest scale conversion was probably the addition ofconst to c c programs an arduous process commonly referred to as const correctness hell .
a close second is addition of generic types to java programs.
years after the introduction of generics sun oracle has not yet converted all of the signatures in the jdk to use generic types and they never intend to convert the bodies to be generics correct.
lisp programs have been retrofitted with declare and proclaim for efficiency and the authors of typed scheme have rewritten part of their systems to use it.
in each of these examples the conversion required hard thinking and program restructuring though the conversion generally did improve the code.
our experience is that when programmers start out with a dynamic mindset they may choose a design that is not statically typable even when a statically typable design exists and is preferable.
this leads to painful program restructuring much later in the development process.
thinking about and writing the types helps to prevent this problem andbeing able to run a type checker helps even more.
this is why we believe that types should be in the programmer s mind and code and be supported by the toolset but not enforced until the programmer is ready from the beginning of the development process.
.
adding dynamic to a static type system abadi et al.
first formalized adding a dynamic type and a typecase construct to a statically typed language though programmers had been using such code often without the benefit of static type checking guarantees for some time.
this approach is known as incremental gradual or hybrid typing.
the key idea is that part of the program is statically type checked and part of the program uses a dynamic type.
type errors cannot be the fault of the statically typed portion but can be due to the dynamically typed portion or the boundary between them.
the boundary between the parts can be arbitrary it may lie along module interfaces or may separate two arguments to an operation.
the programmer explicitly decides the boundary and indicates it by writing type annotations.
the key challenge taken up by researchers is defining behavior at the boundary correctness no type errors in the static portion efficiency and blame control finding the root cause of an error that arises dynamically in the static portion .
optional typing sometimes called pluggable typing offers no compiletime or runtime guarantees but the types nonetheless offer software engineering and performance benefits.
gradual typing guarantees that in a fully annotated program all type errors are caught at compile time and no dynamic checks are needed.
otherwise there are checks at the boundary and objects carry their types with them at least for higher order types.
the type system replaces type equality with type consistency which permits coercions that add and remove instances of ?
their name for dynamic .
quasi static typing is a similar idea but type errors can occur at runtime even in a completely annotated program.
another precursor is the babyj dialect of javascript which focuses on nominal types.
thorn s like types are intermediate between staticallychecked types and dynamic and their benefits are also intermediate between the two.
a like type s uses must be correct according to the static type system but any value may be assigned to a like type and must be checked at runtime .
introducing a like type can introduce both compile time and runtime errors but does not guarantee the absence of either.
a thorn programmer must manage boundaries between dynamic like types and concrete types rather than just between dynamic and concrete types.
runtime checks at the boundaries guarantee that there are no type errors in the statically typed portion of the code but thorn omits blame assignment to avoid performance penalties.
typed scheme adds procedure declarations and contracts runtime checks at the boundary.
hybrid typing along with work in a similar spirit by ou et al.
takes contracts even further.
its refinement types are arbitrary assertions and the static analysis does both type checking and theoremproving to statically discharge as many as possible.
a type checking error arises only from an assertion that can be proved to always fail.
any assertion that cannot be discharged is left in the generated code to be checked at runtime.
there is no guarantee that an assertion failure will not halt the program at runtime.
blame assignment aims to help programmers understand the root cause of a runtime error.
the runtime error may arise in type checked code but may be due to an earlier problem in unchecked code such as putting a value of incorrect type in a data structure.
to test higher order values blame assignment uses wrappers that test the values at the point of use rather than at the boundary into typed code .
then a challenge is to improve efficiency for instance using fewer wrappers and retaining tail call optimization .
.
comparison to the ductile approach our work differs from the related work in supporting full sound statictyping throughout a codebase and permitting the entire codebase to be treated as dynamically typed.
unlike the work of section .
ductilej does no type inference but requires explicit type annotations.
unlike the work of section .
ductilej makes no guarantees that code in which static types are written will suffer no type error at runtime if the whole codebase is statically type correct the guarantee holds .
as a result ductilej can run more code and the programmer is not forced to explicitly identify and maintain the boundary between the statically and dynamically typed code.
we now identify some other differences.
which types should be dynamic?
most of the related work assumes that a programmer is able and willing to determine which parts of his or her program should be dynamic or that sound static typing is not a requirement.
ductilej automatically uses the dynamic type everywhere even while permitting a programmer to write and check types.
when should dynamic typing be used?
some of the related work assumes that a programmer will want to use dynamic typing indefinitely in some parts of a program the work seeks interoperability with staticallytyped code.
other work aims to evolve dynamically typed programs into statically typed programs .
but once the program has been converted the benefits of dynamic typing are lost during later maintenance stages unless the programmer explicitly changes types back to dynamic .
our work is unique in its focus on transitioning in both directions of the typing discipline which supports important software development needs.
we also advocate writing approximations to static types from the beginning.
even if they are imperfect e.g.
the type used might not yet be defined they convey intent and cause the programmer to think about static types throughout the interactive design process.
they give incremental typing benefits without lock in and they ease the final transition to types making it more palatable and likely.
what is the starting point for the language design?
unlike most related work we start from the context of a statically typed language and seek to add the benefits of dynamic typing rather than vice versa.
and our work has a robust implementation in the context of a real industrial strength language giving it the potential to yield practically interesting questions and answers.
what are the scarce resources?
today computation is plentiful and cheap.
human effort and attention dominate the cost of most software produced today especially if one includes the costs of bugs and rework that result from inadequate or poorly focused human attention.
much of the related work is motivated by efficiency even to the point of removing features like blame assignment .
by contrast our primary focus is on the programmer.
we do not force the programmer to write perfect type annotations before running the code.
we could utilize optimization approaches proposed by others but they may be less necessary in our context since ductilej s dynamic execution is used only in the context of in house testing dynamism is removed before a release build is produced.
we believe it is critical to first determine whether the approaches proposed by us and others are useful.
if so then they can be optimized rather than the other way around.
.
tolerating inconsistencies ductilej s key idea is to provide feedback despite the existence of inconsistencies that will eventually be resolved.
this is not a radical idea a similar approach has been independently proposed1 but not implemented nor evaluated.
the approach is in widespread use informally as programmers use static checkers from lint to pluggable type systems that can be temporarily disabled or simply not run while the programmer focuses on other issues.
ossher et al.
take a similar approach to requirement engineering providing a single toolset that supports both checked and unchecked modeling.
they had found that current tools consistency checking got in the way and caused users to abandon those tools losing other features such as change propagation and information migration to downstream tools.
relaxes a particular set of compiler requirements making it possible to run code that violates java s static type system.
perhaps the sweet spot is to relax the static requirements even more such as by eliminating checks for uninitialized variables or by executing calls with an incorrect number of arguments.
perhaps the sweet spot relaxes fewer static requirements such as by prohibiting misspelled identifiers which were the main annoyance in our case studies.
smalltalk takes this approach it is dynamically typed but when it encounters a symbol that is not in scope the ide pops up an offer to declare it.
or perhaps the best programming methodology requires stricter type checking than current languages or even that code should be forbidden from being tested until after it has been formally proved correct.
the particular choices made in our current ductilej implementation seem to be effective based on the case studies.
now that we have proposed the approach future work should determine whether other choices are even better and whether particular development styles or problem domains affect the choice.
.
conclusion we have proposed a novel approach to integrating features normally found in dynamically typed scripting languages into statically typed programming languages.
the key idea is to permit a programmer to view a program through the lens of completely dynamic typing or completely static typing and to switch between these views seamlessly as often as desired.
this approach contrasts with other work that attempts to find a middle ground and that retains neither safety nor flexibility.
our goal is to enable programmers to work faster than they can with statically typed languages and to produce more reliable code than they can with dynamically typed languages.
our approach enables the programmer to obtain either static or dynamic feedback whenever the programmer chooses.
this overturns current ide paradigms putting the programmer in charge of the analysis tools rather than the analysis tools in charge of the programmer.
our experiments demonstrate that our approach is sufficiently correct and performant and that the benefits of dynamism aid programmers during both prototyping and evolution.
ductilej is publicly available including source code .
.