an effective dynamic analysis for detecting generalized deadlocks pallavi joshi eecs uc berkeley ca usa pallavi cs.berkeley.edumayur naik intel labs berkeley ca usa mayur.naik intel.comkoushik sen eecs uc berkeley ca usa ksen cs.berkeley.edu david gay intel labs berkeley ca usa dgay acm.org abstract we present an e ective dynamic analysis for nding a broad class of deadlocks including the well studied lock only deadlocks as well as the less studied but no less widespread or insidious deadlocks involving condition variables.
our analysis consists of two stages.
in the rst stage our analysis observes a multi threaded program execution and generates a simple multi threaded program called a trace program that only records operations observed during the execution that are deemed relevant to nding deadlocks.
such operations include lock acquire and release wait and notify thread start and join and change of values of user identi ed synchronization predicates associated with condition variables.
in the second stage our analysis uses an o the shelf model checker to explore all possible thread interleavings of the trace program and check if any of them deadlocks.
a key advantage of our technique is that it discards most of the program logic which usually causes state space explosion in model checking and retains only the relevant synchronization logic in the trace program which is su cient for nding deadlocks.
we have implemented our analysis for java and have applied it to twelve real world multi threaded java programs.
our analysis is e ective in practice nding thirteen previously known as well as four new deadlocks.
categories and subject descriptors d. .
testing and debugging d. .
software program veri cation general terms reliability veri cation keywords deadlock detection dynamic program analysis concurrency .
introduction a deadlock in a multi threaded program is an unintended condition in which one or more threads block forever waiting permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa.
copyright acm ... .
.for a synchronization event that will never happen.
deadlocks are a common problem in real world multi threaded programs.
for instance of the bug reports in the bug database at for sun s java products involve the keyword deadlock .
moreover deadlocks often occur non deterministically under very speci c thread schedules making them harder to detect and reproduce using conventional testing approaches.
finally extending existing multi threaded programs or xing other concurrency bugs like races often involves introducing new synchronization which in turn can introduce new deadlocks.
therefore deadlock detection tools are important for developing and testing multi threaded programs.
there is a large body of work on deadlock detection in multi threaded programs including both dynamic analyses and static analyses .
most of these approaches exclusively detect resource deadlocks a common kind of deadlock in which a set of threads blocks forever because each thread in the set is waiting to acquire a lock held by another thread in the set.
speci cally these techniques check if the program follows a common idiom namely that there is no cycle in the lock order graph consisting of nodes corresponding to each lock and edges from l1tol2where lock l2could be acquired by a thread while holding lock l1.
dynamic analyses predict violations of this idiom by analyzing multi threaded executions of the program that do not necessarily deadlock whereas static analyses do so by analyzing the source code or an intermediate representation of the source code of the program.
however deadlocks besides resource deadlocks namely communication deadlocks that result from incorrect use of condition variables i.e.
wait notify synchronization as well as deadlocks resulting from unintended interaction between locks and condition variables are no less widespread or insidious than resource deadlocks.
from the user perspective deadlocks are harmful regardless of the reason that causes the involved set of threads to block forever.
yet in the extensive literature on deadlock detection only little work e.g.
addresses communication deadlocks.
we initially set out to devise a dynamic analysis to predict communication deadlocks by checking an idiom analogous to that for resource deadlocks.
however after studying a large number of communication deadlocks in real world programs we realized that there is no single idiom that programmers follow when writing code using condition variables.
therefore any such dynamic analysis based on checking idioms would give many false positives and false negatives.
the study also suggested that nding communication deadlocksis a hard problem as a communication deadlock can be nontrivially dependent on aspects of the underlying synchronization logic that vary from program to program.
in this paper we present a novel dynamic analysis called checkmate to predict a broad class of deadlocks subsuming resource deadlocks communication deadlocks and deadlocks involving both locks and condition variables.
checkmate instead of checking conformance to a particular idiom creates a simple multi threaded program called a trace program by observing an execution of the original program and model checks the trace program to discover potential deadlocks.
the trace program for a given multi threaded execution creates an explicit thread for each dynamic thread created by the execution.
the code for each thread in the trace program consists of the sequence of lock acquires and releases wait and notify calls and thread start and join calls by the corresponding thread in the original execution.
however this is not enough the state of the synchronization predicates associated with condition variables must also be tracked and checked.
in the trace programs these synchronization predicates are represented as boolean variables with explicit assignments where the original program performed an assignment that caused the predicate s value to change and explicit checks before uses of wait and notify.
all other operations performed by a thread in the original execution such as method calls assignments and expression evaluations are not incorporated in the trace program.
in summary a trace program captures the dynamic synchronization pattern exhibited by the original program execution.
checkmate then model checks i.e.
explores all interleavings of the trace program and checks if it could deadlock.
if a deadlock is discovered checkmate maps the interleaving back to the original program and reports it as a potential deadlock in the original program.
checkmate analyzes java programs but java does not make synchronization predicates explicit any predicate could be the synchronization predicate for a condition variable making it di cult to automatically identify them.
synchronization predicates could be inferred statically however we do not focus on such analysis in this paper.
instead checkmate requires that programmers identify synchronization predicates using a lightweight annotation mechanism section .
.
checkmate uses these annotations to observe all changes to values of synchronization predicates.
note that manual annotations are not necessary if the language makes synchronization predicates explicit.
in summary the key contributions of checkmate are a key insight underlying our approach is that model checking applied to the trace program is much more likely to scale than if it were applied to the original program.
this is because the trace program discards all data operations and computations performed by the program and only retains operations that are deemed relevant to nding deadlocks namely synchronization operations and changes to values of synchronization predicates.
moreover it is generated by observing a single nite execution of the original program.
therefore a trace program has a much smaller and nite state space than the original program and is more tractable to model check.
a key bene t of our approach is that it can nd any kind of deadlock irrespective of whether the program follows a recommended idiom or not.
another bene t of our model checking based approach over idiom checking based approaches is that our approach provides detailed counterexamples explaining the deadlocks it reports a feature we have found particularly useful for debugging communication deadlock.
we believe that our idea of capturing the essential synchronization skeleton of a program execution using a trace program is novel and could be applied to discover other kinds of concurrency bugs although such applications might need to extend a trace program with more kinds of operations.
our analysis is not sound because a deadlock in the trace program may not be feasible in the original program.
our analysis is also not complete as we construct the trace program by observing a single execution.
note that this is true of most predictive dynamic analyses such as eraser and goodlock .
however we have found our analysis to be e ective in practice.
we have implemented it and applied it to twelve real world multi threaded java benchmarks.
it has low run time overhead and generates trace programs that are model checked e ciently using java pathfinder jpf an explicit state model checker for java bytecode.
it also has low false positive and false negative rates and detects thirteen previously known as well as four new deadlocks in our benchmarks.
.
rationale in this section we explain the rationale behind our approach after describing the recommended usage pattern for condition variables.
recommended usage figure shows the recommended pattern for using condition variables in java.1the condition variable in the gure is associated with a synchronization predicate b e.g.
fifo xis non empty .
any code like f1 that requires bto be true e.g.
dequeuing an element from fifo x must hold the condition variable s lock l and repeatedly wait l.wait on the condition variable until bis true.
any code f2 that might make btrue e.g.
enqueue an element in fifo x must make these modi cations while holding the condition variable s lock l and must notify all threads that might be waiting for bto become true l.notifyall .
after a waiting thread wakes up it should again check to see if bindeed holds for two reasons.
first the notifying thread f2 may notify when bis not necessarily true.
second some other thread may have invalidated bbefore the woken thread was able to acquire lock l. our initial effort we devised a dynamic analysis to predict communication deadlocks using thread interleavings that did not exhibit the deadlocks.
we checked to see if all condition variables used in such interleavings followed the recommended usage pattern shown in figure .
consider the real world code fragment in figure .
any of its interleavings violates two aspects of that pattern rst thread uses an ifinstead of awhile to check predicate b and secondly neither thread 1strictly speaking java uses monitors that combine a lock and a condition variable.
we use lock and condition variable to clarify to which aspect of a monitor we are referring this also makes clearer how checkmate would apply to languages with separate locks and condition variables.
f1 f2 synch l synch l while !b change in value l. wait of b that could do something that make b true requires b true l. notifyall figure recommended condition variable usage.
we use synch to abbreviate synchronized.
thread thread i f !b b true synch l l. notifyall synch l l. wait figure deadlock due to missed noti cation.
accesses bin the same synchronized block as the one containing l.wait orl.notifyall .
the analysis we devised thus reports a possible deadlock in this code fragment regardless of the interleaving it observes.
indeed the shown interleaving of this code fragment exhibits a deadlock.
in this interleaving thread rst nds that boolean bis false.
thread then sets bto true noti es all threads in the wait set of l i.e.
the threads that are waiting on l and releases l. the wait set of l however is empty in particular thread is not yet waiting on l. finally thread resumes and waits on l assuming incorrectly that bis still false and blocks forever as thread the only thread that could have noti ed it has already sent a noti cation and terminated.
this is a classic kind of communication deadlock called a missed noti cation in java.
limitations of pattern enforcement we found pattern based enforcement to be of limited value for two reasons.
first programmers often optimize the recommended pattern based on their knowledge about the code.
for instance if the synchronization predicate bis always true when a thread is woken up then the thread may not need to check bagain i.e.
the while inf1 can be an if.
or if a number of threads are woken up by a notifying thread but the rst thread that acquires lock lalways falsi es the predicateb then waking up the other threads is pointless.
in this case the notifying thread f2 can use notify to wake a single thread.
a real world example violating the pattern is found in lucene version .
.
a text search engine library by apache in some cases a thread may change the value of a synchronization predicate in one synchronized block and invoke notifyall in another synchronized block.
although the noti cation happens in a di erent synchronized block it always follows the change in value of the predicate and hence there is no deadlock because of this invariant which the recommended usage pattern does not capture.
second code that respects the pattern can still deadlock because of interactions between other locks and condition variables.
consider the code in figure based on a real example the locks follow the cycle free lock order graph idiom for avoiding resource deadlocks and the condition variables follow the recommended usage pattern in figure for avoiding communication deadlocks yet their combined use causes a deadlock exhibited by the shown interleaving.
this code fragment can occur because a library uses the condition variable involving lock l2 and an application calls into the thread thread synch l1 synch l2 while !b l2.
wait synch l1 synch l2 l2.
notifyall figure deadlock involving both locks and condition variables.
library while holding its own lock l1.
in fact this pattern occurs frequently enough in practice that findbugs a popular static bug nding tool for java that checks common bug patterns reports that calls to wait with two locks held may cause a deadlock .
in summary we could not nd an idiom for accurately predicting all deadlocks by observing interleavings that did not exhibit them.
this motivated us to devise an analysis that uses a model checker to explore all possible interleavings.
model checking is di cult to scale to large programs.
we chose to strike a trade o between scalability completeness and soundness by model checking a trace program obtained from a single execution of the given program.
in so we sacri ce both completeness and soundness but our analysis scales to large programs.
this is not only because the trace program is generated from a single nite execution of the given program but also because it only records operations that we deem are relevant to nding the above kinds of deadlocks.
not only does our analysis nd both deadlocks discussed above it does not report a false deadlock for the correct usage of noti cation in lucene described above.
.
overview in this section we illustrate our analysis using the example java program in figure .
class mybuffer is intended to implement a thread safe bounded bu er that allows a producer thread to add elements to the bu er and a consumer thread to remove elements from it.
list bufrepresents the bu er cursize denotes the current number of elements in the bu er and maxsize denotes the maximum number of elements allowed in the bu er at any instant.
ignore the underlined eld condition and all operations on it for now.
the program uses a condition variable with two associated synchronization predicates to synchronize the producer and consumer threads.
the rst predicate checks that the bu er is full method isfull and the second that the bu er is empty method isempty .
a producer thread adds elements to the bu er using the put method.
if the bu er is full it waits until it gets noti ed by a consumer thread.
after adding an element to the bu er it noti es any consumer thread that may be waiting for elements to be available in the bu er.
likewise a consumer thread removes elements from the bu er using the get method.
if the bu er is empty it waits until it gets noti ed by a producer thread.
after removing an element from the bu er if the bu er was full it noti es any producer thread that may be waiting for space to be available in the bu er.
finally the resize method allows changing the maximum number of elements allowed in the bu er.
the main method creates a mybuffer object bfwith amaxsize of .
it also creates and spawns three threads that execute in parallel a producer thread pthat adds two integer elements to bf a consumer thread cthat removesan element from bf and a third thread rthat resizes bfto have a maxsize of .
1public class mybuffer 2private list buf new arraylist 3private int cursize maxsize 4private conditionannotation condition new conditionannotation this public boolean isconditiontrue return mybuffer o .
isfull public mybuffer int max maxsize max public synch void put object elem condition .
waitbegin this while isfull wait condition .
waitend buf.add elem cursize notify public object get object elem synch this while isempty wait elem buf.
remove synch this condition .
notifybegin this i f isfull cursize notify else cursize condition .
notifyend return elem public synch void resize int max maxsize max public synch boolean isfull return cursize maxsize public synch boolean isempty return cursize public static void main string args final mybuffer bf new mybuffer thread p new thread public void run for int i i i bf.put new integer i .
start thread r new thread public void run bf.
resize .
start thread c new thread public void run bf.get .
start figure example with a communication deadlock.
suppose we execute the program and the three threads spawned by the main thread interleave as shown in figure .
in this interleaving thread p rst puts integer into bf.
since the maxsize ofbfis bfis now full.
but before pputs another integer into bf thread rchanges the maxsize ofbfto .
thus bfis not full any more.
thread pthen puts integer into bf.
finally thread cremoves integer from bf.
note that neither of the two wait s in the program is executed in this interleaving.
however there is another interleaving of threads p r and cthat deadlocks.
this interleaving is shown in figure .
thread pputs integer into bf.
since the maxsize ofbfis bfgets full.
when p tries to put another integer into bf it executes the wait in theput method and blocks.
thread rthen increases the maxsize ofbf and thus bfis not full any more.
thread c then removes integer from bf.
since bfis not full any more as thread rgrew its capacity it does not notify thread p. thus pblocks forever.
our analysis can predict the deadlock from the interleaving in figure although that interleaving does not exhibit the deadlock and does not even execute any wait .
for this purpose our analysis records three kinds of information during the execution of that interleaving.
first it records synchronization events that occur during the execution like lock acquires and releases calls to wait andnotify and calls to start and join threads.
secondly it records changes to the value of any predicate associated with a condition variable during the execution.
since java has no explicit synchronization predicates associated with condition variables our analysis requires the user to explicitly identify each such predicate by de ning an instance of class conditionannotation shown in figure .
in our example in figure there are two condition variables in class mybuffer one for predicate isfull and the other for predicate isempty .
we manually annotate the mybuffer class with the underlined eld condition de ned on lines to identify predicate isfull .
this eld holds a conditionannotation object that de nes a method isconditiontrue that can determine in any program state whether that predicate is true.
our analysis uses this method to determine if each write in the observed execution changes the value of predicate isfull .
we provide a similar annotation not shown for brevity for predicate isempty .
note that our annotations are very simple to add if we know the implicit synchronization predicates associated with condition variables.
these annotations can also be inferred automatically using static analysis but we leave that to future work.
thirdly our analysis also records each wait and notify event that did not occur during the observed execution because the condition under which it would have occurred was false in that execution.
our analysis again relies on manual annotations for this purpose this time in the form of calls to pre de ned methods waitbegin waitend notifybegin and notifyend on the conditionannotation object corresponding to the predicate associated with the condition.
the annotations on lines and denote that the execution of wait in the put method depends on the value of predicate isfull .
during execution even if this predicate is false these annotations enable our analysis to record that had it been true the wait would have executed.
likewise the annotations on lines and denote that the execution of notify in the get method depends on the value of predicate isfull .
similar annotations not shown for brevity are added to handle the use of the isempty predicate.
our analysis generates the java program shown in fig thread p thread r thread c bf.put bf.
resize bf.put bf.get figure non deadlocking interleaving for figure .
thread p thread r thread c bf.put bf.put bf.
resize bf.get figure deadlocked interleaving for figure .
1public class traceprogram 2static object bf new object 3static boolean isfull 4static thread main new thread public void run isfull false p. start r. start c. start static thread p new thread public void run synch bf enter bf.put i f isfull synch bf bf.
wait isfull true bf.
notify leave bf.put synch bf enter bf.put i f isfull synch bf bf.
wait bf.
notify leave bf.put static thread r new thread public void run synch bf enter bf.
resize isfull false leave bf.
resize static thread c new thread public void run synch bf enter bf.get i f isfull synch bf bf.
notify leave bf.get public static void main string args main .
start figure trace program generated by observing the execution of the interleaving in figure of the example in figure .
ure which we call a trace program by observing the execution of the interleaving in figure and with the help of the above annotations.
note that the trace program has excluded all the complex control structure e.g.
the forloop and method calls and memory updates e.g.
changes incursize and buf and has retained the necessary synchronization operations that happened during the execution.
this simple trace program without the complicated program logic of the original program is much more e cient to model check.
in the trace program we have used descriptive identi er names and comments to help relate it to the original program.
such comments and identi er names help our analysis to map any error trace in the trace program to the original program which could be used for debugging.
the fact that our analysis can generate an informative error trace in the original program is a key advantage of our technique over other predictive dynamic analysis techniques.
in the trace program bfdenotes the instance of mybuffer created during the observed execution.
note that we make bfof type object instead of type mybuffer because we do not need to worry about the program logic in the trace program.
isfull denotes predicate bf.isfull upon which thewait in the put method and notify in the get method are control dependent.
the main thread main initializes isfull to false and starts threads p r and cas in the observed execution.
note that although the wait in the put method is not executed in either of the two calls to bf.put by thread pin that execution the run method of thread pin the trace program records that this wait would have been executed in either call had isfull been true.
also isfull is set to true on line since the bu er becomes full after thread pputs the rst integer into it.
thread ris the thread that resizes the bu er and increases its maxsize .
the run method of thread rsets isfull to false on line since the bu er is no longer full after its maxsize has been increased.
finally although the notify in the get method is not executed in the call to bf.get by thread cin the observed execution the run method of thread cin the trace program records that the notify would have been executed had isfull been true.
thus the trace program captures all synchronization events in the observed execution any writes in that execution that change the value of any annotated predicate associated with a condition variable as well as any annotated wait s and notify s that did not occur in that execution but could have occurred in a di erent execution.
all other operations in the observed execution of the original program are not deemed relevant to nding deadlocks.
there exists an interleaving of the threads in this trace program that corresponds to the interleaving in figure that exhibits the deadlock.
in this interleaving of the trace program pexecutes its run method till the wait on line where it gets blocked.
then rcompletely executes its run method and exits.
thereafter cexecutes its run method but does not notify pbecause isfull is false.
thus pblocks forever waiting to be noti ed by c. our analysis uses an o the shelf model checker to explore all possible interleavings of the trace program and check if any of them deadlocks.
in the process of model checking it encounters this interleaving and thus nds the deadlock in the original program.
.
algorithm in this section we present our deadlock detection algorithm.
we rst describe the annotations our algorithm requires section .
.
we then formalize the execution of a concurrent system that includes the operations that our al gorithm deems relevant to nding deadlocks section .
and use that formalization to describe our trace program generation algorithm section .
.
we then discuss how to model check the trace program to report possible deadlocks in the original program section .
.
.
condition annotations 1public abstract class conditionannotation 2protected static int counter 3protected object o 4protected int condid 5protected boolean curval 6public conditionannotation object o1 o o1 condid counter associatewithobject o1 initcond public abstract boolean isconditiontrue public void waitbegin object lock int lockid getuniqueobjid lock boolean val isconditiontrue addline if c condid f i f !
val addline synchronized l lockid fl lockid .wait g public void waitend addline g public void notifybegin object lock int lockid getuniqueobjid lock boolean val isconditiontrue addline if c condid f i f !
val addline synchronized l lockid fl lockid .notify g public void notifyend addline g public void logchange boolean newval isconditiontrue i f newval !
curval addline c condid newval curval newval private void associatewithobject object o .
.
.
associate this instance of conditionannotation with the object o ... private void initcond curval isconditiontrue addline c condid curval figure de nition of class conditionannotation .
our algorithm requires users to annotate the predicate associated with each condition variable in a java program using class conditionannotation figure .
for brevity we do not show the synchronization required to make conditionannotation thread safe.
we describe here how programmers use conditionannotation to annotate their programs section .
shows how our algorithm uses these annotations to generate the trace program.
for each predicate associated with a given condition variable the user subclasses conditionannotation implementing its abstract method isconditiontrue .
this method must evaluate to true if and only if the predicate evaluates to true.
this predicate will depend on one or more java objects1public class addlinestotraceprogram 2public map thrtolines new treemap 3public int getuniqueobjid object o .
.
.
return unique integer id for object o ... 6public void addline string line ...append line to list mapped to current thread in thrtolines ... figure de nition of class addlinestotraceprogram used by class conditionannotation and algorithm .
or static elds.
for simplicity we describe here only the case where the predicate depends on a single object o but our implementation handles the more general case.
the object ois passed to the conditionannotation constructor and accessed by the isconditiontrue implementation.
finally the user calls pre de ned methods waitbegin waitend notifybegin and notifyend on the created instance of conditionannotation before and after any calls to wait notify and notifyall that are control dependent on the predicate.
figure shows the annotations required for the bu erfull predicate.
the underlined eld condition de ned on lines speci es the actual predicate line simply a call to method isfull of class mybuffer and the object on which it depends line the mybuffer instance .
on lines and it speci es the predicate dependent calls towait and notify .
.
concurrent system in this section we formalize the execution of a concurrent system in terms of the operations that our algorithm deems relevant to nding deadlocks.
it is straightforward to express the synchronization logic of a multi threaded java program in this system.
a concurrent system consists of a nite number of threads that communicate with each other using shared objects.
at any instant the system is in a state s in which each thread is at a statement.
it transitions from one state to another with the execution of a statement by a thread.
the initial state is denoted by s0.
we assume that locks are acquired and released by each thread in a nested manner that is if a thread acquires l1before l2then it releases l2before l1.
this is true for java programs.
our algorithm can be extended to settings with arbitrary locking patterns.
we also assume that each thread tis started only once.
a statement may be of one of the following forms we use current thread to denote the thread executing the statement .acquire l the current thread acquires lock l. .release the current thread releases the lock it last acquired.
.wait l the current thread is waiting on the condition variable monitor l. .notify l the current thread noti es a thread if any waiting on the condition variable l. .notifyall l the current thread noti es all threads waiting on the condition variable l. .start t the current thread starts a fresh thread t that is a thread that has not yet been started.
.join t the current thread is waiting for thread tto nish executing.algorithm traceprogramgenerator s0 s s0 while enabled s do t a random thread in enabled s stmt next statement to be executed by t s execute s t ifstmt acquire l then lid getuniqueobjid l addline synchronized l lid f else if stmt release then addline g else if stmt wait l then lid getuniqueobjid l addline l lid .wait else if stmt notify l then lid getuniqueobjid l addline l lid .notify else if stmt notifyall l then lid getuniqueobjid l addline l lid .notifyall else if stmt start t then tid getuniqueobjid t addline t tid .start else if stmt join t then tid getuniqueobjid t addline t tid .join else if stmt write o jjstmt call o then foreach conditionannotation cassociated with odo c.logchange end for end if end while ifactive s then print system stall!
endif createtraceprogram addlinestotraceprogram.thrtolines .write o the current thread writes to some eld of object o.
.call o the current thread invokes a method on objecto.
we also use the following de nitions in our algorithm .enabled s denotes the set of all threads that are enabled in state s. a thread is disabled in the following situations i it is waiting to acquire a lock currently held by another thread ii it is waiting to be notied by another thread or iii it is waiting for another thread to nish executing.
.active s denotes the set of all threads that have not nished executing in state s. .execute s t denotes the next state resulting from the execution of thread t s next statement in state s. .
generating the trace program the rst stage of checkmate algorithm generates a trace program by observing an execution of a program with synchronization predicate annotations.
it populates global map thrtolines in class addlinestotraceprogram figure while observing the execution.
map thrtolines maps each thread in the observed execution to a list of strings.
each string is a statement or a part of a statement and the whole list is a legal block of statements that constitutes the body of the corresponding thread in the trace program.
whenever a synchronization statement is executed by a thread in the observed execution the algorithm calls method addline in class addlinestotraceprogram to add the string it generates to the list mapped to that thread inalgorithm createtraceprogram thrtolines lockids set of lock identi ers in thrtolines predids set of synchronization predicate identi ers in thrtolines thrids set of thread identi ers in thrtolines print public class traceprogram f for all lidsuch that lidis in lockids do print static object l lid new object end for for all pidsuch that pidis in predids do print static boolean p pid end for for all tidsuch that tidis in thrids do print static thread t tid new thread f print public void run f for all ssuch that sis in thrtolines do print s end for print g g end for print public static void main string args f for all tid tid .start not in any list in thrtolines do print tid .start end for print g g thrtolines .
the generated string depends on the kind of synchronization statement that was executed.
if a lock acquire statement is executed the algorithm begins a synchronized statement for the involved lock object.
the lock object is uniquely identi ed in the trace program using method getuniqueobjid in class addlinestotraceprogram which provides a unique integer for each object created in the observed execution.
if a lock release statement is executed the algorithm closes the last synchronized statement that it had started for the thread.
we had earlier stated our assumption that locks are acquired and released in a nested fashion.
thus a lock release statement always releases the lock that was most recently acquired by the thread.
if a wait statement is executed the algorithm generates a corresponding wait statement.
similarly when a notify notifyall start or join statement is executed a corresponding statement is generated.
if a statement writing to some eld of object ois executed or a method is called on an object o then the algorithm nds all conditionannotation objects that are associated with object o this association is setup in the conditionannotation constructor .
after the write or the method call the state of omay have changed and hence the predicates associated with those conditionannotation objects may have also changed.
the trace program needs to track changes to the values of predicates associated with condition variables.
for this purpose the algorithm calls method logchange in class conditionannotation to evaluate the predicate and check if its value has indeed changed and if so generates a statement writing the new value to the variable associated with the predicate.
when calls to the pre de ned methods waitbegin waitend notifybegin and notifyend figure that have been added as annotations execute statements are generated for the trace program that capture the controldependence of the execution of the wait ornotify ornotifyall on the synchronization predicate that has been annotated.
these statements are also added using themethod addline in class addlinestotraceprogram .
we useifstatements to capture the control dependence with better annotations or program analysis we can use while statements wherever appropriate to state the control dependence.
after observing the complete execution the algorithm creates a legal java program trace program by calling method createtraceprogram de ned in algorithm .
it creates an object for each lock object a boolean variable for each predicate and a thread object for each thread in the observed execution.
for each created thread it prints a run method containing the list of strings generated for the corresponding thread in map thrtolines .
finally the algorithm prints the main method and starts all those threads in it which are not started by any other thread2.
the trace program for the example in figure is shown in figure .
the algorithm does a couple of optimizations before it prints the body for each thread.
firstly it does not print anysynchronized statement that involves a lock that is local to the thread.
thread local locks cannot be involved in a deadlock and hence can be safely removed.
secondly for any sequence of statements that consists only of synchronized statements it does the following optimization.
it nds the di erent nestings of lock acquires within the sequence.
instead of printing all synchronized statements present in the sequence the algorithm prints one block of nested synchronized statements for each nesting of lock acquires.
this removes a lot of redundancy in synchronized statements because of loops in the original program.
.
model checking the trace program the second stage of our algorithm uses an o the shelf model checker to explore all possible thread interleavings of the trace program and check if any of them deadlocks.
a deadlock in the trace program may or may not imply a deadlock in the original program.
the counterexample provided by the model checker assists in determining whether a deadlock reported by our algorithm is real or false.
multiple counterexamples may denote the same deadlock.
we group together counterexamples in which the same set of statements either lock acquires or calls to wait is blocked and report each such group as a di erent possible deadlock.
to increase readability we map the statements in the counterexample back to the corresponding statements in the original non trace program.
the deadlock for the example in figure is shown in figure .
.
evaluation we have implemented our analysis in a prototype tool called checkmate for java programs.
given a java program we rst use the conditionannotation class figure to manually annotate the predicate associated with each condition variable in the program.
checkmate then uses jchord a program analysis framework for java to instrument lock acquires and releases calls to wait notify and notifyall calls to thread start and join and all writes to objects and method calls in the program.
it then executes the annotated instrumented program on given input data and generates the trace program.
finally it uses the jpf model checker to explore all possible executions of the trace program and report deadlocks.
2normally just the main thread.
.
experimental setup we applied checkmate to several java libraries and applications.
we ran all our experiments on a dual socket intel xeon 2ghz quad core server with 8gb ram.
the libraries include the apache log4j logging library log4j the apache commons pool object pooling library pool an implementation of the osgi framework felix the apache lucene text search library lucene a reliable multicast communication library jgroups the jdk logging library java.util.logging the apache commons dbcp database connection pooling library dbcp and the jdk swing library javax.swing .
we used two di erent versions of jgroups .
we wrote test harnesses exercising each library s api including two di erent harnesses for each of pool and lucene and a single harness for each of the remaining libraries.
the applications include groovy a java implementation of a dynamic language that targets java bytecode groovy jruby a java implementation of the ruby programming language jruby and a java web server from w3c jigsaw .
for jigsaw we wrote a harness to concurrently send multiple requests and administrative commands like shutdown server to the web server to simulate a concurrent environment.
.
results table summarizes our experimental results.
the second column reports the number of conditionannotation s we had to provide each annotating a di erent synchronization predicate in the benchmark.
we report the number of conditionannotation s that we had to de ne and not the total number of lines of code that we had to use to de ne theconditionannotation s and to invoke methods on those conditionannotation s. the numbers in this column show that the annotation burden of our approach is very small.
the third column shows the number of lines of java code in methods that were executed in the original program.
the fourth column shows the number of lines of java code in the trace program.
notice that the trace programs are much smaller than executed parts of original programs although the trace program unrolls all loops and inlines all methods executed in the original program.
the fth column gives the average runtime of the original program without any instrumentation.
we do not report the runtime for the jigsaw webserver because of its interactive nature.
the sixth column gives the average runtime of the original program with annotations and instrumentation it includes the time to generate the trace program.
comparing these two columns shows that the runtime overhead of checkmate is acceptable.
the seventh column gives the average runtime of jpf on the original program.
we could not run jpf on eight of these programs because it does not support some jdk libraries and has limited support for re ection.
for the remaining six programs jpf did not terminate within hour nor did it report any error traces.
the eighth column shows the average runtime of jpf on the trace programs.
it terminates within a few seconds on eleven of these programs.
it does not terminate within hour for jgroups .
.
andjigsaw .
.
but it reports a number of error traces in that time.
these benchmarks have a lot of threads for jgroups .
.
and for jigsaw2.
.
hence a huge number of thread interleavings whichprogram no.
of orig trace orig time jpf time jpf time no.
of poten con r known name cond prog prog prog to gen on orig on trace error tial med errors annots loc loc time prog prog prog traces errors errors groovy .
b1 .118s 1s 1h .3s log4j .
.
.116s 1s .7s pool .
.116s 1s 1h .3s harness pool .
.123s 1s 1h .6s harness felix .
.
.173s .8s lucene .
.
.230s 3s 1h 1s harness lucene .
.
.296s .6s 1h 20s harness jgroups .
.
.228s 4s .4s jigsaw .
.
1h jruby .
.0rc3 .1s .7s .9s jgroups .
.
.89s 21s 1h java logging .177s 2s 1h .7s jdk .
.
dbcp .
.
.74s .3s 12s java swing .96s .6s 105s jdk .
.
table experimental results makes model checking slow.
jpf crashes on the trace program for felix .
.
.
comparing the runtime of jpf on the original and trace programs shows that it is much more feasible to model check the trace programs.
the ninth column shows the number of error traces produced by jpf for the trace programs.
an error trace is an interleaving of threads that leads to a deadlock.
not each error trace leads to a di erent deadlock and thus the number of error traces is not an indication of the number of di erent deadlocks in the program.
hence checkmate groups together error traces in which the same set of statements either lock acquires or calls to wait is blocked and reports each such group as a potential deadlock.
the tenth column shows the number of these potential deadlocks reported by checkmate .
the eleventh column shows how many of these deadlocks we could manually con rm as real and the nal column shows the number of deadlocks that were previously known to us.
the rst number in each entry in the last three columns is the number of communication deadlocks including the deadlocks that involve both locks and condition variables.
the second number is the number of resource deadlocks.
in most of the benchmarks we were able to nd all previously known deadlocks.
since jpfcrashed on the trace program for felix .
.
we applied a randomized model checker i.e.
a model checker that tries out random thread schedules to it.
the randomized model checker reported a deadlock that was the same as it s previously known communication deadlock.
.
deadlocks found we found a number of previously known and unknown deadlocks in our experiments.
we discuss some of them in detail below.
our running example in figure documents the previously known communication deadlock we found in log4j that is reported at org bugzilla show bug.cgi?id .
figure shows a previously known deadlock in groovy reported at groovy .
it shows relevant code from memoryawarecon t2 synch writelock concurrentreads t1 synch writelock synch writequeue while concurrentreads !
writequeue .
wait t2 synch writelock concurrentreads synch writequeue writequeue .
notify figure deadlock in groovy .
currentreadmap.java .
this deadlock is a hybrid between a communication and resource deadlock.
thread t2increments eld concurrentreads of a memoryawareconcurrentreadmap object.
thread t1checks predicate concurrentreads !
.
since this predicate is true it executes the wait on line .
t1executes the wait onwritequeue but it also holds a lock on writelock .
thread t2is the only thread that can wake it up but before t2can reach the notify on line it needs to acquire the lock on writelock to decrement the value of concurrentreads .
since the lock on writelock is held by t1 it gets blocked.
thus t1 is waiting to be noti ed by t2 and t2is waiting for t1to release writelock .
we found a previously unknown communication deadlock injigsaw .
figure explains the deadlock.
the line numbers in the gure are of statements in resourcestoremanager.java in the benchmark.
thread t1is astoremanagersweeper thread that executes the wait on line after it has been started.
but before it can execute this wait the server receives a request to shut down.
thread t2 which is ahttpd server thread tries to shut down the storeman t1 t2 synch void shutdown notifyall boolean done false while !
done wait done true figure deadlock in jigsaw .
agersweeper thread and invokes notifyall at line during the process of shutting down.
this notifyall is the noti cation that is meant to wake t1up when it waits at the wait on line .
thus when t1actually executes thewait it just gets hung there.
it has already missed the noti cation that was supposed to wake it up.
two resource deadlocks in jigsaw were known previously .
we not only found those two deadlocks but we also found three other resource deadlocks in jigsaw .
they are similar to the two previously known deadlocks in that they also involve locks on socketclientfactory and socketclientstate objects but they di er in the source line numbers where the locks are acquired.
.
other related work there is little prior work on detecting communication deadlocks.
agarwal and stoller dynamically predict missed noti cation deadlocks in particular they de ne a happens before ordering between synchronization events and use it to reason if a wait that was woken up by a notify could have happened after that notify.
farchi et al describe several concurrency bug patterns that occur in practice including missed noti cation.
they also describe a heuristic that can increase the probability of manifesting a missed noti cation during testing.
hovemeyer and pugh present several common deadlock patterns in java programs that are checked by their static tool findbugs including many involving condition variables such as unconditional wait wait with more than one lock held etc.
their patterns cannot help to detect the deadlock in figure and missed noti cations in general.
von praun also statically detects waits that may execute with more than one lock held and waits that may be invoked on locks on which there is no invocation of a notify.
his approach too cannot detect the deadlock in figure and missed noti cations.
li et al build a deadlock monitor that runs as a system daemon and detects deadlocks that actually occur during the execution of systems with multiple processes or threads.
the monitor can detect deadlocks involving semaphores and pipes in addition to locks.
in checkmate we observe a deadlock free program execution and predict deadlocks that could occur in a di erent execution of the program.
.
conclusion and future work we have presented a novel dynamic analysis called checkmate that predicts a broad class of deadlocks.
like most predictive dynamic analyses checkmate is neither complete nor sound.
since it does not track all control and data dependencies observed during execution it can miss deadlocks as well as report false deadlocks.
one way to rectify that would be to use dynamic slicing to track not just the variables in synchronization predicates but also other variables that can a ect the values of variables in synchronization predicates.