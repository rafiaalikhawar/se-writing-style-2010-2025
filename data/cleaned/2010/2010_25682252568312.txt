conlock a constraint based approach to dynamic checking on deadlocks in multithreaded programs yan cai shangru wu w. k. chan department of computer science city university of hong kong hong kong china ycai.mail gmail.
com department of computer science city university of hong kong hong kong china shangru .wu my.
cityu.edu.hk department of computer science city university of hong kong hong kong china wkchan cityu.edu.hk abstract many predictive deadlock detection techniques analyze multithreaded programs to suggest potential deadlocks referred to as cycles or deadlock warnings .
nonetheless many of such cycles are false posit ives.
on checking these cycles existing dynamic deadlock confirmation techniques may frequently encounter thrashing or result in a low confirmation probability .
this paper present s a novel technique entitled conlock to address these pro blems.
conlock firstly analyzes a given cycle and the execution trace that produces the cycle .
it identifies a set of thread schedu ling constraints based on a novel should happen before relation .
conlock then manipulates a confirmation run with the aim to not violat e a reduced set of scheduling constraints and to trigger an occurrence of the deadlock if the cycle is a real deadlock.
if the cycle is a false positive conlock report s scheduling violation s. we have validated conlock using a suite of real world program s with deadlocks.
the result shows that among all cycles reported by magiclock conlock confirm s all deadlocks with a probabilit y of .
on the remaining cycles conlock reports scheduling violation s on each .
we have systematically sampled out of the cycles and confirmed that all the se cycles are false positives.
categories and subject descriptors d. .
software program verification reliability correctness proofs validation .
d. .
testing and debugging testing tools .
d. .
processing management concurrency deadlocks .
general terms reliability verification keywords deadlock confirmation should happen before relation.
.
introduction many multithreaded programs use various locking mechanisms to coordinate how their threads produce the program outputs .
improper sequence s of lock acquisition s and releases performed by these threads may result in concurrency bugs such as data races atomicity violation s or deadlock s .
a deadlock occurs when every thread in a thread set waits for acquir ing a lock that another thread in the same set is holding .
each occurrence of a deadlock stops the threads involved in it from making further progress.
deadlock is a critical failure .
once a deadlock has occurred in an execution trace it is not diff icult to report the occurrence and reproduce it .
in general deadlocks rarely occur in the program executions of real world programs but may reveal their presence s in some other execution traces .
to suggest potential deadlocks many static techniques e.g.
and dynamic techniques e.g.
have been proposed.
static techniques analyze the program code to infer the existence of cyclic lock acquisition i.e.
cycles among threads as potential deadlocks.
they generally suffer from repor ting many false positives.
for instance the experiment in reported more than potential cases when analyzing the java jdk and yet only of them could finally be confirmed as real deadlocks after applying v arious unsound heuristics .
dynamic predictive techniques also suffer from reporting false positives albeit less serious than the static counterparts .
tracking the happened before relations or constructing a segmentation graph on the corresponding execution trace may eliminate some kinds of false positive s but may also eliminate certain true positives due to different thread schedules which is risky .
confirming each given cycle to be a real deadlock or not by ex ecuting the program with respect to the cycle is desirable .
latest t echniques that can automatically confirm cycles as real deadlocks include deadlockfuzzer and magicscheduler .
a minor adaptation of pct is also an alternative.
however in section our experiment shows that they either are unable to confirm a real d eadlock at all or can only achieve a low confirm ation probability.
besides existing dynamic techniques such as have no strategy to handle cycles that are false positives .
to ease our presentation we refer to an execution used to suggest cycle s as a predictive run .
similarly we refer to an execution that is used to confirm whether a suggested cycle c is a real deadlock or not as a confirmation run .
we also suppose that cycle s have been suggested by a predictive technique on a predictive run.
in this paper we prop ose conlock a novel constraint based a pproach to dynamic confirmation of deadlocks and handling false positive s. conlock consists of two phases in phase i conlock analyzes the predictive run and generates a set of scheduling constraints with respect to the given cycle c. each constraint spe cifies the order of a pair of lock acquisition release events in a confirmation run between the corresponding pair of threads involved in the cycle c. in phase ii conlock manipulates a confirmation run with the attempt to not viola te the reduced set of constraints produced in phase i so as to trigger the deadlock if the cycle c is a real deadlock or else it reports a scheduling violation against the given set of constraints which indicat es that the cu rrent run is no longer meaningful to confirm the cycle c. in either case conlock terminates the current confirmation run.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india .
copyright acm ... .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
we have implemented a prototype of conlock to validate conlock on a suite of real world programs .
we compare d conlock with magic scheduler deadlockfuzzer and pct in terms of confirmation probability consistency in confirmation and the amount of time taken to check against all given cycles .
in the experiment conlock achieved a consistently higher probability in confirming all real deadlocks whereas other techniques either missed to confirm to cycles as real deadlocks in every confirmation run or only achieved a lo wer probability on remaining real deadlock cases .
we systematically sampled a subset cycles in total of the remaining cycles on which conlock reported scheduling violations for careful manual code inspection and confirm ed that they were all false positives .
the main contribution of this paper is threefold this paper propose s conlock a novel dynamic constraint based deadlock confirmation technique to isolating real dea dlocks from the given set of cycles with a high probability and a low slowdo wn overhead .
to the best of our knowledge conlock is the first technique that can terminate confirmation runs on false positive cycles by reporting scheduling violations .
we report an experiment which confirm s that conlock can be effective and efficient.
in the rest of this paper section revisits the preliminaries of this work .
section motivates our work by an example.
section present s the conlock algorithm.
section describes a validation experiment and reports the experimental results .
section reviews the closely related work .
section concludes this paper.
.
preliminaries .
.
events and trace s our model monitors a n execution trace over a set of critical oper ations acq rel performed on locks where acq represents lock acqui sition and rel represents lock release .
the extension to handle other synchronization primitives e.g.
barriers is straigh tforward .
definition .
an event e t op m s ls denotes that a thread t performs an operation op on a lock m which occurs at the site s and at the same time t is holding a set of locks called lockset ls each of which is associated with the site where t acquires the corresponding lock.
definiti on extends the definition of lock dependency in by including lock release rel in .
a site is an execution context e.g.
the triple call stack statement number the latest occurrence count of the couple call stack statement number can be used to denote an execution context .
an execution trace of a program p is a sequence of events and t is the projection of a trace on a thread t of the same trace .
.
.
cycle as potential deadlock definition .
a sequence of k events denoted by c e1 e2 ... ek where ei ti acq mi si lsi for i k is called a cycle if both of the following two conditions are satisfied for i k mi lsi and mk ls1 and for i j k ti tj mi mj mi lsi and lsi lsj .
a cycle models a potential deadlock the site si in the event ei involved in a cycle c is referred to as a deadlocking site of the thread ti.
the lock mi of an event ei is the lock that the thread ti waits to acquire.
for instance figure b to be described in section depicts that a thread t1 is holding the lockset a p m and is waiting to acquire the lock n at site s08 and a thread t2 is holding the lockset n and is waiting to acquire the lock p at site s16.
the four boxed operations represent a deadlock bug that has not been triggered in the scenario and this deadlock can be modeled as a cycle c0 t1 acq n s08 a s03 p s06 m s07 t2 acq p s16 n s15 .
we denote the set mi ei ti acq mi si lsi ei c by wlockc.
it means that each lock in wlockc is a lock waiting to be acquired by a thread involved in the cycle c at its deadlocking site.
simila rly we denote the set of all locks each of which is being held by a thread involved in c at the deadlocking site by the set hlockc i.e.
hlockc nj ei ti acq mi si lsi ei c nj sj lsi for some site sj .
moreover t he site to acquire a lock m wlockc n hlockc respectively is denoted by wsitec m hsitec n respectively .
for the above cycle c0 in figure b we have wlockc0 n p wsitec0 n s08 wsitec0 p s16 hlockc0 n p a m hsitec0 n s15 hsitec0 p s06 hsitec0 a s03 and hsitec0 m s07.
.
motivating example figure a shows a bug that can be triggered by using two threads operating on four locks .
the operations acq x and rel x in the figure depict a lock acquisition event and a lock release event on the lock x respectively.
the program in figure a illustrates a deadlock bug as shown by the four boxed operations .
execution depicted in figure a passes through the path s13 s14 s01 s02 s03 s04 s05 s06 s07 s15 resulting in a deadlock occu rrence specifically t he thread t2 firstly acquires the lock a at the site s13 and then releases the lock a at the site s14.
when the thread t2 is about to acquire the lock n at the site s15 the thread t2 is suspended.
then the thread t1 execute s the operations at sites s01 to s07 to acquire three locks a p and m at the sites s03 s06 and s07 respectively.
when t1 is about to acquire the lock n at the site s08 it is suspended and the thread t2 is resumed to successfully a cquire the lock n at the site s15.
then the thread t2 is suspended when it is about to acquire the lock p at the site s16 because the lock p is being held by t1 at this moment.
as such the thread t1 resumes its execution.
nonetheless the thread t1 has to wait for the thread t2 to release the lock n so that the thread t1 can acquire this lock n. the two threads now mutually wait for each other to release their waiting locks.
the execution triggers a deadlock.
execution depicted in figure b passes through the path s13 s14 s15 s16 s17 s18 s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 failing to trigger any deadlock suppose that the thread t2 has acquired the lock n at the site s15 which is different from the execution and is about to acquire the lock p at the site s16.
at this moment the thread t2 is suspended and the thread t1 is resumed.
however the thread t1 cannot successfully acquire the lock n at the site s01 because the thread t2 is holding the lock n. hence t1 is suspended.
the thread t2 is then resumed and acquires the lock p. it finally releases the two locks p and n at the s ites s17 and s18 respectively .
next the thread t1 is resumed and completes its remaining execution .
no deadlock has been triggered .
existing dynamic predictive techniques e.g.
may analyze execution to suggest the cycle c0 t1 acq n s08 a s03 p s06 m s07 t2 acq p s16 n s15 .
however without confirm ing the cycle c0 this cycle c0 is unknown to be a 492real deadlock or just a false positive.
manually confirming every such cycle can be tedious and error prone.
the latest state of the art techniques on automatic confirmation of cycles as real deadlocks include deadlockfuzzer and magicscheduler .
pct is not designed for deadlock confirm ation but it provides a probabilistic guarantee to detect real dea dlocks if they exist.
we review them to motivate our work.
magicscheduler ms ms is the latest dynamic deadlock confirmation technique.
it uses a heuristic to random ly schedule each individual thread in a given program against a set of given cycles and suspend a threa d if the thread holds a set of locks and requests another lock at the deadlocking site of this thread specified by a given cycle .
consider the example in figure b .
ms aims to suspend the thread t1 when t1 is right before executing the operation at the site s08 and suspend the thread t2 when t2 is right before executing the operation at the site s16.
directly applying the above heuristic can be challenging to sche dule the two threads in a confirmation run to trigger a real dea dlock.
suppose that ms firstly suspend s the thread t2 right before executing the operation at the site s16 after the thread t2 has a cquired the lock n at the site s15 .
to trigger the deadlock with r espect to the cycle c0 ms aims to wait for the thread t1 to be su spended at the site s08.
this target is nonetheless impossible to achieve because the thread t1 has been blocked at the site s01 or the site s04 as the lock n is being held by t2 and yet t2 has been suspended .
this kind of problem is known as thrashing .
to resolve this occurrence of thrashing ms resume s the thread t2 which runs to complete the execution of the operation s up to the site s18 and release s the lock n. nonetheless the deadlocking site s16 for t2 has been passed .
so the cycle c0 could not be confirmed.
execution starts with the thread t2 at the site s13.
on execution according to the scheduling strategy of ms ms always results in thrashing and fails to trigger the cycle c0 as a real deadlock.
an execution scenario that starts with the thread t1 would still result in thrashing caused by ms. for instance suppose that ms has successfully suspended the thread t1 at the site s08 before acqui ring the lock n and then the thread t2 starts.
the thread t2 cannot acquire the lock a at s13 because t1 is still holding the lock a. as a result thrashing occurs.
ms resumes t1 to acquire the lock n. as such no deadlock could be trigger ed.
this also illustrates that merely applies the active thread schedul ing at the sites s08 and s16 is unlikely to trigger the deadlock bug with a high probability.
deadlockfuzzer df uses a heuristic strategy that is identical to ms except that df tries to confirm one cycle per run instead of a set of cycle s per run.
the running example has only one cycle .
df suffers from the same problem experienced by ms. probabilistic scheduler pct probabilistically generates a sequence of priority changing points.
from the probabilistic the ory pct can generate a thread schedule e.g.
execution in figure a that results in triggering a deadlock occurrence .
accor ding to its guaranteed probability is n k d for a concu rrency bug of depth d involving n threads that execut es a total of k steps .
for the running example the guaranteed probability is or .
which is low despite that pct can detect the deadlock bug without needing any predictive run or any information about a given cycle.
in the next section we present conlock and illustrate how conlock confirm s the cycle c0 in figure .
.
conlock .
.
overview conlock is a novel constraint based dynamic approach to deadlock checking .
it consists of two phases with respect to a given cycle as depicted in figure .
a predictive technique firstly suggests a cycle c as depicted in figure a .
conlock then starts its two phases.
in phase i given a cycle from a predictive run conlock generates a set of constraints as depicted in figure b .
the generation of the constraint set is based on the novel should happen before relation proposed in section .
.
.
in phase ii conlock actively schedules a confirmation run with respect to a subset of constraint s and produces two important consequences if the given cycle is a real deadlock as depicted in figure c conlock tries to confirm it .
as shown in our e xperiment its confirmation probability is high if the given cycle is a false positive as depicted in figure d conlock reports a scheduling violation.
the two consequences significan tly distingui sh conlock from the existing techniques .
.
.
phase i generation of constraint set and scheduling points to schedule a confirmation run that successfully confirms a given cycle as a real deadlock each thread involved in a cycle should be precisely suspended at its deadlock ing site.
many e xisting dyna mic active testi ng techniques have used this insight to extract information from a predictive run to guide the manipulation of a confirmation run.
moreover we observe that at the same time a confirmation technique shoul d avoid occurrences of thrashing as much as possible.
hence our goal is that each thread involved in a cycle should not be artificially blocked by any other thread i nvolved in the same cycle before the former thread is about to a cquire the lock at its deadlocking site as much as possible.
based on the above two observations we formulate a novel rel ation entitled the should happen before relation to effectively prevent occurrence of thrashing and precisely suspend each thread involved in a cycle at its deadlocking site.
we note that the thread t1 thread t2 s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12acq n rel n acq a acq n rel n acq p acq m acq n rel a rel p rel m rel n s13 s14 s15 s16 s17 s18acq a rel a acq n acq p rel p rel n thread t1 thread t2 s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12acq n rel n acq a acq n rel n acq p acq m acq n rel a rel p rel m rel n s13 s14 s15 s16 s17 s18acq a rel a acq n acq p rel p rel n waiting to acquire the lock deadlocking site.
actual case in a and predictive case in b thread execution interleaving among threads a execution scenario with deadlock b execution scenario without deadlock i the execution order figure .
example deadlock adapted from jdbc connector .
bug id .
the acronym n a p and m are connection statement serverpreparedstatement and connection.mutex respectively.
493should happen before relation is a relation between two events in the execution trace of a predictive run where the run itself has no deadlock occurrence .
it denotes that the two related events should occur in a specified order in the confirmation run .
.
.
should happen before relation we firstly revisit the happened before relation .
we use to denote the happened before relation between two events .
in our problem context t he happened before relation describes a relation between two events over the given execution trace of the predictive run .
the happened before relation is defined as follows i program order if two events e1 and e2 are performed by the same thread and e1 appeared before e2 in the execution trace then e1 e2.
ii lock a cquire and release if er is a lock release on a lock m by a thread t1 ea is a lock a cquisition on the same lock m by a thread t2 where t1 t2 and er appears prior to ea in the execution trace then er ea.
iii trans itivity if e1 e2 and e2 e3 then e1 e3.
we proceed to present the de finition of should happen before relation.
we use to represent this relation over two events.
to ease our subsequent presentation sometimes we refer to the event ei by the thread ti involved in the cycle c as c ti and use the site of an event e to denote e when describing the and relations.
definition .
given an execution trace a cycle c on suppose that t t and t are threads involved in the cycle c where t t and t t the should happen before relation is defined as rule suppose that e and e are two events performed by two threads t and t respectively and they both operate on the same lock m. if the three conditions m wlockc e c t and e c t are satisfied then e e .
rule suppose that e and e are two events performed by two threads t and t respectively and they both operate on the same lock n. if the three conditions n hlockc e c t and e t acq n hsitec n ls for some ls are sati sfied then e e .
note that e c t and e c t .
rule def ines a condition to prevent predictable thrashing to occur on these locks in the set wlockc.
figure a uses execution to illustrate this rule via the lock p and the cycle c0.
in figure a the lock p is in wlockc0 the site s16 is the deadlocking site for the thread t2 i.e.
t in the rule that operates on this lock p and the deadlocking site for the thread t1 i.e.
the thread t in rule is the site s08.
rule specifies that any lock acquisition or release event on this lock p performed by the thread t1 e.g.
the event e at the site s06 that happened before the event c0 t1 at the site s08 should happen before the event i.e.
e performed by the thread t2 at its deadlocking site s16.
thus by rule we get s06 s16.
similarly rule defines a condition that prevents predictable thrashing on these locks in the set hlockc.
figure b uses exec ution to illustrate this rule via the lock n. in figure b the lock n is in hlockc0 and the thread t2 i.e.
the thread t in rule holds a lockset n s15 when t2 is about to acquire the lock p at its deadlocking site s16.
we also recall that the deadlocking site for the thread t1 i.e.
the thread t in rule is the site s08.
rule specifies that any lock acquisition or release event on n performed by t1 that happened before the event occurred at its deadlocking site s08 should happen before the lock acquisition event on n at site s15 i.e.
the event e .
thus by rule we get s05 s15.
the lock n has also been acquired or released by the thread t1 at sites s01 s02 and s04.
so we get s01 s15 s02 s15 and s04 s15 accordingly .
the whole set of should happen before relations in the running examples we now apply rule and rule to identify a complete set of should happen before relations with respect to the cycle c0.
we recall that execution in figure b operates on four locks n a p m .
the cycle c0 has two deadlocking sites s08 of the thread t1 and s16 for the thread t2.
wlockc0 is n p and hlockc0 is n a p m .
the lock m is only acquired once .
there is no should happen before relation on it because the should happen before relation is defined over two events performed by different threads .
consider the lock n. we have applied rule on it to have ident ified s01 s15 s02 s15 s04 s15 and s05 s15 in the above illustration of rule .
the thread t1 performs the event on the lock n at its deadlocking site s08 which is also denoted by c0 t1 .
for the thread t2 there is only one event e t2 acq n s15 operating on the lock n and e c0 t2 .
by rule we get s15 s08.
consider the lock p. we have applied rule on this lock to have identified s06 s16.
we recall that hsitec p is the site s06 but there is no event operating on the lock p by the thread t2 that happened before the event c0 t2 at the site s16.
thus rule produces no further should happen before relation for the lock p. a a predictive run suggests a cycle c c deadlock confirmed b the s et of constraints?
..................t1 t2 t1 t2 t1 t2conlock existing work d scheduling violation reported ......t1 t2 or predictive phase phase i phase ii figure .
an o verview of conlock .
t1ast t2 ast s01 s02 s03 s04 s05 s06 s07 s08acq n rel n acq a acq n rel n acq p acq m acq n s13 s14 s15 s16acq a rel a acq n acq p t1ast t2 ast s01 s02 s03 s04 s05 s06 s07 s08acq n rel n acq a acq n rel n acq p acq m acq n s13 s14 s15 s16acq a rel a acq n acq p a rule 1on the lock p s06 s16 b rule on the lock n s05 s15e e e e happened before should happen before deadlocking site c0 t1 c0 t1 figure .
examples of rule and rule on execution .
494consider the lock a. rule gives no should happen before rel ation on this lock because the lock a is not in wlockc0.
in the cycle c0 the lock a is in a lockset of an event for thread t1.
by rule any lock acquisition or release event on the lock a that happened before c0 t2 should happen before the lock acquisition event on a performed by the thread t1 at the site s03.
as for the thread t2 s13 c0 t2 and s14 c0 t2 we get s13 s03 and s14 s03.
in total based on execution and the cycle c0 we identify a set of eight should happen before relations s01 s15 s02 s15 s04 s15 s05 s15 s06 s16 s13 s03 s14 s03 s15 s08 .
they are depicted as dotted arrows in figure a .
execution fails to trigger the deadlock and its execution path is s13 s14 s15 s16 s17 s18 s01 s02 s03 s04 s05 s06 s07 s08 s09 s10 s11 s12 .
this path violates out of these eight should happen before relations each has been highlighted in the last paragraph .
in fact any other execution path violating at least one of these eight should happen before relations miss es to trigger the deadlock.
execution triggers a d eadlock occurrence and its execution path is s13 s14 s01 s02 s03 s04 s05 s06 s07 s15 before deadlocking at the site s08 for the thread t1 and the site s16 for the thread t2.
we observe that this execution path satisfies all eight should happen before relations.
in section we have illustrated an occurrence of thrashing suffered by both ms and df.
this thrashing occurrence is due to the thread t2 having acquired the lock n at the site s15 before the thread t1 attempts to acquire the same lock at the site s01 and yet the thread t2 is actively suspended by the technique e.g.
ms at the site s16.
the above set of should happen before relation s has pointed out that the execution under active scheduling has already violated the relation s01 s15 irrespective to whether or not the technique suspends t2 at s16.
conlock can identify all such should happen before relat ions before scheduling a confir mation run.
as such it has the ability to guide a thread scheduler to avoid occurrence of thrashing .
.
.
generat ion of should happen before relation s conlock treats each identified should happen before relation as a scheduling constraint in a confirmation run .
algorithm shows the constraint set generat ion algorithm generator for short .
given an execution trace and a cycle c algorithm firstly identifies all the locks in wlockc and hlockc and all threads in c as threads c lines .
then it checks each event in the projection t of the trace over each thread t in the reversed program order starting from the deadlocking site of the thread t lines with respect to the two rules lines .
the set threads c at line keeps all the threads involved in the cycle c computed at line .
for each event e t op l s ls from t the algorithm checks whether the lock l is in the set wlockc line .
if this is the case the algorithm further checks e against e to determine whether the pair of events e and e forms a should happen before relation based on rule lines .
if this is the case it adds the relation e e into the set line .
next the algorithm checks whether the lock l is in the set hlockc line .
if this is the case it checks whether or not there is an event e operating on the lock l such that l s of the event e is in the lockset ls of c t lines which indicates the site s is hsitec l .
if there is such an event e the algorithm adds the rel ation e e into line based on rule .
conlock can schedule a confirmation run with the aim of not vi olating any constraint thus produced .
however if the size of the set constraint is large scheduling a program execution against such a large set of constraints from the beginning may incur a high runtime overhea d. in the following two subsections we present a precise constraint reduction algorithm and an optimization by selecting a nearest scheduling point for each thread .
.
.
reduction of constraint s we first give two properties of the should happen before relation property transitivity if the constraint set has included both e1 e2 and e2 e3 then needs not to include e1 e3 because the event order specified by e1 e3 has been impli citly and jointly specified by the relations e1 e2 and e2 e3.
property program locking order if the constraint set has included ea ex and er ex such that ea is the corr esponding lock acquisition event of er performed by the same thread t then needs not to include ea ex because ea ex is enforced by the program order of the thread t and er ex.
applying both properties produces a smaller but equivalent set of constraints generated by algorithm .
the reduction algorithm is straightforward recursively applying the two properties on every triple of constraints until no more constraint can be reduced .
for the running example applying these two properties on the constraint set produced by algorithm removes the following four constraints from the original constraint set s01 s15 s02 s15 s04 s15 s13 s03 see figure b .
.
.
identifying scheduling point s lu et al.
empirically conclude that a concu rrency bug in real world large scale multithreaded programs usually needs a short algorithm generator input an execution trace input c a cycle output a constraint set with respect to c on wlockc hlockc for each event t req m s ls in c do wlockc wlockc m threads c threads c t for each n sn ls hlockc hlockc n end for end for for each t threads c do let i p such that t c t while i do let t be e t op l s ls e c t op acq rel if l wlock then by rule for each e t acq m s ls c t t t do if l m then m wlockc e e end if end for end if if l hlockc then by rule let e t acq l s ls where t t let c t t acq m s ls the deadlocking site of t if l s ls then thus we have s hsitec l e e end if end if end while end for 495depth to manifest itself in an execution .
in other words it is e mpirically enough to explicitly schedule only part s of an execution to manifest a deadlock .
this indicat es the existence of a set of points events from which conlock can start to schedule the involved threads.
such a point may be the beginning of each thread in the worst case .
we refer to such a point as a scheduling point .
a scheduling point should happen before the deadlocking site of the same thread .
besides the lockset held by a thread at such a point must be empty otherwise suspending a thread at its sche duling point may prevent other threads to acquire locks at their corresponding scheduling points which is akin to the occurren ces of thrashing .
in general a threa d may have one or more scheduling points.
conlock select s the scheduling point nearest to the deadlocking site of the same thread.
we formulate a schedu ling point as an event and denote all scheduling points and the nearest one of a thread t in as sp t and nsp t respectively.
figure c shows four scheduling points two for the thread t1 and two for the thread t2 denoted by the horizontal arrows .
the algorithm to select the nearest scheduling point for each thread t i.e.
nsp t can be revised from algorithm by inserting the following four lines z1 z4 to the position in between line and line in algorithm .
for brevity and owing to its simplic ity we do not show th e whole revised algorithm here .
z1 z2 z3 z4 if ls then nsp t e break while end if for the running example figure d shows an execution schedule fragment that starts from the nearest scheduling point of each thread and satisfies the constraints in figure c .
in the confirm ation run for the program in figure conlock is able to confirm the cycle c0 predicated from execution figure b as a real deadlock with a certainty and produces no thrashing occurrence.
.
.
phase i i conlock scheduler .
.
confirmation algorithm conlock accepts a program p a cycle c a set of nearest schedu ling point s nsp one for each thread in c and a set of constraints as inputs.
it firstly executes the program using randomized sche duling and monitors the events until any thread say t involved in c reaches i.e.
is the same as its scheduling point.
then conlock suspends t without executing the event and waits for other threads involved in c to reach their corresponding nearest schedu ling points.
next conlock schedule s all subsequent event s with the aim of not violat ing the reduced constraints set and checks for deadlock occurrence.
it stops the current confirmation run immediately whenever it detects a scheduling violat ion.
we proceed to present a few auxiliary concepts before presenting the scheduling algorithm of conlock .
state of a constraint .
given a constraint h ea eb the state of the constraint h denoted as state h is one of the following s idle if both ea and eb are not executed .
active if eb is about to be executed and ea is not executed .
used if ea is executed .
state of a thread .
given a thread t the state of the thread t denoted as state t is one of the following s enabled if t can be scheduled to execute its next event .
waiting if t is waiting on a constraint .
note if t is about to execute an event e but there is a constraint say h e e on which e has not been executed.
to avoid violating the constraint h conlock suspend s the thread t until the event e has been executed.
in such cases we say that the thread t is waiting on the constraint h and is in the waiting state.
suspended if t is suspended by conlock .
disabled if t has terminated or suspended by os .
definition .
a scheduling violation occurs in a confirmation run with respect to a cycle c if the two conditions below are satisfied t threads c such that state t enabled and t threads c such that state t waiting .
a schedul ing viol ation means that no any thread in threads c is in the enabled state and each thread in threads c is either disabled or waiting on a constraint .
each waiting thread t waits on a constraint say e e to be fulfilled i.e.
the event e from a different thread i.e.
t should be executed before the execution of the event e by t .
because there is no thread in the enabled state no any event can be further executed .
to continue the whole execution at least one constraint will be violated in the current scheduling or else a deadlo ck has been triggered .
because a constraint has been violat ed the current confirmation run is no longer meaningful to be further scheduled not to violate other constraints in view of triggering the deadlock with respect to the given cycle.
hence we can terminate the confirmation run .
algorithm presents the confirmation scheduler of conlock .
it takes a program p a cycle c a set of constraints and a set of nearest scheduling points nsp one for each thread involved in c t1 t2 s01 s02 s03 s04 s05 s06 s07 s08 s13 s14 s15 s16t1 t2 s01 s02 s03 s04 s05 s06 s07 s08 s13 s14 s15 s16t1 t2 s03 s04 s05 s06 s07 s08 s15 s16t1 t2 s01 s02 s03 s04 s05 s06 s07 s08 s13 s14 s15 s16 a the original set of should happen before relations b the reduced set of should happen before relations c scheduling points and the set of should happen before relation after the nearest scheduling points d a confirmation run that does not violate the should happen before relations shown in c sp t1 nsp t1 nsp t2 nsp t1 nsp t2 sp t2 figure .
reduction of constraints and selection of nearest scheduling points with respect to the cycle c0 and execution 496as inputs.
the schedu ler firstly initializes the state of each constraint as idle line .
it also updates the state of each thread as enabled lines .
then it uses os scheduling to execute the operation of a randomly selected instruction lines .
if a thread t is about to execute an event that is the nearest scheduling point of the same thread the scheduler suspends t moves t from enabledset into suspended set and sets state t suspended lines .
otherwise the instruction is executed line .
after all these threads reach their corresponding nearest schedu ling points by checking whether threads c suspended set line conlock enables all these threads lines and .
in order to check for the occurrence of a real deadlock conlock maintain s some necessary data for each thread .
these data are three maps from a thread t to a lockset as ls t from t to its requested lock as req t and from t to its requested site as site t which are all initialized to be empty line .
next conlock starts its guided scheduling lines .
it randomly fetches the next event e from a random and enabled thread line .
before executing the event e conlock checks e against each constraint in that is not in the used state and determines the state s of both the selected constraint and the cu rrent thread t lines such that no constraint is violated .
there are three cases to consider if there is any constraint h ea eb such that state h idle and the current event e eb the execution of event e will be postponed until ea has been executed .
conlock sets state h active and state t waiting on h lines .
it then checks whether any scheduling violation occurs and reports the violation if any lines .
if there is a ny constraint h ea eb and state h active such that the current event e ea conlock sets state h used and updates the state of every thread say t that is waiting on h to be enabled lines .
at line we use notify h to indicate the change of the state of each thread say t waiting on this constraint h from waiting to enabled.
if there is a ny constraint h ea eb and state h idle such that the current event e ea conlock sets state h used lines .
next conlock checks the type of the event e and perform s a corresponding action.
if e is a lock acquisition conlock updates the three maps req site and ls and call s the function checkdeadlock lines .
if e is a lock release conlock updates the map ls only line .
for any other event conlock directly executes the event .
algorithm then handles the next instruction.
if the function checkdeadlock lines finds any cycle according to definition conlock reports the occurrence of a real deadlock and terminates the confirmation run .
.
.
discussion s conlock can report both real deadlock occurrences and scheduling violations.
this feature makes conlock significantly different from existing active randomized schedulers.
take confirming a cycle on the mysql database server as an e xample.
mysql is a server program that accept s a query and return s a dataset .
however after serving this query the program will wait for the next input instead of program termination.
as such there is always at least one active thread once mysql has been started.
existing schedulers e.g.
magicsch eduler and deadlockfuzzer will not terminate the confirmation run by their algorithmic design .
we also recall from the motivating example that once an occu rrence of thrashing happens they will activate a previously su spended thread.
because the deadlocking site for the previously suspende d thread has been passed in the run the given cycle could no longer be confirmed.
algorithm conlock scheduler input p a program input c a cycle input a set of constraints input nsp the nearest scheduling point s for each h state h idle for each thread t in p state t enabled enabledset all threads in p suspendedset while enabledset threads c suspendedset do e the next event from a thread t if e nsp t then suspendedset suspendedset t state t suspended .
enabledset enabledset t .
else execute e end if end while enabledset enabledset suspendedset resume all threads suspendedset for each thread t do state t enabled ls t req t site t end for while t threads c state t enabled do let e t op m s ls be the next event of the thread t check e against each constraint in if h ea eb eb e state h idle then state h active state t waiting on h if a scheduling violation occurs by definition then print a scheduling violation occurs.
halt early termination of confirmation run end if continue else if h ea eb ea e state h active then state h used notify h state t enabled else if h ea eb ea e state h idle then state h used end if else execute e and check for deadlock switch op case acq req t m site t s call checkdeadlock req t ls t ls t m s case rel ls t ls t m s for some s end switch execute e other event e.g.
thread termination end while function checkdeadlock if a sequence of events e1 e2 ... en where ei ti acq req ti site ti ls ti for i n is a cycle by definition then print a deadlock occurs .
halt end if end function .
experiment .
.
implementation and benchmarks implementation .
we implemented conlock to handle both java and c c programs.
the java implementation used asm .
to identify all synchronized operations of each loaded class and wrap them to produce events .
following the mechanism in java we take each object as a loc k instance .
the c c i mplementation was based on pin .
on linux.
we used the probe mode of pin because the analysis of deadlock is a high level pr oblem and there is no need to monitor any low level memory access in our case besides the probe mode provide s almost native execution performance .
conlock via pin i nstrument ed a c c binary program to produce events by wra pping the pthread library functions.
we implemented pct magicscheduler ms deadloc kfuzzer df and conlock cl on the same framework.
al though deadloc kfuzzer is available from the current release of calfuzzer yet this tool is for java programs and cannot ha ndle c c benchmarks and when we tried it on java benchmark i.e.
jdbc connector it only instrumented the test harness programs but not the library files i.e.
the program code that co ntains the deadlock s to prevent us from profiling any event to detect the deadlocks.
w e finally chose to faithfully implement df based on and calfuzzer to include all its optimizations instead of modifying calfuzzer .
we note here that according to the experiment in df was able to confirm deadlocks in the java library list i.e.
arraylist linkedlist and stack and map i.e.
hashmap weakhashmap linkedhashmap identityhashmap and treemap with and probabilities respectively.
the original tools of pct were unavailable for download ing at the time of cond ucting this experiment .
thus we implemented its scheduling algorithms for deadlocks according to .
we have assured our implementation by a few programs .
benchmarks .
we selected a suite of widely used real world java and c c programs including jdbc connector sqlite and mysql database server .
these benchmarks have been used in previous deadlock related experiments e.g.
and are available online .
all o ur test cases on these benc hmarks are taken from or their bugzilla repositories.
site.
we use d the existing object frequency abstraction to model the site of an object or an even t .
the same site of each object or event is used by all techniques i.e.
pct ms df cl .
.
.
experimental setup we ran the experiment on ubuntu linux .
configured with a .16ghz duo2 processor and .25gb physical memory ope njdk .
and gcc .
.
.
for each benchmark we used magic lock to generate the set of cycles based on the collected execution trace s. we then inputted each cycle and other inputs needed by algorithm if any to each technique i.e.
pct ms df and cl for each test case to run times .
pct is insensitive to a given cycle.
hence if a benchmark sho ws the presence of k cycles we ran pct for k times.
table shows the descriptive statistics of the benchmarks used in the experiment.
the column benchmark bug id and sloc show the benchmark name the available bug report number and the size of each benchmark in terms of sloc respectively .
the deadlock description column shows the functions or ope rations that can lead to the corresponding deadlock state.
the next three columns show the number of threads and the number of locks of threads locks the total number of cycles of cycles and the cycle id for each real deadlock of real deadlocks cycle id .
the last two columns show the number of data races of data races detected by loft configured with fasttrack and the number of events of events on the predicative runs respectively .
.
.
data analysis table shows the experimental results for all real deadlocks summarized in table .
the first column shows the cycle id cycle id followed by the number of threads and the number of locks of threads locks in the cycle and the number of constraints of constraints before and after constraint reduction generated by conlock on each cycle .
note that all the constraints before the nearest scheduling points are not counted.
the next three major columns show the confirmation probability probability the number of thrashing of thrashing and the time consumption time by each technique to confirm each cycle respectively .
note the time consumption is that co nsumed by each technique to successfully confirm the correspon ding cycle as a real deadlock or the confirmation run has resulted in a preset timeout for each run i.e.
seconds as indicated by .
on cycles c7 c11 we cannot precisely collect the normal exec ution time and the time need ed by pct because these cycles are on mysql server which is non stopping according to the test ha rness used .
we also use to indicate these cases.
the confirmation probability is computed using the formula sc rt where sc is the number of runs successful ly confirm ing the cycle and rt is the total number of confirmation runs .
note that the number of thrashing occurrence may not be directly related to the confirmation probability .
table lists the total number of real deadlocks in each benchmark of real deadlocks and the total number of such dea dlocks confirmed by each technique confirmed by at least one confirmation run.
table .
descriptive s tatistics and execution stat istics of the benchmarks note the of locks is the of objects benchmark bug id sloc deadlock description of threads locks of cycles of real deadlocks cycle id of data races of events java jdbc connector .
connection .preparestatement and statement .close c1 preparedstatement .executequery and connection .close c2 statement .executequery and conenction .preparestatement c3 c4 c c sqlite .
.
sqlite3unixentermutex and sqlite3unixleavemutex c5 c6 mysql server .
.
alter on a temporary table and a non temporary table c7 c10 insert and truncate on a same table using falcon engine c11 .
.
effectiveness on real deadlocks table shows that pct only confirmed out of cases as real deadlocks ms and df both confirmed real deadlocks and conlock confirmed all deadlocks.
table shows that conlock confirm ed cycles as real deadlocks with a probability from to .
on confirming cycles c1 to c7 conlock can always confirm each of these cycle s as a real deadlock in every run whereas the other techniques were signif icantly less effective in confirming these cycles as real deadlocks.
on confirming cycles c8 to c10 all techniques except conlock can only achieve a quite low or zero confirmation probability.
specifically pct ms and df each had a very low probability to confirm to cycles as real deadlocks and we highlight the co rresponding cells in table to ease readers to reference .
it is worth noting that pct does not rely on any given cycle to detect it as a real deadlock.
hence the comparison with pct should be considered as for reference only.
the column entitled of thrashing shows that both ms and df encountered thrashing quite frequently.
on confirming each of c1 c4 both ms and df each encountered thrashing in runs out of runs.
on each of c5 c7 they even guide d the corresponding confirmation runs to experience thrashing with very high probabilities .
on confirming c8 c10 their thrashing probabilities are .
to .
respectively.
on confirming c11 the number of thrashing occurrences seems acceptable.
the mysql server is the largest benchmark we used in the e xperiment that has sloc.
on confirming cycles for this benchmark conlock encountered almost no occurrence of thras hing in the entire experiment except one on confirming c10.
however ms and df encounter ed thrashing much more frequently.
from table we observe that the number of constraints after reduction ranges from to .
this is consistent with an empirical study result that a concurrency bug usually needs a short depth to manife st it .
we note that e ven though there were constraints for each of cycles unlike ms and df conlock did not suffer from thrashing on confirming these cycles as real dea dlocks .
.
.
effectiveness on false positives to validate the ability of conlock on cycles that are false pos itives w e sampled cycles out of all cycles for manual ver ification.
the cycles were sampled by the following rules we selected all i.e.
remaining cycles on jdbc connector .
on sqlite there is not false cycle.
on mysql server we selected out of every consecutive cycles reported by magic lock which resulted in a total of cycles.
we manually inspected and verified that all these cycles were false positives which had already took us about one whole week to complete this manual task .
as such we did not manually verify whether the remaining cycles are false positives.
table shows the mean performance of conlock on handling the sampled cycles .
the first two column s show the benchmark and the bug id respectively.
the next column of false positives inspected shows the average number of false positives reported by conlock as scheduling violations that we manual verified .
the last two columns avg.
of thrashing and avg.
time show the mean number of thrashing and the mean time for each technique on confirmation run s respectively.
from table to confirm against cycles that were false positives ms and df were very likely to result in thrashing in the exper i table .
the of real deadlocks confirmed by each t echnique benchmark bug id of real deadlocks confirmed pct ms df cl jdbc connector .
sqlite .
.
mysql server .
.
total table .
experimental results comparisons among pct magicscheduler ms deadlockfuzzer df and conlock cl cycle id of threads locks in the cycle of constraints before after reduction probability of thrashing time in seconds pct ms df cl pct ms df cl native pct ms df cl c1 .
.
.
.
.
.
.
.
.
c2 .
.
.
.
.
.
.
.
c3 .
.
.
.
.
.
.
.
c4 .
.
.
.
.
.
.
.
.
c5 .
.
.
.
.
.
.
c6 .
.
.
.
.
.
.
c7 .
.
.
.
.
c8 .
.
.
.
.
.
.
c9 .
.
.
.
.
c10 .
.
.
.
.
c11 .
.
.
.
.
.
.
table .
average performance of conlock on false positives note there is no false warning on sqlite means time out in every run.
pct is excluded due to its insensitiveness to a given cycle benchmark bug id of false positives inspected avg.
of thrashing avg.
time in seconds ms df cl ms df cl jdbc connector .
.
.
.
mysql server .
.
.
.
499ment whereas conlock only encountered a small number e.g.
in the row entitled mysql server of thrashing .
.
.
performance from the column entitled time in table the runtime ove rheads incurred by ms df and cl on successful confirmations are quite close to one another and the absolute time needed are all practical.
note that there are much more number s of thrashing occurrences incurred by ms and df than cl on each row and on confirming cycles c5 c6 ms and df simply suspend ed some threads until the timeout was reached.
from table we observe that cl can terminate a confirmation run against a false positive much earlier than ms and df.
we also found that cl can report a scheduling violation in each case except in one confirmation run where a thrashing has occurred.
we have experimented to configure cl using the whole set of constraints without reduction and scheduling points .
however on large scale programs i.e.
mysql this configuraiton encountered many thrashing occurrences and incurred significant slowdown .
.
.
threats to validity we have not manually validated all identified cycle s on mysql server due to our time and effort constraints .
the probability the ratios of thrashing and the time taken by the techniques may be different if different numbers of runs different benchmarks and tool implementations were used to conduct the experiment.
our im plementation is based on binary instrumentation.
an implementation of conlock through symbolic execution might produce more effective result s e.g.
higher confi rmation probability as the constraints can be determined more precisely .
however symbolic execution is still not scalable to handle large scale programs as noted in that the largest programs that can be symbolically executed today are on the order of thousands of lines of code .
in our benchmarks mysql server has millions of source lines of codes i.e.
sloc which is far out of the ability of state of the art symbolic execution engine s to handle.
.
related work many predictive deadlock detection techniques have been proposed .
magiclock is the state of the art dynam ic technique.
they all suffer from reporting false positives.
real deadlocks of them should be isolated .
kahlon et al.
proposed a static theor etical model for analysis of concurre ncy bugs in programs with well nested lock acquisitions and r eleases.
however the lock acquisitions and releases in modern real world programs e.g.
java and c c are usually not well nested and there exists a huge gap between static model s and the modern programming languages .
hence unlike conlock their model cannot handle the occurrence of thrashing.
marino et al.
proposed a static approach for detecting deadlocks in o bject oriented programs with data centric synchronizations.
their approach needs manual annotations to identify the ordering b etween atomic sets.
conlock is a fully automated dynamic a pproach.
deadlockfuzzer is the first technique that proposes to use the lock dependencies i.e.
a variant of event in this paper to detect cycles and to schedule the program execution to confirm cycles as we note that on the remaining cycles which we have not manually verified them to be false positives conlock reported scheduling viol ations in at least runs out of on each cycle and did not report any deadlock occurrence on checking them in a ny confirmation run.
real deadlocks .
magicscheduler the third phase of magicfuzzer advances deadlockfuzzer by allowing multiple cycles to be confirmed in the same run.
we have intensively reviewed these two schedulers and compared them with our conlock technique.
in we proposed asn the first constraint based real deadlock confirmation technique.
asn extracts constraints from the given cycle s and formulates them as barriers .
however asn cannot handle false positive s. conlock is able to detect scheduling viol ation to terminate an execution with respect to false positive s on real deadlocks like asn it is also able to confirm them with high probabilities and low slowdown overheads .
java path finder jpf has the potential to explore all possible schedules from a single input .
these schedules can be integrated with a deadlock detector to find deadlocks .
however these techniques are unable to handle large scale multithreaded programs e.g.
mysql even with the use of symbolic execution .
synchronization coverage techniques may e xplore mu ltiple schedules of the same input but they do not handle infeas ible coverage requirements adequately.
dimmun ix prevent s the re occurrence of each previously occurred deadlock through online monitoring .
gadara inserts deadlock avoidance code at the gate position of each deadlock warning via static analysis and then prevent s deadloc k occurrence at runtime .
nir buchbinder et al.
used an execution serializ ation strategy for deadlock healing.
these techniques develop and utilize no constraints among different threads and do not choose any nearest scheduling point needed by conlock .
besides dimmunix and gadara suffer from false positives deadlocking healing may introduce new deadlocks .
esd synthesizes an executio n from a core dump of a prev ious execution with deadlock occurrence .
conlock can take a cycle irrespective of whether it is a deadlock as an input.
both contest and ctrigger inject noise to a run to increase the probability to trigger concurrency bugs.
conlock is not complet ely an active randomized scheduler and need s not to adopt such a strategy.
penelop e also synthesizes an execution and uses a scheduling strategy similar to deadlockfuzzer and magicsche duler to detect real atomicity violation s. it does not use constraints to avoid thrashing .
conlock uses constraints and scheduling point s and is able to detect false positives .
replay techniques e.g.
are able to reproduce runs that co ntain concurrency bugs.
however they are unable to turn a run containing a suggested cycle into a run containing a real deadlock.
.
conclusion conlock analyzes a given execution trace and a cycle on this trace to generate a set of constraints and a set of nearest scheduling points.
it schedules a confirmation run with the aim to not violat e a reduced set of constraints from the chosen nearest scheduling points .
conlock not only confirms real deadlocks but also report s schedul ing violations if the given cycles are false positives.
the experimental results show that conlock can be both effective and efficient .
we will generalize conlock to confirm other types of concurrency bugs effectively and efficientl y in the future .
.