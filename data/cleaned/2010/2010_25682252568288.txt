ape an annotation language and middleware for energy efficient mobile application development nima nikzad dept of computer science and engineering univ.
of california san diego la jolla ca usa nnikzad cs.ucsd.eduoctav chipara dept of computer science university of iowa iowa city ia usa octavchipara uiowa.eduwilliam g. griswold dept of computer science and engineering univ.
of california san diego la jolla ca usa wgg cs.ucsd.edu abstract energy e ciency is a key concern in continuously running mobile applications such as those for health and context monitoring.
unfortunately developers must implement complex and customized power management policies for each application.
this involves the use of complex primitives and writing error prone multithreaded code to monitor hardware state.
to address this problem we present ape an annotation language and middleware service that eases the development of energy e cient android applications.
ape annotations are used to demarcate a power hungry code segment whose execution is deferred until the device enters a state that minimizes the cost of that operation.
the execution of power hungry operations is coordinated across applications by the ape middleware.
several examples show the expressive power of our approach.
a case study of using ape annotations in a real mobile sensing application shows that annotations can cleanly specify a power management policy and reduce the complexity of its implementation.
an empirical evaluation of the middleware shows that ape introduces negligible overhead and equals hand tuned code in energy savings in this case achieving .
energy savings compared to the case when there is no coordination.
categories and subject descriptors d. .
design tools and techniques computer aided software engineering case d. .
language constructs and features constraints general terms experimentation languages performance keywords mobile applications energy e ciency hardware monitoring annotations programming permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india acm ... .
.
.
introduction the rapidly advancing capabilities of modern smartphones have enabled the development of a new generation of continuously running mobile crm applications such as those for personal health and user context monitoring.
such applications may periodically wake to collect and process sensor data check with a remote server for updates or provide reports to a user.
examples include cenceme surroundsense audiosense and citisense .
even though these applications operate at low duty cycles cumulatively they have a large impact on the battery life of a device due to their periodic use of power hungry system resources such as the cellular radio for networking or the gps for localization.
even though mobile operating systems like android provide control over these power hungry resources developing an energy e cient crm application is challenging.
beyond the expected algorithmic and systems challenges of designing a power management policy see section there are also signi cant software engineering challenges the code for power management tends to be complex.
not just because the application must actively manage which resources are required or not but also because it must manage nuanced tradeo s between the availability of resources and desired battery life.
users are often willing to accept delays in processing or approximations in measurement to increase battery life.
additionally as will be seen in section .
power management code is often event driven and multithreaded.
power management optimizations should be postponed until the application s requirements are set.
mobile developers often depend on tight agile development cycles in order to elicit feedback from early adopters on basic application behavior.
developing and cyclically revising complex power management code earlyon would slow this cycle.
thus while many power management techniques have been developed there is no high level way to access these as language primitives to specify or implement an applicationspeci c policy for a new application.
this paper makes three contributions we present our system annotated programming for energy e ciency ape a small declarative annotation language with a lightweight middleware runtime for android sections .
and .
ape enables the developer to demarcate power hungry code segmentspermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm e.g.
method calls using annotations.
the execution of these code segments is deferred until the device enters a state that minimizes the cost of that operation.
policies have a declarative avor allowing the developer to precisely trade o delay or adapt sensing algorithms to reduce power.
the policies abstract away the details of event and multi threaded programming required for resource monitoring.
we introduce an abstract model of the ape approach based on timed automata.
with this model a wide variety of existing power management techniques can be described demonstrating both the scope and simplicity of the approach section .
.
the model guided both our language and middleware design.
we provide a rst evaluation of the ape approach.
we evaluate the expressiveness of the language through a a series of policy examples section .
and b a case study of introducing power management into the citisense crm application both without and with ape section .
.
for the middleware runtime we show that an ape annotated implementation of citisense saves as much power as the hand tuned implementation while requiring fewer changes to the original source code and having negligible runtime performance overhead section .
.
.
background and related work in recent years energy saving optimizations for mobile devices have been an active area of research.
such work typically falls into one of two categories low level optimizations and system level optimizations.
low level optimizations save energy by judiciously controlling the power state of hardware components such as the cpu radio ash memory and sensors see for a review .
low level optimizations are implemented as part of device drivers or even in hardware to ensure that they interact with the device at time scales comparable to the transition times between power states typically sub millisecond .
examples of such policies include dynamic voltage and frequency scaling see for a review tickless kernel implementations low power listening and scheduled transmissions for radios and batching of i o operations for devices such as ash .
system level optimizations interact with the hardware components on longer time scales and as a consequence may be implemented as part of applications or middleware services.
three common approaches to system level optimizations include workload shaping sensor fusion and ltering.
an example of workload shaping is that of delaying large network operations until a wi fi connection is available as wi fi is typically more e cient than cellular data transmission.
such a policy is found in applications such as google play market facebook and dropbox.
sensor fusion is used to combine data from multiple potentially heterogeneous sources that have diverse energy costs.
sensor fusion has found applications in state of the art localization techniques that combine information from gps cell towers wi fi and bluetooth e.g.
.
power savings are achieved by shifting the sensing burden from the high power gps sensor to the other sensors that consume signi cantly less energy.
in the same vein context recognition frameworks adapt sensingand networking operations based on the user s context.
optimizations found in such frameworks include adjusting the amount of processing applied to sensor data selecting a minimal set of sensors to power and avoiding sensing altogether by inferring context based on already known information .
recent techniques for environmental and user context sensing have examined the use of models to lter out collected data incurring the high cost of processing and transmitting collected measurements only if they deviate from expected values .
challenges.
in spite of the signi cant progress made in developing power management policies energy e cient applications remain di cult to develop.
a one size ts all approach fails to yield desirable results as minute di erences in hardware speci cations or quality of service requirements makes power management policies suboptimal or in pathological cases leads to energy being spent ine ectively.
this reality leads developers to include highly customized power management code in their applications.
unfortunately such code is prone to errors because even when written at the application level the developer must still use complex low level power management primitives and handle the concurrency required by hardware monitoring code.
what is needed is a general mechanism of encoding power management policies that allows a developer to easily customize them for new applications.
a general model for specifying power management policies may be di cult to derive as it must encode complex trade o s between quality of service and energy consumption.
we will show that a timed automata model meets these criteria the model allows simple policies to be composed into more complex ones.
more importantly the complex trade o s in quality of service can be e ectively expressed as state transitions in the timed automaton which are triggered by hardware events and the passage of time.
our approach and related work.
ape employs an annotation language and middleware runtime that allows developers to annotate their code to declaratively compose power management policies from low level primitives.
ape is not a replacement for existing power saving techniques but rather facilitates the design and implementation of such techniques in real world applications.
ape targets the implementation of system level power optimizations.
the design of ape was inspired by openmp an api and library that facilitates the development of parallel c c and fortran applications.
as an alternative to lowlevel thread management openmp allows a developer to specify using preprocessor directives placed directly in the code how tasks should be split up and executed by a pool of threads.
several other projects have examined the use of annotations for code generation veri cation and driving optimizations .
energy types allows developers to specify phased behavior and energy dependent modes of operation in their application using a type system dynamically adjusting cpu frequency and application delity at runtime to save energy .
however this approach requires developers to structure their application into discrete phases and would likely require signi cant e ort to apply to an existing application later in the development cycle.
enerj allows a developer to specify which pieces of data in their application may be approximated to save energy and guarantees the isolation of precise and approximate components516 .
these systems are complementary to our own and may be used alongside ape.
ape is to our knowledge the rst such system to provide a general and highly programmable way of expressing runtime power management policies for mobile applications without the need for signi cant refactoring.
.
ape design overview ape is designed to provide developers a simple yet expressive mechanism for specifying power management policies for crm applications.
three basic principles underline the design of ape ape separates the power management policies expressed as java annotations from the code that implements the functional requirements of an application.
this enables developers to focus on correctly implementing the functionality of an application prior to performing any power optimizations.
ape does not propose new power management policies but rather it allows developers to compose simple power management policies into more complex ones using an extensible set of java annotations.
ape annotations are both simple and su ciently exible to capture a wide range of power management policies.
ape insulates the developer from the complexities of monitoring hardware state and provides a middleware service that coordinates the execution of power management policies across multiple applications for increased power savings compared to when power management is not coordinated across applications .
ape includes an annotation preprocessor and a run time environment.
the preprocessor validates the syntax of annotations and translates them into java code.
the generated code makes calls to the run time environment that coordinates the execution of power management policies across multiple ape enabled applications.
the remainder of the section is organized as follows.
first we will introduce the formal model that is used by ape.
then we present the set of java annotations that ape provides to the developer.
.
the ape policy model ape builds on the following key insight power management policies defer the execution of expensive operations until the device enters a state that minimizes the cost of that operation .
for example crm applications reduce the cost of networking operations by deferring their data uploads until another application turns on the radio.
if no connection is established within a user de ned period of time the application turns on the radio and proceeds with the data uploads.
similarly an application that maps road conditions e.g.
detect potholes would collect data only when it detects the user to be driving.
an energy e cient mechanism for detecting driving may be to rst use the inexpensive accelerometer to detect movement and then lter out possible false positives by using the power hungry gps sensor.
to our surprise this insight holds across diverse powermanagement policies that involve di erent hardware resources and optimization objectives as illustrated by the examples in this section.
nevertheless the examples also illustrate the di culties associated with developing a generalmodel for expressing power management policies.
the model must capture both static properties of hardware resources that may be queried at run time e.g.
radio on o as well as user de ned states that must be inferred using complex algorithms e.g.
driving .
henceforth we refer to changes in hardware states or in inference results as application events .
the model must also incorporate a notion of time.
the rst example illustrates the use of timeouts to trigger a default action.
more interestingly the second example de nes a policy where the application should monitor for potholes as a sequences of application events evolving over time rst the accelerometer must detect movement that is then con rmed by gps.
ape adopts a restricted form of timed automata to specify power management policies.
the automaton encodes the precondition when an operation oshould be executed as as to minimize energy consumption.
at a high level a power management policy is encoded by the states and transitions of the timed automaton.
the timed automaton starts in the start state and performs transitions in response to application events and the passage of time.
eventually a timed automaton reaches an accepting state that triggers the execution ofo.
formally ape s restricted timed automata is a tuple ta s s sf c e where is a nite set of events sis a nite set of states state s02sis the start state sf sis a set of accepting states cis a nite set of clocks and eis a transition function.
the transition e2eis a tuple c wherecis a clock constraint and is a boolean expression consisting of application events.
the automaton transitions from state si tosj sic !sj when both cand hold.
in contrast to standard timed automata in our model transitions from the current state are taken as soon as the required clock constraints and inputs are satis ed.
additionally we also restrict the expressiveness of clock constraints.
clock constraints can only refer to a single global clock cgor to a single local clock clthat is reset each time a transition is taken to a new state.
the local clock can be used to impose constraints on transitions outgoing from a state while the global clock can be used to impose a time constraint on the total delay before an operation ois allowed to execute.
the above restrictions ensure that the automaton can be executed e ciently on resource constraint devices such as mobile phones.
to clarify our ape s formal model let us return to the examples introduced in the beginning of the section.
example defer uploads for up to minutes until the wi fi radio has connected to a network.
figure shows the automaton associated with this policy.
it includes only two states a start state and an accepting state.
transitions from the start state to the accepting state occur in two cases when the radio is connected and the global clock is less than minutes or the global clock exceeds minutes.
note the expressive power of the automaton to compactly517starttrue wifi.connected cg 30min true figure defer uploads for up to minutes until the wi fi radio has connected to a network.
capture conditions that depend both on applications events and time constraints.
example defer sensor sampling until the user is driving.
driving is detected by rst verifying movement using the accelerometer and then waiting for up to seconds for driving to be con rmed using gps.
figure shows the automaton associated with this policy.
the automaton includes three states transitioning from the start state to state accwhen movement is detected based on readings from the accelerometer which is captured by predicate accel.move .
the automaton transitions to the accepting state from acc when driving is con rmed based on readings from the gps which is captured by the predicate gps.drive .
start acctrue accel.move cacc 30sec true true gps.drive figure defer sensor sampling until movement is rst detected by the accelerometer and driving is con rmed using the gps.
the described formal model allows us to capture a wide range of power management policies.
however a disadvantage of using timed automatons as a speci cation language is that they are hard to de ne using simple literals that may be included in java annotations.
while experimenting with expressing power management policies in ape we observed that most of policies have a regular structure that can be captured using a simpler model.
the execution of an operation ois deferred until a nite sequence t1 t2 n tn of states holds p f t1 t2 n tn g tmaxdelay sequences of conditions when n are resolved in order optionally rolling back and rechecking the previous condition i ti if the current condition being checked i ti is not satis ed before titime has passed.
additionally a policy may provide an upper bound tmaxdelay on the delay introduced by the policy.
constructing a timed automaton from the simple model is a straight forward process that we omit due to space limitations.using this concise notation the previous two policies can be expressed as p1 f wifi.connected g min p2 f accel.move gps.drive sec g most policies found in literature and real world applications can also be expressed using ape s simpli ed model.
for example a policy implemented by applications such as evernote google play market and youtube is to delay syncing data and downloading updates until a wi fi connection is available and the device is charging f wifi.connected and battery.charging g while advertisements in mobile applications are typically fetched over the network whenever one is required an advertisement framework could instead display ads from a locally stored corpus that is updated periodically .
the policy that manages when updates to the corpus are fetched could be described as f ads.needupdate net.active and wifi.connected g batching write requests to ash memory is yet another example of a power saving technique for mobile applications.
an email client may store newly received emails in memory writing them out to ash in batches periodically or when the number of emails in memory exceeds some threshold .
such a policy could be described as f batch.threshold g min while these examples show that the simpli ed timed automata model of equation is able to express a diverse set of real world policies this model is not as expressive as the full model of equation .
for example consider an extension of the driving detection policy in example see figure .
in the extended policy driving is still detected by rst monitoring for movement using the accelerometer and then verifying that the user is driving by using the gps.
however the policy additionally requires that driving be observed continuously for seconds before allowing execution to continue.
during this second period if the accelerometer fails to detect motion or the gps to detect driving the policy immediately returns to the initial state of checking the accelerometer for motion.
this policy cannot be expressed in the simpli ed model because the transition from the state acc to the start state occurs on an event accel.move or gps.drive rather than on a timeout as required by the simpli ed model.
ape annotations further discussed in the next section build on the simpli ed model as it has a simple textual representation and captures most of the policies we have encountered.
ape may be further extended in the future to provide a more complex syntax for expressing power management policies using general timed automata.
.
the ape annotation language ape realizes the above model in a small and simple language implemented using java annotations.
a preprocessor translates the annotations at compile time into java code that makes calls to the ape middleware runtime section .518start acctrue accel.move true accel.move or gps.drive cacc 30sec gps.drive figure defer sensor sampling until the user is driving.
driving is detected by rst verifying movement using accelerometer for seconds and then con rmed using gps.
ape waituntil the ape waituntil annotation is the direct realization of the model syntax and semantics speci ed above in equation .
as such it prefaces a code segment and speci es the sequence of application events that must be satis ed before execution proceeds to the prefaced code.
for example the policy from example can be expressed as while true ape waituntil wifi.connected inf maxdelay uploadsensordata wifi.connected is an ape recognized application event that ape monitors on behalf of the application inf says that the local clock constraint is true i.e.
cs infinity andmaxdelay asserts global clock constraint as cg seconds.
the parentheses can be dropped when there is no local clock constraint while true ape waituntil wifi.connected maxdelay uploadsensordata similarly the policy from example can be expressed as void startdrivinglogging ape waituntil accmove inf gpsdrive maxdelay inf beginsensorsampling where accmove andgpsdrive are local functions that encompass logic speci c to the application.
with ape waituntil it is also possible to designate java code that must be executed before the thread begins waiting or after waiting has ended while true ape waituntil wifi.connected maxdelay prewait log started waiting for wi fi... postwait log finished waiting for wi fi!
uploadsensordata the optional prewait and postwait parameters are useful when an application has to prepare for or recover from blocking the annotated thread.
ape if ape elseif and ape else example can be further extended to conditionally wait up to minutes for a wi fi connection if the battery level is greater than or otherwise to wait up to two hours while true ape if battery.level ape waituntil wifi.connected maxdelay ape else ape waituntil wifi.connected maxdelay uploadsensordata the ape if ape elseif and ape else annotations allow developers to specify multiple energy management policies for the same segment of code selecting one at run time based on application and device state at time of execution.
unlike ape waituntil expressions which block until they evaluate true any expressions provided to an ape if or ape elseif annotation are evaluated immediately by the ape runtime and the selected branch is taken to invoke the appropriate policy.
state expressions and transitions the ape waituntil ape if and ape elseif annotations each take as a parameter a boolean expression consisting of application events that represents a potential state of the application and device.
each term used in an expression must be either a recognized primitive in the ape language or a valid java boolean expression.
an ape term refers to a property of a hardware resource.
for example wifi.connected refers to the status of wi fi connectivity.
a java expression included in an annotation is surrounded by curly braces.
terms are joined using and andoroperators.
as an example requestspending and wifi.connected or cell.3g describes the state where the client application has requests pending and it is either connected to a wi fi or 3g network.
therequestspending method must be in scope at the location of the annotation.
each of the expressions provided to an ape waituntil annotation is a predicate controlling the transition to the next state in a timed automaton.
consistent with android s event driven model ape treats these predicates as events when in a given state ape monitors the events necessary to trigger a transition to the next state.
as events arrive their containing predicate expression is reevaluated and if true it triggers a transition to the next state.
arriving in a new state causes ape to unregister for the last expression s events and to register for the events required to trigger the next transition.
likewise event triggers are set up for a state s local clock the global clock is its own event trigger set up when the automaton enters the start state.
the ape compiler must handle two special cases when compiling an ape annotation both related to the dichotomy between events and method calls.
when an ape expression includes a local method call the method is periodically polled until its containing expression evaluates to true or until the evaluation becomes irrelevant due to another event trigger.
for example in the case of the expression requestspending the method requestspending is periodically polled until its containing boolean expression evaluates to true.
when ape initially registers for an event it also makes a direct query to the resource of interest to determine if the resource is already in the desired state.
for the expressionwifi.connected for example ape both registers for events regarding changes in wi fi status and queries wi fi to determine if it is already connected.
if so ape imme 519diately evaluates the expression to true.
otherwise ape waits for a callback from the system regarding a change in wi fi status and rechecks for the connected condition.
the ape preprocessor performs syntactic checking and error reporting with ape terms being checked against an extensible library of terms.
the device state primitives supported by ape are speci c to each device but there is a standardized core that encompass the display cellular wifi and power subsystems of a device and their various features and states.1additional details regarding the e cient implementation of timed automata semantics and the evaluation of state expressions are discussed in the next section.
ape de neterm the ape de neterm annotation allows a developer to de ne a new term that can be used in ape annotations throughout the application.
de ning new terms not only provides for reuse but also allows nonexperts to utilize policies constructed by others.
for example a new term myterm may be de ned by ape defineterm myterm battery.charging and wifi.connected or cell.4g and used to construct ape annotations such as ape waituntil requestspending and myterm maxdelay any ape recognized primitive or valid java boolean expression may used in the de nition of a new term.
terms do not encode any notion of timing and are thus not complete policies in themselves but rather building blocks for higher level policies.
ape de nepolicy in addition to de ning new terms developers may de ne reusable high level policies with the use of the ape de nepolicy annotation.
the di erence between a term de ned using ape de neterm and a policy is that a policy may encode timing constraints and transitions.
unlike terms which can be joined together with other terms to form state expressions a de ned policy represents a complete state expression.
transitions may be used to chain policies together.
for example a new policy mypolicy may be de ned by ape definepolicy mypolicy display.off inf myterm and used to contruct ape annotations such as ape waituntil mypolicy dataready maxdelay the timing parameters in a de ned policy act as defaults and may be optionally replaced when referencing a policy ape waituntil mypolicy inf dataready maxdelay for many power management policies such as those without transitions simply de ning a new term is su cient.
annotations are translated at compile time into runtime requests to the ape middleware service discussed in section which is responsible for monitoring device state and resolving policies on behalf of ape enabled applications.
java annotations are simply a form of metadata added to source code and thus have no impact on application behavior without the relevant processor interpreting them during the build process.
this feature of annotations means that a developer can experiment with a power management policy and then quickly disable it during testing by simply removing the ape annotation processor from the build process.
1ape builds upon android s java hardware api speci cation which standardizes the names and low level states of many components.
.
the ape runtime service the ape runtime is responsible for executing ape annotations from multiple ape enhanced applications.
in this section we focus on the key design decisions behind the service and discuss optimizations made to reduce the overhead of executing ape annotations.
the runtime consists of a client library and a middleware service.
a single instance of the middleware services implemented as an android service component runs on a device.
the middleware service is responsible for monitoring for changes in hardware state and re evaluating ape expressions in response to these changes.
ape applications communicate with the middleware through remote procedure calls rpcs .
the details of rpc including binding to the service parameter encoding and error handling are encapsulated in the client library.
having a single middleware service instance has the advantage of amortizing the overhead associated with policy evaluation over multiple applications.
more importantly this approach allows the middleware to coordinate the activities of multiple clients for added energy savings shown experimentally in section .
.
.
ape annotations are translated into java code by the ape preprocessor prior to compilation.
each policy is converted into an equivalent integer array representation so as to avoid string processing at runtime.
the generated code relies on three functions provided by the client library registerpolicy ifexpression and waitforexpression .
the registerpolicy function is executed during the initialization of the application and registers each ape policy with the middleware through rpc calls.
the middleware service returns a policy handler that can be used by ifexpression andwaitforexpression to refer to a particular policy at runtime.
rpcs to the middleware are synchronous blocking the execution of the calling application thread until they return.
consistent with the model described in section .
each policy is represented as a timed automaton that is executed by the middleware.
an rpc completes when the automaton reaches an accepting state.
this triggers the return of the rpc and subsequently the execution of the deferred application code.
the generated code is split into initialization segments registerpolicy calls and policy segments ifexpression andwaitforexpression calls in order to reduce runtime overhead.
as the overhead associated with rpc is dependent on the size of the request the potentially large representations of policies are only transmitted once to the middleware using registerpolicy calls during initialization.
runtime policy segments utilize policy handlers so as to avoid uploading policies to the middleware multiple times.
as policy handlers are implemented as integers they add only four bytes to the size of a rpc request thus minimizing runtime overhead.
the overhead associated with rpc is further discussed in section .
.
.
for the middleware to execute the timed automatons efciently it must track changes in hardware state and update the ape expressions in response in an e cient manner.
the monitoring of low level device state primitives is implemented as components called device state monitors.
aside from requiring concurrent programming device state monitors are challenging to write because they must glean information through somewhat ad hoc mechanisms.
for example the connectivity of the cellular radio is determined by periodically polling the connectivitymanager .520figure the boolean expression tree representation of a particular ape waituntil request.
all leaf nodes in the tree represent primitives in the expression while all non leaf nodes represent operators.
however to determine whether data is transmitted received the device monitor must register callbacks with the telephonymanager .
additional connectivity information may also be extracted from sysfs the linux s standard mechanism for exporting kernel level information.
our device monitors provide clean apis that hide the idiosyncrasies of monitoring hardware resources.
in response to a registerpolicy call the middleware generates an equivalent boolean expression tree for each expression.
the tree is constructed such that leaves represent terms in the expression and non leaves are andororoperators.
a node maintains a reference to its parent and any children.
in addition a node also maintains a boolean representing the evaluation of its subtree expression.
at a high level the expression trees are evaluated from leaves to the root.
the leaves involve low level states monitored using the device state monitors.
these values are propagated up the tree and combined based on the boolean operator and or or .
this approach reduces the cost of evaluating expressions as changes in low level state often do not require the entire tree to be reevaluated.
figure provides an example of a simple boolean expression tree in ape.
the arrows indicate the ow of information during the evaluation of the boolean expression represented by the tree.
the tree is evaluated in one of two ways.
in the case of ifexpression the ape service calls a method of the same name on the head node of the tree.
when ifexpression is called on a non leaf node the node calls ifexpression on each of its children and applies its operator to the returned values.
when ifexpression is called on a leaf node the device monitor associated with the node returns the current state of the hardware device.
the value returned by the method call on the head node is in turn returned back to the client application where the result is used to select which policy if any should be applied.
in the case of waitforexpression the ape service again calls a method of the same name on the head nodeof the tree.
rather than evaluating all nodes immediately waitforexpression noti es all leaf nodes to begin monitoring changes in device state and starts any necessary timers.
leaf nodes register for callbacks from the relevant device monitor about changes regarding the node s term.
if necessary threads are created in the client application to periodically evaluate any local java code used as part of an annotation and to communicate the result to the ape service.
whenever a node receives information that would change the evaluation of its term or operator it noti es its parent node of the change.
this lazy evaluation of the expression tree from the bottom up ensures that each term and operator in a state expression is only reevaluated when new information that may a ect its result is present.
to avoid unnecessary message passing and computational overhead device state monitors only actively monitor the hardware components necessary to resolve all pending requests from leaf nodes.
when the head of the expression tree evaluates to be true or if the tree s timer expires all leaf nodes are noti ed to stop monitoring changes by unregistering from their corresponding device state monitor.
in the case that a policy consists of multiple expressions the trees are evaluated in the order that they appear moving forward to the next tree once the current tree evaluates true or returning to a previous tree if the current expression times out.
given the synchronous nature of the remote procedure calls calls towaitforexpression will block the calling thread of execution in the client application until the call returns thus ensuring the costly operation that follows is not executed until the desired conditions have been satis ed.
.
evaluation in this section we evaluate ape from two perspectives.
first we present a case study of introducing power management into the citisense crm application both with and without the use of ape.
we then examine the performance of the middleware runtime and show that ape e ectively reduces power consumption by coordinating the workloads of multiple applications while requiring fewer changes to the original source code and having negligible runtime performance overhead.
.
case study citisense the authors have developed a variety of crm applications notably citisense which monitors records and shares a user s exposure to air pollution using their smartphone and a bluetooth enabled sensor device .
building an application that performed all the required tasks without depleting the smartphone s battery proved challenging as the application depended heavily on the use of gps for localization bluetooth for sensor readings and cellular communication to upload measurements to a server for further processing.
much of the challenge in improving citisense arose from adding evaluating and iteratively revising the application s already complex code base to implement energymanagement policies.
in this section we share our experience in implementing a policy for uploading sensor data from the citisense mobile application to a remote server providing both hand coded and ape implementations.
the initial implementation of the citisense mobile application cached air quality measurements on the user s device and attempted to upload all stored readings once every twenty minutes.
if the loss of connectivity caused a trans 521thread uploadthread new thread new runnable while true try thread.sleep catch interruptedexception e attemptupload uploadthread.start figure example of a naive implementation of sensor reading uploading in citisense.
a thread thread wakes every twenty minutes to attempt uploading any stored sensor readings before returning to sleep.
thread uploadthread new thread new runnable while true intent batt context.registerreceiver null new intentfilter intent.action battery changed int lvl batt.getintextra batterymanager.extra level int scl batt.getintextra batterymanager.extra scale float batterypct lvl float scl try if batterypct thread.sleep else thread.sleep catch interruptedexception e attemptupload uploadthread.start telephonymanager telemanager telephonymanager context.getsystemservice context.telephony service translistener translistener new translistener telemanager.listen translistener phonestatelistener.listen data activity private class translistener extends phonestatelistener public void ondataactivity int act if act telephonymanager.data activity in act telephonymanager.data activity out act telephonymanager.data activity inout uploadthread.interrupt figure an improved implementation of uploading in citisense that is both battery life and cellular radio state aware.
mission to fail then the data would be preserved until the next upload window.
although timed batching saves energy the approach still has several drawbacks.
uploads attempted while a user s phone had a weak cellular network signal often failed but still incurred high energy consumption during the failed attempt.
additionally even if connectivity was available nineteen out of every twenty minutes the lack of connectivity at the twentieth minute mark meant the upload would be delayed until the next attempt.
for some users with unreliable cellular coverage it often took hours before their data was uploaded successfully to the server.
to improve the energy e ciency and reliability of citisense uploads the application was modi ed to attempt a transmission whenever the phone s cellular radio was detected to already be transmitting or receiving data see figure .
the equivalent timed automaton for this policy is presented in figure .
the concept is that if the phone detects that another application on the phone has successfully sent or received data over the cellular radio then citisense would also likely succeed.
additionally with radio already being active citisense would no longer be forcing the radio out of a low power idle state the application is takingstarttrue battery.level true battery.level true network.active cg 20min true cg 60min true true network.active figure the equivalent timed automaton for the policy implemented in figure .
advantage of other workloads waking the radio reducing its impact on device battery life.
in the event that no other application wakes the radio in a timely manner citisense attempts to upload any stored readings after a timeout.
however unlike the static twenty minute timer used in the rst implementation this one varies timeout length based on the remaining battery life of the device.
if remaining battery life is greater than the application waits up to twenty minutes for the radio to become active otherwise citisense will wait up to one hour.
unfortunately what was once a simple nine line implementation now requires querying the android system for the status of the battery registering the application for callbacks regarding changes in cellular data activity in the system and implementing a custom phonestatelistener to handle callbacks and to interrupt the sleeping upload thread if data activity is detected.
further extending the implementation to be dependent on the state or availability of other resources such as a wi fi connection would require implementing additional listeners to handle callbacks and additional concurrency management.
given the large number and complexity of changes required prototyping and experimenting with a variety of potential policies becomes time consuming and burdensome.
even a well thought out policy can perform poorly in practice and require tweaks or major changes.
when we reimplemented this policy in ape the code collapses back to nine lines with the lines of policy code being reduced to three lines of ape annotations thread uploadthread new thread new runnable while true ape if battery.level ape waituntil network.active maxdelay ape else ape waituntil network.active maxdelay attemptupload uploadthread.start the developer implemented phonestatelistener event handling and thread concurrency management are now handled by the ape middleware.
in this compact declarative522format it is now possible to read the policy at a glance and to attempt variants of the policy quickly.
the ape policy managing uploads can be rapidly extended to also consider the quality of the cellular connection and the availability of wi fi thread uploadthread new thread new runnable while true ape if battery.level ape waituntil wifi.connected or network.active and cell.3g or cell.4g maxdelay ape elseif battery.level ape waituntil wifi.connected or network.active and cell.3g or cell.4g maxdelay ape else ape waituntil wifi.connected or network.active and cell.3g or cell.4g maxdelay attemptupload uploadthread.start instead of waiting for simply any cellular network activity citisense now uploads sensor readings only while connected to a wi fi network or if cellular activity was observed while connected to either a 3g or 4g cellular network.
the maximum time to wait for such a state was set to be minutes if remaining battery life was greater than minutes if between and and minutes if less than .
with the use of ape the new energy management policy can be expressed in a total of six annotations.
in contrast an experienced android developer implementing the same policy by hand required lines including ve lines for suspending and waking threads three lines to register the application for callbacks regarding changes in device state from the android system and lines and one new class for handling the callbacks.
the thread responsible for uploading sensor readings is put to sleep until it is interrupted by a di erent thread which handles callbacks from the android system and determines when all required resources are available.
not only is this implementation much longer than the ape based implementation it is signi cantly more di cult to understand and maintain.
this shows that ape not only represents power management policies concisely but also signi cantly reduces the implementation complexity by removing the need to write error prone concurrent code.
.
system evaluation in this section we evaluate ape by examining the overhead associated with communicating requests to the middleware service.
additionally we present power savings achieved by using ape to implement a simple resourceaware energy management policy in an application that makes regular use of network communication.
all experiments were run on a pantech burst smartphone running android version .
.
.
the power consumption of the device was measured using a power monitor from monsoon solutions .
the battery of the pantech burst was modi ed to allow a direct bypass between the smartphone and the power monitor allowing power to be drawn from the monitor rather than the battery itself.
traces of this power consumption were collected on a laptop connected to the power monitor over usb.
measurements involving network communication were run on the at t cellular network in the san diego metropolitan area.
though the pantech burst supports lte all experiments were run while operating on at t s hspa network as lte coverage was not available at the site of our experiments.
time to resolve ms state expression length figure time to register expressions of various lengths using registerpolicy .
as the size of the expression grows the size of the message passed over ipc begins to impact latency.
.
.
ape overhead to evaluate the overhead associated with using ape we examine the time required to complete a simple request to the middleware service.
additionally we examine the impact of expression length on the latency of registerpolicy requests.
a simple android application was built that performed no operations other than to execute the code being benchmarked.
the time required to execute code segments was measured by taking the di erence between calls to system.nanotime placed just before and after the code segment.
to evaluate the latency overhead associated with using ape we measured the time required to check the current status of data activity on the device using the standard android api and using ape.
checking the current status of data activity using the standard android api was done using the following code telephonymanager telman telephonymanager getsystemservice context.telephony service int dataact telman.getdataactivity the average time required to execute this code was measured to be approximately .
ms. checking the current status using ape was implemented using the following annotation ape if network.active the average time required to check for data activity using ape was measured to be approximately .
ms meaning approximately .
ms were spent sending the request to the ape service over ipc evaluating a single term expression tree and returning a message to the client application over ipc.
given that a developer would use ape to shape delaytolerant workloads we believe that an overhead of .
ms is negligible especially when compared to the time that will be spent waiting for ideal conditions.
to evaluate the impact of expression length on the time required to register a policy calls to registerpolicy using expressions of various lengths were measured using our test application.
expressions were constructed using a chain ofnetwork.active andand terms.
as observed in figure the time to register policies remains fairly constant at lower expression lengths.
it is only when expressions begin to become longer than terms that the overhead associated with passing large messages over ipc begins to take its toll.
messages are passed between processes using a bu er523figure increase in system power consumption due to the introduction of additional applications that periodically make use of network resources.
ape enhanced applications e ectively recognize opportunities to transmit data e ciently only marginally increasing power consumption.
figure power consumption mw traces from a smartphone device running a variety of naive top and ape enhanced bottom crm applications.
in the android kernel.
if messages become su ciently large they require additional bu er space to be allocated in the kernel thus introducing additional latency in resolving requests.
however expressions of such length are unlikely to arise in practice as realistic energy management policies depend on signi cantly fewer application events.
in the experience of the authors most ape expressions tend to be between one and nine terms.
as these requests are completed only once at the start of an application their overhead is considered acceptable even at long expression lengths.
.
.
power savings to demonstrate the potential impact of crm applications on the battery life of a device power measurements were collected from a smartphone running an instance of the citisense application which fetched data from a remote server once every two minutes.
as a baseline we measured the power consumption of the phone while powering its display at maximum brightness and running a single instance of citisense to be .
mw.
up to ve additional instances of citisense were then introduced to the system.
the power consumed by these applications when their use of networkresources does not overlap presented in figure reached as high as .
mw a .
increase.
this is a worst case scenario as there is no coordination with existing workloads on the device to ensure e cient usage of resources.
to demonstrate the potential savings of using ape to implement even a simple energy management policy the applications were each modi ed using a single ape waituntil annotation to wait up to seconds for the cellular radio to be woken before attempting transmission.
as observed in figure the introduction of this annotation signi cantly reduced the power consumption of additional crm workloads adding ve additional ape enhanced instances of the citisense application increased power consumption by only .
mw or .
.
as can be seen in figure ape is able to e ectively coordinate the workload of the crm applications to minimize the number of times the cellular radio is woken and put into a high power state.
if no background application had been running on the device and transmitting data then the rst ape enhanced application to timeout would wake the radio to transmit its request.
the other ape applications would then have detected this event and transmitted at the same time for nearly no additional energy cost.
this experiment shows that ape provides e ective means of coordinating power management across applications to achieve signi cant energy savings.
.
conclusion annotated programming for energy e ciency ape is a novel approach for specifying and implementing systemlevel power management policies.
ape is based on two key insights power management policies defer the execution of power hungry code segments until a device enters a state that minimizes the cost of that operation.
the desired states when an operation should be executed can be e ectively described using an abstract model based on timed automata.
we materialized these insights in a small declarative and extensible annotation language and runtime service.
annotations are used to demarcate expensive code segments and allow the developer to precisely control delay and select algorithms to save power.
we showed our approach to be both general and expressive in that it can replicate many previously published policies and that its use reduced the complexity of power management in citisense.
the ape middleware s use of techniques like code generation policy handlers lazy evaluation and encoding policies as integer arrays kept overhead below .
ms for most requests to the service.
in our benchmarks ape provided power savings of .
over an application that did not coordinate access to resources.
tools for assisting developers in reasoning about appropriate places to apply ape annotations are currently under development.
we are also exploring the use of a type system for designating delay in tolerant data in an application.
a user study of experienced developers will be conducted to examine how well developers new to ape adapt to using annotations to express power management policies.
.