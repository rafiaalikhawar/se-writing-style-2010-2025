draftgraph based pattern oriented context sensitive source code completion anh tuan nguyen tung thanh nguyen hoan anh nguyen ahmed tamrawi hung viet nguyen jafar al kofahi tien n. nguyen electrical and computer engineering department iowa state university anhnt tung hoan atamrawi hungnv jafar tien iastate.edu abstract code completion helps improve developers programming productivity.
however the current support for code completion is limited to context free code templates or a single method call of the variable on focus.
using software libraries for development developers often repeat api usages for certain tasks.
thus a code completion tool could make use of api usage patterns.
in this paper we introduce grapacc a graphbased pattern oriented context sensitive code completion approach that is based on a database of such patterns.
grapacc represents and manages the api usage patterns of multiple variables methods and control structures via graph based models.
it extracts the context sensitive features from the code under editing e.g.
the api elements on focus and their relations to other code elements.
those features are used to search and rank the patterns that are most fitted with the current code.
when a pattern is selected the current code will be completed via a novel graph based code completion algorithm.
empirical evaluation on several real world systems shows that grapacc has a high level of accuracy in code completion.
keywords pattern based code completion api usage pattern i. i ntroduction code completion which is a built in support in many integrated development environments ides aims to help improve programming productivity.
however most of the state of the art code completion tools can help in the completion of only a single method call or a single object declaration initialization.
for example eclipse provides an alphabetical order list of available methods for the variable under editing.
the user then has to go through a long list of unranked options.
for better auto completion several approaches have been proposed to rank such a suggested list of method calls.
however the volume of auto completed code is still limited to a single method call.
aiming to provide more auto completed code some ides recommend the templates for common program constructs e.g.
for while and popular classes methods e.g.
iterator .
however they do not consider the context of the code under editing thus do not predict well users editing intention.
using software libraries developers follow the api specifications to perform their tasks with some intended functionality.
other developers may also repeat those tasks via the same api usages.
the correct and repeated ways of using apis are often called api usage patterns .
the patterns include the usages of variables method calls and controlstructures with specific control and data dependencies and the orders among them.
thus to support better api usages and provide more auto completed code a code completion tool can rely on api usage patterns.
moreover a developer uses the apis to achieve a different goal in the context of his own program.
thus such a tool should predict his intention based on the current context of the code under editing e.g.
current api elements to provide best fitted patterns.
this paper introduces grapacc a graph based patternoriented context sensitive code completion method and tool that performs code completion based on a collected database of api usage patterns.
each pattern is represented as a graph based model that is able to capture the usages of multiple variables in different types method calls in multiple libraries control structures and their data control dependencies.
grapacc extracts the context sensitive features from the code under editing e.g.
the api elements being on focus or under modification and their relations to other code elements.
the features are then used to search and rank the patterns that are best matched with the current code.
when a pattern is chosen by a user grapacc will fill in the code based on that pattern with proper replacements of program elements in the current context of the program.
we conducted an empirical evaluation on grapacc s correctness.
the evaluation results on real world systems show that grapacc can achieve up to precision recall and f score in code completion.
we found that on average of an api s usage in a project is covered by usage patterns.
the key contributions of this paper include .
a formulation and algorithms for graph based feature extracting searching andranking of api usage patterns that are best matched with the context of the current code .
a novel algorithm for graph based code completion .
grapacc a graph based context sensitive code completion tool that takes into account the current editing context and makes use of api usage patterns and .
a comprehensive empirical evaluation method that shows the correctness and usefulness of grapacc.
section ii presents motivating examples.
sections iii vi describe our model and algorithms.
our empirical evaluation is presented in section vii.
related work is discussed in section viii.
conclusions appear last.draft1display display new display 2shell shell new shell display ... 4button button new button shell swt.push 5button.settext ok 6button.setsize new point 7button.setlocation new point ... 9shell .pack 10shell .open 11while !
shell .isdisposed if !
display.readanddispatch display.sleep 15display.dispose figure .
swt usage example ii.
m otivating examples api usage patterns.
figure shows a portion of code using swt a graphical user interface gui library to create a window containing ok button.
according to swt documentation creating a window involves two types of objects.
a display object is responsible for managing the gui events and related resources between swt and the operating system.
a shell object represents a gui window which is associated with the display object and acts as a container for other gui elements such as buttons text boxes etc.
after adisplay object display is created a shell object shell is created to form a top level window lines .
it then starts to receive and process the events via display until object shell is disposed lines .
finally object display is disposed.
according to swt documentation this usage of those swt elements the classes display shell and their methods is a correct way to perform the task of creating a top level gui window in swt.
thus this api usage lines and occurs very frequently in java code that uses swt library.
we call this correct usage an api usage pattern or a pattern for short .
this example shows a common practice in which developers reuse existing software components via libraries and their apis.
such api elements are intended to be used in some specific usage procedure i.e.
an usage pattern in order to accomplish a specific task.
thus when using libraries developers usually follow the corresponding usage patterns to achieve their goals.
aiming to reduce developers burden in remembering exact api elements and their usages as well as providing more auto completed code a code completion tool could be based on api usage patterns.
with the knowledge on usage patterns it could recommend the appropriate pattern that fits with the current context of code under editing.
for example if a developer finishes the first two lines in figure a pattern oriented code completion tool should recognize that s he is using two swt variables of types display and shell which belong to the window creation pattern.
then it could predict that s he intends to create a window and fill in the1button button new button shell swt.push 2button.settext ok 3formdata bdata new formdata 4button.setlayoutdata bdata figure .
swt usage example remaining part of the pattern lines .
providing higher volume of code such a pattern oriented tool could help to complete code faster than the single method suggestions.
alternative patterns.
figure lines illustrates an swt usage pattern for creating a button object.
a button object can be instantiated with two parameters one for its swt window container and one for the button style.
then other properties of the button could be set including its textual label via method settext its size via setsize and its location via setlocation .
swt also provides another pattern in which the layout e.g.
size and location of a button is controlled indirectly via a formdata object.
in figure instead of calling setsize and setlocation one can specify the layout information via a formdata object line and associate it with the button line .
this example shows that there exist multiple usage patterns for a specific task called alternative patterns .
alternative patterns can share or involve different api elements classes methods .
thus a pattern oriented code completion tool must be context sensitive i.e.
consider the context of the code under editing such as the currently used api elements.
for example assume that a developer wrote the code to create a button object and finished lines figure .
due to the existence of a formdata the tool could predict that s he intends to use the pattern of creating a button with a layout object.
thus the tool should recommend toward the pattern with layout i.e.
ranking it higher than its alternative.
interleaving patterns.
figure also illustrates a common case that a developer can use multiple usage patterns whose code is interleaved with one another e.g.
creating a window and a button .
this implies that a pattern oriented contextsensitive code completion tool could use the current focus position as context information to guess the user s editing intention.
then the tool should switch between those patterns for code completion depending on the current focus cursor.
for example if s he is in the middle of editing line figure the tool must recognize that the usage pattern for swt window creation is the most relevant and suggest that pattern lines .
assume that during filling the details of that pattern s he switches to create a new button as in line new button ... .
the tool must recognize the switching and suggest the button creation pattern.
graph based patterns.
as seen some api elements have strict usage orders while others do not.
for example in the button creation pattern lines figure the constructor ofbutton must be called before other methods settext setsize draft1display display new display 2shell shell new shell display ... 4button button new button shell swt.push 5formdata formdata new formdata 6button.
figure .
swt query example and setlocation .
however there is no required order among those setters.
the existence of such partial control data dependencies suggests that the patterns and the context should be modeled via graph based structures rather than sequences or sets of method calls as in existing work.
iii.
i mportant concepts we develop grapacc a graph based pattern oriented context sensitive tool for code completion.
it takes as an input a database of usage patterns and completes the code under editing based on its context and those patterns.
definition pattern an api usage pattern is a set of api elements i.e.
classes variables method calls and control structures i.e.
condition repetition with specific control and data dependencies.
a usage pattern specifies a correct usage of api elements to perform a programming task.
figure lines shows an instance of swt window creation pattern.
an instance is concrete code realizing that pattern.
a pattern contains the usage of the classes via variables methods via method calls and control structures e.g.
while if with specific orders and inter dependencies.
a pattern could be a composite one built from multiple subpatterns.
the patterns could be interleaved with each other.
definition query a query is a code fragment under editing i.e.
a sequence of textual tokens written in a programming language.
a query is generally incomplete in term of the task that is intended to achieve and might not be parsable.
figure illustrates a code fragment as a query.
the character denotes the editing cursor where a developer invokes the code completion tool during programming.
we developed a graph based model called groum to represent object usage patterns.
grapacc uses groum to represent api usage patterns and queries as follows.
definition groum a groum is a graph based model in which the nodes represent actions i.e.
method calls data i.e.
objects variables and control points i.e.
branching points of control structures such as if while for etc .
the edges represent the control and data dependencies between the nodes.
labels of the nodes are built from the corresponding names of classes methods control structures.
figure illustrates the usage patterns in section ii as groum models.
for clarity purpose we label the nodes using the simple names of classes and methods.
in the actual implementation nodes labels have their fully qualified names.display.new shell.new shell.pack shell.open shell.isdisposed display.readanddispatch display.sleep display.disposeifwhiledisplay shelldata dependencycontrol dependency data node action node control nodebutton.new button.settext button.setsize button.setlocationbutton button.new button.settextbutton button.setlayoutdataformdata.new formdataa.
b. c. figure .
swt usage patterns as seen two data nodes labeled display and shell represent two variables display and shell.
action nodes such as display.new display.readanddispatch and shell.open represent the method calls.
an edge from data node display to action node shell.new represents the data dependency while an edge from display.new toshell.new represents their control flow order.
grapacc matches the patterns to the code under editing via their features extracted from their groums and associated context sensitive information.
moreover because a query might be incomplete or not fully parsable the corresponding groum might not contain all necessary information or might not even be available.
thus grapacc also extracts the features from the texts of the query.
there are two types of features graph based features andtoken based features .
definition feature a graph based feature is a sequence of the textual labels of the nodes along a path of a groum.
a token based feature is a lexical token extracted in a query.
thesizeof a graph based feature is defined as the number of elements in its corresponding sequence.
thus in a groum a node has a corresponding graph based feature of size and an edge has a graph based feature of size .
larger features can be built from a path in the groum.
in figure 4a there are a size graph based feature a size2 graph based feature a size graphbased feature etc.
in grapacc a token based feature always has its size equal to and is used to represent the usage of a class amethod or a control structure in the current incomplete code.
for example the query for iterator is incomplete and can not be parsed into an ast.
however grapacc still extracts two tokens forand iterator and uses them to match this query to the patterns that have the usages with a forloop and an iterator variable.draftto measure the similarity of any two features grapacc defines a function sim that compares their textual similarity and the orders of their elements see section iv for details .
to compare a query against a pattern via features grapacc also takes into account the context information of the query.
such information is modeled via the contextsensitive weights associated with the features.
that is context sensitive weights measure the significance of the features in a query based on the relations of the features to the focus editing position user based factor and based on the structure of the query s groum structure based factor .
based on the similarity of the features and their corresponding context sensitive weights grapacc defines a relevance measure fitbetween a query and a pattern in order to rank the candidate patterns to a query.
the details of function fitand weights are presented next.
iv.
q uery processing and feature extraction grapacc analyzes the query q i.e.
the code under editing and extracts its context sensitive features and weights in four main steps tokenizing the input qto extract lexical tokens which could be used as token based features using partial program analysis ppa tool to parse the input code into an ast building the corresponding groum from the ast and extracting the graph based features from that groum collecting the token based features from the un parsable tokens i.e.
the tokens without associated ast node and determining the context sensitive weights for the extracted features.
tokenizing grapacc breaks the code qwithin the current method into lexical tokens records their locations and computes their distances to the editing cursor.
after tokenizing grapacc keeps the keywords related to the control structures e.g.
while if for case etc and object instantiation new .
unrelated keywords e.g.
public class void etc are not used in query formulating but kept for later code completing.
partial parsing if the current code under editing is not parsable by eclipse s java parser grapacc will use the ppa tool to handle the query.
the ppa tool as an eclipse s plugin accepts a portion of code and returns an ast with all possible type binding information.
however in some cases there might exist some unresolved nodes for example their types are undeterminable in the query.
thus they are assigned with an unknown type.
groum building grapacc constructs the corresponding groum from the ast provided by ppa in the previous step using the constructing algorithm from our prior work .
due to the incompleteness of the query code the unresolved nodes in the ast are discarded.
they are considered as tokens and used to extract token based features.
the data nodes corresponding to the variables of the data types that are not resolved to fully qualified names are kept with only simple names.
figure shows the groum built for thedisplay.new shell.new display shell button.new button formdata.new formdatafocus node figure .
graph based usage model of query in figure query example in figure .
as seen the objects shell button bdata and display are resolved to the data nodes labeled with their types shell button formdata and display respectively.
node button is denoted as the focus node because the token closest to the editing cursor is button .
feature extracting and weighting in this step grapacc extracts the graph based features from the groum built for the query and other features for the retained tokens.
feature extracting .
grapacc first maps each node in the groum built in the previous step back to the tokens built in the tokenizing step.
for example data node button in the groum drawn in figure is mapped to three tokens of the query listed in figure button line button line and button line .
the first token denotes the type annotation of the variable button corresponding to that data node and the two other tokens are the two