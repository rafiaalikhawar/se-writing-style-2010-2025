rc25300 wat1208 august computer science ibm research report detecting deadlock in programs with data centric synchronization daniel marino symantec research labs christian hammer saarland university julian dolby mandana vaziri frank tip ibm research division thomas j. watson research center p.o.
box yorktown heights ny usa jan vitek purdue university research division almaden austin beijing cambridge haifa india t. j. watson tokyo zurich limited distribution notice this report has been submitted for publication outside of ibm and will probably be copyrighted if accepted for publication.
i t has been issued as a research report for early dissemination of its contents.
in view of the transfer of copyright to the outside publisher its distributio n outside of ibm prior to publication should be limited to peer communications and specific requests.
after outside publication requests should be filled only by reprints or legally obtained copies of the article e.g .
payment of royalties .
copies may be requested from ibm t. j. watson research center p. o. box yorktown heights ny usa email reports us.ibm.com .
some reports are available on the internet at .detecting deadlock in programs with data centric synchronization daniel marino christian hammery julian dolbyz mandana vaziriz frank tipz jan vitekx symantec research labs email danlmarino yahoo.comysaarland university email c.hammer acm.orgzibm t.j. watson research center email fdolby mvaziri ftipg us.ibm.com xpurdue university email jv cs.purdue.edu abstract previously we developed a data centric approach to concurrency control in which programmers specify synchronization constraints declaratively by grouping shared locations into atomic sets .
we implemented our ideas in a java extension called aj using java locks to implement synchronization.
we proved that atomicity violations are prevented by construction and demonstrated that realistic java programs can be refactored intoajwithout significant loss of performance.
this paper presents an algorithm for detecting possible deadlock in ajprograms by ordering the locks associated with atomic sets.
in our approach a type based static analysis is extended to handle recursive data structures by considering programmersupplied lock ordering annotations.
in an evaluation of the algorithm all ajprograms under consideration were shown to be deadlock free.
one program needed ordering annotations and others required minor refactorings.
for the remaining programs no programmer intervention of any kind was required.
i. i ntroduction writing concurrent programs that operate on shared memory is error prone as it requires reasoning about the possible interleavings of threads that access shared locations.
if programmers make mistakes two kinds of software faults may occur.
data races and atomicity violations may arise when shared locations are not consistently protected by locks.
deadlock may occur as the result of undisciplined lock acquisition preventing an application from making progress.
previously we proposed a data centric approach to synchronization to raise the level of abstraction in concurrent object oriented programming and prevent concurrency related errors.
in our approach fields of classes are grouped into atomic sets.
each atomic set has associated units of work code fragments that preserve the consistency of their atomic sets.
our compiler inserts synchronization that is sufficient to guarantee that for each atomic set the associated units of work are serializable thus preventing data races and atomicity violations by construction .
our previous work reported on the implementation of atomic sets as an extension of java called aj we demonstrated that atomic sets enjoy low annotation overhead and that realistic java programs can be refactored intoajwithout significant loss of performance .
however our previous work did not address the problem of deadlock which may arise in ajwhen two threads attemptto execute the units of work associated with different atomic sets in different orders.
this paper presents a static analysis for detecting possible deadlock in ajprograms.
the analysis is a variation on existing deadlock prevention strategies that impose a global order on locks and check that all locks are acquired in accordance with that order.
however we benefit from the declarative nature of data centric synchronization in ajto infer the locks that threads may acquire.
we rely on two properties of aj i all locks are associated with atomic sets and ii the memory locations associated with different atomic sets will be disjoint unless they are explicitly merged by the programmer.
our algorithm computes a partial order on atomic sets.
if such an order can be found a program is deadlock free.
for programs that use recursive data structures the approach is extended to take into account a programmerspecified ordering between different instances of an atomic set.
we implemented this analysis and evaluated it on aj programs.
these programs were converted from java as part of our previous work and cover a range of programming styles.
the analysis was able to prove all programs deadlock free.
minor refactorings were needed in cases and a total of ordering annotations were needed all in program.
in summary this paper makes the following contributions we present a static analysis for detecting possible deadlock in ajprograms.
it leverages the declarative nature of atomic sets to check that locks are acquired in a consistent order.
if so the program is guaranteed to be deadlockfree.
otherwise possible deadlock is reported.
to handle recursive data structures we extend ajwith ordering annotations that are enforced by a small extension ofaj s type system.
we show how these annotations are integrated with our analysis in a straightforward manner.
we implemented the analysis and evaluated it on a set ofajprograms.
the analysis found all programs to be deadlock free requiring minor refactorings in two cases.
only ordering annotations were needed in program.
ii.
d ata centric synchronization with aj aj extends java with the syntax of fig.
.
an ajclass can have zero or more atomicset declarations.
each atomic sethas a symbolic name and intuitively corresponds to a logical lock protecting a set of memory locations.
each atomic set has associated units of work code fragments that preserve the consistency of their associated atomic sets.
these units of work are the only code permitted to access the atomic set s fields so only this code needs to be synchronized to ensure its consistency.
by default the units of work for an atomic set declared in a class cconsist of all non private methods incand its subclasses.
given data centric synchronization annotations the ajcompiler inserts concurrency control operations that are sufficient to guarantee that any execution is atomic set serializable i.e.
equivalent to one in which for each atomic set its units of work occur in some serial order.
one may think of a unit of work as an atomic section that is only atomic with respect to a particular set of memory locations.
accesses to locations not in the set are visible to other threads.
methods that do not operate on locations within atomic sets will not be synchronized.
we illustrate the discussion with a binary tree example.
fig.
shows a class tree with fields rootandsize rootpoints to the node that is the root of the tree.
each node has left and right fields pointing to its children as well as a value and a weight .
class tree has methods size which returns the number of nodes in the tree find for finding a node with a given value and insert for inserting a value into the tree.
the latter two methods rely on methods node.find and node.insert .tree also has methods compute which returns the weighted sum of its nodes values and copyroot which inserts the root s value into another tree passed as an argument.
we assume that the programmer wants to ensure that concurrent calls to incweight and compute on the same tree never interleave as this might trigger a race condition that causes tree.compute to return a stale value.
we now discuss how this can be achieved in aj.
tree declares an atomic set t line .
the annotations on lines have the effect of including root and size in this atomic set.
at run time each tree object has an atomicset instance tcontaining the corresponding fields.
the aj atomicset a a class or interface declaration may have multiple atomic set declarations.
atomic a annotation on instance fields and classes.
a field can belong to at most one atomic set.
annotated fields can only be accessed from the this reference.
unitfor a annotation on method arguments.
this declares the method to be an additional unit of work for the specified atomic set in the argument object.
notunitfor annotation to indicate that a method is not a unit of work for atomic sets in its declaring class.
ja this.bjannotation on variable declarations and constructor calls.
this unifies the atomic set ain the annotated variable or constructed object with the current object s atomic set b. fig.
.
data centric annotations.1class treef 2atomicset t 3private atomic t node rootjn this.tj 4private atomic t int size 5tree intv froot new nodejn this.tj v g 6intsize freturn size g 7inode find intv freturn root.
find v g 8void insert intv froot.
insert v size g 9intcompute freturn root.compute g void copyroot tree tree ftree.
insert root.getvalue g 11g 13interface inodefvoid incweight intn g 15class node implements inodef atomicset n private atomic n node leftjn this.nj private atomic n node rightjn this.nj private atomic n int value weight node intv fvalue v g intgetvalue freturn value g void insert intv f if value v weight else if v value f if left null left new nodejn this.nj v else left .
insert v 28gelsef if right null right new nodejn this.nj v else right .
insert v 31g 32g public void incweight intn fweight n g inode find intv f if value v return this else if v value return left null?null left .
find v else return right null?null right .
find v 38g intcompute f intresult value weight result left null ?
left .compute return result right null ?
right .compute 43g 44g fig.
.
ajtree example.
compiler inserts locks to ensure that the units of work for texecute atomically.
preserving the consistency of complex data structures typically requires protecting multiple objects e.g.
all of a tree s nodes with a single lock.
this can be achieved using aliasing annotations which unify the atomic sets of a tree and the different node objects into one larger atomic set.
aliasing annotations are type qualifiers so the declaration node leftjn this.nj on line specifies that the atomic set instance nof the object referenced by leftis unified with that of the current object.
likewise atomic set instance nin the node allocated on line is unified with atomic set instance tin its enclosing tree object.
aj s type system enforces the consistency of such aliasing annotations to prevent synchronization errors.
together the aliasing annotations on tree andnode ensure 245class textends threadf t tree t0 intv ftree t0 value v g public void run ftree.
insert value g tree tree intvalue 49g 51public static void main string args throws ...f tree tree new tree thread t1 new t tree thread t2 new t tree t1.start t2.start t1.join t2.join 56g57class uextends threadf u tree t1 tree t2 ftree1 t1 tree2 t2 g public void run ftree1.copyroot tree2 g tree tree1 tree2 61g 63public static void main string args throws ...f tree tree1 new tree tree2 new tree thread t3 new u tree1 tree2 thread t4 new u tree2 tree1 t3.start t4.start t3.join t4.join 68g a b fig.
.
two clients of the tree class of fig.
.
that all locations in a tree object are protected by the same lock.
fig.
a shows a client where two threads insert concurrently into a tree.
such operations will execute correctly as ajensures mutual exclusion.
note that the client code does not refer to atomic sets at all as is typical in our approach.
iii.
d eadlock detection in aj a. execution of the example recall that for any object ocreated at runtime that is of a type that declares an atomic set t there will be an atomic set instanceo tthat protects the fields in othat are declared to be int.
atomic set instances can be thought of as resources that are acquired when an associated unit of work is executed.
as we shall see shortly deadlock may arise if two threads concurrently attempt to acquire such resources out of order.
consider the program of fig.
a which creates a tree and two threads that work on it.
execution proceeds as follows when a tree object is created and assigned to variable tree on line its corresponding atomic set instance tree.t protects the rootandsize fields of the new object.
tree s constructor on line creates a node object.
the alias declaration on line causes its left right value and weight fields to be included in atomic set instance tree.t .
the object creations for t1andt2on lines are standard with no special operations for atomic sets.
once the workers start line both threads attempt to invoke insert ontree.
since insert is a unit of work for tand both threads operate on the same tree object aj s runtime system enforces mutual exclusion by taking a lock upon calling insert see sec.
v .
thus the two operations execute serially.
the join calls on line wait for the workers to finish.
now consider the code in fig.
b which is similar except that two tree objects are created and assigned to variables tree1 and tree2 line .
then two worker threads t3 and t4 are created on lines .
note that each worker thread is passed