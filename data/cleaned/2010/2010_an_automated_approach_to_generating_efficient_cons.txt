see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation an automated approach to generating efficient constraint solvers article in proceedings int ernational conf erence on softw are engineering june .
ic se.
.
citations 12reads author s including dharini balasubr amaniam univ ersity of st andr ews publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y dharini balasubr amaniam on may .
the user has r equest ed enhanc ement of the do wnlo aded file.an automated approach to generating efficient constraint solvers dharini balasubramaniam christopher jefferson lars kotthoff ian miguel peter nightingale school of computer science university of st andrews st andrews uk dharini caj21 lk223 ijm pwn1 st andrews.ac.uk abstract combinatorial problems appear in numerous settings from timetabling to industrial design.
constraint solving aims to find solutions to such problems efficiently and automatically.
current constraint solvers are monolithic in design accepting a broad range of problems.
the cost of this convenience is a complex architecture inhibiting efficiency extensibility and scalability.
solver components are also tightly coupled with complex restrictions on their configuration making automated generation of solvers difficult.
we describe a novel automated model driven approach to generating efficient solvers tailored to individual problems and present some results from applying the approach.
the main contribution of this work is a solver generation framework called dominion which analyses a problem and based on its characteristics generates a solver using components chosen from a library.
the key benefit of this approach is the ability to solve larger and more difficult problems as a result of applying finer grained optimisations and using specialised techniques as required.
keywords generative programming constraint solvers software architecture model driven development i. i ntroduction combinatorial problems appear in a wide variety of settings that impact all of our lives from institution timetabling and factory scheduling to industrial and experimental design configuration and combinatorial mathematics.
constraint solving offers a means by which solutions to such problems can be found efficiently and automatically.
there are two phases to solving combinatorial problems using constraint technology.
in the first phase the problem is modelled as a set of decision variables and a set of constraints on those variables that a solution must satisfy.
a decision variable represents a choice that must be made in order to solve the problem.
the domain of potential values associated with each decision variable corresponds to the options for that choice.
in the case of timetabling one might have two decision variables per lecture one representing its time and the other its venue.
the second phase uses a constraint solver to find solutions to the model assignments of values to decision variables satisfying all constraints e.g.
a valid timetable .
constraint solvers typically employ a systematic backtracking search through the space of partial assignments in order to find solutions.a major challenge facing constraints research is to deliver constraint solving that scales easily to problems of practical size.
current constraint solvers such as choco eclipse gecode ilog solver or minion are monolithic in design accepting a broad range of models.
this convenience comes at the price of a necessarily complex internal architecture resulting in significant overheads and inhibiting efficiency and scalability.
each solver may thus incorporate a large number of features many of which will not be required for most constraint problems.
the complexity of current solvers also means that it is often prohibitively difficult to incorporate new techniques as they appear in the literature.
a further drawback is that current solvers perform little or no analysis of an input model and the features of an individual model cannot be exploited to produce a more efficient solving process.
to mitigate these drawbacks constraint solvers often allow manual tuning of the solving process.
however this requires considerable expertise preventing the widespread adoption of constraints as a technique for solving the most challenging combinatorial problems.
the components of a constraint solver are also usually tightly coupled with complex restrictions on how they may be linked together making automated generation of different solvers difficult.
in this paper we describe the development and evaluation of a novel and automated approach to improving the scalability of constraint technology while simultaneously removing its reliance on manual tuning by an expert a constraint solver generator framework called dominion that for a given problem produces a solver tailored to that problem.
there are two key benefits in generating a solver from scratch it will enable fine grained optimisations that are not possible for a general solver allowing the solution of much larger more difficult problems and it will enable the utilisation of many techniques in the literature that although effective in a limited number of cases are not suitable for general use leading to more powerful solvers.
these benefits lead to faster and more scalable solvers.
in addition the automated approach simplifies the task ofmodelling constraint problems by removing the need to manually optimise specifications.
a few current solvers such as the minion solver mentioned earlier allow some specialisation.
there are variable types in minion and each constraint is compiled for two parameters each of which can be a different variable type.
each constraint is therefore compiled times.
adding one extra option to variables doubling the number of variable types increases compilation time fourfold.
in contrast dominion compiles only those variables and constraints that are required for each problem.
in order to manage the complex dependencies on the compatibility and configuration of components that constitute a solver we adopt a model driven approach.
the generation process in dominion is driven by the software architecture of the target solver.
software architecture provides a highlevel model of a system in terms of its constituent elements and their interactions as well as properties that have to hold among the elements .
the specified properties can be checked for consistency at the architectural level as well as against an implementation.
thus software architecture forms a useful basis for the design implementation and evolution of systems.
a brief outline of the implications of the dominion approach in particular the complex dependencies of solver components on the specification of software architecture of the solver is provided in .
as well as architecture driven development we utilise concepts from generative programming ai domain specific software engineering and product lines in the dominion approach.
to achieve the goal of generating an efficient constraint solver for a given problem we begin by specifying an architectural element or component corresponding to that problem.
an architecture of the solver is constructed from this seed as a directed acyclic graph using pre defined components from a library that satisfy the properties required by existing nodes in the graph.
thus each new node represents a potential variation point in the architecture.
each dag thus produced will model a valid solver but not necessarily an efficient one.
established ai approaches are used to determine the best option for each variation point.
the chosen instantiation forms the software architecture of the desired solver.
the paper is structured as follows.
we use the n queens problem specified in section ii throughout the paper to illustrate the dominion approach.
the challenges of automatically generating constraint solvers are discussed in section iii.
section iv provides a brief overview of the grasp adl used to represent the solver architecture while section v outlines the generative process.
the unique features of dominion which would be difficult to implement in monolithic solvers are discussed in section vi.
the current status of the framework and results from evaluating the performance of solvers generated by dominion against an existing solver are given in section vii.
section viii describes other attempts to fully or partially generate problem specific solvers and differentiates them from our work.
we conclude the paper with some thoughts on further work in section ix.
ii.
a nexample n q ueens n queens is the problem of placing nqueens on an n nchessboard such that no two queens attack each other.
it will be used in the remainder of the paper to illustrate the dominion approach to automating the generation of specialised constraint solvers.
it is also used along with other problems to evaluate the performance of generated solvers against existing work in section vii.
listing shows the n queens problem expressed in the dominion input language dil which is a modelling language that can express any constraint problem.
in this example we observe that every row of the chessboard has exactly one queen on it and we represent the position of that queen using a decision variable with domain ...n .
constraints are then added to rule out any pair of queens attacking each other.
a constraint problem is expressed as a list of parameters given decision variables find their domains and finally a list of constraints and constraint comprehensions that any solution must satisfy following such that .
a constraint comprehension is a compact way of specifying a set of parameterised constraints for a range of parameter values.
a problem class such as n queens has a set of parameters specifying dimensions or other aspects of the problem.
in this case there is a single parameter nspecifying the dimensions of the chessboard n n and the number of queens to be placed on it.
before solving all parameters are substituted in to create a problem instance .
n queens has a one dimensional matrix of decision variables named queens .
the matrix is first dimensioned with thedimkeyword .
the explicit dimensioning is necessary to allow for cases in which only some of the variables in the matrix are used.
this process can be compared to lazily allocating memory in a programming language if the memory is not used it is not actually allocated.
then a find statement is used to insert decision variables into the matrix.
in this case all positions in the matrix have a decision variable with domain ..n. following the key words such that each constraint or comprehension is given a unique name in the dil in this case alldifferent diagonals1 anddiagonals2 .
constraints are specified as con arg1 arg2 ... where conis one of a fixed but extensible set of constraint identifiers.
arguments may be matrices single decision variables or constants.
finally constraints like many other structures in dil may be placed in a comprehension as in diagonals1 anddiagonals2 .
the first constraint in listing ensures that no two queens are in the same column.
it uses the alldiff constraint language dominion .
given n int .. dim queens int find queens int ..n such that alldifferent alldiff queens j i queens i in ..n j in i ..n i j queens i in ..n j in i ..n listing .
the n queens constraint problem which ensures all variables in an array take different values.
the two constraint comprehensions ensure queens cannot attack each other along the diagonals by ensuring the difference between the queens in columns iandjis neither i jorj i. a dil specification may contain