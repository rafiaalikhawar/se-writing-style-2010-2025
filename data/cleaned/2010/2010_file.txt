statically checking api protocol conformance with mined multi object specifications michael pradel department of computer science eth zurich switzerlandciera jaspan jonathan aldrich institute for software research carnegie mellon universitythomas r. gross department of computer science eth zurich switzerland abstract programmers using an api often must follow protocols that specify when it is legal to call particular methods.
several techniques have been proposed to find violations of such protocols based on mined specifications.
however existing techniques either focus on single object protocols or on particular kinds of bugs such as missing method calls.
there is no practical technique to find multi object protocol bugs without a priori known specifications.
in this paper we combine a dynamic analysis that infers multi object protocols and a static checker of api usage constraints into a fully automatic protocol conformance checker.
the combined system statically detects illegal uses of an api without human written specifications.
our approach finds bugs and code smells in mature real world java programs with a true positive rate of .
furthermore we show that the analysis reveals bugs not found by state of the art approaches.
keywords typestate static analysis specification mining i. i ntroduction many application programming interfaces apis impose constraints on clients for example by prescribing particular orders of method calls.
violating such constraints can lead to unexpected behavior incorrect results and even program crashes.
unfortunately most api usage constraints are not formally specified making it difficult for programmers to learn the constraints and challenging for program analyses to find violations.
as a motivating example consider java source code we found in a commonly used benchmark program figure .
the program iterates over a list using an iterator and attempts to remove elements from the list.
this usage of java s collection api leads to a runtime exception programmers must not modify a collection while iterating over it.
as the example shows api usage constraints are often subtle and violations of them can be hard to detect.
automatic bug finding techniques based on mined specifications are a promising approach to find api usage bugs with little effort.
this paper focuses on specifications of legal method call sequences through finite state machines fsms called api usage protocols .
while existing work focuses on checking programs against mined protocols for a single object this paper presents an automatic bug finding technique based on mined multi object protocols.considering multiple interacting objects allows our approach to specify and check constraints that are not expressible in single object protocols.
consider the following examples from the java standard library while iterating over a collection with an iterator one must not modify the collection .
figure violates this constraint.
to retrieve the entries of a zipfile one must obtain anenumeration over all entries iterate through it and finally close the zipfile .
threads can synchronize via condition s and reentrantlock s. before calling the condition s waiting or signaling methods one must acquire the lock.
eventually the lock must be released.
when wrapping resource like objects such as a filereader wrapped into a bufferedreader closing the wrapping resource is sufficient as it will implicitly close the wrapped resource.
all examples are taken from the protocols mined in the evaluation of this work.
despite this variety we henceforth focus on collections and iterators to simplify the presentation.
checking programs against multi object protocols can reveal more bugs than a single object approach.
for example our approach detects the concurrent modification in figure .
this bug cannot be found with a protocol specifying only iterator s orcollection s it is only expressible with a protocol specifying both together.
in addition to finding more bugs a multi object approach avoids false positives caused by the limited scope of singleobject protocols.
for example calls to iterator.next should be preceded by iterator.hasnext collection.size or collection.isempty to avoid requesting a non existing element.
a single object iterator protocol specifying the first possibility leads to false positives when the other two possibilities are used.
in contrast a multi object protocol can specify all possibilities.
the bug detection technique presented in this paper is the result of combining two analyses a dynamic miner of multiobject protocols and a static checker of api usage constraints fusion .
figure provides an overview of our approach.
the dynamic specification miner runs training programs to infer specifications from program traces.
theselinkedlist pinconnections ... iterator i pinconnections.iterator while i.hasnext pinlink curr pinlink i.next if ... pinconnections .remove curr figure .
illegal usage of a collection and an iterator found in the dacapo benchmarks .training programstarget program warningsdynamic protocol minertranslationstatic checker fusion prunermulti object api usage protocolsrelationshipbased specificationslegal illegal calls figure .
overview.
the components to translate mined protocols into relationship based specifications and to prune warnings are the primary technical contributions of this paper.
api usage protocols are translated into relationship based specifications suitable for the static checker.
the static checker checks the code of a target program against the specifications and classifies api method calls as potentially legal or illegal.
some of the potentially illegal calls may be due to incomplete protocols so a pruner uses heuristics to remove results that are likely false positives.
the final set of warnings is then presented to the user for manual inspection.
while most related approaches combine mining and checking into a single analysis we build upon two special purpose analyses.
the main reason is that an analysis made for mining specifications is not necessarily the best choice for checking programs.
in particular all in one approaches typically do not guarantee that each reported deviation from a common pattern can actually occur at runtime.
our work avoids this source of false positives by using a complete static checker.
the key difficulty in blending the protocol miner with the static checker is to connect the two formalisms used for encoding specifications.
while the miner produces fsms labeled with method calls the checker requires relationshipbased annotations of api methods.
we present a translation between these two formalisms which is the foundation of the presented bug finding technique.
our approach finds bugs without any a priori known specifications and without human refinement or selection of the mined protocols.
the price for this automation is that the combined analysis is neither sound nor complete mined protocols can be incomplete introducing false positives and incorrect introducing false negatives.
our results show both problems to be manageable in practice.
to evaluate our work we analyze the programs of the dacapo benchmark suite a .
mloc collection of open source java programs.
our system detects issues bugs and suspicious code smells with a true positive rate of .
this precision is higher than that of comparable state of the art approaches in in in and we show by direct comparison that our approach reveals bugs that these approaches cannot find.
to assess which bugs our approach misses we randomly seed bugs into the programs of which the system finds .
we attribute the remaining to four types of false negatives.
furthermore we report on a sensitivity analysis of the pruning heuristics.
finally we find that multi object protocols are relevant in practice of the mined protocols are multi object protocols and of the issues our system detects are found only with a multi object protocol.
in summary this paper contributes the following a fully automatic technique to find multi object protocol bugs.
it requires neither tests to run the target program nor formal specifications.
a translation between fsm based mined specifications and a relationship based api specification formalism which enables the first contribution.
pruning techniques to improve precision.
empirical evidence that multi object protocols are relevant in practice.
empirical evidence that combining a heuristic dynamic specification miner with a precise static checker can reveal serious problems in well tested programs with a good true positive rate.
ii.
b ackground our approach uses a dynamic specification miner and a static checker to respectively produce and check specifications of multi object protocols.
both analyses divide a protocol into two parts.
the first part determines the applicability of a protocol and the second part describes the constraints imposed by the protocol.
a. specification mining and api usage protocols we use a dynamic specification miner that extracts api usage protocols from training programs .
any existing api client can serve as a training program.
a protocol consists of a deterministic finite state machine and a set of typed protocol parameters.
states represent the common state of multiple objects or for single object protocols the state of a single object.
transitions are labeled with method signatures that are annotated with protocol parameters naming the receiver the method parameters and the return value.
the protocol miner analyzes execution traces that is sequences of method calls and returns.
at first the miner extracts subtraces that contain calls to a particular object o to objects passed to oas an argument and to objects returned byo.
then all subtraces for a set of receiver types are summarized into a protocol in such a way that each subtrace is accepted by the protocol.
the mined protocols distinguish two kinds of states setup states and liable states .
the setup states establishwhich objects interact in the protocol by binding objects to protocol parameters.
the liable states describe constraints on method calls that a programmer ought to respect.
the miner constructs protocols in such a way that the set of parameters bound at a state is unambiguous.
states at which all parameters are bound are liable states all other states are setup states.
figure shows an api usage protocol describing the interplay of a collection cand an iterator i. the protocol specifies how to use the iterator call hasnext before next and that updating the collection invalidates the iterator.
calling the method iterator onc which returns i establishes the interaction between these two objects.
therefore the later states and are all liable states.
the table in figure gives the set of bound protocol parameters for each state.
b. relationship based static checking this work uses fusion a relationship based static analysis to check api clients against specifications over multiple objects.
fusion encodes usage constraints based onrelationships between objects.
a relationship is a userdefined uninterpreted predicate across objects.
for example a binary relationship rcontains list element can express that an object of type list contains another object of type element such as rcontains list element .
if a relationship predicate is true we say that the objects are in the relationship.
likewise to say that the objects are not in a relationship means that the relationship predicate evaluates to false.
in fusion api methods are specified with requirements and effects.
a requirement is a logical proposition over relationship predicates that describes a precondition on a method.
for example list.remove element may require that rcontains list element holds.
an effect is a postcondition that describes how the truth of relationship predicates changes after calling a method.
for instance list.remove element may have the effect to remove list element from rcontains .
both requirements and effects are guarded by a trigger a logical proposition that describes when the requirement or effect applies.
a complete specification of a protocol in fusion is a set of relationships a set of effects and a set of requirements on the relevant methods.
based on specifications of api methods fusion performs an intraprocedural analysis of api clients to check whether they respect the usage constraints.
for each call to a method with a specification the analysis checks whether all triggered requirements are fulfilled and applies all triggered effects.
we use a complete variant of fusion which guarantees that any bug found will actually occur dynamically.
1fusion can only make this guarantee to the degree that it is given precise aliasing information see section v c for how this affects results in practice.
45c new collection c.update c.update c.update c.update i c.iterator i.hasnext i.hasnext i.next state bound protocol parameters fg f cg fc ig fc ig fc ig figure .
protocol describing how to use a collection and an iterator.
the call c.update summarizes calls that modify the collection for example c.add orc.remove .
liable states have a gray background.
1collection c ... 2iterator i c.iterator 3if i.hasnext system.out.println i.next current state unknown 6c.update legal invalidates iterator 7if i.hasnext bug iterator not valid anymore system.out.println i.next figure .
the state in line cannot be determined because different paths lead to it.
iii.
f rom mined protocols to checkable specifications this section presents a translation of fsm based protocols into relationship based constraints suitable for checking programs.
a more detailed and formal description is given in .
the main goal of the translation is to detect protocol violations while reporting few false positives.
that is the generated specifications should cause a warning only if the analyzed source code actually violates a protocol.
we use figure as a running example throughout this section.
a. challenges we must deal with two main challenges the first being common to all static analyses and the second being specific to multi object checking limited static knowledge static analysis inherently lacks precise knowledge about which program path is taken and as a result may miss bugs or report false positives.
for example figure shows a piece of source code where static analysis cannot determine the protocol state in line .
after the call to hasnext the protocol is known to be at state .
the branch creates two paths one path on which next is called leading back to state and another path on which we stay at state .
because static analysis cannot determine which path is taken the state in line is unknown.
our combined analysis should nevertheless find the call in line to be legal and detect the protocol violation in line .
object interactions checking multi object protocols is challenging because calling a method on one object caninfluence the state of other objects.
for example the call toupdate in line does not refer to the iterator i but directly affects its state.
this dependence is implicit in mined multi object protocols where a state is the common state of all involved objects.
b. naive approach states as relationships an obvious but insufficient way to map protocols to relationships is to have a unary relationship per state and to track each object s state by updating these state relationships .
for this naive approach we create an effect for each transition leading from state xto state y this effect removes the object from rxand adds it to ry.
to check whether calling a method is legal we require that the receiver object is in a relationship representing a state where the method is enabled.
for example calling method i c.iterator requires that r2 c the call has the effect of removing c from r2and of adding canditor3.
unfortunately the approach does not deal well with the challenges illustrated in figure .
the lack of static knowledge whether line is executed leads to a loss of knowledge in line because both r3 i andr4 i are possible but not both fusion concludes to know nothing about i. thus the analysis cannot detect that line is illegal.
furthermore the approach is oblivious of the relationship between candi so that in line i s state is not changed.
this limitation is another reason why the naive approach cannot find the bug in line .
c. revised approach triple bookkeeping given a set of protocols how can we generate relationship based specifications in a way that addresses the above challenges?
we extend the approach described in section iii b by using relationships to reason about three aspects of objects with respect to a protocol.
we call the idea underlying this revised approach the triple bookkeeping principle.
first we keep track of whether calling a method is allowed with a method relationship .
this is a unary relationship for a method of the protocol.
if an object is in a method relationship it means that one can legally call the corresponding method on this object.
the protocol in figure has four method relationships the types in parentheses specify which objects can be in a relationship rnext iterator rhasnext iterator rupdate collection riterator collection there is no method relationship for constructor calls because a newly created object cannot be in any relationship before the constructor call.
second we keep track of the current state of an object or a set of objects with state relationship s. the semantics of a state relationship is that if an object or a set of objectsis in this relationship we know these objects to be at the corresponding state.
in contrast to the naive approach the state relationship here is over all objects that are bound at that state.
the states of the protocol in figure translate into four state relationships r2 collection r3 collection iterator r4 collection iterator r5 collection iterator there is no state relationship for the initial state because no variables are bound at this state.
third we keep track of which objects interact as part of a multi object protocol.
for this purpose we create a protocol relationship over all protocol parameters.
the semantics of the protocol relationship is that if a set of objects is in this relationship we know these objects to interact with each other in the protocol.
for example we create a binary relationship rprot collection iterator for the two object protocol in figure .
the three kinds of relationships serve as data structures for the static analysis.
the analysis uses them to check whether method calls are allowed and to represent the effects of method calls.
checking requirements for method calls to check whether calling a method is legal we require that the receiver is in the corresponding method relationship.
for example to call i.next we require that rnext i is true.
the requirements imposed by a protocol are only valid if the current state is a liable state.
therefore we guard requirements with the protocol relationship ensuring that the involved objects interact in the protocol and that the protocol is in a liable state.
for example the requirement on calling i.next is guarded by rprot c i .
this can be thought of as a logical precondition of the form 8c rprot c i rnext i making effects calling a method can have effects on the current state on the currently enabled and disabled methods and on the binding of objects to protocols.
we create specifications that reflect these effects by adapting the corresponding relationships.
for example calling i c.iterator as shown in figure influences the state maintained by the analysis as shown in table i. knowing that a particular method is called may not be sufficient to determine which effects to apply and which requirements to check because a single method can label multiple transitions.
for example calling c.update at state leading again to state has different effects than calling the same method at state leading to state .
we handle this problem by guarding effects with triggers on state relationships.
in the example for c.update the translation creates two constraints in fusion one triggered byr2 c and the other triggered by r3 c i .table i example effects from calling i t e r a t o r .
protocol effects of calling effects on relationships i c.iterator move to state .
set r3 c i to true set r2 c r4 c i andr5 c i to false.
enable methods i.hasnext andc.update disable methods i.next andc.iterator .set rhasnext i and rupdate c to true set rnext i andriterator c to false.
establish the interaction between c andi.setrprot c i to true.
our revised approach meets the challenges mentioned in section iii a. we deal with limited static knowledge by maintaining both the current state and the currently enabled and disabled methods.
this approach allows the analysis to recover knowledge that has been lost when merging paths.
even when the current state is unknown the analysis may still know about currently enabled methods and continue the analysis based on this information.
the translation addresses the problem of interacting objects by representing states at which nobjects are bound by n ary state relationships.
furthermore we represent the interaction of objects through the protocol relationship.
by using the protocol relationship as a trigger the analysis can apply effects on all involved objects even if a method