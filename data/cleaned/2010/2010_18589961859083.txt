test generation to expose changes in evolving programs dawei qi abhik roychoudhury zhenkai liang national university of singapore dawei abhik liangzk comp.nus.edu.sg abstract software constantly undergoes changes throughout its life cycle and thereby it evolves.
as changes are introduced into a code base we need to make sure that the effect of the changes is thoroughly tested.
for this purpose it is important to generate test cases that can stress the effect of a given change.
in this paper we propose anautomatic test generation solution to this problem.
given a changec we use dynamic symbolic execution to generate a test input t which stresses the change.
this is done by ensuring i the change cis executed by t and ii the effect of cis observable in the output produced by the test t. to construct a change reaching input our technique uses distance in control dependency graph to guide path exploration towards the change.
then our technique identifies the common programming patterns that may prevent a given change from affecting the program s output.
for each of these patterns we propose methods to tune the change reaching input into an in put that reaches the change and propagates the effect of the changeto the output.
our experimental results show that our test generation technique is effective in generating change exposing inputs for real world programs.
categories and subject descriptors d. .
testing and debugging testing tools symbolic execution general terms experimentation reliability keywords software evolution test generation symbolic execution .
introduction regression testing is one of the most commonly known software engineering activities for developing reliable software.
in simple terms it stresses program changes as a program evolves from one version to another checking whether new functionality introduced permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.by the changes is correct and whether the changes result in errors in existing functionality.
often regression testing involves re testingusing a new test suite containing both existing test cases and newtest cases as the program evolves.
for re testing with existing test cases because the test suite of a program is often huge it is inefficient to test the changed program with all existing test cases.
most of the past research efforts in regression testing focus on this inefficiency issue and provide so lutions via test selection selecting a subset of the tests to be run or test prioritization changing the order in which a set of given tests is run .
however the evolution of a program often involves addition of new functionality and thus the test suite should also evolve withthe evolution of the program.
in this aspect the key challenge is to generate test cases related to the changes.
recent work has studied test suite augmentation for evolving software.
themain task in test suite augmentation is to find new test cases thatstress the program changes and affect the program output.
suppose a program p with a test suite t evolves to a program p prime i.e.
pischanged to produce p prime.
a test suite augmentation method should generate test cases that make the effect of the changes visible in terms of observable program output.
if these test cases do not appear in the existing test suite t we add them to t. let us now examine an intuitive way of generating test cases for stressing program changes.
consider an output variable outin programs pandp prime and let the inputs of pandp primebein1 in2 ... andink.
by performing a strongest post condition computation using symbolic execution on program p we represent the output variable outinpas a formula in1 i n ... i n k .
similarly by performing a strongest post condition computation on programp prime we represent the variable outinp primeas another formula prime in1 i n ... i n k .
we can then solve in1 i n ... i n k negationslash prime in1 i n ... i n k and the solutions are test cases assignments of values to inputsin i n ... i n k that make the output values different in the two programs.
although the above approach is straightforward it does not scale.
since we need to perform static symbolic execution on the program rather than dynamic symbolic execution on an execution path ofthe program it is difficult for the approach to scale up to large real world programs.
in this paper we develop a scalable approach fortest suite augmentation.
our approach builds on the execute infectpropagate pie paradigm the new tests should i execute the program changes ii infect the program state and iii propagatethe infection to the output.
from a high level our approach works in two steps.
the first step is to generate an input satisfying the execute property in the 1intx input v ariable 2inty 3into output variable input x 7if x 8y change y if x y o y else o else o if x o output o a example programentry exit1475 b control flow graphentry exit c control dependence graph figure a motivating example to illustrate our approach.
pie paradigm.
given a change c in source code from one program version to another we find a path that reaches cin the control flow graph.
we then perform symbolic execution along the path to find an input tthat makes the program execute the path leading to c. the second step of our approach aims to generate test cases thatsatisfy the infect and propagate properties in addition to the execute property.
since any infection in program states is reflected as different variable values after the change in the two programversions we observe that state infection and propagation may be avoided if i variables affected directly indirectly by a programchange are defined but not used or ii the uses of affected variable cannot propagate the change effect forward by affecting other variables .
if an assignment of some affected variable vis not used in the execution of test t we find a new test t prime aided by symbolic execution along a path that can execute the uses of v. if the use of variable vdoes not propagate the change effect forward we find a new test t primethat can propagate the effect in v. the preceding describes our method in a nutshell.
the key to the method s efficiency lies in our strategy in avoiding symbolic execution on programs.
our approach performs every symbolic execution along a program path.
note that symbolic execution along a program path has additional overhead in enumerating and search ing for the right path.
we use various analysis methods to guideus to the right path.
when trying to execute the change the shortest path in the control dependency graph guides us to efficiently locate and construct a path to the change.
when trying to propagatethe change effect we identify the reasons for which the propaga tion terminates and propagate the change effect to program outputwhile detecting branch correlations on the fly which allows us to avoid infeasible program paths .
performing symbolic execution along a path also helps us avoid the memory alias problem since the symbolic execution is along a program path all memory