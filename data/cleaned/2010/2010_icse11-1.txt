mining message sequence graphs sandeep kumar siau cheng khoo abhik roychoudhury david lo national university of singapore singapore management university sandeep khoosc abhik comp.nus.edu.sg davidlo smu.e du.sg abstract dynamic specification mining involves discovering softwar e behavior from traces for the purpose of program comprehension and bug detection.
however mining program behavior from execution traces is difficult for concurrent distribut ed programs.
specifically the inherent partial order relatio nships among events occurring across processes pose a big challenge to specification mining.
in this paper we propose a framework for mining partial orders so as to understand concurrent program behavior.
our miner takes in a set of concurrent program traces and produces a message sequence graph msg to represent the concurrent program behavior.
an msg represents a graph where the nodes of the graph are partial orders represented as message sequence charts.
mining an msg allows us to understand concurrent program behaviors since the nodes of the msg depictimportant phases or interactionsnippets invol ving several concurrently executing processes.
to demonstrate the power of this technique we conducted experiments on mining behaviors of several fairly complex distributed sys tems.
we show that our miner can produce the corresponding msgs with both high precision and recall.
categories andsubject descriptors d2.
requirements specifications methodologies general terms algorithms design experimentation keywords specification mining distributed systems .
introduction software is developed to cater to a specific set of requirements that are dictated by real life problems or business permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
icse may waikiki honolulu hi usa copyright acm ... .
.needs.
however a formal documentation of the software specification the intended behaviors that the software is supposed to capture is often missing even though it is essential to the design implementation and testing phases of software development.
moreover formal software specifica tions are crucial for the maintenance of legacy software.
as any software project team would agree the cost for software maintenance is usually much higher than the initial software development cost.
the cost of maintaining software and managing its evolution is said to account for more than of the total cost of a software project prompting certain authors to call it a legacy crisis .
the absence of any semi formal and abstract representation in many development processes makes it difficult for users of the system to understand and appreciate its accurate behavior.
in addition several systems that follow recommended requirements gathering and design practises during early stages deviate from their early specifications as development and maintenance progresses.
this deviation is a result of both errors in the implementation and changes in the requirements themselves.
as a result even if a software specification is available it may not reflect the behaviors of the latest version of the program.
dynamic specification mining is a dynamic program analysis method to automatically infer the specification of a program from its execution traces.
the mining of various specification formats such as automata and temporalrules hasbeenstudied.
ingeneral specificat ion mining techniques employ data mining or machine learning techniques on execution traces to generate models that are useful in program verification.
however these specification mining techniques have primarily been designed with sequential programs in mind.
in order to apply such techniques on distributed systems the execution of each component has to be analyzed in isolation from rest of the system.
in reality the components of a distributed system do not function in isolation but rather communicate and collaborate at several points of their execution.
very often specifying how components interact becomes a crucial part of input traces dependency graphs mined basic mscsmsg identify basic mscsautomaton learningconvert to partial order figure stages in the proposed mining framework.
a sample execution traces inputs to our msgminer b mined msg output from our msgminer figure banking system example the design of distributed system.
in order to express such behavior specification languages such as uml sequence diagrams or message sequence charts mscs are commonly used e.g.
see for an early work on mining sequence diagrams .
however sequence diagrams only represent one scenario in the execution of a concurrent distributed soft ware it does not capture the complete specification of the program s behavior.
in this paper we study this problem.
we propose msgminer a framework to discover specifications of distributed systems as message sequence graphs msgs .
an msg is a directed graph having an msc at each of its vertices.
these mscs referred to as basic mscs only describe an interaction snippet in the system s execution.
figure describes the transformations performed bymsgminer to construct an msg.
we convert each execution trace to a partial order or dependency graph by i considering the individual control flows across differen t processes and ii marking the dependencies between a send event and its corresponding receive.
we then analyze these dependency graphs to find largest frequently recurring portions which then appear as the basic mscs in our mined model.
the basic mscs constitute the nodes of our mined msg model.
these nodes are then connected up using automata learning techniques.
our approach thus involves a combination of automata learning and mining of partial orders.
consider a hypothetical distributed banking system in which a user client interacts with a distant portal that in turn relies on a database at a separate location.
figure a shows threesampletraces collectedfrom executionsofsuch a system.
figure b shows what an msg mined from traces would appear like.
the mined msg is not an exact representation of the set of traces but instead a generalized mode l of the system suggesting many more possible scenarios.
the main contribution of this paper is our framework for mining inter process or inter component concurrent sy stem specifications in the form of a message sequence graph msg .
conventional mining methods have focused on either intra process specifications where the control flow in side each process is mined as an automaton or rule based specifications where system behavior is summarized as temporal properties either in textual form or in visual form suc h as live sequence charts .
it is worthwhile to emphasize that our focus on mining for msgs involves a fundamental conceptual shift from mining of live sequence charts lscs .
this is because lscs visually describe properties which must hold every system execution whereas msgs are a complete description of the global system behavior.
through the mined msg model we emphasize the interaction snippets or commonly executed protocols across the processes and these get captured as the nodes or the basic mscs in our mined msg model.
by understanding these figure a schematic msc and its partial order.
frequently occurring interaction snippets a programmer c an understandthecommon concurrentinteractions andinwhat sequence they occur thereby getting a clear first cut understanding of the behaviors of a concurrent program.
we evaluated our msg mining framework via case studies on real life distributed software.
it was found that the mining framework discovers msg specifications that are easy to comprehend.
moreover the mined msg models compare favorably in terms of precision recall w.r.t.
manua lly constructed models.
.
background message sequencecharts mscs arecommendationfrom itu have traditionally played an important role in soft ware developmentandbeenincorporated intomodelling languages such as room sdl and uml .
the basic msc syntax consists of a set of vertical lines each denot ing a process or a system component internal events representingintraprocess executionandannotateduni directi onal arrows denoting inter processes communication.
figure shows a simple msc with two processes m1andm2are messages sent from ptoq.
semantically an msc denotes a set of events message send message receive and internal events corresponding to computation andprescribesapartialorderovertheseeven ts.
this partial order is the transitive closure of a the total order of the events in each process1and b the ordering imposed by the send receive of each message.
.
it is also understood that arrows depicting the inter process communication is either a horizontal line or one that is slanting downwards.
the events are described using the following notation.
a send of message mfrom process pto process q is denoted as an bracketle tp!q m an bracketri ht.
the receipt by process qof a message msent by process pis denoted as an bracketle tq?p m an bracketri ht.
consider the chart in figure .
the total order for process pis an bracketle tp!q m1 an bracketri ht an bracketle tp!q m2 an bracketri htwheree1 e2denotes that event e1 happens before event e2.
similarly for process qwe have an bracketle tq?p m1 an bracketri ht an bracketle tq?p m2 an bracketri ht.
for themessages we have an bracketle tp!q m1 an bracketri ht an bracketle tq?p m1 an bracketri htand an bracketle tp!q m2 an bracketri ht an bracketle tq?p m2 an bracketri ht.
the transitive closure of these four ordering relations defines the partial order of the chart.
note that it is nota total order since from the 1time flows from top to bottom in each process.
2the send event of a message must happen before its receive event.transitive closure we cannot infer that an bracketle tp!q m2 an bracketri ht an bracketle tq?p m1 an bracketri ht or an bracketle tq?p m1 an bracketri ht an bracketle tp!q m2 an bracketri ht.
thus in this example chart the send ofm2and the receive of m1can occur in any order.
the partial order suggested by the msc in this example is also shown in figure .
the vertical lines representing the independent processes or threads whose interactions we capture are also referred to aslifelines.
mscs can be formally defined as follows.
definition .
msc .
an msc mcan be viewed as a partially ordered set of events m l el l l wherelis the set of lifelines in m elis the set of events in which lifeline ltakes part in m. is the alphabet of send and receive event labels and el l l is a function assigning each send or receive event a label.
is the partial order over the occurrences of events in el l lsuch that lis the linear ordering of events in el which are ordered top down along the lifeline l smis an ordering on message send receive events in el l l. if es an bracketle tp!q m an bracketri htand the corresponding receive event is er with er an bracketle tq?p m an bracketri ht we have es smer.
is the transitive closure of l uniontext l l land sm that is l uniontext sm concatenation of msgs can be defined in two different manners.
for a concatenation of two mscs say m1 m2 all events in m1must happen before any event in m2.
in other words it is as if the participating processes synchro nise or hand shake at the end of an msc.
in msc literature it is popularly known as synchronous concatenation .
on the other hand asynchronous concatenation performs the concatenation at the level of lifelines or processes .
thus f or a concatenation of two mscs say m1 m2 any participating process say interface must finish all itsevents in m1prior to executing any event in m2.
for the rest of this paper we remain faithful to the latter definition of concatenation.
an msc of our definition is suited to specify a single execution scenario.
a complete specification of a system would therefore require multiple mscs.
a large number of mscs will be required to describe most non trivial systems.
for this reason msc standards include high level message sequence charts hmscs that make it easy to define and visualize large collections of mscs.
hmscs are hierarchical graphs that have as nodes either a basic msc or a lower level hmsc chart.
we limit our mining exercises to the simpler yet semantically equivalent representation of message sequence graphs .
formally an msc graph or msg is a directed graph v e v s vf in which vis the set of vertices ea set of edges vsa set of entry vertices vfa set of accepting vertices and a labelling function that assigns an msc to every vertex.
from any path in an msg of the form v1 v2...vn where v1 vs vn vf we can derive one msc by the concatenation of basic mscs v1 v2 ... vn .
.
miningalgorithm msgminer takes in a collection of execution traces of a system implementation and produces an msg describing the system s behavior.
the main challenge in this process lies in the ability to discover occurrences of concurrency b ehaviorfromtraces andspecifyingthemusingmscs.
werepresent mscs usingdatastructurescalled dependencygraphs figure dependency graphs for mscs in figure thatfullycapturethepartialorderrelationshipamongeve nts in the msc.
furthermore we introduce a novel idea of maximal connected dependency graph mcd for a given trace set to capture basic mscs that can be used as the building blocks for constructing an msg.
the entire mining process is thus divided into three stages which are elaborated in the rest of the section trace processing collection of traces and the transformation of each trace into a dependency graph.
msc mining identifying basic mscs in mcd representation from the dependency graphs and transforming each dependency graph into a chain of mscs.
msg construction merging of chains of mscs into an msg.
.
traceprocessinganddependencygraphs traces are collected by instrumentingand executinga system implementation with various inputs.
in a distributed system the trace points are chosen to be at program locations where processes send or receive messages.
a trace eventiseitherasendorreceivemessage oftheform an bracketle tp!q m an bracketri ht or an bracketle tq?p m an bracketri htrespectively where mis the message being exchanged between a sender named pand a receiver named q. furthermore every event must contain a time stamp to determine the ordering of events.
for presentation clarity we assume that traces are strings of events which are drawn from a trace alphabet .
the collected traces record some linear temporal order in which events occur during the execution of the system.
our first task is to eliminate temporal ordering of events from different lifelines when they are not explicitly imposed through messages.
with these eliminations we will have converted the total ordering of events implied by the traces into a partial ordering that captures concurrent behavior.
recall from .
that an msc m l el l l prescribes the partial ordering among a set of events.
was defined to be a transitive closure of the union of an ordering relationship between events within each lifeline l and the ordering of send and receive events of a message sm .
we observe that only the ordering imposed by l and smare sufficient to specify the inherent behavior of the system and define a dependency graph to capture these behaviors.
specifically a dependency graph is a graph data structure g l vl l l r where eachvi vlcorresponds to an event ei el there is a directed edge v1rv2iff for their corresponding events e1ande2 e1 e2 l l l sm vi ei for every event eiand its corresponding vertexviin the dependency graph.we will use v r as a shorter representation for dependency graphs whenever the lifelines and event alphabet is not relevant to the analysis.
note that dependency graphs are a graphical representation equivalent to traces in tr ace theory .
figure shows the corresponding dependency graphsg1 g2 g3andg4 for basic mscs m1 m2 m3andm4 respectively.
some of the properties of dependency graphs used by the mining algorithm are as follows.
definition .
equivalence .for dependency graphsg1 v1 r1 1 andg2 v2 r2 2 g1 g2iff there exists a bijection f v1 v2such that v1 v1 1 v1 2 f v1 and v1 v2 v1 v1r1v2 f v1 r2f v2 .
definition .
concatenation .for two graphs g1 l1 v1l l l1 r1 1 andg2 l2 v2l l l2 r2 2 the concatenation g1 g2 l vl l l r such that l l1 l2 vl v1l v2lifl l1 l2 v1lifl l1 l2 v2lifl l2 l1 1 2 r r1 r2 rl rsr the concatenated graph contains the following new sets of edges .rl this enforces the ordering that for a lifeline l the events in v1loccur before those in v2l.
let function first vil return vertex v vilsuch that v vil vriv .
similarly let l ast vil return the last event in lifeline l. rl last v1l first v2l l l1 l2 .rsr this pairs an unmatched send event in g1with an unmatched receive event in g2.
since a graph may contain repetitions of the same send receive event we resolve ambiguity by defining a function l vl n0to differentiate between identical events within the same lifeline.
for a vertex v vl l v v v vl v v rl r1 r2 v v .
rsr vp vq vp v1p vq v2q an bracketle tp!q m an bracketri ht an bracketle tq?p m an bracketri ht vp an bracketle tp!q m an bracketri ht vq an bracketle tq?p m an bracketri ht p vp q vq figure shows the result of concatenation of dependency graphsg1 g3andg2of figure .
the dotted lines show newly added edges.
definition .
sub graph .
a sub graph relationship among dependency graphs is as follows g gif and only if there exist graphs xandysuch that g x g y. definition .
prefix and suffix .
a sub graph g gis a prefix of giff for some graph y g g y. similarly g is a suffix iff for some graph x g x g .
ourdefinitionofsub graphfordependencygraphsisstricter thanand not tobe confused with thedefinition commonlyused in graph theory.
in figure gx gyandgzare subgraphs of the concatenated dependency graph.
the subgraphgxis a prefix and gza suffix.
definition .
frequency .
the frequency of subgraphg in dependency graph gisn if there exist dependency graphsg0 g1 ...gnsuch that g g0 g g1 g ... gn andg notsubseteqlg0 g1...gn.
note that g0 g1...gnmay be empty.
informally the frequency of a sub graph g ingis the number of distinct occurrences of the g ing.
figure also shows the frequency of gx gyandgzin g1 g3 g2.
figure concatenated graph g1 g3 g2 and some of its sub graphs we define a function dgraph t that accepts a trace tas parameter and constructs a dependency graph.
the dependency graph is constructed by first creating a unique vertex for each occurrence of an event.
after this edges are added to link up events within a lifeline intoa chain.
subsequentl y the send andreceive eventsare linked upin a backwardfashion starting from the bottom of the trace.
for example the last occurrence of event an bracketle tq?p m an bracketri htis linked to the last occurrence of event an bracketle tp!q m an bracketri htand so on.
this manner of constructing a dependency graph gives function dgraphthe property that given a trace t for any of its suffixes ts dgraph ts is a suffix of dgraph t .
we have made two assumptions about the system during the construction .
no messages are lost in the message channels.
.
the message are sent over fifo channels.
theconcatenatedgraphinfigure5isequivalentto dgraph t1 constructed from trace t1in figure a .
the algorithm for function dgraphis detailed in a technical report .
.
msc mining using the function dgraph we convert the available trace sett t1 t2 ...tn to a set of dependency graphs g g1 g2 ...gn where each dependency graph gi gcorresponds to a scenario of system execution.
our next step is to identify basic sections within these graphs that recur a t several places within the same graph or across the graphs ing.
these fundamental blocks are likely to capture the basic mscs in an msg describing the system.
there are many possible ways to break down a graph into fundamental blocks.
our method aims to discover mscs which are as big as possible and yet recurring frequently enough in theinput execution traces or their corresponding dependency graphs .
therefore we introduce the notion of maximal connected dependency graphs mcds to signify mscs.
formally definition .
mcd .
for a given trace set t t1 t2 ...tn gmcd v r is an mcd iff .
there is a trace t tsuch that gmcd dgraph t .
.
g gmcd freq gmcd freq g .
for every distinct v1 v2 v v1 v2 r r .
.
there is no graph g that satisfies conditions such thatgmcd g .
criterion guarantees that no part of an mcd and thus its corresponding msc appears in some context in which the rest of the mcd does not also appear.
criterion enforces the maximality of mscs.
criterion requires that events in mcds be connected with each other.
this additional constraint is introduced to simplify the mining task .
an exhaustive search for graph structures that meet the conditions specified above could turn out to be expensive.
instead we identify a graph structure termed event tail for each event and then successively merge them to arrive at dependency graphs that will satisfy the frequency connect edness and maximality criteria of mcds.
we describe event tails and the method of merging graphs in the following subsections.
.
.
eventtail for an event e when given a trace set t its tail tail is the largest dependency graph that contains a single minimal vertex which is a vertex in the graph without any associated incident edges labelled eand satisfies conditions of definition .
.
apart from the minimal vertex it also contains all events that immediately follow s every occurrence of ein a consistent partial order.
algorithm outputs an associative array tail that maps every event in to its tail.
for an event eand trace set t teis the set of trace suffixes that start with e.tecan be easily derived from a suffix tree constructed from the trace set.
from tewe obtain a collection of suffix graphs by identifying dgraph ts for every ts te.
in such a graph letvebe the vertex corresponding to the first occurrence of evente.
all vertices vin the graph for which ve v ne ationslash r are removed as they do not belong to the tail.
after this the function getcommonprefix is invoked to identify the largest prefix common to all suffix graphs in the collection for event e. this common prefix is the desired event tail tail .
operationally function getcommonprefix identifies the largest common prefix in a pair of dependency graphs g1 andg2through a simultaneous breadth first traversal over these two graphs.
during the traversal vertices and edges are gradually added to the largest common prefix g. a vertexvwith label eis added to gif and only if there are verticesv1ing1andv2ing2havingacommonlabel e and2 v1andv2have identical incident edges and all vertices from which there are edges incident to v1 v2have already been added to g. in addition getcommonprefix ensures that all events added to the common graph have identical frequencies.
all these operations ensure that conditions and o f 3given a trace set t t1 t2 ...tn freq g is the sum of the frequency of gin dgraph t1 dgraph t2 .. dgraph tn .algorithm find event tails input t the trace set set of events appearing in t. output tail that maps every event e to its tail.
for all e do findte the set of all suffixes of traces in t starting with e lette ts1 ts2 ...tsne tail fori ...nedo v r dgraph tsi letvebe the vertex corresponding to the first event e for all v vs.t.
ve v r do v v v end for iftail then tail v r else tail getcommonprefix tail v r end if end for end for definition .
are satisfied.
moreover since the event tail i s the maximal graph common to all suffixes with veas its minimal vertex we have ensured that tail contains atleast one vertex ve and tail cannot be extended without violating conditions or .
details of getcommonprefix is presented in .
figure a shows some of the event tails derived from traces of the banking system in figure .
.
.
combiningeventtails algorithm 2uses themappingfrom eventstotails tail to derive a mapping from events to mcds mcd .
the algorithm starts with g1 tail .
we know that tail ecannot be extended at the end as it is already maximal.
hence we attempt to grow g1by prefixingit with other graphs.
for every event e we verify if tail can be merged into g1.
let tail be the graph g2.
without loss of generality we can express the two tails as g1 gpref gcommand g2 gpref gcomm gsuff wheregcommis the largest possible such graph.
if gcomm is empty we do not perform any merging.
if gcommis not empty we obtain gpref g1as the merged graph.
to satisfy the frequency criterion we chose to accept the merged graph only when freq gpref g1 freq g1 .
when more than one prefix of g2satisfy the conditions on gpref we select the largest one.
the dependency graph g1is an mcd if no more event tails can be merged into it.
provides a proof for the claim that for each event e1 mcd determined by algorithm is an mcd.
figure b shows the set of mcds that are obtained by merging event tails obtained from traces in figure a .
.
.
convertingtracetosequenceofmscs algorithm associates each event with an mcd.
utilizing this association we transform every trace from the given trace set into a sequence of dependency graphs.
to achieve this we group events in a trace based on their associated mcds.
for a trace t we represent each group of events by a dependency graph giand derive a sequence of the form g1 g2 ...gi...gm such that dgraph t g1 g2 ... gm.
the order of dependency graphs in the sequence is constrained by the dependency relationship between events indgraph t .
in most cases we can expect gito be one of the mcds we identified.
certain cases warrant special handling.
firstl y a b figure a event tails and b mcds for events in the traces of the banking system algorithm combine event tails input tail for all events e output mcd for all events e for all e1 do w e1 g1 tail while e2 ws.t.
merge g1 tail ne ationslash do g1 merge g1 tail w w e2 end while mcd g19 end for merge g1 g2 input g1 g2 the candidates for merging output the merged graph.
if merge is not possible .
letgcommbe the largest suffix of g1that is a sub graph of g2.
if gcommis empty then return else find largest gpref 2that satisfies g2 gpref gcomm gsuff freq gpref g1 freq g1 ifno such gpref 2is found then return else return gpref g110 end if end if we may have derived two mcds that share a common sub graph.
for example we may have mcd gx gand mcd g gy.
since mcds are maximal we know that the merged graph gx g gymust have a lower frequency that its sub graphs.
in such scenarios we will drop the common sub graph gfrom one of the mcds.
secondly two mcds may not co exist as they constrain each other in certain traces.
to resolve such cases we automatically split one ofthe mcds intosmaller partswhenever necessary.
this scenario is explained with an example in .
while we have defined mcds as dependency graphs we do not require them to correspond to complete mscs ie.
there may exist a send event in an mcd which does not contain the matching receive event and vice versa.
in order to guarantee that all vertices of an msg denote complete mscs we concatenate successive partial graphs in a postprocessing step to ensure that each dependency graph in the final sequence of mscs will represent a complete msc.
algorithm performs this transformation.
it takes a sequence of dependency graph glistand creates outputlist a list of dependency graphs without any unmatched send or receive events.
at the end of this stage we have defined an alphabet of basic mscs and produced strings from this alphabet for the construction of msgs.algorithm convert to full mscs input glist a sequence of dependency graphs output outputlist sequence of dependency graphs each representing a valid msc outputlist temp glist fori ...glist.size do iftemp has an unmatched send event then temp temp glist else outputlist.add temp temp glist end if end for return outputlist .
constructing messagesequence graphs there exists a choice of algorithms to learn a finite state machine fsm from a training set of strings .
for our experiments we implement a variant of the sk strings algorithm as described in .
a shared prefix tree is initially constructedfromthesetofmscstrings.
thealgorithmthen identifies a set of nodes that are equivalent.
two nodes are considered equivalent if their k futures match.
the k future of a node is simply the set of all valid paths of length k or less if the end node is reached starting from that node.
several possible heuristics havebeen suggested tomatch tw o sets of k futures.
for better precision one could insist on t he match being exact.
other methods involve matching two sets of strings if they meet a certain probabilistic threshold.
equivalent nodes are merged to get a more general and compact model.
during the merging process loops are introduced to the model.
for a prefix tree with nnodes since every pair of nodes are compared the algorithm has a worse case execution time of o n2mk where mis the size of the trace alphabet.
for an operation comparing the k futures of any two nodes the maximum number of nodes to be compared is never greater than the total number of nodes in the tree.
as a result the algorithm has an execution time not worse than o n3 for any value k. note that nis shorter than the number of events in the initial traces as we have transformed them to msc strings.
once an msg has been mined from traces using the fsm learner it is refined through a series of state reduction ste ps.
an fsm learner usually produces a mealy model state machine which in our setting has to be transformed into a minimal moore model.
in the latter state machine each state corresponds to a basic msc.
the final msg is a structurepreserving homeomorphic embedding of the moore model state machine.
the general rule for reduction is that if anystate s is reachable from one and only one state s and s is the only state reachable from state s then the msc in state s can be concatenated to the msc in state s .
this concatenation yields new basic mscs.
the reduced directed graph of basic mscs is our finaloutput.
the msg canbe exported as image files for visualization.
.
extensions our work on msg mining has relied on a simple definition of mscs which was sufficient to represent partial order arising from asynchronous message exchanges.
this constraints us from representing more complicated behavior within mscs.
for example in some systems a process may broadcast messages to multiple processes and await responses from its audience.
we refer to such instances as message broadcasts .
in such scenarios the order in which the messages are sent or the responses received is usually in consequential.
furthermore the actual order of events see n in traces may be different for each realization of such broadcasts.
without knowledge of message broadcasts the mining process presented thus far may fail to produce a succinct and comprehensible msg.
msg semantics provide features such as coregions or parinline expressions to capture situations where there may be no specific logical ordering between some events within a lifeline.
the parexpression allow us to list a group of mscs and imply that they are to be executed in parallel.
to handle such scenarios using these features we extend the existing framework to accept additional input that declares specific behaviour such as the presence of broadcast messages.
we term this additional input an oracle.
our extended system when informed by the oracle will construct customized dependencygraphs and identify mcds thatcapture such scenarios the msgs produced by the extended system become less cluttered and much more comprehensible.
the technical report details the use of such oracle s to extend the system.
.
casestudies through case studies we attempt to evaluate the practicality of employing msgminer on real distributed systems.
in each case we have also scored the accuracy of mining by comparing the msgs mined from traces to hand derived specifications.
we consider the following distributed systems a center tracon automation system an air traffic control system from nasa b a system of server and voip clients communicating based on the session initiation protocol sip and c a system of server and clients that follow the xmpp instant messaging and chat protocol.
in each of these systems multiple processes perform asynchronous communication over tcp socket connections.
timestamped traces were collected by inserting instrumentation code at points were messages are written to or read from a socket.
the traces were filtered and the message names abstracted with the help of text processing scripts.
.
evaluation we propose an evaluation technique to validate the mined model against a known correct model.
the correct model is used only for evaluation and never part of the mining process.
given correct and mined models we derive a precision and recall score by performing language comparison.
precision and recall are popular metrics in information retrieva land have also been used to quantify the accuracy of mined state based models .
recall that concatenating basi c mscs along any path from a starting vertex to an accepting vertex in the msg produces an msc that represents a valid execution scenario.
we say that such an msc is generated by the msg.
precision is defined as the number of mscs generated by the mined model that are accepted by the correct model divided by the total number of mscs generated by the mined model.
similarly recallis the ratio of the number of mscs from the correct model that are accepted by the mined model to the total number of mscs generated by the correct model.
all possible msgs can not be enumerated as infinitely many mscs can be generated from an msg.
instead we use only a finite sample from the msg s language for evaluation.
our sample consists of all accepting paths in the msg with a finite bound on loops.
this bound is enforced my limiting the number of times any vertex is revisited in a path.
for the dependency graph g corresponding to each msc from the generating msg we verify if there is a path in the accepting msg that forms a dependency graph identical to g. this is done by an efficient depth first search in the accepting graph.
as our case studies consider reactive systems that contain concurrently executing processes existing automato n learning methods can not be applied to their traces.
such methodscaninsteadbeusedtoinferastatemachinefor each process iftheoriginal traces areseparatedintotracesloc al to each of the constituent processes.
we compare the accuracy of our proposed approach with the accuracy of mining this alternative model of local automata from the same collection of traces.
to do this we derive a similar precision and recall score of the learnt automata with respect to the same correct msg specification that was used to score the mined msg.
the algorithm used to learn automata is identical to the method used in the automaton learning phase of msg mining section .
.
precision and recall for automata is measured as the ratio of the number of traces rather than mscs generated from one model that is accepted by the other model to the total number of traces generated.
we generate random sample of traces from the collection of automata.
the parallel composition of the automata may contain accepting paths that create invalid traces eg receiv e event may appear before the message is sent .
to generate only correct traces we simulate the fifo message channels between processes.
while exploring a path in the composed automaton if an edge outputting a send event an bracketle tp!q m an bracketri htis chosen the message mplaced in the buffer corresponding to the channel .
an edge outputting a receive event an bracketle tq?p m an bracketri htcan be explored only if message mcan be removed from the front of buffer .
a path explored in the composed automaton signifies a valid trace only when an accepting state is reached and all the message buffers are empty.
we impose a bound on the number of loops as before.
table tabulates the results from the case studies.
it shows the precision recall and f 1measure harmonic mean of precision and recall of the mined models obtained from the two alternatives automaton learning and msg mining for each case study.
the mining was performed on a jvm running on an intel duo core cpu with 1gb of available memory.
the results from the systems considered for case study suggest that the proposed msg mining method provides better mining accuracy.systemno of eventsmined automata mined msg prec rec f1score time s prec rec f1score time s sip .
.
.
.
.
.
.
xmpp core .
.
.
.
.
.
.
xmpp muc .
.
ctas .
.
.
.
table table comparing accuracy of mining for msg and autom ata specifications .
ctas ctas is an air traffic control system from nasa.
the ctas weather control logic specification was one of the case studies recommended by the 3rd international workshop on scenarios and state machines scesm04 .
ctas is a distributed system having a central communications manager cm process to which clientprocesses connect.
the weather control specification details how clients shoul d connect tocm and howagraphical user interface referred to as the weather control panel wcp ought to communicate with cm to update weather status.
as access to the ctas systemislimited weprocureexecutiontracesbyimplement ing and executing a simulation of this system in java.
our implementation is based on a formal specification of the system in promela and high level hmsc that was developed by a fellow researcher.
the msg mined from the collected traces is shown in figure .
our mining on the ctas system succeeds in identifying the states of the system that are mentioned in the informal requirements documents.
the narrative in sub sections of the document matches neatly with the visual representation provided by the basic mscs.
.
sessioninitiationprotocol sip is a signalling protocol used to establish manage and terminate voip calls and multimedia sessions in general .
sip clients interact with servers that perform the necessary call routing and function as gateways to the public switched telephone network pstn .
we attempt to specify how clients should interact with their proxy server to achieve some of the basic call features.
for this we set up a system having three sip clients connected to a single server .
we use instrumented versions of kphone a sip client implementation and the opensips server both of which are available with source code under a gpl license.
we execute a set of test cases involving features such as basic cal l setup call screening and call forwarding.
a set of test case s for each feature are identified and a trace set is prepared by executing them on the system.
the test cases involve three clients or sip user agents labelled as alice bob and carol whose roles were restricted in the following way.
in all test cases alice initiates calls and bob is the intended recipient.
features such as call screening or forwarding ar e enabled at the client bob.
carol is the recipient of diverted calls.
specification mining was performed from the trace set.
a specification that reflects allotted client names and roles was manually derived by the authors for quantitative analysis and comparison.
.
xmpp extensible message and presence protocol is an open instantmessaging standardoriginally developedbythejabbe r open source community.
the core functionality of the protocol is specified in rfcs and .
xmpp is the protocol for exchange of instant chat messages and presence information between various entities in a network that are addresse dby unique jabber id.
the clients communicate to the server through structured xml messages.
the protocol defines how xml nodes known as stanzas are to be exchanged between various entities.
a client connecting to a server is authenticated through tls or sasl through special xml stanzas.
we attempt to discover the client server interacti on protocol from a system having two jabber clients that are brokered by a single server.
in the specification the server and client processes are the lifelines and the message arrow s represent the xml stanzas.
the openfire xmpp server and jeti pidgin client implementations were instru mented and executed for trace collection.
for discovering the core specification as an msg we only record stanzas used for authentication or those having a message orpresencetag and ignore rest of the message exchanges.
in addition to the core specification xmpp standards foundation xsf has standardised several additional chat features.
we attempt to mine behavioral specification for the multi user chat muc functionality .
for this we use a separate set of test cases involving features such as servi ce discovery multi party chat and creation and administrati on chat rooms.
in all test cases user1creates the chat room therebyacquiringtherole oftheroom owner.
onlymessages sent from or addressed to the muc conference service are recorded.
.
related work research in specification mining has attempted to discover common specification formats like frequent patterns rules finite state machines and boolean expressions .
approaches that mine frequent patterns highlight statistically significant patterns in the execution of the system whichcanbe interpretedas temporal rules.
whilethemined set of rules and properties are valuable to processes like model checking they provide a limited understanding of the system as a whole.
we mine for mcds based on a frequency criterion and use them along with automaton learning methods to provide a complete sepcification of the system.
most methods that mine finite state machines are built upon the k tails learner .
in mined state machines the transition edges between program states are usually labell ed with method calls.
ammons et al.propose the use of automaton mining on execution traces to infer state machine specifications for application programming interfac es api .
the precision and recall of automaton mining is improved by a trace filtering and clustering method proposed by lo and khoo .
lorenzoli et al.further combines the work of daikon with mining finite state models .
boolean invariants are attached to transition s among the nodes in the finite state machines to express guards.
ourapproachusesasimilar automatonminingalgorithm but performs additional steps so as to mine state machines having mscs at each node.
it is possible to apply the techniques proposed in the past work on top of our method to improve the mining accuracy e.g.
by performing tracefigure the mined msg for ctas left and the learnt automat a for individual processes filtering and clustering and enhance the expressiveness of the mined model e.g.
by the addition of guards .
in archaya et al.
extract relevent api interaction scenarios out of static traces generated from program code.
the scenarios are then summarized as compacted partial orders.
a collection of work that attempts to infer frequent partial order from string databases is discussed in .
th e generic partial order representation that is identified can be used to explain multiple sequences occuring in the database .
louet al.in construct workflow models from traces of concurrent systems by identifying dependency relationshi ps between pairs of events in interleaved traces.
different fro m the above studies we express partial orders in the semantics of message sequence charts mscs .
msc is a popular specification language and formally specifies the partial or der constraints among messages sent between lifelines.
als o we compose many partial orders into a message sequence graph msg .
the work of mine live sequence charts lsc that represent rules of the format if the execution describ ed by the pre chart occurs the execution prescribed by the main chart must eventually follow .
we emphasize that our focus on mining for msgs a global system model involves a fundamental conceptual shift from mining of lscs a collection of temporal properties .
this is because lscs are simply a visual description of temporal properties whic h must hold in every system execution.
in contrast msgs are a complete description of the global system behavior.
through the mined msg model we highlight the interaction snippets or commonly executed protocols across the processes and these get captured as the nodes or the basic mscs in our mined msg model.
efforts have been made in program visualization by constructing uml sequence diagrams from dynamic executions .
such work constructs a sequence diagram from dynamic traces traces but does not produce graph based models like msg that include loops and branches.
rountev et.
al.
perform a static inter procedural analysis to reverse engineer uml sequence diagrams from programs.
such an analysis requires the program source code whereas our analysis being dynamic only needs execution traces.
we also present a framework that supports mining with synchronous asynchronous message passing within mscs andsynchronous asynchronous concatenation across mscs making it a fully general framework for mining msc based system models.
.
conclusion andfuture work in this paper we have presented a dynamic specification mining framework to mine message sequence graphs from execution traces of concurrent distributed programs.
our focus on message sequence graphs is driven by the view that the mined specification will be used for program comprehension.
thus our mining framework exploits the easeof use of mscs msgs for understanding interactions in a concurrent distributed software.
as demonstrated by our experiments an msg being a global graph of interaction snippets provides a higher level view of the system behavior and its interactions as compared to mining the behavior of individual processes of a concurrent program as state machines.
in future we plan to pursue several avenues to extend the work.
one particular issue relates to the succinctness of mined msgs.
we observe that many large scale concurrent distributed programs are essentially parameterized systemscontaining several processes which are behaviorally similar .
for instance multiple clients in the chat system perform many similar actions such as loginandsign out.
this can result in several redundant basic mscs in the msg that try to explain the same behavior.
one way to manage such complexity would be to automatically identify such similar basic mscs during the mining process and group them together.
this requires us to develop a formal notion of roles and attach distinctroles to the participating processes in an msc e.g.see for ideas along these lines .
mining msc based system models for large scale parameterized distributed software in such a fashion remains an important direction of our future research.
in a broader perspective our work can be seen as a precursor of a multiview mining framework in which multiple views of a system model are mined from the execution traces.
in particular we envision a mining framework which mines state based intra process style specifications as well as msc based int erprocess style specifications from the traces of a concurrent distributed system.
.
acknowledgement this work was partially supportedbynusresearch grants r and r .
.