compatibility testing using patterns based trace comparison venkatesh prasad ranganath kansas state university rvprasad cis.ksu.edupradip vallathol university of wisconsin madison pradip16 cs.wisc.edupankaj gupta microsoft corporation redmond usa pankaj.gupta microsoft.com abstract when composing a system from components we need to ensure that the components are compatible.
this is commonly achieved by components interacting only via published and well de ned interfaces.
even so it is possible for client components to learn about and depend on unpublished yet observable behaviors of components.
to identify and support these situations compatibility testing should uncover such observable behaviors.
as a solution we propose a patterns based approach to test compatibility between programs in terms of their observable behaviors.
the approach compares traces of behaviors observed at identical published interfaces of programs and detects incompatibilities stemming from both the presence of previously unobserved behaviors and the absence of previously observed behaviors.
the traces are compared by transforming them into sets of structural and binary linear temporal patterns.
during windows development cycle we applied this approach to test compatibility between usb .
and usb .
bus drivers.
upon testing usb .
devices that were functioning without errors with both usb bus drivers we uncovered previously unknown incompatibilities between the bus drivers.
categories and subject descriptors d. .
testing and debugging debugging aids testing tools keywords observable behaviors patterns sequential data testing trace similarity permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
introduction in its simplest form compatibility testing checks if software component acan use or serve another software component bvia published interfaces.
the most common form of compatibility testing is backward compatibility testing e.g.
can microsoft excel be used to open and manipulate worksheets created using microsoft excel ?
as software gets more modular and extensible it is necessary to ensure that the set of components constituting a software are mutually compatible.
to this end most software take proactive measures to allow only the use of compatible components.
for example consider the scenario of a user upgrading her favourite web browser.
upon upgrading her browser from versionv1tov2 the installer program checks if any of the previously installed browser plug ins are incompatible with versionv2of the browser.
for each incompatible plug in the installer will o er to upgrade the plug in to a compatible newer version if available or to disable the plug in.
the incompatibilities deviations between the browser and the plug in can arise from syntactic or semantic changes to the published interfaces of the browser.
incompatible syntactic changes to a published interface of the browser e.g.
change in function signatures can be easily detected by compiling the plug in against version v2 of the browser.
as for incompatible semantic changes to a published interface very few of them e.g.
change in values of an enumeration type can be easily detected by compiling the plugin against version v2of the browser.
for most semantic changes the plug in will need to be executed with version v2 of the browser to exercise the change and uncover the incompatibility.
for example suppose version v2of the browser removed the value monday from an enumeration type for weekdays.
if none of the decisions in plug in adepend on the value monday then the behavior of plug in awill be una ected by version v2of the browser.
on the other hand if a decision in plug in adepends on the value monday then plug in awill most likely exhibit a new behavior when executed with version v2of the browser possibly leading to malfunction of both plug in aand the browser.
beyond such semantic changes programs can depend on behaviors observable at published interfaces .
1the notion of published interfaces was introduced by martin fowler .
2we will use the terms deviation and incompability interchangeably.
s.q c f s s.q c g s a corrects.q c f s g s b incorrect figure ways to use functions fand gfrom library l. for example consider a c language library lthat publishes two functions fandgthat accept a pointer to a structure with a eld qas their only argument and require eld qto contain value cupon invocation.
the correct way to use these functions is shown in figure 1a.
in version v1of l suppose the e ect of fon eld qis unspeci ed and qis unmodi ed upon returning from f. this observation about the implementation of f can be exploited to optimize clients of versionv1ofl when invoking fandgin sequence with a common structure argument s assign ctos.qand then invoke fandgwithout any intervening assignment of ctos.q as shown in figure 1b .
however in a subsequent version v2ofl if the implementation of fmodi es s.q then clients optimized against version v1oflwill fail when executing with version v2ofl.
a real world example.
during the development of windows the usb team built a new usb .
bus driver from scratch to support usb .
protocol in windows .
since usb .
protocol is backward compatible with usb .
protocol the usb .
bus driver needed to support usb .
devices along with their device drivers that were built against the existing usb .
bus driver.
hence when servicing usb .
devices the usb .
bus driver was required to mimic the observable behavior of usb .
bus driver.
in this context an example of incompatibility was that the usb .
bus driver could complete isochronous transfer requests at passive level interrupt request level when the usb .
bus driver would always complete such requests at dispatch level interrupt request level.
while such incompatibilities may not a ect any of the usb .
devices used to test the usb .
bus driver they could a ect untested usb .
devices which could be numerous given the vast number of unique usb devices in the world.
to uncover such incompatibilities stemming from observable behaviors many software shops employ eld testing by providing users with pre release versions of their software e.g.
windows by microsoft firefox by mozilla .
the success of eld testing in uncovering incompatibilities depends both on the number of users participating in eld testing and the extent to which users exercise various behaviors of the software.
when pre release versions of software have low adoption and usage incompatibilities can go undetected until the release of the software.
upon release and wider adoption of the software latent incompatibilities can surface causing reliability issues to users and maintenance costs to software vendors.
proposed approach to address the above real world scenario we devised a simple di erential approach to compatibility testing.
given two programs with identical published interfaces the approach relies on clients interacting identically with these programs via their published interfaces i.e.
the clients submit samerequests in the same order until any failure occurs .
these interactions are traced as observable behaviors and the resulting traces are compared to detect incompatibilities resulting from both the presence of previously unobserved behaviors and the absence of previously observed behaviors.
in addition since the approach uncovers issues independent of the success or failure of the execution yielding the traces it can uncover issues that can a ect yet unexplored executions.
as for comparing traces in our approach traces are abstracted as sets of structural and temporal patterns based on existing notions of patterns that can be mined using existing algorithms and these sets of patterns are compared using simple set operations i.e.
union intersection and difference.
this is the key feature of our approach.
in terms of guarantees our approach is unsound every detected incompatibility need not be a bug.
it entails human e ort to examine detected issues and classify them as either benign issues or bugs.
on the other hand our approach is complete w.r.t.
given traces every incompatibility that can be represented by the pre de ned classes of patterns used to abstract traces and are present in the given traces will be detected.
we successfully used our approach to test compatibility between usb .
and usb .
bus driver stacks in windows during the development of windows .
when used with an appropriate work ow the approach uncovered previously unknown compatibility bugs in the usb .
bus driver by analyzing pairs of traces from usb .
devices that were functioning without errors with both usb bus drivers.
contributions the key contributions of this manuscript are as follows.
.
we propose a di erential approach to compatibility testing based on patterns based trace comparison.
this approach can uncover compatibility issues stemming from both the presence of previously unobserved behaviors and the absence of previously observed behaviors.
unlike traditional testing our approach can detect compatibility issues independent of the success and failure of program executions.
.
we demonstrate the e ectiveness of the proposed approach in an industrial setting by using it during windows development cycle to test compatibility between usb .
and usb .
bus drivers.
.
we show that structural and temporal patterns observed in traces can serve as e ective trace abstractions to enable software engineering and maintenance tasks e.g.
compatibility testing.
the rest of this manuscript is organized as follows.
sections and describe compatibility testing and how to realize it via patterns based trace comparison.
section provides a detailed exposition about our experience using patterns based trace comparison to test compatibility between usb .
and usb .
bus drivers in windows .
section discusses related e orts.
section presents future possibilities.
.
compatibility testing given two programs prandpt compatibility testing checks ifprandptproduce identical outputs upon consuming identical inputs i.e.
8x pt x y pr x .
the above simple view of compatibility testing su ces when we are testing if the observed output is identical to the expected output e.g.
for argument does function abs 1return the same value as function abs ?
in many cases we are interested in testing if the observed value is similar identical modulo certain di erences to the expected output e.g.
upon consuming input x do programs p1andp2 output log les that contain the same messages but not necessarily in the same order?
to admit such notions of similarity into compatibility testing we formally de ne compatibility testing as follows.
de nition .
given an input xand two programs prand pt ptandprare compatible denoted as pt pr if pt x pr x holds where is a transformation function over program outputs and is a binary test predicate over transformation values.
with this de nition di erent forms of compatibility testing can be described using appropriate combinations of transformation functions and test predicates.
for example the simplest form of compatibility testing based on equality of output i.e.
pr x pt x can be described by id with identity function id as and equality predicate as .
similarly we can describe compatibility testing of programs that output traces sequences .4consider programs that consume an input xand produce a trace as output.
from the above de nition given two programs prand ptthat output traces rand tupon consuming test input x pris compatible to ptif r t holds with pr x randpt x t. hence the problem of compatibility testing based on traces reduces to the problem of trace comparison under and .
now consider programs that consume a sequence of inputs and produce an output trace.
if we want to test such programs based solely on the sequence of outputs then we can perform compatibility testing via trace comparison as described above.
if we want to consider both the sequence of inputs and outputs then we can perform compatibility testing as described above by conditioning the output trace as follows when a program pconsumes an input sequence x x1 x2 xnand produces an output trace xis a subsequence of and for every input xk2x if the corresponding output ykofpexists in thenykfollowsxkin i.e.
yk 9i xk i j .
in summary under a notion of similarity determined by the combination of and the problem of testing compatibility between programs based on their output traces reduces to the problem of trace comparison.
.
patterns based trace comparison in this section we describe two notions of trace similarity.
these notions of similarity use set equality as the test predicate .
as for transformation functions they are based 3observe that regression testing can be viewed as a form of compatibility testing where prandptare two consecutive versionspiandpi 1of the same program p. 4we will use the terms trace and sequence interchangeably.on event abstractions and binary linear temporal patterns proposed by lo et al.
.
from here on an event e fa17!c1 a27!c2 a37!
c3 an7!cngis a map from attributes ais to values cjs and a trace t e1 e2 en is a sequence of events.
.
structural patterns based similarity the most common notion of trace similarity is based on the presence absence of events in traces while ignoring the order of events i.e.
consider traces as sets of events and compare these sets.
we refer to this notion as event based trace similarity .
while this notion is simple it can be ine ective when di erent attributes of an event have di erent relevance in di erent scenarios.
for example when comparing two execution traces in terms of invoked functions it might su ce to consider views of events limited to the attribute capturing function names e.g.
consider ffun7!
fopen gview of the invocation eventffun7!
fopen arg17!
passwd.txt arg2 !
r return7!0x21g.
from this observation we propose a notion of trace similarity based on the presence absence of event abstractions of events in traces where any non empty subset of an event eis an abstraction of e. we refer to this notion as event abstraction based trace similarity .
in many situations it is useful to consider data constraints spanning multiple attributes.
for this purpose we propose using the notion of event abstraction with quanti cation given an event abstraction e fa17!c1 a27!c2 a37!
c3 an7!cng e0 fa17!vi a27!c2 a37!vj an7!
cngis a quanti ed abstraction of eif there exists a substitution a non empty map from variables to values such that8ai e e0 e e0 wherevis are variables.
consequently we say an attribute is quanti ed if it is associated with a variable as opposed to a value .
these event abstractions are patterns of event structures observed in a trace hence we refer to these abstractions as structural patterns .
further structural patterns with and without quanti cation are referred to as quanti ed structural patterns and unquanti ed structural patterns respectively.
finally we de ne the notion of structural patternsbased trace similarity as the equality of the sets of structural patterns observed in traces.
in other words compatibility testing based on traces can be realized with a function that transforms a trace into a set of structural patterns as the tranformation function and set equality as the test predicate .
.
temporal patterns based similarity structural patterns based trace similarity will be ine ective in situations where traces are identical in terms of the structural patterns but di er in the order of structural patterns.
for example traces t1 a b c andt2 a c b are identical under structural patterns based trace similarity as both traces contain the same set of events fa b cgand will result in the same set of structural patterns.
to handle such cases we propose transforming a trace into a set of temporal patterns composed of structural patterns.
of the numerous forms of temporal patterns we consider the following four binary linear temporal patterns de ned in .
given structural patterns a referred to as anchor and bare observed in a trace .a b b a is observed in the trace when an eventeimatchingais followed preceded by an event ejmatchingb where an event ematches a structural pattern cifcis an abstraction of e. these are eventually patterns .
.aa b ba a is observed in the trace when event eimatchingais followed preceded by an event ej matchingband no event between eiandejmatches a. these are alternation patterns .
in the above patterns either both aand bare quantied or both aand bare unquanti ed.
further when a and bare quanti ed the associated substitutions resulting from matching events should be identical i.e.
a b. for example event abstractions ffun7!
fopen return7!
0x21gandffun7!
fclose arg17!0x21gmatch the pattern ffun7!
fopen return7!v1g ffun7!
fclose arg17!
v1gunder the substitution fv17!0x21g.
however event abstractions ffun7!
fopen return7!0x21gandffun !
fclose arg17!0x23gdo not match the same pattern as there are no substitutions common to both event abstractions.
we shall refer to temporal patterns with and without quanti cation as quanti ed temporal patterns andunquantied temporal patterns respectively and we de ne the notion oftemporal patterns based trace similarity as equality of sets of all temporal patterns observed in traces.
in other words compatibility testing based on traces can be realized with a function that transforms a trace into a set of temporal patterns as the tranformation function and set equality as the test predicate .
.
statistical similarity the above notions of trace similarity are insu cient when traces exhibit identical set of patterns but the patterns have di erent statistical properties e.g.
frequency distance between events matching temporal patterns.
in such cases the notion of trace similarity can be extended to include the statistical properties of patterns.
for example two traces are similar if they exhibit the same set of patterns and the frequency of each pattern in both traces is greater than a given threshold.
while we explored such notions of trace similarity for performance debugging we will not explore it further in this manuscript.
.
alternative trace comparison techniques in contrast to patterns based trace comparison described above here are two alternative trace comparison techniques.
lcs based comparison the longest common subsequence lcs of two traces can be used to identify the di erences between traces events that are not part of the common subsequence.
however it will fail to identify incompatibilities due to temporal orderings of events.
further it is unclear if and how can event abstractions be e ectively and e ciently considered in lcs based comparison.
graph based comparison similar to lcs based comparison two traces can be compared by di ng their succession graphs nodes represent events and directed edges capture successor or reachability relation between events.
while graph based comparison seems similar to patternsbased comparison it is unclear how to incorporate event abstractions into graph based comparison.
function driver mouse driver filter driver usb .
controllerusb .
bus driver usb device mouse 1figure an illustration of how various types of wdm drivers are stacked when a usb device is plugged into a usb .
port on windows pc.
.
testing compatibility between usb drivers in windows in this section we describe our experience using patternsbased trace comparison to test compatibility between usb .
driver stack and usb .
driver stack in windows .
this was a joint e ort with usb team in windows organization within microsoft.
we describe this experience in detail to present the nuances involved in using patterns based trace comparison for compatibility testing.
these details should enable other researchers and practitioners to easily reproduce our experience in other contexts.
.
windows driver subsystem most of the kernel mode device drivers on windows vista and windows conform to windows driver model wdm .
this model supports the following kinds of drivers.
please refer to figure for an illustration of how various kinds of wdm drivers are connected.
abus driver services devices that support child devices e.g.
bus controllers adapters and bridges.
as these are necessary drivers microsoft provides these drivers for each type of bus e.g.
usb and pci.
all communication to devices on a speci c bus goes through the corresponding bus driver.
a lter driver extends the functionality of a device or intercepts and possibly modi es i o requests and responses from drivers.
afunction driver exposes the operational interface of a device to the system e.g.
the device driver provided with microsoft comfort curve keyboard.
in wdm most of the communication with and between drivers is packet based.
typically an i o request is dispatched to a driver by invoking iocalldriver routine with ani o request packet irp a structure in c language 5we use the terms driver s and device driver s interchangeably.
472embodying the request.
the irp is delivered to the i o manager which then forwards the request to the appropriate driver.
upon completing a request the servicing driver modi es the corresponding irp e.g.
updates status elds or copies data into bu ers in the irp and signals the completion of the request to the i o manager by invoking iocompleterequest .
i o manager then signals the requesting driver about the completion by invoking the iocompletion routine registered for the irp.
the elds of the irp both de ne the type of requests and the data both input and output pertaining to requests.
.
problem as mentioned in building windows blog windows supports usb .
protocol with a new usb .
driver stack that provides a bus driver dedicated to usb .
controller.
since usb .
driver stack is a clean room implementation it does not borrow any code and hence any behavior from existing usb .
driver stack in windows .
further usb .
driver stack exclusively supports devices controlled by usb .
controller connected to usb .
port while usb .
driver stack exclusively supports devices controlled by usb .
controller connected to usb .
port .
in the rest of this exposition we focus on the usb bus drivers provided by the usb driver stacks as they control the underlying usb controller.
so we shall refer to usb bus driver as usb driver.
consider the situation where a user plugs in a usb .
device into a usb .
port on a computer running windows .
since usb .
protocol is backward compatible with usb .
protocol the user expects the device to behave as if the device was plugged into a usb .
port and serviced by usb .
driver.
in other words the observable behavior of a usb .
device plugged into a usb .
port should be identical to the observable behavior of the same device plugged into a usb .
port.
to enable the above scenario usb .
driver needs to support usb .
protocol to guarantee behavioral equivalence with usb .
driver.
however it is possible that existing function drivers depend on unpublished yet observable behaviors of usb .
driver e.g.
usb .
driver zeroes out the portstatus bits in the irp upon failing to service i o control code ioctl internal usb get port status.
hence for compatibility usb .
driver should exhibit any unpublished yet observable behaviors of usb .
drivers and we need to test these usb drivers for equivalence of such behaviors.
a naive approach to test for such equivalence is to exercise usb .
driver with every usb .
device and its function driver and check for observable failures.
however this approach is prohibitive given the vast number of unique usb devices in the world.
to identify an alternative we observed that every function driver exposes the functionality of a device to the system by interacting with the device via the bus driver.
so it is likely that any deviation in interactions between a function driver and the bus driver could lead to deviations in the observable behavior of the device.
hence we chose to test compatibility between usb drivers by the checking for equivalence of interactions between function drivers and the usb drivers at point in figure i.e.
for every request from a func6such behaviors can stem from decisions while implementing weakly speci ed parts of usb .
protocol.tion driver is the response from usb .
driver similar to the response from usb .
driver?
.
solution our solution to this problem uses patterns based trace comparison described in section within a simple workow outlined in figure .
in the following sections we describe how we realized the approach via this work ow.
.
.
trace interactions between drivers given a usb .
device we enabled tracing plugged in the device to a usb .
port waited for the device to be recognized by windows ejected the device waited for the device to be unavailable in windows and disabled tracing.
we then repeated these steps with the same device plugged into a usb .
port.
for tracing we used a customized lter driver developed by usb team to capture the interactions between functions drivers and usb drivers and log these interactions into etw traces via event tracing for windows etw .
.
.
mine patterns from traces the traces collected in the previous step contained simple types of events.
of these simple event types few captured the invocations of driver routines e.g.
iocalldriver that enable inter driver communication few captured the completions of driver routines and the rest captured the arguments to these routines.
we used this knowledge to combine these simple event types into compound event types that represent the invocation of driver routines along with their arguments and the completion of driver routines with their return values.
in addition we synthesized certain information e.g.
i o control codes ioctl and captured them in few synthesized event attributes.
since the events in etw are structured we also attened access paths to elds.
after these transformations there were attributes including few synthesized attributes across compound event types.
to curb the explosion of structural patterns during mining we employed domain knowledge by consulting a developer in the usb team.
speci cally out of attributes we identi ed attributes that could be ignored.
of the remaining attributes we identi ed attributes as necessary i.e.
they should occur in all structural patterns of an event and attributes as optional i.e.
not necessary .
also we identi ed attributes that should not be quantied of these attributes were identi ed to be abstracted as either null or non null.
7here are two other alternatives that we considered to test compatibility between usb drivers.
approach check for equivalence of on the wire interactions between the usb controller and the usb device at point in figure .
this form of checking can be brittle due to controller speci c nuances stemming from weakly specied parts of usb protocol.
also since the usb driver does not have direct control over these interactions it was unclear if this approach will help uncover compatibility issues directly stemming from the implementation of usb driver.
approach check for equivalence of command level interactions between the usb driver and the usb controller at point in figure .
this form of checking can be brittle due to nuances stemming from the combination of the exibility of usb command language and the implementation of both the usb controller and the usb driver.
473usb .
trace mine patterns .
patternsusb .
trace mine patterns .
patternsdomain knowledge filter diffknown patterns filtered diff patterns bug patternsbenign patternsdevelopercapture tracecapture trace user def filtersshrink diffgenerate difffigure work ow to perform compatibility testing using patterns based trace comparison.
in terms of quanti cation we identi ed attributes that should always be quanti ed.
for example since we were interested in checking if similar irps are processed similarly by both driver stacks we need not have to mine patterns involving event spanning di erent irps hence irpidattribute that uniquely identi es the source irp of an event was always quanti ed.
further when quanti cation of attributes is used to capture data ow between events participating in a temporal pattern non existent data ow can be captured due to representational equivalence i.e.
two elds with di erent semantics can use the same data type.
to curb this noise based on domain knowledge by way of con guration we considered only data ows between di erent attributes in addition to data ow between same attributes occurring in di erent events.
with the above setup we mined every structural and temporal patterns of the forms described in section occurring in the collected traces.
in unquanti ed form we considered only patterns involving necessary attributes.
in quanti ed form we considered only patterns involving all necessary attributes and up to three optional attributes.for mining we used tark a toolkit to mine the patterns described in section .
for details about the pattern mining algorithms implemented in tark please refer to .
while the patterns are mined from traces of every device the domain knowledge about attributes is elicited once for the usb domain and merely reused when patterns are mined from traces .
.
.
calculate unique patterns deviations for each usb .
trace we calculated two sets of unique patterns deviations based on all usb .
traces in our corpus.
the rst set was composed of unique usb .
patterns observed in every usb .
trace but not observed in the given usb .
trace the di erence between the intersection of pattern sets of every usb .
trace and the pattern set of the given usb .
trace.
these patterns identify observable behaviors of usb .
driver that were not exhibited by usb .
driver.
the second set was composed of unique usb .
patterns observed in given usb .
trace but in none of the usb .
traces the di erence between the pattern set of given usb .
trace and the union of pattern sets of every usb .
trace.
these patterns identify extraneous observable behaviors exhibited only by usb .
driver.
when executed with usb .
driver a function driver can fail due to both these patterns a driver dependent on unique usb .
patterns could fail due the absence of such patterns while a driver not capable of handling unique usb .
patterns could fail due the presence of such patterns.
.
.
shrink unique pattern sets given the number of patterns mined from each trace was huge as shown in table we employed the following techniques to shrink the sets of patterns by eliminating redundant patterns.
partitioning.
when a trace contains a unique structural pattern the trace can contain numerous unique temporal patterns that involve this unique structural pattern.
from the perspective of detecting unique deviations such temporal patterns do not identify deviations that are di erent from the deviations detected by the contained unique structural pattern.
hence we ignored such temporal patterns.
simplification.
by de nition of the temporal patterns in section the presence of an alternation pattern e.g.
aa b in a trace implies the presence of corresponding eventually pattern e.g.
a b in the trace.
hence we removed eventually temporal patterns from a pattern set if their alternation counterparts were present in the pattern set.
in a similar vein by way of construction the existence of a complex pattern e.g.
a b c implies the existence of simpler constituent patterns e.g.
a candb c .
hence either only complex patterns or only simple patterns can be presented without any loss of information.
favoring simplicity we removed complex patterns from a pattern set if all of their simple constituent patterns were present in the pattern set.
474compaction.
if a pattern set contains patterns of the form aa bandaa b we replaced them with a single pattern of the form aa !bwith the meaning an event matching a will be followed by an event matching b with no intervening events matching either a or b. .
.
report deviations to the developer as the nal step for each device a developer from usb team examined the resulting unique patterns and classi ed them as either benign deviations or bugs.
subsequently detected bugs were entered into the windows bug repository.
reducing false positives.
as the approach is conservative in considering all possible patterns benign deviations can lead to false positives.
for example unique patterns stemming from elds values that do not impact the behavior of function drivers will lead to false positives due to incomplete domain knowledge .
to curtail such false positives we applied user de ned lters e.g.
ignore patterns in which ioctltype eld is equal to urb function select configuration .
these lters were often based on patterns observed while examining test results.
the user de ned lters were saved and reused while examining results from subsequent tests.
in addition we suppressed patterns that were observed in previous tests as they were already classi ed as either benign deviations or bugs.
this is depicted by the dashed line in figure .
we refer to these patterns detected in previous tests as known patterns .
aiding diagnosis.
for all unique patterns we identi ed matching events.
in addition for unmatched temporal patterns we identi ed events that matched the anchor of the temporal pattern.
the developer then started diagnosing the issue starting at these matching events.
.
evaluation for this evaluation we collected pairs of traces one with usb .
driver and another with usb .
driver from di erent usb .
devices and compared these traces as described in the previous section to test for compatibility.
based on this data set we evaluated the e ectiveness precision and cost of our approach.
table provides the breakdown of deviations and bugs uncovered in this evaluation.
table provides the breakdown of mined patterns and costs of testing as observed in this evaluation.
.
.
effectiveness in this data set a developer from usb team identi ed deviations as previously unknown incompatibilities between usb .
driver and usb .
driver.
of these bugs bugs were based on unique structural patterns and bugs were based on unique temporal patterns involving only common structural patterns .
following is the description of few of the detected bugs.
when usb .
driver fails to service ioctl internal usb get port status request the driver zeroes out all bits of portstatus eld.
however usb .
driver does not zero out these bits.
this bug was based on a unique structural pattern.
upon completing an isochronous transfer request usb .
driver sets the status eld of the isochronouspacket to oxffffffff .
however this was not the case with usb .
driver.
this bug was based on a unique structural pattern.
usb .
driver completed isochronous transfer requests atdispatch level interrupt request level.
however usb .
driver completed similar requests at passive level interrupt request level.
this bug was based on a unique structural pattern.
a usb device can have multiple operational con gurations along with corresponding interfaces and one of these con gurations is selected while enumerating the device.
when an i o request to select a con guration for a device was submitted usb .
driver failed to communicate the corresponding interface in its response.
this deviation was based on a unique temporal pattern with interfacehandle eld attribute remaining unchanged across the two events supporting the pattern.
when a usb device is not in use its function driver can notify the usb driver that the device is idle and the device can be suspended or put in low power state.
upon completing an i o request corresponding to such a noti cation usb .
driver did not change pendingreturned eld in the irp.
this deviation was based on a unique temporal pattern.
.
.
precision our solution started out with a high number of false positives out of deviations reported for device deviations were false positives.
see false ve andreported columns in table .
to alleviate this problem as we tested more devices we collected and saved false positives and then ltered them out of subsequent test results as described in section .
.
.
consequently the number of false positives dropped to less than in subsequent tests corresponding to devices through and to less than in out of tests.
hence we conjecture that the false positives reported by our approach will decrease as the number of devices used for compatibility testing increases.
in addition we collected a total of user de ned lters while testing with devices and .
in retrospective few of these lters could have been injected as domain knowledge during pattern mining.
in terms of curtailing the number of deviations presented to the developer simpli cation reduced the number of detected deviations by at least a factor of .
similarly compaction reduced the number of simpli ed deviations by a factor of .
see simpli ed and compaction columns in table .
revisiting the issue of number of false positives consider the cost of compatibility testing.
observe that the bugs were detected from traces of devices that functioned without errors with both bus drivers.
if we wanted to detect the same bugs by observing devices failing due to these bugs then we would need to test both usb bus drivers with every unique usb device in the world.
this would amount to testing with thousands of unique usb devices.
in contrast with our approach the developer spent less than hours in many cases to examine a non empty set of deviations resulting from a test device in few cases the developer spent up to a day to examine a set of deviations.
so when we compare 475number of deviations number of bugs device known detected simpli ed compacted reported false ve structural temporal table breakdown of deviations detected by our approach in order .
for a device test each row provides the number of known deviations detected deviations reported deviations false positives and bugs of various sorts.
x y denotes x structural patterns and y temporal patterns.
a b denotes a bugs were unique out of b bugs.
devices tests at which new lters were collected are marked with .
known deviations are simpli ed deviations from previous tests.
the cost of testing with every unique usb device including the cost of tracking and procuring devices to the cost of developer spending hours to sift through test verdicts with less than false positives per test the number of false positives becomes a non issue.
.
.
cost while the cost of capturing a pair of traces for a device was in the order of few minutes the time to mine quantied patterns from these traces ranging from 200k to 500k patterns per trace varied from minutes to minutes on a core server with 32gb of ram depending on the length of the trace and the average number of attributes per event.
see time and patterns columns in table .
the time taken to di erence pattern sets and to simplify and report the di erence for a pair of traces was minutes for unquanti ed patterns and minutes for quanti ed patterns with few exceptions of and minutes.
see di time column in table .
given that our approach is automated and there are no alternative approaches to detect deviations that do not affect the device under test we believe the associated cost is reasonable.
.
.
comparison at the time of our experiments none of the related approaches discussed in section could be immediately applied in our setting.
hence we could not directly compare our approach with the related approaches.
regression testing can uncover the reported incompatibilities by testing usb .
driver against usb .
driver with every unique usb device in the world under all possible usage scenarios.
however since test labs have access to a subset of all the unique usb devices in the world and are not aware of all possible usage scenarios regression testing in its naive form parity of device failures on both drivers will not su ce.
this observation is supported by the fact that our approach detected incompatibilities in the version of usb .
driver that was regression tested and all the issues reported from regression testing were xed.
nevertheless regression testing can be adapted to uncover the reported incompatibilities by employing test criteria thatare based on observable behaviors.
such test criteria can be de ned using the approaches to trace comparison described in section .
.
.
limitations as demonstrated the approach can detect only deviations that can be captured as structural patterns or binary linear temporal patterns.
however this limitation can be addressed by mining and using richer patterns e.g.
longer linear temporal patterns or nite state machines.
.
threats to validity since the approach was e ectively applied to one nontrivial problem instance the approach and its e ectiveness cannot be immediately generalized to other problem instances.
in our experiment the e ects of various latent factors such as the size of the interface e.g.
number of functions data ow properties at the interface domains of values consumed and produced by the interface and existence of a well de ned protocol governing the observable behavior at the interface were not considered.
hence the in uence of the latent factors on the e ectiveness of the approach cannot be immediately ruled out.
however both of the above concerns can be addressed by more experimentation.
.
lessons learned if domain knowledge is available use it.
as the results suggest the approach would have provided useful results independent of the domain knowledge.
however the number of false positives would have been high in such results and consequently the cost of identifying anomalies would have been high.
also domain knowledge helped the underlying algorithm to focus on relevant patterns and reduce computation costs.
if a feedback loop can be established set it up.
with user feedback lters and decisions the approach was able to lter out both irrelevant and previously seen results and bubble up previously unseen deviations hence helping the user focus on relevant deviations.
presentation matters.
while the sorts of patterns presented as deviations were simple few presentation tweaks 476usb .
traces usb .
traces di time id no.
of unquant mining quant mining no.
of unquant mining quant mining unquant quant events time patterns time patterns events time patterns time patterns patterns patterns .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table data about mining and di ng traces in our experiment.
each row provides data for both a usb .
trace and a usb .
trace of a device.
for each trace its length in events mining time in seconds the number of mined patterns of various sorts and pattern di erencing time in seconds are provided.
the largest number in each column is italicized.
based on the information needs of the user helped reduce the number of reported deviations without any loss of information .
in turn this made the approach and the results more accessible to the user.
.
related work the number of e orts in the space of software testing is huge it is impossible to to fairly cite a few e orts here to the extent that there are venues dedicated to software testing e.g.
icst issta tap .
most of these e orts rely on software tests that embody well de ned expected outcomes to automatically provide conclusive test verdicts.
in comparison our approach relies on execution traces of both the system under test and the reference implementation to automatically detect a class of behavioral and possibly performance deviations.
in other words our approach automatically hoists observable behaviors in the reference implementation as well de ned expected outcomes.
in terms of using event sequence patterns as a core idea to enable software testing dallmeier et al.
used method call sequences as trace features to predict and localize defects by comparing traces from passing and failing executions of test cases.
however they employed method call sequences based on n grams while we used patterns spanning across non consecutive events .
in terms of fault localization dallmeier et al.
used di ering method call sequences to identify and rank likely defective classes while we presented events that match deviating patterns as likely symptoms causes.
recently beschastnikh et al.
used unquanti ed temporal invariants patterns satis ed by logs to automatically construct a graph model of a system.
in comparison we have considered both unquanti ed and quanti ed variants of temporal patterns to model behaviors captured in traces.
beyond software testing there have been numerous e orts to mine various features from system logs and then monitor live systems for absence of these features.
similar to software testing e orts few of these monitoring efforts have used n grams and state machines as trace features while other monitoring e orts have employed features based on statistical properties of traces such as relative frequencyand correlation of events.
ignoring the speci c classes of patterns and the corresponding mining techniques our effort is similar to these e orts in terms of using patterns and pattern mining techniques as features and feature extraction techniques respectively.
in a similar vein barringer et al.
used human speci ed quanti ed parameterized temporal patterns with logs to enable postmortem runtime veri cation of ight software for nasa s recent mars rover mission .
in comparison we use automatically mined quanti ed temporal patterns to detect both the presence of new behaviors and the absence of old behaviors when testing compatibility of programs.
in terms of trace comparison data mining community has proposed and used various edit distances e.g.
hamming levenshtein and sequence based patterns to compare sequences .
in software community miranskyy et al.
identi ed di erences between traces by iteratively di erencing various inter event abstractions of traces e.g.
set of function calls caller callee relation sequence of function calls .
in comparison our approach is similar to these efforts with the di erence being the choice of structural and temporal patterns used to abstract and compare traces.
while we were pursuing this e ort yang and evans explored the use of temporal patterns properties observed in program logs to identify behavioral di erences between programs.
besides the operational di erences in terms of the underlying mining algorithms and related cost precision trade o s they mined nine types of unquanti ed patterns to characterize the traces in their evaluation while we used four types of unquanti ed and quanti ed temporal patterns along with structural patterns.
in addition we also used a simple yet e cient feedback based work ow to e ectively deal with false positives.
.
possibilities traditional regression testing relies on pass fail outcome of existing tests.
it does not detect behavioral deviations that do not a ect the outcome of tests.
however with execution traces from regression tests our approach can be employed to detect such behavioral deviations.
further similar to alternative approaches mentioned in section the approach 477can be used to detect deviations between passing and failing instances of a test to aid fault localization and debugging of failures.
when responding to a customer incident support engineers often sift through system application logs to identify if the reported incident is similar to any previously observed incident possibly resolved incidents.
in such scenarios structural and temporal patterns observed in logs can be used as features with o the shelf clustering and classication algorithms e.g.
hierarchical clustering n nearest neighbor classi cation to automatically recommend a ranked list of similar incidents.
consequently organizations can harness institutional knowledge and decrease turn around time for customer incidents.