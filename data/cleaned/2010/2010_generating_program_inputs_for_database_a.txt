generating program inputs for database application testing kai pan xintao wu university of north carolina at charlotte kpan xwu uncc.edutao xie north carolina state university xie csc.ncsu.edu abstract testing is essential for quality assurance of database applications.
achieving high code coverage of the database application is important in testing.
in practice there may exist a copy of live databases that can be used for database application testing.
using an existing database state is desirable since it tends to be representative of real world objects characteristics helping detect faults that could cause failures in real world settings.
however to cover a specific program code portion e.g.
block appropriate program inputs also need to be generated for the given existing database state.
to address this issue in this paper we propose a novel approach that generates program inputs for achieving high code coverage of a database application given an existing database state.
our approach uses symbolic execution to track how program inputs are transformed before appearing in the executed sql queries and how the constraints on query results affect the application s execution.
one significant challenge in our problem context is the gap between program input constraints derived from the program and from the given existing database state satisfying both types of constraints is needed to cover a specific program code portion.
our approach includes novel query formulation to bridge this gap.
our approach is loosely integrated into pex a state of theart white box testing tool for .net from microsoft research.
empirical evaluations on two real database applications show that our approach assists pex to generate program inputs that achieve higher code coverage than the program inputs generated by pex without our approach s assistance.
i. i ntroduction database applications are ubiquitous and it is critical to assure high quality of database applications.
to assure high quality of database applications testing is commonly used in practice.
testing database applications can be classified as functional testing performance testing load and stress scalability security testing environment and compatibility testing and usability testing.
among them functional testing aims to verify the functionality of the code under test.
an important task of functional testing is to generate test inputs to achieve full or at least high code coverage such as block or branch coverage of the database application under test.
for database applications test inputs include both program inputs and database states.
a. illustrative example the example code snippet shown in figure includes a portion of c source code from a database application that calculates some statistic related to mortgages.
the corresponding database contains two tables customer andmortgage .
their01 public int calcstat int type int zip int years count totalbalance int fzip zip if type years else years sqlconnection sc new sqlconnection sc.connectionstring .. sc.open string query select c.ssn c.income m.balance from customer c mortgage m where m.year years and c.zipcode fzip and c.ssn m.ssn sqlcommand cmd new sqlcommand query sc sqldatareader results cmd.executereader while results.read int income int.parse results int balance int.parse results int diff income .
balance if diff count totalbalance totalbalance balance return totalbalance fig.
.
an example code snippet from a database application under test schema level descriptions and constraints are given in table i. thecalcstat method described in the example code snippet receives two program inputs type that determines the years of mortgages and zip that indicates the zip codes of customers.
a variable fzip is calculated from zip and in our example fzip is given as zip .
then the database connection is set up lines .
the database query is constructed line and executed lines and .
the tuples from the returned result set are iterated lines .
for each tuple a variable diff is calculated from the values of the income field and thebalance field.
ifdiff is greater than a counter variablecount is increased line and totalbalance is updated line .
the method finally returns the calculation result.
both program inputs i.e.
input parameters and database states are crucial in testing this database application because the program inputs determine the embedded sql statement in line the database states determine whether the true branch in line and or the true branch in line can be covered being crucial to functional testing because coveringtable i database schema customer table mortgage table attribute type constraint attribute type constraint ssn int primary key ssn int primary key zipcode string foreign key name int year int gender string age int balance int max income int a branch is necessary to expose a potential fault within that branch the database states also determine how many times the loop body in lines is executed being crucial to performance testing.
b. problem formalization in practice there may exist a copy of live databases that can be used for database application testing.
using an existing database state is desirable since it tends to be representative of real world objects characteristics helping detect faults that could cause failures in real world settings.
however it often happens that a given database with an existing database state even with millions of records returns no records or returned records do not satisfy branch conditions in the subsequently executed program code when the database receives and executes a query with arbitrarily chosen program input values.
for example method calcstat takes both type andzip as inputs.
to cover a path where conditions at lines and are bothtrue we need to assign appropriate values to variables years andfzip so that the execution of the sql statement in line with the query string in line will return nonempty records while at the same time attributes income and balance of the returned records also satisfy the condition in line .
since the domain for program input zip is large it is very likely that if a tester enters an arbitrary zip value execution of the query on the existing database will return no records or those returned records do not satisfy the condition in line .
hence it is crucial to generate program input values such that test inputs with these values can help cover various code portions when executed on the existing database.
c. proposed solution to address this issue in this paper we propose a novel approach that generates program inputs for achieving high code coverage of a database application given an existing database state.
in our approach we first examine close relationships among program inputs program variables branch conditions embedded sql queries and database states.
for example program variables used in the executed queries may be derived from program inputs via complex chains of computations we usefzip zip in our illustrative example and path conditions involve comparisons with record values in the query s result set we use if diff in our illustrative example .
we then automatically generate appropriate programinputs via executing a formulated auxiliary query on the given database state.
in particular our approach uses dynamic symbolic execution dse to track how program inputs to the database application under test are transformed before appearing in the executed queries and how the constraints on query results affect the later program execution.
we use dse to collect various intermediate information.
our approach addresses one significant challenge in our problem context there exists a gap between program input constraints derived from the program and those derived from the given existing database state satisfying both types of constraints is needed to cover a specific program code portion.
during dse these two types of constraints cannot be naturally collected integrated or solved for test generation.
to address this challenge our approach includes novel query formulation to bridge this gap.
in particular based on the intermediate information collected during dse our approach automatically constructs new auxiliary queries from the sql queries embedded in code under test.
the constructed auxiliary queries use those database attributes related with program inputs as the target selection and incorporate those path constraints related with query result sets into selection condition.
after the new auxiliary queries are executed against the given database we attain effective program input values for achieving code coverage.
this paper makes the following main contributions the first problem formalization for program input generation given an existing database state to achieve high code coverage.
a novel program input generation approach based on symbolic execution and query formulation for bridging the gap between program input constraints from the program and from the given existing database state.
evaluations on two real database applications to assess the effectiveness of our approach upon pex a stateof the art white box testing tool for .net from microsoft research.
empirical results show that our approach assists pex to generate program inputs that achieve higher code coverage than the program inputs generated by pex without our approach s assistance.
ii.
d ynamic symbolic execution in database application testing recently dynamic symbolic execution dse was proposed for test generation.
dse first starts with default or arbitrary inputs and executes the program concretely.
along the execution dse simultaneously performs symbolic execution to collect symbolic constraints on the inputs obtained from predicates in conditions.
dse flips a branch condition and conjuncts the negated branch condition with constraints from the prefix of the path before the branch condition.
dse then feeds the conjuncted conditions to a constraint solver to generate new inputs to explore not yet covered paths.
the whole process terminates when all the feasible program pathstable ii a g iven database state customer table mortgage table ssn zipcode name gender age income ssn year balance alice female bob male have been explored or the number of explored paths has reached the predefined upper bound.
dse has also been used in testing database applications .
emmi et al.
developed an approach for automatic test generation based on dse.
their approach uses a constraint solver to solve collected symbolic constraints to generate both program input values and corresponding database records.
the approach involves running the program simultaneously on concrete program inputs as well as on symbolic inputs and a symbolic database.
in the first run the approach uses random concrete program input values collects path constraints over the symbolic program inputs along the execution path and generates database records such that the program execution with the concrete sql queries can cover the current path.
to explore a new path it flips a branch condition and generates new program input values and corresponding database records.
however their approach cannot generate effective program inputs based on the content of an existing database state.
the reason is that some program inputs e.g.
zipin our illustrative example appear only in the embedded sql queries and there is no path constraint over them.
our approach differs from emmi et al.
s approach in that we leverage dse as a supporting technique to generate effective program input values by executing constructed auxiliary queries against the existing database state.
as a result high code coverage of the application can be achieved without generating new database states.
when dse is applied on a database application dse often fails to cover specific branches due to an insufficient returned result set because returned record values from the database often involve in deciding later branches to take.
we use pex a dse tool for .net to illustrate how our approach assists dse to determine program input values such that the executed query can return sufficient records to cover various code portions.
during the program execution dse maintains the symbolic expressions for all variables.
when the execution along one path terminates dse tools such as pex have collected all the preceding path constraints to form the path condition.
pex also provides a set of apis that help access intermediate information of its dse process.
for illustration purposes we assume that we have an existing database state shown in table ii for our preceding example shown in figure .
to run the program for the first time against the existing database state pex uses default values for program inputs type andzip.
in this example because type andzip are both integers.
pex simply chooses type zip as default values.
the condition in line is then satisfied and the query statement with the content in line is dynamicallyconstructed.
in line where the query is executed we can dynamically get the concrete query string as q1 select c.ssn c.income m.balance from customer c mortgage m where m.year and c.zipcode and c.ssn m.ssn through static analysis we can also get q1 s corresponding abstract form as q1abs select c.ssn c.income m.balance from customer c mortgage m where m.year years and c.zipcode fzip and c.ssn m.ssn the execution of q1 on table ii yields zero record.
thus the while loop body in lines is not entered and the exploration of the current path is finished.
we use the pex api method pexsymbolicvalue.getpathconditionstring after line to get the path condition along this path p1 type results.read !
true to explore a new path pex flips a part of the current path condition from type to type !
and generates new program inputs as type zip .
the condition in line is then not satisfied and the sql statement in line is dynamically determined as q2 select c.ssn c.income m.balance from customer c mortgage m where m.year and c.zipcode and c.ssn m.ssn note that here we have the same abstract form for q2 as for q1.
however the execution of q2still returns zero record and hence the execution cannot enter the while loop body either.
the path condition for this path is p2 type results.read !
true we can see that at this point no matter how pex flips the current collected path condition it fails to explore any new paths.
since pex has no knowledge about the zipcode distribution in the database state using the arbitrarily chosen program input values often incurs zero returned record when the query is executed against the existing database state.
as a result none of paths involving the while loop body could be explored.
in testing database applications previous test generation approaches e.g.
emmi et al.
then invoke constraint solvers to generate new records and instantiate a new test database state rather than using the given existing database state required in our focused problem.
in contrast by looking into the existing database state as shown in table ii we can see that if we use an input like type zip the execution of the query in line will yield one record c.ssn c.income m.balance which further makes line condition true and line condition false .
therefore using the existing database state we are still able to explore this new path p3 type results.read true diff furthermore if we use type zip the execution of the query in line will yield another record c.ssn c.income m.balance which will make both line condition and line condition true .
therefore we can explore this new path p4 type results.read true diff in section iii we present our approach that can assist pex to determine appropriate program input values such that high code coverage can be achieved using the existing database state.
iii.
a pproach our approach assists pex to determine appropriate program inputs so that high code coverage can be achieved in database application testing.
as illustrated in our example not covered branches or paths are usually caused by the empty returned result set e.g.
for path p1 or insufficient returned records that cannot satisfy later executed conditions e.g.
for path p3 .
the major idea of our approach is to construct an auxiliary query based on the intermediate information i.e.
the executed query s concrete string and its abstract form symbolic expressions of program variables and path conditions collected by dse.
there are two major challenges here.
first program input values are often combined into the executed query after a chain of computations.
in our illustrative example we simply setfzip zip in line to represent this scenario.
we can see that fzip is contained in the where clause of the executed query and zip is one program input.
second record values in the returned query result set are often directly or indirectly via a chain of computations involved in the path condition.
in our illustrative example the program variable diff in the branch condition diff line is calculated from the retrieved values of attributes income and balance .
to satisfy the condition e.g.
diff in line we need to make sure that the program input values determined by our auxiliary query are appropriate so that the query s return records are sufficient for satisfying later executed branch conditions.
a. auxiliary query construction algorithm illustrates how to construct an auxiliary query.
the algorithm accepts as inputs a simple sql query in its both concrete and abstract forms program input values and the current path condition.
formally suppose that a program takes a set of parameters i i1 i2 ... ik as program inputs.
during path exploration dse flips a branch condition pcs e.g.
one executed after the query execution from the false branch to the true branch to cover a target path.
such flipping derives a new constraint or path condition for the target path as pc pc1 pc2 ... pcs.
dse feeds this constraint to the constraint solver to generate a new test input whose later execution however does not cover the true branch of pcsas planned likely due to database interactions along the path.
in the path exploration dse also keeps records of all program variables and their concrete and symbolic expressions in the program along this path when dse reaches pcs.
from the records we determine program variables v v1 v2 ... vt that are data dependent on program inputs i. dse also collects the concrete string of an executed query along the current path.
in our approach we assume the sql query takes the form select c1 c2 ... ch from from list where a1 and a2 ... and an in the select clause there is a list of hstrings where each may correspond to a column name or with arithmetic or string expressions over column names and constants following the sql syntax.
in the from clause there is a from list that consists of a list of tables.
we assume that the where clause contains npredicates a a1 a2 ... an connected by n and s. each predicate aiis of the form expression op expression where opis a comparison operator or a membership operator in not in and expression is a column name a constant or an arithmetic or string expression.
note that here we assume that the where clause contains only conjunctions using the logical connective and .
we discuss how to process complex sql queries in section iii c. some predicate expressions in the where clause of qmay involve comparisons with program variables.
from the corresponding abstract query qabs we check whether each predicate aicontains any program variables fromv.
we take the path p3 line true line true and line 18false in our preceding example shown in figure to illustrate the idea.
the program input set is i type zip and the path condition pc is p3 type results.read true diff the program variable set vis type zip fzip .
when flipping the condition diff pex fails to generate satisfiable test inputs for the flipped condition diff .
the abstract form is shown as qabs select c.ssn c.income m.balance from customer c mortgage m where m.year years and c.zipcode fzip and c.ssn m.ssn we can see that the predicate set ain the where clause is formed as m.year years c.zipcode fzip c.ssn m.ssn .
predicates m.year years and c.zipcode fzip contain program variables years andfzip respectively.
furthermore the program variable fzip is contained in v. in other words the predicate c.zipcode fzip involves comparisons with program inputs.
algorithm shows our procedure to construct the auxiliary query qbased on the executed query q s concrete string andalgorithm auxiliary query construction input a canonical query q q s abstract form qabs program input set i i1 i2 ... ik path condition pc pc1 pc2 ... pcs output an auxiliary query q find variables v v1 v2 ... vt data dependent on i decompose qabswith a sql parser for each clause construct a predicate set a a1 a2 ... an from q s where clause construct an empty predicate set a an empty attribute set cv and an empty query q foreach predicate ai ado ifaidoes not contain program variables then leave aiunmodified and check the next predicate else ifaidoes not contain program variables from vthen substitute ai s program variables with their corresponding concrete values in q else substitute the variables from vwith the expression expressed by i substitute the variables not from vwith their corresponding concrete values in q copy aito a addai s associated database attributes to cv end if end if end for append cvto q s select clause copy q s from clause to q s from clause append a ato q s where clause find variables u u1 u2 ... uu coming directly from q s result set findu s corresponding database attributes cu cu1 cu2 ... cuw foreach branch condition pci pc afterq s execution do ifpcicontains variables data dependent on uthen substitute the variables in pciwith the expression expressed by the variables from u substitute the variables from uinpciwithu s corresponding database attributes in cu add the branch condition in pcito pc end if end for flip the last branch condition in pc append all the branch conditions in pc to q s where clause return q its abstract form qabs and the intermediate information collected by dse.
lines present how to construct the clauses select from and where of the auxiliary query q. we decompose qabsusing a sql parser1and get its npredicates a a1 a2 ... an from the where clause.
we construct an empty predicate set a. for each predicate ai a we check whether aicontains program variables.
if not we leave ai unchanged and check the next predicate.
if yes we then check whether any contained program variable comes from the set v. if no program variables in the predicate are from v we substitute them with their corresponding concrete values in q. in our example the predicate m.year years belongs to category.
we retrieve the concrete value of years from qand the predicate expression is changed as m.year .
if some program variables contained in the predicate come fromv we substitute them with their symbolic expressions expressed by the program inputs in i substitute all the other program variables that are not from vwith their corresponding concrete values in qand copy the predicate aito a. the predicatec.zipcode fzip in our example belongs to this category.
we replace fzip withzip and the new predicate becomesc.zipcode zip .
we also add ai s associated database attributes into a temporary attribute set cv.
those attributes will be included in the select clause of the auxiliary query q. for the predicate c.zipcode fzip the attributec.zipcode is added to aand is also added in the select clause of the auxiliary query q. after processing all the predicates in a we get an attribute setcv cv1 cv2 ... cv j and a predicate set a a1 a2 ... al .
note that here all the predicates in a are still connected by the logical connective and .
the attributes from cvform the attribute list of the q s select clause.
all the predicates in a aconnected by and form the predicates in the q s where clause.
note that thefrom list of the q s from clause is the same as that ofq.
in our example aisc.zipcode zip a ais m.year and c.ssn m.ssn and the attribute set cvis c.zipcode .
the constructed auxiliary query qhas the form select c.zipcode from customer c mortgage m where m.year and c.ssn m.ssn when executing the preceding auxiliary query against the existing database state we get two zipcode values and28223 .
the corresponding program input zip can take either27694 or28222 because of the constraint c.zipcode zip in our example.
a test input with the program input either type zip or type zip can guarantee that the program execution enters the while loop body in lines .
however there is no guarantee that the returned record values satisfy later executed branch conditions.
for example if we choose type zip as the program input the execution can enter the while loop body but still fails to satisfy the branch condition i.e.
diff in line .
hence it is imperative to incorporate constraints from later branch conditions into the constructed auxiliary query.
program variables in branch condition pci pc after executing the query may be data dependent on returned record values.
in our example the value of program variable diff in branch condition diff is derived from the values of the two variables income balance that correspond to the values of attributes c.income m.balance of returned records.
lines in algorithm show how to incorporate later branch conditions in constructing the where clause of the auxiliary query.
formally we get the set of program variables u u1 u2 ... uw that directly retrieve the values from the query salgorithm program input generation input an auxiliary query q program inputs i intermediate results cvand afrom algorithm output program input values rfori execute qagainst the given database get resulting values rv for the attributes in cv substitute the attributes cvfor predicates in awith the values inrv resulting in new predicates in a feed the new predicates in ato a constraint solver and get final values rfori return output final program input values r returned result set and treat them as symbolic inputs.
for each program variable ui we also keep its corresponding database attribute cui.
note that here cuimust come from the columns in the select clause.
we save them in the set cu cu1 cu2 ... cuw .
for each branch condition pci pc we check whether any program variables in pciare data dependent on variables in u. if yes we substitute such variables in pci with their symbolic expressions with respect to the symbolic input variables from uand replace each uiinpciwith its corresponding database attribute cui.
the modified pciis then appended to the q s where clause.
in our example the modified branch condition c.income .
m.balance is appended to the where clause and the new auxiliary query is select c.zipcode from customer c mortgage m where m.year and c.ssn m.ssn and c.income .
m.balance when executing the preceding auxiliary query against the existing database state we get the zipcode value as .
having the constraint c.zipcode zip input type zip can guarantee that the program execution enters the true branch in line .
program input generation.
note that executing the auxiliary query qagainst the database returns a set of values rvfor attributes in cv.
each attribute in cvcan be traced back to some program variable in v v1 v2 ... vt .
recall thatvcontains program variables that are data dependent on program inputs i. our final goal is to derive the values for program inputs i. recall in algorithm we already collected in the predicate set athe symbolic expressions of cvwith respect to program inputs i. after substituting the attributes cvwith their corresponding concrete values in rvresulted from executing qagainst the given database we have new predicates in afor program inputs i. we then feed these new predicates in ato a constraint solver to derive the values for program inputs i. we give our pseudo procedure in algorithm .
in our illustrative example after executing our auxiliary query on table ii we get a returned value for the attributec.zipcode .
in a we havec.zipcode zip .
after substituting c.zipcode inc.zipcode zip with the value we have zip .
the value for the program input zip can then be derived by invoking a constraint solver.
in our prototype we use the constraint solver z32integrated in pex.
z3 is a high performance theorem prover being developed at microsoft research.
the constraint solver z3 supports linear real and integer arithmetic fixed size bit vectors extensional arrays uninterpreted functions and quantifiers.
in practice the result rcould be a set of values.
for example the execution of the auxiliary query returns a set of satisfying zip code values.
if multiple program input values are needed we can repeat the same constraint solving process to produce each returned value in r. b. dealing with aggregate calculation up to now we have investigated how to generate program inputs through auxiliary query construction.
our algorithm exploits the relationships among program inputs program variables executed queries and path conditions in source code.
database applications often deal with more than one returned record.
in many database applications multiple records are iterated from the query s returned result set.
program variables that retrieve values from the returned result set further take part in aggregate calculations.
the aggregate values then are used in the path condition.
in this section we discuss how to capture the desirable aggregate constraints on the result set returned for one or more specific queries issued from a database application.
these constraints play a key role in testing database applications but previous work on generating database states has often not taken them into account.
consider the following code after the query s returned result set has been iterated in our preceding example shown in figure ... while results.read int income int.parse results int balance int.parse results int diff income .
balance if diff count totalbalance totalbalance balance 20a if totalbalance 20b do other calculation... return ... here the program variable totalbalance is datadependent on the variable balance and thus is associated with the database attribute m.balance .
the variabletotalbalance is involved in a branch condition totalbalance in line 20a.
note that the variabletotalbalance is aggregated from all returned record values.
for simple aggregate calculations e.g.
sum count average minimum and maximum we are able to incorporate the constraints from the branch condition in our auxiliary query formulation.
our idea is to extend the auxiliary query with the group by and ha ving clauses.
for example learn that the variable totalbalance is a summation of all the values from the attribute m.balance .
the variabletotalbalance can be transformed into an aggregation functionsum m.balance .
we include c.zipcode in the group by clause and sum m.balance in the ha ving clause of the extended auxiliary query select c.zipcode sum m.balance from customer c mortgage m where m.year and c.ssn m.ssn and c.income .
m.balance group by c.zipcode having sum m.balance cardinality constraints.
in many database applications we often require the number of returned records to meet some conditions e.g.
for performance testing .
for example after execution reaches line we may have another piece of code appended to line as 20c if count 20d computesomething here we can use a special dse technique for dealing with input dependent loops.
with this technique we can learn that the subpath with the conditions in lines and being true has to be invoked at least three times in order to cover the branch condition count in line 20c.
hence we need to have at least three records iterated into line so that true branches of lines and 20c can be covered.
in our auxiliary query we can simply add count in the ha ving clause to capture this cardinality constraint.
select c.zipcode from customer c mortgage m where m.year and c.ssn m.ssn and c.income .
m.balance group by c.zipcode having count program logic could be far more complex than the appended code in lines 20a d of our example.
we emphasize here that our approach up to now works for only aggregate calculations that are supported by the sql built in aggregate functions.
when the logic iterating the result set becomes more complex than sql s support we cannot directly determine the appropriate values for program inputs.
for example some zipcode values returned by our auxiliary query could not be used to cover the true branch of lines 20a b because the returned records with the input zipcode values may fail to satisfy the complex aggregate condition in line 20a.
however our approach can still provide a super set of valid program input values.
naively we could iterate all the candidate program input values to see whether some of them can cover a specific branch or path.
c. dealing with complex queries sql queries embedded in application program code could be very complex.
for example they may involve nested subqueries with aggregation functions union distinct and groupby views etc.
the fundamental structure of a sql query isalgorithm program input generation for dpnf query input a dpnf query qdpnf program inputs i output program input value set rdpnf fori foreach disjunction diinqdpnf s where clause do build an empty query qi append qdpnf s select clause to qi s select clause append qdpnf s from clause to qi s from clause append ditoqi s where clause apply algorithm on qiand get its auxiliary query qi apply algorithm on qiand get output ri rdpnf rdpnf ri end for return output final program input values rdpnf a query block which consists of select from where group by and ha ving clauses.
if a predicate or some predicates in the where or ha ving clause are of the form where qis also a query block the query is a nested query .
a large body of work exists on query transformation in databases.
various decorrelation techniques e.g.
have been explored to unnest complex queries into equivalent single level canonical queries and recent work showed that almost all types of subqueries can be unnested.
generally there are two types of canonical queries dpnf with the where clause consisting of a disjunction of conjunctions as shown below select c1 c2 ... ch from from list where a11 and ... and a1n or ... or am1 and ... and amn and cpnf with the where clause consisting of a conjunction of disjunctions such as a11 or... or a1n and ... and am1 or... or amn .
note that dpnf and cpnf can be transformed mutually using demorgan s rules3.
next we present our algorithm on how to formulate auxiliary queries and determine program input values given a general dpnf query.
our previous algorithm deals with only a special case of dpnf where the query s where clause contains only one a11 and ... and a1n .
we show the algorithm details in algorithm .
our idea is to decompose the dpnf query qdpnf intomsimple queries qi i m .
the where clause of each qicontains only one disjunction in the canonical form ai1 and ... and ain .
we apply algorithm to generate its corresponding auxiliary query qi and apply algorithm to generate program input values ri.
the union of ris then contains all appropriate program input values.
iv.
e valuation our approach can provide assistance to dse based testgeneration tools e.g.
pex for .net to improve code coverage in database application testing.
in our evaluation we seek to evaluate the benefit and cost of our approach from the following two perspectives iii evaluation results on riskit total covered blocks runs time seconds no.
method blocks pex pex ours increase pex ours pex ours getallzipcode .
3time out .
filteroccupation .
4time out .
filterzipcode .
.
.
filtereducation .
4time out .
filtermaritalstatus .
.
.
findtopindustrycode .
4time out .
findtopoccupationcode .
5time out .
updatestability .
6time out .
userinformation .
.
.
updatetable .
.
.
updatewagetable .
8time out .
filterestimatedincome .
8time out .
calculateunemploymentrate .
7time out .
calculatescore .
time out .
getvalues .
time out .
getonezipcode .
6time out .
browseuserproperties .
9time out .
all methods total .
.
.
rq1 what is the percentage increase in code coverage by the program inputs generated by pex with our approach s assistance compared to the program inputs generated without our approach s assistance in testing database applications?
rq2 what is the cost of our approach s assistance?
in our evaluation we first run pex without our approach s assistance to generate test inputs.
we record their statistics of code coverage including total program blocks covered blocks and coverage percentages.
in our evaluation we also record the number of runs and execution time.
a run represents one time that one path is explored by pex using a set of program input values.
because of the large or infinite number of paths in the code under test pex uses exploration bounds to make sure that pex terminates after a reasonable amount of time.
for example the bound timeout denotes the number of seconds after which the exploration stops.
in our evaluation we use the default value timeout 120s and use time out to indicate timeout cases.
pex often fails to generate test inputs to satisfy or cover branch conditions that are data dependent on the query s execution or its returned result set.
we then perform our algorithms to construct auxiliary queries based on the intermediate information collected from pex s previous exploration.
we then execute the auxiliary queries against the existing database and generate new test inputs.
we then run the test inputs previously generated by pex and the new test inputs generated by our approach and then record new statistics.
we conduct an empirical evaluation on two open source database applications riskit4andunixusage5.riskit is an insurance quote application that makes estimation based on users personal information such as zipcode and income.
it has an existing database containing tables attributes and than .
million records.
unixusage is an application to obtain statistics about how users interact with the unix systems using different commands.
it has a database containing tables attributes and more than .
million records.
both applications were written in java.
to test them in the pex environment we convert the java source code into c code using a tool called java2csharptranslator6.
the detailed evaluation subjects and results can be found on our project website7.
a. code coverage we show the evaluation results in table iii and table iv.
for each table the first part columns shows the index and method names.
the second part columns shows the code coverage result.
column total blocks shows the total number of blocks in each method.
columns covered blocks show the number of covered blocks by pex without our approach s assistance the number of covered blocks by pex together with our approach s assistance and the percentage increase respectively.
within the riskit application methods are found to contain program inputs related with database attributes.
these methods contain code blocks in total.
test inputs generated by pex without our approach s assistance cover blocks while pex with our approach s assistance covers blocks.
in fact pex with our approach s assistance can cover all branches except those branches related to exception handling.
for example the method no.
contains blocks in total.
pex without our approach s assistance covers blocks while pex with our approach s assistance covers blocks.
the two not covered blocks belong to the catch statements which mainly deal with exceptions at runtime.
xwu dbgentable iv evaluation results on unixusage total covered blocks runs time seconds no.
method blocks pex pex ours increase pex ours pex ours coursenameexists .
.
.
getcourseidbyname .
.
.
computefiletonetworkratio .
7time out .
forcourseandsessions outputusername .
.
.
deptnameexists .
.
.
computebeforeafterratiobydept .
.
.
getdepartmentidbyname .
3time out .
computefiletonetworkratiofordept .
6time out .
officenameexists .
.
.
getofficeidbyname .
.
.
raceexists .
.
.
useridexists version1 .
.
.
transcriptexist .
.
.
gettranscript .
.
.
commandexists version1 .
.
.
categoryexists .
.
.
getcategorybycommand .
.
.
getcommandsbycategory .
.
.
getunixcommand .
.
.
retrieveusagehistoriesbyid .
.
.
useridexists version2 .
.
.
commandexists version2 .
.
.
retrievemaxlineno .
3time out .
retrievemaxsequenceno .
3time out .
getsharedcommandcategory .
3time out .
getuserinfoby .
4time out .
doesuseridexist .
.
.
getprinterusage .
.
.
all methods total .
.
.
theunixusage application contains methods whose program inputs are related with database attributes with code blocks in total.
pex without our approach s assistance covers blocks while pex with our approach s assistance covers all blocks.
the unixusage application constructs a connection with the database in a separate class that none of these methods belong to.
thus failing to generate inputs that can cause runtime database connection exceptions has not been reflected when testing these methods.
b. cost in tables iii and iv the third part columns shows the cost.
columns and pex show the number of runs and the execution time used by pex without our approach s assistance.
we notice that for both applications pex often terminates with time out .
the reason is that pex often fails to enter the loops of iterating the returned result records.
columns and ours show the additional number of runs by pex with assistance of our approach and the extra execution time i.e.
the time of constructing auxiliary queries deriving program input values by executing auxiliary queries against the existing database and running new test inputs incurred by our approach.
we observe that for both applications pex with assistanceof our approach achieves much higher code coverage with relatively low additional cost of a few runs and a small amount of extra execution time.
in our evaluation we set the timeout as seconds.
for those time out methods pex could not achieve new code coverage even given larger timeout values.
our approach could effectively help cover new branches not covered by pex with relatively low cost.
note that in our current evaluation we loosely integrate pex and our approach we perform our algorithms only after pex finishes its previous exploration i.e.
after applying pex without our approach s assistance since our algorithms rely on the intermediate information collected during pex s exploration.
we expect that after our approach is tightly integrated into pex our approach can effectively reduce the overall cost of pex integrated with our approach which is currently the sum of the time in columns and .
in such tight integration our algorithms can be triggered automatically when pex fails to generate test inputs to satisfy branch conditions that are data dependent on a query s execution or its returned result set.
v. r elated work database application testing has attracted much attention recently.
the agenda project addressed how to generatetest inputs to satisfy basic database integrity constraints and does not consider parametric queries or constraints on query results during input generation.
one problem with agenda is that it cannot guarantee that executing the test query on the generated database states can produce the desired query results.
willmor and embury developed an approach that builds a database state for each test case intensionally in which the user provides a query that specifies the preand post conditions for the test case.
binnig et al.
also extended symbolic execution and used symbolic query processing to generate some query aware databases.
however the test database states generated by their qagen prototype system mainly aim to be used in database management systems dbms testing.
emmi et al.
developed an approach for automatic test generation for a database application.
their approach is based on dse and uses symbolic constraints in conjunction with a constraint solver to generate both program inputs and database states.
we developed an approach that leverages dse to generate database states to achieve advanced structural coverage criteria.
in this paper we focus on program input generation given an existing database state avoiding the high overhead of generating new database states during test generation.
li and csallner considered a similar scenario i.e.
how to exploit existing databases to maximize the coverage under dse.
however their approach constructs a new query by analyzing the current query the result tuples the covered and not covered paths and the satisfied and unsatisfied branch conditions.
it can neither capture the close relationship between program inputs and results of sql queries nor generate program inputs to maximize code coverage.
vi.
c onclusions in this paper we have presented an approach that takes database applications and a given database as input and generates appropriate program input values to achieve high code coverage.
in our approach we employ dynamic symbolic execution to analyze the code under test and formulate auxiliary queries based on extracted constraints to generateprogram input values.
empirical evaluations on two open source database applications showed that our approach can assist pex a state of the art dse tool to generate program inputs that achieve higher code coverage than the program inputs generated by pex without our approach s assistance.
in our future work we plan to extend our technique to construct auxiliary queries directly from embedded complex queries e.g.
nested queries rather than from their transformed norm forms.
acknowledgment.
this work was supported in part by u.s. national science foundation under ccf for kai pan and xintao wu and under ccf for tao xie.