automated support for repairing input model faults senthil mani vibha singhal sinha pankaj dhoolia saurabh sinha ibm research india sentmani vibha.sinha pdhoolia saurabhsinha in.ibm.com abstract model transforms are a class of applications that convert a model to another model or text.
the inputs to such transforms are often large and complex therefore faults in the models that cause a transformation to generate incorrect output can be difficult to identify and fix.
in previous work we presented an approach that uses dynamic tainting to help locate input model faults.
in this paper we present techniques to assist with repairing input model faults.
our approach collects runtime information for the failing transformation and computes repair actions that are targeted toward fixing the immediate cause of the failure.
in many cases these repair actions result in the generation of the correct output.
in other cases the initial fix can be incomplete with the input model requiring further repairs.
to address this we present a pattern analysis technique that identifies correct output fragments that are similar to the incorrect fragment and based on the taint information associated with such fragments computes additional repair actions.
we present the results of empirical studies conducted using real model transforms which illustrate the applicability and effectiveness of our approach for repairing different types of faults.
categories and subject descriptors d. .
testing and debugging debugging aids tracing general terms algorithms experimentation measurement keywords model repair repair actions execution tracing pattern analysis model driven engineering .
introduction model driven engineering mde is the paradigm of software development that uses formal models at different abstraction levels to represent the system under development and uses permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.automated transforms to convert one model to another model or text.1a significant class of model transforms called model to text transforms generate text output e.g.
code configuration files or html jsp files from an input model e.g.
xml or uml .
the inputs to the transforms are often large and complex containing tens of thousands of elements.
therefore faults in an input model that cause a transformation to fail by generating an incorrect output can be difficult to identify and fix.
although model transformation failures can be caused by faults in the transform the goal of our work is to develop techniques for investigating failures that are caused by faults in the input models.
this is particularly relevant in mde where it is a common practice for transform users to use transforms that are not written by them e.g.
standard built in transforms provided by a tool.
therefore when an execution of such a transform fails the pertinent task for the user is to locate and fix faults in the failure inducing input models investigating the transform code is irrelevant from the user s perspective.
in recent work we presented an approach for assisting with fault localization identifying the input model faults for modelto text transforms.
that approach uses dynamic tainting to trace the flow of data from the transform input to the transform output.
using the generated taint logs and a location in the output where a missing or incorrect string occurs the approach identifies the fault space that the user can examine incrementally to locate the fault.
fault localization is only the first step in debugging an input model the next step is fault repair fixing the fault so that the execution of the transform on the fixed model generates the correct output.
although fault localization may identify the problematic parts of the input with high accuracy fixing the fault may not be obvious.
to illustrate consider a case in which an input model attribute isgen determines the outcome of a conditional statement in the transform.
an incorrect value of isgen causes a wrong path to be taken and consequently an incorrect output to be generated.
even though isgen may be identified precisely during fault localization fixing the value of isgen may not be obvious.
this is especially true when the user has no access to the transform code which as mentioned is often the case.
thus in addition to fault localization a technique for supporting fault repair is essential for developing efficient model debugging.
existing work on fault repair for models e.g.
considers only those faults that violate consistency constraints such faults can be detected using consistency checkers.
however in the context of automated transforms a large class of faults may violate no model or transform constraints and yet cause a transformation 1atransform is a function or a program that maps one model to another model or text a transformation is the application or the execution of a transform on a model instance .
failure.
such faults cannot be detected using automated checkers therefore no support for fault repair can be provided.
to extend our work on fault localization and address these limitations in this paper we present techniques to support fault repair fixing the input model faults.
our approach for fault repair collects runtime information for the failing transformation and uses the information to compute repair actions to be performed on the failure inducing input model.
for example a repair action could suggest the addition of an element to the model or a change in the value of a model attribute.
we define different types of runtime information or metadata about the failing transformation that need to be collected to enable the computation of accurate repair actions.
the metadata contain information about conditional statements looping constructs and how input model elements and attributes are accessed during the transformation.
for example for a conditional statement we capture information about the comparison made on an input model element the model element that is compared the comparison operator and the value compared with.
to collect the runtime information we leverage and extend the dynamic taint analysis developed in our previous work .
we present two techniques that leverage the metadata to compute repair actions.
the first technique fault index analysis computes repair actions that are targeted toward fixing the immediate cause of the failure.
this initial set of repair actions can in many cases fix the fault completely so that the transform generates the correct output on the repaired input model.
however in other cases the application of the repair actions may not generate the correct output because the input model requires further repairs.
to address this we present a second technique which performs pattern analysis on the output of the failing transformation to find instances of correct output string fragments that are similar to the incorrect output string fragment.
the intuitive idea underlying this technique is that by analyzing correct samples of similar output fragments appropriate repair actions can be computed.
for instance the correct samples can highlight omissions missing elements and attributes that need to be added to the input model.
in addition to finding similar fragments in the output of the failing transformation pattern analysis can be performed on the output generated from exemplar input models.
we implemented our fault repair approach for xsl based transforms that convert input models to text java code properties files and configuration files .
using the implementation we conducted empirical studies on a set of real transforms to evaluate the usefulness of our approach.
our results indicate that for the subjects considered different types of metadata are necessary to enable the computation of accurate repair actions.
moreover the fault indexbased repair actions suffice for completely fixing many types of faults.
for the types of faults for which the initial repair actions are insufficient the pattern analysis technique computed meaningful repair actions in each instance.
the main contributions of the work are the definition of metadata about failing transformations that enable the computation of accurate fault repair actions the development of two complementary techniques faultindex analysis and pattern analysis for supporting repairs of input model faults the implementation of the techniques for xsl based modelto text transforms empirical results that illustrate the applicability of the techniques in supporting model repairs for real model transforms2.
background in this section we introduce an example to illustrate the problem and discuss our tainting based fault localization technique .
.
example transform and input model model to text m2t transforms are a class of applications that transform input models to text files.
examples of such transforms include uml to java code generators and xml to html converters.
an m2t transform can be implemented using a generalpurpose programming language such as java.
such a transform reads content from input files performs the transformation logic and writes strings to output files.
alternatively a transform can be implemented using specialized templating languages such as xslt extensible stylesheet language transformation that let developers code the transform logic as a template.
the associated xalan library provides the functionality to read the input and write the output to a text file.
figure a presents printuser an example m2t transform written in xslt.
the transform takes as input an xml file containing user information and prints the information in a plain text format.
the xml shown in part b of the figure illustrates a sample input to the transform.
the input model contains two user elements lines and each of which has a family element.
each family element in turn contains a list of user elements that specify the spouse and dependents of the containing user element.
as illustrated a user element can have five attributes first last hasmiddle middle and gender .
a user element also has a relationship element contained within it.
each element has a unique node id specified as the tagattribute which is added by our infrastructure to identify input model elements.
printuser iterates over the top level user elements using the xsl for each construct line .
within the loop it first calls function printusername shown in lines to print the user name lines .
then it processes family elements lines it prints spouse details lines and dependent details lines .
to print the spouse information the transform uses the choose construct at line to test the gender attribute of user lines .
if the value of gender isf the transform selects the contained user element whose relationship sub element has type attribute with value husband line and prints the husband s name lines .
lines perform a similar processing for the case where the value of gender ism.
the output of the transform on the sample input is shown in figure c .
lines of the output correspond to the data printed for the first user element lines of the input .
transform lines print output lines transform lines print output line and transform lines print output lines .
the input model contains three faults that which cause incorrect output to be generated.
the incorrect parts of the output which have missing substrings are highlighted in the output as e1 e2 and e3.
e1 illustrates a missing middle name on output line .
this occurs because of a fault in line of the input the user element is missing attributes hasmiddle andmiddle .
e2 highlights missing text for the spouse name which occurs because of the fault in input line where element relationship is missing attribute type.
finally e3 highlights missing dependent details this occurs because element family in input line is missing an entire user sub element.
.
fault localization in previous work we presented a dynamic tainting based approach that can assist in locating such input model faults.
as mentioned earlier the goal of our work is to assist with locating and 196figure illustrative example a xsl transform printuser b a failure inducing input and c the corresponding incorrect output the error markers e1 e2 and e3 in the output point to locations where substrings are missing .
figure association of taint marks with the input left and propagation of the marks to the output right .
fixing input model faults and not transform faults .
therefore we assume that the transform is correct.
moreover we assume that the input model satisfies all consistency constraints imposed by the metamodel or required by the transform.
the fault localization approach associates taints marks with inputmodel elements and adds probes to the transform that propagate the taint marks to the output string.
a key feature of our approach is that it distinguishes different types of taint marks data taints control taints and loop taints which are propagated at different transform statements.
a data taint is propagated at assignments and statements that directly or indirectly construct the output string.
acontrol taint is propagated at conditional statements to the parts of the output that are constructed along the branches of the conditional.
a loop taint is propagated at looping constructs to the output strings that are constructed within the loops.
the taint marks associated with substrings of the output are used to construct a fault space which the user can examine incrementally to locate the fault.
to illustrate consider a smaller fragment of the input model of figure b shown in a tree form in figure left .
the model el ements and attributes have taint marks labeled t1tot8 associated with them.
during the execution of the transform these taint marks are propagated to the output string to generate a taint log.
the right side of the figure shows an intuitive representation of the taint log.
different substrings in the output have data control and loop taints associated with them.
for example the output string jane has data taint t3 dassociated with it because the string is constructed from the input model attribute first which was initialized with taintt3.
for another example the output string p. is generated under a condition line of printuser whose outcome is determined by attribute hasmiddle which was initialized with taint t5 therefore t5is propagated to p. as control taint t5 c. a data or a control taint can be empty i.e.
it may enclose no string.
this occurs when an input model attribute is empty or no string is generated along the taken branch of a conditional whose outcome is determined by an input model attribute.
given a taint log and an error marker i.e.
a location in the output text where a missing or incorrect string occurs identified by the user the fault localization technique identifies enclosing taints in reverse order of nesting and constructs the fault space incrementally.
to illustrate for failure e1 line of printuser attempts to access attribute hasmiddle for the second user.
because this attribute does not exist no control taint information is generated for the access.
starting at the error marker our fault localization technique would search for the enclosing control taints.
it would identify the control taint that was propagated at line the loop that lex2figure shows an abstract representation of the taint log.
in our implementation the taint log is an xml file in which different elements and their nesting structure capture the taint information.
we show samples of taint logs in the discussion of our approach section .
197figure overview of our approach which performs faultindex analysis and pattern analysis to compute repair actions.
ically encloses line via the call in line .
thus the fault would be localized to the second user element in the input model.
although our fault localization technique is able to localize such faults effectively it provides no guidance on how the fault should be fixed.
next we present techniques that provide automated support for repairing such input model faults.
.
automated fault repair the goal of our approach for fault repair is to offer recommendations to the user on how to fix a faulty input model that causes a transformation failure.
a fix recommendation rconsists of a set of repair actions on a faulty input model.
a repair action ron an input model is a unit change to be made to the model.
we define a repair action as follows r add attr toelem t add elem toelem t set attr tovalue value the first action adds an attribute with an arbitrary possibly empty value to an element.
the second action adds an element to another element.
the final action sets an attribute to the specified value any value other than the specified value or to an arbitrary value indicated by .elem is an element name whereas elem tcan be an element name for a newly added element by a repair action or a node id for an existing element in the model .
figure presents the overall approach for debugging input model faults it includes both fault localization and fault repair.
given a transform program tand a failure inducing input model ifaulty for which tgenerates an incorrect output fault localization assists in identifying the input model fault.
given a user provided error marker and the taint log for the failing transformation the fault localizer computes the fault space and the fault index lfiin the taint log the relevant taint mark for a given error marker.
to compute repair actions we have extended the taint propagation mechanism to collect additional information or metadata about the failing transformation.
the fault repair approach takes as input the fault index in the taint log.
it computes a set of alternative recommendations r. the user can select a recommendation r r and apply the repair actions in rto the faulty input.
next we define the metadata required for computing accurate repair actions section .
.
following that we present the two fault repair techniques fault index analysis section .
and pattern analysis section .
.
both these techniques leverage a common algorithm for computing repair actions which we present in section .
.
finally we present an analytical discussion of the approach section .
.
.
metadata collection for fault repair for fault localization information about the flow of input data to output text in the failing transformation is sufficient.
however tosupport fault repair extra information that indicates how the input data was used to create the output is required.
this metadata essentially allows us to recreate to some degree the transform logic.
our approach collects three types of metadata for the failing transformation accesses of input model entities conditional statements and selection of model elements from a collection.
metadata about entity access.
we collect metadata about transform statements that directly or indirectly attempt to access input model entities elements or attributes .
for entities that exist in the input model this information is naturally captured via taint propagation.
however for a missing entity no taint initialization occurs therefore no taint propagation is performed even though the transform attempts to access the attribute.
to handle such cases we augment the transform instrumentation to collect runtime information about accesses to input model entities irrespective of whether the access succeeds.
the metadata is captured in a get element in the taint log.
this element has two attributes xpath which records the path in the input model along which a model entity is accessed and startnode which records the input model element on which the path is executed.
figure a shows the metadata collected at line of printuser when executed on the faulty input.
the xpath attribute of the get element indicates the access of hasmiddle .
the startnode attribute of get indicates that the hasmiddle is being accessed on element .
.
thus although hasmiddle for the second user element is missing the collected information indicates that the attribute was attempted to be accessed at line .
metadata about conditional statements.
for a conditional statement i.e.
anifor a case statement our technique collects information about the comparison that occurs at the statement the left hand and right hand expressions which could represent an input model entity or a string literal and the comparison operator.
for example for line of printuser we collect information that attribute hasmiddle for a particular user element is compared to true using the equality operator.
in the taint log the information is represented in a condition element with attributes leftnode and lvalue to capture the left hand expression opto capture the comparison operator and rightnode andrvalue to capture the right hand expression.
if an expression is a string literal the node attribute does not occur.
if the accessed input model attribute does not exist neither the node attribute nor the value attribute exist.
the condition element in the taint log fragment for line shown in figure a illustrates this.
in this case condition is missing leftnode and lvalue attributes because the accessed attribute hasmiddle does not exist in the input model.
metadata about selection in loops.
transforms often select specific elements from a collection of elements based on some selection criteria.
for such statements we collect data about the input model elements being iterated over and the selection criterion being applied to each element.
the taint log in figure b illustrates the metadata collected at lines .
the get sub element of the loop element which contains information about loop taints records the selection criterion an xpath expression in the xpath attribute.
the xpath captures the fact that the type attribute of the relationship element is compared using the equality operator to string wife.
3thexpath attribute can capture a general xpath expression http .
for xslt based transforms this expression is readily available during the transform execution.
198figure illustration of fault repair a for e1 using metadata about attribute access and conditional statements b for e2 using metadata about selection in loops and c for e3 using metadata and pattern analysis.
.
fault index analysis the fault index analysis uses the metadata associated with the fault index to compute repair actions.
consider the taint log fragment shown in figure a in which the fault index for failure e1 is highlighted as i1.
the fault index is an empty control taint which is preceded by a condition node.
this control taint is propagated during the execution of line of the transform on the faulty input.
thus the empty control taint indicates that the fault caused the conditional in line of printuser to evaluate false.
the metadata associated with the condition element lets our technique reconstruct the expected evaluation as leftnode true .
however the leftnode attribute is not present in the taint log suggesting that the input model entity that was accessed as leftnode did not exist.
next the get element preceding the condition element provides information that attribute hasmiddle was accessed on inputmodel element .
.
putting together all this information the technique computes the following repair actions add hasmiddle to1.
set hasmiddle totrue figure b illustrates the fault index for e2 highlighted by the ellipse.
similar to e1 the fault index is an empty control taint.
the control taint is preceded by a next element whose parent element is a loop element.
this indicates that the fault causes a loop iteration to not occur.
the metadata associated with the get sub element of loop captures the criterion that was used to select the elements to be iterated over.
thus starting at element .
the transform expected the path family user relationship to exist in the input such that the type attribute of relationship was wife.
moreover the analysis is able to resolve the access of relationship to id .
.
.
.
see line in figure b we discuss the resolution algorithm in section .
thus the fault index analysis issues two repair actionsadd type to1.
.
.
.
set type towife part c of figure illustrates the fault index for e3.
in this case the problem is traced to a missing loop iteration which occurs because the selection criterion is not satisfied.
following a similar approach as for e2 the analysis computes four repair actions add user to1.
.
add relationship touser add type torelationship set type todependent the repair actions computed by the fault index analysis target fixing the immediate cause of the failure.
however some faults can require multiple fixes in the input model.
for such faults the repair actions computed by fault index analysis fix the model only partially.
in our example both e1 and e3 illustrate partial fixes.
for e1 after repair actions r1 e1 and r2 e1 are applied and the transform is rerun the desired output the middle name for user amit vyas is still not generated.
although the repair actions fixed attribute hasmiddle attribute middle was still missing in the fixed model.
on this execution the fault index is the empty data taint marked i2in figure a .
the fault index analyzer computes the following additional repair actions for e1 add middle to1.
set middle to in this manner the user could iteratively perform fault localization and repair and in each iteration fix the model partially based on the repair actions computed by the fault index analysis until the fix is complete.
clearly such an approach can be cumbersome.
our pattern analysis technique which we discuss next addresses this problem by identifying all possible repair actions that may be required to generate the correct output.
199figure intuitive illustration of the pattern analysis performed on the hierarchy of taint marks.
.
pattern analysis pattern analysis attempts to find output string fragments that are similar to the incorrect string fragment.
it does this based on the structure of taint marks in the taint log.
intuitively the taint marks in the log have a hierarchical tree like structure.
figure presents an illustrative example.
each taint mark in the log is represented as a node.
the edges in the tree represent the nesting among the taint marks.
the sibling nodes are ordered from left to right based on their sequence of occurrence in the log.
thus each node has anindex associated with it which specifies the position of the node among its siblings.
in the figure the index of a node is specified as a subscript .
a loop taint has a control taint child per iteration of the loop and one control taint child for the last loop condition evaluation after which execution exits the loop .
in addition to the three types of taints nodes also represent string literals which have no taints associated with them.
a data or a literal node can occur only as a leaf node.
the fault index of a taint log maps to a taint node in the taintlog tree.
in figure node is the fault index.
intuitively starting at the fault index the pattern analysis traverses up in the tree to identify the unique path to the root which we refer to as thefault path .
this path is highlighted in the figure with shaded nodes.
next the analysis traverses down in the tree in a depth first manner guided by the fault path to find a matching path that is at least as long as the fault path and that ends at a data node.
the fault path guides the downward traversal in the following manner.
if a loop node is encountered the traversal explores each child of the node except the child that occurs in the fault path .
at any nonloop node the traversal continues at the child node whose index matches the index of the corresponding node i.e.
the node at the same depth in the fault path.
for the fault path the algorithm traverses node it does not traverse because its index does not match the index of the fault node.
because is a loop node the analysis explores all its child nodes except for because it occurs on the fault path.
the analysis traverses four paths which are emphasized with thick lines in the figure.
of these the subpaths in dotted lines illustrate the traversals along which the analysis finds no relevant paths for computing repair actions.
for example path is irrelevant because its length is less than the length of the fault path.
path is irrelevant because it does not end at a data or string literal node path is also irrelevant of same reason.
the highlighted path is the only matching path.
the search for matching paths is guided by the fault path to ensure that a similar string is explored by the pattern analysis.
the constraints on the path length i.e.
path must be at least as long asalgorithm computerepairactions input ltaint log ttaint mark in l output rfix recommendation for t begin .iftis a data taint then .
ift s preceding element e next e.node then .
add tor .
elsefind preceding get element e access of missing entity .
add tor .
add tor .else if tis a control taint then .
ift s preceding element e1 next then missing loop iteration .
find e1 s preceding get element e2 .
add tor .
else if t s preceding element e1 condition then .
if e1.leftnode e1.rvalue then .
add tor .
else if negationslash e1.leftnode e1.rvalue then .
find e1 s preceding get element e2 .
add tor .
add tor end figure the algorithm for computing intermediate repair actions.
the fault path and on the last node i.e.
the node must be a data node ensure that the repair actions computed based on a matching path will lead to a change in the output text at the error marker.
the repair actions are generated based on the metadata associated with the taints that are encountered starting at the node where the length of the matching path is equal to the length of the fault path.
to illustrate the pattern analysis consider the taint log shown in figure c which is used to compute repair actions for e3.
we illustrate paths using the line numbers in the log.
the fault path in the log is .
to find a similar output instance the algorithm traverses the matching path .
in the matching path it skips the first six nodes because the length of the fault path is six and then repair actions are computed based on the metadata information associated with node i.e.
at lines and .
this part of the taint log is highlighted with a bounding box.
the next element at line indicates that attribute first of .
.
.
is printed.
generalizing the metadata information to model entity types we identify that attribute first is required for model entity of type user .
.
.4is a model entity of type user .
therefore the pattern analysis suggests the following additional repair actions for e3 add first touser set first to combined with the four repairs actions r1 e3 computed by the fault index analysis our approach thus computes a recommendation with six repair actions.
in general for each matching path an alternative recommendation is computed.
.
algorithm for computing repair actions the fault index and pattern analyses compute repair actions starting at a taint mark t. in the case of fault index analysis tis the fault index whereas in the case of pattern analysis tis a taint encountered during the traversal of a matching path in the taint tree structure.
both these analyses leverage a common algorithm that computes repairs actions for a given taint mark.
the algorithm consists of three steps.
the first step computes intermediate repair actions.
an intermediate repair action can contain an xpath expression.
for example for e2 the intermediate repair actions corresponding to r1 e2 and r2 e2 are computed as4 add family user relationship type wife to1.
4the symbol in an xpath expression represents access a node attribute.
200figure presents the algorithm that given a taint mark t computes repair actions for t. for a data taint the algorithm checks whether a preceding next element with a node attribute exists if it does the created repair action suggests a change in the value of the named attribute lines .
if no such element exists the algorithm looks for a preceding get element line which captures information about access of a missing entity in this case the algorithm computes two repair actions to suggest the addition of the missing entity with some value lines .
for a missing loop iteration lines a similar repair action is generated by accessing information about the loop selection criterion captured in a get element .
for a condition element if leftnode andrvalue exist a repair action is generated that sets leftnode to either rvalue or the negation of rvalue depending on the comparison operator lines .
finally if leftnode does not exist indicating a comparison with a missing entity and rvalue exists appropriate add and setactions are created lines .
the intermediate repair actions can contain complex xpath expressions parts of which may already exist in the input model in the second step we refine the intermediate repair actions based on such existing parts.
this step executes each xpath on the input model to identify parts that already exist in the input.
for the non matching non existent xpath parts we generate repair actions.
to illustrate consider the intermediate repair action for e2 which has the complex xpath family user relationship type .
any of the direct or indirect sub elements of .
family user relationship or the attribute type of relationship could be missing.
we execute this xpath on the input model starting at .
.
this returns node .
.
.
.
up to which the match has occured but beyond that type is missing.
thus we generate the repair actions r1 e2 and r2 e2 which suggest that a type attribute be added to .
.
.
.2and its value be set to wife.
in the last step after all the recommendations have been computed we prune the recommendation set to filter out duplicate recommendations and invalid recommendations.
two recommendations are equal if they consist of the same set of actions.
an invalid recommendation is one whose application can alter the output prior to the error marker.
the goal of fault repair is to fix the input in such a way that the output at the error marker changes to the expected output all text preceding the error marker is assumed to be correct.
therefore we classify a recommendation as invalid if it can potentially change any output text that precedes the error marker.
to illustrate consider the scenario in which the fault for e2 has been fixed i.e.
an appropriate type attribute has been added to line of the input figure b .
in this case the analysis can recommend two sets of repair actions for e3.
one of them requires the addition of a new dependent user sub element to the family element in line of the input.
the second one suggests modifying the user element in line as follows set .
.
.
.type todependent however because .
.
.
.type is used to generate spouse details applying this repair action would change the part of output that is assumed to be correct.
therefore this recommendation is classified as invalid and filtered out.
.
discussion although we have illustrated our approach using xslt based transforms it is applicable more generally to other transform implementations e.g.
in java.
for such implementations the runtime metadata would need to be collected appropriately to generate the taint log.
for example collecting the metadata for loop selections which is fairly straightforward for xslt transforms would require analysis to identify the code that performs the selection.
similarly table subjects used in the empirical studies.
xslt constructs used in the subjects select subject templates loop condition data variables simple complex total clsgen1 clsgen2 intgen1 intgen2 plugingen propgen total identifying the metadata for conditionals would require code analysis and appropriate instrumentation.
however the fault index and pattern analyses which operate on the taint log remain unchanged.
the pattern analysis computes repair actions based on instances of correct strings that are similar to the incorrect string.
it presumes that all matching paths identified in the taint tree structure generate correct strings.
therefore if a model contains multiple faults the analysis could use an incorrect string to compute repair actions.
in our approach we assume that all output before the error marker is correct and if there are multiple faults the user identifies the error markers in order from the beginning of the output.
with these assumptions the pattern analysis could compute repair actions based on only those strings that precede the error marker alternatively it could rank lower the repair actions that are computed based on strings that follow the error marker.
.
empirical evaluation we implemented our fault repair approach and conducted empirical studies.
the goals of the studies were to investigate the effectiveness of the fault index analysis and the characteristics of the recommendation sets computed by the pattern analysis.
after describing the experimental setup we present the results of the two studies.
.
experimental setup .
.
subjects and faulty inputs we used six xsl transforms listed in table as our experimental subjects.
the transforms are real programs that have been developed in projects at ibm research.
each transform takes as input a domain specific ecore emf model and generates different types of text output clsgen1 andclsgen2 generate java classes intgen1 andintgen2 generate java interfaces plugingen generates an xml configuration file and propgen generates a properties file consisting of name value pairs.
table lists different xslt features used in the subjects which indicates the complexity of the subjects.
columns list respectively the counts of template column for each column if when otherwise column value of column and variable param column .
columns present data about the select construct.
we classified a select as simple if it contained no condition or axes e.g.
child parent and complex otherwise.
as the data indicate clsgen2 is the most complex subject whereas propgen is the least complex.
to generate failure inducing input models we used the technique of generating test inputs by applying mutation operators to a valid input e.g.
.
specifically we defined four mutation operators deleteelement deletes a model element deleteattribute deletes a model attribute enumerateattribute modifies the value of an attribute based on a predefined enumeration of values for the attribute and emptyattribute sets an attribute to empty.
we used two valid input models that contain approximately and entities respectively.
we applied the mutation 201table faulty inputs generated using the mutation operators.
delete delete empty enumerate subject element attribute attribute attribute total clsgen1 clsgen2 intgen1 intgen2 plugingen propgen total operators to the two valid inputs to generate faulty inputs.
given the large sizes of our input models we used an upper limit of for each input to bound the number of mutants.
from the initial set of mutants we eliminated equivalent mutants mutants that caused no change in the transform output.
table lists the number of faults of different types that were generated for the subjects.
overall the different types of faults are fairly well represented deleted element faults have a lower representation but nonetheless are not insignificant in number.
a fair distribution lowers the bias that predominant numbers of some fault types might have introduced in our studies.
.
.
implementation we leveraged and extended the implementation infrastructure which had we developed in our previous work on fault localization for xslt based transforms .
our implementation converts an xslt program to a java translet on which all the analyses operate.
the infrastructure consists of five main components.
a taint api which contains taint initialization and taint propagation methods.
an instrumentation component implemented using bcel which adds probes to the translet bytecode to invoke control tainting and loop tainting method.
an aspect weaver component implemented using aspectj which weaves in aspects to the instrumented bytecode to invoke taint initialization and data tainting methods.
an indexer component which sanitizes and indexes the raw taint log to make it appropriate for querying.
a differencing component which compares the faulty output with the correct output and identifies the first point at which the output differs specified as the error marker .
reference provides the implementation details.
as part of the extensions for this work we bound additional aspects over the translet class specifically at calls to iterator and compare methods of the xalan api to extract metadata information.
we implemented the fault index analyzer and the pattern analyzer in java to compute all possible recommendations.
we automated the execution of all the steps using a ant build script.
.
effectiveness of fault index analysis .
.
goals and methods the goals of the first study were to evaluate the applicability and effectiveness of the fault index analysis.
we measure applicability as the percentage of faults for which different types of metadata can be used for computing repair actions.
in the discussion we refer to the entity access condition and select metadata as me mc and ms respectively.
thus applicability indicates the importance of a particular type of metadata in terms of how often it can be used in practice.
we measure effectiveness as the percentage of faults for which the repair actions computed by the fault index analysis completely fix the faulty model.
to collect the data we executed each subject on each of its faulty input model.
for each execution we identified the error marker in the incorrect output using a file differencing utility and mappedthe marker to the fault index in the taint log.
next we used the fault index analyzer to compute repair actions.
we determined applicability by identifying the mutation operator and the fault index.
for example for operators deleteelement and deleteattribute if the fault index points to a control taint meandmcare applicable if the fault index points to a loop taint meandmsare applicable finally if the fault index points to a data taint meis applicable.
thus metadata applicability depends on both the type of fault and the structure of the program.
.
.
results and analysis figure presents data about applicability and effectiveness.
the chart on the left shows the applicability data.
it contains a segmented bar for each subject.
the height of a bar represents of the faulty inputs for the subject for which we computed repair actions.
note that these numbers are less than the faulty inputs shown in column of table .
this occurs because for some of the faults no repair actions are required and no meaningful repairs actions can be computed.
for example consider a fault where the value of an attribute name is incorrect and suppose that name is simply written out by the transform i.e.
it is not used at a condition or a select.
in such cases no suggestion can be made on how the incorrect value of name should be fixed.
the fault localization would point the user to name and it would be up to the user to decide how to change the value.
the segments within the bars represent the percentage of faults for which me mc and msare applicable individually.
in some cases meandmcare applicable together and meandms are applicable together the bar chart contains segments for these combinations as well.
for example for clsgen1 of the total faults were fixed using the merecommendation were fixed using both meandmc were fixed using both meandms were fixed using mc and the remaining required ms. overall the data indicate that meis applicable in many cases typically in combination with mcandms.
this confirms our belief that mecollects valuable metadata about accesses of model entities.
this information is especially useful when the accessed entity is missing in the model.
the percentage of faults for which mewas required varied from for clsgen1 to for intgen2 .
on average mewas required for of the faults.
another observation we make is that msis applicable quite frequently as well both individually and in conjunction with me.
on average msis applicable for .
of the faults.
figure b presents the completeness data.
in pretty much all cases for the faulty inputs in which elements were missing i.e.
the inputs created using the deleteelement mutation operator the application of repair actions computed by the fault index analysis resulted in incomplete fixes.
in general repairs performed based on the fault index analysis would be complete for a missing element fault only if the element is a leaf element or none of its attributes or sub elements are accessed by the transform.
we did not observe such cases in our subjects.
on average for of the faults the metadata based repairs were complete whereas for the remaining the repairs were incomplete.
.
characteristics of recommendation sets .
.
goals and methods the goal of this study was to evaluate our approach in terms of the number and sizes of the computed recommendations.
for each subject except clsgen2 and each faulty input for the subject we ran the pattern analyzer on the taint logs with the fault index identified in it and computed the sizes of the recommendation sets.
one 202figure applicability of different types of metadata for computing repair actions using the fault index analysis left and the completeness of fixes resulting from the application of those repair actions to the faulty inputs right .
figure sizes of recommendations computed using the pattern analysis.
of the steps of our approach is the removal of duplicate recommendations.
to assess the benefit of this step we collected data about the reduction in the number of recommendations after the removal of duplicate recommendations.
.
.
results and analysis figure shows the distribution of the sizes of the recommendation sets.
the height of the segmented bar for a subject represents of the faulty inputs for the subject.
the segments in a bar depict different ranges of sizes.
for example for intgen2 for of the faulty inputs our approach computed recommendations consisting of only one repair action for of the faulty inputs it computed recommendations containing two repair actions for of the inputs the recommendations contained between three and five repair actions and for the remaining the recommendations contained between six and nine repair actions.
for propgen all the recommendations contained only two repair actions.
for none of the subjects except plugingen more than repair actions were computed the largest recommendation set for plugingen consisted of repair actions the average recommendation set size was two.
thus for our subjects and faulty inputs the pattern analysis computed recommendations that were not very large.
table presents data about the reduction achieved by the removal of duplicate recommendations.
maximum reduction occurs when the pruned recommendation set contains only one recommendation over all subjects this was achieved for of the faulty inputs.
for another of the faulty inputs at least reduction occurred.
for propgen after the removal of duplicates all the recommendation sets contained only one recommendation.
on average of the recommendation sets contained no duplicates therefore no reduction occurred for these sets.
to summarize the data indicate that the pattern analysis can often compute duplicate recommendations and that the removal of duplicates can achieve significant reductions.
thus the removal of duplicates is an important and effective step in our approach.table reduction in the sizes of the recommendation sets.
suject recommenation set reduction .
.
.
clsgen1 intgen1 intgen2 plugingen propgen .
threats to validity the most significant threats to the validity of our results are threats to external validity which arise when the observed results cannot be generalized to other experimental setups.
in our studies we used six xslt based subjects and therefore we can draw limited conclusions about how our results might hold for transforms written using other frameworks.
however our transforms vary in complexity and generate different types of outputs code properties and configuration files which gives us confidence that the results might apply to other xslt transforms.
for transforms written using other frameworks the effectiveness of the approach would vary depending on the quality of the metadata that is collected.
another threat to validity is the representativeness of the faulty input models.
we used mutation analysis to generate the faulty models which may not represent the types of faults that occur frequently in practice.
however based on our experience with developing transforms we designed the mutation operators to capture commonly occurring faults.
this threat is further mitigated by the fact that different types of faults were well represented in our set of faulty models.
a related threat is that in our studies each faulty input contained a single fault.
further experimentation using inputs that contain multiple faults is required to provide evidence of the usefulness of our approach in more general settings.
for this study we performed the pattern analysis on the taint log for the faulty input model only we did not use additional exemplar models.
because our input models are large and contain instances of different elements pattern analysis using only the faulty input worked well.
if the faulty input model was not as comprehensive as the inputs used in our studies or if exemplar models were used to perform the pattern analysis the effectiveness of pattern analysis might vary.
in the extreme case when no instance of correct pattern is available only the fault index analysis which can compute partial fixes would be applicable.
.
related work fault localization and repair is an active research area that has a rich body of work.
however most of the research addresses the problems of locating and fixing faults in programs.
unlike this research the goal of our work is to provide support for repairing faults in large and complex inputs.
from the perspective 203of this goal existing research that is most closely related to ours is the work on automated repair of model inconsistencies e.g.
and automated repair of data structures e.g.
.
although the overall goal of this work and our work is similar the types of faults targeted and the techniques developed for supporting fault repair differ significantly.
specifically in the context of uml models existing research has developed approaches for detecting design inconsistencies in linked models and suggesting repairs to fix the inconsistencies after changes are made to the models .
in these approaches the patterns for design inconsistencies are identified manually they include both generic patterns that apply to all uml models and model specific constraints.
the fixes could be specified statically along with the pattern e.g.
by using first order logic formulas .
xiong and colleagues present a language that can be used for writing both consistency relations and fixing behavior.
thus the existing techniques for supporting model repairs focus on only those faults that can be specified as consistency relations.
our goal is not to fix statically identifiable inconsistencies but to fix conditions in the input that do not violate consistency constraints and yet cause a transformation failure.
existing research in data structure repair attempts to fix inconsistencies at runtime to prevent unexpected program termination.
demsky and rinard present a specification based approach for dynamic detection and repair of data structure inconsistencies.
elkarablieh and colleagues leverage program assertions to identify consistency constraints expected on the input data structures.
their approach uses static analysis and symbolic execution to identify the repair actions at the assertion point.
unlike this research the goal of our work is to assist the user in fixing faults in input models.
moreover our work focuses on supporting fault repair after a failure is observed its goal is not to detect and fix faults on the fly during transform execution.
other techniques for providing automated support for bug fixes focus on faults in programs.
kim and colleagues present an approach for building a catalog of project specific bug patterns and bug fix patterns.
by analyzing the code changes made to fix bugs their approach creates a normalized representation of a bug code that is deleted in a bug fix and the bug fix code that is added in a bug fix .
based on pattern matching on such a catalog their approach can suggest fixes.
debugadvisor and hipikat create a project memory by mining relationships between various software artifacts present in different project repositories.
for any new bugs users can query these project memories to understand how similar bugs have been fixed in the past.
.
summary and future work we presented an approach for assisting transform users in fixing faulty input models.
we defined different types of information about the failing transformation that are essential for computing accurate repair actions we presented two techniques that analyze the metadata and compute repair actions.
finally we demonstrated the feasibility of our approach by implementing it for xslt transforms.
there are several directions for future work.
although the metadata that our approach requires are generic in nature the ease with which they can be collected can vary with different transform implementations.
our current implementation has explored the technique for xslt transforms.
future work could investigate how such metadata can be collected for transforms written using other frameworks or general purpose languages such as java.
to suggest complete fixes for an incorrect output our approach performs pattern analysis to identify correct output string fragmentsthat are similar to the incorrect or missing output string fragment.
to be successful pattern analysis requires samples of correct output to be available.
when such samples are unavailable which can occur in practical scenarios pattern analysis would not be applicable.
moreover a sample input model may not exercise all paths in the transform to generate a particular output.
therefore the alternative sets of recommendations we compute may be incomplete.
to overcome these limitations predicate switching may be a promising technique which we plan to investigate.
finally user studies are required to evaluate how it can help users locate and fix faults efficiently and effectively.