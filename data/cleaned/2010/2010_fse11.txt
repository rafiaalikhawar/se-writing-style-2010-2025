how dofixesbecome bugs?
a comprehensivecharacteristicstudyonincorrectfixesin commercialand open sourceoperatingsystems zuoning yin ding yuan yuanyuan zhou shankar pasupathy lakshmi bairavasundaram department ofcomputer science univ.
ofillinois aturbana champaign urbana il usa zyin2 dyuan3 cs.uiuc.edu department of computer science andengineering univ.
ofca lifornia san diego lajolla ca92093 usa yyzhou cs.ucsd.edu netapp inc. sunnyvale ca94089 usa pshankar lakshmib netapp.com abstract software bugs affect system reliability.
when a bug is exposed in the field developers need to fix them.
unfortunately the bug fixing process can also introduce errors which leads to buggy patches that further aggravate the damage to end users and erode software vendors reputation.
this paper presents a comprehensive characteristic study on incorrect bug fixes from large operating system code base s including linux opensolaris freebsd and also a mature commercial os developed and evolved over the last 12years investigating not only the mistake patterns during bug fixi ng but also the possible human reasons in the development process when these incorrect bug fixes were introduced.
our major findings include at least .
.
of sampled fixes for post release bugs1in these large oses are incorrect and have made impacts to end users.
among several common bug types concurrency bugs are the most difficult to fix correctly of concurrency bug fixes are incorrect.
developers and reviewers for incorrect fixes usually do not have enough knowledge about the involved code.
for example of the incorrect fixes are made by developers who have never touched the source code files associated with the fix.
our results provide useful guidelines to design new tools and also to improve the development process.
based on our findings the commercial software vendor whose os code we evaluated is building a tool to improve the bug fixing and code reviewing process.
categories and subject descriptors d. .
software engineering general general terms reliability 1these only include those fixes for bugs discovered after software releases.
permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
esec fse september szeged hungary.
copyright acm ... .
.keywords incorrect fixes software bugs bug fixing human factor testing .
introduction .
motivation as a man made artifact software suffers from various errors referred to as software bugs which cause crashes han gs or incorrect results and significantly threaten not only the reliability but also the security of computer systems.
bugs are detected either during testing before release or in the field by customers post release.
once a bug is discovered developers usually need to fix it.
in particular for bugs that have direct severe impact on customers vendors usually make releasing timely patches the highest priority in order to minimize the amount of system down time.
unfortunately fixes to bugs are not bullet proof since they are also written by human.
some fixes either do not fix the problem completely or even introduce new problems.
for example in april mcafee released a patch which incorrectly identified a critical windows system file as a virus .
as a result after applying this patch thousands of systems refused to boot properly had lost their network connection s or both.
in trend micro also released a buggy patch which introduced severe performance degradation .
the company received over calls from customers about this issue and eventually spent more than million to compensate customers.
the above two incidents are not the only cases in recent history.
as a matter of fact there were many other similar events in the past which put the names of big companies such as microsoft apple and intel under spotlight.
we had also conducted a study on every security patch released by microsoft in its security bulletin since jan uary to april .
surprisingly out of the total released security patches of them were buggy when they were first released.
these patches were expected to fix some severe problems.
once released they were usually applied to millions of users automatically.
therefore they would have enormous impacts and damages to end users as well as software vendors reputation.
mistakes in bug fixes may be caused by many possible reasons.
first bug fixing is usually under very tight time schedule typically with deadlines in days or even hours char buf ...... lines omitted sprintf buf you have an existing file s. n ... sprintf buf you have an existing file s do you want to rename the existing keytab a very long message ?
n ... kerberos.c freebsd first fix second fix char buf char buf ...... lines omitted sprintf buf you have an existing file snprinf buf sizeof buf you have an ... s do you want to rename the existing keytab a very long message ?
n ... figure an incorrect fix example from freebsd.
a part of the first fix appended a console message with some additional information unfortunately introducing a buffer overflow the added lines are in bold while the deleted lines are crossed out .
definitely not weeks.
such time pressure can cause fixers2 to have much less time to think cautiously especially about the potential side effects and the interaction with the rest of the system.
similarly such time pressure prevents teste rs from conducting thorough regression tests before releasin g the fix.
figure shows a real world example from freebsd the original bug fix appended a log message with additional information.
unfortunately the fixer did not pay attention to the buffer length defined lines upwards in the same file and introduced a buffer overflow.
sock lock so if inp check sockaf so pf inet if so so pcb null return ...... sock unlock so audit arg.c freebsd first fix second fix sock lock so if inp check sockaf so pf inet if so so pcb null sock unlock so return ...... sock unlock so figure an incorrect fix example from freebsd.
the first fix tried to fix a data race bug by adding locks which then introduced a deadlock as it forgot to release the lock via sock unlock before return .
second bug fixing usually has a narrow focus e.g.
removing the bug comparing to general development.
as such the fixer regards fixing the target bug as the sole objective and accomplishment to be evaluated by his her manager.
therefore he she would pay much more attention to the bug itself than the correctness of the rest of the system.
similarly such narrowly focused mindset may also be true for the testers tester may just focus on if the bug symptom observed previously is gone but forget to test some other aspects in particular how the fix interacts with other parts and whether it introduces new problems.
as shown in figure the fixer just focused on removing the data race bug by adding locks.
while the data race bug was removed the fix unfortunately introduced a new bug a deadlock.
this deadlock was obviously not discovered during regression testin g. third the two factors above can be further magnified if fixers or reviewers are not familiar with the related code.
while an ideal fixer could be someone with the most knowledge about the related code in reality it may not always be the case.
sometimes it may be difficult to know who is the best person to do the fix.
even if such person is known he she may be busy with other tasks or has moved to other projects and is therefore unavailable to perform the fix.
sometimes it is due to the development and maintenance process.
some software projects have separate teams for 2we will refer the developer who fixes the bug as the fixer in the rest of the paper.developing and maintaining software.
all these real world situations can lead to the case that the fixer does not have enough knowledge about the code he she is fixing and consequently increases the chance of an incorrect fix.
this might help explaining the incorrect fix shown in figure from the commercial os we evaluated.
when we measure the fixer s knowledge based on how many lines he had contributed to the file involved in the patch we found that he had never touched this file in the past indicating that he may not have sufficient relevant knowledge to fix the bug correctly.
if correct sum if correct sum blk count blk clear flag blk f blk valid rescan.c a commercial os first fix second fix if correct sum blk count if correct sum blk count !blk scan exist blk blks calc blk clear flag blk f blk valid figure an incorrect fix that hadn t fixed the problem completely.
this example is from the large commercial os we evaluated.
the first fix tried to address a semantic bug by modifying the ifcondition.
unfortunately the revised condition was still not restrictive enough.
regardless what is the reason for introducing these errors during bug fixing and why they were not caught before release their common existences and severe impacts on users and vendors have raised some serious concerns about the bug fixing process.
in order to come up with better process and more effective tools to address this problem we need to first thoroughly understand the characteristics of incorre ct fixes including how significant is the problem of incorrect fixes?
more specifically what percentages of bug fixes are incorrect?
how severe are the problems caused by incorrect fixes?
what types of bugs are difficult to fix correctly?
are some types of bugs just more difficult to fix correctly so that fixers testers and code reviewers for these types of bug fixes should pay more attention and effort to avoid mistakes?
what are the common mistakes made in bug fixes?
are there any patterns among incorrect bug fixes?
if there are some common patterns such knowledge would help alerting developers to pay special attention to certain aspects during bug fixing.
additionally it may also inspire new tools to catch certain incorrect fixes automatically.
what aspects in the development process are correlated to the correctness of bug fixing?
for example does fixers and reviewers relevant knowledge have a high correlation to incorrect fixes?
a few recent studies had been conducted on certain aspects of incorrect fixes .
for example liwers ki et al.
proposed an effective way to automatically locate fix inducing changes and studied the incorrect fix ratios in eclipse and mozilla.
they found developers are easier to make mistakes during bug fixing on friday.
purushothaman et al.
studied the incorrect fix ratio in a switching system from lucent but their focus was on the impact of one line changes.
gu et al.
studied the incorrect fix ratio in three apache projects but they focused on providing a new patch validation tool.
while these studies have revealed some interesting findings most of them focused more on incorrect fix ratios and studied only open source code bases providing one of the first steps toward understanding incorrect bug fixes.
thisimportance of incorrect fixes implications at least .
.
of examined fixes for post release bugs are incorrect.
of the examined incorrect fixes can cause crashes hangs data corruptions or security problem s.although the ratio of incorrect fixes is not very high the imp act of the incorrect fixes indicate that the problem of incorrect fixes is significant and worth special attention.
among common types of bugs and based on our samples fixes on concurrency bugs of them are most error prone followed by semantic bugs and then memory bugs .developers and testers should be more cautious when fixing concurrency bugs.
incorrect fixes to concurrency bugs implications fixes on data race bugs can easily introduce new deadlock bugs or do not completely fix the problem.the synchronization code added for fixing data races need to be examined in more detail to avoid new deadlock.
knowing all the access locations to the shared objects is the key to fix data race completely.
fixes to deadlock bugs might reveal bugs which were hidde n by the previous deadlock.fixers need to further examine the path after deadlock in cas e there are some bugs hidden due to the existence of the deadloc k. incorrect fixes to memory bugs implications fixing buffer overflows by statically increasing the buffe r size is still vulnerable to future overflows.
fixing buffer ov erflows by dynamically allocating memory could introduce null pointer dereference bugs if the allocated memory is used wit hout check.it is better to use safe string functions e.g.
snprintf or bound checking to fix buffer overflow.
fixers need to be aware of the potential memory leaks and the failure of allocation when fix ing buffer overflows by dynamically allocating memory.
fixing memory leaks can introduce dangling pointer bugs when freeing the memory without nullifying the pointer and memory corruption when freeing something that should not be freed or do not solve the problem completely when forgettin g to free the members of a structure.it is good to nullify the pointer after freeing the memory.
it is also important to clearly understand what and when should be freed to avoid overreaction.
fixers should remember to free the structure members when freeing a complex structure to avoid an incomplete fix.
human reasons to incorrect fixes implications comparing to correct fixes the developers who introduce d incorrect fixes have less knowledge or familiarity with th e relevant code.
of the incorrect fixes are even made by fixers who previously had never touched the files involved in the fix.code knowledge has influence on the correctness of bug fixes.
it is dangerous to let developers who are not familiar with th e relevant code to make the fix.
interestingly in most of the cases the developers who a re most familiar times of the actual fixers with the relevant code of these incorrect fixes are still working on the project but unfortunately were not selected to do the fixes.having a right software maintenance process and selecting t he right person to fix a bug is important.
the code reviewers for incorrect fixes also have very poor relevant knowledge.it is also important to select a developer who is familiar wit h the relevant code as the code reviewer.
table our major findings of real world incorrect bug fix characteris tics and their implications.
please take our methodology and potential threats to validity into conside ration when you interpret and draw any conclusions.
paper goes much beyond prior work studying both commercial and open source large operating system projects and investigating not only incorrect fix percentages but al so other characteristics such as mistake patterns during bug fixing types of bugs that are difficult to fix correctly as well as the potential reasons in the development process for introducing incorrect bug fixes.
.
our contribution to the best of our knowledge this paper presents one of the most comprehensive characteristic studies on incorrect fixes from large oses including a mature commercial os developed and evolved over the last years and three open source oses freebsd opensolaris and linux exploring not only the mistake patterns but also the possible human reasons in the development process when these incorrect fixes were introduced.
more specifically from these four os code bases we carefully examined each of the randomly selected fixes for post release bugs and identified the incorrect fixes.
to gain a deeper understanding of what types of bugs are more difficult to fix correctly as well as the common mistakes made during fixing those bugs we further sampled another set of fixes on certain important types of bugs.
the details of our methodology and potential threats to validity are described in section .
our major findings are summarized in table .
these findings provide useful guidelines for patch testing and val i dations as well as bug triage process.
for example motivated from our findings the large software vendor whose os code was evaluated in our study is building a tool to improve its bug fixing and code review process.
while we believe that the systems and fixes we examined well represent the characteristics in large operating syst ems we do not intend to draw any general conclusions about all the applications.
in particular we should note that all of t he characteristics and findings in this study are associated wi th the types of the systems and the programming languages they use.
therefore our results should be taken with the specific system types and our methodology in mind.
paper outline in section we discuss the methodology used in our study and threats to validity.
section .
after that we present our detailed results on the incorrect fix rati o in section .
then we further study which types of bugs are more difficult to fix and what common mistakes could be made in section .
after that we study the human factors which could lead to incorrect fixes in section .
section is the related work and we conclude in section .
.
methodology in this section we first discuss the software projects used in our study section .
the techniques to find incorrect fixes section .
how we select bug samples section .
and how we study the influence of human factors on bugfixing section .
.
at the end we talk about the threats to the validity of our study section .
.
.
software projects under study app loc open src?
the commercial os confidential n freebsd .97m y linux .94m y opensolaris .99m y table the four oses that our study uses.
table lists the four code bases we studied including a commercial closed source os from a large software vendor3 and three open source oses freebsd linux and opensolaris .
we chose to study os code because they are large complex and their reliability is critically important.
add itionally as os code is developed by many programmers contains lots of components uses a variety of data structures and algorithms it could provide us a broad base to understand incorrect fix examples.
the four oses have different architectures.
the commercial os is especially designed for high reliability system s with many enterprise customers like big financial companies and government agencies.
it has evolved for almost years.
the other three open source oses have different origins.
freebsd originates from academia berkeley unix .
opensolaris originates from a commercial os solaris .
linux completely originates from the open source community.
we think the variety in data sources would help us find general software laws or interesting specificiti es.
these oses usually have multiple branches series in their os families.
we focus on those branches which are both stable and widely deployed.
for the commercial os we chose the branch which is most widely deployed.
for freebsd we chose freebsd series.
for linux we chose linux .
series.
for opensolaris it has a different release model so we just studied the releases since its .
version.
in order to further preserve the privacy and reputation for the software vendor we anonymized the results in section and .
the four code bases will be just referred as a b c and d with the mapping information hidden.
we know that such anonymization may prevent us from making some interesting comparison between open source and commercial code bases but fortunately we can still make many other findings like the ones summarized in introduction.
.
finding incorrect fixes the definition of incorrect fix a bug fix fxis defined as an incorrect fix if there is another following bug fix fy that fixes either a new problem introduced by fx or the original problem that was not completely fixed by fx.
note that we consider only fixes to bugs not any general or non essential changes e.g.
feature addition or renaming .
this is identified by checking whether a fix is associated with a bug report.
this screening criteria is important to the fidelity of our study since bug reports often contain rich information which is important for us to understand the fix.
it is hard to obtain a complete picture from the bug fix itself alone.
unfortunately the link between fixes and bug reports is not always systematically maintained .
for the commercial os and opensolaris the scm software configuration 3due to confidentiality agreement we can neither mention the company s name nor the loc of its os.management systems record the link between every bug report and every change.
however for freebsd and linux such links are only documented voluntarily by developers in an unstructured way.
to identify such links we use a method similar to the methods used in .
the main idea is to leverage the verbal information in the bug reports or change logs to reconstruct the links.
for example developers may write the bug is fixed by change 0a134fad in a bug report.
then we can link the bug to the change 0a134fad.
after the above process we will have a set of bug fixes linked with bug reports.
we then randomly select a target number of bug fixes and then semi automatically check whether each one is an incorrect fix or not.
we call the process semi automatic because we use a two step process first step automatically selects potential incorrect fix candida tes while the second step manually verifies each candidate.
two techniques are used in the first step to automatically identify potential incorrect fix candidates.
first we look at thesource code overlap between changes.
this technique is similar to the methods used in .
if there is source code overlap between two changes then the latter change may be made to correct the previous change.
more specifically if a latter change fyoverwrites or deletes the code written in the previous change fxorfyjust adds code in the proximity lines of fx we regard fxas an incorrect fix candidate for manual examination.
the second technique is to search for specific keywords in the bug report and change log of each fix that may suggest an incorrect fix.
for example if we find this patch fixed a regression introduced by the fix in bug in the bug report linked with fy we regard the fix in bug as an incorrect fix candidate.
in general we find the first technique to be more comprehensive.
please note that the first step is only identifying candidates.
we still need to manually examine each candidate which is the unique challenge in our study.
we examined all the relevant code related to each fix.
we also examined the bug reports and change logs to get proof from developer s explanation.
for some fixes we even discussed with developers of these systems to ensure the correct understanding on them.
then based on all the evidences we got we finally decide whether a fix is incorrect or not.
also note that the first step may prune a few incorrect fixes out especially those incorrect fixes whose next fixes in a completely different location without any overlap at all i.e.
beyond the lines proximity .
but we expect such incorrect fixes are very rare as two subsequent fixes to the same problem usually has good locality in terms of code changes.
and we did try to relax the proximity requirement to be within the same file but did not find more incorrect fixes.
.
the target bugs to study in this study we used two sets of bug fixes with different focuses.
sample set to get this sample set we first randomly sampled a total of bug fixes from each os that are associated with bug reports.
from these bug fixes we further select only those fixes to post release bugs in total .
selecting such post release bug fixes allows us to focus on fixes to bugs that made high impacts to both customers and vendors.
post release bugs are selected afte rthe random sampling instead of before the sampling because the manual effort in verifying all bug fixes would be too huge.
we then use the process described in the previous subsection to identify and study incorrect fixes.
sample set this sample set is used to further zoom in certain bug types observed in sample set whose fixes are most error prone.
specifically we chose to study the fixes to memory leak buffer overflow data race and deadlock bugs.
however it is difficult to reuse the bugs in sample set since there are not statistically sufficient number of bug fixe s for these types of bugs.
therefore we deliberately sampled more bug fixes focusing on these four types.
specifically we used all the related keywords to search for the bug fixes of a specific type.
keyword search is enough to get these bug fixes since there are only limited ways to name them.
then we randomly selected from each type for each code base.
in total we sampled fixes which provide us a richer base set to study the incorrect fixed patterns.
this set is only used in section .
.
measuring codeknowledge to understand why a programmer cannot fix a bug correctly we also dive deeper into his her knowledge about the relevant code.
in this study we measure code knowledge by checking the cumulative authorship of each line of code at a particular version which can be systematically measured .
from scm we obtain the authorship of each line for a file at a given version by using commands such as svn annotate .
assume a developer d a file f a function fand a version v we calculate code knowledge at two levels of granularity k file d f v the loc written by dforfatv the total loc in fatv k func d f f v the loc written by dforfinfatv the total loc in the fatv we use percentage as the unit of k file andk func .
for example k file d f v means of code lines infat version vare written by d.dmay write these code lines in any version that is not later than v. both fixers and reviewers knowledge are measured in our study in this way.
.
threats to validity real world empirical studies are all subject to validity problems so is our study.
potential threats to the validity of our study are the representativeness of the selected softwa re projects the representativeness of the incorrect fix sampl es our classification process and evaluation methodology.
representativeness of software both commercial and open source software are covered in this study so we believ e that we have a good coverage for at least os code.
we do not intend to draw any general conclusions in all software but some of the findings such as fixers and reviewers knowledge would also apply to other applications.
representativeness of bug fix samples we studied only those bug fixes that could be linked to a bug report.
the set of fixes that cannot be linked were not covered and some of our findings might not hold in them .
fortunately the results from the commercial os and opensolaris are immune to this threat since every bug fix is linked to a bug report.
since the results from freebsd and linux show a similar trend as the commercial os and opensolaris which may ease the concern on this threat for this problem.
as discussed earlier there is also a potential problem inour automatic filtering process i.e.
we can potentially fil ter out an incorrect fix if its subsequent fix does not have any proximity in code location.
fortunately our exercises o f relaxing the proximity constraint did not discover any more incorrect fixes which indicates that the amount of missed incorrect fixes should be very low.
threats of manual classification our study involves manual classification on bug reports and fixes which cannot be replaced by automatic techniques.
therefore subjectiv ity is inevitable.
however we tried our best to minimize such subjectivity by using double verification.
also the authors have previous experience in studying bugs and familia r with oses .
for every incorrect fix candidate we examined all the information sources we could have including source code bug reports change logs etc.
besides for some fixes we also discussed with developers of these systems to ensure the correct understanding on them.
since we manually examined each incorrect fix candidate and classify it as incorrect only if we have concrete evidence we are confident that the number of false positives should be very low.
limitation in measuring the knowledge the way we measure code knowledge is relatively simple since we only want to check the fixers and reviewers knowledge in a coarsegrain qualitative way.
a more sophisticated knowledge model might provide us more accurate results in section which remains as our future study.
.
isincorrectfixreallyasignificantproblem?
the ratio of incorrect fixes among all bug fixes and the impact of bugs introduced by incorrect fixes are important for us to accurately understand whether incorrect bug fix is a significant problem.
as described in section we first randomly sampled bug fixes from the four oses from each os among them are fixes to post release bugs.
app of post release of incorrectratiobug fixes fixes a .
.
b .
.
c .
.
d .
.
table the ratio of incorrect fixes on sampled postrelease bugs in the four oses.
a confidence interval is used.
table shows the ratio of incorrect fixes based on our samples is .
.
among the four oses.
as discussed in section .
this is only a lower bound estimation.
conside ring that the fixes on post release bugs would be applied by a lot of customers and users even this ratio can still have sig nificant impact.
since regression testing had already been applied before releasing the fixes it also indicates genera l testing techniques may need to be tailored to be more effective in capturing the errors in patches.
we further studied the impact of the bugs introduced by the examined incorrect fixes.
we judge the impact based on the symptoms described in the bug reports.
we found .
of them introduced crash .
caused system to hang .
led to data corruption or data loss .
caused security problem .
degraded the performance and .
introduced incorrect functionality.
some bugs introducedare actually more severe than the original bugs.
moreover for some bugs they could even be incorrectly fixed for several times.
finding at least .
.
of the sampled bug fixes are incorrect.
moreover of the incorrect fixes resulted in severe bugs that caused crash hang data corruption or security problems.
implication incorrect fix is indeed a significant problem that requires special attentions from software vendors.
.
incorrectfix patterns though bug fix patterns had already been studied in few had studied the patterns of incorrect fixes before.
in this section we first study which types of bugs are more likely to introduce incorrect fixes.
then we probe deeper into each of these bug types and try to understand their incorrect fix patterns via case studies.
finally we discuss how we can leverage those patterns to detect incorrect fixes in the testing process.
.
which types of bugs are more difficult to fix correctly?
we classified all the sampled fixes into three categories based on the bugs they fix memory bug concurrency bug or semantic bug.
semantic bugs are those bugs that cannot be classified as memory or concurrency bug and are usually application specific problems.
this classification is adopt ed from previous literature .
app concurrency memory semantic a b c d overall table the number of incorrect fixes among all the sampled fixes and the incorrect fix ratio for the three categories of bugs in the four oses.
table shows the ratio of incorrect fixes to each type of bug.
based on our samples concurrency bugs have the largest incorrect fix ratio overall indicating concu rrency bugs are the hardest to fix.
semantic bugs and memory bugs have similar ratio and respectively.
we focus on studying concurrency bugs and memory bugs while only providing some high level discussion on semantic bugs section .
.
.
this is because semantic bugs have very diverse root causes so that it is difficult to observe general patterns from their fixes and the mistakes in the fixes.
bug types and their percentages data race deadlock buffer overflow memory leak uninitialized read null pointer deref table the most observed bug types among all the concurrency bugs and memory bugs being fixed incorrectly.
only top six are shown.
to select the important types of bugs for a detailed study we further dive into all the concurrency bugs and memory bugs being fixed incorrectly to see which sub types are most observed.
the result is shown in table .
among all the bug types data race deadlock buffer overflow and memory leak are the top four types of themost observed concurrency bugs and memory bugs which were fixed incorrectly.
therefore we just focused on the characteristics of bug fixes to these four types of bugs.
appbug types race deadlock buf overflow mem leak a b c d all table the number of incorrect fixes among the all the fixes and the incorrect fix ratio for the four important types of bugs from sample set .
table further shows the ratio of incorrect fixes for these four types of bugs.
the result is from fixes only to these bug types sample set mentioned in section .
where for each type we randomly sampled fixes from each code base.
we use this data set instead of the one used above because among the original fixes sample set mentioned in section .
there are not statistically sufficient numbe r of bug fixes for these four types of bugs.
sample set provides us a richer base set of incorrect fixes to conduct our case studies in section .
.
as indicated in table fixes to data race and deadlock are most error prone with an incorrect fix ratio of and respectively which is generally 4x 6x of buffer overflow and memory leak.
finding based on our samples concurrency bugs are the most difficult to fix right.
among concurrency and memory bugs which were fixed incorrectly the four most observed bug types are data race deadlock buffer overflow and memory leak.
implication developers and testers should be more cautious when fixing concurrency bugs.
the allocation of fixing and testing resources could consider the types of bugs to be fixed.
.
mistakes inbug fixing after understanding which types of bugs are more difficult to fix right it would be interesting to understand the common mistakes patterns when fixing a particular type of bugs and the consequence introduced by those incorrect fixes.
in this section we use the incorrect fix examples got from sample set .
generally we find there are two types of incorrect fixes incomplete fixes andintroducing new problems while each type of bug also has its own incorrect fix patterns.
we also discuss techniques to detect or reveal these mistakes either extending current techniques or sug gesting new approaches.
.
.
fixingdataraces the most common practice for fixing data race is to add synchronization primitives e.g.
locks to create mutual exclusion on shared resources.
however delivering a correct fix requires deep reasoning on all the side effects of the newl y added synchronization which is often error prone.
specifically adding locks might introduce deadlock.
this incorrect fix pattern is observed in all the four code bases we evaluated and in .
out of of the incorrect fixes to data race bugs.
figure shows one of the examples.
in the first fix a lock scwas added to avoid a race.
however the function bus teardown intr is not supposedfxp lock sc ether ifdetach sc arpcom.ac if ..... bus teardown intr sc dev ... fxp unlock sc if fx.c freebsd first fix second fix fxp lock sc ether ifdetach sc arpcom.ac if ..... fxp unlock sc bus teardown intr sc dev ... figure incorrect fix to a data race introduced a deadlock.
the function bus teardown intr cannot be called with lock held otherwise deadlock will be introduced.
to be called inside the critical section otherwise it can le ad to deadlock.
unfortunately developers were not aware of this rule and made the incorrect fix.
to fix this deadlock bus teardown intr was moved out of the critical section.
figure in section is another example of this pattern that fixing data race introduces deadlock.
the fixer forgot to release the lock via sock unlock before a return statement therefore a deadlock happened.
implications when adding synchronization primitives fixers need to make sure the newly added primitives e.g.
lock will not introduce deadlocks with the existing synchr onization code.
this can be checked by extending deadlock detectors to only focus on the synchronization primitives newly added.
besides lock and unlocks should be added in pairs along all the execution paths in the newly formed atomic region.
this can be checked automatically by extending some existing path sensitive bug detection tools such a s racerx or pr miner to only scan the code regions touched by the fix.
spin lock irqsave hcall lock flag plpar hcall9 ... spin unlock irqrestore hcall lock flag ...... plpar hcall9 norets ... hcp if.c linux first fix second fix spin lock irqsave hcall lock flag plpar hcall9 ... spin unlock irqrestore hcall lock flag ...... spin lock irqsave hcall lock flag plpar hcall9 norets ... spin unlock irqrestore hcall lock flag figure fix to a data race was not complete.
the first fix only added locks to protect function plpar hcall9 while forgot to protect plpar hcall9 noret which contains the access to the same shared objects in plpar hcall9 .
fixing data races could be incomplete such that not all the data races are fixed.
this incorrect fix pattern is observed in three of the code bases we evaluated and in .
out of of the incorrect fixes to data race bugs.
for example as shown in figure when adding locks the developer forgets to lock all the places she should lock.
implications for a complete fix to data race it is important to know all the accesses to the shared objects which could race with each others.
we can design checkers to detect where the same shared objects are protected by lock in some paths but unprotected in some others and make these checkers focus only on checking the patched code.
.
.
fixingdeadlocks to fix a deadlock developers may either reverse the order of locks or even drop some locks.
however these means need to be applied with caution.
specifically fixing deadlocks could still lead to deadlock bugs.
this incorrect fix pattern is observed in three of the code bases we evaluated and in .
out of of the incorrect fixes to deadlocks.
figure shows such an example.
the root cause of this incorrect fix is similar to the onedown write bonding if ... rtnl lock if atomic read ... cnt rtnl unlock goto out bond destroy bond rtnl unlock goto out ... out up write bonding first fix second fix if ... rtnl lock down write bonding if atomic read ... cnt goto out bond destroy bond up write bonding rtnl unlock goto out ... out bond sysfs.c linux if ... rtnl lock down write bonding if atomic read ... cnt goto out unlock bond destroy bond goto out unlock ... out unlock up write bonding rtnl unlock out original bug figure incorrect fix to a deadlock introduced a new deadlock.
the first fix reversed the order of locks to prevent deadlock but forgot to release locks before taking agoto path.
rw enter iss iss lockp mutex enter stmf lock for i i nentries i ... mutex exit stmf lock rw exit iss iss lockp ... for i i nentries i ... first fix second fix mutex enter stmf lock rw enter iss iss lockp for i i nentries i ... rw exit iss iss lockp mutex exit stmf lock ... for i i nentries i ... stmf.c opensolaris mutex enter stmf lock rw enter iss iss lockp for i i nentries i ... ... for i i nentries i ... rw exit iss iss lockp mutex exit stmf lock original bug figure a fix to a deadlock exposed a hidden data race bug.
in figure .
therefore we can again extend some current path sensitive bug detection tools to spot the deadlock.
additionally fixing deadlock may reveal some other bugs that were originally hidden by the deadlock especially dat a race bugs.
this incorrect fix pattern is observed in two of the code bases we evaluated and in .
out of of the incorrect fixes to deadlocks.
though we only spotted such cases we think this is still an interesting pattern.
figure shows one of the examples.
there are two bugs in the original code a deadlock caused by the wrong order of the two locks and a data race caused by an unprotected shared variable in the second forloop.
however the data race is hidden by the existence of the deadlock since the execution would not even reach the second forloop due to the deadlock.
the first fix resolved the deadlock.
however it also enables the execution to proceed so that the data race is much easier to manifest.
implications the hang introduced by deadlock bugs might prevent some execution paths from being exercised thoroughly which could make some bugs hidden in those paths difficult to manifest.
after removing deadlock bugs fixers should further test those execution paths.
.
.
fixingbuffer overflow we also found some interesting incorrect fixes examples for memory bugs.
however since the total numbers of incorrect fixes to buffer overflows and memory leaks in sample set2 is not statistically large enough and respectively we do not claim those examples are frequently observed incorrect fix patterns.
however we assume these examples could be common for the incorrect fixes to buffer overflows and memory leaks shown in section .
.
if we can further enlarge our sample set.
common techniques to fix buffer overflow include a restrict the length of the data which will be stored into buffer by using safe string functions e.g.
snprintf or do boundchecking b increase the buffer size statically from stack c allocate larger buffer dynamically from heap to replace a stack buffer.
based on our observation technique a is usually safe and seldom introduces any further incorrect fixes since it eradi cates the chance of a buffer overflow in the future.
implications the good practice to fix buffer overflow is to use safe string functions or do bound check when possible.
vm offset t avail vm offset t avail for indx avail !
indx size1 avail avail machdep.c freebsd first fix second fix vm offset t avail vm offset t avail for indx avail !
indx size1 avail avail figure incorrect fix to a buffer overflow by increasing static buffer size.
the first fix enlarged the buffer size to but the size was still not big enough.
under certain input avail was still overflown.
technique b is potentially problematic if the developer cannot anticipate the input size accurately.
the buffer size after increasing may still be not enough for an untested input in the future.
as shown in figure the first fix was incomplete.
after it increased the size of avail to avail was still overflown later.
actually even the second fix might still be flawed.
since the developer does not add a bound check a future input beyond the size could still overflow avail .
implications increasing the static buffer size can be dangerous if the input size cannot be accurately estimated.
char tempmail char tempmail len strlen tmpdir tempmail char malloc len ... strcpy tempmail tmpdir temp.c freebsd first fix second fix char tempmail len strlen tmpdir if tempmail malloc len ... null panic out of memory strcpy tempmail tmpdir figure incorrect fix to a buffer overflow by allocating heap memory.
the first fix allocated heap memory to replace stack buffer but the return value of malloc was unchecked.
for technique c developers need to be aware of the rules to use memory allocation functions.
the memory allocated needs to be freed after use otherwise it may introduce a memory leak.
besides developers need to consider to do error handling if memory allocation fails.
as shown in figure the fixer did fix the buffer overflow but introduced a potential invalid memory access.
implications when allocating memory dynamically to fix buffer overflow developers also need to follow the safety rules of using memory allocation functions.
.
.
fixingmemoryleak once a memory leak is detected writing fixes may be straightforward but mistakes can still be made.
specifically fixing memory leak can introduce dangling pointer or null pointer dereference if the pointer would sti ll be accessed after the free.
figure shows an example where a dangling pointer bug was introduced.
implications it is a good practice to nullify the pointer after freeing it which can avoid dangling pointer bugs.
developer may also not be aware of the condition to free an object.
they should only free an object when it is no longer used.
if they overreact they could mistakenly free an object still in use under certain conditions.
figure shows such an example which led to data corruption.void blk online work online t p ...... kmem free p return void blk scan blk online work info find blk by id info wit fs toc.c a commercial os first fix second fix void blk online work online t p ...... kmem free p p null return void blk scan blk online work info find blk by id info wit fs figure incorrect fix to memory leak introduced a dangling pointer.
the pointer pwas later used in function find blk by id with null pointer check.
however the first fix simply freed pwithout nullifying it.
...... acm free m usm case username auth.c a commercial os first fix second fix if is default get choices acm free m usm case username figure incorrect fix to a memory leak introduced data corruption.
the first fix freed the data indexed bycase username unconditionally.
however the data should be freed only under certain conditions.
implications before fixing memory leak developers should make sure when and what should be freed.
if lseek cat fd nextset ...... free cat set msgcat.c freebsd first fix second fix if lseek cat fd nextset ...... if !cat set tag free cat set data free cat set figure incomplete fix to a memory leak.
the first fix only freed cat set but forgot to free its member data .
besides fixing memory leak can be incomplete.
for some complex data structures fixers may forget to free all their members.
figure shows such an example.
implications for complex data structures fixers should remember to free all their members.
.
.
fixingsemanticbugs semantic bugs have very diverse root causes so the ways to fix them are also diversified.
however we still observed one common incorrect fix pattern for semantic bugs conditions e.g.
ifcondition are difficult to fix correctly.
as shown in figure in section the first fix to the ifcondition was still not restrictive enough.
though this pattern i s frequently observed it is not easy to leverage current tech niques to detect them.
we think fixing semantic bugs correctly may require more application specific knowledge from fixers.
.
.
generalapproachesto detectincorrectfixes understanding the impact of the change a fundamental reason for developers to make mistakes during bug fixing is that they do not know all the potential impacts of the newly fixed code.
for example in figure the fixer was not aware that the newly added lock scwould deadlock with the function bus teardown intr .
if all such potential influenced code either through control or datadependency is clearly presented to developers they may have better chances to detect the errors.
we envision compiler techniques such as program slicing can be extended to analyze such information using the dependencies to the patch as the slicing criterion.appactual fixer for actual fixer for potential incorrect fixes correct fixes optimal fixer k file k func k file k func k file k func a .
.
.
.
.
.
.
.
.
.
.
.
b .
.
.
.
.
.
.
.
.
.
.
.
c .
.
.
.
.
.
.
.
.
.
.
.
d .
.
.
.
.
.
.
.
.
.
.
.
avg .
.
.
.
.
.
table the fixers average code knowledge on the buggy files functio ns.
the variance of the code knowledge is shown in the parentheses.
code knowledge is shown in the form of percentage e.g.
.
means a knowledge value of .
.
potential optimal fixer is the developer with th e most knowledge on the buggy files functions but might not be always assigned the bug fixing task.
apply checkers incrementally as discussed before it is possible for some existing bug detection tools checkers to detect some types of incorrect fixes.
however applying these tools directly on the full code base after the fix is not practical it may take a very long time for them to scan the entire code base which may be redundant with the original testing steps or not always necessary.
also it may produce too many false positives.
instead developers may want to check the code influenced by the patch first.
one observation is that sometimes just checking within the function boundary is enough to detect problems in the patch.
for example in figure section a path sensitive checker that simply checks the rule lock is always paired with an unlock can easily detect the missed sock unlock by only scanning the function that the patch modified.
dealing with incomplete fixes some incomplete fixes are introduced by the fact that fixers may forget to fix all the buggy regions with the same root cause.
this types of incomplete fixes can be mitigated by using technique which searches for other places that have the same patterns or usage scenarios in entire code.
for example in figure the first fix that suggested certain shared objects need to be protected.
then developers can try to find the other places where those objects are accessed without protection .
however this technique is less effective when a consistent pattern is difficult to learn.
moreover those incomplete fixe s related to conditions figure in section cannot be solve d by this technique.
.
lack ofknowledge multiple factors can influence developers to make an incorrect fix.
in this section we focus on programmers code knowledge.
intuitively if a file or a function is mostly writ ten by a developer the developer may have higher chance to give a correct fix to a bug rooted in that file or function.
we first measured the k file andk func defined in section .
for the fixers who made the incorrect fixes.
the incorrect fixes are from sample set .
the results are shown in table .
we found that in general these fixers who made the incorrect fixes were not knowledgeable about the buggy files functions.
specifically they had only contributed on average .
to the files and .
to the functions involved in the patch before they made the incorrect fix.
in comparison table also shows the fixers knowledge in correctfixes.
the correct fixes are from the complement of the incorrect fix set .
we found those fixers who made the correct fixes had contributed on average .
to the files and .
to the functions.
in other words the knowledge of the fixers who made the correct fixes is .
times of that of the fixers who made the incorrect fix based on ourcode knowledge metrics indicating source code knowledge could be a factor to incorrect fixes.
but can we really find a developer who is more knowledgeable than the actual fixer of the incorrect fix?
table also answered this question surprisingly by selecting th e most knowledgeable developer who is still active in the development when the bugs need to be fixed as the fixer the k file andk func can reach as high as .
and .
respectively which is times of the knowledge of the actual fixers in incorrect fixes.
additionally by selecting the two of the most knowledgeable developers as reviewers two is the average number of reviewers in the oses we studied the k file andk func can reach .
and .
respectively which is times of the knowledge of the actual reviewers on each incorrect fix.
note that these potential optimal fixers are still reachable when th e bugs were opened which suggests that the current bug fixing and reviewing process is not always assigning the problem to the developers who could be most knowledgeable with the bug.
.
.
.
.
.
.
.
k k k k k k file k func different levels of knowledge k of incorrect fixes figure the distribution of incorrect fixes in different knowledge scales.
figure further studies why the k file andk func in incorrect fixes are low by probing deeper into the distribution of incorrect fixes in different knowledge scales.
we found the low k file andk func are caused by a large portion of incorrect fixes that were made by fixers with zero prior knowledge to the buggy files functions.
as shown in figure .
of the fixers had not contributed any lines to the file k file they were about to fix.
it is even worse at the function level.
.
of fixers had not contributed any lines of code to the function they were about to fix.
these first touches could be dangerous since the developer could have little knowledge about the particular part of code when they are the fix.
besides studying the effect of code knowledge in terms of k file andk func we further study the code knowledge in terms of whether the fixer actually fixed the lines of code previously written by him.
the intuition behind this is that even though a fixer had written small amount of code i.e.
small k file k func as long as the fixer was modifying the code regions that he had written he might be still considered as the knowledgeable person for the fix.
specifically for each fix if any code line modified by the fix was alsopreviously written by the same fixer we count this fixer is fixing his own code.
the result is shown in table .
app for incorrect fixes for correct fixes a .
.
b .
.
c .
.
d .
.
avg .
.
table the percentage of fixes that fixer is fixing his own code.
for example the number .
in the first cell means among all the incorrect fixes from os a .
of them were actually fixed by developers who were fixing their own code.
table shows large difference between correct fixes and incorrect fixes.
the ratio of the fixers who fixed their own code for correct fixes is .
times of the ratio for incorrect fixes .
v.s.
.
.
this suggests fewer fixers in term of ratio are fixing their own code for incorrect fixes than for correct fixes which further suggests that fixing code writte n by others might be prone to incorrect fixes.
based on our study in code knowledge a software vendor is building a tool to find knowledgeable fixers and reviewers.
sometimes when the bug report just arrives it may be unclear which files functions contain the bug.
in these cases the knowledge is more useful to assign reviewers who are knowledgeable to the files functions involved in the fix afte r the fix is made.
this knowledge can also be used in prioritizing patch testing efforts to pay more attentions to the patches fixed by less knowledgeable fixers.
finding the fixers knowledge on the buggy files functions in correct fixes is .
times of the fixers knowledge in incorrect fixes.
fewer fixers in term of ratio are fixing their own code for incorrect fixes than for correct fixes.
moreover nearly of the incorrect fixes are made by developers who have not contributed a single line to the entire file they are about to fix.
the potential optimal developer who is most familiar with the buggy code has times knowledge of that of the actual fixer in incorrect fixes.
implication it might be beneficial to assign the bugs to developers with more knowledge during the bug triage process.
the knowledge can also be considered as a factor in prioritizing the testing efforts on patches.
.
related work studying incorrect fixes as briefly discussed in introduction several previous studies had also studi ed incorrect fixes.
our work is complementary in several ways we focus on large os code while previous studies focused on certain types of applications.
we study both commercial and open source code bases while previous work studied only either open source or commericial.
previous studies more focused on measuring incorrect fix ratios while we went much beyond and also studied what types of bug fixes are more error prone the common mistake patterns as well as the possible human reason in the development process for introducing incorrect fixes.
liwerski et al.
proposed an effective way to automatically locate fix inducing changes by linking a version archive to a bug database.
they studied the incorrect fixratio in eclipse and mozilla and also found developers are easier to make incorrect changes on friday.
purushothaman et al.
studied the incorrect fix ratio in a switching system from lucent but their focus was the impact of one line changes.
gu et al.
studied the incorrect fix ratio in three apache projects but they focused on providing a tool to validate the patch.
baker et al.
visualized the incorrect fix ratio for a switch system in at t. human factors the influence of code knowledge on general code changes had been explored in .
mockus et al.
found that changes made by more experienced developers were less likely to induce failures.
rahman et al.
found file owner with higher knowledge is less associated with fix inducing code.
our study focused on bug fixes and measured the knowledge of the fixers who made the incorrect fixes in commercial and widely used open source oses.
we found of the incorrect fixes are made by fixers with zero knowledge suggesting there might be some flaws in the overall bug assignment process.
some work also studied human factors for designing recommendation systems.
anvik et al.
suggested to assign fixer based on bug history.
mcdonald et al.
suggested to find the person who last modified the code.
we proposed to assign fixer reviewer based on code knowledge defined at line level.
besides other aspects of human factors had also been studied.
meneely et al.
found that independent developer groups were more likely to introduce a vulnerability.
bird et al.
found that a binary might be more buggy if more developers are working on it.
nagappan et al.
studied the organizational structure and used it to build model to predict the failure proneness in windows vista.
taming incorrect fixes there are different ways to solve the problem of incorrect fixes including predicting or isola ting buggy changes patch validation automatic patching and regression testing .
l iwerski et al.
built a plug in for eclipse which shows the risk of changing a particular code location based on previous revision information.
kim et al.
also leveraged the historical source repository data to train models for predicting the co rrectness of a future change.
mccamant et al.
compared operational abstractions generated from the old component and the new component to predict the safety of a component upgrade.
zeller et al.
proposed automated delta debugging to locate the bug introducing changes.
clearview automatically generates patches without human intervention which can reduce the chance of incorrect fixes.
besides regression testing is also a common practise to ensu re patches don t break the previously working functionalitie s. our study discovered some incorrect fix patterns which are helpful for detecting exposing avoiding incorrect fixes.
we studied what mistakes programmers should be aware of during bug fixing which are also useful to design new detection tools to detect errors in fixes.
besides we also proposed a bug assignment process based on code knowledge which is being implemented by a large software vendor.
.
conclusion andfuture work this paper presents one of the most comprehensive characteristic studies on incorrect bug fixes from large operat ing system code bases including a commercial os project.
we first studied the ratio and impact of incorrect fixes and found incorrect fix is a significant problem that requires spe cial attention.
we also studied the common patterns of mistakes made in incorrect fixes that can be used to alert the programmers as well as to design detection tools to catch incorrect fixes.
we finally studied the code knowledge of developers and found of incorrect fixes are made by developers who have not contributed a single line to the entire file they are about to fix.
a tool based on our findings to assign the most knowledgeable developer to fix review the bug is being built into the bug assignment process of a large software vendor.
though we had already done some preliminary study on the the fixes to semantics bugs there are still some interesting questions waiting to be answered considering their diversity.
therefore we plan to have a more comprehensive study on the fixes to semantics bugs in the future.
besides we also plan to extend the characteristic study to non os applications such as server applications and client appli cations.
another possible direction we want to proceed is to build some checkers to detect incorrect fixes based on the patterns we learned.
.