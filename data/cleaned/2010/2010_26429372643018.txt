information flows as a permission mechanism feng shen namita vishnubhotla chirag todarka mohit arora babu dhandapani eric john lehner steven y .
ko lukasz ziarek university at buffalo the state university of new y ork ffengshen namitavi chiragto marora babupras ericj stevko lziarekg buffalo.edu abstract this paper proposes flow permissions an extension to the android permission mechanism.
unlike the existing permission mechanism our permission mechanism contains semantic information based on information ows.
flow permissions allow users to examine and grant per app information ows within an application e.g.
a permission for reading the phone number and sending it over the network as well as cross app information ows across multiple applications e.g.
a permission for reading the phone number and sending it to another application already installed on the user s phone .
our goal with flow permissions is to provide visibility into the holistic behavior of the applications installed on a user s phone.
in order to support flow permissions on android we have developed a static analysis engine that detects ows within an android application.
we have also modi ed android s existing permission mechanism and installation procedure to support flow permissions.
we evaluate our prototype with popular applications and malicious applications and show that our design is practical and e ective in deriving flow permissions.
we validate our cross app ow generation and installation procedure on a galaxy nexus smartphone.
categories and subject descriptors d. .
processors compilers c. .
microcomputers portable devices e.g.
laptops personal digital assistants f. .
semantics of programming languages program analysis keywords android permissions information flows .
introduction modern mobile oses such as ios and android provide permission mechanisms allowing users to review how an permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
app accesses the resources on a mobile device.
android in particular has a comprehensive permission mechanism at development time an app writer needs to explicitly request permissions by statically declaring them in an app con guration le androidmanifest.xml .
during installation a user needs to review the permissions that an app requests and explicitly grant them.
currently there are over permissions which android apps can request in api level .
generally an app can ask for permissions to use protected apis for phone resources e.g.
storage nfc wifi etc.
or information available on the phone e.g.
contacts location call logs etc.
.
for example if an app wants to use apis that control the camera it needs to request android.permission.camera.
although considered to be robust the current permission mechanism of android provides little contextual information on how permissions of an app are leveraged by the app.
for example it is unclear if an app with the permission to access the internet as well as the phone s sim card exposes the private telephony data stored on the sim card to the outside world.
apps can also communicate with one another via android s ipc mechanisms to e ectively gain permissions they were not explicitly given thereby bypassing the current permission mechanism .
to address these issues we propose a new permission mechanism called flow permissions that extends the existing android permission mechanism with information ows between permission domains e.g.
reading from the sim card and sending over the network .
our flow permissions identify single app ows i.e.
information ows within an app as well as cross app ows i.e.
information ows across apps via ipc mechanisms.
in order to synthesize single app ows we develop an automated static analysis engine that detects information ows within an android app.
to synthesize cross app ows we modify android to perform crossapp permission analysis when installing a new app.
this cross app permission analysis compares information ows within the new app to those of already installed apps and derives new flow permissions.
this combination of static and installation time analysis comprises blueseal our flow permission synthesis system.
more speci cally this paper makes the following contributions flow permissions we propose a new permission mechanism based on information ows between permission domains within an app as well as across multiple apps.
cross app ow detection is leveraged at installation time to alert the user of possible interactions between apps.
blueseal we develop a holistic system called blueseal for automatically generating flow permissions and building them into android.
the design of blueseal shows a primer on how to modify classic program analyses to statically analyze android speci c constructs.
blueseal statically generates per app flow permissions and at installation time it generates crossapp flow permissions.
we augment android s package installer to perform cross app permission analysis.
we validate the feasibility and e ectiveness of our implementation by showing experimental results on a galaxy nexus smartphone.
case studies detailed performance analysis including a comparison study with state of the art tools validation against known benchmark apps manual introspection as well as a large validation across popular and malicious apps.
this paper is an extended version of our previous page ase new idea paper .
our previous paper introduces flow permissions as a new permission mechanism and shows preliminary results of blueseal.
we extend our previous paper with a more thorough discussion of blueseal an augmented package installer and new case studies and performance results.
.
overview in our previous new idea paper we have discussed the shortcomings of the current permission mechanism of android and proposed our new flow permission mechanism.
this section summarizes our previous paper.
.
limitations of the current mechanism in order to install an app on android a user needs to explicitly grant one or more permissions requested by the app.
for example gmail a popular mail client on android requests many permissions such as internet and storage.
the internet permission once granted allows the app to send and receive packets over the network.
the storage permission allows the app to read from and write to the phone s storage.
there are other kinds of permissions such asphone state which allow sensitive personal data to be read and written e.g.
the phone number and the device id.
this means that if a user grants a permission to read the phone s device id and as well as access to the internet the user is also implicitly granting permission to transmit the device id over the internet to an external entity.
in general once the app has permission to read from a given piece of data stored on the phone i.e.
a data source as well as permission to send data outside of the app i.e.a data sink the app also implicitly has permission to export the source data via the sink.
the problem is that the current permission mechanism o ers no insight to make the connection between di erent permissions.
in addition it is known that multiple apps can gain permissions implicitly without requiring users to explicitly grant them .
this is possible since android s ipc mechanisms do not necessarily check app permissions.
for example suppose that app 1has permission to access the network and app 2has permission to read the device id.
in android app 1can expose its network access capability through an ipc mechanism allowing app 2to leverage app 1to send the device id over the network without explicitly requesting the network permission.
.
flows as permissions the goal of the flow permission mechanism is to show whether or not an app contains a ow between a source and a sink.
the general structure of a flow permission is of source!sink.
for example if an app has a data ow between the phone state source and the internet sink then the corresponding flow permission is phone state!
internet.
this means that the app can potentially read the phone state e.g.
the phone number and subsequently exports through the use of the network.
in this manner flow permissions provide the user additional context on how the standard android permissions and the resources data they protect are leveraged by the apps.
nevertheless it is up to the user to decide if these behaviors should be allowed or not.
the existence of a ow does not indicate that the app is necessarily malicious.
for example a social networking app might be expected to contain a ow from the device id to the network as this provides the app a mechanism to uniquely identify the device for analytics.
regardless some users may not be comfortable providing such information to the app developer as other mechanisms e.g.
manual login can be used without exposing such data.
.
flow permission mechanism flow permissions are an extension to the android permission mechanism that characterizes the implicit interactions between data and apis protected by standard permissions.
as described in the rest of the paper we derive ne grained information ows using static analysis.
we also derive crossapp ows by combining per app ows across di erent apps.
this is done by matching one app s sinks to another app s sources.
we display these ows to users at installation time so that users can examine the ows present in an app.
since it is possible that an app has many ows we categorize sources and sinks into domains to reduce the number of ows that need to be shown to the users.
we currently have thirteen source domains sms storage history bookmarks use dictionary fine location coarse location calendar accounts phone state contacts call log voicemail and log.
similarly we use ve sink domains network log mms storage and intent.
our previous paper describes how we determine these domains .
.
blueseal design our system blueseal depicted in fig.
is comprised of two main components the static analysis engine which performs per app analysis o ine and the cross app analysis engine which performs cross app analysis at installation time on the phone itself.
our static analysis engine is built on top of the soot java optimization framework .
since soot was originally developed for analyzing java bytecode it was extended recently to transform dex bytecode into soot s own intermediate representation jimple using dexpler .
we extend soot to leverage the pscout permission map abstractly a permission map is a mapping between android api calls and the permissions required to enact those calls.
the pscout permission map was gener516soot based per app analysisandroidapkdex bytecodemanifestfilelayoutfileapispecpscoutmappingflow permissions and meta datanew manifest filerepackagedapkphone based cross app analysisblue sealinstallerfigure the blueseal android app analysis framework architecture.
ated by statically analyzing the entire android source code and to our knowledge is the most complete among known permission maps.
our compiler leverages this precomputed mapping internally within the analyses to associate speci c permission to api calls.
at its core blueseal leverages classic forward and backward intraprocedural data ow analysis as well as interprocedural data ow analysis based on graph reachability.
blueseal leverages six main analysis passes to generate flow permissions entry point discovery call graph restructuring unused permission analysis resolution of intents content providers as well as uses of the binder and interprocedural permission ow analysis.
we augment android s package installer to perform the 6th pass crossapp permission ow analysis as described in section .
.
abstractly blueseal uses analyses and to disambiguate android speci c constructs and to identify source and sink points prior to tracking ows between sources and sinks in analysis .
blueseal implements stowaway s unused permission analysis to remove unnecessary permissions.
since blueseal is built from classic analysis techniques we tailor our discussion on how to support android speci c linguistic constructs libraries and ipc mechanisms in standard analyses.
currently blueseal is not path or context sensitive and is subject to the precision of the analyses from which it is constructed.
since our previous new idea paper mainly discusses analysis steps and i.e.
entry point and interprocedural permission ow analyses we omit the details here.
brie y our entry point discovery deals with the event driven nature of android programming we discover ui callbacks e.g.
a button click callback we detect standard framework components of android such as activity service broadcastreceiver and contentprovider that essentially replace traditional main .
we have also crawled the online api documentation of android and discovered callback methods that can serve as entry points for api .
our interprocedural ow analysis uses a xed point algorithm leveraging the standard work list model and method summaries.
the method summary constructed during this analysis is a ow graph representing the ows between sources and sinks within the method itself as well as arguments returns and class variables the method reads or writes.
once public class mainactivity extends activity protected void oncreate bundle savedinstancestate ... new task .execute ... ... private class task extends asynctask string string integer ... protected void onpreexecute ... protected integer strs ... publishprogress intermediate result ... return intobj protected void onprogressupdate string...strings ... protected void onpostexecute integer intobj ... figure a code snippet illustrating the methods that comprise the control ow of an asynctask in android and the implicit ow of arguments provided by the android framework.
mainactivity.oncreate ...task.execute ... ...task.onpreexecute ...task.
val task.onprogressupdate ...task.onpostexecute ...ui threadimplicit thread figure the execution ow of asynctask methods in their respective threads at runtime.
method summary construction reaches a x point we synthesize a global ow graph from the per method summaries giving us all potential ows across methods.
per app flow permissions can be generated from the graph by enumerating all paths and removing duplicates e.g.
an app may send contact data over the network in multiple code blocks .
.
call graph restructuring the android framework is responsible for invoking methods associated with many of the constructs it provides.
to correctly analyze an app we must infer the association of user called methods to their corresponding framework invoked methods.
we dicuss this in detail below.
.
.
asynctask asynctask is a new threading class introduced in android.
it provides a simple way to write a short lived thread that communicates with the ui thread in an asynchronous fashion.
an asynctask can implement ve methods onpreexecute onprogressupdate onpostexecute and oncanceled which dictate the control ow of the asynchronous task.
as an example consider the code snippet in fig.
and the corresponding control ow given in fig.
.
the method performs the actual compu517public class handleractivity extends activity ... private handler mhandler new handler public void handlemessage message msg ... bundle data msg.getdata ... public void onclick view v new thread new runnable public void run try ... msg.setdata data mhandler.sendmessage msg ... catch interruptedexception e ... .start figure flows based on pairing message sends to the appropriate message handlers.
tation for the asynctask.
the methods onpreexecute and onpostexecute run before and after and typically include pre and post processing.
the oncanceled method is called when the asynctask is canceled by another thread.
notice that onpreexecute will execute in the implicitly created thread backing the asynctask but the onpostexecute callback will be executed by the ui thread.
similarly onprogressupdate gets executed as a callback in the ui thread after there is a call to publishprogress within an app writer can call asynctask s execute and executeonexecutor to start an asynctask.
obviously a typical call graph generation process does not understand this execution ow hence we identify all asynctask instances and augment the call graph to include edges corresponding to the asynctask control ow.
we do this by effectively replacing the invoke of execute with invoke calls to onpreexecute and onpostexecute.
similarly a call to publishprogress is replaced with a onprogressupdate call.
notice that implicitly passes its return value as an argument to onpostexecute.
publishprogress also passes its arguments as arguments to onprogressupdate.
the call graph and method bodies are updated accordingly.
.
.
handler android also provides a message mechanism for communicating between threads within an app called handler depicted in fig.
.
threads can communicate through a shared handler object.
receiving threads implement the handlemessage method to process received messages and sending threads communicate through the sendmessage family1of methods.
similar to asynctask blueseal effectively replaces a call to sendmessage with a call to handlemessage to restructure the call graph.
.
content provider resolution analysis after restructuring the call graph blueseal performs additional analyses to identify permission sinks and sources.
1by method family we mean any methods of similar form de ned by the same class e.g.
setdata and setdataandtype belong to the method family setdata .
public class contentproviderexampleactivity extends activity ... public void onbuttonclick view v uri uri contactscontract.contacts.content lookup uri ... processquery uri ... ... ... public void processquery uri uri ... ... results getcontentresolver .query uri ... ... ... pscoutpermission mapcp identityfigure the data ow of an uri object that identies which content provider is being utilized.
dashed arrows indicate information derived from data ow analyses and block arrows how that information is used to disambiguate the content provider.
public class uriexampleactivity extends activity private final uri muri ... protected void oncreate bundle savedinstancestate ... muri builduri content edu.buffalo.cse.provider ... ... private uri builduri string scheme string authority ... uri.builder uribuilder new uri.builder uribuilder.scheme scheme uribuilder.authority authority return uribuilder.build ... figure the data ow of an uri object initialization that is resolvable statically.
one mechanism for interaction between apps is contentprovider.
an app can provide content to itself or other apps can consume content hosted by a content provider or both.
content providers are uniquely identi ed by a uri object and to correctly pair uses of content providers these objects must be tracked and disambiguated to the extent possible by static analysis.
to identify uses of content providers we track the content provider api calls as well as the uri objects as shown in fig.
.
our content provider resolution analysis cpra is based on an interprocedural data ow analysis that leverages a backward intraprocedural data ow analysis.
abstractly we track backward ows from uses of the content provider mechanism to the de nitions of uri objects and from the de nitions of uri objects to the strings that uniquely identify them.
content providers are accessed through two separate classes in android contentresolver andcontentproviderclient.
within these classes the methods from which we begin tracking ows are insert query and update.
each of these methods takes an uri object as an argument.
our analysis identi es the creation points of the uri objects passed into these methods.
uri objects can be created in one of two ways they can be provided by the android libraries or they can be constructed by the app itself.
in the former the 518public class binderactivity extends activity private binderexamplebinder mbinder ... private serviceconnection mconnection new serviceconnection public void onserviceconnected ... ibinder service mbinder binderexamplebinder service ... protected void onstart ... bindservice ... mconnection ... ... public void onclick view v ... mbinder.printstr test string ... public class binderservice extends service private ibinder mbinder new binderexamplebinder public ibinder onbind intent intent return mbinder public class binderexamplebinder extends binder public void printstr string str ... figure data and control ow relations between a binder activity and service.
identifying uri string is hidden.
for precision our analysis leverages pscout which provides a mapping between framework provided uri objects and their uri strings as shown in fig.
.
for app created uri objects we attempt to discover this information in the compiler.
once the app created uri object is identi ed the analysis tracks the construction of this object.
there are two ways to construct an uri object.
one is to use uri.parse and the other is to useuri.builder.
the rst case is simple as the argument to the parse method is the uri string.
if uri.builder is used then uri.builder.scheme is used to set the scheme and uri.builder.authority is used to set the authority.
for example content edu.buffalo.cse.provider is a valid content provider identi er where content is the scheme and edu.buffalo.cse.provider is the authority.
after the scheme and the authority are set the actual uri object is returned by uri.builder.build.
thus our analysis tracks calls to scheme andauthority and the arguments passed to them as shown in fig.
.
.
binder resolution analysis binder ibinder commonly referred to as just binder is the default ipc mechanism on android.
it can be used for inter component communication within the same app e.g.
activity to service communication as well as inter process communication between di erent apps.
android provides multiple ways to use the binder mechanism such as simply extending the base binder class or using aidl android interface de nition language to de ne a customized interface.
regardless of which method is used a binder server i.e.
an ipc callee implements all the ipc methods in the binder class.
a binder client i.e.
an ipc caller uses an ibinder object which is the proxy for the server side binder.
fig.
shows an example.
although binder calls are mostly identical to local calls there are two cases to handle for correctness of our analysis.
first for inter component communication we need to match each call with an ibinder object to the corresponding binder implementation.
second for inter process communication each client side ibinder call is a potential sink which might result in a server side binder call which then becomes a potential source.
a variation of binder ismessenger which allows a process to send a message to another process.
it relies onbinder ibinder to implement its functionalities underneath but is simpler to use from the programmer s point of view.
in order to receive a message a server needs to create a messenger object it also needs to implement a handler as described in section .
.
and pass it to the messenger object.
in order to send a message a client can use messenger s send method.
we handle these implicit calls by matching calls to send with handler s handlemessage.
if matches cannot be enumerated we treat them as a potential sink for send or a source for handlemessage .
.
intent resolution analysis intents are message objects that can be used to send data between components within a single app as well as across di erent apps.
an app can receive intents in two ways either statically or dynamically.
static intents are declared in the app s manifest le on a per component basis.
an app can also register itself to receive intents dynamically at run time without declaring it in its manifest le.
blueseal performs intent resolution analysis ira in much the same way as cpra.
namely it identi es possible sources and sinks related to the intents by examining relevant api calls such as put extra setdata get send broadcast startactivity etc.
that are capable of reading from writing to sending and receiving intents.
in general handling intents more precisely is a much broader problem and octeau et al.
provide a mechanism for improved precision.
we are currently exploring how to integrate their techniques into blueseal.
.
repackaging the application once the flow permissions are derived for an app blueseal appends these permissions to the list of permissions that the app requests.
it does this by rst extracting the manifest le androidmanifest.xml of the app and modifying it.
it then repackages the application le apk for distribution.
finally it uses newly added flow permissions for display at installation time as well as for cross app analysis done on a phone described next.
.
augmented package installer in order to display flow permissions and perform crossapp analysis we have augmented android s package installer in three ways.
first we have added all our flow permissions 519figure flow permission example screenshot to the source manifest le the framework s androidmanifest.xml that the package installer accesses during installation.
this is the global list of all permissions available in the system.
second we display our flow permissions by modifying the package installer.
fig.
shows an example of how we display flow permissions to users.
lastly we implement cross app analysis in the package installer in its packageinstalleractivity.
in our implementation we synthesize cross app permissions by performing all to all matching between all existing ows from alreadyinstalled apps and ows from the app being installed.
for example while installing app ifapp already installed has a ow from the device id to a le and app 2has a ow from the same le to a socket a new cross app flow permission phone state!network is created and displayed.
a similar matching is done between the derived sources and sinks of already installed apps.
for this analysis our new package installer stores all permissions from all already installed apps in its storage.
our performance results in section demonstrate that our all to all comparison is still practical and feasible to run on a smartphone.
.
results and discussion to validate our approach we tested blueseal on of the top rated free apps available on the google play store with apps from january apps from january and on known malicious apps from the malgenome project2 .
we ran blueseal on amazon ec2 using an ecus and vcpus node instance with 15gb of ram.
in the set of apps there are apps not analyzed because the soot framework which blueseal relies on threw exceptions when performing intermediate representation transformation.
blueseal thus was able to analyze apps.
our full data set and results can be found at the main purpose of our evaluation is to assess the analysis capability and usefulness of blueseal.
we do this in four ways.
first we present aggregated as well as categorized statistics regarding information ows and flow permissions.
second we present the analysis performance of blueseal.
overview count total apps total number of raw ows detected avg number of raw ows per app .
distinct ows total number of flow permissions avg number of flow permissions per app .
distinct flow permissions table a brief overview of experiment results of flow permissions0100200300400500600 frequency figure distribution of flow permissions generated for each app.
apps do not generate any flow permission and are not shown.
third we discuss the limitations of blueseal with manual validation.
fourth we show the usefulness of blueseal with a user survey.
.
statistics of flow permissions table shows the overview of our results.
although we detect many information ows in an app the number of flow permissions is signi cantly smaller due to our domain categorization described in section .
fig.
shows the distribution of flow permissions generated by blueseal.
most of the apps contain less than flow permissions an amount practical for a user to examine.
the app with the maximum number of flow permissions contains a heavy usage of di erent content providers currently distinguished based on their uris.
we plan on categorizing content providers in much the same way as permission domains.
the app that contains the maximum number of raw ows ows as shown in figure generates twenty flow permissions.
table shows the ten most common ows observed from normal apps and table shows the ten most common ows observed in malicious apps.
from these two tables we make four observations.
first normal apps are more concerned about users input data since most normal apps require a user s login information and many provide social communication functionality that requires a lot of user input.
on the other hand malicious apps are heavily interested in the phone s unique identi er deviceid.
second both normal and malicious apps read system content providers often.
the most commonly accessed content provider in both normal and malicious apps is the contacts.
third normal apps access the phones location data more frequently than of flows050100150200250300350 frequencyfigure distribution of raw ows generated for each app.
apps range from to and apps with ow are omitted.
count raw flow edittext gettext!
intent putextra contentresolver query!
intent putextra edittext gettext!
log e location getlatitude !intent putextra location getlongitude!
intent putextra edittext gettext!
log d contentresolver query!
log e location getlongitude !dataoutputstream writeshort location getlatitude !dataoutputstream writeshort edittext gettext!
printstream println table ten most common ows in normal apps.
malicious apps.
fourth most of the ows in normal apps indicate that data is often used inside the app while in malicious apps data mainly ows to the network and storage.
this observation suggests that normal apps leverage the sensitive data for debugging purposes while malicious apps may store or send the data.
last the two location ows in table show that location is often sent within intents this is in fact a common design pattern that many developers use.
an app gets a location update wraps it in an intent and sends the intent to itself to display the update.
blueseal currently does not distinguish whether or not an app sends intents to itself it just detects that there is a ow to an intent that gets sent out.
to improve blueseal s precision we can leverage existing techniques such as the ones implemented in epicc .
in tables and we collect top ten sources used by normal and malicious apps respectively.
as shown in these two tables there are three main categories of sources frequently accessed by both normal and malicious apps system content providers phone identi er and location.
speci cally normal apps use the users location data while malicious apps read the phone identi er and data stored in system content provider which is often private e.g.
contacts .
table and table show the top ten sinks present in normal and malicious apps respectively.
we observe that there are mainly three categories of sinks in normal apps log storage and intent.
in malicious apps the top sinks are log intent storage and network.
logging which is usedcount raw flow telephonymanager getdeviceid!
log d telephonymanager getsubscriberid!
log d telephonymanager getdeviceid!
log e telephonymanager getdeviceid !httpclient execute telephonymanager getdeviceid !bytearrayoutputstream write contentresolver query!
log i contentresolver query!
log d telephonymanager getsubscriberid!
log e telephonymanager getdeviceid!
intent putextra contentresolver query!
fileoutputstream write table ten most common ows in malicious apps.
count source type edittext gettext contentresolver query location getlatitude location getlongitude locationmanager getlastknownlocation telephonymanager getdeviceid fileinputstream read accountmanager getaccountsbytype autocompletetextview gettext telephonymanager getline1number table top sources in normal apps.
for debugging purposes is the most frequently used sink in both normal and malicious apps.
.
uses of the statistics using these statistics we can make observations about the di erence between malicious apps and normal apps in terms of information ows.
for this purpose we have classi ed malicious apps into di erent categories according to their malware type e.g.
anserverbot beanbot droidkungfu3 droidkungfu4 golddream etc.
we then examined what common or distinct ows exist across the categories.
a visualization of this data can be found for all categories at with this ow analysis we have discovered that there are a few ows that highlight the di erence between malicious apps and normal apps.
table shows the number of apps in malicious and normal categories.
it summarizes the ow analysis result for one speci c ow the ow from telephonymanager getline1number to network outputstream write.
this ow is used to ex ltrate the user s phone number using java s socket io.
we observe that this ow is only used in out of the normal apps which have more than one ow.
this ow exists with a much greater frequency in the droidkungfu3 and droidkungfu4 categories.
further we have found out that out of the normal apps with this ow have been removed from the play store since we originally downloaded them these apps are com.superqiang.
sexygirlwallpaper.apk com.superqiang.sexygirlwallpaper3.apk and muli.touch.sex10009.apk.
these individual ows can also be grouped to make a more speci c match.
table shows the number of apps in each malicious category and among all normal apps for the ow pair from telephonymanager getline1number to network outputstream write and the ow from telephonymanager getdeviceid tohttpclient execute.
the former ow is the same ow that we used in table .
the 521count source type telephonymanager getdeviceid telephonymanager getsubscriberid contentresolver query location getlatitude location getlongitude locationmanager getlastknownlocation telephonymanager getline1number fileinputstream read edittext gettext telephonymanager getcelllocation table top sources in malicious apps.
count sink type intent putextra log e log d dataoutputstream writeshort dataoutputstream writeutf printstream println outputstream write dataoutputstream write log i log w table top sinks in normal apps.
latter ow sends the device id over to the network with an http api.
by ow pair we mean two ows that are held within the same app.
in this case each app counted contains a ow that is capable of sending the phone number o the phone using the java socket io methodology and is capable of sending the phone s device id over the network using android s httpclient.
we observe that this ow pair is found in out of normal apps which have any ow.
three of these apps were the same three that had been removed from the play store since our initial download.
of the remaining three one is the free version of a popular guitar simulator app.
the other two apps com.applock1 and com.mm.security.androidhider1 require root access and avg threat labs indicate that they are malware.
in the droidkungfu4 category the ow pair was found with the greatest frequency.
more ows in increasingly larger groups can be used to narrow down the likelihood of an app being malicious and possibly what malicious category the app would pertain to.
certain ows can be even more telling of malicious activity.
in many of the categories ows with a source of smsmanager sendtextmessage were found to be malicious which can be seen in table .
one app in our normal group that used this as a source stood out as well com.bluecode.
photo.space.effects.fx.apk.
this app is stated to add space e ects to one s photos and this ow may be construed as a way to send photos to friends via text messages.
this assumption would be false though as photos need to be sent via mms using a built in mms app s api.
while we wanted to test this app further it has since been removed from the play store with avg s threat labs reporting that this app contained adware.
.
performance blueseal is able to analyze and synthesize per app flow permissions for all but the largest apps in under ten minutes.
only apps require an analysis time greater thancount sink type log d log e log i intent putextra httpclient execute contentresolver insert bytearrayoutputstream write outputstream write log v fileoutputstream write table top sinks in malicious apps.
category distinct count total count anserverbot beanbot droidkungfu3 droidkungfu4 golddream normal table distinct malicious and normal apps using a ow telephonymanager getline1number to network outputstream write ten minutes all of these apps nish under minutes .
fig.
shows the full performance results.
however soot s front end dex bytecode parser dexpler has limitations and generates incorrect intermediate representations for of the apps.
these apps are all from the google play store.
we are currently investigating the causes of the mis translation of the remaining apps.
to measure the performance of our cross app analysis we have tested the installation performance of blueseal s augmented package installer with random apps.
in our experiment we have installed each app on a galaxy nexus phone one app at a time without uninstalling previouslyinstalled apps.
we have measured the cross app analysis time as well as the total time until the installer displays the installation screen.
as fig.
shows it takes less than .
seconds for all the apps to analyze cross app permissions and display the installation screen.
synthesizing cross app ows does not exceed .
seconds for any of the app installs.
.
manual validation false positives and false negatives are well known limitations of static analysis which also apply to blueseal.
thus we manually validate blueseal in three ways to understand its limitations.
first we have compared against taintdroid a custom android os that performs a dynamic taint analysis for identifying malicious ows.
we have manually compared blueseal s generated flow permissions to taintdroid s dynamically discovered taints on thirty apps.
each app was manually executed for minutes and fed random key presses.
unsurprisingly the most common taints reported by taintdroid mirrored our own ndings and that of prior work.
we have not discovered any taints reported by taintdroid for which blueseal does not generate a corresponding flow permission.
second we have randomly chosen and inspected apps that have exactly one blueseal reported ow.
we have examined each app s intermediate representation of the source 522category distinct count total count anserverbot beanbot golddream normal droidkungfu4 droidkungfu3 table distinct malicious and normal apps using a ow pair compared to distinct apps within a category category distinct count total app count bgserv coinpirate dogwars droidkungfu3 endofday geinimi gamblersms gpssmsspy nickybot normal smsreplicator walkinwat table distinct malicious and normal apps using the smsmanager sendtextmessage sink and veri ed that blueseal detects actual ows in all apps.
lastly we have vetted blueseal against droidbench an android benchmark suite with apps provided by flowdroid .
blueseal can detect all the ows in droidbench except implicit ows since blueseal currently does not handle implicit ows.
in addition there are several apps for which blueseal reports false positives.
this occurs for one of three reasons ows in dead code lack of context sensitivity and ows in complex data structures.
blueseal reports ows in dead code since it does not perform any dead code analysis.
blueseal simply relies on soot to determine code reachability.
also blueseal is not currently context sensitive for example if there is a ow from a source to a class variable and another ow from the same class variable to a sink blueseal reports that there is a ow regardless of the relationship of the call sites in which those ows occur.
lastly if an app has a ow from a source to a complex java data structure such as hashmap and a ow from the same data structure to a sink blueseal reports that there is a ow.
as a result blueseal reports one ow in apps in droidbench that do not have any ow.
.
user study to test the utility of flow permissions we created a user survey and tested graduate and undergraduate students taking computer science courses.
these students are mixed majors cs and non cs .
our survey results were obtained anonymously with participants.
the survey procedure is as follows.
the survey presented a description of an anonymized app and its requested permissions.
students then responded how likely they were to install the app.
the same question was asked including our flow permissions synthesized for the app.
at the end of the survey the anonymized app was revealed and the students were once appid020040060080010001200140016001800anaylsis time second performancefigure scatter plot showing the time taken to analyze all apps in seconds.
of apps0.
.
.
.
.
.
time taken seconds cross app analysis time display time figure performance of our cross app analysis.
again asked how likely they were to install the app.
we repeated the survey for two apps twitter and dropbox.
table presents the results of our survey.
the percentages shown in the table show the likelihood of installation of the app.
the rst column presents results of the anonymized app with standard android permissions.
the second column shows results for our flow permission mechanisms for the anonymized app.
the last column shows how the answers change once the app name is revealed.
our results indicate that flow permissions can signi cantly impact user s decisions to install an app when the users are unbiased i.e.
when users do not have any preconceived notions about the app or the developer of the app.
flow permissions have a minor impact on biased users.
although these results are preliminary they do give a positive indication that flow permissions can be useful in a realworld setting especially when users are not familiar with an app or its developer.
.
threats to validity and discussion we have used independent sources to obtain our testing apps which helps us to validate blueseal without much selection bias.
the rst source is malgenome project that 523app name android flow permissions android anonymized anonymized named twitter dropbox table user survey result showing how likely the user is to install the app.
provides malicious apps.
the second source is the google play store where we downloaded free apps.
these apps include top rated apps from all categories and randomly selected apps.
selection bias can potentially come from malgenome project s choice of apps as well as google s categorization of apps.
in addition both cs and non cs majors are represented in our user study which also reduces the chance of selection bias.
.
related work the growing popularity of android has resulted in many tools case studies and analysis engines.
chex provides a tool for detecting highjack enabling ows within an app.
it is the rst tool to tackle analysis of android s constructs such as asynctask and handler though it uses a brute force permutation approach for matching call sites to destinations.
our call graph restructuring described in section .
can re ne chex s approach since we identify implicit calls in android s constructs whenever possible.
xiao et al.
propose a privacy aware accesss control approach based on information ows.
they employs the user driven access control mechanism that allows users to choose among realinformation anonymized information or abort execution to protect users privacy.
epicc is another tool for statically analyzing android apps.
their focus is precise analysis for intents to detect inter component communication.
they reduce the problem to an instance of the interprocedural distributive environment ide problem with less false positive rates.
androidleaks is a static analysis tool implemented in wala that can nd leaks of sensitive information sent over the network from android apps.
it does not support analysis of asynctask intent nor contentprovider and is unable to track cross app ows.
scandroid rst proposed a methodology for analyzing intents statically but was never tested on real world apps.
the approach also required the original java source of the programs.
mann et al.
created a framework to identify privacy leaks from the android apis but the framework has not been evaluated on real world applications.
droidchecker is a static analysis tool aimed at discovering privilege escalation attacks and thus only analyzes exported interfaces and apis that are classi ed as dangerous.
scandal is an abstract interpretation framework for tracking information ows within apps.
currently their framework is able to track ows between location information phone identi ers camera and microphone exported to the network and sms.
flowdroid is an extendable data ow detection system for android.
our analysis techniques are complementary to flowdroid as our techniques are designed to handle android constructs speci cally.
dendroid is a tool used to automatically classify malware based on code structures.
apppro ler developed a knowledge base with which to expand upon what applications are using the permissions for which they call behaviors.
they present informaiton on an applications behvaior to the user and re ceived anonymous feedback on whether the behaviors were objectionable or not.
a methodology for empirical analysis was developed by this paper using self organizing maps to visualize the android permission mechanism.
besides static analysis tools there is a plethora of tools that perform dynamic analyses.
alazab et al.
provide a dynamic analysis technique that runs apps in a sandbox and can detect malicious apps.
mockdroid is a tool that protects users privacy by supplying mock data instead of sensitive data.
aurasium provides user level sandboxing and policy enforcement to dynamically monitor an app for security and privacy violations.
crowdroid is an ofine analysis over traces that can be leveraged to identify malicious apps through examining their behavior via crowdsourcing.
moonsamy et al.
provided a thorough investigation and classi cation of apps using static and dynamic techniques over the apps java source code.
grace et al.
showed that ad frameworks opportunistically scan and leverage permissions granted by the app they are called from.
addroid introduced a new advertisement framework with privilege separation accomplished through a new set of advertising apis and permissions.
we believe our tool can be extended to analyze their framework through extensions to the permission map blueseal takes as parameter.
pios a static analysis tool for ios leverages reachability analysis on controlow graphs to detect leaks.
appintent instruments applications to provide gui noti cations indicating the events that lead to data leakage.
vetdroid a dynamic analysis platform designed to reconstruct permission use behaviors of android applications speci cally for malware analysis.
although android has a comprehensive permission mechanism it has limitations.
most users do not understand what each permission means and blindly grant them .
these studies have shown that the android permission mechanism is not e ective as a protection mechanism and suggest allowing users to grant permissions individually blocking and sanitizing sensitive data designing an app veri cation mechanism and analyzing apps to report over privilege .
fragkaki et al propose an extension to the android permission mechanism for disallowing of ows of the form disallow flow a b and shows how interesting policies can be built on top of such a mechanism.
we believe our synthesized flow permissions could be leveraged to conservatively check the adherence of an app to such policies statically.
previous case studies have reported that comprehension of permissions is reduced primarily due to the presentation of the permissions and not the mechanism itself.
we believe our flow permissions can bene t from new presentation styles as they are developed.
.
conclusions in this paper we have presented a ow based extension to the android permission mechanisms called flow permissions.
we have detailed a comprehensive primer on android speci c mechanisms and libraries in our description of blueseal an automated infrastructure for synthesizing flow permissions.
we have provided a comprehensive evaluation of flow permissions in a wide variety of android apps both for single app static analysis as well as cross app analysis.
our evaluation shows that blueseal is practical to deploy and flow permissions provide visibility into the holistic behavior of mobile apps.
524references amazon ec2.
avg threat labs.
app pkg com.bluecode.photo.space.effects.apk .
moutaz alazab veelasha monsamy lynn batten patrik lantz and ronghua tian.
analysis of malicious and benign android applications.
in proceedings of the 32nd international conference on distributed computing systems workshops icdcsw pages washington dc usa .
ieee computer society.
steven arzt siedfried rasthofer christian fritz eric bodden alexandre bartel jacques klein yves le traon damien octeau and patrick mcdaniel.
flowdroid precise context ow eld object sensitive and lifecycle aware taint analysis for android appstion in tcb source code.
in pldi edinburgh uk .
kathy wain yee au yi fan zhou zhen huang and david lie.
pscout analyzing the android permission speci cation.
inproceedings of the acm conference on computer and communications security ccs .
david barrera h. g une s kayacik paul c. van oorschot and anil somayaji.
a methodology for empirical analysis of permission based security models and its application to android.
in proceedings of the 17th acm conference on computer and communications security ccs pages new york ny usa .
acm.
alexandre bartel jacques klein yves le traon and martin monperrus.
dexpler converting android dalvik bytecode to jimple for static analysis with soot.
in proceedings of the acm sigplan international workshop on state of the art in java program analysis soap pages new york ny usa .
acm.
alastair r. beresford andrew rice nicholas skehin and ripduman sohan.
mockdroid trading privacy for application functionality on smartphones.
in proceedings of the 12th workshop on mobile computing systems and applications hotmobile pages new york ny usa .
acm.
iker burguera urko zurutuza and simin nadjm tehrani.
crowdroid behavior based malware detection system for android.
in proceedings of the 1st acm workshop on security and privacy in smartphones and mobile devices spsm pages new york ny usa .
acm.
patrick p.f.
chan lucas c.k.
hui and s. m. yiu.
droidchecker analyzing android applications for capability leak.
in proceedings of the fth acm conference on security and privacy in wireless and mobile networks wisec pages new york ny usa .
acm.
manuel egele christopher kruegel engin kirda and giovanni vigna.
pios detecting privacy leaks in ios applications.
in ndss.
the internet society .
serge egelman adrienne p. felt and david wagner.
choice architecture and smartphone privacy there s a price for that.
in proceedings of the 11th annual workshop on the economics of information security weis .
william enck peter gilbert byung gon chun landon p. cox jaeyeon jung patrick mcdaniel and anmol n. sheth.
taintdroid an informationow tracking system for realtime privacy monitoring on smartphones.
inproceedings of the 9th usenix conference on operating systems design and implementation osdi pages berkeley ca usa .
usenix association.
william enck machigar ongtang and patrick mcdaniel.
on lightweight mobile phone application certi cation.
in proceedings of the 16th acm conference on computer and communications security ccs .
adrienne porter felt erika chin steve hanna dawn song and david wagner.
android permissions demysti ed.
inproceedings of the 18th acm conference on computer and communications security ccs .
adrienne porter felt kate greenwood and david wagner.
the e ectiveness of application permissions.
in proceedings of the 2nd usenix conference on web application development webapps pages berkeley ca usa .
usenix association.
adrienne porter felt elizabeth ha serge egelman ariel haney erika chin and david wagner.
android permissions user attention comprehension and behavior.
in proceedings of the 8th symposium on usable privacy and security soups .
adrienne porter felt helen j. wang alexander moshchuk steven hanna and erika chin.
permission re delegation attacks and defenses.
in proceedings of the 20th usenix conference on security sec .
elli fragkaki lujo bauer limin jia and david swasey.
modeling and enhancing androids permission system.
in sara foresti moti yung and fabio martinelli editors computer security esorics volume of lecture notes in computer science pages .
springer berlin heidelberg .
adam p. fuchs avik chaudhuri and je rey s. foster.
scandroid automated security certi cation of android applications.
michael c. grace wu zhou xuxian jiang and ahmad reza sadeghi.
unsafe exposure analysis of mobile in app advertisements.
in proceedings of the fth acm conference on security and privacy in wireless and mobile networks wisec pages new york ny usa .
acm.
shashank holavanalli don manuel vishwas nanjundaswamy brian rosenberg feng shen steven y. ko and lukasz ziarek.
flow permissions for android.
in proceedings of the 28th ieee acm international conference on automated software engineering ase .
peter hornyack seungyeop han jaeyeon jung stuart schechter and david wetherall.
these aren t the droids you re looking for retro tting android to protect data from imperious applications.
in proceedings of the 18th acm conference on computer and communications security ccs .
jinyung kim yongho yoon kwangkeun yi and junbum shin.
scandal static analyzer for detecting privacy leaks in android applications.
in hao chen larry koved and dan s. wallach editors most mobile security technologies los alamitos ca usa may .
ieee.
long lu zhichun li zhenyu wu wenke lee and guofei jiang.
chex statically vetting android apps for component hijacking vulnerabilities.
in proceedings of the acm conference on computer and communications security ccs .
christopher mann and artem starostin.
a framework for static detection of privacy leaks in android applications.
in proceedings of the 27th annual acm symposium on applied computing sac pages new york ny usa .
acm.
veelasha moonsamy moutaz alazab and lynn batten.
towards an understanding of the impact of advertising on data leaks.
int.
j. secur.
netw.
march .
mohammad nauman sohail khan and xinwen zhang.
apex extending android permission model and enforcement with user de ned runtime constraints.
in proceedings of the 5th acm symposium on information computer and communications security asiaccs .
damien octeau patrick mcdaniel somesh jha alexandre bartel eric bodden jacques klein and yves le traon.
e ective inter component communication mapping in android an essential step towards holistic security analysis.
in proceedings of the 22nd usenix security symposium usenix security .
paul pearce adrienne porter felt gabriel nunez and david wagner.
addroid privilege separation for applications and advertisers in android.
in proceedings of the 7th acm symposium on information computer and communications security asiaccs pages new york ny usa .
acm.
sanae rosen zhiyun qian and z. morely mao.
apppro ler a exible method of exposing privacy related behavior in android applications to end users.
in proceedings of the third acm conference on data and application security and privacy codaspy pages new york ny usa .
acm.
guillermo suarez tangil juan e. tapiador pedro peris lopez and jorge blasco.
dendroid a text mining approach to analyzing and classifying code structures in android malware families.
expert systems with applications part .
raja vall ee rai phong co etienne gagnon laurie hendren patrick lam and vijay sundaresan.
soot a java bytecode optimization framework.
in proceedings of the1999 conference of the centre for advanced studies on collaborative research cascon pages .
ibm press .
raja vall ee rai etienne gagnon laurie j. hendren patrick lam patrice pominville and vijay sundaresan.
optimizing java bytecode using the soot framework is it feasible?
in proceedings of the 9th international conference on compiler construction cc pages london uk uk .
springer verlag.
michael s. ware and christopher j. fox.
securing java code heuristics and an evaluation of static analysis tools.
inproceedings of the workshop on static analysis saw pages new york ny usa .
acm.
xusheng xiao nikolai tillmann manuel fahndrich jonathan de halleux and michal moskal.
user aware privacy control via extended static informationow analysis.
in proceedings of the 27th ieee acm international conference on automated software engineering ase pages new york ny usa .
acm.
rubin xu hassen sa di and ross anderson.
aurasium practical policy enforcement for android applications.
in proceedings of the 21st usenix conference on security symposium security .
zhemin yang min yang yuan zhang guofei gu peng ning and x. sean wang.
appintent analyzing sensitive data transmission in android for privacy leakage detection.
inproceedings of the acm sigsac conference on computer communications security ccs pages new york ny usa .
acm.
yuan zhang min yang bingquan xu zhemin yang guofei gu peng ning x. sean wang and binyu zang.
vetting undesirable behaviors in android apps with permission use analysis.
in proceedings of the acm sigsac conference on computer communications security ccs pages new york ny usa .
acm.
yajin zhou and xuxian jiang.
dissecting android malware characterization and evolution.
in security and privacy oakland ieee symposium on .