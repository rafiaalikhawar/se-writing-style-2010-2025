search based synthesis of equivalent method sequences alberto goffi alessandra gorla andrea mattavelli mauro pezz and paolo tonellax university of lugano switzerland goffia mattavea pezzem usi.ch saarland university germany gorla st.cs.uni saarland.dexfondazione bruno kessler italy tonella fbk.eu abstract software components are usually redundant since their interface o ers di erent operations that are equivalent in their functional behavior.
several reliability techniques exploit this redundancy to either detect or tolerate faults in software.
metamorphic testing for instance executes pairs of sequences of operations that are expected to produce equivalent results and identi es faults in case of mismatching outcomes.
some popular fault tolerance and self healing techniques execute redundant operations in an attempt to avoid failures at runtime.
the common assumption of these techniques though is that such redundancy is known a priori.
this means that the set of operations that are supposed to be equivalent in a given component should be available in the speci cations.
unfortunately inferring this information manually can be expensive and error prone.
this paper proposes a search based technique to synthesize sequences of method invocations that are equivalent to a target method within a nite set of execution scenarios.
the experimental results obtained on methods from classes show that the proposed approach correctly identi es equivalent method sequences in the majority of the cases where redundancy was known to exist with very few false positives.
categories and subject descriptors d. .
testing and debugging f. .
specifying and verifying and reasoning about programs general terms measurement veri cation keywords redundancy equivalent method sequences search based software engineering speci cation mining mauro pezz e is also with the university of milano bicocca.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction the presence of equivalent code fragments for example methods or method sequences make modern software systems redundant .
informally two methods are equivalent if they produce indistinguishable results when called with proper parameters.
this is the case for instance of methods put and putall in the google guava class abstractmultimap .1they produce indistinguishable results when putall is called with a collection containing the single value passed toput .
beside interchangeable methods as in the previous example it is possible to obtain equivalent executions by combining several method invocations.
for example method pop of class stack in the java standard library is equivalent to the method sequence remove size .
indeed removing the element on top of the stack pop leads to the same result as removing the element in the last position remove size .
this form of redundancy should not be confused with what are usually referred to as code clones.
code clones are typically the result of bad design and implementation practices such as copy and paste and indicate the need of code refactoring .
instead the redundancy described above is the result of good design practice as it aims to o er a richer api to client components and to increase code reusability.
while in some cases redundancy exists only at the interface level it often extends to the underlying code.
for example the code of methods popandremove is substantially di erent as shown in figure .
the di erence in the implementation extends even to removeelementat which is invoked by pop since it does not use the code of remove .
we omit the code ofremoveelementat for lack of space.
recent studies indicate that redundancy is widely spread in software systems.
jiang and su studied the linux kernel and found more than semantically equivalent code fragments while carzaniga et al.
found more than equivalent methods or method sequences in java applications and libraries of non trivial size and complexity including apache ant google guava joda time and eclipse swt .
equivalent method sequences nd many useful applications from the automatic generation of test inputs to the design of self healing systems and the automatic generation of test oracles .
in all these applications the equivalence is exploited automatically but must be identi ed manually .
the manual identi cation of equivalent method sequences is a non trivial and error prone activity that may represent an obstacle to the practical applicability of these techniques.
e pop f e obj intlen size obj peek removeelementat len return obj 7g1public e remove intindex f if index elementcount throw new arrayindexoutofboundsexception index e oldvalue elementdata index intnummoved elementcount index if nummoved system.arraycopy elementdata index elementdata index nummoved elementdata null return oldvalue 12g figure methods popand remove of class stack from the java standard library in this paper we propose a search based technique that can automate this activity.
given a target method and an initial set of execution scenarios our technique automatically synthesizes method sequences that are likely equivalent to the target method.
the synthesized method sequences are equivalent with respect to the set of execution scenarios and are expected but not guaranteed to be equivalent in the general case.
the synthesis proceeds in two phases in the rst phase the search goal is to synthesize a candidate method sequence to be likely equivalent to the target method in the second phase the search goal is to synthesize a counterexample showing that the candidate method sequence is not equivalent to the target method on some previously unexplored scenarios.
the two phases iterate with the counterexamples added to the execution scenarios until the second phase fails to nd a new counterexample.
at this point the synthesized method sequence is deemed as likely equivalent to the target method.
the technique is fully automatic and requires only as few as one test input the initial execution scenario that may be either provided by the developers or generated automatically.
our experiments indicate that the technique is e ective in synthesizing equivalent method sequences and at the same time is reasonably e cient.
on methods belonging to di erent classes for which equivalent method sequences were known a priori our approach synthesizes of the known equivalences nding one or more equivalent sequences for each target method with few false positives and within reasonable execution time.
this paper is organized as follows section introduces the concepts of software redundancy and equivalent sequences and provides some basic terminology used throughout the paper.
section overviews the essential characteristics of search based engineering to make the paper self contained.
section presents our approach in detail.
section discusses the validity of the proposed technique referring to some experiments conducted on relevant case studies.
section overviews the related work.
section summarizes the results presented in the paper and illustrates our future research plans.
.
software redundancy a software system is redundant if the execution of di erent methods or combinations of methods leads to indistinguishable results albeit executing totally or partially di erent code.
two executions lead to indistinguishable results if they produce the same output and lead to states that cannot be di erentiated by further interacting with the system.
intu itively we are considering a type of observational equivalence where the states produced by the executions may be internally di erent but not externally distinguishable by probing the system through its public interface .
for example both methods pop and remove size of the java class stack return the object on top of the stack and leave the stack without the top object.
they produce indistinguishable results but execute di erent code as illustrated in figure .
we say that two methods or combinations of methods are equivalent if they produce indistinguishable results for all possible inputs as in the previous example.
a method is trivially equivalent to itself and to an exact copy of itself.
however in this paper we are interested in methods or combinations of methods that are equivalent but execute at least partially di erent code as in the example ofpop and remove size because of the interesting applications in the area of software testing and self healing.
redundancy can be explicitly added to a software system to increase reliability or may be due to modern design practices that span from backward compatibility to the inclusion of overlapping libraries and design for reusability .
a library might maintain di erent versions of the same component to ensure compatibility with previous versions.
for example java contains at least classes and methods that are deprecated and that overlap with the functionality of newer classes and methods.
modern development practices naturally induce developers to use reusable components that already implement the needed functionality.
it is common to nd several components that provide similar or identical functionalities.
for instance the trove4j library implements collections specialized for primitive types that overlap with the java standard library.
yet another form of redundancy is due to performance optimization.
for example the gnu standard c library implements its basic stable sorting function using the insertion sort algorithm for small sequences and merge sort for the general case.
although all kinds of intrinsic redundancy that concretize in equivalent code fragments are interesting in this work we focus on equivalent methods and combinations of methods in the same component.
in this paper we present a technique that synthesizes equivalent methods or combinations of methods by exploiting search based metaheuristics.
we synthesize equivalences by examining the program behavior on a nite set of execution scenarios and we refer to the synthesized methods or combinations of methods as likely equivalent to indicate that they may behave di erently for inputs not considered in the synthesis process.
.
search based engineering search based software engineering is an emerging eld that consists in applying search based algorithms to software engineering problems .
in the last years search based engineering has produced interesting results especially in the area of automatic test case generation where genetic algorithms gas play a dominant role mostly because of their good performance .
gas are inspired by the natural laws of evolution discovered by charles darwin and in particular by the survival of the ttest principle.
informally gas look for approximate solutions to optimization problems whose exact solutions cannot be obtained at acceptable computational cost.
in a nutshell a ga aims to either minimize or maximize the value of a tness function that quanti es the distance of the candidate solutions from optimality.
each candidate solution of the problem is encoded in what we refer to as achromosome .
apopulation is a set of chromosomes that iteratively evolves through generations by means of genetic operators.
genetic operators select and evolve candidate solutions to produce new tter chromosomes.
the genetic operators commonly employed in gas have two objectives.
first they select chromosomes with the best tness values that is those candidate solutions to be preserved in the next generation.
second they create new chromosomes by introducing variations in a candidate solution for example through chromosome mutation and crossover.
gas terminate when they either nd the desired solution or exhaust the time budget for the search and return the best solution found during the evolution process.
to apply gas to a problem it is necessary to de ne i a representation of a candidate solution as chromosome ii a tness function de ned on the basis of the chosen candidate representation and iii a set of genetic operators.
gas have been successfully used to generate test cases for both procedural and object oriented software systems .
gas transform the problem of generating test cases into the problem of searching for inputs that maximize the coverage metrics associated with the chosen test adequacy criterion for instance branch coverage.
when generating test cases for object oriented systems a chromosome is a combination of invocations of constructors and methods terminated with the invocation of the method under test.
primitive types are generated randomly while the objects needed for the nal call are generated by invoking their constructors.
intermediate method calls are introduced in a chromosome to change the internal state of an object.
some mutation operators are general for example the mutation of a primitive value while others are designed speci cally to manipulate method sequences by inserting removing or replacing method calls.
di erently from mutation operators which are applied to single chromosomes thecrossover operator combines pairs of chromosomes for instance by swapping their su xes.
the tness function commonly employed in the literature to maximize branch coverage is the sum of the approach level and the branch distance .
the approach level rewards those executions that get close to the target branch referring to the control ow graph while the branch distance quanti es heuristically the distance of a condition from the opposite boolean value .
by evolving iteratively over generations gas produce test cases with increasing tness values until either all branches are covered or a time limit is reached.
.
synthesis of equiv alent method sequences we exploit search based algorithms and in particular gas to synthesize a sequence of method invocations that is likelyequivalent to a target method mby means of a two phase iterative process.
we start with an initial non empty set of execution scenarios that represent a sample of the input space of m. the initial execution scenarios may be as simple as a single test case.
in the rst phase we use gas to generate a likely equivalent candidate eqfor the given set of scenarios.
in the second phase we validate eqby using gas to nd a counterexample which corresponds to an execution scenario for which eqand mbehave di erently.
if we nd a counterexample we add it to the set of execution scenarios and we iterate through the rst phase looking for a new candidate eq.
otherwise we have successfully synthesized a method sequence eqthat is likely equivalent to m. method mmay be equivalent to many di erent method combinations.
therefore once an equivalent method sequence has been synthesized we incrementally remove the methods used in the synthesized sequence from the search space and we iterate looking for further equivalences.
the process for identifying a likely equivalent method sequence for a target method mis detailed in algorithm .
the algorithm needs a non empty set of execution scenarios form.
if the method comes with one or more test cases the algorithm uses them otherwise it generates an initial set of execution scenarios line and then iterates over the two phases lines .
the rst phase is detailed with function find equivalent lines .
the search based algorithm is employed to generate a sequence of method invocations that is likelyequivalent to the input method mfor the current set of execution scenarios.
the algorithm iteratively generates a candidate sequence of method invocations line and evaluates the equivalence of the synthesized sequence with mfor all the executions ein the set of execution scenarios lines .
if the candidate is equivalent to mfor all the execution scenarios the phase terminates and returns the candidate line .
otherwise the algorithm discards the candidate and generates a new one which will then be evaluated for all the execution scenarios.
the function equivalent compares the object attributes and the return values obtained by executing the original method mand the candidate method sequence on a given execution scenario.
if no candidate equivalent sequence is found within a given time bound the rst phase terminates line and the whole algorithm terminates as well line .
the second phase is detailed in function find counterexample lines .
during this phase the algorithm validates the candidate through the exploration of new scenarios in the attempt to violate the equivalence between mand the candidate equivalent sequence synthesized after the rst phase.
the search for a counterexample terminates when either a counterexample is found line or the search budget expires line .
if this process produces a counterexample then the candidate is deemed as not equivalent tomand the second phase terminates.
the algorithm iterates from the rst phase adding the counterexample to the execution scenarios.
the main iteration line terminates when a timeout expires and the algorithm fails in synthesizing an equivalent sequence line .algorithm synthesis of an equivalent method sequence.
input m execscenarios load initial ts while time overall time limit do candidate find equivalent m execscenarios ifcandidate is nil then return nil end if counterex find counterexample m candidate ifcounterex is nil then print candidate remove calls candidate end if add counterex to execscenarios end while function find equivalent m execscenarios while time time limit do candidate synthesize equivalent calls candidatefound true foreach e in execscenarios do if equivalent m candidate e then candidatefound false break end if end for ifcandidatefound then return candidate end if end while return nil end function function find counterexample m candidate while time time limit do counterex synthesize counterexample if equivalent m candidate counterex then return counterex end if end while return nil end function if the algorithm cannot produce new counterexamples it prints the likely equivalent sequence line removes the method calls used in the synthesis of the candidate line and iterates to synthesize new equivalent sequences.
we implemented the algorithm illustrated above in a java prototype tool called sbes search based equivalent synthesis .
figure shows the main components of sbes which exploits evosuite as search based engine.
the execution scenarios generator generates a set of execution scenarios by invoking evosuite.
the stub generator creates a modi ed version of the target class by removing the target method m to enable the synthesis of equivalent sequences.
the driver iteratively invokes evosuite to synthesize equivalent sequences and to search for counterexamples.
evosuite natively supports the generation of test cases with method calls constructors arrays of random length and primitive values.
we modi ed evosuite to better deal with arrays of given length and values.
currently evosuite does not generate some arithmetic operators loops and conditional statements and thus our current prototype implementation figure main components of sbes cannot synthesize equivalent sequences that contain these constructs.
in the next sections we detail the key components of sbes and describe the generation process.
.
initialization execution scenarios deciding whether two methods are equivalent for all the possibly in nite execution scenarios is an undecidable problem.
however the problem becomes tractable by limiting the number of scenarios to a nite set.
we thus synthesize a method sequence to be equivalent to a target method mby comparing the functional behavior of mand the candidate sequence on a nite set of execution scenarios.
execution scenarios can be either provided by developers typically in the form of a test suite for the target method m or can be generated automatically with tools such as randoop and evosuite .
in our experiments we used test suites when available and we generated the execution scenarios with evosuite otherwise .
evosuite generates and evolves test suites in the attempt to cover a set of target branches through the invocation of any accessible method.
since the tool may generate method invocations that call the target method mindirectly we modi ed evosuite forcing every generated execution to include an explicit call to mas its last statement.
in the context of java programs an execution scenario is a sequence of method invocations that generates objects by means of constructors operates on such objects by means of public and protected methods and terminates with an invocation of method m. the following method sequences are two examples of valid execution scenarios for the pop method of the stack class stack s new stack s.push int result s.pop stack s new stack s.push s.push int result s.pop .
first phase candidate synthesis the rst phase synthesizes a sequence of method invocations that is equivalent to the target method mon a set of execution scenarios.
for this task the prototype relies on thestub generator and the driver components.
the stub generator creates a stub for the target class namely the class that includes the declaration of the method m. the stub class encloses all the execution scenarios and evaluates the equivalence between the target method and the synthesized candidate sequence.
the driver iteratively synthesizes method sequences by invoking evosuite and uses the stub class to evaluate whether the generated sequence is equivalent to the target method m. given a class cthat declares the target method m the stub generator produces a new stub class cstub that contains the following core elements expected states is an array containing one object of type c for each execution scenario.
this data structure stores the state of these objects after the execution of each scenario.
expected results is an array containing the return values of each execution scenario on the target method m. actual states is an array containing one object of type cfor each execution scenario.
this data structure stores the state of the objects after the execution of the synthesized method sequence on each scenario.
actual results is an array containing the return values of the execution of the synthesized method sequence on each scenario.
custom methods the stub class declares every method originally declared in class cand every method that c inherits from any of its superclasses.
each of these custom methods simply invokes the corresponding original method of con every object in the actual states array and returns the corresponding return values of such executions in the form of an array.
class constructor the constructor of the stub class invokes each scenario on the objects stored in expected states and stores the results in expected results .
similarly it invokes all the methods of each scenario on the objects stored in actual states .
these latter invocations do not include calls to the target method m. setresults method is a utility method that stores the return values of the synthesized sequence in actual results .
method under test is the target method for the searchbased test case generator.
it contains a single branch whose condition asserts the equivalence of method m and the synthesized sequence with respect to all the execution scenarios.
the equivalence considers both the object states as stored in expected states andactual states and the return values as stored in expected results and actual results .
figure shows the automatically generated stub for the stack class in the java standard library.
given the two execution scenarios presented in section .
the stub class declares two arrays of length for the expected and the actual object states and two arrays of length for the expected and the actual execution results.
the constructor at line executes both scenarios and stores states and results in the expected states andexpected results arrays respectively.
the actual states array contains the object states obtained by applying each execution scenario up to the invocation of the target method for example pop in the running example .
method push line is an example of how the stub generator redirects the invocations of the methods of the stack class to the objects stored in actual states .
such redirections occur for every method that was originally declared in the stack class with the exception of the target method pop.
the method method under testat line is the main driver for the synthesis of a candidate equivalent sequence.
by generating an execution that covers the true branch of this method we obtain a method sequence that is equivalent to the target method in all the considered scenarios.
we1class stack stubf stack exp state new stack intexp result new int stack act state new stack intactresult new int public stack stub f execution scenario exp state new stack exp state .push exp result exp state .pop actstate new stack actstate .push execution scenario exp state new stack exp state .push exp state .push exp result exp state .pop actstate new stack actstate .push actstate .push 23g public int push intitem f intres for inti i i res act state .push item return res 30g ... public void method under test f if distance exp state act state distance exp state act state distance exp result act result distance exp result act result target 38g public void setresults intres f for inti i i actresult res 43g 44g figure the stub automatically generated for the stack class of the java standard library generate such sequence with evosuite which has been modi ed so that its only goal is to cover the true branch of method under test.
the generation of likely equivalent method sequences is guided by the tness function that quanti es the distance of each candidate sequence from satisfying the condition at lines .
since the condition is a conjunction of atomic clauses the tness function is the sum of the branch distances for each single clause so that the overall distance is zero when all the clauses evaluate to true .
in turn the branch distances for the atomic clauses are computed as numeric object or string distances depending on the involved types.
when the distance involves objects the search based algorithm cannot guide the evolution since comparing objects with the boolean method equals attens the tness landscape .
to overcome this problem we resort to an object distance that quanti es the di erence between two objects similarly to what artoo and recore implement.
such notion of equivalence between objects is stronger and in fact implies the notion of behavioral equivalence.the driver component of our tool controls all the elements described so far and drives the whole process towards the synthesis of a candidate equivalent sequence as follows i it generates the initial set of scenarios by means of the execution scenarios generator or it loads the initial scenarios if these are available ii it generates the stub class and iii it invokes evosuite to generate a sequence of method invocations that tries to cover the target branch in method under test after saving the results of the execution by calling setresults .
in an attempt to nd an equivalent sequence for method popof class stack the driver may generate the following sequence of method calls 1stack stub x0 new stack stub 2intx1 x0.remove 3x0.set results x1 4x0.method under test which in turn can be automatically transformed into the candidate sequence stack.pop stack.remove this candidate expresses the equivalence between pop which removes the object on top of the stack and returns such object and remove which removes the rst element in the stack and returns it.
this equivalence holds only because the rst and the last elements in the two scenarios considered above are the same two integer values equal to .
this equivalence though does not hold in other scenarios.
the next section describes how the second phase can invalidate such a spurious candidate.
.
second phase candidate validation the second phase validates the candidate equivalence synthesized in the rst phase by considering other execution scenarios.
more precisely this phase aims to identify a scenario for which the equivalence does not hold.
similarly to the rst phase the prototype automatically generates a method under testcontaining a single branch asserting the non equivalence between method mand the synthesized candidate sequence.
the prototype then automatically includes such method in the declaration of class c. for instance this is how our sbes prototype automatically transforms class stack 1class stackf public int pop f...g public int push intitem f...g ... public void method under test f stack stack deepclone this intexpect this.pop intactual stack.remove if distance this clone 0jjdistance expect actual target 11g 12g similarly to the rst phase we exploit evosuite to automatically generate an execution covering the target branch line hence generating a counterexample for the equivalence.
the original method popis applied on object this while the candidate sequence is applied to a clone of object this.
we rely on a deep clone library to create exact copies of the current state of the object.
this operation is crucial to avoid spurious results since not all classes may contain a sound and complete implementation of the optional method clone .for the stack example evosuite might produce the following method sequence in an attempt to cover the true branch of method under test 1stack x0 new stack 2x0.push 3x0.push 4x0.method under test which indeed provides a scenario that shows that the equivalence between pop and remove does not hold.
in this scenario the rst and the last elements in the stack are different and consequently the two operations have di erent e ects on the stack .
as described in algorithm the process iterates and the synthesis of a new candidate takes into account also the new execution scenario stack s new stack s.push s.push int result s.pop in the second iteration of the rst phase for this example the stub considers three scenarios and the size of all the arrays and the branch conditions to cover are updated accordingly.
the new iteration of the rst phase may generate the following method sequence that covers the new target branch 1stack array x0 new stack array 2intx1 x0.size 3intx2 arrayutils.add x1 4intx3 x0.remove x2 5x0.set results x3 x0.method under test thus producing the following new candidate stack.pop int x0 stack.size int x1 x0 result stack.remove x1 in this new iteration the search for a counterexample times out and the synthesis process outputs the likely equivalent sequence.
since a method can be equivalent to a code fragment that combines more than one method sbes incrementally removes the methods used in the currently synthesized sequence from the stub.
at each iteration sbes repeats the search process for each newly generated stub to obtain further equivalent sequences when more exist.
.
experimental ev aluation the evaluation of our work aimed to answer the following research questions rq1 recall can the proposed approach correctly identify equivalent method sequences?
rq2 precision how often does the proposed approach wrongly identify non equivalent method sequences as equivalent?
rq3 performance how e ciently can the proposed approach identify equivalent method sequences and counterexamples?
rq4 role of counterexamples how often do counterexamples correctly discard method sequences that are not equivalent to the target one?
research questions rq1 and rq2 deal with the e ectiveness of the proposed approach by considering its ability toretrieve known equivalences recall and to report them with few false positives precision .
rq3 deals with the e ciency and the practical applicability of the approach.
rq4 validates the need for the second phase of the approach to generate counterexamples and eliminate sequences that were at rst wrongly identi ed as equivalent.
to answer rq1 and rq2 we resorted to the standard recall and precision metrics recall true positives true positives false negatives precision true positives true positives false positives recall is de ned as the ratio between the number of equivalent sequences correctly synthesized with the approach true positives and the total number of equivalent sequences which include both the ones correctly synthesized true positives and the ones that the approach fails to synthesize false negatives .
precision is de ned as the ratio between the number of equivalent sequences correctly synthesized with the approach true positives and the total number of sequences deemed as equivalent which include both the equivalent ones true positives and the non equivalent ones erroneously identi ed as equivalent by the approach false positives .
to answer rq3 we measured performance as the time required to synthesize an equivalent sequence and the time required to nd a counterexample since these two measures directly in uence the overall performance of our approach.
we use these two values to compute the optimal timeouts.
in fact we acknowledge a synthesized sequence as likelyequivalent to the target method when no counterexamples are found within a given timeout.
the maximum time required to nd a counterexample indicates the optimal value for the counterexample timeout a smaller value would lead to missing some counterexamples a larger value would cause time waste.
similarly the maximum time required to synthesize a sequence indicates the optimal synthesis timeout that is the value that avoids missing sequences without wasting time.
for rq4 we measured the role of counterexamples as the number of method sequences identi ed as candidates for equivalence that the counterexamples discard as false positives.
this number corresponds to the number of iterations between the second and the rst phase since discarding a sequence results in re executing the rst phase.
.
experimental setup the rst target of our experiments is class stack taken as a representative for the various containers available in the java standard library.2class stack is particularly challenging because it contains many generics and many non trivial equivalent method sequences.
we also considered a set of classes from graphstream a library to model and analyze dynamic graphs.
our experiments cover methods of class stack and methods belonging to classes of graphstream as reported in table .
stack and graphstream represent di erent application domains are developed and maintained by di erent html party subjects and include all the language characteristics that we can currently handle with evosuite which constrains our prototype implementation.
we ran the experiments by feeding the prototype with the class under analysis the target method and an initial scenario.
the target method is the method of the class under analysis for which we would like to synthesize equivalent method sequences.
the initial scenario consists of one test case that was either extracted from the existing test suite or generated automatically with evosuite depending on the availability of the test suites.
we gave a search budget of seconds to both the rst and the second phase.
to answer rq1 and rq2 we compared the sequences that we synthesized automatically against the set of sequences that we previously identi ed with manual inspection within the limits of the current prototype.
in theory the amount of equivalent sequences would be in nite since we can easily combine simple equivalent sequences to obtain new ones.
for example method pop is equivalent to remove size but is also equivalent to push pop remove size .
in our experiments we considered only minimal equivalences that we informally identify as those that cannot be derived by suitably combining simpler equivalences or adding method calls with a globally null e ect as the pair push pop in the previous example.
in our experiments we synthesized equivalent method sequences for single methods only.
synthesizing equivalent sequences for method sequences does not change the problem but simply augments the size of the experiment.
our automatic synthesis is limited by evosuite that can deal with method calls constructors primitive values and arrays but not with all the arithmetic operators loops and conditional statements.
these limitations are inherited from evosuite itself and do not belong to the approach that can synthesize equivalent sequences for general method sequences potentially exploiting all language constructs.
we repeated the experiments times because of the random nature of search based algorithms and we considered both the maximum averaged and cumulative results over the executions.
the maximum result is the one obtained from the best execution while the average result gives the result expected from a single execution.
the cumulative result aggregates results from all executions.
the execution environment provides a listener that logs detailed information about the timing of the events.
each iteration consists of creating a stub compiling and executing it.
the listener logs the compilation and execution time recording the execution time of both the prototype and evosuite.
these data allowed us to compute all the performance metrics discussed above.
.
results in this section we discuss the experimental results.4we ran our prototype on methods of classes taken from the stack java standard library and the graphstream library.
we automatically synthesized equivalent method sequences which represent more than of the sequences that we manually identi ed ahead by inspecting the classes documentation.
we considered only the minimal equivalences 4a replication package containing both the subjects and the data collected during our experiments is available at sample sequences synthesized with sbes original sequence synthesized sequence java.util.stack addelement object e add e push e add e size collection c new collection c.add e addall c clear removeallelements setsize collection c new collection retainall c e pop e peek index size removeelementat index e set int i object o e remove i insertelementat o i org.graphstream.graph.implementations.edge getsourcenode temp gettargetnode getopposite temp gettargetnode temp getsourcenode getopposite temp org.graphstream.graph.implementations.singlenode getattribute string s getattribute s object.class org.graphstream.ui.geom.vector2 ll double d vector2 v new vector2 v.set d d copy v point2 p new point2 d d set p.x p.y scalaradd d org.graphstream.ui.geom.vector3 copy vector3 v point3 p new point3 p.move v set p.x p.y p.z and we excluded those that could not be found due to the limitations of our prototype.
table presents a sample of the equivalent sequences that we synthesized automatically.
sbes can synthesize both simple equivalences e.g.
methods that can be replaced interchangeably and complex equivalences that include non trivial combinations of method calls as in the case of collection c new collection c.add e addall c that is equivalent toaddelement e .
table summarizes the experiment results.
for each of the analyzed methods the table shows the following information i the number of minimal equivalent sequences identi ed with manual inspection column tot which we use as baseline ii the amount of equivalent sequences automatically synthesized in at least one run column max t iii the maximum amount of equivalent sequences synthesized with a single run column max r iv the average amount of equivalent sequences identi ed in the runs column avg v the precision prec and the recall rec computed over the runs.
table shows that in all those cases where a target method has multiple equivalent sequences our approach can synthesize a substantial fraction if not all of the equivalences even within a single run.
this is a very interesting result since all of the practical applications of redundancy typically bene t from a high level of redundancy .
in the stack case study when sbes was not able to synthesize all the manually identi ed equivalences we observed that sometimes the correct equivalent sequence was indeed synthesized during the evolution of the individuals.
however the objects holding the correct results were not used as parameters of thesetresults method and therefore the search did not stop.table rq1 rq2 e ectiveness of the approach case study totsynthesizedprec recmax tmax ravg java.util.stack add int object .
.
.
add object .
.
.
addelement .
.
.
clear .
.
.
elementat .
.
.
rstelement .
.
.
get .
.
.
indexof .
.
.
lastelement .
.
.
peek .
.
.
pop .
.
.
push .
.
.
remove object .
.
.
remove int .
.
.
set .
.
.
org.graphstream.graph.path getedgecount .
.
.
getnodecount .
.
.
org.graphstream.graph.implementations.edge getnode0 .
.
.
getsourcenode .
.
.
getnode1 .
.
.
gettargetnode .
.
.
changeattribute .
.
.
setattribute .
.
.
addattribute .
.
.
getattribute .
.
.
getfirstattribute .
.
.
org.graphstream.graph.implementations.singlenode changeattribute .
.
.
setattribute .
.
.
addattribute .
.
.
getattribute .
.
.
getfirstattribute .
.
.
org.graphstream.graph.implementations.multinode changeattribute .
.
.
setattribute .
.
.
addattribute .
.
.
getattribute .
.
.
getfirstattribute .
.
.
org.graphstream.ui.geom.vector2 x .
.
.
y .
.
.
set .
.
.
ll .
.
.
copy .
.
.
org.graphstream.ui.geom.vector3 x .
.
.
y .
.
.
z .
.
.
set .
.
.
ll .
.
.
copy .
.
.00table rq3 e ciency of the approach case study synthesiscounter exampleminimum timeout java.util.stack .0s .0s 76s graphstream.path .0s .0s 60s graphstream.edge .0s .0s 7s graphstream.node .0s .0s 7s graphstream.multinode .0s .0s 9s graphstream.vector2 .0s .0s 36s graphstream.vector3 .0s .0s 29s we are currently working on improving the evolution process to make use of any object available in the current method sequence instead of arbitrarily choosing one.
in summary precision and recall are high almost always close to or equal to one indicating that the proposed approach can retrieve most of the known equivalent sequences with a low number of false positives.
therefore we can answer positively to both rq1 and rq2 rq1 rq2 the proposed approach can correctly identify one and often more than one equivalent method sequences with recall and precision which are close or equal to one in most of the cases.
table reports the e ciency metrics.
column synthesis shows the time required to synthesize an equivalent sequence while column counterexample reports the time for the counterexample generation.
column minimum timeout shows the minimum timeout that can be set to the counterexample phase without altering the e ectiveness of the approach that is the precision and recall values reported in table .
columns synthesis and counterexample report the median of the values computed over the runs across the target methods of each class we aggregate performance data by class to save space the interested reader can nd the detailed data in our replication package .
column minimum timeout reports the worst computation time experienced in the experiments during the counterexample phase.
the table reports only the counterexample timeout because the synthesis timeout is always lower than the counterexample one and thus the counterexample timeout represents an upper bound for the performance of the approach.
the execution time is acceptable and compatible with the typical usage scenarios in which redundancy is needed.
in fact even when equivalent sequences are used at runtime for example in selfhealing applications the synthesis of equivalent sequences can be carried out in advance o ine.
hence we can answer positively to research question rq3 rq3 the proposed approach requires a total execution time that is compatible with the typical application scenarios where redundancy can be identi ed o ine.
table reports the data about the e ectiveness of the counterexamples column false positives indicates the amount of sequences that were erroneously identi ed as equivalent and were not automatically discarded with a counterexample.
column discarded indicates the amount of over tted candidate solutions that are identi ed as non equivalent by a counterexample and column e ciency indicates the percentage of sequences automatically discarded with counterexamples.table rq4 e ectiveness of counterexamples classfalse positivesdiscarded e ciency java.util.stack .
graphstream.path .
graphstream.edge .
graphstream.node graphstream.multinode graphstream.vector2 .
graphstream.vector3 .
the table indicates that counterexamples are extremely effective in identifying and removing many method sequences erroneously proposed as equivalent from in the worst case to over in the best case.
false positives include both sequences for which evosuite fails to nd a counterexample and sequences for which evosuite crashes silently due to a nullpointerexception before completing the search.
this last category corresponds to about of the false positives and we expect to signi cantly reduce them by solving the cause of the exceptions in evosuite.
we can thus positively answer research question rq4 rq4 counterexamples can discard a relevant amount of method sequences erroneously identi ed as equivalent to the target one and can thus reduce signi cantly the number of reported false positives.
.
threats to validity the main threats that a ect the validity of the empirical study described above are the authors bias and the external validity threats.
authors bias the authors have manually identi ed the reference set of equivalent sequences used to assess the e ectiveness of the approach.
such task was carried out before running sbesto avoid any in uence from sbesoutput.
moreover one author has cross checked the equivalent sequences identi ed by another author to verify that no equivalent sequence was missed and that the identi ed equivalent sequences were correct.
external validity we have validated our approach on classes and methods taken from two real world subjects.
di erent results could be obtained for di erent systems.
we have chosen two subjects java.util and graphstream that were known to contain some degree of redundancy in their implementation.
by construction our approach will not produce any valuable result on systems that do not include any redundancy at all.
the selection of the two subjects used in the experiments was driven exclusively by prior knowledge about the presence of redundancy.
hence we expect our approach to behave similarly on other systems having a comparable degree and kind of redundancy.
on the other hand speci c implementation details might a ect the performance of search based generators in nding candidate method sequences or counterexamples.
for instance the use of generic types in class stack represented a technological obstacle that required some tool adaptation.
we have tried to choose the subjects used in the reported experiment so as to maximize their diversity.
the only way to further reduce the external validity threat consists of replicating our study on more subjects.
for this reason we make our experimental package publicly available to other researchers.
.
related work the technique proposed in this paper uses a search based approach to automatically synthesize method sequences that are equivalent to a target method.
relevant related work can be found in the areas of automatic inference of speci cations and search based techniques to synthesize redundancy.
.
specification inference speci cation mining nds its roots in the pioneer work of ernst et al.
who proposed daikon to infer likely program invariants from a nite set of executions .
dysy improves the quality of the invariants by exploiting dynamic symbolic execution .
similarly the feedback loop framework proposed by xie and notkin re nes the likely invariants inferred with daikon by feeding them to a test generator and by using the newly generated executions to re ne the invariants .
our work shares the idea of using a nite set of executions to infer some information about the program but these techniques infer program invariants while we infer equivalence among operations.
other speci cation mining techniques infer nite state machine models of software components.
mariani et al.
infer models representing the protocol of components .
pradel et al.
can generate similar models but target mainly multiobject protocols .
ghezzi et al.
build nite state machines that model the partial behavior of components and then make such models more general via graph transformation rules .
dallmeier et al.
instead infer nite state machines representing the objects behavior and exploit test case generation to explore unobserved behavior .
more recently beschastnikh et al.
proposed a framework to specify model inference algorithms declaratively .
although nite state machines can express equivalence among di erent operations they typically abstract from the concrete events observed in the program execution.
consequently the event sequence equivalences that can be obtained from the inferred models hold for the abstract state but not necessarily for the complete concrete one.
the work of henkel and diwan is the most closely related to ours.
they use re ection to get the list of methods in a java class and they generate executions to infer algebraic speci cations for such class .
the axioms that they generate to describe the behavior of the class include information that can be used to infer the equivalence of method sequences.
however inferring the equivalence of method sequences is not their primary goal.
di erently from them we focus on the synthesis of equivalent method sequences trying to produce as many di erent equivalences as possible.
this a ects the sequence generation approach they generate method invocations randomly while we employ a search based technique to generate only those sequences that are relevant for synthesizing equivalence.
moreover our two phase approach reduces the number of invalid equivalences while they have less chances to invalidate incorrect axioms.
.
search based techniques for redundancy search based techniques have been employed in multiple domains to solve di erent problems.
test case generation is one of such domains and search based techniques have shown their potential in producing test suites that achieve high coverage according to speci c criteria .
the work closest to ours is related to search based techniques to automatically synthesize redundancy.
feldt usesgenetic programming to automatically generate program variants for fault tolerance techniques like n version programming and recovery blocks .
such variants adhere to the speci cation of the original program but are di erent enough to tolerate faults.
similarly benoit et al.
generate sosies which are variants generated by adding removing and replacing statements in the original program .
sosies provide the same expected functionality as the original program while exhibiting di erent executions.
langdon and harman produce variants of an original program with di erent non functional requirements .
these techniques generate redundancy in the sense that they synthesize programs that are slightly di erent from the original one either in their functional or non functional behavior.
our technique instead aims to identify redundancy that already exists in the considered components.
.
conclusions software redundancy that derives from the presence of equivalent method sequences nds many interesting applications that span from testing to fault tolerance and self healing.
the di erent approaches that exploit equivalent method sequences rely on manual identi cation of the equivalence and this limits their applicability and scalability.
in this paper we propose a novel technique that exploits search based algorithms to infer equivalent method sequences.
the approach is fully automatic and applies to any method sequence.
in this paper we report the experimental results obtained with a prototype that implements the approach to infer method sequences equivalent to single methods.
the results obtained for methods belonging to two di erent libraries are extremely positive.
we can automatically synthesize more than of the known equivalences that include many non trivial combinations of method calls with a negligible number of false positives.
our prototype implementation uses evosuite and inherits from it some limitations.
we are currently working on relaxing the limitations imposed by evosuite to both widen the experimental scope and consolidate the validation results.
we are also working on extending the automatic synthesis of equivalent method sequences beyond single methods to be able to identify additional equivalent elements in software systems.
finally we are studying di erent applications of intrinsic redundancy beyond the results obtained so far in the automatic generation of self healing systems and test oracles .
.