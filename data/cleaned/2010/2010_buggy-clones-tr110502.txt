cbcd cloned buggy code detector technical report uw cse may revised march jingyue li dnv research innovation h vik norway jingyue.li dnv.com michael d. ernst u. of washington seattle wa usa mernst uw.edu cbcd cloned buggy code detector jingyue li dnv research innovation h vik norway jingyue.li dnv.com michael d. ernst university of washington seattle wa usa mernst uw.edu abstract developers often copy or clone code in order to reuse or modify functionality.
when they do so the y also clone any bugs in the original code.
or different develo pers may independently make the same mistake.
as one example of a bug multiple products in a product line may use a component in a similar wrong way.
this paper makes two contr ibutions.
first it presents an empirical study of cloned bug gy code.
in a large industrial product line about of the bugs are duplicated across more than one product or file.
in three open source projects the linux kernel the git version control system and the postgresql database we found and duplicated bugs respectively.
second this pape r presents a tool cbcd that searches for code that is semantic ally identical to given buggy code.
cbcd tests graph iso morphism over the program dependency graph pdg representat ion and uses four optimizations.
we evaluated cbcd by s earching for known clones of buggy code segments in the thre e projects and compared the results with text based token bas ed and ast based code clone detectors namely simian ccfi nder deckard and clonedr.
the evaluation shows that cbc d is fast when searching for possible clones of the bugg y code in a large system and it is more precise for this purpo se than the other code clone detectors.
keywords validation debugging aids i. introduction although copy paste is generally regarded as a bad coding practice it is sometimes necessary and som e developers do it to save development effort.
baker found that of files examined included exact matches of cod e lines .
ducasse et al.
reported that two files of gcc have more than duplication .
a study of code clones in linux showed that a few copy pasted segments were copied more than eight times.
device drivers and cryptography have the highest percentage of clones because many drivers share si milar functionality and cryptographic algorithms consist of multiple similar computational steps.
code copy paste and software reuse makes buggy code appear in multiple places in a system or in differe nt systems.
for example code clones and software reuse have ca used duplicated software security vulnerabilities .
cut andpaste is a major cause of operating system bugs .
this paper makes two contributions.
first we exami ned the data in the scm software configuration managem ent system of projects an industrial software produ ct line the linux kernel git and postgresql.
we discovered th at identical buggy code does exist in all projects.
second to find clones of buggy code we developed a clone detection tool cbcd.
given an example of bug gy code cbcd uses isomorphism matching in the program dependence graph pdg to search for identical code that is clones.
subgraph isomorphism is np compl ete so we implemented four optimizations that red uce the number and complexity of graphs in the pdg isomorph ism matching.
evaluation of cbcd on real cloned buggy c ode confirms that cbcd is scalable to large systems.
to evaluate how well cbcd can find cloned bugs we also compare d cbcd with text based token based and ast based co de clone detectors using the identified buggy codes a nd their clones as oracles.
cbcd outperformed the other appr oaches.
our evaluation focuses on the important problem of finding clones of buggy code.
for other tasks the other c lone detectors may be better than cbcd.
the rest of this paper is organized as follows.
sec tion presents our empirical study of cloned buggy code i n one commercial product line and three large open source systems.
section describes the design and implementation o f cbcd which can find cloned buggy code.
section present s our experimental evaluation.
section discusses relate d work and section concludes.
ii.
an empirical study of cloned buggy code we first manually investigated whether buggy lines of code are cloned in real systems.
we examined the sc m of the linux kernel git and postgresql and the bug reporting system of a commercial software product line.
a. the linux kernel for the linux kernel we searched for the keywords in table i in commit messages and in the bug tracking system which records discussions between developers during debugging.
for each match we read the description of the commit the discussions between developers and the diff of the original file and the changed file.
this inf ormation indicated to us whether the commit was necessitated by duplication of a bug.
if so we identified the bugg y code and its clones manually.
the second column of table i shows the number of distinct independent bugs that exist in multiple l ocations.
by distinct we mean that we count a bug once even if it appears in places.
by independent we mean that if a comm it message said the same problem as commit w e count only one of the two bugs.
finally there is n o double counting if a commit message said the same proble m as with the same fix then it only appears in one row of table i. some examples of these cloned bugs are sh own in table ii.
however for some of these bugs we canno t locate the cloned buggy code because the developers did n ot give enough details.
the third column of table i omits s uch bugs.
for example one developer said the same bug that existed in the 64bit memcpy also exists here so fix it he re too but did not specify which version of which file of the system includes the fix of the bug in 64bit memcpy .
as t here are many files and many versions of linux it would be difficult to search all of them to find the fixes to memcpy .
even if we found a change to memcpy without further info rmation we do not know if that change is the fix mentioned by the developer.
table i. cloned bugs which exist in more than one place in the linux kernel key words used for searching the scm number of distinct bugs existing in more than one place number of bugs whose clones we can locate same bug same fix same issue same error same problem sum table ii.
examples of cloned bugs in the linux kernel phrases in the scm explaining the cloned bugs code modified i.e.
the lines of code modified by the bug fix this is quite the same fix as in 2cb96f86628d6e97fcbda5fe4 d8d74876239834c static int my atoi const char n ame int val for name switch name case ... val val name break default return val this patch fixes iwl3945 deadlock during suspend by moving notify mac out of iwl3945 mutex.
this is a portion of the same fix for iwlwifi by tomas.
ieee80211 notify mac priv hw ieee80211 notify re as soc it turns out that at least one of the caller had the same bug.
ret btrfs drop extents trans root inode start aligned end start hint byte other platforms have this same bug in one form or another atomic inc call data finished func info b. git and postgresql for the git and postgresql projects we used the sa me methodology.
table iii shows the number of bugs tha t exist in multiple places.
c. a commercial software product line we also evaluated a commercial product line in whic h a single product is produced for more than differe nt operating systems and mobile devices.
for of the projects we have access to bug reports and developer discuss ions.
these projects have a total of valid bugs tha t are confirmed and resolved as a bug in the code not a user error.
we searched for the same keywords in the bug report s. unlike the linux kernel git and postgresql we do not have full access to the source code in the scm.
th us we did not check the code differences.
our assessment of whether a bug was duplicated as shown in table iv was based on reading the discussions between developers during debugging.
it turns out that .
of th e bugs in these projects exist in more than one place.
table iii.
cloned bugs which exist in more than one place in g it and postgresql key words used for searching the scm git postgresql number of distinct bugs existing in more than one place number of bugs whose clones we can locate number of distinct bugs existing in more than one place number of bugs whose clones we can locate same bug same fix same issue same error same problem sum table iv.
cloned bugs which exist in more than one place in t he commercial software product line key words used for searching the bug reports number of distinct bugs existing in more than one place same bug same fix same issue same error same problem sum iii.
cbcd a tool to search for cloned buggy code once a bug is detected it is necessary to check th e whole system to see if the bug exists somewhere else.
sec tion ii shows that this is not merely a theoretical concern but is important in practice.
it is especially important f or a software product line because of high similarity among prod ucts.
customer satisfaction drops when a customer re enco unters a bug that the vendor claimed to have fixed.
although regression testing can check whether a bug is fixed or can detect an identical manifestation of the bug in oth er products regression testing cannot find all occurrences of t he bug especially when testers do not know where the buggy code may appear.
thus it is important to supplement reg ression testing by a search for clones to locate code that may behave similarly to the buggy code.
a. pdg based code clone detectors some buggy lines may be copy pasted as is but of ten developers slightly modify the copy pasted code to fit a new context .
more than of copy pasted segments in linux require renaming at least one identifier and code insertion and deletion happened in more than of the copy pasted segments .
statement reordering ide ntifier renaming and statement insertion or deletion are a lso common in buggy code clones especially clones intr oduced due to code or component reuse.
for example in tab le ii a developer stated that other platforms have this sa me bug in one form or another.
our approach is to adapt program dependence graph pdg based code clone detection methods because we believe that the pdg based approach is m ore resilient to code changes than text based token ba sed and ast based approaches.
b. tool architecture our tool cbcd for cloned buggy code detector has a pipe and filter architecture as shown in fig .
.
cbcd represents a program or code fragment as a pdg whi ch is a directed graph.
each vertex represents an entity of the code such as a variable statement and so on cbcd also records the vertex kind e.g.
control point declaratio n or expression the position i.e.
the file name an d the line of the represented source code and the source code t ext itself.
each edge of a pdg represents control or data depen dency between two vertexes.
cbcd s algorithm consists of three steps.
step codesurfer generates the pdg of both the buggy code the bug pdg and of the system to be searched for clones of the buggy code the system pdg .
the bug pdg may consist of multiple sub graphs depe nding on the structure of the buggy code cbcd handles th is case but for simplicity of presentation this paper assum es the bug pdg is connected.
the system pdg consists of a coll ection of interlinked per procedure pdgs.
step cbcd prunes and splits the system pdg see section iii.c to reduce its complexity and make su bgraph checking cheaper.
optionally cbcd also splits the original bug pdg into multiple smaller pdgs see section iii .c.
.
step cbcd determines whether the bug pdg is a subgraph of the system pdg.
it uses igraph s implementation of subgraph isomorphism matching.
ig raph is faster than other tools such as nauty whe n comparing randomly connected graphs with less than nodes .
cbcd filters the matches reported by igraph.
cbcd only outputs matches where for each corresponding vertex the vertex kinds match and the source code text mat ches.
when comparing vertex kinds cbcd tolerates control replacement e.g.
when developers change a for l oop to a while loop to provide the same functionality.
whe n comparing source code text vertexes that represent parameters of a function call are exempted.
note th at even if all vertex kinds and text match identically which cbcd does not require the source code could still be d ifferent so long as it led to the same pdg.
for example reord ering of non dependent statements does not affect the pdg nor does insertion of extra statements such as debuggi ng printf statements.
cbcd aims to find all semantically identical code c lones.
two code snippets are semantically identical if the re is no program context that can distinguish them that is if one snippet is substituted for the other in a program the program behaves identically to before for all inputs.
dete rmining semantic equivalence is undecidable so cbcd report s code with matching pdgs.
as a result every match that c bcd finds is semantically identical to the buggy code but cbcd is not guaranteed to find all semantically identica l clones.
c. pruning the search space for isomorphism graph matching all code clone detection tools that rely on graph matching face scalability problems.
cbcd s isomorph ism matching step is the most time consuming step espe cially for matching two big graphs.
the reason for this is that subgraph isomorphism identification is np complete .
in the worst case the fast subgraph isomorphism algor ithm implemented by igraph requires o n!n time wh ere n is the sum of the number of nodes and edges of both graphs to be compared.
liu et al.
claim that pdgs can not be arbitrarily large as procedures are designed to be of reasonable size for developers to manage.
in pract ice a procedure can be very big.
for example we used git as a subject program and its handle revision opt procedure has vertexes and edges.
but even smaller comparisons can be intractable in practice.
conside r a modest example the buggy code has lines of code with around vertexes and edges in the pdg and the procedure has lines of code around vertexe s and edges .
in this example n and n!n is .
.
output bug clones step subgraph testing split bug pdg pruned system pdg step split the bug pdg and prune the system pdg bug vertex info.
bug pdg system pdg system vertex info.
temporary file cbcd steps step create bug pdg step create system pdg buggy lines system to be checked figure .
architecture of cbcd to deal with the scalability problem step of cbc d prunes the number and complexity of the graphs to b e compared.
we have implemented four optimizations.
the first t hree optimizations are sound each never excludes a true match but makes the algorithm faster overall.
these optim izations are run by default.
the fourth optimization runs on ly if the buggy code segment contains too many lines of code.
the first three optimizations are based on the fact explained in section iii.b that cbcd reports syste m code as a clone of buggy code only if both the shape of the respective pdgs and also the vertex kind and source text of corresponding vertices are identical.
the first th ree optimizations can be viewed as enhancements to the subgraph isomorphism checker working around its limitation that it does not account for vertex kind s and source text.
all four optimizations are also based on the follow ing observation in most cases the bug pdg is small.
f ig.
validates this observation it is the maximum numbe r of contiguous lines of code in each of the git li nux kernel and postgresql bugs for which we can locate their c loned bugs.
this excludes bug fixes that added code r ather than changing code.
more than of the bugs cover o r fewer contiguous lines of code.
optimization opt1 exclude irrelevant edges and nodes from the system pdg cbcd removes every edge that cannot match an edge i n the bug pdg because such an edge is irrelevant for cbcd s purposes.
in particular cbcd removes every edge wh ose start and end vertex kinds and vertex text are not included in the start and end vertex kinds and characters of an edge in the bug pdg.
in the best case this disconnects ent ire sets of nodes but it is useful even if it merely removes e dges because a single system pdg can be very big.
for example suppose the bug pdg has two edges on e from vertex kind control point to vertex kind ex pression and the other from expression to actual in .
the n cbcd excludes from the system pdg all edges that do not start with control point and end with expression or start with expression and end with actual in .
at this point cbcd also compares the vertex charac ters source code text for vertex kinds whose code mus t match e.g.
not procedure parameters nor arguments .
cbc d discards those with text that cannot match the bug pdg.
the purpose of comparing vertex kinds and characters is different than step of section iii.b.
the comparison here e xcludes system pdg vertexes and edges that are irrelevant t o the bug pdg.
the comparison in step ensures that the vertexes in the isomorphism matching graphs are als o identical.
optimization opt2 break the system pdg into small graphs this optimization transforms the system pdg from on e large graph into multiple small ones.
cbcd must run more subgraph isomorphism matchings but each matching w ill focus on a smaller graph.
the idea is to utilize th e vertex kind information of the bug pdg to choose only smal l sections of the procedure pdg for each subgraph isomorphism matching.
the steps of opt2 are opt2 step1 count the number of nodes of each vertex kind in the bug pdg and the system pdg.
opt2 step2 choose the vertex kind vk min in the bug pdg that has the minimum number of occurrences in the system pdg.
if it occurs times in the system pdg there is no graph match.
opt2 step3 calculate the pseudo radius db of the bug pdg the greatest distance between a node of vertex kind vk min and any other node.
opt2 step4 for each node of vertex kind vk min in the system pdg find the neighbor graph of the vertex with radius db from the node of kind vk min .
the distance computations ignore edge directions.
figure .
size contiguous lines of the largest component of each bug fix fig.
shows an example.
since the nodes of vertex kind vk min must match and there are few of them it makes se nse to check subgraph isomorphism only near them.
it is possible for the neighbor graphs to overlap in which case s ome pdg nodes appear in multiple distinct neighbor graphs a nd will be tested for isomorphism with the bug pdg multiple ti mes.
bug pdg radius db vertexes of pdg node of kind vkmin vs. neighbor graph of node of kind vkmin with radius db system pdg figure .
breaking the system pdg into smaller pieces opt2 opt2 adds some extra overhead to cbcd.
here is the theoretical analysis of the time complexity without opt2 and with opt2.
we assume that the bug pdg has i nodes and j edges and the system pdg has i nodes and j edges.
then the time complexity of each step of opt2 is opt2 step1.
o i i2 opt2 step2.
o opt2 step3.
o i j1 because of the igraph diameter function of igraph .
opt2 step4 o w i j where there are w vertexes in the system pdg having the chosen vertex kind from opt2 step2 because of igraph neighborhood graph function of igraph .
although opt2 adds the above overhead it can significantly reduce the time complexity of step of section iii.b i.e.
subgraph isomorphism matching.
without opt2 the time complexity of comparing the bug pdg and the system pdg is between o i j i j and o i j i j !
i j i j for the algorithm implemented by igraph.
since each subgraph of the system pdg has identical pseudo radius as the bug pdg after opt2 we can ass ume the size of subgraph of the system pdg is v i1 j where v is expected to be close to .
with opt2 we compare the bug pdg with w neighbor graphs in the system pdg in step of cbcd.
the time complexity of each comparison will b e between o w i j v i1 j and o w i j v i j !
i j v i j .
let us compare the time complexity of isomorphism testing without opt2 with opt2 the best case o w i j v i j vs. o i j i j the worst case o w i j v i j !
i j v i j vs. o i j i j !
i j i j opt2 step2 chooses the vertex kind with the fewest occurrences.
so it reasonable to assume that w is small namely much less than i .
in addition we have observed that the buggy code often includes only a few lines so we can assume i j1 is much smaller than i j2.
if the two assumptions stand the time complexity of comparing the bug pdg and system pdg with opt2 will be at least a s good as the time complexity of this step without op t2 in the best case.
even in the worst case the time complex ity with opt2 will still be better than the one without it because i j is related to the size of the buggy code which is often small while i j2 is related to the size of the procedure to be compared which can have hundreds of lines of code.
optimization opt3 exclude irrelevant pdgs this optimization discards some parts of the system pdg.
the bug pdg must match within one of the rela tively small components of the system pdg.
more specifica lly each node of the bug pdg must correspond to some no de of a system pdg component so each system pdg componen t must have as many or more nodes of each vertex ki nd than the bug pdg does.
cbcd discards any system pdg component that does not satisfy this criterion.
for example suppose the bug pdg has four nodes of the expression vertex kind two nodes of the control point vertex kind and two nodes of the actual in verte x kind.
if a system pdg component includes four nodes of the expression vertex kind one node of the control point vertex kind and three nodes of the actual in ver tex kind this system pdg component will be excluded from isomorphism matching because it has too few nodes of vertex kind control point .
it therefore cannot be a supergraph of the bug pdg.
optimization opt4 break up large bug code segments although most bug segments cover or fewer lines o f contiguous code as shown in fig.
some bug segme nts are larger.
when the buggy code segment is large opt1 opt2 and opt3 may not be able to improve the performance of the system enough because when the buggy code segment is large the bug pdg will include many vertex kinds.
thus opt1 may not be able to prune many edges of the system pdg.
when the buggy code segment is large the radius of the bug pdg will be large.
thus the sub graphs of the system pdg after opt2 will still be large and isomorphism matching will be slow.
even if few large bug pdgs and large system pdgs need to be compared for isomorphism matching the system will perform very slowly.
thus opt3 which reduces the number of comparisons does not help enough.
to deal with large contiguous buggy code we implemented a fourth optimization.
it is only trigg ered when the bug has more than lines of contiguous code.
t he optimization is performed in step of cbcd and bre aks up bug code segments into sub segments with fewer line s of code.
we set two thresholds which are configurable and default to and .
the purpose of setting these tw o thresholds is to split large buggy code segment int o smaller sub segments and at the same time avoid having too small sub segments.
for a buggy code segment having more than lines of code cbcd puts the first lines of code in a subsegment first.
if the remaining lines have or few er lines of code cbcd does not split it further.
otherwise cb cd again puts the first lines of the remaining lines in the second sub segment and reconsiders the remaining li nes.
cbcd searches for clones of each sub segment independently and then merges their corresponding matched clones together.
merging can increase the false pos itive rate of cbcd if cbcd merges two unrelated partial match es into a complete match that it would never have di scovered if using the larger bug pdg.
to deal with this issu e cbcd checks the last line of one suspected buggy sub seg ment with the first line of another suspected buggy sub segme nt to be merged.
if the difference is more than lines of c ode or the two sub segments are in different files cbcd assum es that these two code lines are too far apart to be part o f clone of a single bug and does not merge them.
iv.
evaluation and discussion we wished to answer the following research question s how well can cbcd find cloned buggy code?
how well does cbcd scale?
a. the subject programs we evaluated cbcd on git the linux kernel and postgresql.
we chose those three systems because they are programmed mainly using c c which means that they can be compiled by codesurfer.
their revision histories enable us to find buggy co de and cloned buggy code for our evaluation.
git has more than 100k lines of code postgresql ha s more than 300k lines of code and the linux kernel has millions of lines of code making them a good test of the scalability of cbcd.
b. evaluation procedure oracles for the evaluation as discussed in section iii.b determining true clo nes of buggy code is undecidable.
our experiments use as an oracle the clones of buggy code that developers ide ntified.
it is possible that the developers found only some clo nes of a given bug in which case any tool that reported the others would be incorrectly considered to suffer false p ositives.
as described in section ii we identified buggy cod e and its clones by searching commit logs and reading cod e. from these bugs we chose only those related to c c co de because that is the only type of code that codesurf er can compile.
we examined all git bugs and all postgresql bugs from table iii and we arbitrarily chose one third of linux bugs from table i. we were not able to use all of these bugs our technique is not applicable when the bug fix adds new code cbcd only handles c and c our processor is bit x86 and in two cases the developers were mistaken in calling two bugs clones because they refer to completely different function s or data structures see table v .
after excluding such case s the evaluation used git bugs postgresql bugs and linux bugs.
a complete list of the bug clones exami ned in the evaluation is in appendix a. appendix d shows t he commitment information of the bugs in scm.
table v. buggy code that programmers called clones but are not true clones buggy lines of code not identical code under cbcd definition struct lock file packlock struct cache file cache file if ahd match scb ahd pending scb scmd id cmd if ahc match scb ahc pending scb scmd id cmd other code clone detectors for comparison to compare cbcd with other types of code clone detectors we also ran simian v2.
.
text ba sed ccfinder v10.
.
.
token based deckard v1.
.
ast based and clonedr v2.
.
ast based on these bugs.
these code clone detectors favor large cloned code segments rather than small ones.
as shown in fig.
cloned bugs are mostly less than lines of code so we ad justed some parameters to make the code clone detectors wo rk better.
for simian we set the number of lines of c ode to be compared for clones to its minimum value i.e.
a nd used default values for the other parameters.
for ccfind er we set the minimum clone length to be and the minimum t ks to be .
for deckard we set min tokens to stride t o and similiartiy threshold to .
.
for clonedr we set the minimum clone mass to the number of characters p er node to number of clone parameters to and similar ity threshold to .
.
for simian ccfinder and deckard the system to be checked for buggy clones is the same file set as cb cd.
however clonedr failed with parse errors when we i nput the same file set as for cbcd.
to enable a comparis on with cbcd we used a slim evaluation the system input to clonedr is only the files that include the bug and the buggy clones found by cbcd.
we additionally commented out lines that clonedr could not parse.
the slim evalua tion determines whether clonedr can find the clones that are identified by cbcd.
however the slim version inclu des only of the input files and of the lines of c ode.
if clonedr could run on all files its false positive rate would be much higher than reported in the slim evaluation .
executing the tools the input to each tool is the file that contains the buggy code along with the starting and ending lines of t he buggy code segment if the tool accepts it only cbcd did plus the system to be checked for buggy clones.
we recorded the execution time of cbcd using the linux command time .
the evaluation was run on a p c with 4g memory 3ghz cpu and running ubuntu .
.
metrics a false negative is a clone identified by the devel oper but not identified by the tool.
a false positive is a c lone reported by a tool that the developers did not report as bug gy.
we count a clone as found if a tool reports a clone pair whose parts are as large as or larger than the or iginal buggy code and the developer identified buggy clone.
thi s metric is very generous to the other code clone tools.
cb cd reports clones that have similar size to the buggy code.
the other code clone tools report much larger clones b ecause they are designed for a different purpose to find large cloned code segments.
often a single result subsumed sever al of cbcd s results.
such large results would be less us eful to a programmer.
these issues make a direct comparison o f precision and recall or of the exact number of tru e and false positives and negatives misleading.
instead for e ach tool we categorized each of the bugs as follows.
n1 no false positives no false negatives.
n2 no false positives some false negatives .
n3 some false positives no false negatives.
n4 some false positives some false negatives.
c. how well can cbcd find cloned buggy code?
table vi counts the bugs in each category.
detailed data are shown in appendix b. cbcd outperforms the other tools in finding buggy clones correctly i.e.
cbcd has t he highest number in n1.
deckard performs the worst partially because it failed with parse errors in out of the n2 cases.
unlike clonedr deckard does not report precisely t he location of the parse error.
thus we could not per form a slim evaluation as with clonedr.
table vi.
comparison with other code clone detectors cbcd simian ccfinder deckard clonedrslim n1 n2 n3 n4 researchers categorize code clones into four main t ypes and so called scenarios subcategorize each type .
the distributions of our examined bugs are shown in det ails in appendix a and are summarized as follows of duplicated bugs are type identical code fragments except for variations in whitespace layo ut and comments.
are in scenarios a b and c of type renaming identifiers or renaming data types and literal valu es.
most of the variable renaming is renaming of functi on actual arguments.
are in scenarios a and b of type small deletions or insertions.
are in scenario a of type reordering of statements.
the tools perform about equally well on type an d type clones.
in theory ast based tools could be best on type clones but cbcd s text comparisons reduce i ts false positive rate in practice.
cbcd outperforms all the other tools on type clones for example cbcd identifie s the code segments shown in table vii as clones while si mian ccfinder deckard and clonedr suffer false negativ es.
unlike text based token based and ast based clone detectors a semantics based clone detector like cb cd tolerates control statement replacement.
our exa mples did not include control statement replacement prog rammers might be less likely to call such code snippets cl ones in the bug tracking system so we evaluated this claim by artificially modifying the code of a git clone from a for statement to a while statement.
the modified code is shown in table viii.
cbcd identified the clone but simian ccfinder deckard and clonedr did not.
table vii.
examples of buggy clones identified correctly by cbcd but not by other code clone detectors buggy lines of code bug clones doorbell cpu to be32 qp rq.next ind qp rq.wqe shift size0 doorbell cpu to be32 first i nd srq wqe shift ret btrfs drop extents trans root inode start aligned end start hint byte ret btrfs drop extents trans ro ot inode file pos file pos nu m bytes file pos hint table viii.
original code vs .
code after control replacement original code code after control replacement for j first j last j struct object entry child objects deltas .obj no if child real type obj ref delta resolve delta child base obj obj type j first while j last struct object entry child objects deltas .obj no if child real type obj ref delta resolve delta child base obj obj type j the clones out of that are not identified by c bcd i.e.
the false negative cases are in table ix.
cbcd misses the first three clones because codesurfer s pdg doe s not represent data structures and macros this is not a reflection on our technique but on our toolset.
cbcd misses t he last three clones because they include variable renaming in an expression.
when a vertex in the pdg is recognized as expression as explained in section iii.c.
cbcd compares the characters of the expression to avoid false positives.
all bugs for which cbcd reports a false positive are similar the buggy code is one line of code calling a function or a few one line function calls without data contr ol dependencies among them.
for all bugs simian ccfinder or deckard either also report a false pos itive or else suffer a false negative due to a built in thre shold that prevents them from ever finding any small clone.
cl onedrslim does slightly better with false negative an d false positives.
recall that we used a slim evaluation fo r clonedr if it ran on all files its false positive rate would be higher.
one example of cbcd s false positives is shown i n table x. other calls of the same function such as memset ib ah attr sizeof param are returned b y cbcd because it tolerates renaming of actual input and o utput parameters.
however as mentioned in section iv.c.
we count as a false positive any cbcd output that is n ot yet reported by the developers as buggy.
some of the cb cdidentified clones of the bug code segments might be bugs that have been overlooked by developers.
thus cbcd s real false positive rate may be lower than table vi repo rts.
table ix.
false negatives buggy code clones that are not identified by cbcd the bug fix shown by diff static const struct amd flash info jedec table .devtypes cfi devicetype x16 cfi devicety pe x8 .uaddr mtd uaddr 0x0555 0x02aa static struct ethtool ops bnx2x ethtool ops .get link ethtool op get link define desc empty desc !
desc a desc b obj struct tag obj tagged vs. object tag tagged blue gain core global gain core global gain core blue bal vs. red gain core global gain core global gain core blue bal if !hpet !ref1 !ref2 vs. if !hpet !ref start !ref stop table x. examples of false positives buggy code all identified clones memset ib ah attr sizeof path true positive memset ib ah attr sizeof path false positive memset best table sizeof best table memset best table len sizeof best table len memset p padding etc.
table xi shows another kind of code that might lead to potential false positive reports from cbcd.
fig.
shows the pdgs.
the two vertexes representing close in bu g pdg and the four vertexes representing close in sys tem pdg lead to several sub graph isomorphism relationships between these two pdgs.
thus cbcd returned several semanti cally identical correspondences between the buggy code an d suspected code.
however all cbcd results point to the same suspected code.
cbcd coalesces duplicate resul ts that point to the same code location.
d. how well does cbcd scale to larger bugs?
in our experiments cbcd finished in seconds after codesurfer completed.
however this is not a good t est of scalability because the cloned bugs are often plat form or architecture dependent in which case the command l ine in the developer supplied makefile that compiles them does not compile the whole system.
table xi.
buggy code and suspected code of a potential false positive in git buggy code system code if pid!
close fd dup2 fd close fd if pid!
close fd dup2 fd close fd close fd close fd pid close dup2 close fd fd fd pid close dup2 close close close fd fd fd fd fd pdg of the buggy code pdg of the system code figure .
snippet of the pdg of the buggy and system code in table xi to determine how well cbcd works with larger bug segments we searched the linux and git scm using t he key word duplicate .
we chose four of these non buggy code segments from git and four from linux.
the four lin ux code segments are located in subcomponents net fs drivers and drivers of linux of different vers ions respectively and we compiled the relevant subcompo nent.
for git we compiled the whole relevant version gi t changed size over time .
table xii gives the result s. step of cbcd performed by codesurfer version .
takes a long time if the system is big but this is done only once and can be reused.
we expect codesurfer s performance to improve in later versions.
checking for clones of new bugs requires only running step and which takes only seconds.
the running time of simian ccfinder and deckard using the same parameter setting as explained in se ction iv.b are shown in table xiii.
we could not run clon edr because of its parse errors.
cbcd is slower than simian and deckard if cbcd s preprocessing step is included.
considering on ly the incremental cost of steps and cbcd is competit ive.
setting parameters to let ccfinder detect small clo nes makes it slower than cbcd because generating all s mall clone pairs first and then searching for clones of a certain code segment is inherently inefficient.
this coul d be changed but cbcd is more accurate than the other approaches regardless of their settings.
we believ e the cost of undetected bugs makes cbcd worth running even if all steps are required.
e. performance improvement due to the four optimizations we used four optimizations to speed up cbcd.
we hav e examined the unique benefits of a given optimizatio n that are not obtained by other optimizations.
for example t o evaluate opt2 we compared cbcd with opts against cbcd with opts .
table xii.
running time of each step of cbcd id nloc number of pdg edge cbcd steps sys.
bug git 67k 358k 6m 13s 5s git 75k 441k 15m 4s 2s git 81k 414k 18m 9s 3s git 81k 414k 18m 6s 2s linux1 170k 1022k 32m 15s 6s linux2 140k 830k 25m 16s 4s linux3 363k 1970k 159m 39s 8s linux4 313k 1645k 95m 17s 7s table xiii.
running time of other clone detectors id simian ccfinder deckard git 2s 5m 4m git 2s 6m 5m git 2s 8m 6m git 2s 8m 6m linux1 6s 63m 8m linux2 5s 34m 7m linux3 16s 899m 32m linux4 13s 623m 24m the results show that our optimizations can greatly improve the performance of the isomorphism matching by reducing the complexity and number of graphs to be compared.
detailed data are shown in appendix c .
opt1 i.e.
filtering out the irrelevant edges and verte xes in the system pdg contributes most to the cbcd performance improvement.
opt1 pruned on average of the edges before the subgraph isomorphism compariso n. for the bugs opt1 on average improved performance times.
however the variation is high.
one case ach ieved times performance improvement and another ach ieved times performance gain.
in one of the four duplicate code linux cases without opt1 the execution of t he step of cbcd was aborted igraph s subgraph isomorp hism function reported an out of memory error because t he system pdg is too big and too many isomorphic subgr aphs are returned .
opt2 i.e.
breaking the system pdg into smaller graphs improves step of cbcd by to times.
in one cas e opt2 improved performance by times.
the performance g ain of opt2 is not significant in other cases because opt prunes out most edges of the system pdg.
in of our exa mined cases the average ratio of size number of edges a nd vertexes of subgraph of the system pdg to size of the bug pdg i.e.
the v in the formulas of section iii.c.
is less than .
opt3 i.e.
excluding irrelevant system pdgs also improves step of cbcd by to times.
as with op t2 after opt1 filters out most of the edges of the sys tem pdg few subgraphs of the system pdgs are left for compa rison.
opt4 i.e.
breaking the large bug code segment is applicable only to three clones that have more than lines of code.
in one case step of cbcd sped up by ti mes but the other two showed no significant performance improvement.
examination of these code segments sho ws that opt4 can bring significant performance gains w hen the bug code segment has many vertex kinds especially vertex kinds such as actual in actual out or declar ation that are related to procedure parameters or arguments.
i n such cases opt1 cannot filter out many vertexes and edg es of the system pdg.
on the contrary if the number of diffe rent vertex kinds of the bug pdg is small many vertexes and edges of other vertex kinds in system pdgs will be pruned out using opt1 and opt2 and opt3 are also more eff ective subsuming the benefits of opt4.
f. threats to validity threats to internal validity the buggy code used for evaluation consists of real cloned bugs in git the linux kernel and postgresq l but were not chosen to be representative or comprehensi ve.
we do not know how many cloned bugs these projects rea lly have but we do know that around of the bugs in a commercial product were duplicates.
threats to external validity we tested cbcd only on git the linux kernel and postgresql.
it is possible that other subject progr ams would have different characteristics.
furthermore the ev aluation considers only cloned bugs in detail and these were not chosen to be representative.
threats to construct validity to measure the false positive rate of cbcd we used the clones identified by the developers as an oracle.
a s mentioned in section iv.c the developers might hav e overlooked some clones so cbcd s real false positi ve rate may be lower than reported in this paper.
g. application constraints although bugs consisting of a one line function cau se false positives in our experiment and fig.
shows that most code fixes are on one line this does not limit the applicability of cbcd.
in real life developers can often merge the buggy code line with few lines before or after it which can be regarded as the context of the buggy c ode to make a bigger code segment as the input for cbcd.
t his may help avoid false positives.
we did not perform this in our experiments to avoid evaluation bias.
v. related work previous code detection methods can be classified i nto token based code clone detecting methods examine token sequence similarities.
text or string based code clone detection methods compare the text or strings in the code.
abstract syntax tree ast based code clone detecti on methods match two asts to find code clones.
pdg based code clone detection tools try to overcome the limitations of the above code clone detectors by comparing the data and control dependence graphs of the code segments.
behavior based code clone detection tries to f ind code clone based on the execution results of test c ases.
memory state based code clone detection compares the abstract memory states of code.
most previous code clone detection tools search for large clones for code refactoring or to find plagiarism.
thus most such tools do not compare small code segments that span only a few lines.
for example pdgs smaller than a certain size are excluded from comparison in .
in genera l such tools have no knowledge of which segment of code sh ould be the input for clone searching.
thus some of the se tools start with the first line of the system and extrac t or lines as input for searching for code clones.
we have identified a new important use case.
cbcd solves a different problem than scanning an entire codebase for plagiarism detection or identifying refactoring opportunities.
cbcd is more like an advanced find command.
the input is a small code segment that inc ludes a few contiguous lines of code most buggy segments c over only a few contiguous lines of code unless the bug is caused by missing functionality or a design change .
the o utputs are all locations of the clones of such a code segment.
a user might assume that general code clone detectors woul d also perform well at detecting clones of buggy code.
how ever as our evaluation showed this assumption would be wro ng.
cbcd outperforms text based token based and ast b ased clone detectors to find cloned buggy code especial ly type and type clones.
we did not compare cbcd with behavior based clone detectors because we lack det ailed knowledge of the expected dynamic behavior of the b uggy code.
memory state based clone detectors do not fit the purpose of detecting cloned buggy code.
unlike generic code clone detectors cbcd does not generate all code clone pairs in advance.
it only s earches for clones of a small code segment on demand.
the ratio nale is that people are usually not interested in finding c ode clones of small code segments to refactor them.
however w hen they find that a code segment is buggy they need t o find all its clones and fix all of them.
as mentioned in sec tion iv.b and iv.e searching for clones on demand rather tha n generating all clone pairs at once makes cbcd more scalable than general clone detectors.
but even if other clone detectors adopted cbcd s incremental approach cbcd is still more accurate.
cbcd uses pdg based code clone detection principles to detect clones.
pdg based methods usually face sc alability problems in sub graph isomorphism checking.
one pro posed solution to improve the performance of pdg based co de clone detection is to match the pdg back to the ast so that the graph isomorphism problem is simplified in to a tree similarity problem.
however such a simplification excludes information for some edges in the pdg and makes the pdg comparison incomplete.
another proposed solution to the scalability problem is to compare the vertex histog ram of pdgs first to exclude highly dissimilar pdgs and st op the sub graph isomorphism matching after the first isom orphism is found .
such a solution is lossy because a d issimilar vertex histogram between a small pdg and a big pdg does not guarantee that the small pdg will not have a su bgraph isomorphism relationship with the large pdg.
a pdg based code clone detector based only on graph isomorp hism performed poorly compared to other code clone detec tors .
cbcd improves the accuracy of pdg based code clone detection by utilizing the syntax and text in formation of the buggy code to prune and break the pdg to be compared.
compared to the system in cbcd is le ss lossy and is more scalable to large pdgs.
yet anoth er proposed solution to the scalability problem is to compare the pdg only within radius of a vertex of contro l point kind .
this is lossy and depends on hard coded choices of radius and vertex kind by contrast our opt2 is not lossy and is general.
the studies transform the code query into graph reachability patterns and match the patterns in the sdg of the source code.
such a method can potentially be u sed to detect clones of buggy code.
however developers mu st manually describe the buggy code using code query language.
compared to these methods cbcd is easier to use because it automatically transforms the buggy code into pdg graphs and then matches the buggy pdg with the pdg of the suspected code.
similarity graph matching a lgorithm has been used to match design patterns .
howeve r the algorithm in is not directly applicable since it finds a hard coded set of design patterns rather than clone s of arbitrary bugs.
cp miner is a code clone detect ion tool that searches for bugs caused by code copy paste.
c p miner can only find bugs caused when programmers forget to modify identifiers consistently after copy pasting .
the study also compares tokens to search defect cl ones.
the securesync tool is similar to cbcd i.e.
a tool to find duplications of a software vulnerability bu g. to use securesync the clones must be classified into cate gories i ii and iii first.
a category i code clone is due t o code copy paste.
for such a code clone an ast based met hod is proposed.
a category ii code clone is due to functi on reuse.
to detect such a clone the local pdg around a func tion call is built and compared.
all other code clones are ca tegorized into iii without any methods proposed to detect the m. compared to securesync cbcd is easier to use.
peop le do not need to categorize code clone into different ca tegories and treat them differently.
for category i code clo nes cbcd better tolerates code insertion deletion and re o rdering.
cbcd can potentially support more kinds of code clo ne for example those in category iii of securesync.
we wo uld like to compare cbcd with securesync but according to its authors securesync is not available for public dis tribution yet.
jiang et al.
investigated how to discover clone related bugs through comparing the nodes in parse t rees.
in the attributes of edges and nodes of two grap hs are extracted to optimize the performance of graph isom orphism comparison for detecting clones of matlab simulink models.
in of bug fixing changes were found to be recurring and most of them occurred in multi ple files at the same revision i.e.
in space .
however this study targets identifying bug clones in object oriented s ystems.
in a few clone detection algorithms are combined with parallel algorithm to detect buggy inconsistency in a very large system.
vi.
conclusions and future work we have identified a new important use case for co de clone detection finding buggy clones motivated i ts importance in real world systems given an algorith m for finding buggy clones and evaluated its accuracy an d performance.
whereas previous work was motivated b y code refactoring or plagiarism detection we focus on detecting cloned buggy code.
the contributions of our work include .
we examined real world bug reports and scm data and established that identical cloned bugs are a serious problem.
in a commercial product line cloned bugs were common and important comprising of all bugs.
.
we proposed a methodology for improving system reliability after a bug is fixed the programmer s hould search for other code that behaves similarly to the detected buggy lines.
even if a system has relatively few cl oned bugs finding these bugs is valuable for programmers and can be done relatively accurately and inexpensively.
.
we extended previous pdg based clone detection algorithms to make them more scalable by pruning t he search space of sub graph isomorphism matching.
det ecting small clones required different algorithms and implementations than previous code detectors which are less effective in finding bug clones.
.
we implemented our algorithms in a tool cbcd t hat detects possible clones of buggy code by comparing the bug pdg and the system pdg.
the cbcd tool is available on request for research purposes.
.
we evaluated cbcd with known cloned bugs and known cloned lines of code showing that cbcd is sc alable and effective in searching for possible clones of b uggy code.
other clone detection tools are less effective for this purpose.
the performance bottleneck of cbcd is codesurfer s pdg generation.
future work is to improve performan ce of this step to make cbcd even more scalable.