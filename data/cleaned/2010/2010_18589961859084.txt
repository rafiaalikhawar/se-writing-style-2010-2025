how did you specify your test suite ?
andreas holzer michael tautschnig helmut veith vienna university of technology holzer tautschnig veith forsyte.atchristian schallhart oxford university computing laboratory christian.schallhart comlab.ox.ac.uk abstract although testing is central to debugging and software certification there is no adequate language to specify test suites over source code.
such a language should be simple and concise in daily use feature a precise semantics and of course it has to facilitate suitable engines to compute test suites and assess the coverage achieved by a test suite.
this paper introduces the language fql designed to fit these purposes.
we achieve the necessary expressive power by a natura l extension of regular expressions which matches test suites rather than individual executions.
to evaluate the language we show for a list of informal requirements how to express them in fql.
moreover we present a test case generation engine for c programs and perform practical experiments with the sample specifications.
categories and subject descriptors d. .
testing and debugging data generators coverage general terms languages verification .
introduction source code based testing is the most practical and important technique to assure software quality.
testing accompanies the development process from early versions of the implementation all the way to product certification.
in this paper we describe a novel approach to software testing where the test suites are specified in the language fql fshell query language .
fql specifications enable the user to formulate test specifications which range from local code specific requirements cover all decisions in function foousing only calls from functionbar tofoo to generic code independent requirements e.g.
condition coverage .
we have designed fql as a specification language which is easy to read it is based on regular expressions but has an expressive and precise semantics.
permission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.test specifications in fql can go well beyond established coverage criteria in our experience with students fql encourages programmers to explore their code more systematically.
fig.
contains a list of informal specifications and table shows how to express them in fql for c programs.
such specifications can be used in many contexts of which we discuss a few cf.
sec.
test case generation.
fql enables us to compute test suites according to user specified coverage criteria cf.
sec.
.
this feature is a crucial difference to directed testing which aims at good program coverage as a push button tool but has no explicit coverage goals.
in particular it enables the programmer to do intelligent and adaptive unit testing even for unfinished code.
requirement driven testing.
we can translate informal requirements into fql test specifications and generate a covering test suite.
when we evaluate the resulting test suite for e.g.
decision coverage we understand if the requirements contain sufficient detail to guide the implementation.
certification.
we can formulate precise criteria for code certification in fql and evaluate them on the source code.
the lack of formal test specifications even in standards such as do 178b has lead to inconsistent tool support.
to illustrate the problem we use the four commercial test tools coveragemeter ctc bullseyecoverage and rational test realtime rtrt to check for condition coverage 1void foo intx inta x x if a else listing sample programon the c program shown in listing .
we compiled the c program using the tool chain of each coverage analysis tool and ran the programs with the two test cases x and x .
here coveragemeter and ctc reported coverage but the other two tools returned a mere .
the difference occurs because bullseyecoverage and rtrt treat not only the variable ain line as condition but also x 2and x 5in line .
coverage evaluation.
we can determine coverage with respect to an fql query achieved by other test methods e.g.
directed model based or manual testing.
a clear understanding of coverage enables us to combine existing testing techniques in a precise manner.
for instance we can use concise specifications of missing test cases as inputs for a heavy weight tool such as a model checker.
an interface with our tool to perform automated coverage completion is part of current work.
systematic reasoning about test specifications.
finally we believe that fql gives us a clean and simple framework to scenario structural coverage criteria.
the certification of critical software systems often requires coverage criteria such a s basic block condition or decision coverage which refer to entities present in all source code.
this results in our first specifications.
basic block coverage and condition coverage.
assuming that q2refers to bullseyecoverage and rtrt s interpretation of condition coverage one must also be able to express th e competing criterion condition coverage as defined by coveragemeter and ctc .
for intensive testing a developer will employ a variant of pat h coverage but restrict it to local coverage due to high costs cover all acyclic paths through functionsmain andinsert .
cover all paths through main andinsert which pass each statement at most twice.
scenario data flow coverage criteria.
we give three examples of typical data flow coverage criteria.
cover all statements defining a variable t. cover all statements that use the variable tas right hand side value.
cover all def use pairs of variable t. scenario constraining test cases.
during development and for code exploration it is often important to achieve the desire d coverage with test cases which for instance avoid a call to an unimple mented function.
below we list five examples of this group.
basic block coverage with test cases that satisfy the assertion j after executing line .
condition coverage in function compare with test cases which call compare from inside function sort only.
basic block coverage in function sort with test cases that use a list with to elements.
cover function eval with condition coverage and require each test case to perform three recursive cal ls ofeval .
cover all calls to sort such that sort never calls unfinished .
the function unfinished is allowed to be called outside sort assuming that only the functionality of unfinished which is used by sort is not testable yet.
cover all conditions and avoid trivial test cases i.e.
require that insert is called twice before calling eval .
scenario customized test goals.
complementary to the constraints on test cases of scenario we also want to modify the set of test goals to be achieved by the test cases.
condition coverage in function partition with test cases that reach line at least once.
condition decision coverage the union of condition and decision coverage .
to understand the interaction of two program parts it is not sufficient to cover the union of the test goals induced by each part but to cover their cartesian product cover all possible pairs between conditions in function sort and basic blocks in function eval i.e.
cover all possible interactions between sort andeval .
in a similar spirit we can also approximate path coverage by co vering pairs triples etc.
of basic blocks cover all pairs triples and quadruples of basic blocks in function partition .
scenario seamless transition to verification.
when full verification by model checking is not possible testing can be used to a pproximate model checking.
for instance we can specify to cover all asse rtions.
cover all assertions in the source.
cover each pair of assertions with a single test case passing both of them.
we can finally use test specifications to provoke unintended p rogram behavior effectively turning a test case into a counterexa mple.
in the following examples we check the presence of an erroneous callin g sequence and the violation of a postcondition cover all basic blocks in eval without reaching label init .
ask for test cases which enter function main satisfy the precondition and violate the postcondition.
figure twenty four examples of informal test case specificatio ns study fundamental issues about test specifications such as equivalence and subsumption of specifications normal forms distribution of specifications to multiple test servers etc.
given the practical importance of a test specification language we were quite surprised that there is very little previous work on this question.
we begin by listing the challenges a simplicity and code independence.
simple coverage criteria should be expressed by simple fql specifications.
to facilitate early test goal specifications and their reuse throughout a project fql specifications should be maximally code independent for instance a specification referring to a procedure should not depend on line numbers.
b precise semantics.
fql specifications should have a simple and unambiguous semantics.
c expressive power.
fql should be based on a small number of orthogonal concepts which allow to express natural coverage criteria including among others the examples of fig.
.
d encapsulation of language specifics.
specifications in fql should be maximally agnostic to the programming language at hand.
to this end fql should provide a clear and concise binding concept with the underlying programming language.
e tool support for real world code.
fql must have a good trade off between expressive power and feasibility.
in particular common coverage specifications should lend themselves naturally to efficient test case generation algorithms.
in this paper we introduce fql which is to the best of our knowledge the first test specification language which satisfies the requirements a to e .
our previous work focused on algorithmic test case generation addressing challenge e .
arguing that test case specification and test case generation have a similar relationship as database query languages and database engines we introduced the notion of query driven test case generation and presented a sat based test case generation approach.
the preliminary specification language used in was a first step towards fql but it lacked both an exact semantics and a clean concept.
organization of this paper.
sec.
provides a gentle introduction into the concepts of fql.
sections to give a systematic description of the syntax and semantics of fql.
most of the presentation is language independent only sec.
.
discusses elements specific to c. sec.
evaluates fql from four perspectives we show that the sample specifications of fig.
can be expressed in fql.
we present an improved version of our test case generation tool .
continuing the discussion in this section we show how fql can be used in different tool chains.
we outline further research around fql.
in sec.
we discuss related work.
.
fql language concept it is natural to specify a single test case on a fixed given program by a regular expression.
for instance to obtain a test case which goes through line number of the program one can write a path pattern as a regular expression .
.
where stands for an arbitrary program command.1in writing the above path pattern we implicitly assume that the alphabet symbols are constraints that a program execution must satisfy.
this simple approach has a principal limitation it only works for a few hand written test cases on a fixed program.
let us discuss the problem on the example of basic block coverage.
basic block coverage requires a test suite where for each basic block in the program there is a test case in the test suite which covers this basic block.
it is clear that basic block coverage can be achieved manually by writing one path pattern for each basic block in the program.
the challenge is to find a specification language from which the path patterns can be automatically derived.
this language should work not only for simple criteria such as basic block coverage but on the contrary facilitate the specification of complex coverage criteria.
to understand the requirements for the specification language let us analyze the above verbal specification .
the specification requires a test suite i.e.
multiple test cases which together have to achieve coverage.
.
the specification contains a universal quantifier saying that each basic block must be covered by a test case in the test suite.
.
referring to entities such as basic blocks the specification assumes knowledge about program structure .
.
the specification has a meaning which is independent of the concrete program under test.
in fact it can be translated into a set of path patterns only after the program under test is fixed .
it will be easy for the reader to confirm that these observations hold true for all test specifications of sec.
with the only exception of observation .
certain test specifications depend on the program under test more than others.
the four observations motivate the following definition of coverage criteria cf.
definition an elementary coverage criterion is a function that maps a program ato a finite set a of path patterns.
a test suite satisfies coverage criterion on program a if each path pattern in a is matched by an element of the test suite except for those path patterns which are semantically impossible in the program e.g.
dead code .
the challenge is to find a language with a syntax expressive power and usability appropriate to the task.
our solution is to evolve regular expressions into a richer formalism fql which is able to address the issues .
.
discussed above.
in the rest of this section we will discuss the main features of fql.
fql is a natural extension of regular expressions.
to cover line we can just write cover .
.
the quotes indicate that this regular expression is a path pattern for which we request a matching program path.
we use 1similarly we can write a safety specification ag such that a model checker can compute a counterexample which serves as a test case.the operators .for union kleene star and concatenation.
note that the regular expressions can contain combinations of conditions and actions as in cover .
x .
.
which requests a test where x holds at line .
using concatenation and union but not kleene star fql combines quoted regular expressions into coverage specifications for test suites.
this is a key feature which we first illustrate on a simple example.
when we write cover .
.
.
.
this is tantamount to a list of two path patterns cover .
.
cover .
.
formally we treat the quoted regular expressions .
.
and .
.
as temporary alphabet symbols xandyand obtain allwords in the resulting regular language x ywith l x y x y cf.
fig.
a .
these words are the path patterns which the test suite has to satisfy.
as we will see more clearly below this feature equips fql with the power for universal quantification.
for program independence and generality fql has support to access natural program entities such as basic blocks files decisions etc.
for instance the expression edges basicblockentry is equivalent to a regular expression of the form in a short program whose basic blocks start in line numbers and .
the expression edges basicblockentry can only be expanded into a regular expression when the test specification is applied i.e.
when the program under test is known.
thus we can write cover .edges basicblockentry .
to achieve basic block coverage.
at runtime this amounts to cover .
.
which is in turn equivalent to the sequence cover .
.
... cover .
.
of path patterns which together specify basic block coverage.
expressions such as basicblockentry are used to denote target graphs .
target graphs contain parsing information about the program.
mathematically they are modeled as subgraphs of the program s control flow automaton a variant of control flow graphs .
fql provides a rich functionality to extract and manipulate target graphs from programs for instance the operations and for intersection and union of graphs.
this feature provides the link to the individual programming language and is the only language dependent part of fql.
for another example of target graphs consider paths func main which returns all non cyclic paths through function main for instance .
.
.
.
.
.
... in fact expressions such as which we used above are shorthands for target graph expressions such as edges line .
.
.
.
.
a .
.
.
.
b basicblockentry func foo basicblockentry func bar c basicblockentry func foo basicblockentry func bar figure automata resulting from cover clauses lines and are basic blocks entries in foo and are the lines for bar to restrict testing to a certain area of interest fql contains passing clauses i.e.
path patterns which every test case has to satisfy.
for instance by writing cover .edges basicblockentry .
passing .
x we request basic block coverage through a test suite where x never becomes negative.
fql contains syntactic sugar to simplify test specifications.
for instance stands for .
.
.
moreover is by default added before and after each path pattern.
let us sum up this introduction to fql with a comparison of three interesting test specifications coveredges basicblockentry func foo func bar coveredges basicblockentry func foo edges basicblockentry func bar coveredges basicblockentry func foo edges basicblockentry func bar in the first specification we require basic block coverage for two functions fooandbar.
in the second specification we have the same coverage criterion written in a different way.
in the third spec however we require a more complex coverage we want test cases in which all cartesian combinations of basic blocks in fooandbar occur in the test suite.
to see this just note that the first two specifications give rise to the path patterns of fig.
b while the third amounts to path patterns of fig.
c .
in this section we have explained complex fql queries by reduction to simpler intuitive fql queries on concrete programs.
to this end we made didactic simplifications e.g.
we assumed that line numbers can distinguish between basic blocks.
in the following sections we will give a formal and thorough description of fql .
.
mathematical model in this section we introduce state based models for the control flow and the program semantics.
based on these notions we formalize the notion of coverage criteria.
state based models.
syntactically we represent programs as control flow automata annotated with parsing information.
for example fig.
a shows the cfa for the code in listing .
nodes represent program counter values edges are labeled with operations and annotations drawn from finite sets opandan respectively.
an operation op opis either a skip statement assignment assumption modeling conditional statements function call or function return.
annotations include parsing information such as line numbers or file names and function names labels etc.
definition .acontrol flow automaton cfa ais a tuple a bracketle tl e i a bracketri ht where l is a finite set of program locations e l lab l is a set of edges that are labeled with pairs of operations and annotations from lab op 2an and i l is a set of initial locations.
we denote the set of cfas withcfa.we write la ea and iato refer to the set of program locations the set of edges and the set of initial locations of a cfa a respectively.
we define and as operations on cfas a bracketle tl1 e1 i1 a bracketri ht a bracketle tl2 e2 i2 a bracketri ht a bracketle tl1 l2 e1 e2 i1 i2 a bracketri ht a bracketle tl1 e1 i1 a bracketri ht a bracketle tl2 e2 i2 a bracketri ht a bracketle tl1 l2 e1 e2 i1 i2 a bracketri ht a bracketle tl1 e1 i1 a bracketri ht a bracketle tl2 e2 i2 a bracketri ht a bracketle tl e i a bracketri htwhere e e1 e2 l u u u l u e l1 l2 and i i1 l .
to describe the behavior of a program we define a transition system as follows definition .atransition system a bracketle ts r i a bracketri htconsists of a state space s a transition relation r s s and a nonempty set of initial states i s. a state insconsists of a program counter value and a description of the memory.
we denote with l t the set of paths a bracketle ts0...sm a bracketri htsuch that s iand si si r for i m. in order to relate a cfa a a bracketle tl e i a bracketri htto a corresponding transition system t a bracketle ts r i a bracketri htwe fix the following functions we consider the operation op opas a function op s 2s that takes a program state and determines its successor states.
bypc s lwe denote a function that given a program state s yields its program location pc s .
bypost e s 2swe denote a function that given a cfa edge l op an l eand a program state s returns the set s pc s l pc s l s op s .
a cfa anaturally induces a transition system ta definition .given a cfa a we define the induced transition system ta a bracketle ts r i a bracketri htwhere scontains all possible program states r s s s s e ea.s post e s and i s s pc s ia .
predicates coverage criteria.
lett a bracketle ts r i a bracketri htbe a transition system.
for a bracketle ts0s1...sm a bracketri htandi jwe write i...jto denote the subpath a bracketle tsi...sj a bracketri ht.
with a bracketle t a bracketri htwe denote the empty path.
a state predicate is a predicate on the state space s apath predicate is a predicate over the set s and a path set predicate is a predicate over the set 2s .
we write s iff a state s ssatisfies iff a path s satisfies and iff a path set s satisfies .
we call a state predicate a path predicate or a path set predicate feasible over t iff respectively there exists a reachable state s swith s a path l t with or a path set l t with .
we interpret the boolean connectives and on state path and path set predicates in the standard way.
for path predicates 1and 2 we define predicate concatenation 1 2where 1 2holds iff 0...n 1and n... 2forsome n or a bracketle t a bracketri ht 1and 2 or 1and a bracketle t a bracketri ht 2 10v a i left j right a bracketle t1!
a bracketri ht a bracketle t!
!
a bracketri ht i i a bracketle ta v a bracketri ht a bracketle t!
a v a bracketri ht skip a bracketle tj left a bracketri ht a bracketle t!
j left a bracketri ht j j a bracketle ta v a bracketri ht a bracketle t!
a v a bracketri ht skip a bracketle ti j a bracketri ht a bracketle t!
i j a bracketri ht t a a a a tt a a a a t return i a control flow automaton a202122 10v a i left j right a bracketle t1!
a bracketri ht a bracketle t!
!
a bracketri ht i i a bracketle ta v a bracketri ht a bracketle t!
a v a bracketri ht skip a bracketle tj left a bracketri ht a bracketle t!
j left a bracketri ht j j a bracketle ta v a bracketri ht a bracketle t!
a v a bracketri ht skip a bracketle ti j a bracketri ht a bracketle t!
i j a bracketri ht t a a a a tt a a a a t return i b target graph for basicblockentry 10v a i left j right a bracketle t1!
a bracketri ht a bracketle t!
!
a bracketri ht i i a bracketle ta v a bracketri ht a bracketle t!
a v a bracketri ht skip a bracketle tj left a bracketri ht a bracketle t!
j left a bracketri ht j j a bracketle ta v a bracketri ht a bracketle t!
a v a bracketri ht skip a bracketle ti j a bracketri ht a bracketle t!
i j a bracketri ht t a a a a tt a a a a t return i c target graph for conditiongraph figure control flow automaton of partition listing and target graphs 1int partition inta int left int right 2intv a i left j right t 3for while a v while j left a v if i j break t a a a a t 9t a a a a t 10return i listing example source code sort.c holds.
note that the last state of 0...nis the first state of n... .
definition .lettbe a transition system.
then a test case is a single path l t and a test suite is a finite subset l t of the paths in l t .
acoverage criterion imposes a predicate on test suites definition .acoverage criterion is a mapping from a cfa ato a path set predicate a. we say that l ta satisfies coverage criterion ontaiff aholds.
while our definition of coverage criteria is very general most coverage criteria used in practice and all criteria expressible by fql are based on sets of test goals which need to be satisfied.
typically test goals are path predicates leading to the prototypical setting accounted for in the next definition.
definition .anelementary coverage criterion is a coverage criterion defined as follows i there is a mapping a 1 ... k which maps a cfa a to a set of test goals 1 ... k where each iis a path predicate.
ii a induces the predicate asuch that aholds iff for each test goal i a which is feasible over ta contains a test case l ta with i. mc dc for example is a coverage criterion that is not elementary.
.
syntax and semantics of fql we will now describe the language fql.
semantically each fql specification boils down to an elementary coverage criterion.
the syntax of fql follows the ideas of sec.
.
technically fql consists of two languages the core of fql are elementary coverage patterns ecps i.e.
quoted regular expressions whose alphabet are nodes edges and conditions of a concrete cfa.
referring to low level cfa details ecps are not intended to be written by human engineers but rather the formal centerpiece for a precise semantics and implementation.
fql specifications are very similar to ecps but do not refer to cfa details.
instead they use target graphs such as basicblockentry or 5to refer to program elements cf.
sec.
.
for a given program an fql specification can be easily translated into an ecp by parsing the program and expanding the target graphs into regular expressions over the cfa alphabet in a manner similar to but more complicated than the didactic examples of sec.
.
.
fql elementary coverage patterns table shows the syntax of elementary coverage patterns.
the nonterminal symbols p c and represent path patterns coverage specifications and ecps respectively.
an elementary coverage patterncover cpassing pis composed of a coverage specificationcand a path pattern p. the alphabets eandldepend on the program under scrutiny lis a finite set of cfa locations and eis a finite set of cfa edges.
the symbols in sare state predicates e.g.
x .
by we denote the empty word and 0denotes the empty set.
we form more complex path patterns over the alphabet symbols using standard regular expression operations.
we denote union with concatenation with .
and kleene star with .
a coverage specification is a star free regular expression over an extended alphabet in addition to the alphabets l eands we use new symbols introduced using the quote operator each expression p where pis a path pattern introduces a single new symbol p in the alphabet of coverage specifications.
table defines the semantics of path patterns and coverage specifications as formal languages over alphabets of program counter locations state predicates program transitions and symbols newly introduced by the quote operator.
we use xin places where either p orcmay occur and denote by l x the language of a path pattern 411and a coverage specification respectively.
except for the newly introduced quote operator all equations follow standard regular expression semantics.
the case of kleene star l p is only relevant for path patterns and l p only appears as part of coverage specifications.
the expression p introduces p as a new symbol and thus l p results in the singleton set p .
for example l a b c .
ac is the set a b ac c ac .
we discuss the last line of table in the following paragraph.
interpretation of path patterns as path predicates.
given a coverage specification or path pattern x we interpret each w l x as a path predicate.
we write wiff satisfies the word wand inductively define the semantics thereof in table .
the empty set is unsatisfiable and the empty word matches the empty sequence a bracketle t a bracketri ht only.
we match individual states with program counter values land state constraints and pairs of subsequent states with transitions e. the case awamounts to predicate concatenation as defined in sec.
.
the path pattern p is satisfied by a path iff there is a word w l p that is satisfied by .
applying these definitions an ecp combines a coverage specification and a path pattern to obtain a set of path predicates as defined in the last line of table .
.
target graphs and cfa transformers target graphs enable the user to directly access natural program entities such as basic blocks line numbers decisions etc.
without referring to nodes or edges of the cfa.
formally a target graph is a fragment of a control flow automaton and typically contains those parts of the source code that are relevant for a given testing target.
definition .acfa transformer is a function t cfa cfa which on input of a cfa a a bracketle tl e i a bracketri ht computes a target graph t a bracketle tl e i a bracketri ht.
the most important cfa transformers are filter functions which extract a subset of the edges of a cfa.
definition .afilter function is a cfa transformer f cfa cfa which computes for every cfa a a bracketle tl e i a bracketri hta target graph f a bracketle tl e i a bracketri htwith l l e e and i l such that e l lab l holds.
for example consider the cfa adepicted in fig.
a the target graph basicblockentry depicted in fig.
b edges not contained in the target graph are grayed out is obtained by applying the filter function basicblockentry toa.
this target graph contains the edges necessary for basic block coverage on a. the filter function conditiongraph extracts the portions of athat are related to decisions in listing see fig.
c .
in def.
the condition i l enables a filter function to change the set of initial locations.
e.g.
basicblockentry as shown in fig.
b sets the initial locations indicated by double circles to the start locations of the edges in the target graph.
filter functions encapsulate the interface to the programming language.
they extract cfa edges based on annotations added to a cfa while parsing the source code.
table lists the filter functions currently supported in fql.
their exact definitions are specific to the c programming language hence we use according terminology.
cover cpassing p c c c c.c l e s p p p p p.p l e s p table syntax of elementary coverage patternsl x1 x2 l x1 l x2 l x1.x2 w1w2 w1 l x1 w2 l x2 l l l x x where x l e s l p l p l p p l cover cpassing p w p w l c table semantics of fql elementary coverage patterns ifffalse iff is the empty sequence a bracketle t a bracketri ht l iff has the form a bracketle ts a bracketri htandpc s l iff has the form a bracketle ts a bracketri htands e iff has the form a bracketle tss a bracketri htands post e s w iff a w with w aw and a l e sor p p iffthere is a w l p such that w table interpretation of path patterns as path predicates further cfa transformers.
a cfa transformer tis either a filter function f function composition a set theoretic operation on target graphs or predication pred t .
applied to a cfa a pred t yields a new cfa that contains for every node u la two new nodes u and u representing the evaluation of a state predicate to true i.e.
u and to false i.e.
u .
the result of applying tto a cfa ais denoted by t .
see table for the semantics of all cfa transformers except filter functions.
.
fql specifications table defines the syntax of fql specifications.
basic operations like or .
are the same as in ecps but where ecps had nodes and edges of a cfa fql specifications require the operatorsnodes t edges t andpaths t k .
here tis a cfa transformer expression and kis a positive integer.
the clause intstates that given a cfa a all filter functions in thecover clause are applied to the target graph t .
in practice this is often used as in func foo cover edges conditionedge passing edges id which is equivalent to the spec cover edges compose conditionedge func foo passing edges id .
id identity function basicblockentry one edge per basic block conditionedge one edge per atomic condition outcome decisionedge one edge per decision outcome if for while switch ?
conditiongraph all edges contributing to decisions file a all edges in file a line x all edges in source line x func f all edges in function f stmttype types all edges within statements types def t all assignments to variable t use t all right hand side uses of variable t call f all call sites of f entry f entry edge of f exit f all exit edges of f table filter functions in fql 412compose t1 t2 t1 t1 t2 t1 t2 t1 t2 t1 t2 setminus t1 t2 t1 t2 pred t a bracketle tl e i a bracketri htwhere a bracketle tl e i a bracketri ht t andl l i i and e u v l u v v v u l u e table semantics of cfa transformers intcover cpassing p c c c c.c c n s p p p p p.p p n s p n nodes t edges t paths t k t f pred t compose t t t t t t setminus t t f id basicblockentry conditionedge conditiongraph decisionedge file a line x func f stmttype types table syntax of fql given a specification and a cfa a every operator nodes t edges t andpaths t k in expands to a sum iterated of path patterns which represent the nodes edges and paths in the target graph t respectively nodes t mapsto n nodes t n edges t mapsto e edges t e paths t k mapsto p pathsk t p intuitively nodes t is the set of nodes of the target graph t obtained by applying ttoa.
the same holds for edges t andpaths k t .
in case a set nodes t edges t or paths k t is empty the corresponding operator expands to the symbol .
the semantics of a specification is obtained by replacing each occurrence of nodes edges andpaths in by the corresponding sum and applying the semantics of table .
formally we define the functions nodes edges and pathsk.
for simplicity let us assume the cfa transformer pred was not applied then nodes t lt edges t et and pathsk t p pis ak bounded path in t .
ak bounded path in t is a sequence of edges starting in it in which no target graph node occurs more than ktimes.
in case pred is applied the corresponding state predicates have to be inserted into the path patterns at the right place.
as an example consider the target graph shown in fig.
.
there nodes a is the set of path patterns l1 l2 l3 l4 l6 and the operatornodes id yields the expression l1 l2 l3 l4 l6.
here li denotes the node labeled with i. the operator edges id yields the path pattern e1 e1 e2 e2 e3 e3 where ei jdenotes the edge from node lito node lj.paths id yields the expression e1 e1 e1 2e2 e1 2e2 e1 2e2 3e3 e1 2e2 3e3 e1 3e3 e1 3e3 .1if x y x y ... 5else ... a bracketle tx a bracketri ht a bracketle t!
x a bracketri ht a bracketle t!
y a bracketri ht a bracketle ty a bracketri ht a bracketle tx y a bracketri ht a bracketle t!
x y a bracketri ht figure edge vs. path coverage syntactic construct expanded expression .
id .
k line k x x k x.
...x ktimes x k i kx i p k p k.p not t setminus id t id table syntactic sugar semantics.
an fql specification ingcover cpassing p maps a cfa ato a finite set a of path predicates.
by c we denote the coverage specification obtained by first applying the transformer gtoaand then replacing all nodes t edges t andpaths t k by n nodes t n e edges t e and p paths t p respectively.
by p we denote the path pattern obtained by replacing all occurrences of nodes t edges t and paths t k by the corresponding sums for the passing clause g is not applied .
then we define a by reducing to an ecp a l cover c passing p proposition .every fql specification satisfies definition and therefore is an elementary coverage criterion.
syntactic sugar.
for simpler use we extend fql by redundant constructions summarized in table .
further simplifications are if neither the operator nodes noredges norpaths is given we useedges as default.
by default id is prepended and appended to cover andpassing clauses.
in analogy to unix grep we can avoid this default by writing at the start or at the end of an expression.
omission of the passing clause is expanded to in t cover c passing id .
omission of the in clause is expanded to in id cover c passing p .
.
ev aluation we evaluate fql in four dimensions expessiveness and usability practical feasibility of test case generation uses of fql in the se tool chain and potential for further research.
.
expressive power and usability table shows how the test case specifications q1 of fig.
can be written in fql.
we see that even complex specifications can be written as succinct and natural fql specifications.
experiments with these specs are discussed in the next section.
we note that inside quotes we can use pattern matching formalisms more powerful than regular expressions with trivial extensions.
we can include e.g.
context free features such as bracket 413q1cover basicblockentry q2cover conditionedge q3cover conditionedge stmttype if switch for while ?
q4coverpaths func main func insert q5coverpaths func main func insert q6cover def t q7cover use t q8cover def t .
not def t .
use t q9cover basicblockentrypassing .
j not q10cover conditionedge func compare passing not call compare .
call compare func sort q11cover entry sort .
len .
len .
not exit sort .
basicblockentry q12in func eval cover conditionedge passing call eval .not exit eval .
call eval .not exit eval .
call eval q13cover call sort passing not func sort .
func sort not call unfinished .
not func sort q14cover conditionedgepassing not call eval .
call insert q15in func partition cover conditionedgepassing q16cover conditionedge decisionedge q17cover conditionedge func sort basicblockentry func eval q18cover basicblockentry basicblockentry q19cover basicblockentry basicblockentry basicblockentry q20cover basicblockentry basicblockentry basicblockentry basicblockentry q21cover stmttype assert q22cover stmttype assert stmttype assert q23cover basicblockentry func eval passing not label init q24cover entry main passing entry main .
precond .
not exit main .
!postcond .
exit main table specification examples matching.
we refrained from so in this paper to keep the presentation simple.
therefore suitable extensions of fql can express essentially all elementary coverage criteria.
note that all elementary coverage criteria are unions of suitable path patterns.
.
prototype implementation our implementation is based on query driven program testing augmented with efficient algorithms for sat enumeration .
the implementation currently supports the full range of fql except for the cfa transformer pred.
it relies on the source code of cbmc .
a bounded model checker with support for full ansi c. currently we work only with c programs with static cfas i.e.
there is limited support for function calls by function pointers and no support for longjmp and setjmp .
since we require a fully specified cfa to compute target graphs we make assumptions about behavior left undefined by the c standard.
expressiveness.
we evaluated the example specifications q1 shown in table with our tool.
since most scenarios for referring to line numbers or function names make only sense for programs which contain certain tokens we applied each specification to one of three suitable source files cf.
table .
the file list2.c contains the program of listing and sort1.c and sort2.c contain fragmentsperforming array manipulation.2for each spec we give the number of test goals goals the number of test cases tc determined by the backend and the number of infeasible test goals inf .
the experiments were done on an intel .
ghz mac os x system equipped with gb ram.
with the exception of q20 quadruple basic block coverage which took seconds all specs were processed in less than seconds.
each run of the test case generation engine required at most mb of memory.
spec source goals tc inf spec source goals tc inf q1 list2.c q13 sort1.c q2 list2.c q14 sort2.c q3 list2.c q15 list2.c q4 sort2.c q16 sort1.c q5 sort2.c q17 sort1.c q6 list2.c q18 list2.c q7 list2.c q19 list2.c q8 list2.c q20 list2.c q9 list2.c q21 sort1.c q10 sort1.c q22 sort1.c q11 sort1.c q23 sort2.c q12 sort2.c q24 sort2.c table experimental results for example specifications scalability.
to study scalability of our backend to real world embedded systems code and possibly also software systems we chose a subset of the specifications and applied them to the following set of programs we picked some tools from the unix coreutils in busybox .
studied as well in we selected kbfiltr.c from the windows ddk initially studied in and we chose an example use case4from where model checking tools were applied to the linux virtual file system layer.
in addition to these well studied examples we applied our framework on two industrial case studies.
we performed test case generation for an engine controller code generated from a matlab simulink model matlab.c .
we examined a dynamic memory manager for airborne software systems memman.c .
as an example of a complete software package we analyzed the sources of the sat solver picosat version .
bb q1 cc q2 bb2 q18 source sloc goals tc goals tc goals tc inf coreutils cat.c coreutils echo.c coreutils nohup.c coreutils seq.c coreutils tee.c kbfiltr.c pseudo vfs.c matlab.c memman.c picosat table summary of experimental results we summarize our experiments in table .
for each source we give the number of lines of code sloc .
to compare to previous work we first established basic block coverage specification q1 .
we give the number of test goals and the number of test cases that were necessary to cover these test goals.
given loop bounds of 2for source code cf.
6measured using david a. wheeler s sloccount tool.
414to we compute test suites for coverage of all feasible test goals.
in in many cases coverage of more than is achieved but the feasibility of the remaining test goals is not investigated.
furthermore we achieved condition coverage with spec q2and squared basic block coverage with spec q18 for all benchmarks.
in case of q18 many of the resulting test goals are expectedly infeasible.
we include these numbers in the column inf.
all experiments except for picosat as discussed below were performed using at most mb of memory.
each test suite was computed in less than two minutes except for q18 for kbfiltr.c which took four minutes.
as picosat has a larger code base the experiments for basic block coverage and condition coverage took up to ten minutes and required up to mb.
for squared basic block coverage the experiments took approximately .
hours and consumed .
gb of memory.
.
fql in the tool chain to demonstrate practical usefulness of fql we describe two ongoing projects with the embedded systems industry.
measurement based execution time analysis.
our initial motivation for fql and the test case generation backend was measurement based execution time analysis for embedded real time software.
together with our project partners we are developing a framework to provide early feedback about the distribution of execution times to the developer.
in this project fql enables us to efficiently compute test suites appropriate for timing analysis.
model implementation consistency checking.
in collaboration with an avionics supplier we are currently developing an automated technique to check consistency of models uml activity diagrams and their implementation c code .
we first compute a test suite at model level that e.g.
covers all edges of the model.
each model level test case then describes a path through the model.
we use this model level test case as path pattern in an fql passing clause and ask for condition coverage at implementation level.
the number of test cases computed reflects the relationship between model and implementation and leads to detailed feedback on possibly unintended discrepancies.
discussion.
our projects demonstrate the usefulness of fql s flexible test case specification to practical problems in embedded systems.
for avionics software that must conform to highest safety requirements we will however need to add support for modified condition decision coverage.
this is beyond the scope of elementary coverage criteria and requires path set predicates as test goals.
we are currently working on a proper integration into fql.
.
research questions about fql the language fql gives rise to a number of interesting questions both about the formalism and efficient evaluation.
the following list just mentions a few of them.
how to check equivalence and subsumption of specifications ?
how can we approximate a specification by a simpler one with a larger test suite ?
where is a good trade off ?
how can we rewrite a specification into a normal form for which test cases can be found more easily ?
how can we distribute specifications over multiple servers ?
how can we trace which code changes compromise the meaning of a test specification ?
how can we reuse existing test suites after code changes ?
when can we reuse existing test suites for new specifications ?
which specifications are amenable to directed testing ?
how can we combine incomplete light weight testing with fql backends for better efficiency ?
how can we build efficient predicate abstraction based tools for fql test case generation ?
how to obtain feedback about infeasibility of test goals ?
how can we succinctly describe incomplete coverage ?
how to capture difficult criteria such as mc dc ?
how can we combine fql with input output tables and executable specifications ?
how can we apply fql to high level models such as uml ?
all these questions can be addressed with the help of fql.
.
related work prior to our work beyer et al.
present a test case generation engine that supports target predicate coverage i.e.
every program location has to be visited by some test case that enters the location with predicate ptrue.
in fql this coverage criterion is given by the specification cover p .nodes id .
for test case generation beyer et al.
use an extended version of the c model checker blast.
like our previous work their work is also mainly addressed at challenge e .
note that blast uses the database analogy in a different way than we do.
blast uses a query language to process and access reachability information from the software model checker.
however the blast query language is not well suited for specifying complex coverage criteria i specifications have to be stated in a combination of two formalisms one for an observer automaton and the other for a relational query.
ii the blast language misses concise primitives for coverage criteria for instance path coverage can only be achieved by creating an individual observer automaton for each program path.
iii the encoding of fql s passing clause into a blast observer automaton is in general non trivial for the working programmer.
random testing directed testing and symbolic execution based approaches aim at achieving a high code coverage with respect to standard criteria like basic block or path coverage .
these approaches are nottailored towards flexible and customized coverage criteria and are therefore orthogonal to our work.
thus these approaches too are primarily addressing challenge e .
it is an interesting question for future research which fql specifications can be solved efficiently by directed testing.
most existing formalisms for test specifications focus on the description of test data e.g.
ttcn and uml tp but none of them allows to describe structural coverage criteria.
friske et al.
have presented coverage specifications using ocl constraints.
although ocl provides the necessary operations to speak about uml models it may yield hard to read expressions for complex coverage criteria.
at the time of publication no tool support for the framework was reported.
hessel et al.
present a specification language for coverage criteria at model level that uses parameterized observer automata.
test suites for specified coverage criteria can be automatically generated using the tool u ppaal cover .
briones et al.
investigate coverage measures considering the semantics of a specification and weighted fault models to arrive at minimal test suites.
415structural coverage criteria e.g.
basic block coverage condition coverage and path coverage are well studied cf.
albeit with different names and a notable lack of precise definitions.
attempts of formalizations using temporal logics automata and graph based approaches or using the z notation do not consider the specifics of the underlying programming language.
predicate complete coverage is an interesting new coverage criterion that subsumes all of the above coverage criteria except for path coverage.
we can express predicate complete coverage by the fql specification cover edges pred id 1 ... k for a given set of predicates 1 ... k. .
conclusion in the introduction of this paper we stated five challenges for the design of a test specification language a d simplicity code independence and encapsulation of language specifics.
regular languages as base formalism make fql easy to read table demonstrates that even complex criteria have simple specifications.
our concept of target graphs ensures code independence and the encapsulation of language specifics.
b precise semantics.
we have given a formal definition of coverage criteria in sec.
and provided a precise semantics of our language fql in sec.
.
every fql specification yields an elementary coverage criterion.
c expressive power.
we have demonstrated that all informal specifications of fig.
can be expressed in fql.
as argued in sec.
.
essentially all elementary coverage criteria can be expressed by fql or suitable extensions.
e tool suppport for real world code.
in sec.
.
we presented experimental results for our test case generation backend.
amongst others we generated test suites for device drivers a sat solver and embedded systems code.
we consider fql an open framework to be extended.
on the language level we are currently working on support for path set predicates which will enable us to specify criteria such as mc dc.
.