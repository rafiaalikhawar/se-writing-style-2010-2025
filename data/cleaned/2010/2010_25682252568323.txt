automated goal operationalisation based on interpolation and sat solving renzo degiovanni dalal alrajehynazareno aguirre sebastian uchitelyz departamento de computaci n universidad nacional de r o cuarto and conicet argentina ydepartment of computing imperial college london uk zdepartamento de computaci n universidad de buenos aires and conicet argentina rdegiovanni naguirre dc.exa.unrc.edu.ar dalal.alrajeh04 s.uchitel imperial.ac.uk abstract goal oriented methods have been successfully employed for eliciting and elaborating software requirements.
when goals are assigned to an agent they have to be operationalised the agent s operations have to be re ned by equipping them with appropriate enabling and triggering conditions so that the goals are ful lled.
goal operationalisation generally demands a signi cant e ort of the engineer.
although there exist approaches that tackle this problem they are either informal or at most semi automated requiring the engineer to assist in the process.
in this paper we present an approach for goal operationalisation that automatically computes required preconditions and required triggering conditions for operations so that the resulting operations establish the goals.
the process is iterative is able to deal with safety goals and particular kinds of liveness goals and is based on the use of interpolation and sat solving.
categories and subject descriptors d2.
requirements speci cations general terms design veri cation keywords requirements engineering craig interpolation sat solving .
introduction goal oriented methods e.g.
kaos and i have been developed and successfully applied to the problem of eliciting and elaborating software requirements.
such methods typically demand the re nement of high level goals that this work was partially supported by anpcyt pict and ubacyt w0813 erc stg pbm fimbse and by the meals project eu fp7 meals .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.require agent cooperation to be achieved into goals that can be realised by individual agents .
a goal assigned to an agent must be operationalised i.e.
mapped into operations provided and executed by agents .
the problem of goal operationalisation has been studied by various researchers.
in the work of letier and van lamsweerde a pattern based technique for deriving operational requirements from system goals is proposed.
this technique provides some templates to derive from goals expressed in linear time temporal logic ltl with certain syntactic restrictions a set of required pre triggering conditions for operations such that these entail the goals.
more recently alrajeh et al.
proposed an approach for semi automatically learning operational requirements from a set of goals .
this approach uses model checking for verifying that a given set of operational requirements satis es the goals.
if veri cation fails the user examines the counterexample generated by the model checker identi es a wrongly executed operation and provides positive scenarios illustrating good occurrences of this operation.
these scenarios are then used by an inductive learning engine to automatically compute new required pre triggering conditions for the selected operation.
the obtained operational requirements ensure that the counterexample is avoided and the behaviour described by the positive scenarios is preserved.
the approach of alrajeh et al.
is semi automated since it requires engineers intervention for providing positive scenarios.
in this work we present an approach for goal operationalisation that automatically computes required pre triggering conditions for operations in order to ful l a set of goals.
moreover this approach does not depend on user provided scenarios and their characteristics e.g.
richness and correctness as is the case with .
the re nement process is based on the use of interpolation and sat solving.
as previous approaches our technique applies to safety and time progress goals.
moreover we are also able to deal with a wide range of liveness goals namely those captured by the reactivity pattern .
our approach starts with a model checking phase for verifying whether the operational requirements speci cation satis es the goals or not.
if the veri cation is successful then the operational speci cation needs no re nement.
if the model checker produces a counterexample an interpolant from the counterexample and the violated goal is computed which is exploited to strengthen or weaken required preconditions and required triggering conditions respectively to remove the counterexample.
the approach performs various logical checks for ensuring that the re ned required conditions are consistentpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
in the sense of with the current operational speci cation.
these checks are performed using sat solving.
an interpolant for formulas aandbwhose conjunction is inconsistent is a formula that is implied by the rst is inconsistent with the second and is expressed in the language common to aandb.
interpolation has been widely used in abstraction based veri cation most notably for automatically re ning abstract models of systems using corresponding concrete models and abstract spurious counterexamples violations of analysed properties .
in this work we propose to use interpolation for a di erent but related purpose.
essentially an interpolant for a formula capturing a trace and a violated goal is a property of the trace expressed in the language that the trace and the goal have in common.
this interpolant can be seen as an explanation of why the trace violates the goal.
as we will show interpolants can be used to re ne required conditions in the process of goal operationalisation.
the remainder of this article is organised as follows section introduces preliminary concepts necessary in the paper.
section presents a running example used to present our approach.
section describes our approach in detail for the operationalisation of safety and time progress goals.
section extends the technique to deal with liveness goals.
section evaluates the approach and compares with a closely related one on some case studies.
finally we discuss related work in section and present our conclusions in section .
.
background .
labelled transition systems fltl and model checking labelled transition systems lts are typically used to model the behaviour of interacting components .
formally an lts pis a quadruplehq a q 0i whereqis a nite set of states ais the alphabet ofp q a f g q is a transition relation and q02qis the initial state.
the semantics of an lts pcan be de ned in terms of its executions i.e.
the set of event sequences that pcan perform starting in the initial state and following p s transitions.
fluent linear time temporal logic fltl is a variant of ltl well suited for describing properties of event based discrete systems e.g.
ltss .
fltl extends ltl by incorporating the possibility of describing abstract states called uents characterised by events of the system.
formally fl hifl tfl bide nes a uent fl whereifl tfl aandifl tfl andb2ftrue falseg indicates the initial value of fl.
when any event in ifloccurs the uent starts to be true and it becomes false again when any event in tfloccurs.
if the term bis omitted then flis initially false.
a fltl formula is an ltl formula where propositions are uents.
given a set of uents a well formed fltl formula is de ned inductively using the standard boolean operators and the temporal operators next andu strong until in the following way i everyfl2 is a formula and ii if and are formulas then so are u .
we consider the usual de nition for the operators always eventually andw weak until in terms of next and strong until and boolean connectives.
model checking provides an automated method for determining whether or not a property described by a typically temporal formula holds in the system s state graph.in our case we will use labelled transition system analyser ltsa a veri cation tool for concurrent systems models.
a system in ltsa is modelled as a set of interacting nite state machines described by fsp processes .
ltsa directly supports fltl veri cation by model checking.
.
interpolation given two formulas aandb such that a bis inconsistent an interpolant foraandbis a formula iwith the following properties i aimpliesi ii i bis unsatisable and iii iis inl a l b i.e.
the language that aandbhave in common.
for instance consider a p q andb q r. then an interpolant for aandbisi q. in this work we use the mathsat constraint solver.
this tool is behind various tasks such as nding operations that lead to certain states querying about operation enabledness etc.
most notably mathsat is able to compute interpolants which is a crucial mechanism underlying our approach.
although mathsat is an smt solver we do not make use for any of our case studies of the theories mathsat is equipped with.
that is we are using the tool only as a sat solver with interpolation computation capabilities .
.
operational requirements for goal models goals are properties that the system should achieve.
a goal model is a decomposition of goals through and or re nement links which essentially capture how a goal can be achieved in terms of simpler ones.
goal re nement the decomposition of goals in subgoals ends when each subgoal at the bottom of the decomposition can be assigned to a single agent.
agents perform operations whose combined behaviours must ful l the goals.
operations characterise state transitions in the system.
each operation is speci ed by its signature input and output variables the domain pre and post conditions dompre and dompost respectively and therequired conditions.
there are three di erent types of required conditions.
a required precondition reqpre captures permission under this condition the operation may be executed.
a triggering condition reqtrig captures obligation under this condition the operation must be executed.
finally the required postcondition reqpost captures additional e ects of executing the operation.
a goal is correctly operationalised by a set of operations operation model if satisfying all required conditions in the set guarantees the satisfaction of the goal .
it is possible to systematically obtain a behavioural model from an operation model .
requirements can be expressed using fltl by combining the always and next operators to capture required conditions and introducing further fltl constraints to cope with the synchronous semantics of kaos.
then an lts that represents the system behaviour can be automatically constructed.
using this characterisation of the operation model a model checker e.g.
ltsa can be employed to check if the system satises the goals if these are expressed as fltl assertions.
let us brie y describe an operation model for a mine pump controller introduced in .
we use this model as a running example throughout the paper and in particular in this section as a motivating example.
the mine pump system controls an alarm and a water pump in a mine depending on di erent levels of methane in the environment 130and water in the mine.
the system monitors three environmental variables methane indicating whether methane is present in the environment and lowwater and highwater indicating the level of water in the mine is low or high respectively and two software variables that are controlled by the system pumpon and alarm indicating whether the water pump and the alarm are on or not respectively.
the above mentioned monitored variables are modi ed by environment events belowlow abovelow abovehigh and belowhigh modify the water level in the mine while signalmethane andsignalnomethane change accordingly the presence of methane in the environment.
the system may actively control the state of the pump and the alarm with the events switchpumpon switchpumpoff raisealarm and stopalarm .
initially the operations are enabled as long as the domain precondition is true i.e.
the required precondition is true and are not obliged to be executed in any state i.e.
the required triggering condition is false .
operation switchpumpon operation switchpumpoff dompre pumpon dompre pumpon dompost pumpon dompost pumpon operation switchalarmon operation switchalarmoff dompre alarm dompre alarm dompost alarm dompost alarm consider a goal pumpoffwhenmethane stating that when methane is present in the environment the pump must be switched o .
in order to check whether our operation model guarantees that this goal is achieved the approach presented in may be followed.
the speci cation is mapped into an event based transition system and a model checker is used to check that the goals are satis ed.
we express goals as fltl formulas since we will use ltsa .
the above goal is expressed in fltl as follows tick!
methane!
tickw tick pumpon the tick event is a means for capturing kaos synchronous interpretation of an operation model under an asynchronous interpretation which is used in ltsa .
the above formula states that if methane is true when tick occurs then before the next tick the pump must be switched o .
having the operation model captured as an lts and goals as fltl formulas it is possible to verify whether the speci cation meets the goals or not.
in our case the goals can be violated and the ltsa model checker produces the following counterexample trace to property violation in pumpoffwhenmethane tick s0 signalmethane methane tick methane s1 switchpumpon methane pumpon tick methane pumpon s2 by examining the above counterexample one can realise that state s2does not satisfy the goal pumpoffwhenmethane .
the problem has to do with the operation switchpumpon being able to occur when there is methane in the environment notice that the required precondition allows for this .
.
using interpolation for refinement the above counterexample can be expressed as a formula a where system states are represented by variables one per uent in the speci cation and these variables are replicated times for the di erent states of the trace i.e.
s0 s1ands2 relating each one with the next according to what the corresponding event indicates.
suppose that the goal can be expressed as a state property b e.g.
this is straightforward if the property is a safety property referring to the last state of the trace.
since the trace is a violation of b clearly a bis unsatis able.
we can then try and use interpolation to see what the interpolant provides.
in this case the interpolant is methane pumpon .
this interpolant indicates that the problem is that in the last state there is methane in the environment and the pump is on which causes a violation in the goal.
let us start going back from the state previous to the last tick trying to nd the rst place where the violation might be avoided.
we can compute the weakest precondition wp of the interpolant with respect to the last action i.e.
switchpumpon obtaining wp switchpumpon methane pumpon methane .
notice that this last operation has the ability to change the truth value of the interpolant.
thus by preventing its execution we can get rid of the previous counterexample.
we have to check however whether this action is obliged or not to be taken when methane is present.
this can be checked using some decision procedure e.g.
sat solving to decide the formula methane reqtrig switchpumpon .
if it is the case then the action cannot be prevented and we have to continue searching backwards in the counterexample for another way of removing the counterexample.
if it is not the case we can get rid of the counterexample by adding methane toswitchpumpon s required precondition.
.
refining operational requirements let us describe our approach for re ning operational requirements in more detail.
for the sake of simplicity we assume that goals are safety properties .
later on we extend the approach to deal with time progress tp and reactivity properties .
given a set g fg1 g ngof goals and an operational requirements speci cation spec that may not satisfyg we propose an iterative approach that re nes spec by constructing new required pre triggering conditions for operations such that the resulting re ned speci cation satis esg.
this approach can only re ne spec by weakening and strengthening required preconditions and required triggering conditions of spec s operations respectively.
the approach consists of two phases that are depicted in fig.
.
the model checking phase is concerned with verifying whether spec satis es the goals gor not.
if the veri cation is successful then the requirements speci cation needs no further re nement.
if on the other hand the goals are not satis ed by spec then the model checker detects a violation to at least one of the goals gi and produces a counterexample as a witness of the violation.
the re nement phase automatically re nes the operational requirements so as to prevent the detected violation from occurring.
to achieve this the approach uses interpolation and starts computing an interpolant from the counterexample trace and the violated goal gi.
this interpolant is exploited using weakest precondition computations to identify operations whose guarding conditions may be altered to get rid of the obtained counterexample.
more precisely the obtained interpolant with the aid of weakest precondition produces the formulas to be used to strengthen or weaken required pre triggering conditions respectively to remove counterexamples.131re nementmodel checking g specspec j greturnspec interpolationrequirements derivationspec gi yes no counterexample ir fail no re nement found figure overview of the iterative approach.
the re ned speci cation that incorporates new more precise required conditions for some operations removes from its behaviours the violation found before.
the process is repeated until no violation is detected obtaining a valid operationalisation for g or until we reach a point in which a violation cannot be eliminated meaning that the found violation cannot be removed by re ning required conditions of the current operational requirements speci cation.
.
model checking phase the ltsa model checker has been used for analysing operational requirements speci cations against goal models expressed in fltl .
the state description of the system is given with uent de nitions cf.
section .
we follow the approach presented in for capturing kaos operation models in ltsa which makes use of a tick event to explicitly represent the start and end of time intervals in asynchronous fltl.
as an example consider the following goal for a model in which ticks are incorporated assert pumponwhenhighwaterandnomethane tick!
highwater methane !
tickw tick pumpon this formula expresses that if at some time point the level of water is high and there is no methane then the pump must be switched on at the next time point.
we can use ltsa for checking if the given mine pump speci cation satis es the goals.
initially we consider the weakest required precondition true and the strongest required triggering condition false for every operation.
ltsa returns the following counterexample for the goal pumponwhenhighwaterandnomethane trace to property violation in pumponwhenhighwaterandnomethane tick s0 abovelow tick s1 abovehigh tick highwater s2 tick highwater s3 because of the way the property is expressed in relation to the tick event the important states are those immediately following tick events.
this counterexample corresponds to a case in which s2 starts with the water pressure being high no methane in the environment and the pump o and by the next time point the situation has not changed and the pump remains o .
.
refinement phase the counterexamples generated by the model checker are used to automatically and iteratively compute re nementsduring the goal operationalisation process which are guaranteed to remove the detected counterexamples.
suppose we obtain a counterexample trace t violating a particular goal gi.
if we build a formula ftcapturing trace t and a formula fgicapturing the fact that giholds at the last state clearly ft fgiis unsatis able.
we can then produce an interpolant from these formulas i.e.
a statement i in the intersection of the languages of the trace and the goal such thatft iandi fgiis unsatis able.
intuitively the interpolant irepresents a weaker counterexample than t a condition reachable from the initial state which leads to the violation of the goal.
so as long as we do not get rid of the property i we will not be able to stop violating the goalgi.
however solely by removing i we do not guarantee the satisfaction of gi but not removing it guarantees its violation.
notice that calculating the interpolant iis in some sense a form of generalisation.
a counterexample may be removed either by prohibiting the occurrence of an operation from certain states i.e.
strengthening the operation s required precondition or by forcing an operation to occur in certain states i.e.
weakening its required triggering condition .
the approach is concerned with automatically detecting which of the above cases is necessary and using the interpolant to produce a change in the corresponding condition.
in the process of re ning required conditions of an operation model using interpolants weakest preconditions play an important role.
.
.
strengthening required preconditions by processing the counterexample trace backwards from the last tick we can compute the weakest precondition wp of the interpolant with respect to the last operation trying to nd the rst place where the violation might be avoided.
letibe the interpolant and t a1 a2 akthe counterexample trace.
we can have two situations with respect towp ak i i0 the weakest precondition of the last operation and the interpolant.
if i0 i then the interpolant does not hold before executing ak.
therefore by forbidding akto occur when i0holds by adding i0to the required precondition of ak we get rid of this counterexample.
this can be done as long as it does not contradict ak s required triggering conditions i.e.
if the operation is not obliged to be executed when i0holds .
ifi0 i then by preventing akfrom occurring we do not stop violating the goal since i still holds.
in this case as well as when adding i0to the required precondition would contradict other conditions of ak we have to continue searching backwards in the trace to try to nd an operation whose occurrence causes the satisfaction of the interpolant and which can be removed from the trace.
the above modi cation to the required precondition ofakdoes not guarantee that gicannot be violated it only prevents its violation through akwheni0holds.
as an example of required precondition strengthening consider the following counterexample violating pumpoffwhenlowwater trace to property violation in pumpoffwhenlowwater tick lowwater s0 switchpumpon lowwater pumpon tick lowwater pumpon s1 in this case switchpumpon is the only non tick operation executed whose current required precondition and required triggering condition are true and false respectively.
the interpolant in this case is lowwater pumpon .
going backwards from the last tick we compute the weakest precon 132dition of this interpolant with respect to the last non tick operation switchpumpon obtaining lowwater .
notice that lowwater lowwater pumpon .
then it is possible to falsify the interpolant by preventing switchpumpon from occurring when lowwater .
this is achieved simply by adding lowwater to the required precondition of switchpumpon as long as this does not contradict the operation s required triggering condition.
we then modify the required precondition of switchpumpon which now becomes lowwater .
in the process just described we have to perform various logical checks namely checking whether a weakest precondition implies or not an interpolant and if a new conjunct of a required precondition does not contradict a required triggering condition.
we perform these checks using sat solving.
in the particular case of checking whether a new identi ed conjunct for a required precondition contradicts or not a required triggering condition we consider the formula reqtrig.condition dompre.condition reqpre.condition which must always hold it is a meta rule of the kaos language .
notice that an operation is able to execute only when its domain precondition holds.
then if by modifying a required precondition adding a new conjunct we violate this property we conclude that the conjunct is contradictory with the current required triggering condition or the domain precondition.
.
.
weakening required triggering conditions in the above described situations a counterexample is removed by preventing an operation that appears in the trace from occurring.
in other situations the solution to remove the counterexample cannot be given in terms of preventing an operation from occurring but instead in terms of forcing an operation that did not occur to occur when it has to i.e.
by weakening the operations required triggering condition.
lett a1 ai tick aj anbe the counterexample trace andithe interpolant computed for this counterexample.
suppose that we cannot get rid of this counterexample by strengthening some operation in aj an.
then as each operation in faj a ngcannot be prevented from occurring we will try to remove the counterexample by forcing an operation to occur.
notice that the operation to be triggered say at must meet the following two conditions atshould be able to be executed when interpolant iholds i dompre at reqpre at at s execution must falsify the interpolant i i dompost at i we evaluate every controlled operationatnot occurring in aj an checking whether it meets both of the above conditions or not.
if we nd such an operation at we re ne its required triggering condition as follows reqtrig at reqtrigpre at i where reqtrigpre at isat s current required triggering condition.
notice that adding the disjunct itoat s required triggering condition does not violate the kaos meta rule sinceatsatis es condition .
if no operation satis es conditions and we proceed to look deeper in the counterexample trace t going backwards fromai and using i0 wp aj an i instead of i.consider for instance the counterexample to the goal pumponwhenhighwaterandnomethane shown in section .
.
this time methane highwater pumpon is the interpolant computed.
notice that in this case no operation is executed between the last two tick events.
we have then to check if there exists an operation that satis es conditions and .
operation switchpumpon is executable when methane highwater pumpon and it falsi es this interpolant.
indeed notice that considering that lowwater andfalse areswitchpumpon s current required precondition and required triggering condition respectively the following formulas corresponding to conditions and hold methane highwater pumpon pumpon lowwater methane highwater pumpon pumpon methane methane highwater highwater methane highwater pumpon then switchpumpon s required triggering condition is rened as follows reqtrig switchpumpon methane highwater pumpon as for the case of strengthening required preconditions weakening required triggering conditions also involves logical checks.
we perform these logical checks using sat solving.
.
iterative refinement the two phases described above correspond to a single iteration of the re nement approach.
these phases are iteratively applied until no further violations are detected in the model checking phase i.e.
until a speci cation that satis es the goals is reached or until we reach a point from which by solely re ning required preconditions and required triggering conditions the goals cannot be achieved.
letoandgbe the initial operational speci cation and a set of goals respectively consistent with respect to a set of uentsd.
let us now discuss correctness incompleteness and termination of the approach.
correctness and incompleteness.
when the approach nishes its outcome is spec o req wherereq is the set of required pre triggering conditions obtained.
req is guaranteed to be a consistent extension to othat correctly operationalises the goals in g. this is formalised as follows o req g6j dfalseo reqj dg due to space restrictions the proof of this claim is not reported here.
the justi cation has to do with each re nement in the process being guaranteed to be sound thanks to the sat checks we perform.
for instance in the case of strengthening a required precondition the validity of condition ensures that the new required precondition does not contradict the current required triggering condition.
in addition conditions and in the case of weakening a required triggering condition ensure that the kaos metarule is not violated.
however the proposed approach does not satisfy completeness.
that is if there exists a re nement modi cations to the required conditions that can satisfy the set of goals then the approach might fail in the process of nding that re nement.
the main reason is related to the the fact that goals can be competing i.e.
trying to ful l one goal may prevent us from later on ful lling another goal.
then by133removing a counterexample the approach can remove edges from the system s behaviour that later could be required to be added to remove another counterexample notice that we cannot add edges since postconditions are not modi ed nor new states are added since the de nition of variables what de nes the state space is not altered .
termination.
as we argued during the presentation of the re nement phase a re nement step removes the counterexample from which the re nement was constructed in the sense that the same execution cannot be obtained.
however there might be other traces violating the same goal.
thus termination is not straightforwardly guaranteed.
let us argue about it for the case of safety goals.
the model checking phase constructs a labelled transition system corresponding essentially to formula o g. if this formula has satisfying traces these are counterexamples.
first notice that the labelled transition system o g is nite it has a nite number of states and of course a nite number of edges.
we have to demonstrate that each re nement of required conditions removes at least one transition since there exists the risks of adding redundant conjuncts disjuncts which would not remove any edge.
we have explained that when a required precondition is added it is because an operation ahas been identi ed which is executable in a pre state satisfying i0 leading to a poststate in which a formula iholds the interpolant .
moreover this action aand condition i0come from a counterexample indicating that i0is a reachable condition where acan be executed.
then when we add i0to the required precondition ofawe remove this particular transition.
by weakening required triggering conditions we also remove edges.
when a required triggering condition is added it is because an operation ahas been identi ed which is executable in a state satisfying i the interpolant and whose execution falsi es the interpolant.
notice then that by weakening the triggering condition for a we remove transitions corresponding to tick.
indeed while tick was executable in the state satisfying i it is no longer executable in that same state due to the obligation of executing ainstead.
thus again the re nement produces an edge removal.
since the number of edges corresponding to o gis nite and we alter this transition system only by deleting edges it is guaranteed that our re nement process terminates when it deals with safety goals.
.
dealing with liveness .
time progress property in discrete time systems a common desired property is the progress of time usually speci ed as 23tick.
this property is called time progress tp and is a particular kind of progress property.
in this section we show how the approach can be extended to operationalise this particular progress property.
in order to detect progress violations we take into account three assumptions i kaos semantic preservation all initiating and terminating uent events can occur only once between ticks ii maximum progress mp assumption a common assumption in reactive systems that gives priority to system events over all other events including ticks and iii safety guaranteed we do not want to interfere in the satisfaction of the safety goals to operationalise the times0 sl ske0 ek 1ek figure counterexample for reactivity properties.
progress property.
so the checking is performed over the system that represents the composition of all domain required conditions and the safety goals.
time progress violations are traces in which at some point no tick event can be executed.
then provided that we have a nite number of events and due to assumption i which prohibits the repetition of events between ticks these tp violations will be deadlocks.
basically the main reason leading to these deadlocks is the way used for specifying the properties i.e.
the goals should be satis ed in the states in which tick occurs.
then the non progress of tick is due to the fact that its execution will violate a goal contradicting the assumption iii .
so our approach to remove progress violations consists of extending the obtained counterexample trace with a tick event at the end and proceeding to compute an interpolant for the extended counterexample and the safety goals that will not hold in the last state due to tick is now being executed .
intuitively this interpolant explains the reasons why tick does not progress and gives us a reachable property of the system that should be removed in order to contribute with the the satisfaction of the safety goals and the time progress property.
to remove this counterexample we follow the technique just presented in section .
.
reactivity properties liveness properties have been used for reactive systems extensively e.g.
in the work of manna and pnueli .
in the context of goal oriented methods liveness properties are typically restricted to bounded liveness .
for instance letier argues in that responsiveness properties for systems trigger!3response where response is controlled by the software to be and trigger is monitored by the system to be should be bounded since otherwise agents may postpone their duties inde nitely without a nite observable violation.
however it is sometimes convenient for these kinds of properties to abstract away the bound because it is unknown or because the bound if large may make the system state space explode as the time units must be explicitly counted in the model .
when properties are further away from the machine world interface or encompass many interactions between the world and the machine think of chained responsiveness patterns properties such as 23as!23g allow abstracting away from the bounded behaviour that the system will have to achieve the goal.
it is then in our opinion worthwhile to deal with liveness in goal operationalisation.
our approach considers liveness properties that match the reactivity pattern 23as!
23g where asandgare non temporal uent expressions.
this pattern is general enough to embrace many liveness properties .
moreover it gives us information about the shape of the counterexample which gives us the opportunity to use interpolation see fig.
.
liveness properties corresponding to the reactivity pattern have two parts the antecedent or assumptions as 134and the consequent or goals g .
a violation of a property of this kind consists of a pre x nite part leading to a loop in which the antecedent is satis ed but not the consequent.
that is at least one state sl skin the loop satis es the assumptions as but no state satis es the goal g. in order to compute an interpolant for this counterexample we encode the reactivity goal in the following propositional formula p k i lasi k j lgj where the expression fimeans that fholds insi.
letft be the formula that characterises the counterexample trace.
clearly ft pis unsatis able.
then we can calculate an interpolant ifor these formulas.
this interpolant is a weaker representation of the loop part that explains what is wrong in the loop.
to remove this counterexample we search for an operation atthat can be executed at some point in the loop such that its execution reaches a states that does not satisfy the interpolant i.e.
it breaks the loop si dompre at reqpre at si dompost at i if we nd such an operation that satis es both and then we re ne at s triggering condition with the conjunction of its required precondition and the negation of the goal reqtrig at reqtrigpre at reqpre at g notice that we do not re ne a new triggering condition based on the interpolant.
worse we may produce triggering conditions that are weaker than needed.
still we can guarantee that the approach is correct and consistent with respect to the operations s preconditions including their previous renements .
so the overall re nement process would rst remove time progress violations second operationalise safety goals and nally deal with liveness goals.
.
demonstrating examples in this section we report the experimental results of applying our approach to two models namely the mine pump controller and the engineered safety feature actuation system esfas .
for the case of safety goals and the time progress property our approach is compared with the framework based on inductive logic programming ilp introduced in for evaluation and validation purposes.
one of the authors provided the positive scenarios needed for ilp based framework.
these were produced manually following the guidelines provided in .
this human intervention however was not required in our proposed approach since it is fully automated.
on the other hand previous approaches to goal operationalisation do not deal with liveness goals so we do not have previous results to compare with to validate the technique.
we argue about this problem later on in this section.
each model is accompanied by an informal description of the system to be a partial operational requirements speci cation and a set of goals speci ed in fltl.
the experiments can be reproduced by downloading and following the instructions therein.
.
mine pump controller this rst model was used as the running example in this article refer to section for details .
in addition to the already speci ed goals sections and we consider additional objectives that should be achieved by the system assert pumpoffwhenlowwater tick!
lowwater!
tickw tick pumpon assert alarmwhenmethane tick!
methane!
tickw tick alarm we have already discussed earlier in the article in the form of examples various re nements performed to the mine pump s operational model.
let us see now how we remove time progress violations.
by performing a tp progress check on the mine pump system considering the needed assumptions ltsa produces the following counterexample.
tp violation.
trace to deadlock tick switchpumpon raisealarm abovelow signalmethane extending the counterexample with a tick event at the end the interpolant computed is pumpon lowwater .
it exhibits a similar violation to the goal pumpoffwhenlowwater shown in subsection .
where we get rid of this counterexample prohibiting the execution of switchpumpon when lowwater re nement t1 .
we follow the approach put forward in which proposes removing rst time progress violations and then safety violations.
we now present a summary of the iterations performed by our re nement process in which each iteration indicates the required condition identi ed to be added to the operational speci cation.
required preconditions t1 t4 remove time progress violations and the required triggering conditions t5 t8 guarantee the satisfaction of the safety goals.
reqpre switchpumpon lowwater t1 reqpre stopalarm methane t2 reqpre switchpumpon methane t3 reqpre switchpumpoff methane highwater t4 reqtrig raisealarm alarm methane t5 reqtrig switchpumpon pumpon methane highwater t6 reqtrig switchpumpoff pumpon lowwater t7 reqtrig switchpumpoff pumpon methane t8 when compared with the requirements learned by the approach presented in for this same model we observe that both approaches iterate exactly the same number of times.
both approaches produce the same required conditions except for the required triggering condition produced in the sixth iteration.
the ilp based framework learns a weaker triggering condition for switchpumpon namely highwater .
due to this overgeneralisation problem of ilp the learned condition leads to the following deadlock in the system trace to deadlock tick s0 abovelow tick s1 abovehigh signalmethane tick s2 belowhigh signalnomethane135the deadlock is produced because in the state s2 both highwater andmethane are true.
then the required precondition from t3 indicates that switchpumpon cannot occur when methane but the learned triggering condition obliges switchpumpon to occur when highwater .
in our case the required triggering condition re ned in t6 is stronger requiring methane to be false when the water level is above high.
on the other hand to remove the deadlock the ilpbased framework is forced to backtrack to previous iterations and requires the engineer to provide further scenarios or manually produce the re nement.
with respect to running times it is worth mentioning that for this model our approach is signi cantly more efcient.
while the ilp based framework requires aprox.
seconds per iteration our approach takes less than sec.
per iteration.
.
esfas the engineered safety feature actuation system esfas was originally introduced by courtois and parnas in .
later on letier reported a kaos speci cation of this system in .
the esfas system of a nuclear power plant prevents or mitigates damage to the core and coolant system of the plant on the occurrence of a fault such as a loss of coolant.
esfas monitors the water pressure and a couple of switches for blocking and resetting and it controls a single boolean variable indicating whether the safety injection system is on or o with the events sendsignal and stopsignal .
basically the system must start safety injection when the pressure becomes too low.
in addition the system can be disengaged via the switches indicating that its actions are overridden overridesignal enablesignal .
the goals that esfas has to satisfy are formalised in fltl as follows assert safetyinjectionwhenlowwaterpressureandnotoverridden tick!
pressurebelowlow overridden !
tickw tick safetyinjection assert sienabledwhenpressureabovepermitormanualreset tick!
occurs reset pressureabovepermit !
tickw tick overridden assert sioverriddenwhenblockswonandpressurelessthanpermit tick!
occurs block pressureabovepermit !
tickw tick overridden intuitively the rst goal indicates that the safety injection signal should be on when the water pressure is below low and the safety injection is not overridden this is the main objective of the esfas .
the second goal expresses that the safety injection should become enabled when the water pressure raises above permit or when the reset button is pushed.
and the third goal establishes that the safety injection should become overridden when the block switch is set on and the water pressure is lower than permit .
the following uent de nitions are considered for the esfas system fluent overridden overridesignal enablesignal true fluent safetyinjection sendsignal stopsignal fluent pressurebelowlow lowerpressurebelowlow raisepressureabovelow true fluent pressureabovepermit raisepressureabovepermit lowerpressurebelowpermit fluent occurs block block tock fluent occurs reset reset tock event tock is executed immediately after tick.
this auxiliary event is introduced as a terminating action for the operators press button actions the actions corresponding tothe system operator pressing the reset and block buttons .
we assume true andfalse to be the initial required preconditions and the required triggering conditions for the operations respectively.
in addition we consider the next domain preconditions for the controlled operations and two environmental assumptions to indicate that the operator cannot press the reset and block buttons at the same time dompre overridesignal overridden dompre enablesignal overridden dompre sendsignal safetyinjection dompre stopsignal safetyinjection assumption tick occurs block!
occurs reset assumption tick occurs reset!
occurs block the process checks the validity of the tp property and renes conditions to remove the violations.
reqpre stopsignal overridden pressurebelowlow r1 reqpre1 overridesignal occurs reset r2 reqpre2 overridesignal pressureabovepermit r3 reqpre enablesignal r4 pressureabovepermit occurs block now the approach starts the re nement process of section in order to ful l the safety goals.
the rst counterexample that ltsa reports is trace to property violation in safetyinjectionwhenlowwaterpressureandnotoverridden tick pressurebelowlow s0 tock pressurebelowlow tick pressurebelowlow s1 this counterexample corresponds to a case in which the water pressure is below low and the system is not overridden and in the next time unit the safety injection signal is o .
the process continues by computing an interpolant for the counterexample and the violated goal obtaining safetyinjection overridden pressurebelowlow .
the weakest precondition of this interpolant with respect to the last non tick operation i.e.
tock leads us to the same formula the interpolant .
so by preventing tock from occurring we do not stop violating the goal.
thus our approach attempts to remove the counterexample by forcing the occurrence of an operation such that the operation s execution avoids the interpolant.
operation sendsignal meets the two conditions for required triggering condition re nement namely i safetyinjection true a i safetyinjection0 overridden0 overridden b pressurebelowlow0 pressurebelowlow i0 whereirepresents the above mentioned interpolant.
condition a ensures that sendsignal can be executed when safetyinjection overridden pressurebelowlow while condition b ensures that sendsignal s execution avoids the interpolant.
then by forcing sendsignal to occur when safetyinjection overridden pressurebelowlow the136counterexample is removed.
the fth iteration nishes rening sendsignal s required triggering condition r5 reqtrig sendsignal r5 safetyinjection overridden pressurebelowlow reqtrig1 enablesignal overridden occurs reset r6 reqtrig2 enablesignal overridden pressureabovepermit r7 reqtrig overridesignal r8 overridden occurs block pressureabovepermit the re ned required conditions of subsequent iterations r5 r8 of our process guarantee the satisfaction of the safety goals.
notice that for example in r5 safetyinjection is redundant in sendsignal s required triggering condition since safetyinjection is the domain precondition of sendsignal .
the approach guarantees that overridesignal s required triggering condition r8 does not contradict overridesignal s required preconditions r2 and r3 thanks to the rst environment assumption which expresses that occurs block occurs reset .
the second assumption is used for justifying that enablesignal s required triggering conditions r6 and r7 do not contradict enablesignal s required precondition r4 .
the operational requirements speci cation obtained by the above requirements achieves the esfas goals so our process successfully terminates.
when comparing our approach with the ilp based framework in the rst di erence shows up in the fth iteration.
the ilp based framework removes the same counterexample but due to the problem of overgeneralisation of this approach it produces a weaker required triggering condition for sendsignal pressurebelowlow i.e.
rather than overridden pressurebelowlow .
this condition forces sendsignal to occur when the water pressure is below the low threshold regardless of whether it is overridden or not.
in the sixth and seventh both approaches produce the same required conditions.
in the eighth iteration however a second di erence is detected.
the ilp based framework learns a weaker triggering condition for overridesignal namely occurs block .
this learned required condition produces a deadlock in the system for a reason similar to the case of the mine pump.
to remove the deadlock the ilpbased framework requires the engineer to backtrack to previous iterations and either manually re ne the required conditions or provide further positive and negative scenarios and rerun the operationalisation process.
let us compare the running times of our approach with those of the ilp framework.
since both approaches use ltsa the critical part in time is interpolation plus sat vs. inductive learning.
in the case of ilp the time increases from seconds in the rst iteration to seconds in the eighth because the set of examples gets bigger the engineer accumulates the positive scenarios from each iteration .
our approach takes less than second per iteration.
.
analysing reactivity properties previous approaches to goal operationalisation do not deal with liveness goals so we do not have previous results or case studies to compare with to validate our technique.
in particular letier s patterns based approach classi es these goals as unrealisable .
so the speci cations that we use for evaluation minepump esfas do not have liveness goals assigned to agents to be operationalised.we then developed some liveness goals that based on the knowledge we have on the models should be satis ed although these do not appear explicitly in the speci cations.
in addition we do not use fairness assumptions and we have to assume certain liveness constraints on the environment e.g.
if the pump is on eventually the water level is not high and to remove some safety goals that imply our developed properties so that liveness counterexamples emerge.
for the mine pump controller the introduced property is if in nitely often there is no methane so the pump can be turned on then in nitely often the water level is not high.
we specify this property as pumpon!
highwater methane!
highwater in order to obtain a counterexample for this goal we remove safety goals that lead to required conditions t4 and t6 .
then a counterexample for the goal is obtained which has the following loop violation of ltl property livenessgoal trace to terminal set of states ... signalmethane highwater methane cycle in terminal set tick highwater methane s3 signalnomethane highwater tick highwater s4 signalmethane highwater methane notice that s4 is the state in the loop that satis es the assumption methane but neither s3 nor s4 satisfy the goal highwater .
then the interpolant computed for this counterexample is the following methane3 highwater3 pumpon3 methane4 highwater4 pumpon4 this interpolant explains what is wrong in the loop.
to remove this counterexample we search for an operation that can be executed at some point in the loop such that its execution reaches a states that does not satisfy the interpolant.
switchpumpon meets these two conditions.
then the re nement weakens the switchpumpon s required triggering condition with the conjunction of its required precondition and the negation of the goal which correctly operationalises the goal reqtrig switchpumpon methane lowwater highwater l1 for the esfas system the developed property is if innitely often the user does not override the system pressing the block button then in nitely often the level of coolant won t be low .
the property to operationalise is safetyinjection !
pressurebelowlow occurs block!
pressurebelowlow the counterexample found for this goal is violation of ltl property livenessgoal trace to terminal set of states ... tick pressurebelowlow cycle in terminal set tock pressurebelowlow tick pressurebelowlow then the re nement process computes an interpolant and weakens the required triggering condition for sendsignal operation in this case weaker than r5 which correctly operationalises the goal reqtrig sendsignal pressurebelowlow l2 .
discussion and related work goal oriented requirements engineering e.g.
kaos and i has been the focus of much research in the requirements engineering community.
an important aspect of this approach to requirements engineering is the notion of relating high level goals achievable only through agent cooperation with lower level goals that can be assigned to speci c agents some of which may be software to be built.
support for re ning goals has been studied extensively too e.g.
.
goal operationalisation aims to produce requirements on a per operation basis that will be provided by a speci c agent to guarantee it achieves a goal that has been assigned to it.
approaches concerned with goal operationalisation are for instance the nfr framework and crews .
however these either focus on non functional requirements or are informal and hence cannot be fully veri ed.
more formal approaches such as allow checking the correctness of operationalisation rather than supporting the elaboration of such operational requirements.
the use of generalisation techniques in the context of goal models is not novel.
for instance presents a method for inferring declarative assertions from scenarios.
it elicits goals from tailored scenarios provided by stake holders using an inductive inference process based on explanation based learning ebl .
apart from not being used speci cally for operationalisation the learning in cannot consider existing knowledge e.g.
existing goals or operational requirements during the inference process.
hence it is unsound and can produce inconsistent speci cations.
interpolation has been used for software analysis purposes notably by mcmillan in combination with sat based model checking for circuit veri cation .
it has also been employed for automated counterexample guided abstraction re nement .
essentially interpolation is used in the context of the veri cation of abstract imprecise models.
when a counterexample is obtained it must be checked whether it is an actual counterexample or it arised due to the imprecision of the model.
if it is spurious then when building the conjunction of the model and the counterexample one arrives to an unsatis able formula.
interpolation explains what is the di erence between the abstract and concrete models of the system that led to the spurious counterexample.
the interpolants obtained can be made part of the abstract model to make it more concrete and thus get rid of the spurious counterexample.
this process is iterated until no further counterexamples are obtained or a real non spurious counterexample is produced.
in this work we proposed using interpolation for a di erent but related purpose.
basically from concrete counterexamples showing goal violations we produce unsatis able formulas so that interpolants can be computed.
these interpolants are used to re ne the concrete operation model.
as opposed to abstraction re nement in our setting we do not have a model of reference to be used for re nement the concrete model in the context of abstraction re nement instead we have an objective namely to correctly and completely operationalise the goals.
the deviation from the objective is what guides our process in the use of interpolation for re ning the operation model.
other related approaches are the works on synthesis of behaviour models in form of lts from goals .
in contrast with our approach which produces declarative required pre triggering conditions for controlled operations these works based on synthesis produce operational re nements for controlled operations.
there exist other approaches that deal with the problem of goal operationalisation systematically.
as mentioned in section the approach introduced in this article is more closely related to the framework presented in which provides a semi automated method that uses model checking for analysing goal achievement and inductive logic programming ilp for learning operational requirements.
there are some important di erences between the two approaches.
requires user intervention to provide positive scenarios for the learning phase and hence its results are dependent on the correctness and richness of the scenarios given whereas this is not required by our presented approach.
uses ilp which searches for the most compressed conditions i.e.
fewest number of uent literals appearing in the required conditions and hence is prone to generating overgeneralised conditions.
the approach introduced in this article on the other hand uses interpolation which produces more precise conditions as the interpolant is necessarily implied by the counterexample trace and it necessarily leads to a violation of a goal.
exactly because of this interpolation based re nement may require more iterations to reach a valid operationalisation compared to the ilp approach.
finally our approach is able to deal with a wide range of liveness properties which are not handled by previous approaches to goal operationalisation.
.
conclusion and future work we presented an approach for goal operationalisation that automatically computes required pre triggering conditions for operations in order to ful l a set of goals.
moreover this approach does not depend on user provided scenarios and their characteristics e.g.
richness and correctness as is the case with .
this approach is based on interpolation and sat solving and applies to safety goals and particular kinds of liveness goals namely reactivity properties a general class that embraces many liveness properties .
we have evaluated our technique on some models taken from the literature and compared our approach with that of showing that in these cases our approach is able to produce goal operatinalisations e ectively and more e ciently.
there are various lines for future work.
we plan to carry out case studies to validate our technique.
this may in particular enable us to evaluate possible scalability issues with our approach to goal operationalisation.
in addition we plan to investigate what is the precise relationship between operationalisations obtained by interpolation and those obtained by inductive logic programming.
in particular we are interested in analysing a possible notion of most general operationalisation and to assess whether interpolation based re nement enable us to reach such operationalisations.
we also plan to investigate a potential complementation between interpolation and inductive logic programming for goal operationalisation.
finally since our approach heavily relies on the calculation of interpolants we plan to evaluate alternative mechanisms for interpolant computation to analyse whether a particular interpolant computation approach better ts our purposes.
.