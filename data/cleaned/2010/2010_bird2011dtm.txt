don t touch my code!
examining the effects of ownership on software quality christian bird microsoft research cbird microsoft.comnachiappan nagappan microsoft research nachin microsoft.combrendan murphy microsoft research bmurphy microsoft.com harald gall university of zurich gall ifi.uzh.chpremkumar devanbu university of california davis ptdevanbu ucdavis.edu abstract ownership is a key aspect of large scale software development.
we examine the relationship between di erent ownership measures and software failures in two large software projects windows vista and windows .
we nd that in all cases measures of ownership such as the number of low expertise developers and the proportion of ownership for the top owner have a relationship with both pre release faults and post release failures.
we also empirically identify reasons that low expertise developers make changes to components and show that the removal of low expertise contributions dramatically decreases the performance of contribution based defect prediction.
finally we provide recommendations for source code change policies and utilization of resources such as code inspections based on our results.
categories and subject descriptors d. .
metrics process metrics general terms measurement management human factors keywords empirical software engineering ownership expertise quality .
introduction many recent studies have shown that human factors play a signi cant role in the quality of software components.
ownership is a general term used to describe whether one person has responsibility for a software component or if there is no one clearly responsible developer.
within microsoft we have found that when more people work on a binary it has more failures .
however to permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse september szeged hungary.
copyright acm ... .
.our knowledge the e ect of ownership has not been studied in depth in commercial contexts.
based on our observations and discussions with project managers we suspect that when there is no clear point of contact and the contributions to a software component are spread across many developers there is an increased chance of communication breakdowns misaligned goals inconsistent interfaces and semantics all leading to lower quality.
interestingly unlike some aspects of software which are known to be related to defects such as dependency complexity or size ownership is something that can be deliberately changed by modifying processes and policies.
thus the answer to the question how much does ownership affect quality?
is important as it is actionable .
managers and team leads can make better decisions about how to govern a project by knowing the answer.
if ownership has a big e ect then policies to enforce strong code ownership can be put into place managers can also watch out for code which is contributed by developers who have inadequate relevant prior experience.
if ownership has little e ect then the normal bottlenecks associated with having one person in charge of each component can be removed and available talent reassigned at will.
we have observed that many industrial projects encourage high levels of code ownership.
in this paper we examine ownership and software quality.
we make the following contributions in this paper .
we de ne and validate measures of ownership that are related to software quality.
.
we present an in depth quantitative study of the e ect of these measures of ownership on pre release and postrelease defects for multiple large software projects.
.
we identify reasons that components have many lowexpertise developers contributing to them.
.
we propose recommendations for dealing with the effects of low ownership.
.
theory related work a number of prior studies have examined the e ect of developer contribution behavior on software quality.
rahman devanbu examined the e ects of ownership experience on quality in several open source projects using a ne grained approach based on x inducing fragments of code and report ndings similar to those of ourpaper.
however they operationalize ownership di erently and ownership policies and practices in oss and commercial software are quite di erent.
thus the similarity of e ect is striking.
furthermore rahman devanbu do not study the relationship of minor contribution on software dependencies nor do they consider social network measures.
weyuker et al.
examined the e ect of including team size in prediction models.
they use a count of the developers that worked on each component but do not examine the proportion of work which we account for.
they found a negligible increase in failure prediction accuracy when adding team size to their models.
we di er in that we examine theproportion of contributions made by each developer to a component.
further we are not interested in prediction but rather determining if there is a statistically signi cant relationship between ownership and failures.
similarly meneely and williams examined the relationship of the number of developers working on parts of the linux kernel with security vulnerabilities .
they found that when more than nine developers contribute to a source le it is sixteen times more likely to include a security vulnerability.
new methods such as extreme programming xp profess collective code ownership but there has been little empirical evidence or backing of this data on reasonably mature complex or large systems.
our study is the rst to empirically quantify the e ect code owners and low expertise contributors have on the overall code quality.
domain application and even component speci c knowledge are important aids for helping developers to maintin high quality software.
boh et al.
found that project speci c expertise has a much larger impact on the time required to perform development tasks than high levels of diverse experience in unrelated projects .
in a qualitative study of commercial software projects curtis et al.
found that the thin spread of application domain knowledge was one of the top three salient problems.
they also found that one common trait among engineers categorized as exceptional was that they had deep domain knowledge and understood how the system design would generate the system behavior customers expected even under exceptional circumstances.
such knowledge is not easily obtained.
one systems engineer explained someone had to spend a hundred million to put that knowledge in my head.
it didn t come free.
the question naturally arises how can we determine who has such domain knowledge?
fortunately there is a wealth of literature that uses the prior development activity on a component as a proxy for expertise and knowledge with respect to the component.
as examples expertise browser from mockus et al.
and expertise recommender from mcdonald and ackerman both use measures of the amount of work that a developer has performed on a software component to recommend component experts.
fritz et al.
found that the ability of a developer to answer questions about a piece of code in a system was strongly determined by whether the developer had authored some of the code and how much time was spent authoring it .
mockus and weiss used properties of an individual change to predict the probability of that change causing a failure .
they found that changes made by developers that were more experienced with a piece of code were less likely to induce failure.
three of their fourteen measures capture theexperience of a developer history by counting prior changes and they were signi cant in prediction.
in a study of o shoring and succession in software development mockus evaluated a number of succession measures with the goal of being able to automatically identify mentors for developers working on a per component basis.
a succession measure based on ownership was able to accurately pinpoint the most likely method and was used in a large scale study evaluating the factors a ecting productivity in project succession and o shoring.
research in other domains such as manufacturing has found that when a worker performs a task repeatedly the labor requirements to complete subsequent work in the same task decreases and the quality increases .
software development di ers from these domains in that workers do not perform the exact same task repeatedly.
rather software development represents a form of constant problem solving in which tasks are rarely exactly the same but may be similar.
nonetheless developers gain project and component speci c knowledge as they repeatedly perform tasks on the same systems .
banker et al.
found that increased experience increases a developer s knowledge of the architectural domain of the system .
repeatedly using a particular api or working on a particular system creates episodic knowledge .
robillard indicates that the lack of such knowledge negatively a ects the quality of software .
indeed basili and caldiera present an approach for improving quality in software development through learning and experience by establishing experience factories .
they claim that by reusing knowledge products and experience companies can maintain high quality levels because developers do not need to constantly acquire new knowledge and expertise as they work on di erent projects.
drawing on these ideas we develop ownership measures which consider the number of times that a developer works on a particular component with the idea that each exposure is a learning experience and increases the developer s knowledge and abilities.
there is a knowledge sharing factor at play as well.
the set of developers that contribute to a component implicitly form a team that has shared knowledge regarding the semantics and design of the component.
coordination is a known problem in software development .
in fact another of the top three problems identi ed in curtis study was communication and coordination breakdowns.
working in such a group always creates a need for sharing and integrating knowledge across all members .
cataldo et al.
showed that communication breakdowns delay tasks .
if a member of this team devotes little attention to the team and or the component they may not acquire the knowledge required to make changes to the component without error.
we attempt to operationalize these team members in this paper and examine their e ect on quality.
if ownership of a particular component in a system whether it be a le class module plugin or subsystem is a valid proxy for expertise then what is the e ect of having most changes made by those with little expertise?
is it better to have one clear owner of a software component?
we operationalize ownership in two key ways here and formally de ne our measures in section .
one measure of ownership is how much of the development activity for a component comes from one developer.
if one developer makes of the changes to a component then we say that the component has high ownership.
the other way that we measure!
.
!
.
.
.
.
.
.
.
.
.
.
?
?
ab9 .
c ?
.
!
.d .
.
.
e .
f423 !
g!
.
0h f423 !.d g!
0h .
f423 g3 314h i j6 .
.k g .
9h !
.
.
.
.
.
.
.
.
.
.
.
l ?
a .
.
abocomp.dll e m .
.
?
.
c .
.
.
nao .
?
c ?
?
.
pqn ?
c ra9 l ?
.
.
.
g. .
rs h ?
.
.
g .
rs h l .
c .
.
?
.
.
.
c .
.
t !ufjv !1wjv a figure graph of the proportion of commits to abocamp.dll by developers during the vista development cycle showing the four measures of ownership used in this paper.
ownership is by determining how many low expertise developers are working on a component.
if many developers are all making few changes to a component then there are many non experts working on the component and we label the component as having low ownership.
we expect that having one clear owner for a component will lead to fewer failures and that when many nonexperts are making changes indicating that ownership is spread across many contributors the component will have more failures.
.
terminology and metrics we adopt basili s goal question metric approach to frame our study of ownership.
our goal is to understand the relationship between ownership and software quality.
we also hope to gain an understanding of how this relationship varies with the development process in use.
achievement of this goal can lead to more informed development decisions or possibly process policy changes resulting in software with fewer defects.
in order to reach this goal we ask a number of speci c questions .
are higher levels of ownership associated with less defects?
.
is there a negative e ect when a software entity is developed by many people with low ownership?
.
are these e ects related to the development process used?
in order to answer these questions we propose a number of ownership metrics and use them to evaluate our hypotheses of ownership.
we begin by de ning some important terms and metrics used throughout the rest of this paper software component this is a unit of development that has some core functionality.
defects canbe traced back to a speci c component and software changes from developers can also be traced to a component.
in windows a component is a compiled binary.
contributor a contributor to a software component is someone who has made commits software changes to the component.
proportion of ownership the proportion of ownership or simply ownership of a contributor for a particular component is the ratio of number of commits that the contributor has made relative to the total number of commits for that component.
thus if cindy has made commits to ie9.dll and there are a total of commits to ie9.dll then cindy has an ownership of .
minor contributor a developer who has made changes to a component but whose ownership is below is considered a minor contributor to that component.
this threshold was chosen based on examination of distributions of ownership1.
we refer to a commit from a minor contributor as a minor contribution.
major contributor a developer who has made changes to a component and whose ownership is at or above is a major contributor to the component and a commit from such a developer is a major contribution.
note that we examine the number of changes to a component made by a developer rather than the actual number of lines modi ed.
within windows each change corresponds to one x or enhancement and individual changes are quite small usually on the order of tens of lines.
we use number of changes because each change represents an exposure of the developer to the code and because the previous measure 1a sensitivity analysis with threshold values ranging from to yielded similar results.
ownership of a.dll by developers a a.dll ownership of b.dll by developers b b.dll figure ownership graphs for two binaries in windows of experience used by mockus and weiss also used the number of changes.
however prior literature has shown high correlation above .
between number of changes and number of lines contributed and we have found similar results in windows indicating that our results would not change signi cantly.
with these terms de ned we now introduce our metrics.
minor number of minor contributors major number of major contributors total total number of contributors ownership proportion of ownership for the contributor with the highest proportion of ownership figure shows the proportion of commits for each of the developers that contributed to abocomp.dll in windows in decreasing order.
this library had a total of commits made during the development cycle.
the top contributing engineer made commits roughly .
five engineers made at least of the commits at least commits .
twelve engineers made less than of the commits less than commits .
finally there were a total of seventeen engineers that made commits to the binary.
thus our metrics for abocomp.dll are metric value minor major total ownership .
.
hypotheses we begin with the observation that a developer with lower expertise is more likely to introduce bugs into the code.
a developer who has made a small proportion of the commits to a binary likely has less expertise and is more likely to make an error.
we expect that as the number of developers working on a component increases the component may become fragmented and the di culty of vetting and coordinating all these minor contributions becomes an obstacle to good quality.
thus if minor is high quality su ers.hypothesis software components with many minor contributors will have more failures than software components that have fewer.
we also look at the proportion of ownership for the highest contributing developer for each component ownership .
if ownership is high that indicates that there is one developer who owns the component and has a high level of expertise.
this person can also act as a single point of contact for others who need to use the component need changes to it or just have questions about it.
we theorize that when such a person exists the software quality is higher resulting in fewer failures.
hypothesis software components with a high level of ownership will have fewer failures than components with lower top ownership levels.
if the number of minor contributors negatively a ects software quality the next question to ask is why do some binaries have so many minor contributors?
we have observed both at microsoft and also within oss projects such as python and postgres that during the process of maintenance feature addition or bug xing owners of one component often need to modify other components that the rst relies on or is relied upon by.
as a simple example a developer tasked with xing media playback in internet explorer may need to make changes to the media playback interface library even though the developer is not the designated owner and has limited experience with this component.
this leads to our hypothesis.
hypothesis minor contributors to components will be major contributors to other components that are related through dependency relationships finally if low expertise contributions do have a large impact on software quality then we expect that defect prediction techniques will be a ected by their inclusion or removal.
we therefore replicate prior defect prediction techniques and compare results when using all data data derived only from changes by minor contributors and and data derived only from changes to major contributors.
we expect that when data from minor contributors is removed the quality of the defect prediction will su er.windows vista windows category metricpre release post release pre release post release failures failures failures failures ownership metricstotal .
.
.
.
minor .
.
.
.
major .
.
.
.
ownership .
.
.
.
classic metricssize .
.
.
.
churn .
.
.
.
complexity .
.
.
.
table bivariate spearman correlation of ownership and code metrics with pre and post release failures in windows vista and windows .
all correlations are statistically signi cant except for that of ownership and post release failures in windows .
hypothesis removal of minor contribution information from defect prediction techniques will decrease performance dramatically.
.
data collection and analysis this data presents an opportunity to investigate hypotheses regarding code ownership.
in this study we examine windows vista and windows .
windows vista and windows is developed entirely by microsoft who have processes and policies that favor strong code ownership.
windows vista and were developed by software developers and is composed of thousands of individual executable les .exe shared libraries .dll and drivers .sys which we collectively refer to as binaries .
we track the development history from the release of windows server to the release of windows and include pre release defects as well as post release failures in vista and as software quality indicators.
we require several types of data.
the most important data are the commit histories and software failures.
software repositories record the contents of every change made to a piece of software along with the change author the time of change and an associated log message that may be indicative of the type of change e.g.
introducing a feature or xing a bug .
we collected the number of changes made by each developer to each source le and used a mapping of source les to binaries in order to determine the number of changes made by each developer to each binary.
although the source code management system uses branches heavily we only recorded changes from developers that were edits to the source code.
branching operations e.g.
branching and merging were not counted as changes.
we also gathered both pre release and post release software failures for all three projects.
we gathered the failures recorded prior to release and in the rst six months after release.
because of the information contained in the failures we can automatically trace them back to the binaries that caused them but cannot reliably trace them to the source les that caused the failures.
we only count failures that the development team deemed important enough to x. finally we gathered source code metrics including various size complexity and churn metrics.
this information is gathered from both the source code repositories and the build process.
.
analysis techniques we use a number of methods to examine the relationship between ownership and software quality.
we began with a correlation analysis of both pre and post release failures with each of the ownership metrics as well as a number of other metrics such as test coverage complexity size dependencies and churn shown in table .
the results indicated that pre and post release defects in had strong relationships with minor total and ownership.
in fact minor had a higher correlation with both preand post release defects in vista and pre release defects in windows than any other metric that microsoft collects!
.
post release failures for windows present a di culty for analysis as at the time of this analysis many binaries had no post release failures reported.
thus the correlation values between metrics and and post release failures are noticeably lower than the other failure categories although all except the correlation with ownership are still statistically significant .
however we also observed some relationship between code attributes and ownership metrics.
for example figure shows data for two anonymized binaries in windows with vastly di erent ownership pro les.
unsurprisingly the binary depicted in figure b b.dll has more failures than the binary in figure a a.dll eight times as many prerelease failures and twice as many post release failures.
however b.dll is also a larger binary and experienced far more churn during the development cycle.
thus it is not clear whether the increase in failures is attributable to more minor contributors or other measures such as size complexity and churn which are known to be related to defects and are likely related to the number of minor contributors.
prior research has shown that when characteristics such as size are not considered they may a ect the validity of other software metrics .
to overcome this problem we used multiple linear regression.
linear regression is primarily used in two di erent ways.
first it can be used to make predictions about an outcome based on prior data for instance predicting how many failures a software component may have based on characteristics of the components .
we stress that while our regression analysis does use failures as the dependent variable in our models the purpose of this paper is notto predict failures.
second linear regression enables us to examine the e ectwindows vista windows model pre release post release pre release post release failures failures failures failures base code metrics base total base minor base minor major base minor major ownership table variance in failures for the base model which includes standard metrics of complexity size and churn as well as the models with minor andownership added.
an asterisk denotes that a model showed statistically signi cant improvement when the additional variable was added.
of one or more variables on an outcome when controlling for other variables.
we use it for this purpose in an e ort to examine the relationship of our ownership measures when controlling for source code characteristics such as size complexity and churn .
a linear regression model for failures indicates which variables have an e ect on failures how large the e ect is in what direction i.e.
if failures go up when a metric goes up or when it goes down and how much of the variance in the number of failures is explained by the metrics.
we compare the amount of variance in failures explained by a model that includes the ownership metrics to a model that does not include them.
there are many measures of churn complexity and size.
however to avoid multi collinearity and over tting we include only one of each measure in the model we choose the measure which results in the best base model.
this gives an indication of how much ownership actually a ects software failures.
we examined the improvement in amount of variance in failures explained by the metrics commonly referred to as the adjusted r2 and examine improved goodness of t using f tests to determine if the addition of an ownership metric improves the model by a statistically signi cant degree .
linear regression models can be reliably interpreted if certain assumptions hold.
two key assumptions are that the residuals are normally distributed and not correlated with any of the independent variables.
in our analysis we found that the distribution of failures was almost always heavily right skewed which led to a similar skew in the residuals.
when we transformed the dependent variable to be the log of the number of failures the skew diminished and the residuals t the normality assumption.
this data transformation was applied to all dependent variables except for post release failures in vista where linear regression assumptions were met by the raw data.
.
results we now present the results of our analysis of windows vista and windows .
table illustrates the results of our analysis.
we denote with an asterisk cases where a goodness of t f test indicated that the addition of a variable improved the model by a statistically signi cant degree.
the value in parentheses indicates the percent increase in variance explained over the model without the added variable.
for example in table the base minor major model in vista explains of the variance in pre release failures which is more than the base minor modelwhich explains .
the base minor model explains more of the variance in pre release failures than the base model.
adding an independent variable to a model can never decrease the variance explained so we use the adjusted r2 measure which penalizes models that have additional variables.
we built ve statistical models of failures for pre and post release defects in windows vista and windows summarized in table .
the rst model contains only the classical source code metrics size complexity and churn.
we refer to this as the base model.
this model showed that churn size and complexity all have a statistically signi cant e ect on both pre and post release failures.
in addition these metrics are able to explain of the variance in pre release failures and of the variance in post release failures in vista and and in windows .
in the second model we added total to the classic variables.
this examines the e ect of team size on defects and does not include any measures of the proportion of contributions made by individual members.
all models exhibitted a statistically signi cant improvement in variance explained.
next we added minor to the set of predictor variables in the base model.
this was done to determine if the total number of developers has a di erent e ect on quality than the number of minor contributors.
the statistics showed thatminor is positively related to both pre and post release failures to a statistically signi cant degree.
the addition of minor increased the proportion of variance in pre release failures to and post release failures to .
the gains shown by minor were stronger than those shown by total for both types of failures to a statistically signi cant degree in all cases except for post release failures in windows indicating that minor has a larger e ect on failures.
the addition of major andownership showed smaller gains but were often still statistically signi cant.
we found similar results regardless of the order that these variables were added to the models.
ownership was found to have a negative relationship with failures to a statistically signi cant degree and major had a positive relationship but was much smaller than minor .minor still showed more of an e ect than ownership andmajor even when it was added last not shown .
the nal models account for up to of variance in failures.
in all cases ownership had a stronger relationship with pre release failures than post release failures and the models in general were less explanatory.
this may indicate that there are already measures being taken e.g.
increased testing more stringent quality controls etc.
between implementation completion and release to counteract the e ects of poor ownership.
for all metrics that measure ownership levels there is a clear trend of having a statistically signi cant relationship to failures in windows.
in all cases major andownership show less of an e ect than minor ortotal indicating that the number of higher expertise contributors has marginal e ect on quality although the results are still statistically signi cant.
the results of our analysis of ownership in both releases of windows can be interpreted as follows .the number of minor contributors has a strong positive relationship with both pre and post release failures even when controlling for metrics such as size churn and complexity.
.higher levels of ownership for the top contributor to a component results in fewer failures when controlling for the same metrics but the e ect is smaller than the number of minor contributors.
.ownership has a stronger relationship with pre release failures than post release failures.
.measures of ownership and standard code measures show a much smaller relationship to post release failures in windows .
.
effects of minor contributors one of the key ndings in our analysis was that the number of minor contributors has a strong relationship with failures in both releases of windows.
since microsoft has the capability to make changes to practices based on these ndings we were eager to gain a deeper understanding of this phenomenon.
to this end we performed two more detailed analyses in order to examine the minor contributors further.
first we observed that almost all developers were major contributors to some binaries and minor contributors to others very few developers never played a major contributor role.
this led us to investigate the obvious question given a particular developer is there a relationship between a component to which she is a major contributor and one to which she is a minor contributor?
second we adapted a fault prediction study carried out by pinzger et al.
and examined the e ect of modifying the study in ways related to ownership.
.
dependency analysis the majority of developers that contributed to windows acted as major contributors to some binaries and minor contributors to others.
there were very few developers who are only minor contributors.
this fact is an indication of strong code ownership as it shows that nearly everyone has a main responsibility for at least one binary.
discussions with engineers at microsoft indicated that often an engineer who was the owner of one binary would make changes to another binary whose services he or she used often in the process of addressing reported bugs.
in our context this would show up as one engineer who was a major contributor to some binary a and a minor contributor to some binary b with a dependency relationship between aandb.
we call this a major minor dependency relationship which is illustrated in figure .
major minor dependency relationship dependency major contributor minor contributor foo.exe bar.dll2add graph rewiring slide around.
ont op..add some thought bubbles to the developer i need to use this... i need to make a change to that... which is used by this... figure illustration of the major minor dependency relationship commonly observed in vista cataldo et al.
found that making changes to a depending component without coordinating with the other stakeholders in our case the owner of the component increases the likelihood of faults .
we have no record of the communication between developers of windows.
however the fact that a minor contributor has by de nition made few if any prior contributions to a component suggests that their participation in the component s implicit team is likely minimal increasing the risk of a introducing a bug.
but does this actually happen?
is a developer d working on binary foo exe statistically more likely to be a minor contributor to a binary bar dll just because foo exe depends on bar dll ?
if so how many of the minor contributors to components can this phenomenon account for?
if the majority of minor contributors are a result of component owners making changes do depending or dependent components to accomplish their own tasks such as resolving failures then deliberate steps could be taken to avoid this type of risky behavior.
to investigate this further we employed a static analysis tool max to detect dependency relationships between binaries.
max uses debugging information les that are generated during compilation to identify these relationships which include method calls read and writes to the registry ipc com calls and use of types.
we were unable to obtain the required debugging information les for windows and thus limit our analysis here to vista.
using this tool we constructed a dependency graph that includes all of the binaries in windows vista.
the next step is to determine whether the major minordependency phenomenon occurs statistically more often than would be expected by chance.
but what exactly does by chance mean?
we model chance by generating a large plausible random sample of contributions we can then compare the observed frequency of major minor dependency with the frequency in the generated sample.
our plausible random model is that each developer chooses their contributions at random while preserving their rate of minor and major contributions.
in other words a developer is just as hardworking but her choice of where to contribute is not in uenced by dependencies in the code.
using this model we generate a large sample of simulated contribution graphs.d bob camyminorminor a before d bob camyminorminor b after figure an illustration of graph rewiring.
rewiring preserves the number of minor and major edges per developer and per binary but randomizes the organization of the contribution network.
this gives us a basis for comparison to evaluate observed real world contribution behavior is in uenced by dependencies between modules.
this bootstrapping approach comes from the statistical theory of random graphs .
a phenomenon is judged statistically signi cant if the actual observed phenomenon occurs rarely in the generated sample graphs.
following previous techniques we use a graph rewiring method to bootstrap our random ensemble based on the observed frequency of commits from individuals.
in each generated random sample each developer makes the same number of major and minor contributions as in the observed real sample but the contributions are chosen at random from the given set of components.
we check to see how often a majorly contributed component for a developer has an actual dependency on a minorly contributed component for the same developer in these generated random samples.
if the frequency of major minor dependency relationships that occur in the ensemble of simulated samples di ers signi cantly from that of the observed real sample then we can conclude that the phenomenon most likely represents some real intended behavior and not simply a chance occurrence.
graph rewiring is performed as follows in our context.
for the sake of convenience we refer to an edge connecting a binary to one of its major contributors as a major edge and an edge connecting a binary to one if its minor contributors as aminor edge .
two edges that are either both major edges or both minor edges are selected at random and endpoints of both are switched as shown in figure .
thus after the switch the number of major and major contributions for each developer node and each component node remains the same.
after performing e2rewirings where eis the number of contribution edges in the graph a su ciently random graph is obtained.
we created such random contribution graphs and compared the frequency of major minordependency relationships to the frequency in the observed actual contribution graph.
we found that in the observed vista contribution graph of the binaries had minor contributors who were major contributors to other binaries that the original had a dependency with.
in contrast this relationship only existed for an average of of the binaries in the random networks with the same minor and major contribution degree distributions.
the maximum value forthe normally distributed frequency of this phenomenon out of all graphs was of the time indicating that is de nitely a statistically signi cant di erence and the phenomenon that we are observing does not occur by chance.
in vista one common reason that a developer is a minor contributor to a binary is that he she is a major contributor to a depending binary.
this allows for processes to be put into place to recognize and either minimize or aid minor contributions.
.
effects on network metrics in pinzger et al.
reported a method to nd fault prone binaries in windows vista based on contribution networks .
a contribution network is composed of binaries and the developers that contributed to those binaries.
thus a node representing a developer is connected to all binaries the developer has contributed to and a node representing a binary is connected to all developers that contributed to it.
figure shows an example of a contribution network with boxes representing binaries and circles representing developers.
major contribution edges are solid and minor contribution edges are dashed.
the eld of social network analysis has developed a number of metrics that measure various attributes of nodes in a network.
for instance the degree of a node is the number of direct connections that it has and can be indicative of how important the node is within the local network.
other metrics measure how much information can ow through a node the average distance from a node to all other nodes how much power a node exerts over its neighbors etc.
an in depth discussion of these metrics can be found in wasserman and faust .
pinzger et al.
found that these measures had a strong relationship with post release failures in windows vista and in a prior study we found that these measures were able to predict failures in eclipse accurately as well.
speci cally pinzger et al.
built a predictor for fault prone binaries using this method it identi ed of the fault prone binaries in vista recall and of the binaries that it classi ed as fault prone actually were precision .
this was a dramatic increase over the predictive power of prior methods that used source code metrics.
we adapted that study and examined the e ect of removing minor and major contributor edges.
in figure such minor edges are indicated by the dashed lines.
the topological e ect of removing minor edges as shown in figure is that many pairs of binaries that had short connecting paths through minor contributors are disconnected.
our ndings focused on two key aspects of the results.
first we examined the correlation between social network measures and post release failures in the complete network and the network with minor edges removed.
second we measured the change in the ability of a predictor to identify fault prone binaries when removing major or minor contribution edges.
table shows the strength of relationship of six network measures with pre and post release failures.
these particular metrics are chosen because they had the highest correlation with failures among those collected.
columns labelled with minor shows the correlations of sna metrics calculated on networks that contain only minor contribution edges and those labelled with major shows correlations from networks of major contribution edges.
for all metrics except for nodewindows vista windows pre release post release pre release post release sna metric minor major minor major minor major minor major degree centrality .
.
.
.
.
.
.
.
closeness centrality .
.
.
.
.
.
.
.
reachability .
.
.
.
.
.
.
.
betweenness centrality .
.
.
.
.
.
.
.
hierarchy .
.
.
.
.
.
.
.
e ective size .
.
.
.
.
.
.
.
table correlation of social network analysis metrics on the contribution network with pre and post release failures.
columns labeled minor are correlations of failures with metrics computed on networks composed only of minor contribution edges.
columns labeled major are from networks made up of major contribution edges.
for the majaority of metrics removing the minor edges drops the correlations considerably.
for some metrics the direction of correlation actually changes for major .
b d c bob sara fu amy ram a figure an example contribution network.
boxes represent binaries and circles represent developers who contributed to them.
a dashed line between a binary and developer indicates a minor contributor relationship.
degree the networks that consider major contributions have dramatically lower correlations.
in fact for the case of hierarchy the sign of the correlation is negative indicating that higher value of hierarchy in the major contribution networks were associated with fewer failures.
these ndings clearly indicate that the edges from minor contributors embody much of the important structure of the contributions graph.
so much so that their removal results in a decrease in the discriminatory power of these metrics.
we also built a predictor from these measures for identifying fault prone binaries in windows vista and windows using the same approach as pinzger et al.
.
they trained a logistic regression model on a randomly chosen two thirds of the binaries in the contribution network and then evaluated the model based on its results when classifying the remaining third.
this process was repeated fty times each with a di erent random split of the data and the measures of performance precision recall and f score standard measures of information retrieval were averaged across all runs.
their original model based on the complete network identi ed of the fault prone binaries and of its fault prone predictions were correct their evaluation was based on a prior windows release .
when the predictor was trainedusing the same methods on the network with minor contributors removed it identi ed only of the fault prone binaries and around of its fault prone predictions were correct.
in pinzger s formulation of the prediction approach random guessing would result in for both measures.
thus a predictor based on network measures for a network containing major contributor only does marginally better than one that chose binaries purely at random.
table shows the performance when a predictor is trained on the complete network as well as the networks with minor contributions removed and major contributions removed.
we also show results for pre release failures in vista as well as pre and post release failures for windows .
in all cases models built on minor contributions performed better than those based on major contributions to a statistically signi cant degree.
in the case of vista post release failures minor contribution prediciton models perform better than models based on the entire network and models based on the entire network were never statistically better than those based on minor contributions we therefore conclude the minor contribution edges provide the signal used by defect predictors that are based on the contribution network.
without them the ability to predict failure prone components is greatly diminished further supporting our hypothesis that they are strongly related to software quality.
.
discussion our ndings are valuable in a number of ways.
we have shown that for both versions of windows ownership does indeed have a relationship with code quality.
this observation is an actionable result as this is an aspect of software development that can be controlled and monitored to some degree by management decisions on development process and policies.
in all projects the addition of minor improved the regression models for both pre and post release failures to a statistically signi cant degree.
after controlling for known software quality factors binaries with more minor contributors had more pre and post release failures in both versions of windows.
thus hypothesis is empirically supported in both projects .
the analysis of ownership is a little bit di erent.
in this case we saw a small but still statistically signi cant e ect in pre and post release failures for vista and pre releasewindows vista windows pre release post release pre release post release sna metric all minor major all minor major all minor major all minor major precision recall f score table performance of network based failure predictors for pre and post release failures for vista and windows failures for windows .
part of this may be attributable to a moderate relationship between the minor andownership but although ownership was signi cant in all models when removing minor the e ect was smaller.
nonetheless in all cases higher values for ownership was associated with lower numbers of failures.
we therefore conclude that hypothesis is supported in the case of windows vista and in pre release data for windows .
the results of empirical software engineering studies do not always generalize to settings where a di erent process is used.
the process that is used may dictate the e ect of other factors on software quality as well.
therefore when determining the applicability of a research result to a software project the context of the study must be taken in account.
microsoft employs strong ownership practices and our results are much more likely to hold in other industrial settings where similar policies are in place.
examining the e ect of ownership in contexts where ownership is not stressed as highly such as in many open source software oss projects is an area of continued study as we attempt to understand the interaction between ownership quality and varying software processes.
for contexts in which strong ownership ispracticed or where empirical studies are consistent with our own ndings we make the following recommendations regarding the development process based on our ndings .changes made by minor contributors should be reviewed with more scrutiny.
changes made by minor contributors should be exposed to greater scrutiny than changes made by developers who are experienced with the source for a particular binary.
when possible major contributors should perform these code inspections.
if a major contributor cannot perform all inspections he or she should focus on inspecting changes by minor contributors.
.potential minor contributors should communicate desired changes to developers experienced with the respective binary.
often minor contributors to one binary are major contributors to a depending binary.
rather than making a desired change directly these developers should contact a major contributor and communicate the desired change so that it can be made by someone who has higher levels of expertise.
.components with low ownership should be given priority by qa resources.
metrics such as minor and ownership should be used in conjunction with source code based metrics to identify those binaries with a high potential for having many post release failures.
when faced with limited resources for quality control e orts these binaries should have priority.it may not always be possible to follow these recommendations for instance in cases where too many potential contributors need changes to a component for one developer to handle however they should be followed as much as possible within reason.
these recommendations are currently being evaluated at microsoft.
we plan to investigate the relationship of the ownership measures used in this paper with software quality in other projects at microsoft that di er in size and process domain e.g.
projects utilizing agile .
further we plan to observe the results of projects that follow these recommendations.
.
conclusion we have examined the relationship between ownership and software quality in two large software development projects.
we found that high levels of ownership speci cally operationalized as high values of ownership andmajor and low values of minor are associated with less defects.
an investigation into the e ects of minor and major contributions on network based defect prediction found that removing minor contribution edges severely impaired predictive power.
we also found that when a component has a minor contributor the same developer is a major contributor to a dependent component approximately half of the time uncovering at least one signi cant reason for high levels of minor contributions.
changes to policies regarding tasks that would lead to this behavior such as defect resolution and feature implementation should be implemented and evaluated.
for organizations where ownership has a strong relationship with defects we have presented recommendations which are currently being evaluated at microsoft.
as our measures of ownership are cheap and lightweight we encourage other researchers and practitioners to perform and report their ndings of similar analyses so that we can build a body of knowledge regarding ownership and quality in various domains and contexts.
.