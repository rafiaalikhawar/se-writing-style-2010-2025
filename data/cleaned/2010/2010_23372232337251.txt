use disuse and misuse of automated refactorings mohsen vakilian nicholas chen stas negara balaji ambresh rajkumar brian p. bailey ralph e. johnson university of illinois at urbana champaign urbana il usa mvakili2 nchen snegara2 rajkuma1 bpbailey rjohnson illinois.edu abstract though refactoring tools have been available for more than a decade research has shown that programmers underutilize such tools.
however little is known about why programmers do not take advantage of these tools.
we have conducted a field study on programmers in their natural settings working on their code.
as a result we collected a set of interaction data from about hours of programming using our minimally intrusive data collectors.
our quantitative data show that programmers prefer lightweight methods of invoking refactorings usually perform small changes using the refactoring tool proceed with an automated refactoring even when it may change the behavior of the program and rarely preview the automated refactorings.
we also interviewed nine of our participants to provide deeper insight about the patterns that we observed in the behavioral data.
we found that programmers use predictable automated refactorings even if they have rare bugs or change the behavior of the program.
this paper reports some of the factors that affect the use of automated refactorings such as invocation method awareness naming trust and predictability and the major mismatches between programmers expectations and automated refactorings.
the results of this work contribute to producing more effective tools for refactoring complex software.
keywords software engineering software maintenance programming environments human factors user interfaces human computer interaction i. i ntroduction refactoring is defined as changing the design of software without affecting its observable behavior .
refactorings rename move split and join program elements such as fields methods packages and classes.
agile software processes such as extreme programming xp prescribe refactoring because it enables evolutionary software design and is the key to modifiable and readable code .
programmers refactor their code frequently .
some refactorings are tedious and error prone to perform manually.
thus automated refactorings were invented more than a decade ago to make the process of refactoring more efficient and reliable .
today modern integrated development environments ides such as eclipse netbeans intellij idea xcode and resharper support many automated refactorings.
recently there has been much interest in improving the reliability of existing automated refactorings and building new ones to automate sophisticated program transformations .
this is not surprising given the tediumand error proneness of some refactorings and the perceived benefits of their automation.
in spite of the growing interest in improving the usability of automated refactorings this aspect of refactoring has not received enough attention.
for example the user interfaces of refactoring tools have changed little since they were first introduced and recent studies suggest that programmers greatly underutilize the existing refactoring tools .
we need to understand the problems programmers have with today s refactoring tools to design future generations of these tools that fit programmers needs.
we conducted a study consisting of both quantitative and qualitative data collection.
we studied developers working in their natural settings on their code for a total of programming hours over three months and collected data about their interactions with automated refactorings.
we observed patterns of interaction in our quantitative data and interviewed nine of our participants to take a more detailed qualitative look at our behavioral data.
then we adapted a general framework of human automation interaction to frame the use disuse and misuse of automated refactorings.
use of automated refactorings refers to programmers applying automated refactorings to perform code changes they might otherwise do manually.
disuse of automated refactorings is programmers neglect or underuse of automated refactorings.
misuse of automated refactorings refers to programmers use of these tools in ways not recommended by the designers.
our empirical study sheds light on how users interact with automated refactorings.
first we have found that a single context aware and lightweight method of invoking refactorings accounts for a significant number of refactoring invocations see section iii .
second we have found several factors that lead to the underutilization of automated refactorings such as need awareness naming trust predictability and configuration see section iv .
third we have found that programmers usually continue an automated refactoring that has reported some error or warning.
this finding casts doubt on the main property of automated refactorings namely behavior preservation.
in addition we have observed some unjustified uses of the refactoring tool see section v .
finally we have proposed alternative ways of designing refactoring tools based on the findings of our study see subsections iii b iv g and v c .
.
c ieee icse zurich switzerland ii.
r esearch methodology to understand why existing automated refactorings are underused we analyzed a large corpus of interaction data gathered from programmers over three months.
in addition we conducted a set of nine semi structured interviews with developers to understand the rationales of their refactoring practices.
a. participants we recruited programmers working on research projects at the university of illinois at urbana champaign.
eleven of these internal programmers were enrolled in computer science graduate programs and the remaining five were research interns.
we also recruited external programmers by sending more than individual emails and posting recruitment messages to the mailing lists and irc channels of over open source java projects.
we asked every participant to fill out a brief survey that collected some demographic information including their years of programming experience and projects.
we received the survey results of participants.
based on the survey and of our participants had and more than years of programming experience respectively.
our participants reported that they had been working on a diverse range of projects such as banking business process management marketing database management and projects of six research labs at the university.
b. data collection we gathered the interaction data using our two minimally intrusive data collectors for the eclipse ide codingspectator and codingtracker .
our participants used these tools for about hours mean sd .
our data collectors were developed to capture data regarding the failure of automated refactorings context of the failure configuration overhead and invocation methods.
codingspectator captures data about the use of automated refactorings while codingtracker collects all manual edits.
codingspectator collects three kinds of events canceled performed and unavailable .
canceled events are triggered when the programmer cancels an automated refactoring.
performed events occur when the programmer applies an automated refactoring and unavailable events are triggered when the programmer tries to invoke an inapplicable automated refactoring and eclipse reports an error.
eclipse creates refactoring descriptor objects for some invocations of automated refactorings and stores them in an xml format.
codingtracker captures the descriptors of all refactorings created by eclipse and codingspectator creates refactoring descriptors of its own which capture more data than those of eclipse.
codingspectator supported of the automated refactorings supported by eclipse during the study.codingspectator records the following information in its refactoring descriptors the time of occurrence of every refactoring event the identifier of the automated refactoring configurations e.g.
input elements project and settings that affect the result of the tool information about the selection used to invoke the automated refactoring and its context whether the refactoring tool was invoked using quick assist the problems reported by each invocation of an automated refactoring the time spent on each page of the refactoring wizards figure illustrates the refactoring descriptor that codingspectator captures for an application of the extract method refactoring.
due to privacy issues we use our own examples instead of our participants data.
refactoring stamp id org.eclipse.jdt.ui.extract.method comment extract method private void printdetails double amount from printer.printinfo to printer exceptions false input src printer.java name printdetails code snippet void printinfo double amount printbanner system.out.println amount amount selection text system.out.println amount amount invoked by quickassist false status ok navigation history pm page of 1file users vazexqi desktop sample.html void printinfo double amount printbanner system.out.println amount amount figure .
the descriptor captured by codingspectator for an extract method refactoring invoked on the highlighted statements of method printinfo in the top box.
see the numbered list of items in subsection ii b for a description of each group of attributes.
codingtracker records the edits made inside the java editors of eclipse so precisely that it can later replay them to show the code evolution in action.
we replayed some of the code edits to obtain more context about some of the refactoring events and estimate the number of lines and files affected by each automated refactoring.
we also used codingtracker to estimate the number of programming hours of each participants.
we computed the number of programming hours by adding up the time intervals between consecutive234codingtracker events that were at most half an hour long.
both codingspectator and codingtracker are open source and available at the analysis of the interaction data was complemented by conducting semi structured interviews with nine of our internal participants.
each interview lasted about an hour.
during the interviews we asked questions about participants awareness and use of automated refactorings.
in addition we prompted the participants with the detailed data that our data collectors had captured and asked them questions about their specific usage patterns such as the refactorings they had performed or canceled the pieces of code they had refactored the selections and methods they had used to invoke the refactorings and the refactoring problems they had received from the tools.
the interview script is in an accompanying technical report .
in this paper we refer to the i th interviewee as i i. c. data analysis we used theoretical sampling to decide what data to collect and whom to interview.
for instance based on the results of our pilot study on undergraduate students at the university we decided to study more experienced programmers for a longer period of time.
we used an inductive approach for analyzing the qualitative data to reliably decide whether two interviewees had provided equivalent responses.
the first author coded the interview scripts to derive the common themes of the interview responses.
he listed all responses belonging to each code and constantly compared and revised the codes until they saturated.
sections iii iv and v present the core categories of our data namely use disuse and misuse and their related categories in subsections.
iii.
u se of automated refactoring tools decisions about the use of automated tools depend on a complex interaction of a variety of factors and are subject to personal differences.
the human automation interaction literature has studied the roles of personal attitudes mental workload cognitive overhead trust confidence risk and other factors on human use of automation .
this section discusses the impact of invocation method on the use of automated refactorings.
a. invocation method eclipse supports several ways of invoking refactorings.
the programmer could go to the refactor menu right click or use shortcut keys to invoke refactorings.
alternatively the programmer may use quick fix orquick assist ctrl to invoke some of the automated refactorings.
quick fix assists programmers in resolving compilation problems.
eclipse shows a small icon close to the location of each compilation problem if a quick fix is available for the problem.
quick fix sometimes offers a refactoring to resolvecompilation warnings.
on the other hand quick assist is not tied into compilation problems and programmers can use it to perform some common changes such as rename and extract method see figure for an example of quick assist .
figure .
quick assist proposes some of the transformations that are applicable to the selected context.
the user can single click on each proposed item to preview its effect on the code.
our results suggest that programmers prefer to quickly apply an automated refactoring and tweak its outcome later rather than spend time configuring the tool up front.
based on the data in table i our participants used quick assist to perform the refactorings that it supports of the time.
our participants relied on quick assist to perform the rename refactoring less than other refactorings perhaps because rename is so frequent that they had learned its shortcut key.
if we exclude the rename refactorings our participants used quick assist to invoke of the refactorings.
this paper reports the first quantitative results on the use of quick assist for performing refactorings.
of the six interviewees who were aware of quick assist five used it as their primary method of invoking the refactorings supported by it.
quick assist is a popular method of invoking automated refactorings because it can be quickly invoked via keyboard narrows the decision space by proposing only a handful of transformations that are applicable to the selected context and makes it easier to configure refactorings by using some default settings and not opening a dialog.
however we noticed that at least two of our interviewees were not aware that quick assist had used some non default settings from the last configuration of the refactoring.
all of our interviewees were aware of quick fix see subsection iii a .
this awareness could be a result of the visual element that indicates the availability of quick fix.
three of our interviewees did not know about the quick assist feature.
nevertheless those who were aware of it heavily relied on it to both discover and invoke automated refactorings.
i 1told us most of them i know about by using quick assist.
i very seldom go into the235table i data about the usage of automated refactorings from 26programmers for about hours over three months .
thecs subscript indicates the data captured using coding spectator and the ct subscript indicates the data captured using coding tracker .
in the complexity column s s imple m m oderate and c c omplex .
config cs is the average configuration time seconds of788 refactorings .
linesct and filesct are the average numbers of affected lines and files computed using the data available for of the performed refactorings captured by coding tracker .
pr p w cs pr performed warning and pr p e cs pr performed error .
the symbol indicates an unknown or undefined value .
performed cs is less than performed ct for change method signature because coding spectator did not support this refactoring from the beginning of the study .
automated refactoring complexity performed cs performed ct canceled cs warning cs error cs fatal error cs quick assist cs preview cs config cs sec linesct filesct pr p w cs pr p e cs change method signature c .
.
.
.
.
convert anonymous class to nested s .
.
convert local variable to field s .
.
.
encapsulate field m .
.
extract class c .
.
extract constant s .
.
.
.
extract interface m .
.
.
.
extract local variable s .
.
.
.
.
extract method m .
.
.
.
extract superclass c .
.
generalize declared type m infer generic type arguments c .
.
inline constant s .
.
.
inline local variable s .
.
.
inline method s .
.
.
.
introduce factory m introduce indirection m .
.
introduce parameter c .
.
introduce parameter object c move c .
.
.
.
move method c .
.
move static member m .
.
.
.
move type to new file s .
.
pull up c .
.
.
.
push down c .
.
.
.
.
rename class m .
.
.
.
.
rename enumeration constant s .
.
.
rename field m .
.
.
.
.
rename local variable s .
.
.
.
.
rename method m .
.
.
.
.
rename package m .
.
.
.
rename type parameter s .
.
use supertype where possible c .
.
.
.
.
.
total counts weighted averages overall pr refactoring menu and only when there is a refactoring that i cannot reach through quick assist and i don t know about .
quick assist will tell me if they are applicable in a certain context.
.
it always annoys me when they are not available through quick assist like change method signature.
i really like quick assist.
as another example when we introduced i 2to the introduce parameter refactoring he commented that s actually pretty cool.
i never knew about the existence of this.
i ve done this a few times manually and i always wondered if it s possible to do this automatically.
yeah i ll probably try it.
does this show up in quick assist?b.
implications we have found that programmers prefer lightweight methods of invoking refactorings like quick assist.
therefore we suggest that other ides such as intellij idea and netbeans support refactoring invocation methods similar to quick assist.
we noticed that quick assist was a somewhat hidden feature of eclipse.
some programmers will not know about this feature until they somehow learn about the magic shortcut key.
more programmers know about quick fix because it has a visual representation.
this observation suggests that recommending refactorings similar to the way quick fix recommends fixes for compilation problems might promote236the use of automated refactorings.
while quick fix removes compilation problems automated refactorings remove code smells .
code smells are common deficiencies of code that make it less readable and reusable .
several tools have been proposed for detecting code smells .
if a code smell detector has a low rate of false alarm and suggests automated refactorings that remove the code smells it may encourage programmers to use the refactoring tool more often.
however metrics for detecting code smells do not rival informed human intuition in practice .
perhaps we need systems that facilitate programmers collaboration on detecting code smells.
iv.
d isuse of automated refactoring tools in the human automation interaction literature disuse refers to underutilization of automation .
disuse of automated refactorings occurs when a programmer performs a refactoring manually even though the ide supports it.
murphy hill et al.
inspected a sample of the version control and refactoring histories of eclipse developers and found that the developers had performed about of their refactorings manually instead of using the refactoring tool .
our interviews provided qualitative evidence for disuse of automated refactorings.
for each of the following refactorings more than half of our interviewees sometimes performed the refactoring manually extract method extract class extract super class extract interface extract constant change method signature infer generic type arguments generalize declared type use supertype where possible encapsulate field introduce factory introduce parameter move instance method move static member and pull up.
in the rest of this section we will discuss the factors that we have found to influence the disuse of automated refactorings.
a. need some automated refactorings are underused just because programmers rarely need them.
for instance table i shows that extract and pull up are performed more than inline and push down.
five of our interviewees told us that this was because they usually started with a simple design and gradually made it more general and reusable.
two interviewees said that it was not worth learning some automated refactorings because they rarely performed the refactorings.
for example i 3said i know that there are many refactorings.
but many times i think that it s easier to just do something manually than try to learn a very particular refactoring that does something that i don t do very often.
b. awareness programmers must be aware of an automated refactoring to use it.
prior survey studies have reported the role ofawareness in the use of refactoring tools .
our interviews showed that even experienced programmers do not know about many of the automated refactorings supported by eclipse.
we asked our interviewees the following three questions about each automated refactoring of eclipse.
did you know that eclipse supported this refactoring?
do you know what this automated refactoring does?
do you ever perform this refactoring manually?
why?
on average our interviewees were unaware of the existence of more than nine automated refactorings of eclipse.
for each of the following refactorings more than half of our interviewees did not know that eclipse had automated support for the refactoring generalize declared type use supertype where possible introduce factory introduce indirection introduce parameter introduce parameter object move type to new file move instance method and move static member.
we asked our participants how they learned the automated refactorings in eclipse and why they knew only a subset of the refactorings in eclipse.
our interviewees told us that they learned automated refactorings by seeing other programmers using them reading articles or exploring the ide.
our findings corroborate the results of prior studies that identified peer interaction as a mechanism of discovering new tools .
we found that our interviewees did not always use all the automated refactorings that they knew about.
for each one of extract method extract class change method signature infer generic type arguments and pull up at least five of our interviewees said that they sometimes performed the refactoring manually even though they were aware of its automated support in the ide.
in the rest of this section we will discuss other reasons of disuse.
c. naming it has been assumed that recalling the names of automated refactorings is a barrier to using refactoring tools .
our study provided more evidence that automated refactorings whose names are hard to understand too technical or confusing are more likely to get underused.
i 4told us generally i don t try them if i don t know what they do.
i might occasionally try them if i can kind of guess what they do even though i m not sure but i don t do that very often.
our interviewees did not know the goals of more than eight automated refactorings on average.
that is our interviewees did not know what each of these automated refactorings did and were not able to correctly guess what the tool was supposed to do based on its name.
for each of the following seven refactorings more than half of our interviewees could not describe the transformation automated by the refactoring extract class generalize declared type introduce factory introduce indirection introduce237parameter introduce parameter object and move instance method.
in particular the majority of our interviewees confused the three automated refactorings infer generic type arguments generalize declared type and use supertype where possible.
d. trust trust influences the use of automation and reliability is a factor in the development of trust.
if the automation is not reliable the operators are more likely to lose their trust in the automation and stop using it especially when the automation fails to perform simple tasks.
however if the automation is highly reliable operators seem to tolerate its occasional failures and continue to use it .
we found usability to be a more important factor than reliability on users trust in a mature refactoring tool like that of eclipse.
even though others have found subtle errors in the refactoring tools of mainstream ides and there are many open issues about the refactoring tools in the bug tracking systems none of our interviewees mentioned the existence of bugs in automated refactorings as a reason for not using these tools.
nonetheless i 2said that he would be more cautious while changing critical code most of the time i don t do refactoring if it involves very critical codes.
i d rather do it manually.
only things that are so easy that they cannot possibly break i would not expect them to break.
on the other hand four of our interviewees did not use some of the automated refactorings because of their usability problems.
i 3said there is also a notion of not trusting the tool.
if the interface of the tool is not good enough how do i know that the implementation is not sketchy?
our interviewees did not use automated refactorings that they had found to have complex user interfaces and unclear benefits.
in general if the benefits of automation are not readily apparent humans are less likely to use the automation because of the cognitive overhead involved in evaluating and using the automation .
e. predictability we have found that the predictability of outcome is an important factor in the use of automated refactorings.
three interviewees did not use some automated refactorings because of their unpredictability.
for example i 3said if it affects only one file then i kind of know exactly what the refactoring does and i can look at the result instantly afterwards.
so i don t like refactorings that are ambiguous enough that i am not able to guess the final result.
if i cannot guess i don t use the refactoring.
i consider it not worth the trouble.
if the thing that the tool does is so complicated that it isn t easy to figure out things are alright i m kind of discouraged to use the tool.
in the following we discuss how the complexity and preview of a refactoring affect its predictability.
complexity it was a challenge to determine the complexity levels of refactorings.
therefore we used two approaches to estimate the complexities of refactorings.
in the first approach each of the first three authors individually assessed the complexities of manually performing the eclipse refactorings in the ide.
then they compared their results and worked together to resolve the disagreements between assignments.
finally they categorized the refactorings as simple moderate and complex.
table i illustrates the complexity level of each refactoring.
we have found that our participants tended to perform simpler refactorings more frequently see figure .
number of performed refactoringscomplexity simplemoderatecomplex281 .
.
.
figure .
this graph shows the counts and percentages of performed refactorings in each category simple moderate and complex.
the counts of performed refactorings in each category are based on the data in columns complexity and performed ct of table i. our second approach for studying the effect of complexity on the use of automated refactorings was quantitative.
we used the number of files and lines affected by an automated refactoring as an indicator of its complexity.
big refactorings can potentially alter many lines of code across many files.
such big refactorings are tedious and error prone to do manually.
therefore one might expect programmers to use automated refactorings for performing bigger changes.
however our data show that of the automated refactorings that our participants performed affected at most six lines and of the performed automated refactorings affected only one file.
there could be various reasons for the low use of automated refactorings that make complex changes.
first there might just be less opportunity for performing large refactorings see subsection iv a .
second we found that the current design of refactoring tools are not suitable for automating big refactorings.
two of our interviewees mentioned the problem with large refactorings.
i 1said if it does too much then it will overwhelm me.
i will get too many changes at once.
i don t like looking at diffs if i don t have to.
and if it does too much for me i feel like i m pushed out of the loop.
suddenly it changes my program in a lot of ways.
i will have to go238and read these things while i prefer it to do a little for me.
since the tools for small refactorings affect a narrow piece of the code it is easier to understand the changes and verify their correctness.
in contrast programmers may worry that the tools for performing big changes may transform their code in unpredictable ways.
disuse of automated support for complex refactorings is consistent with findings from the human automation interaction literature that imply humans prefer to take ownership of complex tasks and delegate simple ones to the machine .
more studies are required to understand the variables that affect the trend in programmers use of complex refactorings.
preview eclipse automated refactorings allow the programmer to preview the changes before applying them.
quick assist highlights the changes in its preview window see figure and refactoring wizards show the code before and after the change side by side.
others identified a usability problem of preview windows based on a survey .
codingspectator s data provides more evidence for the underutilization of preview windows.
our interviews and quantitative results see table i show that our participants rarely previewed their automated refactorings.
we asked five of our interviewees who had used quick assist whether they had previewed the refactorings in the quick assist menu.
all of them told us that they had not previewed the changes using quick assist.
i 5told us the scope of the preview is quite small and there is also no highlighting or indentation.
so if the code is a bit more complex it can get quite difficult to understand.
i1gave the following reason for not previewing refactorings.
quick assist actions are very quick to execute and i can just look at them in the browser .
i admit i don t really enjoy looking at diffs and i prefer to get a sense of the change if it is local by un often several times.
our interviewees mentioned several reasons for not previewing refactorings.
first since they usually used the refactoring tool to perform small changes that were localized to a single method or class see subsection iv e1 they did not need to preview the change.
second one interviewee said that the preview window was not very useful because it always showed a small portion of the code.
third the overhead of inspecting the big changes presented in the previews is high.
finally two of the interviewees said that they could better review and evaluate their refactorings as they performed them manually.
for instance i 6said it manually gives me a sense of how things have changed as a design review so that i can see the different options and reevaluate my choices.
f .
configuration eclipse lets the programmer perform slight variations of every refactoring by providing a few options.
for example the extract method refactoring in eclipse .
lets the programmer control the access modifier or declared exceptions of the extracted method.
codingspectator recorded the time of opening and closing every refactoring wizard see subsection ii b .
we use the amount of time a refactoring wizard is open to estimate the time needed for configuring an automated refactoring.
based on the data our participants configured the refactoring tool in at most eight seconds in of the time.
three of our interviewees complained about the complexity of refactoring wizards.
i 4said to me whenever you go into these refactorings you have some dialogs and you have to figure out what it s and if there s one or two call sites you can still do it simply manually i think.
configuration dialogs break the programming workflow and impose an overhead by requiring the programmer to understand the options.
more configuration options may make the automated refactoring more powerful but also more complex and harder to understand.
our results provide more evidence for the disruptiveness of refactoring tools that others identified in a survey .
g. implications better training on refactorings and their tools may persuade programmers to use automated refactorings more.
however there are other obstacles to the adoption of existing automated refactorings.
for instance designers should choose more intuitive and consistent names for automated refactorings.
tools that facilitate the exchange of knowledge between programmers can raise awareness of refactoring tools.
for example a tool that uses social indicators to notify members of a software development team about the refactoring activities of other members might encourage programmers to learn more tools from each other .
a main motivation of automated refactorings is to reduce the human burden and error in making complex changes to the source code.
researchers have been proposing automated support for complex refactorings .
however our results suggest that programmers are reluctant to use automated refactorings whose outcomes are difficult to foresee.
one may expect previews to help programmers predict the results of automated refactorings.
in contrast we have shown that the current previews of refactorings are not effective.
perhaps more radical ways of reviewing refactorings are needed.
the challenge would be to present the changes distributed across the code base in a concise and precise manner.
an alternative way of reviewing the changes of refactorings is to provide facilities to inspect the changes after they are performed rather than before.
one way to present the changes after they are performed is to mark up the changes in the editor.
it might also be useful to help the programmer navigate through each part of the code that239is affected by the refactoring tool.
alternatively a graphical representation of a refactoring may be more effective for understanding the impact of the refactoring.
high cost of configuration diminishes the value of automated refactorings.
therefore the designers should make the configuration of refactorings seamless.
v. m isuse of automated refactoring tools parasuraman and riley defined misuse of automation as user s overreliance on automation.
according to their definition misuse of automation occurs when the user relies on the automation even though it would have been better to perform the task manually .
we sometimes found it challenging to judge whether a use of an automated refactoring was an overuse or clever use.
therefore we qualify the definition of misuse to better explain the phenomenon in the context of refactoring tools.
we define the misuse of an automated refactoring as use of the automated refactoring in ways not recommended by the designers.
refactoring tools are designed to preserve the behavior of the program as much as possible except when certain features of the language such as reflection or native code are involved.
the eclipse refactoring tool checks a few preconditions to ensure that it will not introduce compilation problems or change the behavior of the program.
if a precondition fails the refactoring tool reports a problem with a severity level of information warning error or fatal error .
warnings of automated refactorings attempt to predict compilation warnings.
errors of automated refactorings predict compilation errors and non behavior preserving changes.
thus eclipse does not recommend performing a refactoring with errors .
fatal errors indicate that the refactoring tool is unable to carry out the transformation and prevent the programmer from continuing the refactoring.
the rest of this section discusses some of the possible misuses of automated refactorings that we have identified.
a. unsafe refactorings when an automated refactoring reports a problem it is no longer guaranteed to be behavior preserving.
therefore we call such a refactoring an unsafe refactoring .
traditionally there has been an emphasis on the behavior preservation property of refactorings .
our study provides the first quantitative and qualitative results about programmers use of unsafe refactorings.
a programmer can handle an unsafe refactoring in two ways.
first the programmer might cancel the refactoring fix the code to satisfy the preconditions and try the tool again.
second the user could perform the refactoring and fix the problems afterwards.
the former approach provides stronger behavior preservation guarantees.
however we have found the latter to be the prevalent approach in dealing with unsafe refactoring.
according to the data collected by codingspectator our participants performed of automatedpublic int getnextnumber if new random .nextboolean return return figure .
if the extract method refactoring tool is invoked on the highlighted piece of code the tool will report the error selected statements contain a return statement but not all possible execution flows end in a return.
semantics may not be preserved if you proceed.
public class c static int i public static void main string args system.out.print system.out.print i figure .
if the programmer uses the extract local variable refactoring tool to extract the highlighted expression to a local variable named i the tool will report the warning a variable with name i is already defined in visible scope.
if the user continues the refactoring the compiler will not report any problems but the output of the program will change from 10to11.
refactorings that had reported some error or warning.
table i illustrates the probability of our participants performing each kind of refactoring in spite of a reported problem.
our participants received a total of different messages from the eclipse refactoring tool.
the following are four of the most frequent problems that the refactoring tool reported to our participants warning code modification may not be accurate as affected resource resource name has compile errors.
error found potential matches.
please review changes on the preview page.
error selected statements contain a return statement but not all possible execution flows end in a return.
semantics may not be preserved if you proceed.
warning a variable with name variable name is already defined in visible scope.
thirteen participants received the first message for a total of times and performed the refactoring of the time.
twelve participants received the second message for a total of times and performed the refactoring of the time.
figure illustrates how to reproduce an error message that the extract method refactoring reported to four of our participants for a total of times.
in of the cases our participants chose to continue the refactoring and manually adjust the compilation problems of the resulting code.
figure illustrates an example where the extract local variable refactoring warns the programmer about name shadowing.
two participants received this warning for a total of six times and performed the unsafe refactoring five times.
one might argue that programmers perform unsafe refactoring because it is easier to interpret and resolve compilation problems than unfamiliar refactoring ones .
we240asked our interviewees to explain the refactoring problems that they had received from the tool.
our interviewees had understood almost all of the error messages of automated refactorings.
only one interviewee confused two error messages of the extract method refactoring and at least two of our participants struggled with a strange error message of extract method.
in every case they were able to understand and resolve the problem eventually.
our interviewees mentioned that they relied on the compiler visual inspection and sometimes running their programs and tests to identify the possible problems of refactorings.
however visual inspection compiler checks runs of programs and tests and code reviews may not catch the subtle errors of refactorings see figure .
the interviewees gave us several reasons for performing unsafe refactorings.
first there is an overhead associated with canceling the refactoring tool and reconfiguring it.
second the chance of introducing an error when the tool reports a warning is low.
third our interviewees claimed that they were well aware of the limitations of the refactoring tool and could easily detect and fix the errors introduced by the tool.
fourth our participants ignored non descriptive messages.
for example none of our interviewees knew what potential matches meant in the aforementioned error message.
five interviewees said that they sometimes manually performed a few steps of a refactoring and intentionally introduced some compilation problems to find all other places that needed to get updated.
even though this way of performing a refactoring is slower than using the refactoring tool it is more interactive and gives more control to the programmer.
b. unjustified uses we suspect that at least two of our participants overused the refactoring tool because they told us that they always used an automated refactoring if one was available for their desired task.
however it is not always optimal to use the automated refactorings.
for example one of our participants used the change method signature refactoring to change the visibility of a method.
visibility changes could lead to subtle changes of a program s behavior.
nevertheless eclipse does not currently perform the necessary checks to guarantee the behavior preservation of such refactorings .
thus the use of the eclipse refactoring tool to change the visibility of a method especially in simple cases is questionable.
when we asked the participant about this particular use of the tool he did not have any justifications.
a combination of excessive trust in the refactoring tool and low confidence in one s coding abilities might lead to the misuse of the tool.
for example an interviewee told us that he always used the tool to perform refactorings because he was afraid of making mistakes in performing the refactoring manually.
while it is error prone to performsome refactorings manually programmers can perform the rest easily.
c. implications we suggest a few techniques for designers of refactoring tools to avoid misuse.
a high rate of false alarms may lead to mistrust of the warnings .
thus reducing the number of false positives might mitigate the misuse of automated refactorings when they report warnings.
although it is valuable to communicate the error messages better our participants performed unsafe refactorings even though they had understood the messages.
one way to mitigate the risk of unsafe refactorings is to provide specialized tools that verify the results and assist the programmers in completing the transformation.
our participants use of unsafe refactorings and reliance on the incremental compiler to perform a refactoring in small steps suggest that predictability and interactivity may be more important factors in the design of refactoring tools than behavior preservation.
if automated refactorings present some of their intermediate results become more interactive and give more control to the programmer they will become more transparent and predictable.
as a result programmers will gain a better understanding of the limitations of the automated refactorings and use them appropriately.
another technique to reduce the misuse of automated refactorings is to make the tools more flexible.
such a flexible tool will attempt to change the code to satisfy the preconditions or propose possible fixes to the programmer instead of just reporting the problem .
also we suggest that trainers warn programmers about the possible excessive trust and misuses of refactoring tools.
trainers could make programmers aware of their excessive trust in certain automated refactorings and show them how to avoid or mitigate the consequences of their misuses.
vi.
l imitations even though a study such as ours captures authentic data it raises privacy issues and makes recruitment challenging.
as a result the majority of our participants and all of our interviewees were at the university see section ii .
the confidentiality issues might have also affected the projects our participants have enabled our data collectors on.
because of the uncontrolled nature of our study the numbers of programming hours of our participants vary a lot see section ii and the number of opportunities to perform refactorings on the projects might have been different.
codingspectator did not capture data about ten automated refactorings in eclipse.
we prioritized which automated refactorings to study based on the usage statistics reported by others .
we fixed some of the bugs of our data collectors during the study and we discovered some bugs in eclipse that241may have affected our data.
however to the best of our knowledge these bugs introduce negligible noise in our data.
we collected data only from java programmers who used eclipse.
however we were able to generalize and suggest improvements to other ides based on our results.
vii.
r elated work parasuraman and riley discussed humans use misuse disuse and abuse of automation .
our work adapted their framework in three ways to automation of refactorings.
first they defined abuse as enforcing automation by designers and managers without considering the consequences on the users.
since we did not find an evidence of abuse in the context of refactorings we excluded it from our framework.
second we used a slightly different definition of misuse.
they defined misuse as overreliance on automation.
we considered uses of automated refactorings in ways not recommended by designers as misuse.
finally we have identified the factors that pertain to use misuse and disuse of automated refactorings specifically and not automation in general.
murphy et al.
s study of developers using the java tools in eclipse stimulated research in this area .
their study collected frequency data on the invoked perspectives views and commands refactorings being a subset .
their data provided a holistic view of how often various features of eclipse were used and raised questions about how users were using the features of the ides.
our interaction data collection methods are similar because we both collect data from programmers in their natural settings.
however the focus of our work was on refactorings and we supplemented our quantitative data by qualitative ones.
murphy hill et al.
analyzed a pool of existing data about refactorings from murphy et al.
the eclipse foundation and the refactoring histories of eclipse developers.
in addition they surveyed five eclipse developers.
they were the first to show some evidence for the underuse of automated refactorings and concluded that further studies are required to understand why developers sometimes choose not to use the refactoring tools.
our study builds upon theirs and discusses the impact of many factors on the underuse of automated refactorings.
for example our results suggest that trust in the state of the art refactoring tools is influenced more by usability than reliability.
in another study murphy hill et al.
examined barriers to using the extract method refactoring .
they instructed their participants to apply the extract method refactoring on a few open source projects.
they observed that users frequently made mistakes in selecting the code snippet to extract and that the error messages from the tools were hard to understand.
based on this observation they proposed visual representations of the error messages.
we also observed that selection problems were common ten of our participants encountered such problems.
however ourinterviewees informed us that they were able to interpret the messages.
this difference in results may be due to the differences of the studied populations in their levels of expertise or familiarity with the code under refactoring.
while some of the results of the two studies overlap the focus of our work was identifying the factors that deterred programmers from using automated refactorings rather than resolving a specific usability issue i.e.
bad messages of the extract method refactoring.
mealy et al.
listed guidelines for refactoring tools by analyzing the literatures of industrial usability standards and human factors .
our approaches are complementary because we proposed improvements to the design of refactoring tools based on the actual usability problems that our participants had encountered.
viii.
c onclusions our quantitative data and interviews revealed many factors that affect the appropriate and inappropriate uses of automated refactorings.
we found that programmers do not use some automated refactorings because they are unaware of them the overhead of learning and configuring some automated refactorings does not justify the few opportunities to use them the names of some automated refactorings are confusing and programmers cannot predict the outcomes of complex tools.
on the other hand programmers appreciate the tools that propose applicable refactorings and are willing to use automated refactorings even when they may change the program s behavior.
our study shows that the major barrier to the adoption of refactoring tools is their usability problems not their rare bugs.
these results suggest that designers should aim for flexible predictable and truly interactive automated refactorings in the design of next generations of refactoring tools.
acknowledgment we thank chris aniszczyk deepak azad danny dig milos gligoric nathaniel hirtz darko marinov and roshanak zilouchian moghaddam for their assistance and our participants for taking part in the study.
this work is partially supported by nsf ccf doe de fc0206er25752 the institute for advanced computing applications and technologies iacat and the universal parallel computing research center upcrc at the university of illinois.