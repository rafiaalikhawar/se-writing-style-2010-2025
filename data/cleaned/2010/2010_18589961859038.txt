veri fication driven slicing of uml ocl models asadullah shaikh universitat oberta de catalunya barcelona spain ashaikh uoc.edurobert claris universitat oberta de catalunya barcelona spain rclariso uoc.eduuffe kock wiil the maersk mckinney moller institute university of southern denmark odense denmark ukwiil mmmi.sdu.dk nasrullah memon the maersk mckinney moller institute university of southern denmark odense denmark memon mmmi.sdu.dk abstract model defects are a significant concern in the model driven development mdd paradigm as model transformationsand code generation may propagate errors to other notations where they are harder to detect and trace.
formal verification techniques can check the correctness of a model buttheirhigh computational complexity can limit theirscal ability.
in this paper we consider a specific static model uml class diagrams annotated with unrestricted ocl constraints and a specific property to verify satisfiability i.e.
is it possible to create objects without violating any constraint?
.
current approaches to this problem have an exponential worst case runtime.
we propose a technique toimprove their scalability by partitioning the original modelinto submodels slices which can be verified independently and where irrelevant information has been abstracted.
the definition of the slicing procedure ensures that the propertyunder verification is preserved after partitioning.
categories and subject descriptors d. .
design tools and techniques d. .
software program verification d. .
language classifications i. .
problemsolving control methods and search general terms verification keywords mdd uml ocl model slicing formal verification permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for pro fit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior speci fic permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.
.
introduction model driven development mdd advocates for a shift in the software engineering process using models instead of code as the primary development artifact.
within mdd tool support for model design analysis and transformation is essential and scalability is an important requirement.
thereareformalverificationtoolsforautomatically checking correctness properties on models but the lack of scalability is usually a drawback and its improvement will be thegoal of this paper.
we will consider the analysis of the staticelements of a software specification modeled as a uml classdiagram.
complex integrity constraints will be expressed in the object constraint language ocl .
in this context the fundamental correctness property of a model is satisfiability is it possible to instantiate the model without violating any integrity constraint?
.
this property is important not only because it can point out inconsistent models but also because it can be used to check other interesting properties like the redundancy of an integrity constraint.
for example a pair of constraints c 1and c2are not redundant if the following is satisfiable c1 c2 c1 c2 i.e.
it is possible to satisfy c1but notc2or vice versa.
reasoning on uml class diagrams without ocl integrity constraints is an exptime complete problem .
furthermore the addition of unrestricted1ocl constraints makes theproblemundecidable.
currentsolutionsforcheckingsatisfiability employ formalisms such as description logics higher order logics database deduction systems linear programming sat or constraint satisfaction problems .
however all the approaches which support general ocl constraints share a common drawback a highworst case computational complexity.
their execution timemay depend exponentially on the size of the model under standingsizeasthenumberofclasses attributes associations in the model and or the number of ocl constraints.
a review of sample uml ocl models highlights two observations which are relevant to this problem.
first models 1some approaches restrict the set of supported ocl constructs e.g.
to make the verification decidable.
in this paper weconsider general oclconstraintswith nolimitations on their expressivity.
figure high level description of the slicing process.
typically contain elements which are either unconstrained or constrained in a trivially satisfiable way.
for instance attributes acting as identifiers should have unique values butoften there are no other constraints on these attributes.
asecond observation is that some constraints refer to indepen dent entities.
for example constraints about the passwordofauserandthepriceofaproductarelikelytobeunrelated.
these observations can be used to improve the scalability of verification methods for satisfiability.
our proposal isbased on model slicing given an input uml ocl model the diagram and its constraints will be automatically partitioned into submodels while abstracting unnecessary model elements.
the structure of the class diagram associations and class hierarchies and the ocl invariants abstract syntax tree will guide the partitioning process.
intuitively theunderlying idea is that all constraints restricting the samemodel element should be verified together and therefore be long to the same slice.
then satisfiability of each slice ischecked independently and the results are combined to assess the satisfiability of the entire model.
figure illustrates the overall flow.
to ensure soundness slicing should not al ter the outcome of the verification.
theremainderofthepaperfocusesonthedefinitionofthe slicing algorithm and the evaluation of its benefits.
section introduces a running example and a more detailed overview of the slicing procedure.
section focuses on the analysis of ocl constraints while section explores the structuralanalysis of theclass diagram.
section 5describes experimen tal results measuring how slicing reduces verification time.section shows a larger real world case study where the benefits of slicing are illustrated.
in section related work is presented.
finally section provides the conclusions andidentifies directions of future work.
.
overview of uml ocl slicing the approach the input of our method is a uml class diagram annotated with ocl invariants.
as an example figure introduces class diagram that will be used throughout the paper modeling the information system of a bus company.
several integrity constraints are defined as ocl invariants.
our goal is to determine whe ther the input cl ass diagram has legal instances thatis instances thatsatisfy all integrityconstraints.
an instance of a uml class diagram is a collection of objects according to the class definitions and a collection of links between them according to the associa tions .
the output of the tool will either be satisfiable or unsatisfiable .
in case of satisfiability a sample instance proving the satisfiability will be computed as well.
two different notions of satisfiability will be considered for verification strongand weaksatisfiability .
aclass diagram is weakly satisfiable if it is possible to create a legal instance which is non empty i.e.
it contains at least one object from someclass.
on the other hand strong satisfiability is a more restrictive condition requiring that thelegal instance has at least one object from eachclass and a link from eachassociation.
some parts of the slicing algorithm will work differently depending on the satisfiability notion being verified.
the algorithm works by partitioning the uml ocl class diagram intoa setofdisjoint slices.
aslice sofauml ocl class diagram dis a subset of the original model another valid uml ocl class diagram where any element class association inheritance aggregation invariant ... appearing in salso appears in d but the reverse does not necessarily hold.
figure represents the slices for strongsatisfiability.
each slice is verified independently and theverification result of the whole model is obtained by com bining the results of all slices.
if we are checking strongsatisfiability it is necessary to check whether allslices are strongly satisfiable.
onthecontrary if we are checkingweaksatisfiability it is sufficient to ensure that at least one slice is weakly satisfiable.
preserving satisfiability thefundamentalrequirement of this procedure is that it should preserve the outcome of theverification theanswer providedbytheverificationwith slicing should be the same as the one given by a verificationtool without slicing.
each slice is a disjoint subset of the integrity constraints and a disjoint fragment of the original class diagram.
as each slice is less constrained than the original model it is clear that if the original model was satisfiable the slices will also be satisfiable.
therefore it is only necessary to ensurethat if the original model was unsatisfiable the answer willalso be unsatisfiable if we are checking strong satisfiabil ity at least one slice will be strongly unsatisfiable and if we are checking weak satisfiability all slices will be weakly unsatisfiable.
a formal proof is out of the scope of this paper but we will try to provide some insight on how satisfiabilityis preserved.
a class diagram can be unsatisfiable due to several reasons.
first it is possible that the model provides inconsistent conditions on the number of objects of a given type.
inheritance hierarchies multiplicities of association or aggregation ends and textual integrity constraints e.g.
type allinstances size can restrict the possible number of objects of a class.
second it is possible that thereare no valid values for one or more attributes of an object inthe diagram.
within a model textual constraints provide the only source of restrictions on the values of an attribute e.g.
self.x .
finally it is possible that the unsatisfiabilityarises from a combination of both factors e.g.
the values of 186context coach invmincoachsize self.noofseats context coach invmaxcoachsize self.trips forall t t.passengers size noofseats context trip invcorrecttripdestination notself.origin self.destination context ticket invuniqueticketnumber ticket allinstances isunique t t.number context ticket invmachinenumber self.name self.vendingmachine.bookingoffice.location.concat self.number.tostring context passenger invnonnegativeage self.age figure uml ocl class diagram used as running example model coach .
some attributes require a certain number of objects to be created which contradict other restrictions.
to sum up an unsatisfiable model either contains an unsatisfiable textual or graphical constraint or an unsatisfiableinteraction between one or more textual or graphical constraints i.e.
the constraints can be satisfied on their own but not simultaneously.
to ensure that unsatisfiability is propagated into the slices three conditions should be guar anteed .
no potentially unsatisfiable constraint should be removed from the problem.
.
if there are two or more constraints whose interaction couldbeunsatisfiable noneofthemshouldberemoved from the problem.
.
all constraints referring to the same model element should appear together in the same slice i.e.
their interaction should not be split into different slices.inordertoensurethatconditions hold theuml ocl model has to be analyzed before slicing.
the analysis should reveal which parts of the model can be abstracted or parti tioned safely.
the following sections focus on this analysisat two levels uml and ocl.
in section a traversal of the syntax tree of each ocl constraint identifies which classes attributes and navigations are being restricted.
additional analysisidentifiestrivialconstraintsandconstraintsthatcanbecheckedindependently.
insection4 dependenciesamongthe number of objects in each class like inheritance hierar chies or multiplicity constraints are studied.
.
analysis of ocl constraints ocl allows the definition of expressions on uml models.
an expression which evaluates to true or false e.g.
a class invariant will be called a constraint .o c lc a na l s ob eu s e d to define the result of query operations which can then be invoked inside other expressions.
187invariant support attributes navigations mincoachsize coach coach.noofseats none maxcoachsize coach trip passenger coach.noofseats travels uses correcttripdestination trip trip.
origin destination none machinenumber vendingmachine ticket name number sells has bookingoffice ticket bo.location uniqueticketnumber ticket ticket.number none nonnegativeage passenger passenger.age none table support attributes and navigations in the running example.
figure slices for the verification of strong satisfiability in the running example.
any ocl expression is defined within the contextof a type.
typically an ocl expression involves several objects from one or more classes of the model.
to get a starting object we can use the keyword self which denotes an object of the context type or the method allinstances which can be used to access all objects of a given type e.g.
trip allinstances returns a set of all objects of class trip.
given an object ocl provides operators to read the values ofitsattributes attribute access andaccesstheobjectsconnected to it through associations navigation .
combining these operators with arithmetic logic and relational opera tors iterators and user defined query operations it is possi ble to write complex constraints about uml models.
this section describes how to analyze ocl invariants in order to extract information relevant to its satisfiability.
weare interested in identifying which model elements are con strained by an invariant as interactions between constraintsappearwhentwoormoreconstraintsrestrictthesamemodelelements.
.
constraint support the supportof an ocl expression is the subset of classes of the class diagram referenced by the expression.
if the expression is a query operation it contains the types whose objects are explored to evaluate the query.
for invariants the support describes the set of classes restricted by the constraint.
this information will be used identify classes thatappear together in the same constraint and therefore mustbe analyzed within the same slice.
formally the support ofan expression econtains the following types .
the context type where eis defined and all its supertypes as long as the self variable appears withine.
.
the type of each association end navigated within e. .
each type referenced explicitly in eby the operation type allinstances or by a type check or conversion operation e.g.
ocliskindof oclistypeof oroclastype.
.
the union of the supports of all query operations invoked from e. another piece of information required by the remaining analysis steps is the set of attributes and navigations used in each invariant.
this information can be gathered with a straightforward traversal of the ocl syntax tree.
table summarizes all this data for the invariants of the runningexample.
.
local and global constraints someparts of a verification problem can be checkedin isolation within the boundaries of a class and without affecting the big picture.
intuitively if there is a constraint on an attribute which is not used anywhere else in the model we can split the verification problem in two separate subproblems checking that the constraint on the attribute is feasible and verifying the rest of the system.
this section will present the tools to identify these local constraints.
an expression is called local to a class cif it can be evaluated by examining onlythe values of the attributes in one object of class c. expressions that do not fit into this category because they need to examine multiple objects of the same class or some objects from another class are calledglobal.
in other words a local expression can be defined as follows a it does not use navigations through associations and b it does not call allinstances c it does not use attributes defined in a superclass d it does not call any global query operation and e it does not perform any typecheck or type conversion operation.
table shows some ex amples of local and global expressions written in the contextof class trip.
some attributes may appear in local constraints global constraints or both.
we are interested in detecting thoseattributes that can be studied locally like those that do notappear in global constraints and are notrelated to attributesthat appear there.
in this sense the set of globalattributes will be iteratively defined as follows a the attributes used in global expressions plus b the attributes used in local expressions where there is at least one global attribute.
all other attributes of the model will be called local.a l o c a l expression which uses only local attributes will be called strongly local .
it should be noted that according to our definition the result of a strongly local invariant does not depend on a at tributes outsidethose mentioned in the expression or b the 188type expression context trip description local self.origin negationslash self.destination attribute access global notself.passengers isempty navigation global ticket allinstances isunique t t.number allinstances global self.oclistypeof privatetrip oclistypeof table examples of local and global invariants.
pattern condition type allinstances isunique at key constraint if attribute is not constrained anywhere else.
self.at op exp derived value constraint if attribute is not used anywhere else and expression does not involve attribute.
ao rb trivially satisfiable if either aorbare satisfiable.
aa n db trivially satisfiable if either aand bare satisfiable.
a implies b a b trivially satisfiable if either aorbare satisfiable.
not a trivially satisfiable if ais trivially satisfiable and it is not a key constraint.
self.navigation isunique at trivially satisfiable if attribute is not used anywhere else.
table patterns with conditions number of objects in any class.
the only chance of potential interaction with other invariants is with other strongly local invariants of the same class if they have any attributein common.
therefore strongly local invariants of a classcan be analyzed separately from the rest of the model.
the division into subproblems is the following a problem defined by the class its local attributes and its strongly local invariants which can be furtherpartitioned if these invariants restrict disjoint sets ofattributes .
anotherproblemdefinedbytheoriginalmodel removing the attributes and constraints that appear in thefirst subproblem.
in our running example invariants mincoachsize nonnegativeage and correcttripdestination are all local invari ants.
of these invariant mincoachsize is not strongly lo cal as the attribute noofseats is also used in the globalinvariant maxcoachsize.
the remaining invariants non negativeage and correcttripdestination can be abstractedfrom the model together with the attributes they reference and their satisfiability can be checked independently.
.
trivially satis fiable constraints a final analysis that can improve the efficiency of satisfiability verification is the detection and removal of trivially satisfiable invariants from the uml ocl class diagram.
detecting satisfiable constraints is as hard as satisfiability itself so we restrict ourselves to consider typical patterns which may arise in different applications.
the first trivially satisfiable pattern which can be safely removed is the key constraint stating that a given attribute must be unique e.g.
type allinstances isunique obj obj.attr .
if the attribute is of type integer float or string and it is not referenced by any other constraint it can be trivially satisfied a different value can be assignedtoeachpotentialinstance e.g.
...theverificationengine does not need to spend time computing the value of the attributein each object and enforcing uniquenessamong different objects.another trivially satisfiable pattern which can also be removed is the derived value constraint where the value of one attributedependsonthevaluesofotherattributes.
thepat tern is self.attrib op expression where attribis an attribute of a basic type boolean integer float string not constrained by any other constraint opis a relational operator negationslash a n d expression is a safe ocl expression which does not include any reference to attrib.b y s a f e we mean a side effect free expression which cannot evaluate to the undefined value in ocl oclundefined .
this meansthat we do not allow divisions that can cause a division byzero or collection operations which are undefined on empty collections like first .
intuitively this constraint cannot make the model unsatisfiable if an instance for the rest of the model can be cre ated it is simply a matter of evaluating expression to find out the right value of attrib.
the conditions on expression no self