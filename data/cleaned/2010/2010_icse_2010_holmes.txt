customized awareness recommending relevant external change events reid holmes department of computer science engineering university of washington seattle wa usa rtholmes cs.washington.edurobert j. walker department of computer science university of calgary calgary ab canada walker ucalgary.ca abstract it is often assumed that developers view of their system and its environment is always consistent with everyone else s in practice this assumption can be false as the developer has little practical control over changes to the environments in which their code will be deployed.
to proactively respond to such situations developers must constantly monitor a ood of information involving changes to the deployment environments unfortunately the vast majority of this information is irrelevant to the individual developer and its sheer volume makes it likely that infrequent change events of relevance are overlooked.
as a result errors may arise at deployment time that the developer does not immediately detect.
this paper presents a recommendation approach for ltering the ood of change events on deployment dependencies to those that are most likely to cause problems for the individual developer.
the approach is evaluated for its ability to drastically lter irrelevant details while being unlikely to lter important ones.
the relevance of the results is assessed on the basis of deployment problems that would have historically occurred within a set of industrial systems.
categories and subject descriptors d. .
distribution maintenance and enhancement k. .
management of computing and information systems software management software maintenance h. .
user machine systems human factors general terms human factors reliability design experimentation keywords change events deployment environment external dependencies information overload developer speci c awareness customized awareness recommendation system yoohoo.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.
.
introduction a basic assumption of many development approaches is that every member of an organization or group of organizations always has a consistent view of their system modulo any changes each developer is currently work on.
because of this model it is assumed that any change a developer makes to their source code will be immediately noticed by everyone else.
unfortunately this assumption does not always hold in practice .
as systems are rarely written entirely from scratch building instead atop existing frameworks libraries and other systems changes to this existing code have the potential to impact the developer.
for example one approach to support the extension of systems is through a plug in infrastructure.
the plug in developer must cede some control over the external environment in which the plug in can be installed while the developer created the plug in in a development environment that used version nof a framework a user may try to deploy the plug in in an environment that uses version n k. if the developer is not aware of the changes between the two framework versions that will a ect their plug in the plug in may fail and it could take a long time before the developer hears of and responds to the problems.
as a concrete example the eclipse metrics plug in is dependent on code from external projects while its developers made only le revisions to their own code between and the systems that metrics depends on made le revisions an overwhelming volume of changes to keep abreast of especially considering the majority of these changes will not impact the relatively small functionality from each external project on which metrics depends.
current plug in infrastructures do not su ce to eliminate such issues at best the developer can prohibit deployment if a too new version of a framework would be used but developers are understandably reluctant to prohibit deployment before they know that a problem actually exists it would immediately and often unnecessarily limit who could deploy their plug in.
although the plug in developer may not be a member of the team that maintains the framework their plug in can still be a ected by the actions of an external framework developer.
the main problem in such situations is that some external change may occur that could break the developer s code when it is deployed but the developer will not immediately be aware of it .
the time delay between the change being made and the problem being detected exacerbates the e ects of the problem as users opinions of the quality of the product or the time available for repairing theissues can be severely reduced.
furthermore such a delay impedes the developer s ability to inform the author of the initial change of the detrimental impact of the change and to have them respond with a reasonable compromise .
it has been shown that facilitating communication between the right people can decrease the time required to resolve technical problems .
one way to avoid these situations is for the developer to monitor all the changes happening to externally dependedupon projects and to act upon these immediately.
ultimately keeping track of all these projects and their changes while being focused on the repair and extension of the developer s own product is an onerous task that is easy to perform poorly .
the majority of these external changes simply are not relevant to the developer s own code the few that are relevant can easily be lost in the noise.
to overcome the burden of managing a high volume of mostly irrelevant changes and the e ort required to monitor changes across many di erent projects we present the yoohoo system.
yoohoo analyzes each change to a dependedupon project for its potential impact on the developer s code and thereby creates custom change event streams that recommend change events as relevant to a speci c developer.
we evaluated yoohoo s ability to reduce the level of noise while not suppressing impactful events by examining the historical changes to a set of industrial systems.
for each system we obtained an old version along with its deployment environment analyzed its external dependencies and used yoohoo to see which change events on these dependencies would have been announced to the system s developers.
to quantify the confusion matrix we analyzed whether these events would have caused problems in deployment and whether they were ever actually acted upon by the system s developer.
we found that the cumulative true positive rate was and that the cumulative false positive rate was nearly .
in addition we examine the prospects for reducing the potential false positives and false negatives in the rare circumstances where they could conceivably occur.
section 2describes two problematic scenarios where customized awareness of external changes could be bene cial.
related work is provided in section .
our approach is described in section while our evaluation is detailed in section .
remaining issues are discussed in section .
.
motivation we illustrate two problematic scenarios involving keeping appraised of potential deployment problems due to changes in externally depended upon projects.
.
large development teams large development teams are often split into many subteams each of which works on an isolated branch of the main source code repository.
integration engineers integrate these branches with the head of the repository at regular intervals and reverse integrate the head back down into each of the sub team branches.
for some large teams their branch may be integrated with the head of the repository only twice a month in these situations it could take as long as a month for a change from one team to be distributed to every other developer on all the sub teams two weeks up and two weeks back down into all other branches .
consider the situation of elliott a developer on the subteam that maintains the core component of a large applica tion.
elliott needs to make a change to the calculate .. method s pre conditions in the core component he searches the repository and nding no con icts makes the change.
one month later lorenzo a developer on the ui component sub team nds that his code has broken.
although he did not change anything the integration engineers reverseintegrated elliott s changes into his development branch overnight and his calculateaction class breaks elliott did not nd lorenzo s dependency because his code had not yet been integrated into his repository.
now lorenzo must diagnose the problem le a bug with the core team and x elliott s code temporarily until the o cial changes are distributed through another integration cycle.
the time lag in this scenario makes it di cult to assess the original failure and increases the likelihood that another developer may take a dependency on the o cial but incorrect version of the calculate .. method rather than the version that elliott will create in response to lorenzo s bug report.
while this bug may have been avoided if lorenzo had noticed elliott s change to calculate .. when it happened keeping abreast of changes on a single sub team is di cult enough without considering other development branches.
.
plug in infrastructures consider the situation of stefania an eclipse plug in developer.
her plug in uses functionality from ve di erent eclipse plug ins two apache projects and one system she found on sourceforge.
when laura installed stefania s plug in into her environment it failed to behave as she expected.
after several frustrating rounds of emails stefania realizes that laura has new versions of three of the eight external dependencies that her plug in uses.
keeping up on the changes of these eight projects is overwhelming so stefania never realized her code was a ected by any of the changes these projects had made after debugging her plugin with the new versions of the dependencies she is able to resolve laura s problem.
in this scenario laura has changed the external environment for stefania s plug in in a way that the plug in was not designed to accommodate.
while stefania ideally would have kept herself current on changes within eclipse the apache projects and the sourceforge project the sheer volume of changes overwhelmed her ability to track them.
.
drinking from the fire hose in both of our motivational scenarios environmental changes beyond the control of the developer introduced errors into his or her system at deployment time.
if the developer kept appraised of these external changes the code could have been adapted to work with the modi ed environment however keeping appraised can be very expensive.
figure 1gives a sample of the arcane detail that further obscures the actual signi cance of an individual commit message table 1demonstrates the volume of commit messages for a year period for several projects.
reading each message interpreting its key content and analyzing its potential impact on one s code would be an enormous chore.
.
related work gross and prinz describe the need to present awareness information in the context of the user s current work activities but do not go beyond a general model our focus on thesubject refactoring.java fixing npe from jan p. jp... at netbeans.org message id hg.abbaf0f1ff63.
.
at hg.netbeans.org date changeset abbaf0f1ff63 in main details baf0f1ff63 description fixing npe diffs lines diff r eb7c38562250 r abbaf0f1ff63 a refactoring.java src org netbeans modules refactoring java ui uiutilities.java b refactoring.java src org netbeans modules refactoring java ui uiutilities.java aug public final class uiutilities headerrenderer table.gettableheader .
getdefaultrenderer component comp headerrenderer.
gettablecellrenderercomponent null column.getheadervalue false false table column.getheadervalue false false int width comp.getpreferredsize .width figure a sample netbeans commit message.
speci c problem of maintaining awareness of environmental changes allows for a solution that can eliminate details that are irrelevant to an individual developer.
cataldo et al.
demonstrate that developers complete tasks more quickly when they are able to coordinate with the right people our approach is complementary to theirs focusing on inferring relationships between developers from the source code rather than explicitly provided links extracted from issue tracking systems.
the need for coordination support in software development has long been recognized e.g.
.
much of this research has focused around software con guration management scm systems as the key interaction point e.g.
.
various work has considered the problem of con icting edits within team development situations e.g.
our problem is signi cantly di erent due to its lack of a single consistent repository to analyze.
de souza et al.
identi ed problems in crossing the boundary from project private information to project public information that lead to rough transitions even within teams despite the application of tools that support it.
coordination and change awareness have moved beyond the artifacts contained within scm systems by also drawing upon the process related metadata contained therein we continue this trend in our approach.
the jazz system provides the concept of a feedthat lists project total daily freebsd kde linux kernel mysql netbeans open o ce table message tra c on the commit mailing lists for several prominent software systems between june and may .
daily average is based on workdays week weeks year.many recent changes to the system and provides an overview of what other team members are working on we adapt the feed concept to a narrow focus on what relevant changes have occurred.
mylyn elides various elements in an ide to help the developer focus on their current task the developer s current task is largely irrelevant in our context.
continuous integration ci tools can help a project team stay appraised of changes builds and tests examples of these systems include trac1and cruise control.
unfortunately ci tools do not currently address version changes between organizations e.g.
external changes or automatically con gure new deployment environments.
we view our approach as being complimentary to ci tools and could foresee integrating them to deliver project speci c rather than developer speci c noti cations.
fitzpatrick et al.
have examined the coordinated use of scm systems noti cation lists and instant messaging in coordination.
all these approaches su er the same issues of information overload for external developers who depend on them .
palant r provides an online view of how developers are modifying their source before it is committed enabling developers to predict future changes .
fisheye is one of many commercial products used for visualizing the overall activity within an scm repository.
the war room command console and fastdash provide realtime awareness systems to teams showing who is working on what code elements at any one time.
each of these approaches provides a global view that while useful for various purposes does not meet the needs of developer speci c support.
sarma et al.
have also examined the needs of multiple teams working in concert on shared artifacts and extended palant r to support it sarma et al.
have also performed notable work in evaluating awareness in scm systems .
however their situation is quite di erent from our producer consumer context.
ideally we would analyze the precise semantic e ects of the changes made in external projects unfortunately this is not possible in the general case due to formal undecidability .
otherwise we might detect changes in external application programming interfaces apis and recommend changes to the developer s client code however for some projects such recommendations will not be possible due to a lack of example transformations to mine.
furthermore the correct course of action may not be as simple as replacing one method call with another.
there are a number of techniques for di erencing source code versions to detect and classify changes a necessary step if they are to be ltered on the basis of category a notable recent representative is the change distiller approach of fluri et al.
that we apply in our solution.
canfora and cerulo demonstrate that ne grained indexing of change repositories can help to track which changes were made to address which bugs we apply a similar technique to track ne grained changes.
.
approach to combat the volume of irrelevant change noti cations we present yoohoo a system for recommending external change events as impacting a speci c developer.
1we do not provide urls for tools that are easily located via a web search.yoohoo has been designed to improve the key shortcomings of general change noti cation systems by providing the following three bene ts.
yoohoo only provides developers with recommendations about changes that are relevant to them.
every change noti cation that the developer receives will be provided because a change was made to a resource that their code is dependent upon.
through this ltering mechanism yoohoo eliminates the vast majority of change noti cations.
yoohoo categorizes changes by their potential to impact the speci c developer s source code.
this categorization enables them to further reduce the message tra c that they must consider by enabling them to ignore changes that are unlikely to break their deployed code if they so choose.
yoohoo integrates the change noti cations from many isolated data sources enabling potentiallyrelevant changes to be considered in a single location.
simply locating and navigating through each repository places a high burden on developers.
yoohoo has two main kinds of component generic change analysis gca engines each of which delivers a stream of change events about a project without tailoring to the needs of an individual developer and developer speci c analysis dsa engines each of which selects a set of gca engines based on the project dependencies of the developer and lters and re nes the generic change event stream based on an estimate of the change impact on the developer s code.
as a result the developer receives recommendations about changes to his code s deployment environment that are very likely to cause failure plus purely informational noti cations about api changes and other project related information that are estimated to be of interest to him.
gca engines typically run alongside the scm that they monitor while dsa engines run on the client s machine typically within an ide .
a central yoohoo gca dispatcher connects dsa engines with the gca engines they require.
yoohoo presently only analyzes changes to java source code.
.
generic change analysis engines each gca engine monitors a source control repository adapters for cvs and subversion are currently supported for commit events and alterations to repository tags and branches.
when a change to the repository is detected it is analyzed and one or more change events are recorded in the engine s internal database.
when a gca engine is initialized it can be set to follow a particular development tree e.g.
the repository head or a speci c branch to reduce the number of false positive changes it detects e.g.
to avoid reporting changes on an experimental branch that will never be integrated into the main development tree .
each gca engine provides a communication interface for clients to obtain change events based on their generic impact timestamp and structural name.
the gca engine can also compare sets of les instead of using a source control repository.
for example the changes between the standard libraries provided by java .
j2se .
and java .
java se can be inferred by comparing the source of the two versions.
the drawback of performing an analysis at the le level is that all the changes are grouped into a single revision set and the additional metadata provided by the scm repository is absent.
by not requiring access to the scm repository the gca can compute changes for situations where the scm repository is unavailable e.g.
prior to java se the java standard library scm repositorywas not publicly accessible .
this mechanism also enables changes to be determined on a release by release basis by only analyzing signi cant copies of the repository rather than incremental changes as they are made.
our gca engine prototype implementation utilizes the change distiller system as a preliminary means to analyze the changes.
by analyzing the abstract syntax trees asts associated with a le before and after a commit change distiller can classify the change into one of different categories.
yoohoo collapses some of these categories e.g.
condition change and statement change are currently treated simply as implementation change and adds others e.g.
entity deprecated to announce events at a granularity that seems most relevant to detecting api changes that might impact some developer in some situation.
the kinds of change events currently recorded are listed in table we currently make no attempt to detect compound events such as refactoring e.g.
a pull up refactor would delete a method from one type and add a new identical method further up the type hierarchy .
we discuss the costs and bene ts of such extensions in section .
.
potentially impactful events non private type method eld added non private type method eld deleted non private eld type changed non private method result type changed type method eld visibility increased type method eld visibility decreased type method eld deprecated type method eld undeprecated type method eld nalized type method eld un nalized supertype added supertype removed implementation changed potentially informative events new branch new tag javadoc modi ed table change events announced by gca engines.
.
developer specific analysis engines each dsa engine consists of three subcomponents code ownership analysis external dependency analysis and change impact estimation .
.
.
code ownership analysis dsa engines can automatically determine the les of relevance to an individual developer.
automatic analysis determines which les a developer has recently committed a con gurable horizon based on le age or number of intervening revisions can be used to ignore les that have not been altered by the developer for some time or for which someone else seems to have taken over the maintenance.
the developer can also indicate individual les packages or projects that are always to be ignored or always to be watched overriding the automated analysis.
.
.
external dependency analysis once the developer s set of watched resources has been identi ed the dsa engine then determines the external dependencies that those resources have.
dsa engines are currently implemented as plug ins to the eclipse ide allowing them to utilize project information about depended upon versions of external projects.
by statically analyzing the source code and project information a dsa engine identi es all the elds accessed methods called types accessed and subtype relationships within the resources of interest.
this set provides yoohoo with a watch list of external resources that the developer is dependent upon and is automatically updated on a semi regular basis to ensure the correct dependencies are being monitored.
changes made to resources that are not in this set are ltered by yoohoo as irrelevant to the developer.
yoohoo can then determine which external resources already have associated gca engines and points the developer s dsa engine to these.
the developer is warned about external resources without associated gca engines by proving a location for the appropriate repository along with the appropriate authentication credentials where needed yoohoo automatically constructs and populates a new gca engine for each.
.
.
change impact estimation dsa engines periodically retrieve change events for the developer s dependent resources based on their timestamp generally since the engine s last access or from a speci c date if yoohoo is freshly deployed by the developer .
change events not related to the dependencies in the watch list are immediately ignored.
all other events are further analyzed to categorize their severity of impact on the developer s code impactful events.
animpactful event is one that the dsa estimates is likely to break the speci c developer s code in some way.
these generally involve changes that alter the external appearance of an api.
uncertain events.
these events cannot be ruled out as breaking the developer s code though it is unlikely.
uncertain events arise due to our imprecise analyses.
in some cases a more precise analysis is readily available that a future version of yoohoo could apply see section .
.
other cases involve potential behaviourbreaking changes that have a remote chance of propagating through an api.
pragmatism suggests that internal implementation changes will very rarely propagate through the api unless the api itself changes which is after all the purpose of an api.
in the end alluncertain events could be recategorized usefully we have retained them at this point to study whether they are really problematic or not see section .
information events.
information events indicate a change that the developer might want to be aware of if they have the time to consider alternative implementations or changes that involve the depended upon entities that do not de nitively have an impact e.g.
updated documentation .
the resulting kinds of events and their severity are listed in table where dependency is de ned as statically making reference to the entity in question.
the current implementation does not attempt to be very precise in its impact analysis for example the removal of a supertype relationship is always recommended for attention impactful evenimpactful events depended on type method eld deleted depended on eld type changed depended on method result type changed depended on type eld method deprecated depended on type eld method visibility decreased uncertain events depended on type eld method nalized type method eld added to depended upon type supertype removed from a depended on type supertype added to a depended on type implementation changed for depended on method information events public type added to depended on package depended on type method eld visibility increased depended on type method eld undeprecated depended on type method eld un nalized new tag in depended on project source repository new branch in depended on project source repository table developer speci c change events as classied by default by a dsa engine.
though it will not matter if the original supertype is not explicitly depended upon like in a cast expression if the methods inherited from it are to be found elsewhere in the remaining hierarchy or if the methods inherited from it are not depended upon at all.
we consider the costs and bene ts of re ning the classi cation analysis in section .
.
the developer can choose to downgrade or upgrade event classi cations on a global or per project basis.
for example he may be aware that parts of his code depend tightly on the current structure of the type hierarchy such as which type implements a given method so changes to the hierarchy will de nitely have to be checked he would likely make supertype changes impactful rather than uncertain in such a situation.
finally recommendations for relevant change events need to be announced to the developer.
our current implementation is simple in this regards presenting results in an eclipse view for each externally depended upon project see figure .
as the goal of our prototype implementation is to evaluate whether such a classi cation and ltration approach would actually signi cantly reduce the ow of events without missing many important changes i.e.
the usefulness of the approach this su ces.
a more usable real world deployment could involve in line noti cations like eclipse s lightbulb marginal annotations and or underlining annotations see figure 3for a mock up .
as yoohoo knows both how a depended upon element changed and how the developer used that element change noti cations can be very speci c for the developer.
rather than a generic statement like itableselectionlistener has been deprecated yoohoo can be more speci c and report itableselectionlistener from the jface project has been deprecated your iresultsview interface is impacted.
this kind of message is much more meaningful for the developer and can even point them in the right direction for resolving the problem.figure developer speci c change awareness view.
figure mock up of an annotation based noti cation alternative.
.
application to the motivational scenarios yoohoo should enable developers to keep appraised of all the relevant changes happening on multiple branches of a source code repository or to follow the development of a large framework without being overwhelmed by irrelevant changes.
yoohoo also enables the rationale for the change s relevance to be viewed by the developer e.g.
in the rst scenario yoohoo could state to lorenzo that elliott changed thecalculate ... method signature this will cause an error in your calculateaction class.
in the rst scenario lorenzo s yoohoo noti cation stream would alert him to anyimpactful changes made to code that he depends upon across any development branch in the repository.
in this way he could contact elliott immediately about how he would be impacted or to immediately respond by modifying his calculateaction class.
for the second scenario using yoohoo stefania could monitor all the changes in her dependent projects without becoming overwhelmed rather than having to sift through thousands of changes yoohoo would promote at most tens of changes for her to react to.
in both of these situations the developer is able to act proactively to changes in external resources rather than reacting to breakage when it happens.
.
evaluation our evaluation addresses four main research questions rq1 how well is the change event stream compressed?
rq2 are the impactful events actually impactful?
rq3 are any impactful events erroneously ltered?
rq4 would a simple approach to surfacing informational but non impactful events again ood the developer?
we performed a retroactive analysis of deployed projects to answer the questions.
these projects were selected arbitrarily from a set of eclipse based tools that we were familiar with that we considered to be somewhat mature.
as eclipsecomprises a large number of plug ins more than in version .
and also heavily uses many other external projects more than in version .
it seemed like an ideal platform to study.
the projects were metrics source code metric calculator.
rssowl cross platform rss reader.
asm plugin bytecode instrumentation integration.
colorer multi language syntax highlighting.
checkstyle coding standard enforcement tool.
table 4describes the number and kinds of external dependencies in each of the analyzed projects.
.
methodology and results in order to watch change events on these projects and various others that we tested yoohoo on while developing it we ultimately created gca engines for individual projects including eclipse projects and apache projects .
these repositories consisted of the entire length of history we could extract from each project s source repository in the case of eclipse this history was generally available from to present.
this required analyzing more than mloc of source code.
the gca repositories ultimately contained information about revisions to resources by system external dependencies projects types methods fields metrics rssowl asm colorer checkstyle table quantity of external dependencies.project external changes yoohoo recommendations or dev.
start end rev.
sets revs.
events impactful uncertain info.
irrelevant metrics sauerf donv70 rssowl bpasero ijuma asm plugin colorer checkstyle table scale of revision sets and of external changes made during the evaluation period.
developers resulting in over change events.
while populating this initial repository took several days keeping the repository consistent took less than one minute per indexed project per day and this is fully parallelizable .
rq1 event stream compression.
for each of the analyzed projects we selected a start and end date for the analysis.
we built each project and extracted its structural dependencies as these existed on the start date.
building these projects correctly several years after the fact was laborious3 thus we did not revise our analysis of the structural dependencies for the project for the length of the study ultimately this choice did not appear to cause problems with the results of the study .
we generated the dsa change feeds for each project as well as at least one speci c developer on that project on the end date.
this list comprised all the impactful information and uncertain events for the developer or project as well as a count of the irrelevant events.
these results can be found in table clearly demonstrating the answer to research question rq1 the cumulative compression of these change event streams is well over .
rq2 correctness of impactful recommendations.
to analyze the accuracy of yoohoo s classi cations we examined the ltered event stream for a putative developer who owned the entire project to be analyzed.
the small number of impactful events were manually inspected to determine their nature and whether a corresponding change was ever made by august to adapt to the change.
by building the version of the system from the start of the study period but with the version of the project s external dependencies at the end of the study period we were able to use the code itself as an oracle any compilation errors that arose should have been recommended as impactful by yoohoo.
we compared the compilation errors against the yoohoo impactful events any error that was not reported as impactful was considered a false negative.
we also looked at the state of the code to con rm that each error listed as impactful by yoohoo was also really xed by a developer these were considered true positives while if the developer did not make the change or they were not really impactful they were considered false positives.
some events are deliberately recommended for attention although 3note that this di culty is purely an artifact of our evaluation.
yoohoo does not need to build projects to perform its function.the developer has the option to do nothing about them in particular deprecation events we always count these as true positive events regardless of whether an intervention ensued although we did ensure that the deprecation event really happened and was applicable to the developer.
rq3 missing impactful notifications.
negative events were so voluminous that manually determining if any of these events should have been impactful was impractical.
we made three alternative pragmatic attempts to nd false negatives.
a we note that the majority of the event kinds that could cause new bugs would also cause compile time issues so compilation was again used to identify any problems that would have arisen from nonrecommended events without corresponding changes.
implementation changes that did not a ect the structural dependencies of the code base would not have resulted in problems from the compilation test procedure errors arising from such changes cannot be perfectly detected but we made two attempts to look for them as follows.
b we wished to run the test suites to ensure whether the analyzed projects would have deployed reliably but we could not locate non trivial test suites for these projects.
c instead we attempted to run the projects and exercise the functionality manually this did not yield any additional false negatives.
the results from these analyses are shown in table wherein only impactful events are considered positives true or false .
in response to research questions rq2 and rq3 we estimate that on average for these systems actual positive events are classi ed as positive of the time the true positive rate tpr and actual negative events are misclassi ed as positive .
of the time the false positive rate fpr .
this means that impactful change events are almost always recommended by yoohoo and that non impactful changes are almost never falsely recommended by yoohoo.
looking at the detailed results section .
we can see speci c targets for improvement.
in contrast to table a developer who is not keeping appraised of any changes would have a precision recall and true positive rate of but would not have to proactively consider any change events until his code breaks since yoohoo provides results with little noise or omissions this does not seem to be a good alternative.
rq4 volume of information events.
finally we can see that despite a potentially large number of change events being classi ed as information the de project tp fp tn fn tpr fpr metrics .
rssowl asm .
colorer .
checkstyle .
cumulative .
table evaluation of the quality of the results provided by yoohoo for the evaluation period.
veloper would not have been hard pressed to keep up with this trickle of information in the worst case here information events in years translates to one message every other working day.
on the other hand one would need to be careful before simply re categorizing the uncertain events as information with about events combined in the worst case this translates to roughly messages every working day.
while not a ood splitting one s attention between multiple projects falling behind on the noti cations for a few days could easily turn into an ignored and thus useless backlog.
research question rq4 is answered by saying that the information events alone are few enough that they would not be overwhelming whether or not they are relevant but that arbitrarily adding more and more events to this category could indeed be overwhelming.
further research into useful informational recommendations is warranted.
.
detailed results in this section we provide a qualitative overview of the customized change event streams generated during our evaluation for each project.
.
.
metrics metrics received the largest number of impactful noti cations in our study at the same time this project has been around the longest and the majority of its development was performed near or prior to the start of the study period.
as such a large number of its apis were either deprecated including full classes or removed from the repository outright.
in particular the developers had to migrate from swt.custom.tabletree to using a new widget that xed a number of drawbacks in the old implementation.
many of the deprecation noti cations were not xed as they were deprecated after the project went into maintenanceonly mode.
at the same time the impactful event list could give a new developer a quick list of actions that should be taken to bring the plug in up to date with the platform.
it is not surprising that sauerf received the majority of the impactful noti cations he was the primary developer and owned the majority of its dependencies.
donv70 owned a smaller portion of the code especially at the start of the study from which we computed the ownership for his event stream and received correspondingly fewer events ultimately none of his code needed to be updated to cope with any external changes.
.
.
rssowl all of rssowl s impactful events were false positives in every case they represented the same condition a method or eld was deleted from a subclass and added to a superclass that was also often newly added .
interestingly the dele tion event and the addition event were often separated by a surprising period of time weeks or longer .
these same false positives a ected several of the other projects as they were on common classes all the swtwidgets had their dispose method moved into a supertype .
the developer speci c feeds again insulated individual developers from changes that only a ected parts of their project they did not own in larger projects we would expect this di erence to be even more pronounced.
.
.
asm plugin an interesting false negative appeared within the analysis of the asm plug in.
a method which previously declared athrows clause removed this clause causing a compilation error in the code.
yoohoo had not considered exceptions and did not capture this change nor does change distiller which we build atop.
we will be adapting the code to detect this in the future.
the asm developers also changed their code to adapt to the deletion of sourcemapper.
fsourceranges and trimlayout.addtrim control int .
.
.
colorer colorer also ended up receiving several method and eld deprecation events but during the course of study period the project ceased to be regularly updated.
that said as with metrics the impactful list has true positive changes with only false positive changes that the developer could likely adapt to in a short period of time.
.
.
checkstyle as one might expect from a project designed to enforce good coding style the checkstyle project is very conservative with the apis they depended upon.
as such few of the apis they used changed although they resolved each of the deprecations they encountered.
one note of interest for checkstyle is that a change in apache.commons.lang.stringutil was not detected because we failed to associate the apache.
commons.lang project with a gca engine.
while yoohoo detects situations when an appropriate gca engine cannot be located the developer must manually ll in the details to get one populated for the missing project.
since such oversights on the part of the developer might indeed happen in practice we record this as a false negative.
.
discussion in this section we discuss a number of remaining issues about the approach and ideas for future work.
.
analytic limitations and extensions yoohoo cannot detect all changes that will de nitely impact the developer s code and only those changes as this is undecidable in general .
instead we take the approach of ordering and ltering change events in terms of which ones are most likely to matter to the developer.
yoohoo does not consider the inheritance hierarchy in many of its analyses.
for example if a developer s code depends on preferentially but its subtype concreteprefpage is changed the developer will not be noti ed.
this decision was made because the developer by registering a dependency on the interface implicitly claims to not be dependent on the concrete class any changes in these situations should be hidden by the interface.
of course interfacesdo not completely shield internal changes from propagating outwards so there are situations where internal changes would be of importance .
nevertheless were we to notify the developer of this relatively rare occurrence we would likely need to also notify her of a plethora of unimportant changes.
thus this was a pragmatic design decision.
instead there are a number of opportunities for more precise analyses to help categorize events.
for example we encountered false positives a few times in our evaluation when a method was moved via a pull up refactoring yoohoo reported method deletions involving depended upon methods despite the fact that the methods were now inherited by the original type.
some of our uncertain events are categorized as such because there can be unusual cases where such changes could cause compile or load time failures making a class nal for example is only a problem if your code had been extending that type this should be simple to detect.
the implementation changes that yoohoo frequently detects can be much more di cult even impossible to decide whether they will be impactful or not but due to developers desire to avoid api changes they should not be impactful without a signi cant accompanying change in the documentation more heavyweight impact analyses could be brought to bear here but it is not clear that this would be worth the cost.
there are two signi cant drawbacks to adding such analyses the occasional di culty in correctly implementing and validating them and the potential performance cost required to run them.
the approach after all is intended solely for providing recommendations keeping it lightweight matters for practicality.
.
results and threats to validity the results of our retroactive analysis con rm our hypothesis that the majority of change events are trivial or irrelevant to a particular developer thus these can be elided from a change event stream customized for them.
the external validity of our experiment is threatened by the fact that we used speci c systems and a particular year period for the analysis the results may not apply to other systems or other periods.
each of these systems is of non trivial scale and activity.
these systems come from di erent domains and developers reducing the likelihood that there is something non representative about them they were also in di ering modes of development maintenance versus active extension .
these systems are used by many other projects making them reasonable targets.
the construct validity of our experiment is threatened by the fact that we performed a post hoc analysis of change repository data to determine what would or would not have been of interest to the developer.
the inference needed in this analysis could have led to false results however the steps we took to determine whether supposed impactful events actually would have been and whether any nonimpactful events would have caused a failure at deployment time demonstrates that the results are a reasonable estimate of the actual true positive rate and false positive rate for this analysis.
.
performance analyzing a changed pair of les takes an average of ms on a commodity desktop machine.
while this results in a signi cant one time cost for large repositories e.g.
org.eclipse.jdt.ui contains revisions requiring10 hours for initial database population the costs of maintaining a repository once it is built is relatively low.
for example yoohoo would take only seconds of analysis per day to keep the org.eclipse.jdt.ui project current.
gca engines can be spread arbitrarily across machines the primary point of contention is the gca dispatcher but this just maintains a lookup table mapping types to urls of gca engines and can easily scale to tens of millions of types.
.
yoohoo for large teams in many ways the large team scenario section .
is similar to the plug in developer scenario.
even in large teams di erent sub teams have di erent schedules priorities and goals.
in these cases yoohoo can create gsa engines along with each branch even though the same pieces of code will be monitored repeatedly across many branches the nature of developer centric code ownership makes it likely that very few branches will actually record changes to any speci c resource.
the results from these per branch gsa engines can then be aggregated to provide a complete view of the state of the code to anyone on the team regardless of what branch they are working on.
this can enable developers to more quickly nd out about changes and to contact their originating author about them before they are integrated into the main repository branch potentially preventing new problems from arising when the code migrated upstream.
.
maintaining gca engines from the user s perspective yoohoo can transparently handle changes to the underlying kind of repository e.g.
migration from cvs to subversion and changes to the location of those repositories e.g.
migrating from sourceforge to google code .
the gca dispatcher abstracts the details of these changes away from the dsa engines.
in the back end whichever developer con gured the gca engine for a system that moved from one repository type or location to another must recon gure the gca engine a one line parameter change .
the gca engine automatically updates to reect the new con guration and noti es the gca dispatcher of the changes.
if a legacy repository is maintained but commits are applied to a new repository location a silent failure would occur.
to combat this the gca engine can announce a cessation of activity event after some timeout period has elapsed.
manual investigation of the situation could then ensue along with appropriate recon guration of the associated gca engine.
.
conclusion software systems are typically heterogenous they make use of software from di erent projects and frameworks not all of which have the same development schedule or are a part of the same organization.
developers do not always have control over when their external dependencies change typically if one of these changes causes a problem their response is both reactive and late a bug report is led and they must scramble to resolve the problem.
while responding to changes in this manner is ine cient and increases the di cult in xing bugs developers take this route because of the di culty to keep appraised of relevant changes.
this paper has described the yoohoo relevant change recommendation system.
yoohoo provides aggregate streams of recommended changes tailored to a developer or team that are customized for their external dependencies.
wehave demonstrated that these streams reduce the number of change noti cations a developer need consider by over while still maintaining a very high true positive rate over .
we have explored the feasibility of also surfacing certain non impactful events purely for sake of developerspeci c awareness and found that the low volume of such events makes this a promising avenue for further study.
by providing customized change recommendations developers can be proactive about ensuring that their system stays current with their external dependencies while remaining productive in other tasks.
.