flexible and scalable consistency checking on product line variability models michael vierhauser christian doppler lab for autom.
softw.
eng.
linz austria vierhauser ase.jku.atpaul gr nbacher systems eng.
and automation johannes kepler university linz austria paul.gruenbacher jku.atalexander egyed systems eng.
and automation johannes kepler university linz austria alexander.egyed jku.at rick rabiser christian doppler lab for autom.
softw.
eng.
linz austria rabiser ase.jku.atwolfgang heider christian doppler lab for autom.
softw.
eng.
linz austria heider ase.jku.at abstract the complexity of product line variability models makes it hard to maintain their consistency over time regardless of the modeling approach used.
engineers thus need support for detecting and resolving inconsistencies.
we describe experiences of applying atool supported approach for incremental consistency checking on variability models.
our approach significantly improves the overall performance and scalability compared to batch oriented techniques and allows providing immediate feedback to modelers.
it is extensible as new consistency constraints can easily be added.
fur thermore the approach is flexible as it is not limited to variabilitymodels and it also checks the consistency of the models with theunderlying code base of the product line.
we report the results ofa thorough evaluation based on real world product line models and discuss lessons learned.
categories and subject descriptors d. .
reusable software domain engineering reuse models d. .
software program verification d. .
programming environments d. .
metrics performance measures general terms experimentation measurement performance verification.
keywords software product lines variability models model consistency incremental consistency checking performance memory consumption lessons learned.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for profit or c ommercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redist ribute to lists requires prior specific permission and or a fee.ase september antwerp belgium.
copyright acm ... .
.
.
introduction product line variability models ar e inherently complex.
regardless of whether feature oriented decision oriented or orthogonal variab ility models are used their size represents a major challenge in real world product lines as they can easily contain thousands of elements with diverse and often complex dependencies.
in the collaboration with our industry partner siemens v ai the world s leading company in engineering and plant buildingfor the iron steel and aluminum industries we learned that engi neers in practice face big challenges when maintaining the consis tency of variability models.
the models are subject to continuous evolution and need to co evolve with the actual system they represent to maintain consistency.
the consistency of the modelsis also essential for deriving correct products.
in product line engi neering consistency constraints range from simple rules and wellformedness criteria e.g.
there must be no cycles in model element dependencies to more sophisticated checks e.g.
each component in the variability model must exist in the product line code base and vice versa .
engineers need support for detecting and keeping track of such inconsistencies when modifying the product line s modelsor code base.
more specifically there are several challenges forconsistency checking in model based product lines c1.
dealing with variability and multiple levels of abstraction .
consistency needs to be checked within and between different spaces and various types of inconsistencies need to be considered.
forinstance consistency checking needs to address the problem spacedescribing variability using concepts from the problem domain thesolution space representing the variable system from a technical point of view and the code base of the product line.
while problem and solution space are typically represented by models check ing the code base requires different mechanisms.
however exist ing checkers are often limited to either models or to code and donot check across boundaries.
also contrary to models describingsingle systems there can be optional or alternative model elements in product lines.
additional inconsistencies can occur when an element is optional or alternative.
c2.
addressing the scale and complexity of product lines .s e v eral consistency checking mechanisms have been reported in theliterature and have been applied to various types of models .
they are typically only capable of checking the consistency of entire models in a batch oriented manner meaning that the rel evant consistency constraints can be evaluated at certain points intime only e.g.
when saving a model due to the complexity of the models.
for example when using a batch oriented approach in our dopler product line tools we ran into significant performance problems when working with real world variability models of our industry partner which contain thousands of model elementswith non trivial dependencies and mappings.
the bad performance meant that feedback could not be provided to modelers immediately as launching the batch checker after each change to the model turned out to be infeasible.
special emphasis is thus necessary to design consistency checking algorithms such that immediate userfeedback is possible.
c3.
providing support for domain specific checks.
another drawback of many available consistency checkers is their lack of extensibility.
it is complicated for modelers to add new consistency constraints and to remove or modify existing ones.
we also faced this challenge with our batch oriented checker as the various con sistency checks were hard to identify and separate in the code.
to address these challenges we started exploring the use of an existing incremental consistency checker for product line variability modeling.
our goals were to extend the scope of consistency checking to model to code consistency and to improve performance to allow immediate feedback to modelers.
we also aimedat checking whether the approach scales to industrial models of dif ferent sizes without performance and memory consumption prob lems.
another goal was to improve the extensibility by making iteasy to add remove or modify consistency constraints.
in this experience paper we report results and lessons learned when applying existing consistency checking methods to a product line setting.
the tool features we developed as part of thisresearch are briefly summarized in a short workshop paper .here we give an overview about the technical approach discuss lessons learned during its implementation and report results of a thorough evaluation.
we first introduce different types of possi ble inconsistencies on and among different layers of product linemodels.
to illustrate the practical challenges we describe consis tency constraints we developed for the component based productline of our industry partner.
we then present our solution to incremental consistency checking on variability models and describe its integration in an existing product line engineering tool suite.
weprovide an evaluation with regard to performance and scalabilityand discuss lessons learned of applying the approach to productline models of our industry partner.
we discuss related work andconclude the paper with an outlook on future work.
.
consistency checking in model based product lines product line models cover both the problem space and the solution space as shown in figure .
a problem space model describes the variability of a system using concepts from the prob lem domain e.g.
in the language of the users in a specific domain.
a solution space model provides a representation of the variable system from a technical point of view e.g.
it describes optional or alternative artifacts and their dependencies .
consistency needsto be maintained between these modeling spaces but also withineach space.
however in order to be useful product line modelsalso need to be consistent with the actual code base cf.
challenge c1 .
checking and maintaining consistency with the code base is particularly challenging as it largely depends on the implementa tion technology used.
furthermore the code base is in practiceoften changed by developers outside the product line modeling environment.
existing variability modeling approaches cover the upper two levels in figure .
feature models decision models or orthogofigure modeling levels in product lines with types of intraand inter level inconsistencies.
nal models have been proposed for modeling the problem space .
architecture description languages or general purposelanguages like the uml can be used to define the solution space.
there are also approaches such as dopler or clafer that provide modeling support for both levels and mappings between them.
figure shows the three modeling spaces together with fivedifferent types of consistency checks pp inconsistencies can exist within the problem space model.
for instance in a decision model cycles caused by decision dependencies need to be detected and prevented.
ps inconsistencies can occur between the problem space model and the solution space model.
for instance a component in the solution space model can have dependencies to two contradictingdecisions.
this can result in an inconsistency if it is impossible toresolve both decisions during product derivation.
ss inconsistencies can exist within the solution space model such as contradicting dependencies between components.
one component might require two other components which in turn excludeeach other.
sc inconsistencies can appear between the solution space model and the code base it represents.
such inconsistencies can for example occur whenever an asset or its dependencies or attributes are changed in the solution space model but not in the code base.
cc inconsistencies can exist within the code base.
they are however typically addressed by integrated development environments and are thus not further investigated in this paper.
the section on related work will discuss existing research for detecting and fixing specific types of inconsistencies.
however themajor practical challenge lies in providing an integrated environ ment capable of dealing with all these types in a holistic manner.
.
modeling a component based product line with dopler in cooperation with our industry partner siemens v ai we have been creating variability models for the cc l2 software product line controlling continuous casting m achines in steel plants.
the simplified meta model for modeling the problem space the solution space and the code base is shown in figure .
the product line has been modeled using the dopler approach which uses decision models to define the problem space asset models defining reusable elements of different types and their dependencies forthe solution space as well as mappings among decisions and assets .
in dopler variation points are represented using decisions which have a unique name and a question that is asked to a user 64figure partial siemens v ai meta model with model elements for the problem space and solution space.
the code base leveldefines additional elements for representing the componentbased implementation of the product line.
during product derivation.
answering a question sets the value of a decision.
possible answers depend on the type of the decision boolean enumeration string or number .
the range of allowed values can be further restricted by validity conditions.
decisions can depend on each other hierarchically if a decision needs to betaken before another decision becomes visible or logically iftaking a decision changes the value of another decision .
deal ing with variability represents a specific challenge for consistency checking as consistency constraints need to consider such dependencies cf.
challenge c1 and table .
assets represent the solution space in the product line e.g.
software components .
assets can depend on each other functionally e.g.
one component requires or excludes another component or structurally e.g.
a component is part of a sub system .
do pler allows modeling assets at arbitrary granularity and with userdefined attributes and dependencies based on a given set of basic types .
users can create domain specific meta models to define thetypes of assets their attributes and dependencies.
in the siemensv ai product line the asset type s in the dopler variability models are components representing spring xml component descriptions which in turn represent java beans and properties key value pairs .
diverse domain specific dependencies have been defined.
for ex ample a component can require another component or a property cf.
figure .
dependencies between assets and decisions are ex plicitly modeled via in clusion conditions that define for an asset when it will be part of a derived product.
due to asset dependencies not every asset needs to be related with a decision to be included in a derived product.
for example when an asset is in cluded because of a decision its requires dependencies might lead to the inclusion of other assets as well.
we decided to create a model image of the code base and to apply incremental transformation to synchronize it with the code.
this allowed us to use the same checking mechanism for all different typesof artifacts.
for that reason the meta model was extended with acode base level containing the spring files c springfile the contained java beans c javabean and their properties c property as well as defines andrequires relations among these elements cf.
figure .
traceability to the solution space model is established by the implements relationship as we will show later.
.
examples of consistency constraints figure shows generic types of constraints pp ps ss sc cc in product line engineering.
here we describe a number of specific constraints based on these types needed in the component based product line of our industry partner.
examples of the constraintsare shown in table .
to allow arbitrary checks and freedom for the developer the constraints are defined in the java programming language.
there are however no language restrictions and anyconstraint language could be used instead.
the problem space and problem to solution space constraints pp and ps are relevant in any dopler variability model.
there aresimple constraints that check whether decisions of type enumer ation have at least two possible values pp1 and that values formodel elements with mandatory attributes have been defined pp2 .it is also essential to detect cycles in the decision model stemming from hierarchical and logical dependencies pp3 .
ps1 is an example of a problem to solution space inconsistency.
the constraintdetects whether inclusion conditions exist in the solution space as sets that never can evaluate to true because they refer to contradic tory decisions in the problem space cf.
challenge c1 .
further constraints depend on the domain specific meta model for siemens v ai cf.
figure and address intra solution space and model to code consistency.
ss1 checks that each componentmodeled in the solution space representing a java bean describedin a spring xml file requires at least one property defining ini tialization parameters for that component.
the most basic model to code constraint sc1 assures that each component modeled in the variability model exists in the c ode base of the product line.
this constraint assures for example that outdated components that are no longer available in the workspace are marked to be purged inthe variability model as well.
the constraints sc2 and sc3 coverthe relations between components in the model and the relations between spring xml files in the file system which in fact depend on relations between the java beans described in that spring files .both constraints assure that there are no unnecessary relations be tween components and that no relations are missing in the vari ability model.
constraints sc4 assure the consistency of varianttype components which represent a particular characteristic of the siemens v ai models.
variant types are used to group identical components implemented in different spring xml files.
we discuss constraint sc2 in detail to illustrate its high level operation sequence sc2 checks the requires relations between components.
as illustrated in figure a requires relation between two components in the model is only needed if it is based on an exist ing dependency in the product line code base.
each component isdefined by a spring file which in turn is realized by one or morejava beans.
if at least one java bean contained in the spring file deburrer.xml requires a bean defined in the second spring file caster.xml then the relation is needed on component level.
otherwise the consistency check will reveal an obsolete relation betweenthe two components.
although sc2 is fairly simple it is impor tant to note that such constraints have to be evaluated many timesin complex models.
for example sc2 needs to be evaluated foreach requires relationship among two components and there are thousands of such relationships in our models .
we developed a batch oriented checker that worked well with 65table examples of constraints in component based product lines.
constraint description pp1 enumeration decision an enumeration decision must have at least two options to choose from.
pp2 mandatory attribute mandatory attributes of model elements must not be empty.
pp3 decision effect cycle there must be no cycles caused by logical decision dependencies.
pp4 visibility condition cyclethere must be no cycles caused by hierarchical decision dependencies visibility .
pp5 visibility condition selfreferencea visibility condition must not c ontain a reference to itself.
ps1 inclusion conditionexclusionan inclusion condition must not contain two contradictory decisions to avoid assets that will never beincluded in a derived product .
ss1 component properties each component representing a java b ean requires at least one prope rty defining initialization parameters for the bean.
sc1 component matching each component in the varia bility model must exist in th e product line code base.
sc2 component relation relations between components in the va riability model must also exist in the product line code base.
sc3 java bean relation a relation between java beans must be r epresented in the v ariability model as a component relation.
sc4 variant type relation variant types must not have requires relations.
sc5 variant type occurrence if two or more components are identical all of them must contribute to the same variant type component.
sc6 variant type consistency only identical components must contribute to a single variant type component.
figure schematic view of constraint sc2.
small variability models and a limited number of constraints in earlier research.
however this approach did not scale well enough for larger models and high number of required consistency constraints that we encountered in industrial practice cf.
challenge c2 .
in particular modelers requested immediate feedback regarding consistency after changes to the model.
while technically itwould have been possible to realize immediate feedback with abatch checker the computational cost made it impractical to reportinconsistencies after each change.
previously our approach thusonly reported inconsistencies after a user invoked the checker when saving the model in the tool.
typically many changes were made by modelers between two invocations of the checker and multiplenew errors were reported at once.
this made it difficult for mod elers to relate the errors to the changes they made to the model orin the code base changes that were made minutes or even hoursearlier.
also our batch oriented checker was difficult to extend or adapt because the consistency constraints were woven togetherinto a long and complex algorithm.
this was a big obstacle to thepractical use of consistency checking because new constraints were increasingly hard to integrate in the existing algorithm.
.
incremental consistency checking on v ariability models we thus pursued an incremental strategy to consistency checking to help modelers with detecting and tracking inconsistencies correctly and quickly after every change.
we adapted an existing incre mental checker to support the fast checking of model changes.the checker identifies all model elements that affect the truth value of any given consistency constraint.
a consistency constraint needs to be re evaluated if one of these model elements changes.
we refer to this set of affected model elements as the scope of a consistencyconstraint.
the elements contained in the scope are stored in thescope database.
our incremental checker computes the change im pact scope of a constraint instance automatically by observing therun time behavior of consistency constraints during their evaluation.
to this end we developed the equivalent of a profiler for consistency checking.
the profiling data is used to establish a correlation between model elements and consistency constraints.
based on this correlation it then decides when to re evaluate consistencyconstraints and when to display inconsistencies thus allowing an engineer to quickly identify all inconsistencies that pertain to any part of the model of interest at any time.
however thus far the checker had only been used and evaluated for uml models.
although our models might seem similar touml on the surface they exhibit quite a range of differences whichrequired significant extensions we will describe in section .
for example as discussed in section and shown in table many of our consistency constraints go beyond the checking of modelsand also include source code and other artifacts.
since the exist ing approach was limited to checking models we had to incre mentally transform code fragments into model fragments to enable their checking.
thus our extended approach combines incremental transformation with incremental consistency checking.
66figure incremental evaluation of sc1 and sc2.
we illustrate the incremental consistency checker using consistency constraint sc1 cf.
table evaluating whether a modeled component is implemented in the source code.
figure depictsa simplified excerpt of one model with three components in thetop and a range of code level constructs at the bottom.
consistency constraint sc1 is written from the perspective of a component i.e.
a given component is considered consistent if it is implemented by acode level xml file.
since there are three components in figure each component has to be evaluated with regard to sc1.
our ap proach thus instantiates the consistency constraint sc1 three times once for each component ci1 ci2 ci3 .
we do this because incremental consistency checking needs to react to model changes and each instance of the consistency constraint is affected differentlyby model changes.
this means that we need to compute how eachconsistency constraint or instance thereof is affected by a modelchange.
for this purpose we need to know the complete changeimpact scope for every constraint instance.
figure indicates that the three sc1 instances ci1 ci2 and ci3 access distinct model elements when they are evaluated.
for example the first instance ci1starts its evaluation at component deburrer then navigates along the implements relationship and finally accesses deburrer.xml .
the constraint instance is satisfied because the component does have an associated code level xml file.
our approach recognizes that from the entire model only these accessed model elements were needed to evaluate instance ci1.
this instance must be re evaluated only if one of those elements changes.
our approach thus maintains a table of instancesof consistency constraints and the model elements they accessed during their evaluation to understand which instances must be reevaluated when the model changes.
it is also important to note thata model element may be accessed by multiple instances of one ormore consistency constraints.
for example constraint sc2 evalu ates a component with regard to the requires relationship.
it makes sure that a component level requires relationship is matched by a code level requires relationship.
figure depicts a requires relationship from deburrer tocaster and during evaluation an instance of sc2 will access the components their code level xml files deburrer.xml andcaster.xml and some of the defines andrequires relationships underneath.
the change impact scope of this instanceof sc2 is also automatically observable through the model profiler.
this scope is also larger than the scope of sc2 and encompassesmany of the model elements underneath deburrer andcaster but notnozzlecheck .
some model elements such as deburrer.xml thus affect multiple instances of consistency constraints.
only these related instances must be re evaluated if deburrer.xml changes.
.
using the incremental checker in the dopler tool suite a major goal when developing our incremental checker was to increase usability by providing immediate feedback to modelers about the detected inconsistencies cf.
challenge c1 as part of a development environment.
we thus decided to seamlessly integratethe incremental consistency checker in the eclipse based dopler tool suite which supports produc t line variability modeling and product derivation.
in particular we integrated the checker with dopler s modeling tool that allows defining decision and asset models as discussed in section .
a modeler can define assets in the variability model editor as shown in figure .
the asset overview shows an outline of already available software components.
this view allows adding orremoving components.
selected components can be modified in theasset detail view which provides information about its attributes and relations to other components.
the modeler can simply add or remove relations to other components via drag and drop in the de tail view.
manipulating components in the editor has an immediateeffect.
for instance after adding a relation to another componentall involved constraints and only those!
are re evaluated.
feedback about detected errors is prov ided within milliseconds after the user action leading to an inconsistency.
the error view provides information about all inconsistencies found in the model.
the errorview also provides details about the source model elements caus ing the problem.
this helps the modeler to resolve the problem forinstance by removing an unneeded relation between two components from the model.
we illustrate our tool architecture by discussing the chain of events and data flow cf.
figure .
the incremental consistency checker relies on tracking changes in the eclipse workspace.
forthat purpose our eclipse change tracker observes arbitrary changes to the variability model and the eclipse workspace.
for instance it listens to the delete component change to the variability model after the modeler del etes a component in the editor and propagates the change to the constraint manager which is responsible for initializing managing and storing constraints.
using thescope database the constraint manager determines the constraint instances to be re evaluated after the deletion of a certain component.
our architecture makes use of the eclipse extension point mechanism to allow adding new constraints flexibly and easyfor new domains.
constraint definitions can easily be added or re moved from the evaluation process by simply activating or deacti vating plugins.
the list of constraint instances is used by the incremental consistency checker which applies incremental checking to variability models by controlling the execution of all affectedconstraint instances.
the constraint instances do not directly ac cess and query the variability model .
instead they use the model access tracker a model adapter component which monitors and records all read access events to model elements for each single constraint instance that is evaluated.
this fine grained model profiling helps improving performance because with each level ofdetail fewer constraint instances need to be evaluated eventually.the model access tracker also builds the scope database ensur ing that only necessary constraints are re evaluated after changesto the model not shown in figure .
the incremental consistency checker sends all newly found inconsistencies to the error man67figure the dopler variability model editor.
the incremental consistency checker identifies errors and displays them in an error view.
ager which manages a list of errors for the user.
it translates abstract constraint evaluation results into error messages meaningful for a modeler and performs basic filtering functions to avoid information overload.
finally the error viewer see also figure displays the detected inconsistencies for the evaluated constraint.
we use the eclipse marker mechanism for the easy management of errors and their presentation in a viewer.
.
ev aluation we define our evaluation goal using the goal question metric gqm approach .
a goal in gqm consists of a purpose describing the actual aim of the evaluation the issue of interest a specific object to be measured and the viewpoint which describes thestakeholder perspective from which the goal is defined.
goals are refined using questions targeting explicit problems of interest.
finally metrics are defined to obtain data addressing those questions.
our evaluation goal is to assess purpose the performance issue of incremental consistency checking object from the viewpoint ofthe modeler viewpoint .
we explore three questions regarding performance memory usage and scalability of the approach cf.
challenge c2.
question .
what is the impact of the incremental consistency checker on the start up performance?
is further refined using two figure the incremental consistency checker re evaluates constraint instances after changes to the model.
metrics m .
.
is the time needed to initialize the incremental consistency checker measured in milliseconds .
it measures the overall start up time when opening a variability model and includeslibrary initializations as well as the creation of the scope database.
the startup time is critical as engineers frequently open models inthe dopler tools.
m .
.
measures the initial memory footprintof the incremental consistency checker after its start up expressedby the number of objects created i.e.
constraint instances scope elements .
understanding memory consumption is important as developers modeling real world product lines have to work withvery large models containing thousands of model elements.
question .
what are the specific performance characteristics of the incremental consistency checker during modeling?
is further defined with metric m .
.
measuring the time needed in milliseconds for consistency checking of key atomic modeling tasks such as adding modifying or deleting model elements.
this met ric is important as it shows the feasibility of the approach duringeveryday modeling activities.
in particular it shows whether theapproach can provide immediate feedback to modelers.
question .
how well does the approach scale?
investigates performance and memory consumption of our approach when applied to industrial models of different sizes.
we compute the met rics m .
.
.
m .
.
and m .
.
for real world models of differ ent sizes to address this question.
in addition we use another metricto investigate this question.
m .
.
measures the number of constraint instances that need to be evaluated for the atomic modeling actions.
this metric checks whether the approach scales regardlessof the specific modeling actions performed by the user.
.
evaluation setup we used variability models of th e siemens v ai cc l2 product line to perform our evaluation.
regarding question .
we evaluate the incremental checker with different model sizes.
we thus created models of different sizes by incrementally merging the available variability models using the merging approach described in .
the smallest variability model i represents a single subsystem andconsists of components.
we use two other models ii and iii forevaluation with and components.
the largest model iv consists of components.
the underlying code base used for 68table siemens v ai solution space models used for evaluation.
included subsystems c s ci s se s i cutting ii model i subsystems caster heating iii model ii subsystems optimizer jamp simulator401 iv model iii subsystems analysis defecttracking v aiqfeeder warmstart768 evaluation contains code model elements xml spring files and java beans and is used in all four models i iv .
table provides a detailed overview of the four models regarding the number of components c s number of instantiated constraints ci s and the total number of instantiated scope elements se s at startup.
a constraint is instantiated for each model ele ment only if needed as explained in section .
the scope databasecontains all scope elements defining the constraint instances thatneed to be re evaluated after a change.
the actual number of model elements is much higher in these models as we only show assets of type of component in the table and do not consider the number ofrelations and model element attributes in table .
.
evaluation results we present the results gained by comparing the four different models in terms of startup and runtime performance when applying the incremental consistency checker.
the mechanism for incremental consistency checking relies on a complete execution of all constraints during startup to initialize the constraint instances and the scope database scope elements need to be created .
figure provides an overview of the initialization costs of the incremental checker for the four different models lower solid line .
the additional time needed to open a variabilitymodel lies between .
seconds for a model with about assets and seconds for a model with assets.
we used a pc witha intel pentium dual core .
ghz processor and gb of main memory for the evaluation.
this time is clearly acceptable for typical model sizes at our industry partner to components persingle model .
also this task is performed as a background threadwhen opening a model and does not block the modeler even in thecase of model iv where the initialization takes about seconds .
the lower solid line is essential for the evaluation of the incremental checker.
however we made an additional interesting observation.
re structuring the constraints already implemented in ourlegacy batch checker into the new format required by the incremen tal checker already had a significant impact on performance.
wecompared the complete time of executing all constraint instances with the initialization time of our legacy batch checking approach.
the dashed line demonstrates the scalability issues we had expe rienced with the batch checking approach.
please note however that the legacy checker is not fully comparable in terms of the con straints it checks.
however the results show the order of magnitude of improvement gained by using the incremental checker.
besides the initialization time we also took a closer look at the memory costs m .
.
.
memory consumption depends on the number and type of constraints and the number of model elements.the maximum number of constraint instances is created if everyconstraint is instantiated once for every asset in the model and everyasset in the code base this is only a theoretical case .
instead constraints are typically instantiated for selected types of asset only figure metric m .
.
.
initialization time of the new incremental checker and evaluation time of legacy batch checker formodels i iv .
e.g.
components and the real number of constraint instances per model is therefore much lower than the theoretical maximum.
the maximum number of scope elements can be calculated as the number of assets times the number of attributes per asset.
scope elements are created only once but can be used in multiple con straint instances.
figure shows the linear increase of scope ele ments and constraint instances for the four variability models de monstrating the scalability of our approach.
figure metric m1.
.
.
number of constraint instances and scope elements after startup models i iv .
in section .
we described a number of basic tasks when working with the dopler variability modeling tool.
we use these typical actions on variability models to gain data concerning the timeneeded to evaluate model changes at runtime.
we simulate creat ing and deleting assets as well as adding and removing relationsfor our live evaluation metric m .
.
and the analysis of affected constraints during one evaluation cycle metric m .
.
.
for live evaluation analysis each single task has been performed times to outweigh effects such as unpredictable background tasks.
the mean values gained are shown in figure .
the costsfor adding assets as well as adding and removing relations to froman asset remains constant in terms of model size.
a single action performed on a variab ility model t ook only about 5t o1 0m s which 69figure metric m .
.
.
performance of basic modeling actions for models i iv .
demonstrates that our approach indeed provides immediate feedback .
only the task of deleting an asset from a model increases linearly.
this is because constraints that were instantiated for the asset to be deleted need to be found and removed from the consistency checking instance.
we expect however that this problem can be easily fixed by using a different data structure.
while constraint instances and scope elements in total increase depending on model size as shown in figure the number ofconstraint instances that need to be re evaluated during live eval uation stays constant.
depending on the type of change very few constraints need to be evaluated see figure .
the number of constraints that need to be evaluated remains constant when addingassets in models of different size.
adding and deleting relations aswell as deleting component moves between .
and .
constraintsevaluated per change event again tested on change samples.
figure metric m .
.
.
number of constraint instances affected by a change for models i iv .
.
lessons learned we derive the following lessons from our experiences support different types of concistency checks.
our aim was to develop a holistic approach capable of checking various consistency constraints within and among differerent levels.
in this paper we distinguished five different types of inconsistencies depending onthe modeling level problem space vs. solution space vs. codebase cf.
challenge c1 and presented both generic constraints applicable to variability modeling with dopler and domainspecific constraints applicable to the specific technical platform of siemens v ai .
domain specific constraints which depend on thetechnology used mainly ss and sc types can greatly complicateconsistency checking but are very important for the usefulness andacceptance of the checker in practice cf.
challenge c3 .
use a model based representation to check consistency.
existing consistency checking mechanisms either work on model level or oncode level but not on both and among them cf.
challenge c1 .
welearned that the benefits of an explicit representation of the code inmodels outweighs the overhead of increased memory consumptionand slightly increased startup time.
however allowing the checker to operate only on the level of models makes the implementation more elegant and easier to understand.
this solution has the advan tage that the checker is more resilient to technical changes as onlythe transformation algorithm has to be updated for example if thecomponent technology language is replaced.
decide whether to allow inconsistencies or to avoid them in the first place.
an interesting issue is that while it is important to know about inconsistencies it is often too distracting to resolve them right away.
the notion of living with inconsistencies advocates thatthere is a benefit in temporarily allowing inconsistencies in design models.
while our approach provides inconsistencies instantly itdoes not require the engineer to fix them instantly.
our approach tracks all presently known inconsistencies and lets the engineer explore inconsistencies according to his her interests in the model.however there are situations where it is beneficial to avoid incon sistencies in the first place.
when developing constraints for thedifferent types we noticed that the number of generic constraints mainly pp and ps types can be kept small by trivial plausibility checks on all levels from pp to cc in the variability model ing tool.
this lesson is related with challenges c1 and c2 definedin the introduction.
go for incremental checking.
while our incremental consistency checking support for product line models has some disadvantages initialization time memory consumption redundant representation of code in models and the required transformation the benefits outweigh these drawbacks as shown in our evaluation.
in particular we have learned that the run time performance enabling immediateuser feedback greatly contributes to the usefulness and acceptancein practical settings cf.
challenge c2 .
support the evolution of constraints .
constraints evolve over time based on experiences made as well as due to changing andevolving technology.
both product line tools as well as the prod uct lines they describe can evolve.
in our case the product linetools were under constant development during the early phases ofthe project and the product line of siemens v ai was refactored and evolved in parallel.
this is why we developed an extensible architecture for our consistency checker to allow adding rules incre mentally and to allow easily replacing and modifying existing rules.our batch oriented checker was difficult to extend or adapt becausethe consistency constraints were woven together into a large andcomplex algorithm.
this was a big obstacle to the practical use of consistency checking because new constraints were increasingly hard to integrate in the existing algorithm.
thus the extensible ar70chitecture turned out to be very important due to this continuous evolution cf.
challenge c3 .
.
related work we structure our discussion of related work according to the types of inconsistencies defined in section .
pp .batory describes an approach combining feature models grammars and propositional formulas to allow arbitrary propositional constraints to be defined among features and checked using satisfiability solvers.
other authors have addressed the automatic analysis of feature models .
for example the fama approach allows using different solvers in the back end to per form analysis operations on feature models.
ps.heidenreich explores possibilities for checking the wellformedness of models describing features in the problem space andtheir realizations in the solution space to ensure their correctness.
several authors have presented work on type systems to guarantee that only well typed programs are generated apel et al.
have developed such a type system on the basis of a formal model of a feature oriented java like language .
similarly delaware et al.
present an extension to lightweight java with support for features together with a constraint based type system.
ss.several approaches are based on identifying inconsistencies between different design models by direct comparison.
some of these approaches also perform incremental consistency checking.xlinkit allows evaluating the consistency of xml based doc uments.
the approach can check the consistency of entire uml models but can also handle incremental consistency checking by only evaluating changes to versions of a document.
argouml detects inconsistencies in uml models based on annotated consis tency rules that also enable incremental consistency checking.
theapproach implements two consistency checking mechanisms consistency rules without annotations are placed into the queue which is continuously evaluated in the background using a batch checker at cpu time.
consistency rules with annotations are evalu ated using an incremental checker.
it has been demonstrated thatargouml s type based consistency checking produces good per formance but it is not able to keep up with an engineer s rate ofmodel changes in very large models .
similar to our approach blanc et al.
address the issue of incremental consistency checking from the perspective of model changes.
however their consistency rules need to be defined explicitly in terms of their impact onchanges.
if done correctly this leads to good performance.
how ever since writing these annotations may easily cause errors theyare no longer able to guarantee the correctness of incremental consistency checking.
while researchers generally agree on the importance of consistency checking the methods on how to detect themvary widely.
for example tsiolakis and ehrig present an ap proach for checking the consistency between class and sequencediagrams based on a common graph structure.
van der straeten et al.
use description logic to detect inconsistencies between sequence and state chart diagrams.
campbell et al.
use a model checker to evaluate inconsistencies within and across uml dia grams.
zisman and kozlenkov use a knowledge base and ex press consistency rules using patterns and axioms.
sc.several papers address the issue of consistency between models and code in evolving product lines.
murta et al.
present an approach for ensuring consistency of architectural models to im plementation during evolution.
their approach support arbitrary evolution policies and is based on recording changes in a configuration management system.
product line evolution support be comes critical in model based approaches to ensure consistency after changes to meta models models and actual development arti facts.
mende et al.
describe tool support for the evolution of software product lines based on the grow and prune model.
they support identifying and refactoring code that has been created bycopy paste and which might be moved from product to productline level.
deng et al.
describe a model driven product line approach that addresses the issue of domain evolution in productline architectures with model transformations.
.
conclusions and future work we presented experiences lessons learned and evaluation results of applying an incremental consistency checker on product line variability models.
the incremental consistency checker works on and across different levels of variability models and also checksconsistency between variability models and source code.
the incremental consistency checker is independent from the domainspecific dopler meta model and can be easily used with arbitrary meta models.
as our event tracking mechanism allows to identify changes down to the level of model element attributes only few con straints need to be evaluated during incremental consistency check ing.
our evaluation with large scale models demonstrates the per formance and scalab ility of the appro ach.
it is fast enough to provide immediate feedback to users and identifies errors within to10 ms for typical modeling actions.
furthermore our approach al lows adding new constraints in a flexible manner via eclipse exten sion points.
constraints can be activated and deactivated as neededin certain domains.
while this paper focused on the practical experiences and lessons learned we plan to report on the technical details of our approachin a further paper.
in particular we will describe the incremen tal code to model transformation approach we developed as part ofthis work.
we will also experiment with more and other types ofconstraints and plan to investigate how dependencies among con straints can be exploited during constraint evaluation.
finally we will extend our tools to support fixing identified inconsistencies as already demonstrated in .