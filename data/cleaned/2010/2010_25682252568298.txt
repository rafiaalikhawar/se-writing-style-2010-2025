detecting differences across multiple instances of code clones yun lin1 zhenchang xing3 yinxing xue4 y ang liu3 xin peng1 jun sun5 wenyun zhao1 1school of computer science fudan university china 2shanghai key laboratory of data science fudan university shanghai china 3school of computer engineering nanyang technological university singapore 4school of computing national university of singapore singapore 5singapore university of technology and design singapore linyun pengxin wyzhao fudan.edu.cn zcxing yangliu ntu.edu.sg dcsxuey comp.nus.edu.sg sunjun sutd.edu.sg abstract clone detectors find similar code fragments i.e.
instances of code clones and report large numbers of them for industrial systems.
to maintain or manage code clones developers often have to investigate differences of multiple cloned code fragments.
however existing program differencing techniques compare only two code fragments at a time.
developers then have to manually combine several pairwise differencing results.
in this paper we present an approach to automatically detecting differences across multiple clone instances.
we have implemented our approach as an eclipse plugin and evaluated its accuracy with three java software systems.
our evaluation shows that our algorithm has precision over .
and recall over .
in three open source java projects.
we also conducted a user study of developers to evaluate the usefulness of our approach for eight clone related refactoring tasks.
our study shows that our approach can significantly improve developers performance in refactoring decisions refactoring details and task completion time on clone related refactoring tasks.
automatically detecting differences across multiple clone instances also opens opportunities for building practical applications of code clones in software maintenance such as auto generation of application skeleton intelligent simultaneous code editing.
categories and subject descriptors d. .
maintenance general terms algorithm human factors keywords code clone program differencing human study .
introduction permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.code clones are similar code fragments in software.
many techniques have been proposed to detect code clones based on token similarity e.g.
ccfinder cloneminer and clonedetective abstract syntax tree ast similarity e.g.
clonedr deckard or program dependence graph similarity e.g.
.
these clone detectors can detect not only textually identical clones type i but also parameterized clones type ii and gapped clones type iii .
textually identical clones refer to code fragments with differences only in whitespace layout and comments.
parameterized clones refer to syntactically identical code fragments except for differences in identifers literals and types.
gapped clones refer to copied fragments with further modifications such as changed added or removed statements.
a code clone often appears in multiple places in the system i.e.
having multiple instances.
table presents a four instances code clone in jhotdraw system.
note that the clone instances are different in places.
some clone instances may be the same in one place but can be different in other places.
in a specific place one clone instance may have parameterized and or gapped differences with other instances.
differences in whitespace layout and comments are not important.
but detecting and analyzing differences in parameterized and gapped clones parameterized and gapped differences thereafter such as those shown in table is important to manage and maintain code clones for example to identify refactoring opportunities to detect bugs to support change propagation in code clones .
existing program differencing techniques compare a pair of cloned code fragments at a time.
pairwise differencing of multiple clone instances cannot provide developers with a complete picture of how multiple clone instances are different.
developers have to manually investigate where clone instances are the same where they are different and if different which instances are different and what types of differences.
unless developers take notes during investigation differences across multiple clone instances are not readily available when developers need them in software maintenance tasks.
furthermore manual analysis of clone differences makes it impossible to automatically use clone differencing results in software maintenance.
in this paper we present an automatic approach to detecting differences across multiple instances of a code clone.
our approach mcidiff multi clone instances differencing takes as input multiple clone instances in a clone set.
it parses source code of each clone instance into a sequence of tokens enriched with relevant syntactic information e.g.
data type of a variable .
mcidiff computespermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
table code clone example in jhotdraw system pertproject .
java public void read file f inputstream in null try in new bufferedinputstream new fileinputstream f nanoxmllitedominput domi new nanoxmllitedominput pertfactory view .
getdomfactory in domi .openelement pertdiagram .
.
.
domi .closeelement catch interruptedexception e .
.
.
netproject .
java public void read file f inputstream in null try in new bufferedinputstream new fileinputstream f nanoxmllitedominput domi new nanoxmllitedominput netfactory view .
getdomfactory in .
.
.
catch interruptedexception e .
.
.
drawproject .
java public void read file f inputstream in null try in new bufferedinputstream new fileinputstream f nanoxmllitedominput domi new nanoxmllitedominput drawfigurefactory view .
getdomfactory in domi .openelement plasmadraw .
.
.
domi .closeelement catch interruptedexception e .
.
.
svgproject .
java public void read file f inputstream in null try in new bufferedinputstream new fileinputstream f dominput domi new nanoxmldominput svgfigurefactory view .
getdomfactory in .
.
.
catch interruptedexception e .
.
.
longest common subsequence lcs of multiple clone instances.
then it analyzes the lcs to determine differential ranges across multiple clone instances and identifies similar tokens in differential ranges.
mcidiff produces as output a list of matched and differential multisets i.e.
bags of corresponding tokens of multiple clone instances.
differential multisets summarize differences that can be found in parameterized and gapped clones.
mcidiff has been implemented as an eclipse plugin with gui that allows developers to interactively investigate code clones and their differences.
our mcidiff tool can be downloaded at http our evaluation shows that mcidiff can build a detailed and accurate summary of differences over .
precision and over .
recall across multiple instances of a code clone.
it can help developers to perform clonerelated refactoring tasks more easily and achieve better performance in refactoring decisions refactoring details and task completion time.
the rest of the paper is structured as followed.
section presents a motivating example of our work.
section describes our approach to detecting clone differences.
section presents our mcidifftool.
section discusses empirical evaluation of our approach.
section discusses our on going work that exploits mcidiff in three software development tasks.
section reviews related work.
finally we conclude and discuss the ideas for future work.
.
motiv ating example table shows four similar code fragments contained in read method of four classes i.e.
pertproject netproject drawproject and svgproject of jhotdraw applications.
such similar code fragments are called code clones .
each code fragment represents a clone instance in the clone set see section .
for a formal definition of clone set .
although the four read methods are very similar they demonstrate four typical types of differences across multiple clone instances.
all parameterized .
all clone instances are different from one another.
for example at line four clone instances cast return value of a method call view getdomfactory to four different types respectively i.e.
pertfactory netfactory drawfigurefactory and svgfigurefactory .same parameterized .
some clone instances have no differences others have parameterized differences.
for example at line pertproject read netproject read anddrawproject read have no difference the data type of variable domi is the same i.e.
nanoxmllitedominput while svgproject.read is different from the other three methods the data type of variable domi is dominput .
that is svgproject read and the other three methods have parameterized differences.
similar case can be found at line .
same gapped .
some clone instances have no differences others have gapped differences.
for example at line both pertproject.read anddrawproject.read calldomi.closeelements while netproject.read andsvgproject.read do not call.
when comparing pertproject.read drawproject.read and netproject.
read svgproject.read these clones have gapped differences.
same parameterized gapped .
some clone instances have no differences some have parameterized differences and others have gapped differences.
for example at line neither netproject.read norsvgproject.read calldomi.openelements .pertproject.read anddrawproject.read calldomi.openelements with different parameters pertdiagram versus plasmadraw i.e.
parameterized difference .
when comparing netproject.read svgproject.read andpertproject.read drawproject.read these clones have gapped difference.
multiple clone instances may have several differences.
in our example four clone instances are different in five places lines and .
some clone instances may be the same in one place but can be different in other places.
for example pertproject read netproject read anddrawproject read are the same at lines and but they have parameterized difference at lines and and gapped difference at line .
furthermore one clone instance may have different types of differences against other clone instances in a specific place.
for example at line pertproject read anddrawproject read have parameterized difference pertproject read andnetproject read have gapped difference while netproject read andsvgproject read have no difference.
clearly it is not an easy task to identify the above differences through manual examination or pairwise differencing across multiple clone instances.
developers have to manually determine where clone instances are the same where they are different and if dif 165figure incomplete syntactic units of code clones ferent which instances are different and what types of differences.
furthermore all manually collected difference information is not readily available when it is required for a software maintenance task.
developers have to recall the information from memory or based on notes if any or they may have to redo manual investigation again.
.
approach we now discuss our approach to detecting parameterized and gapped differences across multiple clone instances.
.
input our approach takes as input a clone set as reported by a code clone detector.
a clone set cs consists of n n clone instances ci k k n .
each clone instance cikrepresents a code fragment.
the code fragments of any pair of clone instances cikand cil k6 l in a clone set csare similar according to similarity metric defined by the clone detector.
code clones reported by a clone detector e.g.
token based clone detector may not be complete syntactic units.
for example in figure code fragments highlighted in green are code clones reported by clonedetective in jhotdraw applications.
these code fragments break syntactic boundary of try block.
we assume that source code of the software is available.
mcidiff builds ast of the method containing reported code clones.
it then analyzes the ast to find inner most syntactic unit i.e.
least common ancestor that contains incomplete syntactic units of cloned code fragment.
the corresponding syntactically complete code fragment is considered as code fragment of clone instances for differencing.
given a clone instance cik we transform its code fragment into atoken sequence ts cik .
according to java language specification there are five types of tokens in java program i.e.
keyword e.g.
if while separator e.g.
operator e.g.
literal e.g.
abc and identifier.
we further classify identifers as type method field variable and label.
as such our approach considers six categories of tokens i.e.
type method field variable literal label keyword separator and operator .
type method field variable literal and label tokens have name attribute.
keyword separator and operator tokens have symbol attribute.
method field variable literal tokens have attached data type as token attribute.
our differencing algorithm compares category and attribute of tokens to determine their correspondences.
we consider method field variable literal as same category of tokens.
that is methods fields variables and literals are comparable as long as they share compatible data type.
.
output given ntoken sequences ts cik representing nclone instances cikof a clone set mcidiff reports a list of multisets i.e.
bags of corresponding tokens.
each multiset msconsists of ncorresponding tokens one from each clone instance i.e.
ms ftkjtk2 ts cik and1 k ng.
a token tkfrom a clone instance cikcan inputstream ci1 ci2 ...inputstream inputstream inputstream in in in in ... ... ... pertfactory netfactory drawfigure factory svgfigure factory ... ... ... ... domi domi .
.
openelement openelement pertdiagram plasmadraw ... ... ... ...diffrange diffrange ci3 ci4 lcs lcs lcs lcs lcs lcs ms1 inputstream inputstream inputstream inputstream lcs multiset ms2 in in in in ms27 pertfactory netfactory drawfigurefactory svgfigurefactory ms40 openelement openelement ms43 pertdiagram plasmadraw ms41 swingutilities swingutilities swingutilities swingutilities lcs figure results of mcidiff only be in one multiset.
the token tkcan be i.e.
a placeholder token which means that no real token from the given clone instance corresponds to tokens from other clone instances in the given multiset.
given a multiset msof corresponding tokens if all pairs of tokens tkandtl k6 l in the multiset are identical i.e.
all tokens in this multiset have exactly the same category and attribute the multiset is a matched multiset.
otherwise the multiset is a differential multiset.
mcidiff further label a differential multiset as follows.
if 9tk tl mcidiff attaches label same to the multiset.
if 9tk6 tl mcidiff attaches label parameterized to the multiset.
if 9tk mcidiff attaches label gapped to the multiset.
figure shows partial token sequences of the four clone instances shown in table .
we index the four clone instances from left to right as ci1through ci4.
different colors illustrates different categories yellow for types canyon for separators and gray for method field variable literal.
we omit datatype attribute of method field variable literal tokens for clarity.
the first multiset ms1thatmcidiff reports in this clone set is a matched multiset inputstream inputstream inputstream inputstream .
it consists of four identical type tokens inputstream from clone instances ci1 ci2 ci3 and ci4respectively.
several reported differential multisets are ms27 pertfactory netfactory drawfigurefactory svgfigurefactory ms40 openelement openelement ms43 pertdiagram plasmadraw .
these differential multisets identify all parameterized same gapped and same parameterized gapped differences discussed in motivating example.
.
differencing multiple clone instances algorithm presents our mcidiff algorithm.
the algorithm takes two parameters.
the parameter tssconsists of ntoken sequences166algorithm mcidiff require list ts tss list range ciranges ensure list multiset token results ?
list int lcs computelcs tss ciranges foreach token index array tokenindices inlcsdo multiset tokens at corresponding token index tokenindecies from token sequences in tss results add multiset end for list range listdiffranges determinediffranges ciranges lcs foreach diffrange inlistdiffranges do derive a new list of non empty ranges newciranges by removing ranges in diffrnge if1 newciranges size ciranges sizethen results add mcidiff tss newciranges else if newciranges size ci ranges sizethen results add identifysimilartokens tss newciranges else if newciranges size then foreach token index iin the non empty range innewciranges do multiset ?
findrange s corresponding token sequence tsintss multiset add ts results add multiset end for end if end for return results tsderived from code fragments of nclone instances.
the parameterciranges consists of a list of to be compared ranges of token sequences.
each range specifies a range of tokens index of first andlasttokens of a specific clone instance identified by clone instance index ciindexin the clone set .
this range will be compared with corresponding ranges of tokens of other clone instances.
we represent a range of a specific clone instance as ciindex .
initially ciranges contains a range for each clone instance.
range atciranges is initialized as cik length i.e.
the whole token sequence of clone instance cik.
the algorithms generates as output a list of multiset of corresponding tokens can be intss.
note that finding the global optimal alignment for nsequences has been shown to be an np complete problem .
mcidiff adopts progressive alignment approach to compute an approximate solution.
progressive alignment approach has been widely applied to align multiple dna sequences .
it has been shown to be an efficient and accurate approach when sequences are similar.
in this work we apply progressive alignment to align token sequences of code clones.
.
.
computing lcs mcidiff first computes a longest common subsequence lcs across input token sequences tsswithin given ranges ciranges line .
the computation starts with two longest token sequences and then proceeds to shorter token sequences one at a time.
that is computerlcs first computes the lcs of the two longest token sequences and then compares the resulting lcs with the third longest token sequences and so on till all token sequences are compared.
given two token sequences computelcs implements dynamic programming algorithm to compute the lcs between them.
computelcs considers only identical tokens i.e.
tokens with exactly the same category and attributes.
note that our token is enriched with relevant syntactic information as token attributes.this can improve accuracy of lcs computation.
for example if two variable tokens have the same name but different data types computelcs will not consider them as identical tokens.
the results of lcs computation is a list of token index arrays.
the length of lcs is the number of token index arrays in the list.
each token index array contains indicies of ciranges size corresponding tokens one from each toke sequence specified by ciranges .
take the four token sequences shown in figure as an example.
computelcs reports the lcs as a list of token index arrays i.e.
the length of lcs across the four clone instances is .
the first token index array i.e.
lcs indicates that the first token inputstream of four clone instances correspond to each other.
similarly the last token index array i.e.
lcs indicates that the 88th token of clone instance ci1 66th token of ci2 88th token of ci3 and 66th token of ci4correspond to each other.
.
.
determining differential ranges next mcidiff determine differential ranges in token sequences that cannot be fully matched across all clone instances line .
determinediffranges essentially determines gaps between subsequent token indices in the lcs of token sequences specified by ciranges .
for the four token sequences shown in figure determinediff ranges reports five differential ranges two of which are shown in the figure.
for example of clone instance ci1 ci2 ci3 and ci4is a differential range between lci andlcs .
we represent such a differential range as ci2 ci3 ci4 .
this range represents unmatched tokens pertfactory netfactory drawfigurefactory and svgfigurefactory in four clone instances respectively.
ci2 ci3 ci4 is another differential range.
this range represents unmatched token subsequences domi .
openelement plasmadraw and in four clone instances respectively.
note that this differential range consists of only two non empty token subsequences from clone instances ci1andci3.
clone instances ci2andci4contain placeholder subsequences i.e.
no real tokens from ci2andci4in this differential range.
furthermore token subsequences of clone instances ci1andci3can be further matched if we compare only ci1andci3.
.
.
processing differential ranges if a differential range consisting of m m ciranges size non empty token subsequences mcidiff will recursively process these token subsequences by calling mcidiff with a list of new to be compared ranges derived from these non empty token subsequences lines and line .
for example from the differential range ci2 ci3 ci4 mcidiff derives a newciranges consisting of two ranges i.e.
ci1 andci3 .
it then calls mcidiff recursively with this newciranges .
such recursive calls will identify as many identical tokens as possible across clone instances before we use similarity heuristics to determine correspondences between non identical tokens across clone instances.
for example the recursive call to mcidiff with to be compared ranges ci3 identifies the lcs between the two token subsequences and leaves only two identifiers pertdiagram inci1and plasmadraw inci3unmatched.
this can improve efficiency and accuracy of similarity based matching of non identical tokens.
the number of non empty token subsequences in a differential range can be the same as ciranges size for example perfactory netfactory drawfigurefactory svgfigurefactory in the initial167call to mcidiff and pertdiagram plasmadraw in the recursive call to mcidiff .
this indicates that mcidiff cannot identify identical tokens across all token sequences in the range ciranges .
in such cases mcidiff calls identifysimilartokens line to determine correspondences between non identical tokens based on their similarities see section .
.
.
.
generating multisets of corresponding tokens first mcidiff generates multisets of corresponding tokens based on the lcs lines .
it visits each token index array in the lcs list and creates a multiset of corresponding tokens accordingly.
for example for the first token index array lcs mcidiff creates a multiset inputstream inputstream inputstr eam inputstream .
for the last token index array lcs mcidiff creates a multiset g1 g2 g3 g4 .
note that the lcs determined in the recursive call to mcidiff consists of tokens from a subset of all token sequences for example token sequences ci1andci3in the recursive call with ranges ci3 .
thus multisets derived from such lcss will consist of tokens only from this subset of token sequences.
for the rest of token sequences that are not in this subset for example ci2andci4 they essentially contribute tokens to the multiset.
for example based on the lcs of two token subsequences in the ranges ci3 mcidiff creates multisets such as domi domi .
next identifysimilartokens generates multisets of corresponding tokens as it determines correspondences of non identical tokens in a given differential range.
finally if a differential range consists of only one non empty token subsequence mcidiff creates multisets that consist of tokens only from this subsequence lines .
that is all other clone instances contribute to these multisets.
.
identifying correspondences between similar tokens given a list of token sequences tss and a list of differential ranges diffranges identifysimilartokens see algorithm processes toke sequences from the longest to the shortest line .
for each to be compared token sequence ts identifysimilartokens scans it from the beginning to the end.
for a not yet matched token tints identifysimilartokens adds it as seed token to a multiset multiset line .
it then attempts to find similar tokens from the rest of token sequences candtss iteratively lines .
in each iteration identifysimilartokens finds a not yet matched token tcand from all candidate token sequences that is most similar to tokens already in the multiset line .
the similarity between a candidate token and tokens in the multiset sim tcand multiset is computed as the average similarity of tcandand each token t2multiset i.e.
p t2multisetsim tcand t j multisetj.
if this similarity is above the threshold h the candidate token tcandis added to the multiset line and the candidate sequence containing tcandis removed from candidate sequence list line .
this process continues until no more similar enough candidate token can be found lines or candidate sequence list is empty i.e.
all candidate sequences already contribute one token to the multiset line .
if the resulting multiset contains two or more tokens it is added to the results list line .
finally identifysimilartokens scans each token sequence and identifies still not yet matched tokens for which identifysimilartokens cannot find any similar enough tokens in other token sequences.
it creates multisets for these still not yet matched tokens in each sequence.
such multisets consist of only one real token and all other tokens are .algorithm identifysimilartokens require list ts tss list range diffranges h ensure list multiset token results ?
create a new list of token subsequences tbctss from tssanddiffranges foreach token sequence tsintbctss from longest to shortest do candtss tbctss remove ts foreach not yet matched token tintsdo multiset ?
multiset add t while candtss6 ?do find a not yet matched token tcand in all candidate token sequences candtss with maximum sim tcand multiset ifsim tcand multiset hthen break end if multiset add tcand remove the token sequence containing tcandfrom candtss end while mark all tokens in multiset as matched ifjmultisetj 2results add multiset end for end for create multisets for all still not yet matched tokens return results identifysimilartokens only matches tokens with same category.
that is if two tokens are of different categories their similarity is .
given two same category tokens t1andt2 identifysimilartokens computes their similarity sim t1 t2 by comparing the attributes of tokens and relative positions in token sequences.
for keyword or separator operator label tokens sim attr if two tokens have the same symbol or name otherwise sim attr .
for type or method field variable literal tokens sim attris computed as jaccard coefficient of common supertypes of type tokens or data return types of method field variable literal tokens i.e.
jsupertype t1 supertype t2 j jsupertype t1 supertype t2 j. identifysimilartokens computes position similarity sim pos between two tokens t1andt2by measuring their relative positions in corresponding token sequences.
given two ranges r1with length len1andr2with length len2 let first index of r1andr2befi1and fi2 index of t1andt2in token sequences be p1andp2 position similarity sim pos t1 t2 is computed as j p1 fi1 len1 p2 fi2 len2j.
given two same category tokens their overall similarity is then computed as average of their attribute similarity and position similarity i.e.
sim t1 t2 sim attr t1 t2 sim pos t1 t2 .
.
tool support we have implemented mcidiff as an eclipse plugin.
the current implementation parses clonedetective s clone detection report as input.
note that mcidiff does not make any specific assumption about clone detectors.
given a different clone detector mcidiff only needs a new parser to parse clone detection report of that clone detector.
mcidiff consists of three views clone set view clone diff view anddiff property view for interactively inspecting code clones and their differences.
figure shows a snapshot of mcidiff for analyzing code clones in our motivating example.
clone set view lists all the clone sets reported by clonedetective for a subject system.
each row corresponds to a clone set it summarizes the number of clone instances ins average length of code of clone instances loc the number of differential multisets diff and the differential ratio diff loc .
clone sets can168figure snapshot for mcidiff table basic statistics of three subject systems system class loc clonesets precision recall javanewio1.
.
jhotdraw7.
.
.
.
jfreechart1.
.
.
.
be sorted by columns.
double clicking a clone set in clone set view opens diff property view and clone diff view.
diff property view summarizes basic statistics of the selected clone set.
clone diff view visualizes differences across clone instances side by side.
differential multisets are highlighted with different background colors all parameterized with red same parameterized with pink same gapped with green parameterized gapped with purple same parameterized gapped with yellow.
clicking upordown button on top right corner of this view highlights previous or next differential multiset in bold font.
.
ev aluation in this section we report our evaluation of mcidiff approach and tool support.
we evaluated the accuracy of our mcidiff algorithm with three open source java systems javaio jhotdraw and jfreechart .
we also conducted a user study to evaluate the usefulness of mcidiff s differencing reports for eight clone related refactoring tasks.
.
the accuracy of mcidiff table summarizes basic statistics of the three subject systems.
clonedetective reports clone sets in the three systems among which are parameterized and gapped clones.
these parameterized and gapped clone sets contain mean stddev differential multisets.
about lines of cloned code fragments contain parameterized and or gapped differences.
to examine the accuracy of mcidiff the third author manually investigated all parameterized and gapped clones reported by clonedetective .
he used eclipse java editor and java compare.
he spent about hours in building ground truth set dactual of differences in the reported code clones.
among all parameterized and gapped clone sets contain instances contain infigure reordered code elements in code clones stances while the rest contain more than instances.
the third author spent on average less than minute on a instances clone set about .
minutes on a clone set consisting of instances and about mins on a clone set consisting more than instances.
although clone sets consisting of three or more instances account for only .
of all clone sets reported the third author spent about of his time on determining differences in these clone sets.
we used precision and recall metrics to evaluate the accuracy of mcidiff s differencing results.
let dreported be the set of differential multisets reported by mcidiff precision is percentage of correctly reported differential multisets i.e.
jdreported dactualj j dreportedj and recall is percentage of actual differential multisets reported i.e.
jdreported dactualj jdactualj.
table presents precision and recall of mcidiff in the three subject systems.
overall mcidiff is able to detect parameterized and gapped differences in code clones of javanewio jhotdraw and jfreechart with a good combination of precision and recall.
mcidiff is accurate in identifying parameterized differences and added removed statements such as those shown in our motivating example.
but the accuracy of mcidiff will most likely suffer when clone instances have reordered code fragments and or complex expressions.
when code fragments are reordered across clone instances differencing results may become arguable.
figure presents such an example.
at line and of two clone instances parameters for calling tx translate are swapped and also different y b y b height versus x b x b width .mcidiff reports169figure complex expressions in code clones five differential multisets y x y x height width and .
that is mcidiff reports the second parameter of method call at line and the first parameter of method call at line as parameterized and reports the first parameter of method call at line and the second parameter of method call at line as gapped.
this differencing result is arguably correct.
first these differential multisets reveal important differences across clone instances e.g.
yversus x height versus width .
second differential multisets and can still remind developers reordering of parameters.
complex expressions pose another challenge to mcidiff .
for example at line and of the two clone instances shown in figure mcidiff reports gapped differences labels .length ?
followed by a parameterized difference labels lines followed by matched multisets .
a more intuitive differencing result would be a differential multiset consists of the two parameters because it can revel that different clone instances initialize jlabel object in different way.
this is a general limitation of token based differencing approach because it does not consider syntactic structure of the program.
mcidiff favors efficiency and simplicity of token based approach over robustness of syntactic differencing.
in the context of differencing code clones i.e.
similar code fragments our results show that token based approach can produce highly accurate results except for about less than differential multisets involving reorder code fragments and or complex expressions.
.
the usefulness of mcidiff having evaluated the accuracy of mcidiff the next question we would like to address is what is mcidiff s differencing results good for?
.
we conducted a user study to investigate whether mcidiff can help developers achieve better performance in clonerelated refactoring tasks.
we acknowledge that refactoring or removing code clones usually involves many factors other than just checking the differences of multiple clone instances .
however detecting and understanding differences across multiple clone instances is one of the key factors to make informed decisions on clone refactorings.
therefore we deem that clone refactoring is a valid means to evaluate the usefulness of mcidiff.
.
.
study design in this study we chose clonedetective as baseline clone analysis tool to compare with our mcidiff .clonedetective is also implemented as an eclipse plugin which allows us to make a fair comparison between mcidiff andclonedetective in the same development environment.
furthermore clonedetective not only detects code clones it also provides rich features for analyzing detected clones such as pairwise differencing and difference highlighting apsectj based visualization of code clones across multiple files keyword based searching.
we recruited graduate students from the school of software fudan university.
before the experiment we surveyed capabil table statistics of subject clone sets instcomplexity description refactoring mediumclones reside in two methods declared in two subclasses of the same direct superclasspull up methods highclones reside in two methods declared in two classes of the same far away ancestor classdo not suggest refactoring mediumclones reside in two methods of two subclasses of the same direct superclass have parameterized differences in lines of cloned codeextract parameters pull up methods highclones reside in three methods declared in three subclasses of the same far away ancestor classes have parameterized differences in method callscannot be refactored lowclones reside in four methods of the same classreplace method body with method call mediumclones reside in four methods declared in two subclasses of the same direct superclass have parameterized differences in lines of cloned codeextract parameters pull up methods highclones reside in five methods of different anonymous classes contained in three different classes the three different classes have grandparent parent child relations have parameterized gapped differences in lines of cloned codeextract parameters extract a new method in grandparent class mediumclones reside in four methods of the same class have same parameterized gapped differences in lines of cloned codeextract parameters extract method ity of participants including years of programming experience familiarity with java and eclipse and familiarity with code clones and refactoring.
we used matched participant two groups design to allocate participants to study groups.
participants are matched in pairs based on their capability.
each pair is then randomly allocated to experimental group or control group.
experimental group g1using mcidiff to perform refactoring tasks while control group g2using clonedetective to perform the same set of tasks.
we gave a tutorial of mcidiff andclonedetective tool three hours before the experiment and asked the participants to familiarize themselves with important concepts and features of the relevant tool they will use.
both groups g1andg2 were given clone sets in jhotdraw see table .
the eight clone sets used in this study differ in the number of clone instances and their complexity.
the complexity is determined based on whether refactoring decisions and details require mainly localized information within clones or more global information beyond clones e.g type hierarchy information .
participants were asked to answer two questions for each clone set refactoring decision whether these clone sets can be refactored what refactoring can be applied and why refactoring details what has to be done e.g.
reconcile naming inconsistencies extract parameters before clones can be refactored and what are expected outcomes of refactorings e.g.
where to place cloned code fragments .
participants were required to run a full screen recorder throughout experiment sessions.
the recorded task videos enable170table scoring criteria for refactoring decisions and details score criteria irrelevant wrong or non sensible reason general or vague reason partly specific and right reason specific and right reason us to analyze behaviors of each participant after the experiment.
we evaluated participants performance in terms of correctness and quality of their refactoring decisions and details.
we invited two experts one expert developed and maintained an in house jhotdraw application for more than one year and the other expert is a senior software architect from alcatel who has nine years industrial experience and is an expert on software clones and related software maintenance issues.
the two experts were asked to work together to provide ground truth answers for the eight clone sets.
they reached consensus that six clone sets can be refactored see table .
after the experiment we asked the two experts to grade participants refactoring answers.
a score ranging from to see table was given to quantify correctness and quality of participants refactoring decisions and details.
to avoid experimenter expectancy effects the two experts did not know which study group a participant belongs to when when they graded the participant s answers.
.
.
results improvement on performance to evaluate performance improvement of mcidiff we compared scores of refactoring decisions scores of refactoring details and task completion time of experimental group g1 and control group g2 .
hypotheses we introduced the following null and alternative hypotheses to evaluate how different performance of experimental and control groups is.
h0 the primary null hypothesis is that there is no significant difference between the performance of both groups.
h1 an alternative hypothesis to h0 is that there is significant difference between the performance of both groups.
results of individual participants table and table present participants performance in terms of each participant s average score of refactoring decisions average score of refactoring details and average task completion time minutes on eight clone sets.
overall mcidiff users achieved higher scores in refactoring decisions 577versus and refactoring details 430versus than clonedetective users.
mcidiff users also completed the tasks in shorter time 2m53s 44sversus 3m31s 47s than clonedetective users.
table performance of mcidiff group participant decision score details score time mins p1 .
.
1m53s p2 .
.
1m46s p3 .
.
3m18s p4 .
.
3m51s p5 .
.
2m10s p6 .
.
2m40s p7 .
.
3m27s p8 .
.
3m54s p9 .
.
3m24s average .
.
2m53s std.dev.
.
.
44stable performance of clonedetective group participant decision score details score time mins p10 .
.
2m03s p11 .
.
2m48s p12 .
.
3m59s p13 .
.
3m27s p14 .
.
3m48s p15 .
.
3m15s p16 .
.
3m09s p17 .
.
4m09s p18 .
.
4m23s average .
.
3m31s std.dev.
.
.
47s results of hypotheses testing we performed shapiro wilk test on refactoring decision scores refactoring details scores and task completion time of both groups.
the analysis shows that the data conforms to normal distribution.
therefore we used paired sample t tests to evaluate the null hypothesis h0 in terms of refactoring decision score refactoring details score and task completion time.
we evaluate the hypotheses at a .
level of significance.
the results of these three tests are shown in table .
based on the results we reject null hypothesis h0 for all the measures of refactoring decision score refactoring details score and task completion time.
therefore we accept the alternative hypothesis h1 i.e.
there is significant difference between the performance of participants who use mcidiff andclonedetective respectively.
table and table show that mcidiff users achieved higher average scores in refactoring decisions and details and they completed the tasks faster.
thus we conclude that mcidiff group perform significantly better than clonedetective group in clonerelated refactoring tasks.
.
.
discussion our qualitative analysis of two study groups task completion time refactoring decisions and refactoring details suggests that task complete time of clonedetective group prolongs and quality of their refactoring decisions and details degrades as the number of clone instances in a clone set or the complexity of clone instances increases.
in contrast performance of mcidiff group remains stable.
our analysis of task videos and interviews with participants suggests that this is because mcidiff s differencing results provide a consistent and readily available means to investigate differences across multiple clone instances.
the performance of two study groups on instances clone sets i.e.
clone sets and were comparable.
for those clone sets mcidiff s differencing results have no fundamental differences from those of clonedetective .
however for clone sets consisting of multiple clone instances clonedetective users start facing two main challenges.
first clonedetective users have to remember which pairs of clone instances have been analyzed.
this is not an easy task because nclone instances requires n n 2pairwise comparison.
for clone sets with four or more clone instances screen size often does not allow developers to see all n n 2eclipse java compare editors.
some participants tried to split eclipse editor area into several regions to accommodate as many compare editors as possible.
however such arrangement often makes each editor too small to read code effectively.
some participants gave up pairwise differencing when clone sets have or more clone instances.
they opened cloned code fragments in multiple eclipse java editor side by side to visually search for differences.
such visual searching is very demanding for clone sets with complex differences.
for171table results of t tests of hypotheses for the variable refactoring decision score refactoring details score and task completion time.
measurements are reported in the following columns minimum value maximum value median means variance degrees of freedom df pearson correlation coefficient pc statistical significance p tcrit and tstatistics.
h var approach samples min max median 2df pc t tcrit p decision h0refactoring decisionmcidiff .
.
.
.
.
.
.
.
.6e rejectclonedetective .
.
.
.
.
refactoring detailsmcidiff .
.
.
.
.
.
.
.
.
rejectclonedetective .
.
.
.
.
completion timemcidiff 1m46s 3m54s 3m18s 2m53s .
.
.
.
.
rejectclonedetective 2m03s 4m23s 3m27s 3m31s .
example clone set consists of five clone instances scattered in five methods of three different classes.
these five clone instances are different in places each of which contains parameterized and or gapped differences.
second clonedetective users have to remember which clone instances are different from other instances where and how.
as shown in our motivating example some clone instances may be the same in one place but different in other places.
furthermore one clone instance may have different types of differences against other clone instances in a specific place.
identifying these differences is challenging remembering them is even more challenging because the amount of information exceeds the capacity of human working memory .
cognitive studies suggest that human working memory has a capacity of about 2chunks.
however our subject clone sets have on average .
differential multisets each of which contains parameterized and or gapped differences.
our video analysis shows that clonedetective users frequently switch or revisit code editors.
they explained in our post experiment interviews that they were trying to recall differences across multiple clone instances.
the key challenge lies in the fact that these differences are not readily available for use unless they took note to keep track of all necessary information.
ourmcidiff addresses these two challenges in a systematic way.
differences across multiple clone instances are automatically identified with high accuracy.
differences are then visualized side by side so that developers can know where clone instances are different and how by a quick glance.
as such mcidiff users spent more time on further investigating differences and relevant program information.
for example do parameterized differences share common syntactic structure?
in our motivating example the four class pertfactory netfactory drawfigurefactory and svgfigurefactory are all subclases of defaultdomfactory .
such further investigation resulted in better refactoring decisions and more specific refactoring details.
in contrast clonedetective users spent much more time on identifying and recalling differences especially when clone sets consist of multiple clone instances with complex differences.
as such their refactoring decisions and details were usually vague and uncertain.
.
runtime performance of mcidiff our mcidiff algorithm adopts a progressive alignment strategy to apply classic lcs algorithm to multiple cloned code fragments.
it have time complexity o mnd where m is the number of cloned code fragments n is the sum of the lengths of two compared token sequences and d is the number of differences in clones.
lcs algorithm performs well when differences are small i.e.
sequences are similr .
mcidiff is consequently fast because it compares cloned code fragments that are similar to each other.
we used our mcidiff tool to compare all parameterized and gapped clone sets on a pc with a corei7 cpu of .7ghz 4g ram and windows .
it took mcidiff seconds to generate differencing results of these clone sets.
for the largest clone set thatcontains clone instances and loc on average mcidiff took about seconds to detect differences in this clone set.
the differencing result of this clone set consists of differential multisets i.e.
differential ratio of this clone set is .
.
.
threats to validity there are mainly three threats in our evaluation.
first we only studied three small to medium sized java systems.
these subject systems may not contain all representative code clones and clonerelated refactoring tasks.
furthermore our study involved only a limited number of developers.
their capabilities and experience may not be representative.
further studies are required to generalize our findings in large scale industrial systems and with more professional developers.
second differences in capabilities of the two groups of participants may threaten equivalence between experimental group and control group.
to address this threat we had tried our best to allocate participants with comparative capabilities into different groups based on our pre study survey and our evaluation of participants capabilities.
third grading of eight refactoring tasks cannot be completely objective because expert opinions may be biased.
in the experiment we asked the two experts to spend as much time as they need on providing ground truth answers as well as on grading participants answers.
this allows the experts to fully explore the tasks and answers.
to avoid experimenter expectancy effects we hid the participants group information from the experts.
we hope this helps to reduce subjectiveness to the minimum.
.
application we now discuss three applications currently under development in our group that exploit mcidiff s differencing results for software development and maintenance.
.
auto generation of application skeleton framework based software development becomes increasingly common and important.
applications built on a framework must adhere to design structure and coding convention dictated by the framework.
complex frameworks often support generating application skeleton based on predefined code templates.
however these predefined code templates usually generate only bare bones of an application with little or no real features.
alternatively frameworks are often shipped with code examples to demonstrate framework usage.
however such code examples usually cover only some typical usage scenarios of the framework.
we are now investigating clone analysis programming differencing and data abstraction techniques to transform crowdsourced code examples of building applications on a specific framework into reusable code templates.
socio professional medias e.g.
eclipse marketplace github archives fast growing body of crowdsourced code examples.
the mined code templates will record not only commonality but also variations across similar code exam 172ples.
code clone detection is used to detect similar code examples.
mcidiff is used to identify differences across similar code examples.
the differences will be represented as optional or alternative variation points in code templates.
such code templates can be easily customized to generate application skeleton with rich features.
as such application developers can concentrate on the specifics of their applications.
.
simultaneous code editing code clones must be made explicit so that they can be consistently maintenance and managed.
several approaches have been proposed to support tracking and consistent evolution of code clones for example during copy paste modify.
these approaches can propagate changes made to one clone instance to others and thus ensure that common parts of code clones will be consistently modified.
our work shows that code clones can be different in various way.
a change made to one instance may not be necessary in the other instance.
in our motivating example pertproject.read anddrawproject.read calldomi openelement anddomi closeelement while netproject.read andsvgproject.read do not.
these gapped differences represent optional method calls for reading a project file.
furthermore a change in one instance may have to be adapted when propagating to the other instance.
in our motivating example suppose the developers declare a new variable of type pertfactory inpertproject read this change cannot be simply propagated to the other three read methods because the other three methods should use different factory types netfactory drawfactory and svgfactory .
these parameterized differences represent adaptation that have to be made during change propagation.
our results suggest that blindly propagating changes across clone instances may not work.
we are investigating simultaneous editing support for code clones that can intelligently infer where to propagate the change and how based on mcidiff s differencing results.
.
revision control although mcidiff was originally designed for analyzing code clone differences it can be applied in other context where several pieces of similar code need to be compared for example revision control.
an original piece of source code may be modified by several developers in parallel.
this can result in similar but also different codes.
existing reversion control supports only pairwise differencing and merging.
given multiple revisions developers may have to perform cascading pairwise differencing and merging.
this cascading process may produce less optimal output because revisions are analyzed in pairs without considering other revisions globally.
mcidiff can be applied to identify the differences across multiple revisions based on which multi way merging of several revisions can be supported.
.
related work researchers have proposed many techniques to detect code clones based on token ast and program dependence graph .
roy and cordy and koschke provide comprehensive surveys of existing clone detection techniques.
to support scalable analysis in large systems clone detection techniques usually rely on easy to compute similarity metrics to determine similarity between code fragments.
detecting detailed differences while identifying code clones is computational expensive and thus impractical.
our approach proposes to use clone detectors to identify which parts of the system are similar i.e.
where clones are first and then use mcidiff identifies how these clones are different efficiently.researchers proposed clone analysis approaches to aiding the interpretation and management of software clones.
for example genimi uses a scatter plot to visualize code clones detected by ccfinder it also computes several code metrics of clones to aid clone analysis.
these clone analysis approaches examine only information of clones but not differences between code clones.
however one cannot interpret code clones i.e.
similarities without understanding their differences precisely .
cp miner finds bugs based on inconsistent identifiers between clones.
kapser and godfrey classify code clones through syntactic analysis of locality of clones.
these approaches analyze clone instances pairwisely and thus cannot systematically identify and summarize differences across multiple clone instances.
program differencing techniques have long been used in software maintenance tasks.
existing program differencing techniques compare two programs at a time.
for example cottrell et al.
developed a pairwise differencing technique to detect correspondences between two pieces of codes for the purpose of generalization.
however simply applying existing program differencing techniques to multiple programs will result in combinatorial explosion of pairwise differencing operations.
our mcidiff performs token based differencing.
structure differencing algorithms such as may produce more accurate differencing results but they are more computational expensive than token based differencing.
in our work we favour efficiency rather than marginal accuracy in the context of differencing code clones.
techniques for multiple sequence alignments have been studied in the area of bioinformatics for the purpose of aligning dna sequences .
our mcidiff is applied to software programs that have completely different characteristics than dna sequences.
furthermore our approach not only identifies longest common parts across multiple clone instances it also zooms into differential parts to detect detailed differences across multiple clone instances.
.
conclusion and future work in this paper we have presented mcidiff an automatic approach to detecting differences across multiple clone instances.
our evaluation has shown that the accuracy of mcidiff is good in practice and it is robust to analyze different types of code clones.
our user study has demonstrated the usefulness of mcidiff s differencing results for clone related refactoring tasks.
mcidiff is a key component in our clone analysis framework that aims to enable practical use of code clones in software maintenance by summarizing syntactic semantic and differential patterns in code clones.
within this framework mcidiff automatically builds a detailed and accurate report of differences across multiple instances of code clones.
this open up many opportunities for practical applications of code clones in software maintenance such as code generation simultaneous code editing revision control.
.
acknowledgement this work is supported by national high technology development program of china under grant no.2012aa011202 national natural science foundation of china under grant no.
and ntu startup grant m4081029.
.
.
.