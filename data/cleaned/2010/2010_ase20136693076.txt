automated verification of pa ttern based interaction invariants in ajax applications yuta maezawa the university of tokyo tokyo japan maezawa nii.ac.jphironori washizaki waseda university tokyo japan washizaki waseda.jpyoshinori tanabe national institute of informatics tokyo japan y tanabe nii.ac.jpshinichi honiden the university of tokyo national institute of informatics tokyo japan honiden nii.ac.jp abstract when developing asynchronous javascript and xml ajax applications developers implement ajax designpatterns for increasing the usability of the applications.
however unpredictable contexts of running applications might concealfaults that will break the design patterns which decreasesusability.
we propose a support tool called jsverifier that auto matically verifies interaction invariants the applications handletheir interactions in invariant occurrence and order.
we alsopresent a selective set of interaction invariants derived from ajaxdesign patterns as input.
if the application behavior breaks thedesign patterns jsverifier automatically outputs faulty executionpaths for debugging.
the results of our case studies show thatjsverifier can verify the interaction invariants in a feasibleamount of time and we conclude that it can help developersincrease the usability of ajax applications.
index terms ajax reverse engineering model checking design pattern i. i ntroduction asynchronous javascript and xml ajax applications have become essential platforms for daily life and are an integral part of google services facebook and twitter.
asynchronous technologies such as ajax make web applications responsive and are credited with the increase in webusers compared to a decade ago .
a key factor in attracting web users is usability of web applications the ease of using websites corresponds towell designed navigation .
when developing ajax applications developers can implement ajax design patterns for increasing the usability of the applications.
although developers intend to correctly implement the design patterns unpredictable contexts while running applications might con ceal faults that will break the d esign patterns.
we claim that such faults decrease usability therefore a technique for verifying whether the applica tion correctly runs according to the implemented design patterns is required.
several studies have been conducted on state based analysis and testing of ajax applications.
some have succeeded inleveraging dynamic analysis t echniques because ajax applications can interactively mani pulate an interface by using the document object model dom .
although these dynamic techniques can leverage actual doms as the states dom based testing does not help verify the correctness execution paths that are not part of the scenarios and environments given by the developers.
as a static approach guha et al.
presented a technique for extracting the behavior relevantto asynchronous communications using a control flow analysis .
this technique can be used for detecting runtime server requests that do not match the extracted behavior however it is presumed that developers can correctly understand and implement this behavior.
since developers might incorrectly implement their requirements such as ajax design patterns implementing we previously presented a method for extracting state machinesfocusing on interactions with applications in order to support program understanding .
we assume the interactions as triggers that can change the states of the applications as described in section iii.
however developers needed to manually determine whether th e extracted state machines satisfy interaction invariants which does not enable them to exhaustively find faulty execution paths.
for this study we propose a support tool called jsverifier which automatically verifies interaction invariants in ajax applications using the spin 2model checker.
the verification method of jsverifier is mainly divided into the following threesteps step1 jsverifier translates the extracted state machines into an application model that spin can interpret.
to simulatethe application behavior jsveri fier also generates an interaction model extractor .step2 when developing applications developers can store information about implemented ajax design patterns iadp information into a repository.
by obtaining the information via the repository jsverifierdetermines interaction invariants based on ajax design patterns and property patterns and generates verification formulas formulator .step3 jsverifier runs spin for verifying the correctness of the application behavior with the invariants.
if the application behavior does not satisfy the invariants jsverifier suggests faulty execution paths verifier .
we assume that developers can debug the applications using these suggestions debugging .
figure gives an overview of this verification method.
we address the following research questions.
c ieee ase palo alto usa158 extractor verifier ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... implementing debugging state machines faulty execution paths faulty source code debugged source code jsverifier can support ajax design patterns formulator interaction invariants repository iadp information fig.
.
overview of verification method used in jsverifier rq1 can jsverifier automatically verify interaction invariants with given iadp information?
rq2 can jsverifier output verification results in a feasible time?
our contributions are as follows an automated verification of interaction invariants in ajax applications.
a selective set of interaction invariants based on ajaxdesign patterns and property patterns.
implementation of the verification method of jsverifier.
an evaluation experiment with case studies that showsthat jsverifier can verify the invariants in a feasible amount of time.
actual faults that jsverifier can expose in real world ajax applications.
some of the faults are difficult to be exposed using testing techniques.
the remainder of this paper is organized as follows.
first we provide background on ajax application development and give a brief example to explain our work in section ii.
in section iii we describe our proposed tool jsverifier.
we then discuss our evaluation in section iv and discuss related work in section v. finally we conclude our work in section vi.
ii.
b ackground in this section we note how developers develop ajax applications focusing on interactions and increase usability of the applications based on ajax design patterns.
we then give a brief example that illustrates an issue of interaction invariantsin ajax applications.
a. ajax applications developments asynchronous javascript and xml ajax are breed approaches in web applications .
our research target is the interactions with ajax applications as shown in figure .
by leveraging an ajax engine on the client side the applications can asynchronously receive necessary data from servers and partially update a web page without page transitions so that user interactionsuser clientweb pagerequests serverinteractions self interactions research targetserver side scripts web page datadynamically generate according to requestsserver s s fig.
.
interactions with ajax applications it can continuously process user requests on the client side.thus this approach makes web applications responsive .
when developing and maintaining rich internet applications containing ajax applications interactions with the applicationsneed to be considered in order to improve user experience .
since the applications are primarily aimed at providing rich user experience developers are concerned with the following.
interactions that the application can handle.
we argue thatinteractions can be classified into user server and self interactions corresponding to nondeterministic elements such as user events asynchronous server responses and timeouts as shown in figure .
application behavior when handling interactions.
developers can also control whether the application will handle certain interactions.
for determining the application behavior developers need to recognize the effects of enablingand disabling these interacti ons .
hence we can argue that the following is also a concern for developers.
application behavior when enabling and disabling interactions.
unfortunately developers have difficulties in correctly implementing interactions while considering all possible execution paths because an interac tion based behavior depends on unpredictable contexts at runtime.
despite their greatestefforts developers may miss certain paths to be executed which can result in unexpected behavior.
therefore a support tool is helpful to extract st ate machines from applications and to determine whether the extracted model contains any unexpected behavior.
b. ajax design patterns the success of ajax applications lies in their asynchronous technologies in e commerce social networking services and enterprise systems .
these applications can provide rich user experience derived from their asynchronous nature.
toattract an increasing number of web users web usability is a key factor in web applications .
fortunately ajax design patterns contain seventy comprehensive findings in termof usability by surveying many real world ajax applications.
thus developers can leverage the ajax design patterns for increasing usability of applications.
for this study we leverage the findings relevant to an interaction based behavior in ajax applications.
html head script type text javascript src .
js prototype .
js script script type text javascript !
window .
onload seteventhandler 6function seteventhandler r e g type .
onchange calcprice r e g attendee .
onchange calcprice r e g payment .
onchange calcprice r e g addcart .
onclick addcart 11function calcprice calculate and display total price 13function addcart disableaddcard proper control if i s v a l i d i n p u t reqruntrans else alert invalid user inputs enableaddcart proper control 20function reqruntrans new ajax .
request runtrans .php method g e t parameters getparams onsuccess su cceeded 24function enableaddcart addcart .
disabled false 26function disableaddcart addcart .
disabled true 28function succeeded d i s a b l e a l l jumptoconfirm script head body ... p r i c e span id price span div type div select id reg type option id a l l value all days option option id cnf value conference option option id wsp value workshop option select div attendee ... select div payment... select span quantity span input id quantity type text value input id addcart type submit value ad d to cart body html fig.
.
source code of our brief example shopping website.
duplicate orderuser interaction prohibited during transaction i page load ii option select iii add to cart iv disabled add to cart fig.
.
screenshots of our brief example shown in figure however unpredictable contexts of running applications might conceal faults that will break the design patterns.
although developers test whether the application expectedlyruns according to the design patterns testing techniques do not help verify the correctness of all execution paths.
for example the user action design pattern suggests that applications should register user events at page load we call such property as a user event registration i n section iii c. this is because executing user event callback functions before displaying web page elements might cause erroneous behavior.
the current implementation immediatelycompletes the loading of all page elements however iterative and incremental development might lengthen the loading time causing unexpected behavior.
since such software evolution over time might break design patterns we address a challenging issue of automatically verifying whether ajax ap plication behavior contains fau lts that are currently concealed but will be exposed.
c. brief example we give the source code and screenshots of an ajax application as a brief example 3in figures and .
this is a 3running examples are available from ajax application for shopping on a website where users i ii select item options and iii iv add the item to their cart.
this application has a fault th at may cause duplicate orders on e commerce websites such as amazon4and ebay5.w e illustrate how developers implement and test this application using ajax design patterns.
first developers implement the option selection functionality based on the user event registration property.
i page load anonload event is first evaluated when users visit the website line .
then the application calls back a function seteventhandler lines .
ii option select when users select options of an item the browser evaluates an onchange event corresponding to the option widget lines .
in the interface users can see the total price according to their selections which is calculated at a callback function calcprice of the events lines .
then developers visit the website and select the options for testing whether this functionality satisfies the property.
since the application displays the correct price this test is successful.
next developers iteratively implement the item addition functionality.
to avoid the dupli cate order problem developers 4amazon help 5ebay answer center the application of handling the add to cart click only once.
the user action design pattern also suggests that ajax applications can prevent multiple calls of specific userevent handlers we call such property as a user event handler singleton in section iii c. iii add to cart users can also add the item to their cart by clicking a submit button labeled add to cart .
when the button is clicked an onclick event occurs line and the application processes anaddcart function lines .
if the selections are valid line the application sends an asynchronous request to run a transaction for taking inventories on the server side lines and .
otherwise an alert box appears for users to give valid inputs lines .
finally the application asynchronously receives a server response lines and and jumps to a confirmation page line .
to test this property developers click the button with valid inputsand see that the application cannot handle the click due to the immediate jump.
since a previous test case also passed developers finally confirm that the application expectedly runsaccording to two properties derived from the user action design pattern.
however the duplicate order problem arises when users unexpectedly double click the add to cart button.
as we mentioned in the previous section it is difficult to expose this duplicate order problem using a testing technique that leveragesexecution results.
this is because the current implementation does not execute such faulty paths in a reliable network and quickly processes the lightweight transaction.
otherwise the duplicate order problem will be revealed.
iv disabled add to cart to avoid the duplicate order problem developers need to implement the appropriate enabling and disabling of the click so that users cannot interact with the button while the transaction is running lines and .
in summary an interaction based behavior in ajax applications is important but difficult for developers to figure out due to unpredictable contexts.
hence if developers intendto implement and test ajax design patterns for increasing usability unpredictable contexts might conceal faults resulting in an erroneous behavior.
therefore we investigated theautomated verification of inter action invariants based on ajax design patterns in ajax applications for revealing faults that are currently concealed but will be exposed.
iii.
a pproach and implementation jsverifier automatically extracts state machines from ajax applications as shown in figure and verifies the correctness and suggests faulty execution paths of interaction invariants as shown in figure .
we present a selective set of interaction invariants based on ajax design patterns.
a. extracting state machines from ajax applications jsverifier extracts interaction based state machines from ajax applications using a rule b ased static analysis technique.
to show that jsverifier deals with nondeterministic behavior of ajax applications we explain how it works although this technique has been proposed in our previous study .extracting state machines rule based extending call graph abstracting extended call graph distinguishing rules url extended call graph state machines e1 e2 refining relationships among interactions en disabling statements end e3 fig.
.
flowchart for extracting state machines verifying interaction invariants translating into promela model generating ltl formulas end verifying correctness suggesting faulty exec.
path extracted state machines information via repository application and interaction models promela clue to debugging v1 v2 v3 satisfy not satisfy running spin fig.
.
flowchart for verifying interaction invariants seteventhandler init addcart reqruntrans ajax.request succeeded disableall onload onclick onsuccess i iii ii a part of extended call graph b abstracted call graph c refined interaction relationships seteventhandler init reqruntrans succeeded onload onclick onsuccess iv addcart seteventhandler init reqruntrans succeeded onload onclick onsuccess addcart v onclick vi fig.
.
partial example of extending ab stracting and refining call graph of our brief example in figure we assume the interactions shown in figure act as triggers that can change the states of applications.
the interaction that we focus on in this study corresponds to a function callin response to an event firing.
hence states and transitions in the extracted state machines represent function calls and the relationships between them.
our analysis technique for extracting state machines consists of three steps as shown in figure e1 e2 and e3 .
first developers input a url of an ajax application and rules for distinguishing interaction related code fragments distinguishing rules into jsverifier and then it analyzes the source code of the application.
since html css and javascript parsers cannot distinguish event attributes callbackobjects event handling functions and control attributes for example onchange onsuccess ajax.request a n d disabled from other syntax elements developers need to define these elements relevant to the interactions interaction elements in the distinguishing rules.
however state machines constructed by combining the interactions might contain many impossible execution paths resulting in a state space explosion.161table i definitions of elements in our promela model element of promela model definition active proctype app an application process that expresses behavior of an ajax application active proctype interaction an interaction process that interacts with app app state a state in which an application process is app event an event that an application process handles int event an event that an interaction process randomly occurs app ch a channel for passing messages of interactions be tween application and interaction processes flg exit an application process that is set to true when it transitions to an exit state goto app state a goto label expressing an app state of an application d step an atomic process for simultaneously setting the state of an application and making events empty rule based extending call graph e1 to obtain possible relationships among the interactions interaction relationships jsverifier leverages a call graph that represents caller callee relationships.
the call graph does not contain the interaction relationships e.g.
event firing and callback but jsverifier extends the call graph in terms of interactions.
by parsing the source code and finding event attributes and callbackobjects jsverifier creates relationships between invoked functions seteventhandler and their corresponding callback functions addcart and assigns the corresponding event types onclick to the relationships lines and in figure and i in figure .
in cases of event handling functions jsverifier makes connections from the functions ajax.request to the corresponding callback functions succeeded with the corresponding event types onsuccess lines and in figure and ii in figure .
thus by statically analyzing the source code with the distinguishing rules it can extend the call graph to containinteraction relationships.
abstracting extended call graph e2 since the extended call graph might have many relationships irrelevant to the interactions jsverifier then abstracts the extended call graph focusing on the interaction elements.
for example our briefexample runs from reqruntrans toajax.request without any interactions iii in figure .
in this case our tool abstracts this caller callee relationship into the corresponding invoked function of reqruntrans iv in figure .
thus it can obtain possible interaction relationships from the extendedcall graph.
refining relationships among interactions e3 additionally developers can implement enabling and disabling of interactions in ajax applications.
for example in figure the add to cart button is enabled on line and disabledon line .
these statements in the application that set parameters on control attributes of dom elements en disabling statements can be distinguished with the distinguishingrules similar to the interaction elements.
by analyzing the en disabling statements jsverifier adds possible interaction relationships and removes impossible ones.
for example in figure c jsverifier adds an onclick relationship from reqruntrans toaddcart v in figure .
however it does not add any relationship at succeeded vi in figure because all interactions are disabled there line31 in figure .
as for branch nodes such as addcart jsverifier skips this analysis b ecause the relationships from the branch nodes are irrelevant to the interactions.
by constructing state machines based on the refined interaction relationships jsverifier automatically extracts real stateful behavior fromajax applications as shown in figure .
in addition to reading the source code developers can leverage the extracted state machines to understand the stateful be havior of ajax applications.
although developers may be able to find faults relevant to the interactions using the extracted state machines the cost may not be negligible for developers to manually and carefully check th e behavior when they modify the source code.
additionally the more interactions developersimplement in the applications t he larger the scale of the state machines jsverifier extracts.
therefore we can argue that a model checking technique is helpful for revealing erroneousbehavior because it can automati cally verify the behavior of the applications with given flexible invariants.
b. verifying interaction invariants in ajax applications jsverifier leverages a widely known model checker spin for verifying interaction invar iants in the extracted state machines.
given flexible invariants expressed as linear temporallogic ltl formulas spin verifies the correctness of nondeterministic automata described in process meta language promela .
accordingly the model checker is suitable forverifying the extracted state machines that model nondeterministic elements of ajax applica tions.
our verification technique consists of three steps as shown in figure v1 v2 andv3 .
translating into promela model v1 jsverifier first translates the extracted stat e machines into a promela model.
figure iii b shows the code of a promela model translated from part of the extracted stat e machines in figure .
table i lists the definitions of the elements in the promela model.
in this model jsverifier outputs an active proctype named app lines for representing application behavior extracted in the state machines.
the active proctype is a process that spin initially instantiates.
app state 1621mtype define all labels 2mtype app state app event int event 3chan app ch of mtype 4bool flg exit false 5active proctype a p p d step 7a p p state init 8a p p event empty two statements are 9i n t event empty set e m p t y goto init do start of initial do loop app ch?
int event if int event onload app event onload d step a p p state seteventhandler set empty goto seteventhandler do app ch?
int event if int event onclick app event onclick d step a p p state addcart set empty goto addcart do app ch?
int event if int event onsuccess app event onsucess d step a p p state exit set empty goto goto exit i n t event onclick app event onclick d step a p p state addcart set empty goto goto addcart ... od e n d of initial do loop goto exit f l g exit true 46active proctype interaction do if flg exit break e l s e if s k i p app ch!
onload s k i p app ch!
onclick s k i p app ch!
onsuccess ... fig.
.
partial example of application and interaction models in promela app event a n d int event variables are defined for requirement descriptions line .
additionally the app process nondeterministically r eceives messages via app ch line andflg exit is set to true when the process exits lines and .
states in the state machines ar e represented in assignment statements to the app state variable lines and .
to represent transitions in the state machines jsver ifier leverages goto functionalities because promela unfortunately does not allow describing function calls.
by searching all states from an initial one in the state machines jsverifier creates goto labels if the states initially appear lines and .
otherwise it assigns goto statements to correspondinglabels line .
jsverifier is exceptionally designed to deals with an exit state in such a way that spin makes the application process exit lines and .
the application model alone is not sufficient to verify the application behavior because th e application changes its state as it handles interactions.
therefore jsverifier also outputs an active proctype named interaction as an interaction model that represents interactions of the application withthe user server and the application itself lines .
this process randomly selects an interaction that the application can handle and sends the message of the interaction to theapp process lines .
when the app process reaches the exit state spin also makes the interaction process exit line .
thus jsverifier can apply spin to simulate the stateful behavior of the ajax application with the application and interaction models.
to verify whether the application model correctly behaves according to implemented ajax de sign patterns it is difficult for developers to define properties to be verified and to cor rectly express them in verification formulas.
since developers have information about the implemented ajax design patterns jsverifier supports the difficult task by generating correctverification formulas using the information.
c. mapping interaction invariants using property patterns we show a selective set of interaction invariants in table ii.
jsverifier leverages the interaction invariants for generating correct verification formulas so that developers only input information about implemented ajax design patterns.
generating ltl formulas v2 since ajax design patterns contain comprehensive findings for increasing usability of ajax applications we first define properties interms of the interactions from the findings ajax design properties .
these ajax design properties consist of a property name and description for example the user event registration name property explains that ajax applications should register user events at an onload callback description .
to express these properties in correct verification formulas we also leverage the property pattern mappings for ltl which classifies raw property specifications of a gui concurrency logic and communication protocol into occurrence and order patterns.
these property patterns contain template verification formulas with given states and events ofrunning applications.
by relating these property patterns to the ajax design properties we can describe ltl templates using app state app event a n d int event in table i for jsverifier.
note that spin requires a negative property against the expected application behavior.
for example a negativeproperty of the user event registration property means that a user event occurrence var precedes that of a page load var .
therefore we relate the precedence property pattern in the order pattern to the user event registration p1 in table ii .
for the user event handler singleton property the existence property pattern in the occurrence pattern is related because the existence of multiple calls var of the user event var negates the design property p2 in table ii .
thus developers163table ii aselective set of interaction inv ariants of ajax design properties p property ajax design pattern prop.
pattern ltl template with var andvar used in table iii user ev.
registration user action precedence app event !
pageloadev u app event userev user ev.
handler singleton user action existence app state preventfunc a p p event userev sever resp.
before activation on demand javascript precedence app event !
svrresp u app state activatefunc user ev.
before submission explicit submission precedence app event !
userev u app state submitfunc process before submission live form precedence app state !
procfunc u app state submitfunc i select ajax design properties and ii input variables in the ltl templates and then jsverifier can generate correct ltl formulas using the relationships listed in table ii.. here we explain ajax design properties leveraged in our case studies in section iv.
an on demand javascript ajax design pattern suggests that ajax applications should activate specific functionalities var using results of the asynchronous data retrieval after the server responses var1 a server response before activation property .
additionally explicit submission andlive form ajax design patterns suggest that ajax applications should require an explicit users operation var in the former and should process form data var1 inthe latter before data submission var in both user event before submission andprocess before submission properties .
these properties are related to the precedence property pattern similar to the user event registration property p3 p4 and p5 in table ii .
running spin v3 when developers implement and test ajax applications based on ajax design patterns they can input information about implemented ajax design patterns iadp information into a repository of jsverifier.
developers can input function and event names in the source code asvariables for selected ajax design properties.
if the names do not appear in the extracted state machines jsverifier can find corresponding states because it stores abstractioninformation.
this information contains to which states the functions are abstracted.
therefore developers do not need to deeply understand how it works.
by obtaining the information via the repository as input jsverifier automatically generates correct ltl formulas representing the design properties.
then spin traverses in the state space of the promela model and verifies whether the model sat isfies the formulas.
this verification of correctness can assure developers that the applicatio n correctly behaves according to their intentions.
otherwise spin outputs a counterexampleof the ltl formula as a fault oracle and then jsverifier extracts an execution path contai ning the fault from the oracle.
finally jsverifier automatically suggests a debugging clue to the developers as output.
d. use scenario and results of our brief example we explain a use scenario of jsverifier and results of our brief example in figure .
we assume that jsverifier can be used in the context of test driven development where developers first give test cases of additional functionalities thenimprove the source code to pass the test cases.
developers first input interaction invariants of implemented ajax design patterns into the repository of jsverifier then they can debuguntil the invariants are verified as correct.
we now illustrate a jsverifier use scenario with our brief example.
we assume that developers implement functionalities in ajax applications based on ajax design patterns.
developers first select the user event registration property and input itsvariables when implementing the option selection functionality i ii .
then jsverifier verifies the correctness of this implementation.
next developers implement the item additionfunctionality iii and give the information for this additional functionality.
at this time jsverifier determines that the current implementation does not satisfy the additional invariant and suggests a corresponding faulty execution path on the extracted state machines.
we assume that developers candebug using the faulty execution path iv .
finally developers confirm that the application c orrectly runs according to the invariants.
iv .
e va l uat i o n to answer the following research questions we conducted case studies and evaluated jsverifier.
rq1 can jsverifier automatically verify interaction invariants with given iadp information?
rq2 can jsverifier output verification results in a feasible time?
a. case studies we used two real world ajax applications sform6is an ajax application for form validation and login with ajax lwa 7is an ajax application plugin on wordpress8 for replacing a login widget.
these applications are runnableand their source codes are available for debugging.
ad ditionally we prepared a sample ajax application called filedler .
we had implemented this application for motivating our previous study.
table iii shows html css and javascrip lines of codes in these applications loc .
the 1k loc range represents the small medium size in ajax applications.
execution pathsdeveloper implementing repositoryiadp information debuggingjsv erifier d l iii implement item addition functionality iv debug using suggested faulty execution path i ii implement option selection functionality ... ... ... ...... ... ......... ...... ...... higher usability ajax applications ... ... faulty execution path init seteventhandler onload calcpriceonchange onchange onchange addcartonclick onchange onchange onchange onclick reqruntrans block 994 onchange onchange onchange onclick succeededonsuccess alertuser clickonchange onchange onchange onclickfaultyexe init venthandl eronload calcpric enchan geonchange onchan ge addcartonclick onchange oncha onclick isvalidinput vv !
isvalidinpvvangeonchan ge onclic k fig.
.
jsverifier use scenario and results of our brief example b. evaluation methodology in our case studies we first determined properties to be verified and corresponding variables in the three applications as shown in table iii.
since we did not know the intent ofthe original developers of sform and lw a we conducted the determinations based on the source code fragments.
here we explain the representative determinations.
10in the source code of sform we found a validateit function for validating form data and a submit function for submitting the data.
we inferred that the validation process should be executed before the form submission and then we determined the process before submission property and the functions as thevariables in sform.
as for lw a we determined the user event registration property because of a jquery.ready 11fragment in the source code.
the ready is usually implemented for attaching all other event handlers as an alternative to an onload event.
therefore we infe rred that the application should register all user events at the ready.
note that we had known expected behavior and injected faults in filedler therefore we determined appropriate properties and variablesaccording to our intentions.
we stored the properties and the variables as iadp information into a repository of jsverifier.
next we ran jsverifier with the repository.
jsverifier measured the extraction and verification times t eandtv .
additionally jsverifier outputte d the extracted state machines verification results and faulty execution paths.
we debugged the applications using the paths and then ran jsverifier again.
finally we confirmed whether jsverifier could verify thecorrectness.
10all the determinations are available from results and discussion automated verification rq1 jsverifier could automatically verify the correct and wr ong application behavior.
we tested sform according to the faulty execution path and then found that sform actually handled the form submission without any user inputs in the form.
then we debuggedsform to initially disable the submit button and confirmed that jsverifier verified the co rrectness.
these results represent that jsverifier could expose executable faults in ajaxapplications.
additionally we searched the user events on the faulty execution in lw a and then found them in the html source code.
these implementations conformed to undesirable ones shown in the user action ajax design pattern.
we debugged them according to a so lution suggested in the design pattern so that jsverifier could output the correct results.
note that this faulty execution path could not be executed in the current implementation.
these res ults represent that jsverifier could also expose inexecutable but concealed faults.
as for filedler we had already had correct and faulty version of the applications.
we confirmed that jsverifier could suggest the faulty execution paths as e xpected.
therefore we argue that jsverifier correctly works for our verification method.
feasible verification time rq2 in our case studies jsverifier could automatically extract state machines from our case studies and verify pattern based interaction invariants within several seconds as shown in table iii.
most of the run time was required for initializing html css and javascript parsers.
these extraction and ve rification times increase linearly with the number of implemented interactions in ajax applications.
we confirmed that the applications contained the sufficient number of the interactions for using jsverifier in our165table iii results of our case studies loc p property var var te msec tv msec result sform user event registration onload onblur correct onload onclick correct process before submission validateit submit fault user event before submission onclick submit correct lwa user event registration ready submit correct ready click correct ready onfocus fault ready onblur fault filedler user event registration onload onkeyup correct onload onclick correct server response before activation onsuccess inputformtext fault user event before submission onclick dosubmit correct user event handler singleton dodownload onkeyup fault dodownload onclick correct case studies.
additionally jsverifier could expose the actual faults in real world ajax applications in a feasible amount of time.
therefore we argue that js verifier can be applicable for real time use.
costs for debugging faults although jsverifier can suggest faulty execution paths on extracted state machinesas clues to debugging developers need to locate faults in the source code using the clues.
as our future work we plan to leverage solutions in ajax design patterns for faultlocalization.
d. threats to validity internal validity threats we considered two external factors that might affect results in our case studies.
we found sform and lw a via the web so these applications do not affect the internal of jsverifier and the results from using these applications represent the usefulness of jsverifier forour verification method.
however we implemented filedler ourselves to contain the faults relevant to interaction invariants which may be a threat to internal validity.
therefore weintend to conduct additional case s tudies using real world ajax applications such as sform and lw a. additionally we defined ajax design properties from ajax design patterns and related property patterns to the properties.
although these definitions and rel ationships might affect the internal validity of jsverifier results of our case studiesshowed that jsverifier could verify the correct and wrong behavior of the applications and expose the actual faults in the real world applications.
as our future work we intend to present an exhaustive set of ajax design properties and to evaluate the usefulness of jsverifier for exposing actual faultsin the additional case studies.
external validity threats with regards to the generality of our approach jsverifier leveraged spin so it could only deal with requirements that were expressed in ltl formulas.
however there are requirements that are beyond the descriptive capability of ltl for example the reachability of certainstates from any other states.
to verify such behavior we consider leveraging smv which can verify the correctness using computation tree logic ctl formulas.
ctl formulas allowdevelopers to express requirements involving the reachability.
additionally we are currently working on outputting timed automata for uppaal 13using jsverifier.
moreover in our case studies although we could leverage lwa that were sufficiently practical sform andfiledler were simple ajax applications.
we need to obtain more experimental results from analy zing large scale and practical ajax applications.
e. limitations data intensive impossible execution paths jsverifier analyzes only enabling and disabling statements to determine whether an ajax application can handle the interactions.
in fact developers can implement s uch interaction controls also using data flows.
in our brief example in figure user inputs for selecting options can never be invalid line whichmeans that the application can never proceed to the state corresponding to invalid user inputs lines .
such dataintensive impossible execution paths can be dealt with bydom based dynamic analysis .
hence we will extend jsverifier to leverag e contributions of these related work in order to construct a hybrid approach.
however we want to claim that the impossible execution paths would be executable fault candidates for example in case that other developers modify the source code of open source ajax applications or that users install other applicationplug ins.
therefore we argue that our pessimistic analysis is valuable to verify the application behavior containing the fault candidates.
additional ajax design patterns we assume that interaction invariants in ajax applications derive from ajax design modelcheck smv.html in fact developers have their original ajax design pattern and flexible requirements.
when adding new design patterns developers need to define verification properties inthe design patterns and to relate appropriate property patterns to the properties.
otherwise developers can use jsverifier with raw ltl verification formulas.
v. r elated work our approach leverages a reverse engineering technique and a model checking technique.
the former aims to provide alternative views of software artifacts such as for redocumenting programs and recovering design patterns .
especially aview of state machines can improve the code understandability of developers .
the latter is an approach for verifying finite state machines representin g concurrent systems such as sequential circuit designs and communication protocols .
ricca et al.
introduced state based analysis and testing of web applications .
although they regarded web pages as states an ajax technology allows the applications to change their states in a single page.
hence marchetto et al.
presenteda state based testing technique for ajax applications .
their tool called reajax could trace execution results of actual doms extract finite state machines from the trace data and generate test cases based on the state machines.
however developers needed to manually and exhaustively execute ajaxapplications for tracing sufficient execution logs.
mesbah et al.
implemented crawljax that could simulate user events by finding fireab le dom elements and extract finite state machines from ajax applications .
to detect dom based faults such as dead clickable elements the toolanalyzed invariants of the dom structure.
additionally they ran the tool on multiple browser environments for crossbrowser compatibility testing .
moreover their extendedtool called cilla could find faults relevant to the presentation of the applications during crawling .
although they mentioned that static analysis techniques had limitations for revealing faults of ajax applications due to interactive dom manipulations we can apply a static approach for extractingand verifying state machines by focusing on the interactions with the applications.
amalfitano et al.
proposed several ajax applicationindependent state change criteria and an interactive process for extracting finite state machines .
they constructed a tool called creria that could suggest state changes based on the criteria and developers coul d accept or reject the suggestions during executing ajax applications.
although creria effec tively leveraged the heuristics of developers this interactive process was less contribution to the automation.
the above dynamic approaches leveraging execution results cannot verify the correctness of the application behavior because these tools may not execute all possible paths in theapplications.
our motivation for constructing jsverifier is that ajax applications may have inexecutable faults to be exposed.
additionally arzti et al.
presented a method for prioritizing event sequences using historical execution results to improve code coverage .
this approach also dealt with dom basedfaults because html css and j avascript errors are defined in their language specifications.
as for valid event sequences there is no general definition of correct or wrong behavior.therefore developers leverage ajax design patterns to define ajax application independent invariant occurrence and order among interactions as interaction invariants.
guha et al.
proposed a static approach for testing vulnerability of ajax applications .
their framework could analyzecontrol flows in the javascript code and extract the request graph containing sequences of asynchronous communications.
developers can use this framework for detecting runtimeserver requests that do not match the sequences.
however their approach was presumed that developers can correctly understand and implement the app lication behavior.
additionally they addressed existing faults to be detected.
considering that developers will modify the source code of opensource ajax applications and that users will install ajax application plugins we claim that developers should debug fault candidates that will be exposed.
jsverifier can verifythe application behavior containing such the fault candidates.
furthermore as a limitation of their approach they pointed out that it is necessary to analyze disabling event handlers to precisely monitor ajax application behavior.
our analysis scope covers the application beh avior containing such enabling and disabling interactions.
blewitt et al.
conducted detection of gof design patterns in java using semantic constraints .
their concern wasthat software evolution over time would cause breaking the design patterns in their original forms on the implementations.
additionally ghabi et al.
addressed an issue of maintaining requirements to code traces because the software evolution also causes invalidating a requirements traceability matrix.in this study we assume that information about implemented ajax design patterns are correct and it would be interesting to how jsverifier works with the invalid information.
vi.
c onclusions and future work we presented a support tool jsverifier and a selective set of interaction invariants based on ajax design patterns and property patterns.
our aim was to automatically verify thecorrectness of an interaction based stateful behavior in ajax applications according to imple mented ajax design patterns.
the results of our case studies showed that jsverifier couldverify the application behavior and could expose the actual faults in the real world ajax applications in a feasible amount of time.
we concluded that jsverifier could help developers increase the usability of ajax applications.
as our future work we plan to provide an exhaustive set of the interaction invariants.
we are going to exhaustively define interaction related properties from ajax design patterns and relate property patterns to the properties.
additionally weintend to support developers to debug ajax applications using the suggested faulty execution paths.
we are considering using solutions in the design patterns to suggest debugging methods.
moreover we will conduct additional case studies using realworld large scale and practical ajax applications.167references b. stearn xulrunner a new approach for developing rich internet applications ieee internet computing vol.
no.
pp.
.
l. d. paulson building ric h web applications with ajax computer vol.
no.
pp.
.
internet world stats.
dec. world internet usage statistics news and world population stats.
.
available j. nielsen and h. loranger prioritizing web usability .b e r k e l e y c a new riders press .
c. e. downing and c. liu assessing web site usability in retail electronic commerce in proc.
computer software and applications conf.
compsac jul.
pp.
.
m. mahemoff ajax design patterns .
o reilly media inc. .
a. marchetto p. tonella and f. ricca state based testing of ajax web applications in proc.
int l conf.
on software testing verification and validation icst apr.
pp.
.
a. mesbah and a. van deursen invariant based automatic testing of ajax user interfaces in proc.
int l conf.
on software engineering icse may pp.
.
d. amalfitano a. r. fasolino and p. tramontana an iterative approach for the reverse engineering of rich internet application userinterfaces in proc.
int l conf.
on internet and web applications and services iciw may pp.
.
s. artzi j. dolby s. h. jensen a. moller and f. tip a framework for automated testing of javascript web applications in proc.
int l conf.
on software engineering icse may pp.
.
a. guha s. krishnamurthi and t. jim using static analysis for ajax intrusion detection in proc.
int l world wide web conf.
www apr.
pp.
.
y .
maezawa h. washizaki and s. honiden extracting interactionbased stateful behavior in rich internet applications in proc.
european conf.
on software maintenance and reengineering csmr m a r .
pp.
.
garrett jesse james.
feb. ajax a new approach to web applications.
.
available j. duhl white paper rich internet applicationb idc tech.
rep. nov. .
m. driver r. valdes and g. phifer rich internet application are the next evolution of the web gartner inc. tech.
rep. may .
j. farrell and g. s. nezlek rich internet applications the next stage of application development in proc.
int l conf.
on information technology interfaces iti jun.
pp.
.
a. blewitt a. bundy and i. stark automatic verification of design pattern in java in proc.
int l conf.
on automated software engineering ase nov. pp.
.
alavi hamid and avrunin george and corbett james and dillon laura and dwyer matt and pasareanu corina.
may property pattern mappings for ltl.
.
available patterns.projects.cis.ksu.edu do cumentation patterns ltl.shtml g. canfora and m. d. penta new frontiers of reverse engineering inproc.
future of software engineering fose m a y2 p p .
.
s. s. som e and t. c. lethbridge enhancing program comprehension with recovered state models in proc.
int l workshop on program comprehension iwpc jun.
pp.
.
e. m. clarke jr. o. grumberg and d. a. peled model checking .
cambridge ma usa mit press .
f. ricca and p. tonella analysis and testing of web applications in proc.
int l conf.
on software engineering icse may pp.
.
a. marchetto p. tonella and f. ricca reajax a reverse engineering tool for ajax web applications software iet vol.
no.
pp.
.
a. mesbah and m. r. prasad automated cross browser compatibility testing in proc.
int l conf.
on software engineering icse m a y pp.
.
a. mesbah and s. mirshokraie automated analysis of css rules to support style maintenance in proc.
int l conf.
on software engineering icse may pp.
.
a. ghabi and a. egyed code patterns for automatically validating requirements to code traces in proc.
int l conf.
on automated software engineering ase sep. pp.
.