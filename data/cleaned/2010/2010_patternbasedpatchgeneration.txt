automatic patch generation learned from human written patches dongsun kim jaechang nam jaewoo song and sunghun kim the hong kong university of science and technology china darkrsw jcnam jsongab hunkim cse.ust.hk abstract patch generation is an essential software maintenance task because most software systems inevitably have bugs that need to be fixed.
unfortunately human resources are often insufficient to fix all reported and known bugs.
to addressthis issue several automated patch generation techniques have been proposed.
in particular a genetic programming based patch generation technique genprog proposed by weimer et al.
hasshown promising results.
however these techniques can generate nonsensical patches due to the randomness of their mutation operations.
to address this limitation we propose a novel patch generation approach pattern based automatic program repair p ar using fix patterns learned from existing human written patches.
wemanually inspected more than human written patches and found there are several common fix patterns.
our approach leverages these fix patterns to generate program patches automatically.
we experimentally evaluated p aron real bugs.
in addition a user study involving students and developers confirmedthat patches generated by our approach are more acceptable than those generated by genprog.
p arsuccessfully generated patches for27out of bugs while genprog was successful for only bugs.
i. i ntroduction patch generation is an essential software maintenance task since most software systems inevitably have bugs that needto be fixed .
unfortunately human resources are ofteninsufficient to generate patches even for known bugs.
forexample windows was shipped with more than known bugs largely due to limited resources .
to reduce manual effort several automatic patch generation techniques have been proposed.
arcuri and yao introducedthe idea of applying evolutionary algorithms to automaticpatch generation .
dallmeier et al.
proposed an approachleveraging object behavior model and applied this approachto real bugs from open source projects .
weimer et al.
proposed a population based technique leveraging genetic programming .
wei et al.
provided a contract based technique to automate patch generation and showed itsusefulness by applying it to bugs in eiffel classes .
among these the award winning patch generation technique genprog and its extension showed the mostpromising results.
to fix a bug in a given program thistechnique generates variants of the program by using crossoveroperators and mutation operators such as statement addition replacement and removal .
then it runs test cases toevaluate each variant.
genprog iterates these steps until one of the variants passes all test cases.
any program variant1918 if lhs dbl mrk lhs ... if lhs undefined lhs strings scriptable calleescope scope a buggy program.
line throws an array index out of bound exception when getshort icode pc is equal to or larger than strings.length or smaller than .
if lhs dbl mrk lhs ... if lhs undefined lhs scriptable lhs .getdefaultvalue null scriptable calleescope scope b patch generated by genprog.
if lhs dbl mrk lhs ... if lhs undefined i getshort icode pc if i !
lhs strings scriptable calleescope scope c human written patch.
if lhs dbl mrk lhs ... if lhs undefined if getshort icode pc strings.length getshort icode pc lhs strings scriptable calleescope scope d patch generated by p ar.
fig.
patches created by genprog a human developer and p arfor mozilla bug .
passing all test cases is regarded as a successful patch.
they experimentally showed that this technique can createsuccessful patches for out of real bugs .
however genprog has an inherent limitation since this technique basically relies on random program mutations suchas statement addition replacement and removal it is pos sible to generate nonsensical patches.
figure b shows anexample of nonsensical patches generated by genprog for the bug shown in figure a .
compared to the human written patch in figure c genprog s patch completely removedthe strings variable from the program.
note that the program would assign an element of strings tolhs as long as the given index is valid while the patch generatedby genprog does not do this.
although genprog s patch canactually pass all the given test cases developers would not accept the patch as shown in section iv c. c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
public itexthover getcurrenttexthover if ftexthovermanager null return null return ftexthovermanager.getcurrenttexthover fig.
example of null checker a bug fix pattern for null pointer exceptionbugs.
this patch fixes a bug of textviewer.java described in eclipse jdt bug .
it inserts an ifstatement to avoid calling getcurrenttexthover when ftexthovermanager isnull .
to address this limitation we propose a novel patch generation technique pattern based automatic program repair p ar .
this approach leverages knowledge of human written patches.
we first carefully inspected human writtenpatches of open source projects.
interestingly we found thatthere were several common fix patterns.
based on our ob servations we created fix templates which are automaticprogram editing scripts based on the identified fix patterns.
p aruses these fix templates to generate program patches.
although creating fix templates requires manual effort this isonly a one time cost and these templates are highly reusablein different contexts after they are created.
figure d shows a patch generated by our approach that is similar to the human written patch figure c .
to evaluate p ar we applied it to actual bugs collected from open source projects including apache log4j1 rhino2 and aspectj3.
we asked human subjects students and developers to compare patches that they would accept if theywere code reviewers of the anonymized patches generated by p arand genprog.
the results of this study clearly showed that patches generated by p arare much more acceptable than patches generated by genprog.
in addition our approachgenerated more successful patches than genprog p arsuccessfully generated 27patches out of bugs while genprog was successful for bugs.
overall this paper makes the following contributions manual observations on human written patches our investigation of human written patches reveals that thereare common fix patterns in patches.
par an automatic patch generation technique leveraging fix patterns we propose a novel automatic patch generation technique using fix templates derived fromcommon fix patterns.
empirical evaluation we present the empirical evaluation results by applying p arto real bugs.
the remainder of this paper is organized as follows.
after presenting common fix patterns identified from human written patches in section ii we propose our approach p ar i n section iii.
section iv empirically evaluates our approach and section v discusses its limitations.
after surveying therelated work in section vi we conclude with directions forfuture research in section vii.
i common fix patterns identified from eclipse jdt s patches.
fix patterns altering method parameters calling another method with the same parameters calling another overloaded method with one more parameter changing a branch condition adding a null checker initializing an object adding an array bound checker adding a class cast checker ii.
c ommon fixpatterns this section presents common fix patterns identified from our manual investigation of human written patches.
we firstdescribe how we collected and examined a large number ofhuman written patches.
then we report a list of common fixpatterns.
a. patch collection for our investigation human written patches were collected from eclipse jdt .
we used eclipse jdt because it has a long revision history more than years and iswidely used in the literature .
we used the kenyonframework to retrieve bug patches .
b. mining common patches since our goal is to explore human knowledge in patch generation we focused on semantic rather than syntactic changes .
first we examined whether any semantics areadded in or removed from the patches.
second we identifiedthe root cause of each bug and the resolution of the cor responding patch.
lastly similar patches were grouped intocommon patterns.
to reduce manual inspection time we first gathered similar patches using groums .
a groum is a graph based model for representing object usage.
although not designed for patchanalysis groums can help detect semantic rather than syntactic differences.
for each patch we built two groums from two consecutive program versions before and after applying thepatch.
then the differences of nodes and edges between thetwo groums were computed automatically.
we could gatherpatches having the same differences into a group.
although a patch group is not necessarily a fix pattern this can substantially reduce manual inspection time.
to identify fix patterns we first classified patches as additive subtractive or altering patches.
additive patches insertnew semantic features such as new control flows whilesubtractive patches remove semantic features.
altering patchesjust change control flows by replacing semantic features.
we then examined the root causes of bugs and how the corresponding patches specifically resolved the bugs.
for ex ample the patch shown in figure inserts a new ifstatement to avoid a crash when ftexthovermanager isnull .i n this example the root cause is null value and the patch resolves it by adding a new control flow.
some patches address multiple causes and these are called composite patches .
we divided a composite patch intomultiple independent patches and analyzed them individually.
fix patterns after inspecting the patches we identify many recurring similar patches i.e.
fix patterns .
table i shows common patterns identified by our investigation.
these top eight patterns cover almost of all patches we observed.
the followingparagraphs describe the details of each pattern pattern altering method parameters.
example obj.method v1 v2 obj.method v1 v3 description this pattern can fix a bug since it makes the caller give appropriate parameters to the method.
pattern calling another method with the same parameters.
example obj.method1 param obj.
method2 param description this pattern changes the callee in a method call statement to fix an inappropriate method invocation.
pattern calling another overloaded method with one more parameter.example obj.method v1 obj.method v1 v2 description this pattern adds one more parameter to the existing method call but it actually replaces the callee by another overloaded method.
pattern changing a branch condition.
example if a b if a b c!
description this pattern modifies a branch condition in conditional statements or in ternary operators.
patches inthis pattern often just add a term to a predicate or remove a term from a predicate.
pattern initializing an object.
example type obj type obj new type description this pattern inserts an additional initialization for an object.
this prevents an object being null .
pattern adding a null array out of bound and classcast checker.example obj.m1 if obj!
null obj.m1 description these three patterns insert a new control flow in a program.
they often add a new if ... statement to avoid throwing exceptions due to an unexpected state ofthe program.
figure shows an example of these patterns.
overall we found that there are common fix patterns in human written patches.
since these major patterns are used inmany real patches almost to fix bugs we may generatemore successful patches by leveraging them in automatic patchgeneration.
iii.
p ar pattern based automatic program repair pargenerates bug fixing patches automatically by using fix patterns described in section ii c. figure illustrates anoverview of our approach.
when a bug is reported a p ar first identifies fault locations i.e.
suspicious statements byusing existing fault localization techniques .
these fault locations and their adjacent locations are modified to fix the bug.
b p aruses fix templates to generate program variants patch candidates by editing the source code around the faultalgorithm patch generation using fix templates in p ar.
input fitness function fit program r input t a set of fix templates input popsize population size output patch a program variant that passes all test cases 1letpop initialpopulation popsize 2repeat letpop apply pop t letpop select pop popsize fit 5until patch inpop that passes all test cases 6return patch locations.
c program variants are evaluated by a fitness function that computes the number of passing test cases ofa patch candidate.
if a candidate passes all given test cases our approach assumes that it is a successful patch .
other wise our approach repeats the patch candidate generation andevaluation steps.
our approach leverages evolutionary computing techniques to generate program patches.
evolutionary comput ing is an iterative process in which a population is reproduced evaluated and selected.
one cycle of these three steps is calledageneration .
algorithm shows our approach following this evolutionary computing process.
our approach first takes a fitness function fix templates and population size as input.
after creating aninitial population of program variants equal in number to thegiven population size line it iterates two tasks generatingnew program variants by using fix templates line reproduction and selecting top variants based on the given fitness function line evaluation and selection .
this iteration stopswhen any program variant passes all given test cases line5 or when it meets predefined termination conditions seesection iv a .
algorithm returns a program variant thatpasses all test cases as a successful patch for the given bug line .
we adopt this evolutionary computing process because it is effective in automatic patch generation by efficientlyexploring a large number of program variants.
applying anevolutionary computing process to program repair was pio neered by weimer et al.
and arcuri et al.
.
the remainder of this section describes the details of fault localization fix templates and fitness function used in p ar.
a. fault localization to determine fault locations p ar uses statistical fault localization based on test cases .
this technique assumesthat a statement visited by failing test cases is more likely tobe a defect than other statements.
specifically this techniqueassigns a value to each statement in a program.
this valuerepresents a degree of suspiciousness.
our approach uses thatvalue to decide whether a statement should be modified.
this localization technique first executes two groups of test cases passing and failing.
then the technique records thestatement based coverage of both test case groups.
comparingthe coverage of each statement results in one of the followingfour outcomes covered by both groups covered only bythe passing group covered only by the failing group and804if lhs dbl mrk lhs ... if lhs undefined lhs strings scriptable calleescope ... g68 g68 g75 g79 g77 g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g73 g77 g86 g71 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 g79 g78 g68 g86 g77 g73 g79 g78 g77 g86 g71 g68 g79 g78 g73 g77 g79 g71 g78 g86 g68 g77 g73 g79 g78 g71 g86 g68 g77buggy program g68 g68 g75 g79 g77 g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g73 g77 g86 g71 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 g79 g78 g68 g86 g77 g73 g79 g78 g77 g86 g71 g68 g79 g78 g73 g77 g79 g71 g78 g86 g68 g77 g73 g79 g78 g71 g86 g68 g77 a fault localization lhs d if lhs un lhs str scriptable c lhs i s g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g79 g78 g73 g77 g79 g71 g78 g86 g68 g77 g73 g79 g78 g71 g86 g68 g77 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g79 g73 g77 g86 g71 g79 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g73 g77 g86 g71 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 g68 g68 g75 g79 g77 g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g73 g77 g86 g71 g79 g68 g68 g75 g79 g77 g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 b template based patch ca ndidate generation failpass c patch evaluationt accept fix templatepatch candidate g86 g71 g68 g74 g78 g79 g77 g79 g68 g78 g90 g77 g72 g73 g85 g79 g90 g77 g72 g73 g86 g71 g77 g79 g78 g3 ifif f ff fff ff f f f ififlllllllllllllllll iiiiiiiiiiiiiiiiiiii g68 g68 g75 g79 g77 g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g73 g77 g86 g71 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 g79 g78 g68 g86 g77 g73 g79 g78 g77 g86 g71 g68 g79 g78 g73 g77 g79 g71 g78 g86 g68 g77 g73 g79 g78 g71 g86 g68 g77 g86 g71 g68 g74 g78 g79 g77 g79 g68 g78 g90 g77 g72 g73 g85 g79 g90 g77 g72 g73 g86 g71 g77 g79 g78 g86 g68 g68 g75 g79 g77 g68 g79 g77 g79 g68 g77 g73 g79 g30 g71 g86 g78 g79 g77 g75 g86 g71 g79 g78 g77 g73 g71 g86 g68 g73 g36 g86 g74 g68 g71 g86 g73 g68 g86 g71 g73 g68 g86 g79 g71 g77 g74 g79 g78 g68 g77 g68 g86 g74 g68 g71 g73 g30 g79 g54 g71 g79 g77 g78 g73 g79 g78 g68 g86 g77 g71 g73 g30 g79 g77 g68 g86 g71 g79 g73 g77 g86 g71 g79 g71 g86 g73 g86 g68 g71 g73 g86 g71 g68 g73 g86 g71 g68 g86 g71 g79 g78 g73 g77 g71 g68 g86 g79 g77 g79 g78 g68 g86 g77 g73 g79 g78 g77 g86 g71 g68 g79 g78 g73 g77 g79 g71 g78 g86 g68 g77 g73 g79 g78 g71 g86 g68 g77repairedprogram faultlocation fig.
overview of our pattern based program repair p ar approach.
p arfirst takes a buggy program and a identifies fault locations.
then b it generates program variants by using fix templates which are program editing scripts derived from common patch patterns section ii c .
the templates modify source code around t he fault locations.
these variants are patch candidates.
finally c patch candidates are evaluated by using test cases.
if a candidate passes all test cases we assume it is a p atch for the bug.
otherwise our approach repeats steps b and c to generate another patch.
2p program 3b fault location ast analysis 6c collect object