programs tests and oracles the foundations of testing revisited matt staats michael w. whalen and mats p .e.
heimdahl department of computer science and eng.
university of minnesota cs.umn.edu abstract in previous decades researchers have explored the formal foundations of program testing.
by exploring the foundations of testing largely separate from any specific method of testing these researchers provided a general discussion of the testing process including the goals the underlying problems and the limitations of testing.
unfortunately a common rigorous foundation has not been widely adopted in empirical software testing research making it difficult to generalize and compare empirical research.
we continue this foundational work providing a framework intended to serve as a guide for future discussions and empirical studies concerning software testing.
specifically we extend gourlay s functional description of testing with the notion of a test oracle an aspect of testing largely overlooked in previous foundational work and only lightly explored in general.
we argue additional work exploring the interrelationship between programs tests and oracles should be performed and use our extension to clarify concepts presented in previous work present new concepts related to test oracles and demonstrate that oracle selection must be considered when discussing the efficacy of a testing process.
categories and subject descriptors d. .
testing and debugging general terms theory keywords theory of testing testing formalism this work has been partially supported by nasa ames research center cooperative agreement nna06cb21a nasa iv v facility contract nng 05cb16c and nsf grants ccf and cns .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.
.
introduction for several decades testing has been an important research topic and a standard part of software development practice.
in the 1980s and early 1990s several authors explored the theory of testing in an attempt to put testing research on a solid formal foundation and provide coherent frameworks for discussion.
notable contributions include explorations of the problem of test set selection the problem of constructing test data adequacy criteria the need to compare test data adequacy criteria the use of input partitioning when constructing test data adequacy criteria and the use of test hypotheses when selecting test sets .
this body of work largely discusses the foundation of testing the goals underlying problems and limitations of testing separate from any specific method of testing.
while these early contributions are valuable and helped shape the direction of testing research as well as our understanding of testing practice this body of work has unfortunately not established itself as a foundation for continued testing research new testing approaches are typically informally described and generally poorly evaluated.
this lack of a formal foundation and rigorous evaluation of proposed new approaches has been a persistent problem in the research community .
consider as examples the generally well conducted and highly influential studies of rothermel et al.
and wong et al.
.
although these studies provide insight into test suite reduction crucial aspects of the experimental setup such as what test oracle was used and the nature and structure of the programs under test are omitted or left implicit leaving the reader to infer these properties of the artifacts.
this in turn makes it difficult to interpret the conflicting conclusions reached in the studies.
we believe these problems can be traced to the lack of a common foundation for empirical testing research making it difficult if not impossible to conduct for example meta analysis synthesizing the empirical results from several independent investigations.
in this work we attempt to remedy this situation and provide a common framework for empirical testing research by revisiting work on the formal foundations of testing highlighting and clarifying issues with the existing work.
we have identified two issues with the existing formalizations that we believe should be addressed.
first the existing formalizations overlook certain factors influencing testing notably test oracles leading to implicit assumptions about testing that may not be true in practice.
these assumptions make it straightforward to prove properties about different aspects of testing for example properties about test coverage criteria but such assumptions lead to research results that may be misleading or may not be generally applicable in real testing projects.
in addition as mentioned above such implicit assumptions makes comparisons of research efforts difficult.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
391p s t osyntactic structure may guide test selectionsemantic s dete rmine s propagation of errors fo r each test combination of o and t determines efficacy of testing process tests suggest variables worth observingtests designed to di stinguish i ncorrect p from ss may guide test selectionp attempts to implement s o approximates s observability of p limits information available to ofigure example relationships between testing factors.
second most foundational research has focused on narrow aspects of the testing problem for example criteria for selecting tests or techniques to generate tests from programs.
we believe a holistic view of the testing problem is essential to move the field forward and yield practically useful results in testing research both in terms of theoretical and empirical results.
in particular the interrelationshipbetween the programs under test the test set selected and the oracle used is not well understood.
for example the effects of program structure on the efficacy of structural coverage criteria and the effect of oracle selection on fault finding have not been adequately explored in current literature.
the implications of this extend to all testing processes.
we have in our empirical work observed how failing to consider all factors in testing can impact the efficacy of the testing process specifically how the the structure of the program under test affects the efficacy of the mc dc structural coverage criterion and how the percentage of program state considered by an oracle and the size of a randomly generated test set jointly influence fault finding ability .
in this paper we begin to address these issues by first providing a formal foundation of testing acknowledging the role of test oracles in the testing process.
we then use this framework to explore the interrelationship between the artifacts involved in software testing.
in particular we consider how one common implicit assumption the existence of a test oracle affects the results of previous work on the theory of testing.
we find this implicit assumption is key to existing results demonstrating for example that comparisons between test coverage criteria must be made with respect to a constant test oracle we clarify existing work demonstrating for example that the spectrum of mutation testing techniques in fact represents one technique defined in terms of the adequacy of both a test set and an oracle and finally we discuss new concepts defining for example desirable properties of test oracles such as sound andcomplete .
based on our formalization and observations we identify a collection of research challenges we see as important to further the frontiers in software testing.
.
a holistic view of testing early work on the testing process focused on test selection leading to the definition of test data adequacy criteria by goodenough and gerhart as well as others .
subsequent work in testing has reinforced this test selection centric view of testing with one author even observing that the problem of testing is to find a graph and cover it .
unsurprisingly a large quantity of work explores issues such aswhat test coverage criteria to use and how to generate tests satisfying those criteria.
nevertheless some authors have acknowledged and explored the influence of other artifacts on testing research.
in figure we illustrate the interrelationships between testing artifacts commonly discussed in the literature specifications programs tests and oracles.
in this context specifications srepresent the abstract perfect notion of correctness the only arbiter of correctness representing the true requirements of the software not the possibly flawed requirements as captured in a document or formal specification.
some of these relationships are straightforward and intuitive.
for example the relationship between the specification and the other artifacts is obvious the program is derived from and intended to implement the specification for instance through requirements capture architecture design and coding or through the creation of a formal model and code generation tests are in a similar way derived from the specification and are intended to demonstrate executions where the program violates the the specification and similarly the oracle is based on the specification and is intended to determine for each test if the program has violated the specification.
the interrelationships between programs tests and oracles are less obvious however and warrant further discussion.
it is easy to see that all three artifacts are intertwined in the testing process.
for example consider a stateful embedded program with a sequence of simple decisions1.
in testing such a program it is likely that longer test cases will be beneficial allowing corrupted state to propagate to outputs.
it is also likely that a more powerful oracle considering internal state information will be beneficial since it may be able to detect corrupted internal states early.
in using longer test cases however we reduce the benefits of using an oracle observing internal state as corrupted state information is more likely propagate to the output.
thus the characteristics of the program suggest two methods of improving fault finding but the use of one method diminishes the value of the other.
such issues involve the largely unexplored interrelationship between programs tests and oracles.
while programs tests and oracles are intertwined to manage the complexity of testing research we tend to think of the artifacts in terms of pairs.
most testing research has been concerned with the relationship between programs pand testst.
examples include the development of structural coverage criteria where the adequacy of a test suite is based on how well it covers syntactic aspects of the program structure and the creation of automated techniques to generate tests providing the desired coverage .
work 1a decision in this context is any boolean expression containing a boolean operator.392relating other aspects of programs and tests is less common and includes work by rajan et al.
on how the structure of the program affects the efficacy of a test suite providing structural code coverage and work by voas et al.
and others demonstrating how the likelihood of errors propagating to the output can be used to guide test selection .
in comparison the interrelationships between oracles oand both the programs por the teststhave received relatively little attention.
concerning the interrelationship between the programs pand oracleso voas et al.
explored how testability information can be used to identify program locations where faults can hide thus indicating locations where assertions may be placed to improve the quality of the oracle .
concerning the interrelationship between teststand oracleso there have been a handful of studies investigating how the oracle and test set used jointly affect fault finding including work by memon et al.
in the domain of gui testing work by briand et al.
comparing state based invariants and input expected value oracles and our own work exploring the joint affect of oracle data and test suite size .
the practical implications of this holistic view of testing are threefold.
first we must develop new theories techniques and tools for finding effective combinations of program characteristics tests and oracles.
in the next section we propose an extension to gourlay s testing framework aimed at addressing the lack of testing theory related to oracles.
we provide a formal treatment of oracles oracle selection and oracle properties similar to that provided for tests and test selection.
note that this formal framework is intended to provide a conceptual framework that can be used as a foundation for future work in empirical software testing research not as a framework intended to prove obscure and often unrealistic properties of the testing process.
second empirical research should more accurately reflect the holistic nature of testing.
at a minimum testing research should make explicit what is changed e.g.
the coverage criterion and what is kept constant e.g.
the structure of the program and the oracle .
authors should then clearly state why their experimental parameters were chosen and argue why they are reasonable.
unfortunately this has not generally been the case in the literature leaving the reader to guess what types of programs and oracles the research generalizes to.
other researchers have also expressed concerns regarding these issues for example briand touches upon some of these issues in his discussion of validity issues in empirical testing research .
finally we must study the interrelationships between artifacts in greater detail in particular we believe greater study on the effect of test oracles is warranted.
example questions concerning the relationship between oracles and programs include how do we create suitable oracles for stateful programs where errors may take significant time to propagate to outputs?
.
example questions concerning the relationship between oracles and tests include given test coverage criteria sensitive to program structure which internal variables should the oracle observe to improve fault finding ability ?
and more generally given finite testing resources for this a program pwhat combination of tests tand oracleoshould i use to achieve high levels of fault finding?
maybe improving the test oracle by inserting more assertions in the code may be a more cost effective solution than producing more tests.
.
functional model of testing beginning with goodenough and gerhart s seminal work a significant portion of the research in the theory of testing has used a functional model for testing a convention we follow here.
we define our functional model of testing based on gourlay s frame work extending and modifying it for our discussion.
we have selected gourlay s framework as a basis for two reasons.
first a significant quantity of relevant theoretical work is based on this formalization by extending his framework we can easily reexamine this previous work.
second the framework is easy to understand and mostly matches our intuitive sense of the testing process.
in gourlay s approach a testing system is defined as a collection p s t corr ok where sis a set of specifications pis a set of programs tis a set of tests corr p s ok t p s as in our discussion in the previous section each specification s srepresents an abstract perfect notion of correctness.
the predicate corr is defined such that for p p s s corr p s impliespis correct with respect to s. of course the value ofcorr p s is generally not known this predicate is thus theoretical and used to explore how testing relates to correctness.
the predicate okis defined such that for p p s s t t ok t p s implies that pis judged as correct with respect to specification sfor testt.
furthermore okis defined such that p p s s t t corr p s ok t p s i.e.
ifpis correct with respect to sthenokis true for all tests.
the predicate okapproximately corresponds to what is now called a test oracle or simply oracle .
while intuitively appealing there are problems with this framework.
first each testing system has only one possible oracle ok .
just as there exist many possible tests and programs however there exist many possible oracles for determining if test executions are successful .
selecting an oracle is the problem of oracle selection and we cannot easily discuss or even formulate this problem using gourlay s framework.
second the notion of correctness and how it relates to test oracles is in our opinion too coarse.
if for p pands s ifcorr p s then we know that t t ok t p s .
however there are no requirements on oracles in terms of their effectiveness in finding faults.
for example the oracle that universally returns true for all programs and specifications satisfies this relationship.
furthermore it will often always?
be the case that the program p does not satisfy the specification s i.e.
corr p s in which case the framework places no constraints on ok. both the inability to discuss oracle selection and the loosely specified relationship between program correctness and oracle behavior create difficulties and ambiguities when discussing the effectiveness of test selection techniques and test oracles.
we therefore make two major changes to gourlay s definition of a testing system.
first we remove the predicate ok replacing it with the set oof test oracles.
we state that an oracle o ois a predicate o t p an oracle determines for a given program and test if the test passes.
second we add a predicate defining correctness with respect to a testt t. this predicate is2 corr t t p s the predicate corr t t p s holds if and only if the specification s holds for program pwhen running test t. obviously p p s s corr p s t t corr t t p s 2note that the tsubscript incorr tis used to differentiate the predicate from gourlay s corr predicate.
it does not relate to any specific testt393in summation we define a testing system to be a collection p s t o corr corr t where sis a set of specifications pis a set of programs tis a set of tests ois a set of oracles corr p s corr t t p s to keep things general we make no attempt to define what exactly constitutes a test oracle specification or program.
we state that a test sometimes called test data is a sequence of inputs accepted by some program.
as in gourlay s framework we consider a specification s sto be the true idealized specification of the desired functionality of program p possibly including internal state behavior.
as mentioned earlier it is quite likely that the stated software requirements or formal specifications used in the development of a program differ from s. finally we note that the predicates are partially defined not all tests can be executed on all programs and not all oracles can be used to determine if a test tis successful when run against a program p. these modifications to the framework allows us to have a more realistic discussion of the testing problem and explore the interrelationships between programs tests and oracles.
.
test oracles a test oracle determines if the result of executing a program p using a testtis correct.
there are many methods of creating an oracle including manually specifying expected outputs for each test monitoring user defined assertions during test execution and verifying if the outputs match those produced by some reference implementation for example an executable model.
a uniform method of describing the numerous types of oracles is outside the scope of this work.
nevertheless we can define general oracle properties.
we begin by defining oracle properties related to correctness of the program being testing borrowing terms commonly used in software verification.
an oracle is complete with respect to program pand specification sfor a test case tif corr t t p s o t p complete oracles relate to correctness as we intuitively expect if the result of running toverpis correct with respect to s the oracleo will state the test passes.
most oracles discussed in testing research and used in practice are designed to be complete though like all software engineering artifacts oracles are imperfect and may contain flaws.
for example a common problem is an oracle that is too precise.
the oracle may have been defined to expect an output of 3but the program generates .
.
in the application domain this accuracy in the computation is perfectly fine and the program is thus correct but the oracle will reject the test.
nevertheless in order to discuss the efficacy of the testing process researchers often assume the oracle used is complete.
note that gourlay s ok predicate is by definition complete if corr p s .
an oracle is sound with respect to pandsfor a test case tif o t p corr t t p s sound oracles represent the conventional wisdom in testing that testing may be imperfect but at least we know that the program is correct for the tests we have run.
for this statement to hold we must use a sound oracle.
unfortunately in practice oracles are rarely sound.
for example an oracle might only observe a subset of the program outputs and or the program s persistent state and would naturally miss any faults manifested in the variables or state not observed by the oracle.
for this reason we do not assume sound oracles in our discussion.
we say that an oracle is perfect with respect to p s andtif it is both sound andcomplete .
we can now generalize the definitions of complete sound andperfect to test suites and again to the entire set of tests.
for example an oracle is perfect forpandsif t o t p corr t t p s .
as mentioned above oracles need not be sound nor complete oracles may both fail to detect faults and may detect faults that do not exist.
heuristic oracles may be neither sound nor complete and may be used in domains like image processing where precisely defining correctness is difficult or time consuming .
relating this type of oracles to correctness would require probabilistic arguments and is beyond the scope of this work.
weyuker informally discusses these oracle characteristics in noting several practical challenges concerning test oracle construction we are unaware of any formulation of these oracle properties however.
in this paper we will often consider oracles which base correctness partly on the internal state of the program.
such oracles may be constructed if the specification defines behaviors internal to the program e.g.
state invariants or class invariants .
in some situations these oracles will detect faults that do not propagate to the output at least not immediately .
we use avizienis and laprie s terminology in which a fault is defined as a system state where a design error manifests.
thus detecting a fault is not synonymous with detecting a failure .
.
.
oracle data as noted above the problem of constructing an oracle while in principle simply involved partitioning each t p tuple into true andfalse outcomes is quite complex in practice.
many factors in oracle selection are dependent on the method underlying the construction of the oracle these factors are outside the scope of our framework.
one factor present in all oracles however is the portion of the program state considered by the oracle which we term the oracle data.
for example a commonly used oracle in the testing literature is one which determines correctness for test tby comparing the outputs produced by the program to outputs specified in the oracle.
the oracle data for this oracle is the set of outputs.
if the oracle were instead to consider the value of every internal variable as well as the output the oracle data would be the set of program variables internal as well as outputs .
for simplicity in this paper we limit our discussion to oracles where the oracle data is a set of variables.
in our discussions we will use as examples oracles that operate by comparing values produced by the program for some test against expected values for said tests.
we will refer to such oracles as input expected value oracles .
when presenting several oracles for the same system these oracles will typically differ in their oracle data.
highly related to our discussions in this section richardson et al.
discuss the oracle problem the need for testers to provide a test oracle for the testing process .
this work has served as the standard for oracle terminology the authors define the oracle information and the oracle procedure .
the oracle information specifies the correct behavior and the oracle procedure verifies the test execution with respect to the oracle information.
we consider the issues of oracle information and oracle procedure to be specific to the method of oracle construction.
defining precisely what constitutes oracle information and what constitutes oracle procedure is difficult and we therefore make no attempt to394incorporate them into our framework.
we instead opt to use definitions that are useful in discussing all oracles such as complete and oracle data .
.
test and oracle adequacy gourlay defines a test methodmas a function m p s t thus a test method takes a program and a specification and generates a test.
gourlay appears to also consider test methods m p s 2t that is test methods producing sets of tests.
nevertheless the use of test coverage criteria also called test data adequacy criteria ortest selection criteria where one or more or none test sets are acceptable for a given program and specification is much more common in both the testing literature and in practice.
we thus adopt it here using the predicate definition originally presented by weiss tc p s 2t.
we are exploring how test oracles influence the testing process.
we therefore propose an analogous concept for oracles termed an oracle adequacy criterion .
an oracle adequacy criterion ocis a predicate oc p s o. this predicate reflects how oracle selection is usually done in practice a single oracle is used to evaluate the result of every test.
most testing approaches used in practice or described in the testing literature can be described using tcandoc.
however it is possible to define adequacy of the testing process in terms of both the test set and the test oracle used i.e.
define adequacy as a pairing of a test set and an oracle.
we define a complete adequacy criterion as the following predicate toc p s 2t o for example a stateful program responsible for mode switching in an avionics systems may be best combined with a test suite providing mcdc coverage and an oracle observing a majority of the internal state variables in addition to all outputs.
in section we will explore an existing example of a complete adequacy criterion.
.
oracle comparisons by extending gourlay s framework with a set oof oracles we have introduced the problem of oracle selection the problem of selecting an oracle ofrom a set of possible oracles.
just as with the problem of test selection we desire some method of estimating the relative usefulness of oracles.
unfortunately we are unaware of any comparison relations specific to oracles though mutation testing represents a method of comparing combinations of test inputs and test oracles see section .
.
to facilitate such comparisons we present several possible oracle comparison relations based on the test coverage criteria comparison relations explored by several authors and discussed in this paper in section .
.
our oracle comparisons like test coverage criteria comparisons are based on the ability of the oracles to detect faults.
recall that an oracle is complete with respect to pandsif for all tests t corr t t p s o t p in other words when a fault is detected by o the fault is real i.e.
it represents an error in the program.
as most oracles discussedin testing research are designed to be complete the oracle comparisons we present assume complete oracles.
comparisons between non complete oracles would require a different approach accounting for oracles signaling faults when none have occurred.
.
power comparison our first relation is based on gourlay s definition of power .
we state an oracle o1has a power greater than or equal to oracle o2with respect to a test set ts writteno1 tso2 for program p and specification sif t ts o t p o2 t p in other words if o1fails to detect a fault for some test then so doeso2.
ifo1 tso2 it is possible that o1ando2are equally powerful i.e.
t ts o t p o2 t p .
we may wish to state that some oracle o1is strictly better than an oracleo2.
we state that o1is more powerful than o2for test set ts o1 tso2 if t ts o t p o2 t p t prime ts o1 t prime p o2 t prime p in other words o1 tso2and for some test t ts o1detects a fault whereo2fails to detect a fault.
var x int var y int if input true x else y figure oracle comparison example program note that power is relative to a fixed test set ts.
given different test sets the relative power of oracles may vary.
consider the sample program pin figure .
consider two oracles oxandoy with both oracles being simple input output oracles and with oxhaving oracle dataxandoyhaving oracle data y. consider two test sets ttandtf each with exactly one test such that ttsetsinput to true andtfsetsinput to false.
assume both lines and are incorrect e.g.
wrong constant is assigned .
then ox ttoy oy tfox for some pairs of of oracles it may be the case that ts 2t o1 tso2 in other words o1has power greater than or equal to o2for all possible test sets ts.
in such a case we state that oracle o1has power universally greater than or equal to oracle o2 writteno1 o2 .
for example consider an oracle oadefined in terms of a set of assertions a where oa t p indicates that test tviolates an assertiona a. leta primebe an additional set of assertions and let oracleoa2be an oracle defined in terms of a set of assertions a a prime.
as the set of assertions used by oa2is a superset of the set of assertions used by oa for any test set ts oa2 tsoa and thusoa2 oa.
a similar situation occurs when an oracle o1 is observing a superset of the oracle data observed by an oracle o2 for example o2observes the outputs from the program and o1 observes additional internal state information.
given that both o1 ando2are complete o1 o2.
.
probabilistic comparison the power relation is a fairly restrictive relation between oracles ifo1 tso2 then not only does o1detect more faults it must detect every fault detected by o2.
while this relationship will often hold for oracles constructed using the same basic principle e.g.
sets of assertions we desire a method of comparing the effectiveness of alloracles i.e.
a total comparison relation.
weyuker et al.
recognized this problem with respect to test coverage criteria and have defined a more useful probabilistic comparison between test criteria called probbetter .
we will hereafter refer to probbetter aspb.
a criterion c1ispbthan c2with respect to program pand specification sif a randomly selected test set satisfying c1is probabilistically more likely to detect a failure inpthan a randomly selected test set satisfying c2 written asc1pbc .
a randomly selected test set refers to a test set drawn from the set of all possible test sets satisfying a criterion c. as most criteria are monotonic the number of test sets satisfying c is often very large or infinite .
consequently it can be difficult toprove thatc1ispbthanc2 nevertheless empirical studies of test coverage criteria effectiveness can be used to approximate this relationship indeed this is arguably one of the primary contributions of such studies thus rendering this criterion comparison and other similar probabilistic comparisons useful.
we base our total oracle comparison on the weyuker et al.
pb relation.
we state an oracle o1ispbthan oracleo2with respect to a test setts o1pbtso2 for program pif for a randomly selected test t ts o1is more likely to detect a fault than o2.
we stateo1is universally pbthan o2ifo1pbto2 wheretis the entire set of tests that can be run againstp.
this is conceptually different from the definition of universally greater power outlined above.
we can show power is a strictly stronger relation than pbwhen applied to oracles i.e.
for test set tsand program p o1 tso2 o1pbtso2.
assume we have oracle o1ando2such that for test set tsand programp o1 tso2.
for any test t ts one of the following is true o1 t p o2 t p o1 t p o2 t p o1 t p o2 t p in other words for all t tsit must be true that neither oracle detects a fault both oracles detect a fault or o1detects a fault while o2does not.
based on the definition of oracle power it cannot be the case that o2detects a fault if o1does not detect a fault.
clearly given an randomly selected t ts o1is at least as likely to detect a fault as o2.
furthermore we know there exists at least onet tssuch that o1 t p o2 t p note the use ts and thus for at least one t ts o1is detects a fault that o2does not.
therefore o1pbtso2.
.
oracle metrics arguably one of the core contributions of testing research is evaluating how testing approaches relate to one another.
unsurprisingly then a number of metrics have been proposed for discussing the set of programs pand the set of tests t including software testability various test coverage criteria and the test coverage criteria comparison relations of power probbetter subsumes etc.
.however we are unaware of any metrics specific to test oracles.
in this section we have proposed two basic oracle comparison metrics and have shown that the more restrictive but non total comparison power implies the less powerful but total comparison pb.
these metrics allow us to compare oracles and highlight a potential albeit in retrospect rather obvious avenue for research into oracles analytically and empirically comparing different oracles as is commonly done for test coverage criteria.
future work in oracles may yield more metrics not explicitly based on fault finding ability.
in the remainder of the paper we will explore how our extended framework explicitly considering test oracles influences the testing process.
.
applications to previous work in this section we revisit some earlier influential work in testing exploring how explicitly considering a test oracle affects the results.
we also explore how existing research can be used to discuss problems related to test oracles.
.
comparing coverage criteria a significant portion of the theoretical and empirical testing research is concerned with methods of comparing coverage criteria.
while several methods have been proposed they implicitly assume the presence of an oracle.
this can lead to conclusions relying on key assumptions that are either unstated or minimally discussed.
if we instead consider that the oracle may vary we can arrive at conclusions that are different from published results in subtle but important ways.
.
.
power comparison we first illustrate why oracles are relevant using the power relation first proposed by gourlay for test methods and subsequently adjusted by weiss for use with test coverage criteria.
weiss states a criterion c1is at least as powerful as c2 written asc1 c2 if for any program pand specification s if all test sets satisfyingc2exposes an error in pthen so do all test sets satisfying c1.
note here that the definition requires alltest sets satisfying the criterion reveal the fault an unlikely occurrence in practice.
weiss s discussion completely omits the notion of an oracle we assume a constant complete oracle ois used.
we restate the definition of the power of a test coverage criterion using our framework.
a criterion c1is at least as powerful as a criterionc2with respect to a complete oracle o writtenc1 oc2 if p p s s t c1 t2 c2 t2 t2 o p t2 t1 t1 o p t1 in other words if all test sets satisfying c2are guaranteed to find a fault forpwhen using oracle o then so are all test sets satisfying c1.
this formulation makes the role of the oracle explicit the relative power of a test coverage criterion is defined with respect to a constant oracle.
it is easy to show that the oracle is relevant in the power relation.
consider the statement st and branch br coverage criteria.
as subsumption between criteria implies power we know that br st. generally speaking this is a vacuous relationship as neither coverage is guaranteed to find faults for most programs p. nevertheless assume there exists a program pwhich has some faultfrevealed by every test set satisfying statement coverage and thus every test set satisfying branch coverage but does not always propagate to the output e.g.
an incorrect constant is used .
letooutbe an input expected value oracle considering only the outputs and let oallbe an input expected value oracle consider 396ing both the outputs and the internal variables.
if a test set tbr satisfying branch coverage is paired with oout and a test set tst satisfying statement coverage is paired with oall thentst oallis guaranteed to detect f buttbr ooutis not.
thus the power relation for test coverage criteria requires the same oracle to be used with both coverage criteria.
.
.
probabilistic comparison the power relation between test coverage criteria is known to be vacuous for most criteria and is thus of limited value .
we extend the weyuker et al.
pbrelation to consider oracles explicitly using the same notation and terminology used for power above.
var temp int var out int forever out temp temp input figure probbetter example program to demonstrate the effect of oracles on pb consider the following example.
let pbe the program in figure and let the specificationsstate that outat iterationishould be equal to the input at iterationi or ifi .
assume the number of possible inputs is bounded at with a range of to .
let tl1alland tl2sinbe coverage criteria such that for a test set ts tl1allis satisfied iftscontains every test of length and no other tests andtl2sinis satisfied if tscontains exactly one test of length .
we define length as the number of loop iterations.
let oout be an oracle with oracle data out and letoallbe an oracle with oracle data outandtemp.
both oracles are input expected value oracles signaling a fault when the value of a variable is incorrect.
out is considered incorrect when sis violated and temp is considered incorrect when the value is not equal to the prior input.
pcontains a fault as line should not double the input.
consequently the value of outat iterationiis only equal to the input at iterationi 1if the input at iteration i 1was .
we make two observations about detecting this fault.
first to detect the fault we must use an input other than as psatisfiessfor .
second the fault requires at least least two inputs to reach the output and thus outwill be correct for all tests of length one.
consequently no test set satisfying tl1allwill detect the fault using oracle oout while all test sets satisfying tl1allwill detect the fault using oall.
furthermore most test sets satisfying tl2sinwill detect the fault using either oracle when using oout only tests in which the first input is will fail to detect the fault while when using oallonly the test in which both inputs are will fail to detect the fault.
letprob c o be the probability of detecting a fault when using oracleoand a randomly selected test set satisfying criteria c. we can state prob tl1all oout .
prob tl1all oall .
prob tl2sin oout .
prob tl2sin oall .
thus for program pand specification s tl2sinpboouttl1all tl1allpboalltl2sin5.
.
implications these results highlight the relationship between oracles tests and programs on the efficacy of the testing process.
the relationship between oracles and tests can easily be seen from these results.
both the power andpbrelation were defined to compare the efficacy of the test coverage criteria with respect to a program and specification in the case of pb .
however it is clear that oracles cannot be ignored when discussing test selection to do so may yield misleading or incorrect conclusions.
while less obvious these results also highlight the relationship between oracles and programs.
the construction of the program in figure is such that the error on line produces incorrect internal state for of the inputs but cannot affect the output unless a test length of at least is used.
if instead the error had occurred on line i.e.
outwas doubled and temp was not the program would be semantically equivalent in terms of input output behavior but pbwould be unaffected by the oracle used.
that such a subtle change can completely negate the benefit of using a more powerful oracle indicates that as with test selection and oracles we cannot ignore program characteristics when discussing oracle selection.
we further explore the relationship between programs and test oracles later in this section.
.
mutation testing mutation testing is a test selection method based on selecting a set of tests to detect small usually syntactic changes in the program .
briefly to select a set of tests satisfying mutation coverage for a program p we first produce a set of mutants mthat differ frompin small ways e.g.
change arithmetic operators swap variable names etc.
.
we then select a set of tests tsuch that each semantically different mutant m mis distinguished from p. several types of mutation testing have been proposed.
in strong mutation testing we must find a set of tests tsuch that m m t t p t negationslash m t i.e.
the output of each faulty programmdiffers from p s output for some test t. in weak mutation testing we need only find a set of tests tsuch that for each m m the internal state of the pandmdiffers for some test t. in woodward and haywood note that mutation testing exists on a spectrum with strong and weak mutation on opposite ends of the spectrum.
this spectrum of approaches is primarily differentiated by the method used to determine if a mutant has been detected.
recall that in section .
we defined a complete adequacy criterion to be an adequacy criterion defined in terms of both the test set and the oracle used.
if we view the method used to distinguish the mutantsmfrom the program pas an oracle we can reformulate the spectrum of mutation testing approaches as a single complete adequacy criterion.
for the set of mutants m mutation adequacy mut mis satisfied for program p specification s test setts and oracleoif mut m p s ts o m m t ts o t m in other words for each mutant m m there exists a test tsuch that the oracle osignals a fault.
this formulation of mutation testing differs slightly from the usual approaches to mutation testing as the oracle is part of the actual testing process whereas generally the method used to distinguishmfrompis only used to select tests.
nevertheless this formulation captures the core of mutation testing constructing a testing process that is guaranteed to detect a set of pre specified faults without focusing on how the faults are detected.
a very strong oracle can be used with a small number of simple tests conversely a weak output only oracle can be used with a tests that397ensure the mutant faults propagate to the output.
the relationship between the program being tested the tests selected and the oracle used is clear in this formulation of mutation testing.
from the program p a set of mutants mare generated.
using the set of mutants an oracle oand a set of tests tsare selected such that each mutant is detected.
if we change one testing factor the other factors must also change accordingly to satisfy the criterion a different program yields different mutants thus requiring different tests and or a different oracle a weaker oracle may require more or different tests simpler tests may require a more powerful oracle.
we believe the close relationship between factors in mutation testing to be worth considering mutation testing is based on detecting faults and detecting faults is the goal of any testing process.
insights related to mutation testing seem likely to hold in many testing processes.
.
testability the testability of a software system as defined by voas et al.
is the probability that the system will fail if faulty .
generally methods of computing software testability estimate the probability of a fault in a specific program location e.g.
a statement propagating to the output usually with respect to an input distribution or specific input.
by computing the testability of each program location it is argued we can focus testing resources on program locations that have low probabilities of propagating errors.
as a representative technique we explore only work led by voas related to the pie propagation infection and execution method .
voas et al.
define several testability metrics .
consider the propagation estimate metric denoted l a. the propagation estimate is the estimated probability that a perturbed value of aat locationlwill affect the output.
in practice measuring testability is about estimating failure probabilities and l ais therefore used to estimate the probability that a if incorrect will cause the program to fail.
consequently l aonly makes sense if we assume the presence of an oracle defined in terms of the outputs.
if we instead consider that the oracle may not be defined in terms of the outputs the propagation estimate above becomes less informative we are not interested in the probability of a fault propagating to anyoutput we are interested in the probability of a fault being detectable by the oracle used.
to account for the oracle we redefine propagation estimate with respect to an oracle o denoting it l a o. this redefined propagation estimate is the estimated probability that a perturbed value of a at locationlwill affect a variable in the oracle data of o. this metric thus estimates the probability that a fault at awill be detectable by oracleo.
we can show that given an arbitrary o o l a o is not necessarily equal to l a. suppose we have a program p a set of testst and three oracles ooandovandoa.
letoobe an oracle with oracle data containing every output and no other variables i.e.
the oracle assumed by l a letovbe an oracle considering the single internal variable v and letoabe an oracle considering the single variablea.
let .
l a o o .0and letabe some variable defined after the last assignment of v thusacannot propagate to v .
therefore .
l a o o .
l a o v .
l a o a .
l a o a l a o o l a o v l a o a l a l a o v we can see that in order to accurately use testability information toguide software testing we must account for the oracle used.
if we do not we may select tests likely to propagate errors to variables in which we are not interested or we may direct resources to increase testing of parts of the program unlikely to propagate errors to the output ignoring the fact that these parts of the program may already be covered by the oracle data.
.
.
effect on oracle selection software testability is often proposed as a method of directing test selection by determining which parts of the program are and are not likely to hide faults we can select tests proportionally.
however software testability can also be used to guide oracle selection.
consider the previous example assume the variable ais unlikely to propagate to the output.
if we wish to improve fault finding we can select tests aimed at improving the probability of apropagating to the output orwe can use a stronger oracle with oracle data containing a variable to which an error in ais likely to propagate.
this leads to the observation that variables with low propagation estimates represent opportunities for increasing the oracle power .
it then naturally follows that if all variables in the program have high propagation estimates increasing the oracle data is unlikely to significantly improve the oracle power .
note here that the former observation has been alluded to by voas and miller who proposed using testability to guide the creation of assertions .
.
.
implications like mutation testing testability metrics highlight the close interrelationship between programs test sets and oracles.
certain faults may be difficult to uncover in a program pthrough testing.
by computing the testability of p we can determine where these faults are likely to hide and then direct testing resources both in terms of tests and oracles to finding them.
voas suggests adding tests to better exercise parts of the code likely to hide faults thus using testability information to improve the testing process.
as noted above and by voas we can also use testability information to select better oracles.
clearly both may be unnecessary if we use testability information to select a better oracle and thus increase the testability we may no longer need additional tests.
similarly given a large number of tests compensating for a low propagation estimate selecting a better oracle may provide little improvement.
.
additional related work we have discussed several related works throughout this paper.
in this section we discuss additional related works with a focus on work in the theory of testing.
to the best of our knowledge our work is the only foundational work focused on how test oracles influence the testing process though weyuker has an interesting discussion on practical difficulties encountered in testing practice .
goodenough and gerhart s seminal work outlines a theory of testing based on test data selection .
weyuker et al.
budd and angluin and gourlay subsequently highlight problems in this theory nevertheless goodenough and gerhart s ideal of a testing criterion capable of finding all faults in a program captures the general goal of test selection and subsequent theories of program testing generally focus on methods of test selection.
gourlay presents a mathematical framework for testing and uses it to re interpret previous work by goodenough and gerhart howden gellar and weyuker .
there exists a large body of formal and semi formal work on the specific problem of test selection criteria.
weyuker et al.
proposes a set of axioms for test data adequacy criteria that charac 398terize good test data adequacy criteria .
this idea is further discussed by zhu and hall by parrish and zweben and by weyuker again .
formal analysis of methods of comparing test selection criteria has been performed by many authors including weyuker weiss and hamlet and by frankl and weyuker specifically for partition testing methods .
hierons illustrates how the presence of test hypotheses and fault domains influence comparison of test selection criteria .
several theories of program testing based on test selection exist.
morell introduces a theory of fault based testing in which the goal of testing is to show the absence of a certain set of faults .
hamlet presents an outline of a theory of software dependability arguing that the foundations of software testing should be statistical in nature .
zhu and he propose a theory of behavior observation for testing concurrent software systems .
bernot gaudel and other authors have developed a theory of testing based on formal specifications .
in this work they define a testing context as a triple h t o wherehis a set of testing hypotheses i.e.
assumptions about the program and specification tis a set of tests and ois a test oracle.
this work uses algebraic specifications as the basis of testing tests are created based on the axioms of the algebra that define the program interface.
gaudel notes that it is not sufficient to provide a statement of correctness specification and program as it is often the case that certain parts of the program necessary to ascertain correctness are not observable e.g.
opaque type equality and internal component state .
the oracle defines the often imperfect mapping between the specification of correctness and what it is possible to observe about the outcome of a test.
the authors also discuss the relationship between testing hypotheses and test selection criteria and the need for test oracles.
note that this body of work is in terms of algebraic sorts and is not applicable to most real world testing situations furthermore the formalization is quite terse.
.
concluding remarks in this paper we have aimed to provide a foundation for software testing research in particular empirical testing research that is better suited for the task than previous attempts.
in particular we include the notion of test oracles in the framework and point out the crucial interrelationship between tests programs and oracles.
to accomplish our goals we extended gourlay s well known framework to account for oracles allowing us to discuss the problem of oracle selection and explore oracle properties.
we then continued to reexamine previous work in testing demonstrating the effect of explicitly considering oracles.
it is worth reiterating that our goal is not yet another formalization of software testing our goal is to provide solid foundation for the future empirical exploration of software testing.
given our results we make two recommendations related to future testing research directions.
first in both theoretical and empirical testing research we must acknowledge all factors influencing the efficacy of a testing approach we must state and defend our all relevant assumptions .
we are often interested in exploring only one or two aspects of the testing process.
nevertheless we must be aware that our results are influenced by other factors for example the choice of oracle.
in some cases simply making our assumptions explicit is sufficient.
this was the case in the definition of the probbetter relation for test coverage criteria for example the results were sound but only with respect to a specific oracle.
in other cases we must argue that our assumptions are reasonable.
this is particularly important in empirical testing research since it is labor intensive and time consuming and thus is generally only capable of thoroughly exploring one factor at the time holding other factors constant.
authors must explicitly chose constant factors argue why they were chosen and discuss the level of generalizablity resulting from these choices.
for example in chen et al.
explore the effect of fault exposure estimates on the efficacy of the testing process.
this is a exceptionally well conducted study nevertheless the results are dependent on the tests used category partitioning with manually generated tests the oracle used presumably output only and the characteristics of the programs studied the popular siemens programs .
by placing a greater emphasis on these factors the ability of other researchers to interpret and apply the results could be greatly improved ignoring or leaving assumptions unstated or implicit makes interpreting and comparing empirical studies impossible and hinders progress in the field.
this leads to our next recommendation greater emphasis should be placed how combinations of factors influence the testing process.
some work in this area discussed previously has been done.
nevertheless we strongly believe that more work exploring how combinations of factors related to the program under test the tests themselves and the oracle used influence the testing process is necessary to better understand and make improvements in the efficacy of the testing process.
for example questions such as how to mate a coverage criterion with a suitable oracle and what coverage criterion suits a particular program structure have not yet been systematically addressed.
.