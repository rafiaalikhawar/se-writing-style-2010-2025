an automated approach for finding variable constant pairing bugs julia lawall diku university of copenhagen inria regal julia diku.dkdavid lo school of information systems singapore management university davidlo smu.edu.sg abstract named constants are used heavily in operating systems code both as internal ags and in interactions with devices.
decision making within an operating system thus critically depends on the correct usage of these values.
nevertheless compilers for the languages typically used in implementing operating systems provide little support for checking the usage of named constants.
this a ects correctness when a constant is used in a context where its value is meaningless and software maintenance when a constant has the right value for its usage context but the wrong name.
we propose a hybrid program analysis and data mining based approach to identify the uses of named constants and to identify anomalies in these uses.
we have applied our approach to a recent version of the linux kernel and have found a number of bugs a ecting both correctness and software maintenance.
many of these bugs have been validated by the linux developers.
categories and subject descriptors d. .
software engineering software program veri cation statistical methods general terms algorithms design experimentation keywords variable constant pairing bugs anomaly detection clustering linux .
introduction integer constants are heavily used in operating systems code in interpreting values read from devices in constructing values to be written to devices and in representing ags.
some constants are represented explicitly as so called magic numbers .
these are well known to be extremely error prone because their form is essentially meaningless in writing the code it is easy to mistype some digit and in reading the code it is impossible to tell what concept is intended to be represented.
operating systems code thus often de nes named constants either using define or an enumeration type declaration.
in this way a constant is associated with a name that suggests its value and the programmer can permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.
.mboxes mcp out mb ... if mboxes bit 0 ... mboxes mcp in mb ... if mboxes bit 0 .
endpoint bendpointaddress usb type mask usb dir out .tp tg3 flags2 tg3 flag 10 100 only figure bugs in constant usage in linux .
.
in drivers scsi qla2xxx qla mbx.c drivers net wireless zd1211rw zd usb.c and drivers net tg3.c respectively use the constant without being aware of this value.
spelling mistakes are likely to result in a reference to a non existent identi er and the bug will be caught by the compiler.
nevertheless the use of define and enumeration type constants is not su cient to prevent all errors.
indeed compilers provide little or no assistance in ensuring that a given constant is used in the right context.
define constants are seen by the compiler as the integer value that they expand into and in the case of c values declared in an enumeration type have type int .
figure illustrates the three kinds of errors that can occur.
in the rst example the constant bit 0 has the right value but the wrong name name bug .
the out mb andin mb elds should be combined with mbx 0 which has the same value as done elsewhere in the le.
in the second example the value of usb type mask has the wrong value for the context in which it occurs value bug .
the result of the bit and operation is compared to usb dir out which only has bits in positions where usb type mask has bits and thus the result of the comparison is always false.
finally in the third example the right constant is used in the wrong context context bug .
the tg3 flag 10 100 only constant should be used with the tg3 flags eld rather than the tg3 flags2 eld.
of these a name bug does not a ect the behavior of the program but can harm its readability and future maintenance.
a value or context bug produces incorrect behavior for example a condition reported by a device may never be detected or a device may be provided with an inappropriate value.
some of these bugs may be detected quickly e.g.
if a device exhibits unexpected behavior.
others may linger due to the di culty of nding such bugs by manual inspection and the lack of appropriate tools.
essentially the problem of ensuring that the right constant is used in the right context is a type checking problem.
indeed a group of constants that may be used in a particular kind of context may be considered to form a type.
nevertheless the problem of inferring these types is more di cult than the problem of ordinary type inference because there are no kinds of terms on whose types we can rely.
thus we must rst identify what the types are and then check that they are respected by the code that uses these values.
this problem is further complicated by issues of dependent types where the type expected in one function argument or structure eld depends on the value contained in another one of subtypes where one module may de ne supplementary constants that are intended to be used in a context that expects constants of another existing type and of bugs implying that any given use of a constant cannot be assumed to be a correct use and thus cannot in itself imply a type de nition.
in this paper we propose to address the issue of type inference for named constants using a combination of program analysis and data mining.
in our approach program analysis is used to collect information about the use of constants and data mining is used to lter out probable anomalous uses to be able to classify the constants into types.
we have applied our approach to the linux .
.
kernel 1focusing on constants that are used in bit and and bit or operations representing the processes of extracting information from existing values and of constructing new values.
in linux .
.
we have found probable bugs of which have been con rmed by linux developers.2this number of bugs is not large but the ability to nd these bugs is unique to our approach existing bug nding approaches typically focus on sets or sequences of function calls and thus are not able to nd bugs in the use of constants.
concretely the contributions of this paper are as follows we identify the pattern of named constant usage in linux code providing a basis for bug nding.
we de ne a program analysis that provides insight into the ow of named constants through linux code.
we de ne a data mining strategy based on clustering that groups named constants into types.
this approach to clustering is novel in that it has no a priori knowledge of the number of clusters but is e cient enough to be used with large and varied data sets.
we provide a detailed evaluation of our approach on the complete linux .
.
source code.
we classify some forms of named constant usage that are problematic for our approach thus providing a basis for future work.
the rest of this paper is organized as follows.
section presents the program analysis used to collect information about constant usage.
section presents some aspects of the implementation of this analysis that are needed to address speci c issues occurring in linux code.
section presents the data mining techniques used rst to group the constants into clusters representing types and then to identify probable bugs in constant usage.
then section evaluates our results on linux .
.
section presents related work and section concludes.
1this is a recent version but one that was released before we had submitted any patches based on our work.
2the reactivity of the linux maintainers varies and thus we have sometimes received no response to our enquiry.
.
analysis overview constants are used within the linux kernel to represent internal ags indicating various conditions and to interact with external devices which communicate using bit sequences of various sizes.
for e ciency bits having di erent purposes are often packed into a single unit of addressable memory byte word etc.
.
accessing information from such bit sequences is carried out using the bit and operator as previously illustrated in figure and bit sequences are constructed using the bit or operator .
in this paper we focus on these operations.
constants are also involved in equality tests and shift operations.
we leave the extension of our approach to these operators as future work.
constants are typically rst used to extract components using the bit and operator from some values that we designate assources then are transmitted through the code structure by the use of various assignments and are nally used to construct new values with the bit or operator to be passed to locations we designate as sinks .
the goal of our analysis is to associate constants to the sources and sinks with which they interact.
sources and sinks can in principle be any sort of expression but to simplify the presentation we assume that they are specially designated variables.
in the next section we will instantiate sources and sinks as structure elds.
the analysis is intraprocedural and ow insensitive.
it does not take aliases into account.
in our implementation we provide ow sensitivity for local variables via prior conversion to static single assignment ssa form and a weak form of alias analysis via types as described in the next section.
.
syntax we present the analysis in terms of the simple imperative language de ned in figure .
the actual implementation however handles full c code as described in the next section.
in the language of figure a program consists of an unordered set of assignments of variables to expressions where the lack of ordering re ects the ow insensitivity of the analysis.
an expression is either a variable a constant a bit and operation or a bit or operation.
some variables are designated as sources orsinks .
c2constants source2sources variables v2variables sink2sinks variables prog2programs p statements stmt2statements v expr expr2expressions cjvjexpr exprjexpr expr figure syntax .
analysis the analysis collects an environment containing information about the bindings of variables to propagate this information between the various statements and at the same time uses the information in the environment to generate anoutput describing the interaction between constants and either sources or sinks.
for example if we consider the case where sources and sinks are structure elds then for the rst line of case of figure the environment would contain a mapping of mboxes tomcp out mb and the output would indicate that mcp out mb interacts with bit 0 .
the analysis iteratively accumulates the environment and output until reaching a xed point.
104the semantic domains used by the analysis are shown in figure .
these are representations summaries environments and output .
a representation ris a pair of a set of variables and a set of constants.
these are the variables and constants that contribute in a particular way to the value of an expression.
a summary sprovides the complete information collected about the computation performed by an expression as a tuple of three representations one indicating the set of variables and constants to whose value the expression may evaluate another indicating the variables and constants involved in any bit and operation that is used to compute the value of the expression and a third providing the same information for bit or operations.
for example in case of figure the summary corresponding to mboxes bit 0 would behh i hfmboxes mcp out mbg fbit 0gi h ii.
an environment maps variables to summaries.
a binding in this environment is written as v s and records the e ect of assignment statements.
finally an output is a pair of relations from sources and sinks respectively to constants.
the constants in an output are annotated with the position o set from the start of the program of the interaction between the source or sink and the constant and thus an output provides information about both the kind and number of such interactions.
r2representations p variables p constants s2summaries representations representations representations 2environments variables!values 2output p sources positions constants p sinks positions constants figure semantic domains used by the analysis representations are ordered as follows where viis a set of variables and ciis a set of constants hv1 c1ivhv2 c2i v1 v2 c1 c2 ?abbreviates the representation h i. summaries are ordered such that a pair of summaries is related if all of their components are related.
environments are ordered similarly.
in each case the least upper bound operation tis de ned by computing the union of corresponding sets of variables and constants.
finally output is ordered by the subset relation.
each of these orderings forms a complete lattice.
the rules for expressions are de ned in figure .
these rules infer judgements of the form expr s wheresis a summary containing information about the variables and constants that are used to compute the value of the expression and represents the output.
in each rule only information about the outermost kind of operator bit and or bit or is collected.
this strategy is based on the observation that e.g.
in a b c we do not know what named constant if any the parenthesized subexpression represents.
it is for this reason that summaries contain separate components for and information.
among the rules for expressions only the rule for bit and expressions generates output.
our understanding of bit and is that it is used to extract information from sources.
in this case if a source is used in computing one of the bit and arguments and a constant is used in computing the other then the expression represents an interaction between them.
the construction of the output in this case uses the function source r which returns the variables in the representation r v v thhfvg i ?
?i c hh fcgi ?
?i expr1 hr r rj1i expr2 hr r rj2i expr1 expr2 h?
r 1tr 1tr 2tr ?i fv7!cjv2source r 1tr c2cst r 2tr g fv7!cjv2source r 2tr c2cst r 1tr g expr1 hr rj1 rj1i expr2 hr rj2 rj2i expr1 expr2 h?
?
r 1trj1tr 2trj2i figure analysis rules for expressions that are sources and the function cst r which returns the constants in the representation r. no output is generated for a variable or constant expression because these do not involve any interactions.
no output is generated for a bit or expression because it expresses only the construction of a value but not the communication of the constructed value to a sink.
our implementation also collects information about the use of and !
.
these operators add information to the rst component of a summary analogous to the rules for variables and constants.
the rules for statements are de ned in figure .
these rules infer judgements of the form stmt where 0contains information about the assigned variable and represents the output.
if the left hand side variable is not a sink the only e ect is to extend the environment with a binding of the variable to the value obtained by analyzing the expression.
if the variable is a sink then output is also generated.
this output maps the sink to each possible constant in the bit or information contained in the summary resulting from analyzing the right hand side expression expr.
v62sinks expr s v expr tf v s g v2sinks expr hr r rji v expr tf v hr r rji g fv7!cjc2cst rj g figure analysis rules for statements the rule for programs iterates the rules for statements over the set of statements in the program until the resulting environment and output reach a xed point.
this iteration terminates because environments and outputs form a complete lattice and because each iteration only monotonically adds information to each of these entities.
the nal result is the output at the end of this iteration.
.
example to illustrate the analysis we consider the program shown below where source is a source sink is a sink x y and z are neither sources nor sinks and a b c dare constants.
.
x source a .
z y c .
y x b .
sink z d to emphasize the ow insensitive nature of the analysis we rst analyze all of the expressions based on the initial environment then analyze the enclosing statements and then iterate.
the analysis steps are shown in table .
each row in the table corresponds to one of the above statements.
within each row the top line is the resulting value or environment as appropriate and the bottom line is the added output positions are elided .
a column labelled exp contains the 105exp stmt exp stmt .x source a a1 h?
hfsourceg fagi ?if x a1 ga1 a1 f x a1 g source7!a none none none .y x b a2 h?
hfxg fbgi ?if y a2 ga2 h?
hfsource xg fa bgi ?if y a2 g none none source7!b none .z y c a3 h?
?
hfyg fcgiif z a3 ga3 a3 f z a3 g none none none none .sink z d a4 h?
?
hfzg fdgiif sink a4 ga4 h?
?
hfy zg fc dgif sink a4 g none sink7!d none sink7!c table analysis trace result of processing the right hand side of an assignment according to the environment that is the least upper bound of the environments generated by the previous column if any.
a column labelled stmt contains the result of processing the complete assignment according to the same environment.
the analysis reaches a xed point after the two iterations shown in table .
the result is then the accumulated output source7!aresulting from source a source7!b resulting from x b and sink7!cand sink7!dresulting from sink z d .
.
implementation of the analysis to successfully treat linux code the analysis must parse the source code identify named constants and select a notion of source and sink.
in practice we have also found it necessary to implement ow sensitivity for local variables.
parsing.
tools that process c code typically rst apply the c preprocessor to eliminate all preprocessor directives.
this is however not appropriate in our case as it eliminates the names of constants that are de ned using define .
furthermore to collect a maximum of information about constant usage we would like the analysis to consider as much of the source code as possible including portions of code that are speci c to the more obscure hardware con gurations.
to address these issues we use the c parser of the coccinelle program matching and transformation tool which parses c code without expanding macro de nitions.
this parser can parse around of the linux .
.
kernel.
identification of named constants.
linux constants typically have names that are constructed entirely of capital letters.
nevertheless this strategy is not always followed.
furthermore some constants may be de ned in multiple les potentially with a di erent meaning in each case.
to be able to identify constants accurately the analysis initially collects for each le a list of the constants that they de ne and the position in the le of that de nition.
subsequently in processing each .c le the analysis phase recursively unwinds all of the include directives collecting for each included le the set of named constants that it de nes.
finally the constants de ned by the .c le are added to this set.
this process does not take into account ifdef directives and thus information about all de ned constants is available.
a constant may be de ned multiple times under di erent ifdef s potentially leading to ambiguity.
we assume that the multiple de nitions may change the value of the constant but not its purpose this assumption has not lead to any problems in practice.selection of sources and sinks.
we have chosen to use structure elds as our notion of both sources and sinks.
linux structures are heavily used to communicate complex information between di erent parts of the kernel and thus their elds tend to have a xed semantics.
indeed we have found that a given eld of a given structure type is often always used in the same way regardless of the structure instance with which it is associated.3thus we choose to represent a structure eld as a pair of the type of the structure and the name of the eld thus unifying the information collected for all occurrences of a given structure eld.
this indeed provides a weak form of alias analysis as long as structures are used in a well typed way.
this choice of the representation of structure elds raises the need to determine the type of each referenced structure.
when the structure is referenced as a variable its type can be obtained from the variable declaration without knowing the structure de nition.
when the structure is expressed as a more complex expression typically another structure eld reference the de nition of the type of the containing structure is required to determine the type of the structure itself.
for this the pass that identi es constants also collects typedefs and structure declarations.
this information is then used to infer the types of structure elds.
implementation of flow sensitivity.
flow insensitive analysis is less expensive than ow sensitive analysis and is typically su cient when the tracked locations are mostly used in a uniform way.
we have argued that this is often the case for structure elds.
nevertheless we have found that it may not be the case for local variables in linux code.
indeed it is common to declare an integer typed local variable with a generic name such as data and use it in for multiple purposes within a single often large and complex function.
figure illustrates a typical case.4the code is essentially divided into two regions with the rst extending from line to line and the second extending from line to line .
in the rst part the variable flag interacts with constants of the form tdes1 while in the second part the variable flag interacts instead with constants of the form tdes0 .
in each case the value of flag is ultimately stored in the same structure but in elds having di erent purposes.
in our data mining based approach it important to keep the various uses of the variable separated from each other.
otherwise the two sets of constants could be merged which would lead 3we will however revisit this assumption in section .
.
4in this code the structure eld initializations involve the macro cpu to le32 .
this function and others like it a ect only the bit order and are considered by our implementation to be the identity function.
106to overlooking a bug in the case of an interaction between them.
and if the sets of constants are not merged but the variables remain identical then one of the initializations of a eld of the priv structure line or line would be reported as a bug amounting to a false positive.
if priv curtx priv dirty tx priv txring size ag tdes1 control icjtdes1 control lsj tdes1 control fs else ag tdes1 control lsjtdes1 control fs .
.
.
if entry priv txring size agj tdes1 control ter priv txring .length cputole32 agjskb len ag tdes0 control ownj plcp signal j8 priv txring .status cputole32 ag drivers net wireless adm8211.c figure illustration of the need for ow sensitivity in di erent regions of code to address this problem we adopt a standard approach to providing ow sensitivity conversion of the source program to static single assignment ssa form .
in this form local variables are renamed such that every local variable is de ned at only one position in the source code.
so called functions are inserted at merge points such as the end of a conditional to collect the variables that can contribute to the value of each variable that is live after the merge point.
this has the e ect of renaming local variables but has no impact on the set of structure elds and thus no impact on the set of sources and sinks considered by the analysis.
in the result of the conversion to ssa form the tdes1 and tdes0 constants are accumulated in di erent variables and are transmitted separately to the di erent elds of the priv structure by the analysis.
.
mining algorithm the goal of our mining algorithm is to discover anomalous variable constant pairings automatically.
it works in three steps as shown in figure .
the rst step constructs a graph to represent the relationships between variables and the constants they are paired with by the analysis.
the second step then uses this graph to cluster related constants together.
finally based on these clusters the third step detects anomalous variable constant pairings.
construct constant variable bi partite graphs step create constant clusters step detect anomalous variable constant pairings step figure high level steps step .
graph construction.
our goal is to construct a bi partite graph capturing the relationships between constants and variables.
one side of the graph contains all the constants and the other side of the graph contains all the variables.5one side of the graph contains all the constants 5in this section we use variable to refer to sources and sinks i.e.
structure elds in our case.
c1 constants variables c2 cn v1 v2 vn ... ... n1 n3n2 n4 n5figure constant variable bi partite graph and the other side of the graph contains all the variables.
there is an edge from a constant to a variable if the variable is used together with the constant.
the label on the edge shows the number of times a constant is used with the variable.in the graph we merge any variables v1andv2 if the set of constants c1associated with v1is a subset of the set of constants c2associated with v2.
an example graph is shown in figure .
step .
create constant clusters.
this step groups constants based on their behavior usage pro le i.e.
the number of times they are paired with various variables.
our goal is to create clusters where all the constants in the cluster are used with a similar set of variables.
each cluster of constants can be viewed as a weak type i.e.
they are used in the same way.
distance metrics.
to create a constant cluster we rst de ne a measure of distance between two constants.
each constant is associated with a corresponding behavior usage pro le which is a vector containing an entry for each variable.
an entry in this vector contains the number of times the constant is paired with the corresponding variable multiplied by a weight denoting the importance of that particular variable.
this weight is determined by considering how many constants that variable is paired with in the dataset weight v jconstants paired with v j this strategy is based on the concept of inverse document frequency or idf commonly used in information retrieval .
based on this vector metrics from information retrieval can be used.
of these metrics we choose cosine similarity .
cosine similarity performs normalization with respect to the size of the vector and is thus less sensitive to this size.
since the vectors tend to be sparse i.e.
a constant is normally used with only a few variables cosine similarity is more accurate than other similarity metrics including euclidean and jaccard similarity .
cosine similarity is de ned as follows cos v1 v2 v1 v2 jv1jjv2j the numerator is the dot product of the two vectors and the denominator is the product of the magnitude of the rst vector i.e.
the square root of the dot product of the vector with itself with that of the second vector.
we then de ne distance as follows dist v1 v2 cos v1 v2 107consider for example two constants c1andc2.c1is used with variables v1andv2whilec2is used with variable v2.
the vectors corresponding to c1andc2are and respectively.
the cosine similarity of the two vectors are p p .
.
the distance is equal to .
.
.
as a cluster is a collection of constants we can aggregate the constants behavioral usage pro le to form the pro le of a cluster.
the pro le of a cluster is a vector where each entry is the sum of the values of the corresponding vector entries of all constants belonging to that cluster.
the distance between a cluster and a constant or a cluster and another cluster is then computed in a similar way as the distance between a constant and another constant.
clustering.
many existing clustering algorithms require specifying the number of clusters which is not known in our case.
we propose a new heuristic based clustering algorithm that works without the need to know the target number of clusters in advance .create an initial set of clusters.
this step greedily scans each constant and assigns it to the best cluster created so far whose distance is close enough based on a user de ned threshold .
if no cluster is found a new cluster is created.
.iteratively re ne the set of clusters.
after a temporary cluster is formed we try to re locate each data point to the cluster whose distance is closest.
at each iteration constants are moved to their respective nearest cluster.
after this reshu ing the pro le of each cluster is recomputed.
we repeat this process until a xed point is reached and no constants can move to another cluster.
in our experiments a xed point is reached in iterations.
.merge clusters that are very close based on the user de ned threshold .
the algorithm is described in more detail in figure .
we use .
as the value of .
we determined the thresholds empirically based on a number of good clusters that we knew in advance.
the threshold of .
keeps many of these good clusters.
we compare our algorithm to some existing clustering algorithms in section .
step .
anomaly detection.
in the third step we detect anomalies by looking for variables that are shared by more than one cluster.
on nding an anomaly a bug report consisting of a variable v a constant c and a cluster l denoted ashv c li is generated.
we rank our bug reports based on their suspiciousness.
it is our intuition that suspiciousness of a variable vbeing paired to a constant cin a cluster l is related to the following size of the cluster l.the size of a cluster is the number of constants that it contains.
we denote the size as size l .
it is our intuition that the more elements a cluster lhas the more likely a programmer is to make a mistake in using the constant in l. strength of the association between the variable v and the cluster lcontaining c.let us de ne freq v c to be the number of times a variable vis paired to a constant c. we de ne the strength of this association as follows procedure clusterconstants inputs constants set of constants to be clustered initial clustering threshold cluster merge threshold output clusters of constants method step i create an initial set of clusters let clusters fg for each constant v in constants for each cluster c in clusters if dist v c v is closest to c add v to c and break if v is not added to any c create a new cluster c containing v add c to clusters step ii cluster re nement do for each cluster c in clusters for each constant v in c if9c 2clusters dist v c dist v c reshu e v to c recompute statistics per cluster in cluster while a constant is reshu ed step iii cluster merge for each cluster c in clusters if9c 2clusters.
c c dist c c merge c with c output clusters figure constant clustering algorithm strength v c ci2l freq v ci max l0!
l c0 i2l0 freq v c0 i from the above formula vis weakly associated to lif the constants in lare paired to vmuch less than constants in another cluster l0are paired to v. it is our intuition that the weaker the association between a variable vandlthe greater is the likelihood that hv c liis a real bug.
the number of clusters that are related to v.the number of clusters related to vis the number of di erent clusters that constants paired to vbelong to.
we denote this as vdeg v .
it is our intuition that if a variable v is used with constants from many clusters there is no or little restriction in pairing vwith an arbitrary constant.
such avmight be polymorphic as it could be used with various types corresponding to various clusters of constants.
anomalies involving such a vare less likely to be real bugs.
based on the above intuitions we sort the candidate bug reports by the following formula suspiciousness v c l size l log size l strength v c vdeg v the larger the size of the cluster l the more suspicious is the pairing.
the weaker the association between vand c the more suspicious is the pairing.
also the more clusters vis related to the less suspicious is the pairing.
we give a higher weight to the size of the cluster las compared to the association between vand c by multiplying the size of the cluster lwith the log of itself.
again we give a higher weight to the number of clusters that vis related to i.e.
vdeg v than the other two.
to do so we take the 108square of vdeg v .
as all bug reports intrinsically have a vdeg v of at least we subtract vdeg v by one before taking the square.
thus vdeg v does not contribute to the suspiciousness score when it is equal to .
at the end of the three steps we report a candidate set of anomalies to be provided to the user for veri cation.
.
evaluation in this section we rst present our experimental setting followed by the results of applying our algorithm to the linux .
.
source code.
we then consider some threats to the validity of our results and nally describe some uses of constants that were identi ed in analyzing our results but that go beyond the scope of the current work .
experimental setting the analysis process was implemented using ocaml and carried out on a hp proliant server with two ghz quadcore xeon processors and gb memory of which only one core was used.
the mining process was implemented using c .net .
and carried out on an intel core2 duo .40ghz .24gb ram windows xp tablet pc.
the total time for processing linux .
.
was around hours with all but a few minutes for the analysis.
we consider three strategies for the clustering process.
in the pos strategy constants are only clustered by the position of their de nition i.e.
constants that are de ned adjacently no blank line between their de nitions are clustered together.
in the pos beh strategy we rst cluster according to position and then re ne the result using the clustering algorithm taking into account constant usage behavior as presented in section .
finally in the beh strategy we cluster only using behavior as presented in section .
in all cases reports are ranked as described in section .
we consider only the top reports in each list as real bugs were quite sparse after this point in every case.
.
results the set of real and probable bugs obtained by applying our algorithm to the linux .
.
source code and manually analyzing the results is shown in table .
we consider a real bug to be one that has been xed or acknowledged by the linux developers and a probable bug to be one that we believe to be a bug based on our study of the code.
the pos strategy gives the worst results with only a precision among the top results.6next is pos beh with a precision.
finally is beh with a precision.
this suggests that position of de nition is not a completely satisfactory indicator of the meaning of a constant as some constants may be declared contiguously but have a di erent purpose while others may have de nitions that are slightly separated even though this placement might have no intrinsic meaning.
the purely behavior based approach is su cient to reconstruct the position relationships when they are relevant and to identify new relationships that are not made apparent by the positions alone.
finally we observe that many of these bugs have been present for multiple years.7the long 6we use the common measure of precision at k from information retrieval .
recall is hard to measure in this case as the total number of variable constant pairing bugs in the target program is not known.
7linux versions are released roughly every months.lifetimes of these bugs suggests that this type of bug is not being identi ed by other approaches whether automated tools or manual inspection.
the false positive with the highest suspiciousness score i.e.
rank when employing clustering by behavior only is the bug report involving the constant supported pause and the eld supported of a structure of type ethtool cmd .
supported pause is in a rather large cluster and has a low score for strength v c causing our approach to list it as a potential bug.
in this case there are two sets of constants that each have the same set of values.
it sometimes occurs that the value of a variable containing one is copied into a variable containing the other causing the constants to appear to be used with the wrong type of variable.
the constant supported pause is involved in a bit more such copies than most of the other constants with which it should be associated and it is used a bit less often than those constants with the variables associated with its own cluster.
this essentially represents a borderline case and the algorithm unfortunately makes the wrong decision putting this constant and two others with similar properties in the wrong cluster.
.
threats to validity as we verify our detected bugs with the linux developers we may assume that our identi cation of real bugs is accurate.
nevertheless the linux developers can only comment on results that they are asked about and thus there is a danger of false negatives.
in our approach there are three primary sources of false negatives parse errors missing include les and overly conservative manual evaluation of the results.
our approach works primarily at the level of the abstract syntax tree and thus it must be possible to parse the source code.
as noted in section our parser does not apply the c preprocessor and instead parses c preprocessor directives according to heuristics .
these heuristics however are not su cient to parse some functions and thus we are not able to collect information from them or nd bugs in them.
additional heuristics could be added however we currently parse of the linux .
.
code.
our approach also relies on information contained in header les to identify named constants and to obtain type information about nested structures.
the linux build process is complex and thus we search for include les based on a few heuristics.
some include les however are missed causing information about the associated constants and structure de nitions to be overlooked.
to address this problem the parser could use path information found in make les or use a wider default strategy for searching for header les.
finally we have manually analyzed the bug reports generated by our tool to identify those that seem like real bugs.
this analysis may be too conservative causing some real bugs to be considered as false positives.
to address this problem we could consult with linux experts earlier in the report assessment process.
.
other issues in evaluating our results we have identi ed two signi cant issues that are not targeted by the design of our algorithm and that may be bene cial to consider in future work.
these aresubtyping in which a generic constant is associated with multiple clusters that also contain more specialized values and dependent typing in which the value of one constant 109constant name category file name p p b b lifetime status susp tg3 flg2 tso capable context drivers net tg3.c no no yes .
.
.
.
f tg3 flag 10100only context drivers net tg3.c no no yes .
.
.
.
f vbsislvds context drivers video sis init301.c yes yes yes .
.
r ahc scb btt context drivers scsi aic7xxx aic7xxx osm.c yes yes yes .
.
r ext4 extents fl context fs ext4 inode.c yes yes yes .
.
.
.
f usb type mask value drivers net wireless zd1211rw zd usb.c no no yes .
.
.
.
f nvtxvalid name drivers net forcedeth.c no no yes .
.
a ahd busfreerev bug context drivers scsi aic7xxx aic79xx pci.c yes yes yes .
.
a ath9k int global value drivers net wireless ath ath9k mac.c no yes yes .
.
a bit0 name drivers scsi qla2xxx qla mbx.c yes yes yes .
.
r legend context see section name wrong constant name but with the right value value wrong constant name wrong value context wrong context right constant name.
p clustering by de nition position only.
p b clustering rst by de nition position then by behavior.
b clustering by behavior only.
a bug that has not been xed in any release.
status f fixed r reported a acknowledged.
susp suspiciousness score using b. table list of bugs found determines the cluster that should be used in some associated code context.
we observe that the c language provides more strict type checking of enumeration constants than the c language.
nevertheless neither subtyping nor dependent types are supported by enumeration types and thus even in c it may be necessary to use some form of unsafe cast or unchecked named constants.
the examples in this section are not restricted to bit and and bit or or to structure elds as sources and sinks and thus give a wider view of the problem than the one that is treated by our current approach.
subtyping.
some of the constants used by linux kernel code are masks that can be used to select a region of bits that then should be accessed using constants within a given cluster.
several clusters may share the same set of significant bit positions and thus a single mask may be usable for these clusters.
in this case we may view the cluster containing the mask as a supertype of the clusters containing the speci c values.
figure shows an example.
the function tg3 get 5752 nvram info at the top tests for flash values while the function tg3 get 5761 nvram info at the bottom tests for flash values.
other functions in the same le test for a mix of flash and other values suggesting a complex subtyping hierarchy where devices reuse some values and de ne some of their own.
the mask nvram cfg1 5752vendor mask covers all of these values and thus can be used to extract the relevant bits in each case.
another form of subtyping occurs when one le extends an existing cluster with new constants or gives new names to some values in an existing cluster.
the constants advertised pause and advertised asym pause de ned in the chelsio speci c header le drivers net chelsio common.h illustrate the latter case.
these constants have the same values as the constants advertised pause andadvertised asym pause de ned in the more widely used header le include linux ethtool.h .
a bug nding algorithm should allow the former constants to appear wherever the latter do.
dependent typing.
dependent typing involving constants is most commonly found in function calls where the value of one argument determines the cluster of another.
it can however also occur for structure elds or variables.
we also consider cases where the cluster of a structure eld depends on the role that that instance of the structure plays a situation that contradicts the hypotheses of the treatment of structure elds in our algorithm section .switch nvcfg1 nvram cfg1 5752vendor mask f case flash 5752vendor atmel eeprom 64khz case flash 5752vendor atmel eeprom 376khz tp nvram jedecnum jedec atmel tp tg3 agsj tg3 flag nvram buffered break case flash 5752vendor atmel flash buffered .
.
.
g drivers net tg3.c tg3 get5752 nvram info nvcfg1 nvram cfg1 5752vendor mask switch nvcfg1 f case flash 5761vendor atmel adb021d case flash 5761vendor atmel adb041d .
.
.
break case flash 5761vendor stam45pe20 .
.
.
g drivers net tg3.c tg3 get5761 nvram info figure illustration of mask related subtyping figure illustrates dependent typing at the function parameter level.
in this code the function xm write16 is called twice lines and rst with the third and fourth arguments as xm hw cfg and xm hw gmii md respectively and then with these arguments as xm rx cmd and a combination of constants of the form xm rx respectively.
the constants xm hw cfg and xm rx cmd in the third argument are de ned in the same enumerator type declaration and thus can be considered to be likely to belong to the same cluster.
on the other hand xm hw gmii md is de ned in a di erent enumerator type declaration than the xm rx constants.
indeed the value of the third argument determines the cluster of the fourth argument.
this is a pattern that occurs often in low level code that interacts with devices but is out of the scope of the current approach.
dependent typing also occurs although less frequently in the case of structure elds and variables.
an example is shown in figure where the value in the eld rap determines the cluster of the value in the eld rdp.
addressing this issue again goes beyond the current scope of our work.
the basic assumption of our treatment of structures as presented in section is that for a given structure type all instances of a given eld are used in the same way.
some 110if hw phytype !
skphy xmac f .
.
.
xmwrite16 hw port xmhw cfg xmhw gmii md g .
.
.
r xmrxlenerr okjxmrxstrip fcs .
.
.
xmwrite16 hw port xmrxcmd r drivers net skge.c genesis mac init figure function parameter dependent typing lance rap csr0 lance rdp stop ariadne initring dev if dev ags iffpromisc f lance rap csr15 lance rdp prom gelse .
.
.
drivers net ariadne.c set multicast list figure a dependently typed structure eld structures however violate this assumption.
for example the le drivers net fealnx.c uses a structure of type fealnx desc to represent ring bu ers used both in the transmission and reception of network packets.
transmission and reception bu ers however are used in di erent ways and thus a di erent set of constants is used in each case.
thus some elds of a fealnx desc structure can hold constants from di erent clusters depending on the kind of bu er being represented.
most structures in linux are however used only for a single purpose and thus we have found that these kinds of false positives are uncommon.
.
related work a number of works use data mining to infer programming rules from common patterns in source code .
these approaches nd rules such as whenever a set of program elements occurs in a method another set of program elements must also occur in the method and whenever a method call is made another method call must be made in the future .
the work of ramanathan et al.
includes some data ow analysis for identifying constraints on values.
these studies have primarily focused on method calls and in some cases can be generalized to other program elements such as structure elds .
however none have considered the issue of bad constant variable pairings as done in this paper.
cp miner locates copy pasted segments and anomalies when one or a few copied segments are not modi ed like the rest .
it found and copy and pasted segments in linux and freebsd respectively.
from the copyand pasted segments and bugs were found in linux and freebsd respectively.
while some bugs in constant usage may derive from copy paste errors our approach is not limited to that case.
muvi correlates variable and structure eld accesses to nd inconsistent update bugs possibly related to concurrency .
such accesses are explicit in the program and thus they do not require a program analysis to collect information transmitted across local variables as we have needed.
theyalso mine for association rules describing a case where the presence of an object aimplies the presence of another objectb.
our clusters could be expressed as association rules involving disjunction but obtaining such rules is out of the scope of the techniques used by muvi.
many clustering algorithms such as k means k me etc.
takes as input the nal number of clusters which is not available in our setting.
one could set this nal number of clusters to be equal to the number of les or the number of variables paired with a constant but either of these options is likely to produce poor clusters.
indeed we have observed that a le can contain many clusters of constants and we have observed that a constant in a cluster can be paired with multiple variables.
lo and khoo extend k me to be parameterless by incrementally increasing the number of clusters one by one and measuring the degree of cluster goodness .
the technique stops when a local optimum is reached.
this technique is not suitable in our setting as the number of constant clusters is very large i.e.
there are many constant groups in the linux kernel code and they are used for a wide variety of purposes.
qt clustering replaces the number of clusters with the maximum diameter of a cluster .
however it requires miterations where mis the eventual number of clusters and this number is very large in our setting.
x means takes as input a lower bound say l and an upper bound say u of the number of clusters .
it extends k means by initially creating l clusters and incrementally increasing it to uby splitting the intermediate clusters.
the number of clusters resulting in the best degree of cluster goodness is reported.
muhr and granitzer extend x means by a merge operation to undo bad initial splitting of clusters .
as we do not know the precise range of the number of clusters a wide range is potentially needed.
also there are cases where both the original x means algorithm and that of muhr and granitzer need more than u literations.
the original x means algorithm includes some optimizations based on a kd tree data structure which could potentially be applicable to our algorithm as well.
we could also investigate the e ect of plugging our distance metric into the algorithms mentioned above and evaluate the quality of the clusters produced.
sun et al.
propose a data mining technique to nd anomalies in a bi partite graph .
their approach uses random walk with restart.
unlike their approach we detect anomalies using clustering.
while the approach of sun et al.
does not take into account the weights in the links we consider weights assigned to features used during clustering process.
also we merge data mining with program analysis and show the utility of our hybrid technique in detecting real bugs in linux kernel code.
the problem of inferring types for constants is an instance of the more general problem of inferring types from untyped data.
soft typing attempts to detect correctly typed terms in dynamic languages and to insert the fewest possible number of run time type checks at places where types cannot be inferred .
soft typing however can rely on information about constants and operators that have only one possible type or only a few possible types such as constants and arithmetic operations.
no such information is available to our approach.
in a problem closer to our own eidor et al.
use a type based approach to identifying various representations of dates within cobol code to address the year problem .
they rely on annotations that may be provided 111by the user or inferred automatically based on rules de ned in terms of common substrings.
we brie y considered an approach based in part on common substrings for clustering constants but found that it gave very poor results.
unlike the case of dates we have no a priori knowledge of what kinds of strings might be relevant.
finally work has been done on inferring types related to units of measure but this work requires explicit type declarations .
most of the bugs we have found are in device driver code.
it is well known that such code is highly error prone and one of the contributors to this is uncontrolled the use of constants.
the devil language addresses this in part by allowing the developer to declare the bit patterns occurring within constants in a high level way .
clay extends this approach with dependent types .
devil and clay are concerned with the values of constants while our work is concerned with their names.
thus the approaches are orthogonal.
.
conclusion named constants are commonly used in systems code to denote various magic numbers and control options.
because compilers provide little or no type checking support for these entities developers can easily use inappropriate constants with no warning from the compiler.
this can lead to incorrect behavior and makes the code more di cult to understand.
we have proposed a new approach to capture bad variableconstant pairings via a hybrid program analysis and data mining technique.
our results show that our technique is scalable as it can treat the entire linux kernel within around hours.
for linux .
.
we have found real or probable bugs.
we have reported these bugs to the developers and a number of them have been subsequently xed.
in the future we will consider operators other than bit and and bit or more types of sources and sinks and the subtyping and dependent typing e ects presented in section .
.