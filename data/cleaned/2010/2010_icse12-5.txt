verifying client side input validation functions using string analysis muath alkhalaf tevfik bultan jose l. gallegos computer science department university of california santa barbara ca usa fmuath bultan jlgallegos g cs.ucsb.edu abstract client side computation in web applications is becoming increasingly common due to the popularity of powerful client side programming languages such as javascript.
clientside computation is commonly used to improve an application s responsiveness by validating user inputs before they are sent to the server.
in this paper we present an analysis technique for checking if a client side input validation function conforms to a given policy.
in our approach input validation policies are expressed using two regular expressions one specifying the maximum policy the upper bound for the set of inputs that should be allowed and the other specifying the minimum policy the lower bound for the set of inputs that should be allowed .
using our analysis we can identify two types of errors the input validation function accepts an input that is not permitted by the maximum policy or the input validation function rejects an input that is permitted by the minimum policy.
we implemented our analysis using dynamic slicing to automatically extract the input validation functions from web applications and using automata based string analysis to analyze the extracted functions.
our experiments demonstrate that our approach is effective in finding errors in input validation functions that we collected from real world applications and from tutorials and books for teaching javascript.
i. i ntroduction a crucial problem in developing dependable web applications is the correctness of the input validation operations.
one of the main forms of interaction between a user and a web application is through text fields where the user types a text as input which is then parsed by the web application and converted to some specific type of data such as a date a credit card number or an e mail address.
a web application needs to separate valid user input from inputs that do not match the expected input type and prompt the user to reenter an appropriate input if necessary.
web applications typically use a three tier architecture which consists of client side code executing at the user s machine that is running the browser server side code executing at the web server and the back end database storing the persistent data on a separate database server .
in recent years in order to improve efficiency and usability web applications have started to migrate many of the computational tasks to the client side code.
this makes applications more responsive by reducing the need to send a request to the web server from the user s machine and wait for the response.
nowadays many web applications include client side input this research is funded by the nsf grants ccf and cns1116967 and by king saud university.validation functions that check the user input and warn the user if the input is invalid without requiring any interaction with the web server.
in this paper we focus on automated verification of clientside input validation functions for three main reasons security client side input validation vulnerabilities are an emerging class of vulnerabilities that are due to errors in the client side input validation functions .
correctness errors in the client side input validation functions can cause valid inputs to be rejected without reaching the server.
performance errors in the client side input validation functions can degrade the performance by creating unnecessary communication between the client and the server.
in order to verify client side input validation functions in an existing web application we first have to extract the input validation functions from the application.
we do this by executing the application using both valid and invalid input values and track accesses to the input values in order to identify the input validation operations.
we use dynamic slicing to find all the statements that are influenced by the input values that we track.
we output the resulting slice in the form of an input validation function that returns true or false based on the input value.
we check the correctness of the automatically extracted input validation functions using an automata based string analysis.
we use deterministic finite automata dfa to represent values that string expressions can take.
at each program point each string variable is associated with a dfa.
we use a forward symbolic reachability analysis that computes an over approximation of all possible values that string variables can take at each program point.
since convergence of the symbolic reachability analysis is not guaranteed without approximation we use an automata based widening operation in the presence of loops.
our analysis is path sensitive and handles the branch conditions by appropriately restricting the values that string variables can take at the true and false branches of a conditional branch.
our analysis is conservative in the sense that the set of string values we compute correspond to a superset of possible string values that a string expression can take at runtime.
we assume that each input validation function takes a string value as input and returns true if the input is valid i.e.
if the input is permitted by the input validation policy or returns false otherwise.
when we automatically extract aninput validation function we extract it in this form.
using our string analysis we compute all possible input values that allows the program to reach to the return true statement.
then we check if this set of values are a subset of the language defined by the regular expression characterizing the input validation policy.
if it is then we know that the application implements the input validation policy correctly.
one easy way to conform to every input validation policy would be to reject all the inputs.
in order to make sure that an input validation function is allowing at least some reasonable set of inputs we write the input validation policies using two regular expressions one maximum policy corresponding the largest set of strings that should be recognized as valid i.e.
everything outside this set should be definitely rejected and one minimum policy corresponding to the smallest set of strings that should be recognized as valid i.e.
everything within this set should be definitely accepted .
having a minimum and a maximum validation policy helps us in two ways it provides more flexibility where an application does not have to match to a single policy exactly but instead has to do validation that is at least as strict as the maximum policy and at least as permissive as the minimum policy.
having a minimum policy allows us to check for the cases where an application erroneously disallows some valid user inputs.
in order to check that the application is at least as strict as the maximum policy we look at the input values that reach the return true statement as we described above.
however in order to check that the application is at least as permissive as the minimum policy we use our string analysis to compute all possible input values that allows the program to reach to the return false statement.
then we check if the intersection of this set of values and the minimum policy is empty.
if it is then we conclude that the application is not rejecting any user input that should be valid according to the minimum policy.
ii.
a noverview in this section we give an overview of how we model the client side input validation function verification problem.
client side input validation functions a client side input validation function takes a string value from a web html form field and checks it against a certain policy.
if none of the validation functions used for a form report a violation then the form data is submitted to the server otherwise it is not submitted.
we make the following assumptions about the validation functions a validation function takes at least one string input and checks it with respect to a certain policy and returns either true or false.
true indicates that the string input conforms to the policy and false indicates otherwise.
figure shows an email validation function taken form a popular javascript book .
the function checks that the email is not empty and that it conforms to the given regular expression.
there is a subtle error in this function.
in the1 function validateemail inputfield helptext if !
.
.test inputfield.value if helptext !
null helptext.innerhtml please enter a value return false else if helptext !
null helptext.innerhtml if !
.
.test inputfield.value if helptext !
null helptext.innerhtml please enter an email address return false else if helptext !
null helptext.innerhtml return true figure .
a javascript input validation function.
regular expression in line the author wanted to specify that the first part of the email before the only contains alphanumeric characters and .
and .
other special characters such as are not allowed.
however .
includes all ascii characters in the range between .
and which includes the special character .
the developer forgot to escape the character which indicates a range of characters if it is not escaped.
validation policies we use two types of validation policies max andmin.
the max policy specifies the maximal set of strings that should be accepted while the minpolicy specifies the minimal set of strings that should not be rejected.
we use regular expressions for specification of the max andmin policies.
this is a natural choice since regular expressions are well known and developers implementing input validation functions commonly use regular expressions in string manipulation functions.
figures and show a number of maximum and minimum input validation policies that we have used in our analysis.
each policy has two entries the type of the input field that is checked against this policy and the specification of the policy as a regular expression.
the standard syntax we use for specifying regular expressions is a subset of preg syntax that is used in javascript and other languages.
for some simpler input types we have the same maximum and minimum policies.
for example the email policy in figure specifies the correct value for an email address.
it is a more restrictive policy than rfc5322 which specifies valid email addresses.
this is due to the fact that some major email providers such as hotmail are much more restrictive in their email address policy than the previous standard.
although some of these policies look simple we were surprised to find that there are many validation functions that do not adhere to them.email !
.
date !
?
phone !
?
?
?
?
?
time !
m ?
zip code !
?
notempty !
.
.
figure .
maximum input validation policies.
email !
.
date !
phone !
time !
zip code !
notempty !
.
.
figure .
minimum input validation policies.
for example four out of five validation functions that we found in javascript tutorials and textbooks that check for emptiness miss the fact that a form field with only spaces should be considered to be an empty field.
input validation function verification if the set of strings accepted by a validation function is not a subset of the max policy or not a superset of the min policy then we consider the validation function to be faulty.
in other words let us assume that the set of strings considered to be valid by a validation function fisl ftrue i.e.
these are the string values for which the validation function returns true.
let us assume that the language of the max policy that specifies the maximal valid set of inputs for the given field type is l pmax and the language of the min policy that specifies the minimal valid set of inputs for the given field type isl pmin .
then the input validation function verification problem is to check if l pmin l ftrue l pmax .
since the string analysis is an undecidable problem in general it is not possible to compute l ftrue precisely.
however using our automata based string analysis approach we can compute an over approximation l ftrue such thatl ftrue l ftrue .
note that if l ftrue l pmax then we can be sure that fconforms to the max policy.
if l ftrue l pmax on the other hand we cannot definitely say that fviolates the max policy.
since l ftrue is an over approximation we may have a false positive.
in this case in order to figure out if the input validation function is really faulty we generate a string value s2l ftrue nl pmax and execute the input validation function on that value.
if the input validation function returns true for this input then we are sure that the input validation function violates the max policy and the generated string sserves as a counter example demonstrating the policy violation.
we cannot use the over approximation l ftrue tocheck conformance to the min policy since l pmin l ftrue does not imply that l pmin l ftrue .
in order to check conformance to the min policy we need an under approximation of l ftrue .
however since our string analysis is a sound analysis technique it can only generate over approximations.
we solve this problem by using our string analysis to compute an over approximation of the set of values for which the input validation function freturns false.
let us call this set l ffalse .
using our string analysis we compute l ffalse such that l ffalse l ffalse .
then we check if l ffalse l pmin .
if the intersection of l ffalse andl pmin is empty then we can be sure that the validation function fdoes not reject any value that is allowed by the minpolicy i.e.
it conforms to the min policy.
if on the other hand l ffalse l pmin we cannot be sure that fviolates the min policy since it can be a false positive.
in this case we generate a string s2l ffalse l pmin and execute the input validation function on input s. if the input validation function returns false for this input then we can be sure that fviolates the min policy and sis a counter example demonstrating this policy violation.
iii.
v alidation function extraction in this section we discuss how we extract a validation function for a given html form input field.
we start with a brief discussion of validation of html forms using javascript.
input validation with javascript the first step in form validation is to register an event handler for some event of the input form or its fields.
the event handler is then used to call the javascript validation code for some or all of the form fields.
based on the result returned by this validation code either the form will be submitted or error messages will be shown to the user.
submission of the form data is done either by the browser itself or a javascript issued xhr xmlhttprequest request when ajax is used.
the default event for handling form validation code is onsubmit event of the form itself.
in the basic case the browser will execute theonsubmit event handler if found when a user tries to submit an html form by clicking on an html element of typesubmit .
if the handler returns true or if there is no handler for onsubmit then the browser will submit the form data using an ordinary http get post request.
in this approach all the validation code goes inside the onsubmit handler and the functions it calls.
in websites that use ajax and xhr to submit the forms the situation is different.
first of all the onsubmit handler should return false when the element used to submit the form is of type submit so that the browser does not submit the form itself .
furthermore since the form will be submitted from within the javascript code the element the user is supposed to click to submit the form does not have to be oftypesubmit and there is a large number of events besides onsubmit that can be linked to form submission such as onclick onmousedown and onmouseup .
finally due to the capturing and bubbling of dom events it is possible to do the validation in an event handler for one of the events of one of the ancestors of the element used to submit the form.
this happens especially when the area the user clicks on to submit the form consists of multiple elements overlaid on top of each other.
validation function extraction it is not feasible to statically find and extract the code that does the client side input validation.
first it is difficult to find the event handlers that contain the form validation code due to the variety and complexity of the input validation process discussed above.
even in the basic case where the onsubmit event handler is used sometimes this event handler is registered dynamically from within the javascript code that loads the page instead of being statically linked in the html code of the webpage.
second even if we succeed in statically locating and extracting the event handling code the code itself is large and full of event handling error handling and error message rendering functions which are hard to separate statically.
furthermore the validation code contains all the validation functions for all form fields mixed together instead of having one function per input field.
in our analysis we focus on one form input field at a time and break the verification process into two phases.
in the first phase we extract a dynamic slice from the javascript code that is executed upon form submission.
this slice represents the validation code for the field we are targeting.
it contains all the statements that access the targeted field along with all the other statements they depend on.
then in the second phase we statically analyze the extracted slice using string analysis techniques discussed in section iv to check if the validation code conforms to the minimum and maximum validation policies.
as discussed in section ii in order to verify the input validation function in a sound manner with respect to the maximum and minimum policies we need to overapproximate both the set of inputs that are accepted by the input validation function and also the set of inputs that are rejected by the input validation function respectively.
we do this by generating based on our policies two input values a valid and an invalid one.
we run the program for each input and extract two separate dynamic slices.
we record the last control branch that accesses the input value that we provided.
if the input value we provided at the beginning is a valid input value we insert the statement return true to the beginning of the branch that the execution takes.
if the input value we provided at the beginning is an invalid input value then we insert the statement return false.
we use the slice extracted using the valid input value to obtain an over approximation of the values that the input validationfunction accepts by computing an over approximation of the input values that reach the statement return true .
we use the slice extracted using the invalid input value to obtain an over approximation of the values that the input validation function rejects by computing an over approximation of the input values that reach the statement return false .
we implemented the dynamic slicing on top of htmlunit which is a browser simulator written in java that uses rhino javascript interpreter.
using htmlunit we simulate the process of filling out a form and submitting it.
we provide a profile of values that will be used to fill out the form including one value per each form input and two values valid and invalid for the target input field.
during this simulation we instrument the interpreter to track all the javascript statements that operate on or test the content of our target field.
we then output these statements and all other statements in the execution trace that they depend on.
if there are function calls we inline them such that the final code consists of only one validation function for the target field which ends with either a return true statement or a return false statement.
since we have instrumented the javascript interpreter we convert all accesses on objects and arrays to accesses on memory locations.
this avoids imprecision in our static string analysis phase due to objects arrays and aliasing.
iv.
s tring analysis given a javascript input validation function we compute an over approximation of string variables values at each program point using a flow and path sensitive intra procedural symbolic string analysis algorithm.
the possible values of a string variable at a program point is represented by a deterministic finite automaton dfa .
we use a symbolic automaton representation where the transitions of the automaton are represented as a multi terminal binary decision diagram mbdd .
lattice since javascript is not statically typed it is not possible to statically infer variable types before performing our analysis.
hence during our string analysis we have to take into account all the variables in the validation function since they can all potentially hold string values.
moreover we have to take into account that variables can change their types during execution.
we use a value lattice that reflects this by initializing all variables in the code to a special value called uninitialized value denoted as?
which corresponds to the bottom element of the lattice.
this special value indicates that the variable type is unknown.
as soon as we figure out that a variable is a string variable we initialize its value to which corresponds to the empty language i.e.
no string value .
if we find out through our analysis that a variable is actually not a string variable we change its value to the top value of the lattice which corresponds to unknown value and unknown type and is denoted as .
just below the top value of the lattice we have which corresponds to all possible strings and this corresponds to the case where we know that a variable is a string variable but we do not know anything about its value i.e.
it could have any string value.
if we exclude the top and bottom elements of the lattice which are introduced to deal with non string values the remaining elements form a sub lattice where is the least element and is the greatest element and all the other elements are regular languages over the alphabet .
algorithm our string analysis algorithm algorithm starts by receiving the control flow graph of the given validation function along with the validation policies as input.
each node in the cfg represents a statement in the given validation function.
in this discussion we will only concentrate on the types of nodes statements that are crucial for our analysis.
there are two main types of statements we are dealing algorithm string analysis cfg policy min policy max initparams queue wq null wq .enqueue cfg entrynode while wq6 null do node wq .dequeue in s node02prednodes node outnode0 if node ifpred then then tmpont tmponf in if numofv ars pred then var getpredv ar pred predv al evalpred pred tmpont in predv al tmponf in predv al end if tmpont tmpont out ont rout ont tmponf tmponf out onf rout onf if tmpont6 out ont then out ont tmpont out onf tmponf wq .enqueue succ node end if else tmp in tmp evalexp exp in tmp tmp out rout if tmp6 out then out tmp wq .enqueue succ node end if end if end while for node return true do if l out node policy max then s pick l out node npolicy max return counter example s else return ok end if end for for node return false do if l out node policy min6 then s pick l out node policy min return counter example s else return ok end if end forexp !
replace ptrn strlit var j call func ... jconcat exp exp j varjstrlitjnumlit jboollit jnulljundefined figure .
the abstract grammar for the right hand side expressions in an assignment statement.
with in the algorithm which are assignment statement and conditional statement .
each statement is associated with two arrays of dfas inandout.
both inandout have one dfa for each variable and input parameter in the validation function.1given variable v and the inarray for a statement in is a dfa that accepts all string values that variable vcan take at the program point just before the execution of that statement.
similarly out is a dfa that accepts all string values that variable vcan take at the program point just after the execution of that statement.
the tmp array is used to store the temporary values i.e.
dfas computed by the transfer function before joining these values with the previous ones.
as shown in algorithm the algorithm starts by initializing all the validation function parameter values in the inarray of the entry statement to .
this indicates that the validation function can receive any string value as input.
at each program point we update the dfas in the out array based on the dfas in the in array and the transfer function of the statement at that point.
below we describe the transfer function used to compute theout array for each of the two basic types of statements mentioned above.
notice that assignment join and widening operations on inandout arrays are carried out as pointwise operations.
assignment statement in this type of statement a variable on the left hand side is assigned a value of an expression on the right hand side.
figure shows the syntax for the type of expressions on the right hand side that we handle with our analysis.
we use the function evalexpto compute the set of string values that an expression can take.
this function takes two inputs an expression on the right hand side of an assignment and an inarray which is the inarray of the assignment statement where the expression is .
it evaluates the expressions as follows var the set of values for the variable varin the inarray i.e the dfa in is returned.
strlit a singleton set that only contains the value of the string literal strlit is returned i.e.
a dfa that recognizes onlystrlit .
numlit boollit null since our analysis is concerned only with analyzing string values in these cases we return indicating that the value and type of the expression is not known.
1in our implementation we have a wrapper around the dfa representation in order to represent the bottom ?and top elements but we will refer to inandout as dfa arrays to simplify the discussion.
undef this represents an uninitialized variable so we return?.
concat exp1 exp2 here we compute the concatenation of the regular languages resulting from evaluating exp1 andexp2and return it as the result using the symbolic dfa concatenation operation discussed in .
replace ptrn strlit var here we compute the result of replacing all string values in in that match the pattern ptrn given as a regular expression with the string literal strlit .
there are two types of pattern matching partial match and full match .
the match operation used is chosen based on ptrn value as follows if the value starts with the symbol and ends with the symbol this means that we have to do a full match where we have to replace a string in in only if it fully matches the regular expression given by ptrn .
this is done by taking the difference between the language in in and the language l ptrn and then adding the replace string strto the result.
otherwise we use partial match where we compute the result by using the language based replacement algorithm described in .
callfunc since our analysis is intra procedural we only analyze one function at a time without following any function call.
however for the commonly used functions such as replace and its variations we have constructed function models that can be used during our analysis.
so in case of a function call there are three options we inline the function if possible.
we use the model that we have for this function if it is available.
if the first two options are not available then we return indicating an unknown string value.
conditional statement this type of statement represents the branch conditions in a number of language constructs in javascript including if statement for loop while loop and do while loop .
conditional statement consists of a predicate on variables and constants.
since it represents a branch in the program unlike other statements it is followed by two statements one after the on true branch and the other one after the on false branch.
the predicate in a conditional statement constrains the values of its variables in each of the two branches of execution following the conditional statement.
if the predicate evaluates to true the execution will continue in the on true branch otherwise it will take the on false branch.
this behavior is represented in our analysis by having two out arrays reflecting the possible future values on each of the two branches of execution.
outontrepresents the values for the on true branch and outonf represents the values for the on false branch.
in order to compute these arrays we first compute the dfa that accepts the set of string values that a variable can take that would make the predicate to evaluate to true we describe this in detail in the next section .
then we compute the out arrayof the on true branch of the conditional statement by intersecting the indfa for the variable with the dfa for the set of strings that make the predicate to evaluate to true.
on the other hand for the on false branch we intersect theindfa with the dfa that is the complement of the dfa that corresponds to the strings that make the predicate to evaluate to true.
fixed point computation algorithm shows our string analysis algorithm that computes the least fixed point that over approximates the possible values that string variables can take at any given program point.
at each iteration of the algorithm we compute the transfer function for a statement as described above.
after computing the transfer function using the inarray we update the out array for the current statement using the join union and widening operators.
the widening operator we use here is taken from and it is used to achieve convergence since the analysis lattice has an infinite height.
briefly we merge those states in the two input automata belonging to the same equivalence class.
two states are equivalent if the languages accepted starting from the two states are equivalent or both states are reachable from the initial state via the same string.
the analysis converges when the work list becomes empty which means that reevaluating the transfer functions will not change any of the out arrays.
after the convergence the out value for the input parameter param at the return true statement which corresponds to an over approximation of the set of input values that the validation function identifies as valid is checked against the maximum policy and the out value for the input parameter at the return false statement which corresponds to an over approximation of the set of input values that the validation function identifies as invalid is checked against the minimum policy.
at return true statement we verify that all input values that are considered valid by the validation function conform to our maximum policy i.e.
are a subset of the maximum policy .
if not we generate a counter example string that is not in the maximum policy but is considered to be valid by the input validation function to compute the counter example string we implement a function pick that returns a string accepted by a given dfa .
at return false statement we verify that none of the input values that are considered to be invalid by the validation function are a member of the minimum policy.
if not we generate a counter example string demonstrating the minimum policy violation.
a. handling predicates we only handle the javascript predicates that are used for string manipulation.
figure shows the syntax of the predicate language that we handle.
due to space limitations we only list a subset of the predicates that we can handle.
an important point that is not expressed in the abstract syntax is that we only handle predicates on a single variablepred !
pred predjpred predj!pred j varrelop strlitjvar.length relop intlit j regexp .test var jvar.match regexp j var.indexof strlit relop intlit relop !
j j j j j!
figure .
the abstract grammar for the branch conditions handled by our analysis.
which means that varin the above syntax must be the same variable throughout the whole predicate.
so each branch condition must be on a single string variable although of course different branch conditions can be on different variables .
the reason behind this restriction is mainly the limitations of the dfa representation we are using which can only store a single set of values for each program variable at each program point.
consider the following predicate on two different variables xandy x foo y bar .
on the on true branch of the condition there are three possible outontstates.
one possibility is to restrict the value of xonly.
the second one is to restrict the value of yonly.
the third and last one is to restrict both values.
these three possibilities reflect the fact that program execution may take the on true branch when either x foo y bar orx foo andy bar .
note that we cannot express these three scenarios using only two dfas one for xand one for y .
even when we handle a predicate with and boolean operator we will have a similar problem when handling the on false branch of the conditional statement.
we can consider using a set of dfas for each variable however this problem gets worse when the conditional statement is part of a loop structure.
in this case for each iteration of the fixed point computation we will add more and more possibilities of out states and the number will grow exponentially requiring more and more dfas to represent it.
hence due to this problem we limit that the predicates should be on a single variable.
interestingly in our experiments we did not encounter any predicate with more that one variable so this limitation was not significant in practice.
algorithm shows the algorithm we use to compute the dfa for a given predicate on a certain variable.
the algorithm takes a predicate on one variable as input and returns the corresponding dfa in the algorithm we represent the dfa using the regular expression for its language .
the dfa is computed recursively on the given predicate following its recursive structure.
notice that wherever we use the notation iit means concatenating itimes where .
we have omitted the discussion of some of the predicates due to the space limitation.
v. e xperiments the approach presented in this paper can be used both as a forward engineering approach as an analysis used during the application development or as a reverse engineeringapproach by automatically extracting and analyzing input validation functions after deployment .
we evaluated the forward engineering scenario on input validation functions collected from tutorials and books for teaching javascript.
algorithm evalpred pred ifpred pred1 pred2 then return evalpred pred1 evalpred pred2 else if pred pred1jjpred2 then return evalpred pred1 evalpred pred2 else if pred !pred1 then return evalpred pred1 else if pred var strlit then retval fstrlitg return retval else if pred var!
strlit then retval fstrlitg return retval else if pred var.length intlit then return intlit else if pred var.length intlit then return sintlit l l else if pred var.length intlit then return sintlit l l else if pred var.length intlit then returnsintlit l l else if pred var.length intlit then returnsintlit l l else if pred var.length !
intlit then return intlit else if pred regexp.test var var.match regexp then ifcheck regexp regexp partial match then return concat concat l regexp else return l regexp end if else if pred var.indexof strlit intlit then ifintlit then return fstrlit g else if intlit 0then return concat intlit concat fstrlit g end if else if pred var.indexof strlit intlit then ifintlit then return concat concat fstrlit g else return concat fstrlit g intlit concat concat fstrlit g end if else if pred var.indexof strlit intlit then return concat fstrlit g intlit concat concat fstrlit g else if pred var.indexof strlit intlit then ifintlit then return fstrlit g else returnsintlit l 0concat l concat fstrlit g end if else if pred var.indexof strlit intlit then ifintlit 0orintlit then return fstrlit g else returnsintlit l 0concat l concat fstrlit g end if else if pred var.indexof strlit !
intlit then ifintlit then return concat concat fstrlit g else if intlit 0then return concat fstrlit g else return concat intlit concat fstrlit g end if else return end ifwe evaluated the reverse engineering scenario on several real world applications by extracting and analyzing their input validation functions.
in our experiments we used a macbook pro with a .
ghz core due processor and gb of memory.
a. verifying stand alone input validation functions in this section we show the results of verifying javascript validation functions collected from a javascript book and several javascript input validation tutorials on the internet.
the book on javascript and the tutorials represent a set of validation functions that should have been written very carefully given that these are examples used for teaching javascript programming.
these functions also include a wide variety of string operations and predicates that one expects to see in a javascript application and hence form a good benchmark for evaluating the effectiveness of our string analysis techniques.
the functions we analyzed cover all the policies mentioned in section ii.
five of the validation functions were changed slightly to conform to our assumptions for validation functions so that the modified function return true false values instead of empty nonempty error messages in case of acceptance rejection of input.
results.
the total time it took for analyzing the functions was .
seconds during which lines of code have been analyzed.
table i shows the individual results for each validation function using our analysis.
the first column is the validation function name.
the second one is the source for this function.
the third column shows the type of data that is validated by this validation function which is also the type of policy used to verify the function itself.
columns four and five show the performance of our string analysis in terms of time and memory.
last column shows the result for verification against both the maximum and the minimum policies.
failing the maximum policy means that the function accepts some values that are invalid according to our policy.
for example the first function does not satisfy the maximum policy which means that it allows email addresses that are considered to be invalid by our policy.
on the other hand failing the minimum policy means that the function rejects some values that are correct according to our policy.
for example function number does not satisfy the minimum policy which means that it rejects some time inputs that we consider to be correct.
discussion.
among the functions we have analyzed of them violated a maximum policy while of them violated a minimum policy.
we tested these results using the counterexamples generated by our analysis and did not find any false positives due to over approximation.
it is interesting to see that all the functions that validate the email addresses failed to comply with our maximum email policy which is the most complicated policy we used .
it is even more interesting to see that four of the five functions that validatenon emptiness failed to comply with our maximum non emptiness policy although this check seems very simple.
the most subtle error in email validation functions is the one that we discussed at the beginning of section ii where the developer forgot to escape the dash character inside a character class.
this results in accepting email addresses with invalid characters such as .
another problem that we have found is the usage of a black list to block invalid characters in an email address rather than a white list where only valid characters are accepted.
all of these black lists miss at least one invalid character.
we think that the white list approach that we used in our policy is much simpler and less error prone.
the phone validation function number failed to comply with our minimum policy because it rejects a phone number that has two parentheses around its area code.
this is the most common format to write a phone number in us and hence in our minimum policy we specify that this should be accepted as valid input.
the most surprising result is the errors in non emptiness checks.
the reason behind the four failures is that these four functions accept a field value that only consists of white space characters while such value should be considered empty.
such a validation error will likely cause an unnecessary interaction with the web server and if the same validation check is also erroneous at the server side it can lead to fatal errors in the application.
our results demonstrate that writing input validation checks in javascript is an error prone task and even the sample validation functions shown in tutorials and books on javascript contain errors.
using the string analysis techniques we presented we can efficiently check the conformance of a javascript input validation function to a given input validation policy.
b. verifying input validation operations in deployed web applications we applied our verification technique to a number of real world websites that use javascript to validate their html form inputs.
for each of these websites we pick an html form fill it out and submit it.
during submission we automatically extract the validation code for one target field and analyze this code statically to see if it violates our predetermined policies for the type of that field.
we applied our technique on fields with common input format such as email phone number etc.
our analysis can also be applied to other fields that need specific policies chosen by the organization running the website such as username and password fields.
results.
table ii shows the results of applying our analysis to a number of websites.
each row represents the results for extracting and verifying the validation code for a single input field in a form in the given website.
since this is done twice for a valid and invalid input we show two sub columns fortable i results of our analysis on input validation functions collected from javascript books and tutorials funcname source type time seconds memory mb result max policy min policy validateemail book headfirst javascript email .
.
xp validateemail tut email .
.
xp emailvalidator tut email .
.
xp checkemail tut email .
.
xp isemailaddress tut email .
.
x x isalphabet tut alphabet .
.1pp isalphabetic tut alphabet .
.0pp isalphanumeric tut alphanumeric .
.1pp isalphanumeric tut alphanumeric .
.2pp isnumeric tut numeric .
.0pp isnumber tut numeric .
.7pp validatedate tut date .
.0pp validatedate book headfirst javascript date .
.2px validatephone tut phone .
.6pp checkphone tut phone .
.4pp validatephone book headfirst javascript phone .
.
x x validatetime tut time .
.1pp validatezipcode book headfirst javascript zipcode .
.1pp validateempty tut notempty .
.
xp notempty tut notempty .
.
xp isempty tut notempty .
.
xp isempty tut notempty .
.2pp validatenonempty book headfirst javascript notempty .
.
xp table ii results of our analysis on deployed websites source type code size loc execution trace size loc extraction time s analysis time s result valid invalid valid invalid valid invalid valid invalid max min email .
.
.
.
xp email .
.
.
.
xp phone number .
.
.
.
xp email .
.
.
.
x x email .
.
.
.
xp email .
.
.
.
xp email .
.
.
.
x x email .
.
xp email .
.
.
.
xp email .
.
xp zip code .
.
.
.
xp email .
.
.
.
xp zip code .
.
.
.
xp each.
the first column is name of website where we got the form from.
the second column shows the type of data that is validated by this validation function which is also the type of policy used to verify the function itself.
column three shows the size in lines of code of the form submission handling code including the validation code from which we extracted the validation function.
column four shows the number of lines of code that has been executed as part of submitting the form.
column five shows the time it takes to dynamically extract the validation function while column six shows the time to statically analyze the extracted function.
in two cases there was no validation code in the application and the extracted validation function was empty.
hence there was no string analysis done for these two cases and the corresponding column is left empty.
last column shows the result for verification against both the maximum and the minimum policies where an x means a policy violation.
policy violations.
we have found a policy violation in each of the websites that we tested.
some of these policyviolations are a result of subtle bugs in the validation code some of them are a result of writing light weight validation code or even not writing any and some of them are due to minor differences between our policies and websites policies.
two subtle bugs that we have found are in and .
in a condition in the validation code was supposed to reject any email that ends with csta.acm.org .
this was written as if ckemailval.match csta.acm.org f..g the programmer forgot to escape the dot as a special character in the regular expression so when javascript converts this string into a regular expression it will interpret dot as any character.
our analyzer output a cstaaacm.org as an example for an email that should not be rejected.
we changed our minimum policy to reflect the website developers intention and still got a policy violation with the same example.
in a website for a large telecom company the developers claim that they follow the rfc standard for emailaddresses.
we found that they disallowed capital characters from emails with no obvious reason and our analyzer gave the following example that should not be rejected a a.aaa .
some of the other websites have lightweight validation code that will accept incorrect input.
for example only checks for presence of and .
in an email and our analyzer gave .
n as an invalid email that is accepted.
accepts any email that does not have space or in it.
our analyzer gave 0x1f 0x1f.0x1f as an invalid email that is accepted.
this latter example was randomly generated and happened to be not printable but for this case there are counter examples with printable characters.
finally two websites and had no validation code at all and our slicer returned an empty validation function meaning that all input values are accepted.
in this corner case there is no need to run the string analysis and we only report a maximum policy violation.
vi.
r elated work client side input validation is an important problem that has been studied before.
flax uses dynamic analysis techniques to discover client side validation vulnerabilities.
the authors use dynamic taint analysis to extract validation code related to a certain sink and then use random fuzzing to test this sink.
in our technique we use a similar approach to extract the validation function but then we statically analyze the extracted code to see if it violates the given policies.
in authors developed a symbolic execution framework for javascript.
at the core of their framework there is a string constraint solver called kudzu that is built on top of the bounded string solver hampi .
their approach is able to handle a larger set of string operations and predicates in javascript compared to our approach.
however their approach bounds the lengths of the execution paths by bounding loops and uses a bounded string solver whereas our approach handles unbounded paths using widening and handles unbounded strings using automata .
for the verification problem we are addressing a bounded string solver can only find policy violations but it can not prove the conformance to a given policy.
our static string analyzer i.e.
the second phase of our analysis is sound with respect to the restricted set of javascript string operations and predicates that we can handle and can prove that a validation function conforms to a given policy.
notamper uses dynamic symbolic execution to discover constraints on html form inputs at the client side.
then it uses these constraints to generate input values to test the server side input validation.
in contrast we are focusing on finding input validation errors at the client side with respect to a given policy.
mitv uses dynamic symbolic execution engine pex to test the correctness of user input validation functions for .net web applications.
these functions arefirst classified according to the type of input they validate.
then each validation function is tested by comparing it to a subset of the functions under the same class.
as we have seen in our experiments it is possible for many or even all functions in a specific class to fail to correctly validate a user input.
so we believe that it is worthwhile to develop validation policies and then use these policies as a reference for verification of different implementations.
gatekeeper uses static analysis to verify the enforcement of security policies written in datalog on javascript widgets.
these policies are different than ours and they are not related to input validation.
due to its importance for establishing dependability of web applications string analysis has been widely studied.
one influential approach has been grammar based string analysis that statically computes an over approximation of the values of string expressions in java programs which has also been used to check for various types of errors in the server side of web applications .
in multi track dfas also known as transducers are used to model replacement operations.
dfa based symbolic string analysis has been used to verify the correctness of string sanitization operations in php programs .
recently foundations of relational string analysis using multi track automata as opposed to single track automata used in our analysis were investigated in .
in the future we plan to investigate integration of relational string analysis to our javascript string analyzer which would allow us to analyze branch conditions on multiple variables.
another future research direction would be automatically synthesizing fixes to validation functions that violate a given policy using techniques similar to the vulnerability patching techniques presented in .
there are also several other string analysis tools that use symbolic string analysis based on dfa encodings .
some of them are based on symbolic execution and use a dfa representation to model and verify the string manipulation operations in java programs .
vii.
c onclusions we have presented an approach for verifying client side input validation functions.
given maximum and minimum policies identifying the largest and smallest set of input values that should be accepted as valid our analysis verifies if a given website conforms to the given policies by first extracting an input validation function from the given website using dynamic slicing and then checking the conformance of the extracted function to the given policies using automata based static string analysis.
when there is a policy violation our analysis generates a counter example string demonstrating the violation.
we applied our analysis to a number of validation functions and websites and our results indicate that it can effectively find subtle errors in client side input validation code.