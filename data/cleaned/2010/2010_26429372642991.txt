leveraging existing tests in automated test generation for web applications amin milani fard mehdi mirzaaghaei ali mesbah university of british columbia vancouver bc canada aminmf mehdi amesbah ece.ubc.ca abstract to test web applications developers currently write test cases in frameworks such as selenium .
on the other hand most web test generation techniques rely on a crawler to explore the dynamic states of the application.
the rst approach requires much manual e ort but bene ts from the domain knowledge of the developer writing the test cases.
the second one is automated and systematic but lacks the domain knowledge required to be as e ective.
we believe combining the two can be advantageous.
in this paper we propose to mine the human knowledge present in the form of input values event sequences and assertions in the human written test suites combine that inferred knowledge with the power of automated crawling and extend the test suite for uncovered unchecked portions of the web application under test.
our approach is implemented in a tool called testilizer.
an evaluation of our approach indicates that testilizer outperforms a random test generator and on average can generate test suites with improvements of up to in fault detection rate and up to in code coverage compared to the original test suite.
categories and subject descriptors d. .
testing and debugging general terms veri cation algorithms experimentation keywords automated test generation test reuse web applications .
introduction web applications have become one of the fastest growing types of software systems today.
testing modern web applications is challenging since multiple languages such as html javascript css and server side code interact with each other to create the application.
the nal result of all permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
interactions at runtime is manifested through the document object model dom and presented to the end user in the browser.
to avoid dealing with all these complex interactions separately many developers treat the web application as a black box and test it via its manifested dom using testing frameworks such as selenium .
these dombased test cases are written manually which is a tedious process with an incomplete result.
on the other hand many automated testing techniques are based on crawling to explore the state space of the application.
although crawling based techniques automate the testing to a great extent they are limited in three areas input values having valid input values is crucial for proper coverage of the state space of the application.
generating these input values automatically is challenging since many web applications require a speci c type value and combination of inputs to expose the hidden states behind input elds and forms.
paths to explore industrial web applications have a huge state space.
covering the whole space is infeasible in practice.
to avoid unbounded exploration which could result in state explosion users de ne constraints on the depth of the path exploration time or number of states.
not knowing which paths are important to explore results in obtaining a partial coverage of a speci c region of the application.
assertions any generated test case needs to assert the application behaviour.
however generating proper assertions automatically without human knowledge is known to be challenging.
as a result many web testing techniques rely on generic invariants or standard validators to avoid this problem.
these two approaches work at the two extreme ends of the spectrum namely fully manual or fully automatic.
we believe combining the two can be advantageous.
in particular humans may have the domain knowledge to see which interactions are more likely or important to cover than others they may be able to use domain knowledge to enter valid data into forms and they might know what elements on the page need to be asserted and how.
this knowledge is typically manifested in manually written test cases.
in this paper we propose to mine the human knowledge existing in manually written test cases combine that inferred knowledge with the power of automated crawling and extend the test suite for uncovered unchecked portions of the web application under test.
we present our technique and tool called testilizer which given a set of selenium test casestcand the url of the application automatically infers a model from tc feeds that model to a crawler to expand by exploring uncovered paths and states generates assertions for newly detected states based on the patterns learned from tc and nally generates new test cases.
to the best of our knowledge this work is the rst to propose an approach for extending a web application test suite by leveraging existing test cases.
the main contributions of our work include a novel technique to address limitations of automated test generation techniques by leveraging human knowledge from existing test cases.
an algorithm for mining existing test cases to infer a model that includes input data event sequences and assertions and feeding and expanding that model through automated crawling.
an algorithm for reusing human written assertions in existing test cases by exact partial assertion matching as well as through a learning based mechanism for nding similar assertions.
an implementation of our technique in an open source tool called testilizer .
an empirical evaluation of the e cacy of the generated test cases on four web applications.
on average testilizer can generate test suites with improvements of up to on the fault detection rate and up to on the code coverage compared to the original test suite.
.
background and motivation in practice web applications are largely tested through their dom using frameworks such as selenium .
the dom is a dynamic tree like structure representing user interface elements in the web application which can be dynamically updated through client side javascript interactions or serverside state changes propagated to the client side.
dom based testing aims at bringing the application to a particular dom state through a sequence of actions such as lling a form and clicking on an element and subsequently verifying the existence or properties e.g.
text visibility structure of particular dom elements in that state.
figure depicts a snapshot of a web application and figure shows a simple dom based selenium test case for that application.
for this paper a dom state is formally de ned as definition dom state .
a dom statedsis a rooted directed labeled tree.
it is denoted by a tuple d q o wheredis the set of vertices qis the set of directed edges o2dis the root vertex is a nite set of labels and d!
is a labelling function that assigns a label from to each vertex in d. the dom state is essentially an abstracted version of the dom tree of a web application displayed on the web browser at runtime.
this abstraction is conducted through the labelling function the implementation of which is discussed in subsection .
and section .
motivation.
overall our work is motivated by the fact that a human written test suite is a valuable source of domain knowledge which can be exploited for tackling some of the challenges in automated web application test generation.
another motivation behind our work is that manually written test cases typically correspond to the most common happy paths of the application that are covered.
automated analysis can subsequently expand these to cover unexplored bad weather application behaviour.
figure a snapshot of the running example and its partial dom structure.
test 2public void testaddnote 3get http localhost theorganizer 4findelement by.id logon username .sendkeys user 5findelement by.id logon password .sendkeys pswd 6findelement by.
cssselector input type image .
click 7assertequals welcome to the organizer !
closealertandgetitstext 8findelement by.id newnote .click 9findelement by.id notecreateshow subject .
sendkeys running example findelement by.id notecreateshow text .sendkeys create a simple running example findelement by.
cssselector input type image .
click assertequals note has been created .
driver .
findelement by.id maincontent .
gettext findelement by.id logoff .click figure a human written dom based selenium test case for the organizer.
running example.
figure depicts a snapshot of the organizer a web application for managing notes contacts tasks and appointments which we use as a running example to show how input data event paths and assertions can be leveraged from the existing test cases to generate e ective test cases.
suppose we have a small test suite that veri es the application s functionality for adding a new note and adding a new contact .
due to space constraints we only show the testaddnote test case in figure .
the test case contains valuable information regarding how to log onto the organizer lines what data to insert lines where to click lines and what to assert lines .
we believe this information can be extracted and leveraged in automated test generation.
for example the paths i.e.
sequence of actions corresponding to these covered functionalities can be used to create an abstract model of the application shown in thick solid lines in figure .
by feeding this model that contains the event sequences and input data leveraged from the test case to a crawler we can explore alternative paths for testing shown as thin lines in figure alternative paths for deleting updating a note contact that result in newly detected states i.e.
s10 and s11 are highlighted as dashed lines.
further the assertions in the test case can be used as guidelines for generating new assertions on the newly de68s1s2notess5logoff s6contactss4dayataglanceoklogofflogoffcontactss8dayataglancenoteslogoffoks11dayataglancedeleteupdatelogoffcontactss10dayataglancedeleteupdatenoteslogoffcontactsindexlogons9createaccountdayataglanceedits3newnotecontactsdayataglancesavenoteslogoffcontactsdayataglanceeditnoteslogoffs7newcontactdayataglancesavenoteslogoffcontactscreateaccountfigure partial view of the running example application s stateow graph.
tected states along the alternative paths.
these original assertions can be seen as parallel lines inside the nodes on the graph of figure .
for instance line of figure veri es the existence of the text note has been created for an element span with id maincontent which can be assigned to the dom state s4 in figure .
by exploring alternative paths around existing paths and learning assertions from existing assertions new test cases can be generated.
for example the events corresponding to stateshindex s1 s2 s10 s4 s 5ican be turned into a new test method testupdatenote which on state s4 veri es the existence of a span element with id maincontent .
further patterns found in existing assertions can guide us to generate similar assertions for newly detected states e.g.
s9 s10 s11 that have no assertions.
.
approach figure depicts an overview of our approach.
at a high level given the url of a web application and its humanwritten test suite our approach mines the existing test suite to infer a model of the covered dom states and event based transitions including input values and assertions blocks and .
using the inferred model as input it explores alternative paths leading to new dom states thus expanding the model further blocks and .
next it regenerates assertions for the new states based on the patterns found in the assertions of the existing test suite block and nally generates a new test suite from the extended model which is a superset of the original human written test suite block .
we discuss each of these steps in more details in the following subsections.
.
mining human written test cases to infer an initial model in the rst step we instrument and execute the human written test suite tto mine an intermediate dataset of test operations.
using this dataset we run the test operations to infer a stateow graph by analyzing dom changes in the browser after the execution of each test operation.
instrumenting and executing the test suite.
we instrument the test suite block figure to collect information about dom interactions such as elements accessed in actions e.g.
clicks and assertions as well as the structure of the dom states covered.
definition manual test path .
a manual test path is the sequence of event based actions performed while executing a human written test case t2t.
test operations datasethuman writtentest suite instrument and execute test suite execute test operationsbrowser explore alternative pathsstate flow graph analyze domupdate generate test suitegenerated test suite regenerate assertionsaddassertionsfigure processing view of our approach.
definition manual test state .
a manual test state is a dom state located on a manual test path.
the instrumentation hooks into any code that interacts with the dom in any part of the test case such as test setup helper methods and assertions.
note that this instrumentation does not a ect the functionality of the test cases more details in section .
by executing the instrumented test suite we store all observed manual test paths as an intermediate dataset of test operations definition test operation .
a test operation is a triple action target input where action speci es an event based action e.g.
a click or an assertion e.g.
verifying a text target pertains to the dom element to perform the action on and input speci es input values e.g.
data for lling a form .
the sequence of these test operations forms a dataset that is used to infer the initial model.
for a test operation with an assertion as its action we refer to the target dom element as a checked element de ned as follows definition checked element .
a checked element ce2viis an element in the dom tree in state vi whose existence value or attributes are checked in an assertion of a test caset2t.
for example in line of the test case in figure the text value of the element with id maincontent is asserted and thus that element is a checked element.
part of the dom structure at this state is shown in figure which depicts the checked element span id maincontent .
for each checked element we record the element location strategy used e.g.
xpath id tagname linktext or cssselector as well as the access values and innerhtml text.
69algorithm state flow graph inference input a web application url url a dom based test suite ts crawling constraints cc output a stateow graph sfg procedure infersfg url ts cc begin tsinst instrument ts execute ts inst top readtestoperationdataset sfg init ?
browser goto url dom browser getdom sfg init.addinitialstate dom fortop2top do c getclickables top forc2cdo assertion getassertion top dom browser getdom robot fireevent c newdom browser getdom ifdom haschanged new dom then sfg init.update c new dom assertion browser goto url sfg ext sfg init explorealterntivepaths sfg ext cc return sfg ext procedure explorealterntivepaths sfg cc begin while constraintsatisfied cc do s getnexttoexplorestate sfg c getcandidateclickables s forc2cdo browser goto sfg getpath s dom browser getdom robot fireevent c newdom browser getdom ifdom haschanged new dom then sfg update c new dom explorealterntivepaths sfg cc this information is later used in the assertion generation process in section .
.
constructing the initial model.
we model a web application as a state flow graph sfg that captures the dynamic dom states as nodes and the event driven transitions between them as edges.
definition state flow graph .
a stateow graph sfg for a web application wis a labeled directed graph denoted by a tuple r v e l where .ris the root node called index representing the initial dom state after whas been fully loaded into the browser.
.vis a set of vertices representing the states.
each v2v represents an abstract dom state ds ofw with a labelling function v !
a that assigns a label fromato each vertex in v whereais a nite set of dom based assertions in a test suite.
.eis a set of directed edges between vertices.
each v1 v2 e represents a clickable cconnecting two states if and only if state v2is reached by executing c in statev1.
.lis a labelling function that assigns a label from a set of event types and dom element properties to each edge.
.sfg can have multi edges and be cyclic.
an example of such a partial sfg is shown in figure .
the abstract dom state is an abstracted version of the dom tree of a web application displayed on the web browser at runtime.
this abstraction can be conducted byusing a dom string edit distance or by disregarding speci c aspects of a dom tree such as irrelevant attributes time stamps or styling issues .
the state abstraction plays an important role in reducing the size of sfg since many subtle dom di erences do not represent a proper state change e.g.
when a row is added to a table.
algorithm shows how the initial sfg is inferred from the manual test paths.
first the initial index state is added as a node to an empty sfg algorithm lines .
next for each test operation in the mined dataset top it nds dom elements using the locator information and applies the corresponding actions.
if an action is a dom based assertion the assertion is added to the set of assertions of the corresponding dom state node algorithm lines .
the state comparison to determine a new state line is carried out via a state abstraction function more explanation in section .
.
exploring alternative paths at this stage we have a stateow graph that represents the covered states and paths from the human written test suite.
in order to further explore the web application to nd alternative paths and new states we seed the graph to an automated crawler block figure .
the exploration strategy can be conducted in various ways remaining close to the manual test paths diverging from the manual test paths or randomly exploring.
however in this work we have opted for the rst option namely staying close to the manual test paths.
the reason is to maximize the potential for reuse of and learning from existing assertions.
our insight is that if we diverge too much from the manual test paths and states the humanwritten assertions will also be too disparate and thus less useful.
to nd alternative paths events are automatically generated on dom elements and if as a result the dom is mutated the new state and the corresponding event transition are added to the sfg.
note that the state comparison to determine a new state line is carried out via the same state abstraction function used before line .
the procedure explorealternativepaths algorithm lines recursively explores the application until a pre de ned constraint e.g.
maximum time or number of states is reached.
the algorithm is guided by the manual test states while exploring alternative paths line getnextoexplorestate decides which state should be expanded next.
it gives the highest priority to the manual test states and when all manualtest states are fully expanded the next immediate states found are explored further.
more speci cally it randomly selects a manual test state that contains unexercised candidate clickables and navigates the application further through that state.
the getcandidateclickable method line returns a set of candidate clickables that can be applied on the selected state.
this process is repeated until all manualtest states are fully expanded.
for example consider the manual test sates shown in grey circles in figure .
the method starts by randomly selecting a state e.g.
s2 navigating the application to reach to that state from the index state and ring an event on s2 resulting in an new state s10.
.
regenerating assertions the next step is to generate assertions for the new dom states in the extended sfg block figure .
in this work we propose to leverage existing assertions to regenerate new ones.
by analyzing human written assertions we can infer information regarding portions of the page that are con70algorithm assertion regeneration input an extended stateow graph sfg r v e l procedure regenerateassertions sfg begin learn from dom elements in the manual test states dataset makedataset sfg .getmanualteststates train dataset forsi2vdo force2si.getcheckedelements do assert ce getassertion cer ce getcheckedelementregion si.addregfullassertion cer forsj2v sj6 sido dom sj getdom generate exact element assertion for sj ifelementfullmatched ce dom then sj.reuseassertion ce assert else if elementtagattmatched ce dom then sj.addelemtagattassertion ce generate exact region assertion for sj ifregionfullmatched cer dom then sj.addregfullassertion cer else if regiontagattmatched cer dom then sj.addregtagattassertion cer else if regiontagmatched cer dom then sj.addregtagassertion cer generate similar region assertions for si forbe2si.getblockelements do ifpredict be then si.addregtagattassertion be getregion sidered important for testing for example a banner section or decoration parts of a page might not be as important as an inner content that changes according to a main functionality patterns in the page that might be part of a template.
therefore extracting patterns from existing assertions may help us in generating new but similar assertions.
we formally de ne a dom based assertion as a function a s c !f true falseg wheresis a dom state and cis a dom condition to be checked.
it returns true ifs matches satis es the condition c denoted by sj c and false otherwise.
we say that an assertion asubsumes implies assertion b denoted by a b ifa!true then b!true.
this means that bcan be obtained from aby weakeninga s condition.
in this case ais more speci c constrained than b. for instance an assertion verifying the existence of a checked element span id maincontent can be implied by an assertion which veri es both the existence of that element and its attributes textual values.
algorithm shows our assertion regeneration procedure.
we consider each manual test state si de nition in the sfg and try to reuse existing associated assertions in si or generate new ones based on them for another state sj.
we extend the set of dom based assertions in three forms reusing the same assertions from manual test states for states without such assertions regenerating assertions with the exact assertion pattern structure as the original assertions but adapted for another state and learning structures from the original assertions to generate similar assertions for other states.
.
.
assertion reuse as an example for the assertion reuse consider figure and the manual test path with the sequence of states hindex s1 s s3 s4 s 5ifor adding a note.
assertions in figure line and are associated to states s1 ands4 re table summary of the assertion reuse regeneration conditions for an element ejon a dom state sj given a checked element eion statesi.
condition description elementfullmatched tag ei tag ej att e i att e j txt e i txt e j elementtagattmatched tag ei tag ej att ei att e j regionfullmatched tag r ei si tag r ej sj att r ei si att r ej sj txt r ei si txt r ej sj regiontagattmatched tag r ei si tag r ej sj att r ei si att r ej sj regiontagmatched tag r ei si tag r ej sj spectively.
suppose that we explore an alternative path for deleting a note with the sequence hindex s1 s2 s s4 s5i which was not originally considered by the developer.
since the two test paths share a common path from index tos1 the assertion on s1 can be reused for the new test case note deletion as well.
this is a simple form of assertion reuse on new test paths.
.
.
assertion regeneration we regenerate two types of precondition assertions namely exact element based assertions and exact region based assertions .
by exact we mean repetition of the same structure of an original assertion on a checked element.
the rationale behind our technique is to use the location and properties of checked elements and their close by neighbourhood in the dom tree to regenerate assertions which focus on the exact repeated structures and patterns in other dom states.
this approach is based on our intuition that checking the close by neighbour of checked elements is just as important.
exact element assertion generation.
we de ne assertions of the form a s j c e j with a condition c ej for elementejon statesj.
given an existing checked element de nition eion a dom state si we consider conditions as follows .elementfullmatched if a dom state sjcontains an element with exact tag attributes and text value as ei then reuse assertion on eifor checking ejonsj.
.elementtagattmatched if a dom state sjcontains an element ejwith exact tag and attributes but different text value as ei then generate assertion on ej for checking its tag and attributes.
table summarizes these conditions.
an example of a generated assertion is asserttrue iselementpresent by.i d maincontent which checks the existence of a checked element with id maincontent .
such an assertion can be evaluated in any state in the sfg that contains that dom element and thus meets the precondition .
note that we could also propose assertions in case of mere tag matches however such assertions are not generally considered useful as they are too generic.
exact region assertion generation.
we de ne the term checked element region to refer to a close by area around a checked element definition checked element region .
for a checked element eon states a checked element region r e s is a functionr e s !fe p e ch e g wherep e and ch e are the parent node and children nodes of erespectively.
for example for the element e span id maincontent figure which is in fact a checked 71element in line of figure at state s4 in figure we haver e s4 fe p e ch e g wherep e td class cssmain valign top andch e f img src img head notes.gif p input id ok src img ok0.gif g. we de ne assertions of the form a s j c r e j sj with a condition c r e j sj for the regionrof an element ejon statesj.
given an existing checked element eion a dom statesi we consider conditions as follows .regionfullmatched if a dom state sjcontains an elementejwith exact tag attributes and text values ofr e j sj asr e i si then generate assertion onr e j sj for checking its tag attributes and text values.
.regiontagattmatched if a dom state sjcontains an element ejwith exact tag and attributes values ofr e j sj asr e i si then generate assertion on r e j sj for checking its tag and attributes values.
.regiontagmatched if a dom state sjcontains an elementejwith exact tag value of r e j sj asr e i si then generate assertion onr e j sj for checking its tag value.
note that the assertion conditions are relaxed one after another.
in other words on a dom state s ifsj regionfullmatched then sj regiontagattmatched and ifsj regiontagattmatched then we have sj regiontagmatched .
consequently it su ces to use the most constrained assertion.
we use this property for reducing the number of generated assertions in subsubsection .
.
.
table summarizes these conditions.
assertions that we generate for a checked element region are targeted around a checked element.
for instance to check if a dom state contains a checked element region with its tag attributes and text values an assertion will be generated in the form of asserttrue iselementregionfullpresent parentelement element childrenelements where parentelement element and childrenelements are objects re ecting information about that region on the dom.
for each checked element ceonsi we also generate a regionfull type of assertion for checking its region i.e.
verifying regionfullmatched condition on si algorithm line .
lines perform exact element assertion generation.
the original assertion can be reused in case of elementfullmatched line .
lines apply exact region assertion generation based on the observed matching.
notice the hierarchical selection which guarantees generation of more speci c assertions.
.
.
learning assertions for similar regions the described exact element region assertion regeneration techniques only consider the exact repetition of a checked element region.
however there might be many other dom elements that are similar to the checked elements but not exactly the same.
for instance consider figure line in which a span id maincontent element was checked in an assertion.
if in another state a div id centrediv element exists which is similar to the span element in certain aspects such as content and position on the page we could generate a dom based assertion for the div element in the form of asserttrue i selementpresent by.id centrediv .
we view the problem of generating similar assertions as a classi cation problem which decides whether a block level dom element is important to be checked by an assertion or not.
to this end we apply machine learningto train a classi er based on the features of the checked elements in existing assertions.
more speci cally given a training dataset dofndom elements in the form d f xi yi jxi2rp yi2f 1ggn i where each xiis apdimensional real vector representing the features of a dom elementei andyiindicates whether eiis a checked element or not the classi cation function f xj!yi maps a feature vector xjto its class label yj.
to do so we use support vector machine svm to nd the maxmargin hyperplane that divides the elements with yi from those with yi .
in the rest of this subsection we describe our used features how to label the feature vectors and how to generate similar region dom based assertions.
dom element features.
we present a set of features for a dom element to be used in our classi cation task.
a feature extraction function e!xmaps an element eto its feature set x. many of these features are based on and adapted from the work in which performs page segmentation ranking for adaptation purpose.
the work presented a number of spatial and content features that capture the importance of a webpage segment based on a comprehensive user study.
although they targeted a di erent problem than ours we gained insight from their empirical work and use that to reason about the importance of a page segment for testing purposes.
our proposed dom features are presented in table .
we normalize feature values between as explained in table to be used in the learning phase.
for example consider the element e span in figure then e .
.
.
.
.
.
corresponding to features blockcenterx blockcentery blockwidth blockheight textimportance innerhtmllength linknum and childrennum respectively.
labelling the feature vectors.
for the training phase we need a dataset of feature vectors for dom elements annotated with important to be checked in assertion and not important for testing labels.
after generating a feature vector for each checked dom element we label it by .
for some elements with label we consider those with most frequent features over all the manual test states.
unlike previous work that focuses on dom invariants our insight is that dom subtrees that are invariant across manual test states are less important to be checked in assertions.
in fact most modern web applications execute a signi cant amount of client side code in the browser to mutate the dom at runtime hence dom elements that remain unchanged across application execution are more likely to be related to xed server side html templates.
consequently such elements are less likely to contain functionality errors.
thus for our feature vectors we consider all block elements such as div span table on the manualtest states and rank them in a decreasing order based on their occurrences.
in order to have a balanced dataset of items belonging to f 1g we select the k top ranked i.e.
kmost frequent elements with label were kequals the number of label samples.
predicting new dom elements.
once the svm is trained on the dataset it is used to predict whether a given dom element should be checked in an assertion algorithm lines .
if the condition f e!x holds we generate a regiontagatt type assertion i.e.
checking tag and attributes of a region .
we do not consider a regionfull i.e.
checking tag attributes and text of a region assertion type in this case because we are dealing with a similar detected region not an exact one.
also we do not generate a regiontag assertion type because a 72table dom element features used to train a classi er.
feature name de nition rationale elementcenterx elementcenterythe x y coordinates of the centre of a dom element.
blockcenterx and blockcentery are normalized by dividing by pagewidth and pageheight i.e.
the width and height of the whole page respectively.web designers typically put the most important information main content in the centre of the page the navigation bar on the header or on the left side and the copyright on the footer .
thus if the x y coordinate of the centre of a dom block is close to the x y coordinate of the web page centre that block is more likely to be part of the main content.
elementwidth elementheightthese are the width and height of the dom element which are also normalized by dividing by pagewidth and pageheight respectively.the width and height of an element can be an indication for an important segment.
intuitively large blocks typically contain much irrelevant noisy content .
textimportance this binary value feature indicates whether the block element contains any visually important text.text in bold italic style or header elements such as h1 h2 ... h5 to highlight and emphasize textual content usually imply importance in that region.
innerhtmllength the innerhtmllength is the length of all html code string without whitespace in the element block.
we normalize this value by dividing it by innerhtmllength of the whole page.the normalized feature value can indicate the block content size.
intuitively blocks with many sub blocks and elements are considered to be less important than those with fewer but more speci c content .
linknum the linknum is the number of anchor hyperlink elements inside the dom element and is normalized by the link number of the whole page.if a dom region contains clickables it is likely part of a navigational structure menu and not part of the main content .
childrennum the childrennum is the number of child nodes under a dom node.
we normalize this value by dividing it by a constant number in our implementation and setting the normalized value to if it exceeds .we have observed in many dom based test cases that checked elements do not have a large number of children nodes.
therefore this feature can be used to discourage elements with many children to be selected for a region assertion to enhance test readability.
higher priority should be given to the similar region based assertions.
.
.
assertion minimization the proposed assertion regeneration technique can generate many dom based assertions per state which in turn can make the generated test method hard to comprehend and maintain.
therefore we avoid generating redundant assertions and prioritize assertions based on their constraints and e ectiveness.
avoiding redundant assertions.
a new reused generated assertion for a state algorithm lines and might already be subsumed by or may subsume other assertions in that state.
for example an exact element assertion which veri es the existence of a checked element span id maincontent can be subsumed by an exact region assertion which has the same span element in either its checked element parent or its children nodes.
assertions that are subsumed by other assertions are redundant and safely eliminated to reduce the overhead in testing time and increase the readability and maintainability of test cases.
for a given state swith an existing assertion b a new assertion agenerated for sis treated as follows discarda ifb a replacebwitha ifa b b62original assertions addatos otherwise prioritizing assertions.
we prioritize the generated assertions such that given a maximum number of assertions to produce per state the more e ective ones are ranked higher and chosen.
we prioritize assertions in each state in the following order the highest priority is given to the original human written assertions.
next are the reused the regionfull the regiontagatt the elementtagatt and the regionatt assertions.
this ordering gives higher priorities to more speci c constrained assertions rst.
.
test suite generation in the nal step we generate a test suite from the extended stateow graph.
each path from the index node to a sink node i.e.
node without outgoing edges in the sfg is transformed into a unit test.
loops are included once.
each test case captures the sequence of events as well as any assertions for the target states.
to make the test case more readable for the developers information such as tag nameand attributes about related dom elements is generated as code comments.
after generating the extended test suite we make sure that the reused regenerated assertions are stable i.e.
do not falsely fail when running the test suite on an unmodied version of the web application.
some of these assertions are not only dom related but also depend on the speci c path through which the dom state is reached.
our technique automatically identi es and lters these false positive cases from the generated test suite.
this is done through executing the generated test suite and eliminating failing assertions form the test cases iteratively until all tests pass successfully.
.
implementation the approach is implemented in a tool called testilizer which is publicly available .
the state exploration component is built on top of crawljax .testilizer requires as input the source code of the human written test suite and the url of the web application.
testilizer currently supports selenium tests however our approach can be easily applied to other dom based tests as well.
to instrument the test cases we use javaparser to get a abstract syntax tree.
we instrument all dom related method calls and calls with arguments that have dom element locaters.
we also log the dom state after every event in the tests capable of changing the dom.
for the state abstraction function as de ned in de nition we generate an abstract dom state by ignoring recurring structures patterns such as table rows and list items textual content such as ignoring the text node note has been created in the partial dom shown in figure and contents in the script tags.
for the classi cation step we use libsvm which is a popular library for support vector machines.
.
empirical evaluation to assess the e cacy of our proposed technique we have conducted a controlled experiment to address the following research questions rq1 how much of the information input data event sequences and assertions in the original human written test suite is leveraged by testilizer?
rq2 how successful is testilizer in regenerating e ective assertions?
73table experimental objects.
name sloc test assertions methods claroline e learning php 295k .
.
js 36k photogallery php .6k .
js .5k wolfcms php 35k .
.
js .3k enterprisestore java 3k .
.
js 57k rq3 does testilizer improve coverage?
our experimental data along with the implementation of testilizer are available for download .
.
experimental objects we selected four open source web applications that make extensive use of client side javascript fall under di erent application domains and have selenium test cases.
the experimental objects and their properties are shown in table .claroline is a collaborative e learning environment which allows instructors to create and administer courses.
phormer is a photo gallery equipped with upload comment rate and slideshow functionalities.
wolfcms is a content management system.
enterprisestore is an enterprise asset management web application.
.
experimental setup our experiments are performed on mac os x running on a .3ghz intel core i7 cpu with gb memory and firefox .
.
.
.
independent variables we compare the original human written test suites with the test suites generated by testilizer.
test suite generation method.
we evaluate di erent test suite generation methods for each application as presented in table .
we compare testilizer exnd ar with three baselines orig original human written test suite exnd rnd test suite generated by traversing the extended sfg equipped with random assertion generation and rand rnd random exploration and random assertion generation.
in random assertion generation for each state we generate element region assertions by randomly selecting from a pool of dom based assertions.
these random assertions are based on the existence of an element region in a dom state.
such assertions are expected to pass as long as the application is not modi ed.
however due to our state abstraction this can result in unstable assertions which are also automatically eliminated following the approach explained in subsection .
.
we further evaluate various instantiations of our assertion generation in exnd ar i.e.
using only a original assertions b reused assertions section .
.
c exact generated section .
.
d similar region generated section .
.
and e a combination of all these types.
exploration constraints.
we con ne the exploration time to ve minutes in all the experiments which should be acceptable in most testing environments.
suppose in the exnd approach testilizer spends time tto generating the initial sfg for an application.
to make a fair comparison we add this time tto the ve minutes for the rand exploration approach.
we set no limits on the crawling depth nor the maximum number of states to be discovered while looking for alternative paths.
note that for both exnd andtable test suite generation methods evaluated.
test suite action sequence assertion generation generation method generation method method orig manual manual testilizer exnd ar traversing paths in the extended sfg generated from the original testsassertion regeneration exnd rnd traversing paths in the extended sfg generated from the original testsrandom rand rnd traversing paths in the sfg generated by random crawlingrandom rand crawling after a clickable element on a state was exercised the crawler resets to the index page and continues crawling from another chosen state.
maximum number of generated assertions.
we constrain the maximum number of generated assertions for each state to ve.
to have a fair comparison for the exnd rnd and rand rnd methods we perform the same assertion prioritization used in testilizer and select the top ranked.
learning parameters .
we set the svm s kernel function to the gaussian rbf and use fold cross validation for tuning the model and feature selection.
.
.
dependent variables original coverage.
to assess how much of the information including input data event sequences and assertions of the original test suite is leveraged rq1 we measure the state and transition coverage of the initial sfg i.e.
sfg mined from the original test cases .
we also measure how much of the unique assertions and unique input data in the original test cases has been utilized.
fault detection rate.
to answer rq2 assertions e ectiveness we evaluate the dom based fault detection capability oftestilizer through automated rst order mutation analysis.
the test suites are evaluated based on the number of detected mutants by test assertions.
we apply the dom jquery and xhr mutation operators at the javascript code level as described in which are based on a study of common mistakes made by web developers.
examples include changing the id tag name used in getelementbyid and getelementbytagname methods changing the attribute name value in setattribute getattribute andremoveattribute methods removing the sign that returns a jquery object changing the name of the property class element in the addclass removeclass removeattr remove attr and cssmethods in jquery swapping innerhtml and innertext properties and modifying the xhr type get post .
on average we generate mutant versions for each application.
code coverage.
code coverage has been commonly used as an indicator of the quality of a test suite by identifying under tested parts while it does not directly imply the effectiveness of a test suite .
although testilizer does not target code coverage maximization to address rq3 we compare the javascript code coverage of the di erent test suites using jscover .
.
results original sfg coverage rq1 .
table shows the average results of our experiments.
as expected the number of states transitions and generated test cases are higher in testilizer.
the random exploration rand on average generates fewer states and transitions but more test cases 74table results showing statistics of the test models and original test suite information usage average over experimental objects.
test suite states transitions test cases or ig state coverage or ig transition coverage or ig input data usage or ig assertion usage js code coverages orig exnd rand compared to the original test suite.
this is mainly due to the fact that in the sfg generated by rand there are more paths from index to the sink nodes than in the sfg mined from the original test suite.
regarding the usage of original test suite information rq1 as expected testilizer which leverages the event sequences and inputs of the original test suite has almost full state and transition coverage of the initial model.
the few cases missed are due to the traversal algorithm we used which has limitations on dealing with cycles in the graph that do not end with a sink node and thus are not generated.
note that we can select the missing cases from the original manual written test suite and add them to the generated test suite.
by analyzing the generated test suites we found that on average testilizer reused input values in addition to the login data from the average of original inputs.
the rand exploration approach covered about of the states and transitions without any usage of input data apart from the login data which was provided to rand manually .
exnd original exnd reused exnd exact generated exnd similar generated exnd combined tesdlizer exnd rnd rand rnd avg asse ons per state before filtering aker filtering figure average number of assertions per state before and after ltering unstable assertions.
figure presents the average number of assertions per state before and after ltering the unstable ones.
the difference between the number of actual generated assertions and the stable ones reveals that our generated assertions combined similar exact generated are more stable than the random approach.
the reduction percentage is and for the original reused exact generated similar generated combined testilizer exnd rnd and rand rnd respectively.a major source of this instability is the selection of dynamic dom elements in the generated assertions.
for instance rnd random assertion generation selects many dom elements with dynamic time based attributes.
also the more restricted an assertion is the less likely it is to remain stable in di erent paths.
this is the case for some of the reused assertions that replicate the original assertions and exact generated ones specially fullregionmatchs type.
on the other hand learned assertions are less strict e.g.
atttagregionmatchs and are thus more stable.
overall the test suite generated by testilizer on average consists of original assertions reused assertions exact generated assertions and of similar learned assertions.
orig exnd original exnd reused exnd exact generated exnd similar generated exnd combined teselizer exnd rnd rand rnd fault deteceon rate figure comparison of average fault detection rate using di erent test suite generation methods.
fault detection rq2 .
figure depicts a comparison of fault detection rates for the di erent methods.
figure shows that exact and similar generated assertions are more e ective than original and reused ones.
the e ectiveness of each assertion generation technique solely is not more than the random approach.
this is mainly due to the fact that the number of random assertions per state is more than the assertions reused generated by testilizer since we always select random assertions at each state from a pool of assertions but not always nd exact similar match in a state.
more importantly the results show that testilizer outperforms fault detection capability of the original test suite by increase and the random methods by increase .
this supports our insight that leveraging input values and assertions from human written test suites can be helpful in generating more e ective test cases.
code coverage rq3 .
although code coverage improvement is not the main goal of testilizer in this work the generated test suite has a slightly higher code coverage.
as shown in table there is a improvement increase over the original test suite and improvement increase over the rand test suite.
note that the original test suites were already equipped with proper input data but not many execution paths thus the slight increase .
on the other hand the random exploration considered more paths in a blind search but without proper input data.
.
discussion test case dependencies.
an assumption made in testilizer is that the original test suite does not have any test case dependencies.
generally test cases should be executable without any special order or dependency on previous tests.
however while conducting our evaluation we came across multiple test suites that violated this principle.
for such cases although testilizer can generate test cases failures can occur due to these dependencies.
75e ectiveness.
the e ectiveness of the generated test suite depends on multiple factors.
first the size and the quality of the original test suite is very important if the original test suite does not contain paths with e ective assertions it is not possible to generate an e ective extended test suite.
in the future we plan to use other adequacy metrics such as dom coverage to measure the quality of a given test suite.
second the learning based approach can be tuned in various ways e.g.
selecting other features changing the svm parameters and choosing sample dataset size to obtain better results.
third the size of the dom subtree region to be checked can be increased to detect changes more e ectively however it might come at the cost of making the test suite more brittle.
e ciency.
the larger a test suite the more time it takes to test an application.
since in many testing environments time is limited not all possible paths of events should be generated in the extended test suite.
the challenge is nding a balance between e ectiveness and e ciency of the test cases.
the current graph traversal method in testilizer may produce test cases that share common paths which do not contribute much to fault detection or code coverage.
an optimization could be realized by guiding the test generation algorithm towards states that have more constrained dombased assertions.
threats to validity.
although selenium is widely used in industry for testing commercial web applications unfortunately very few open source web applications are publicly available that have working selenium test suites.
therefore we were able to include a limited number of applications in our study.
a threat to the external validity of our experiment is with regard to the generalization of the results to other web applications.
to mitigate this threat however we selected our experimental objects from di erent domains with variations in functionality and structure.
with respect to reproducibility of our results testilizer the test suites and the experimental objects are publicly available making the experiment reproducible.
.
related work elbaum et al.
leverage user sessions for web application test generation.
based on this work sprenkle et al.
propose a tool to generate additional test cases based on the captured user session data.
mcallister et al.
leverage user interactions for web testing.
their method relies on prerecorded traces of user interactions and requires instrumenting one speci c web application framework.
none of these techniques considers leveraging knowledge from existing test cases as testilizer does.
xie and notkin infer a model of the application under test by executing the existing test cases.
dallmeier et al.
mine a speci cation of desktop systems by executing the test cases.
schur et al.
infer behaviour models from enterprise web applications via crawling.
their tool generates test cases simulating possible user inputs.
similarly xu et al.
mine executable speci cations of web applications from selenium test cases to create an abstraction of the system.
yuan and memon propose an approach to iteratively rerun automatically generated test cases for generating alternating test cases.
this is inline with feedbackdirected testing which leverages dynamic data produced by executing the program using previously generated test cases.
for instance artemis is a feedback directed tool for automated testing of javascript applications that uses generic oracles such as html validation.
our previous work feedex applies a feedback directed explorationtechnique to guide the exploration at runtime towards more coverage and higher navigational and structural diversity.
these approaches however do not use information in existing test cases and they do not address the problem of test oracle generation.
yoo and harman propose a search based approach to reuse and regenerate existing test data for primitive data types.
they show that the knowledge of existing test data can help to improve the quality of new generated test data.
alshahwan and harman generate new sequences of http requests through a def use analysis of server side code.
pezze et al.
present a technique to generate integration test cases from existing unit test cases.
mirzaaghaei et al.
use test adaptation patterns in existing test cases to support test suite evolution.
this work is also related to test suite augmentation techniques used in regression testing.
in test suite augmentation the goal is to generate new test cases for the changed parts of the application.
more related to our work is which aggregates tests generated by di erent approaches using a uni ed test case language.
they propose a test advice framework that extracts information in the existing tests to help improve other tests or test generation techniques.
a generic approach used often as a test oracle is checking for thrown exceptions and application crashes .
this is however not very helpful for web applications as they do not crash easily and the browser continues the execution even after exceptions.
current web testing techniques simplify the test oracle problem in the generated test cases by using soft oracles such as generic user de ned oracles and html validation .
our work is di erent from these approaches in that we reuse knowledge in existing human written test cases in the context of web application testing reuse input values and event sequences in test cases to explore alternative paths and news states of web application and reuse oracles of the test cases for regenerating assertions to improve the fault nding capability of the test suite.
.
conclusions and future work this work is motivated by the fact that a human written test suite is a valuable source of domain knowledge which can be used to tackle some of the challenges in automated web application test generation.
given a web application and its dom based such as selenium test suite our tool called testilizer utilizes the given test suite to generate effective test cases by exploring alternative paths of the application and regenerating assertions for new detected states.
our empirical results on four real world applications show that testilizer easily outperforms a random test generation technique provides substantial improvements in the fault detection rate compared with the original test suite while slightly increasing code coverage too.
for future work we plan to evaluate the e ectiveness of other state space exploring strategies e.g.
diversi cation of test paths and investigate correlations between the effectiveness of the original test suite and the generated test suite.
.