proving programs robust swarat chaudhuri rice university swarat rice.edusumit gulwani microsoft research sumitg microsoft.comroberto lublinerman pennsylvania state university rluble psu.edu sara navidpour pennsylvania state university ssn123 psu.edu abstract we present a program analysis for verifying quantitative robustness properties of programs stated generally as if the inputs of a program are perturbed by an arbitrary amount then its outputs change at most by k wherekcan depend on the size of the input but not its value.
robustness properties generalize the analytic notion of continuity e.g.
while the function exis continuous it is not robust.
our problem is to verify the robustness of a function pthat is coded as an imperative program and can use diverse data types and features such as branches and loops.
our approach to the problem soundly decomposes it into two subproblems a verifying that the smallest possible perturbations to the inputs of pdo not change the corresponding outputs signi cantly even if control now ows along a di erent control path and b verifying the robustness of the computation along each controlow path of p. to solve the former subproblem we build on an existing method for verifying that a program encodes a continuous function .
the latter is solved using a static analysis that bounds the magnitude of the slope of any function computed by a control ow path of p. the outcome is a sound program analysis for robustness that uses proof obligations which do not refer to changes and can often be fully automated using o the shelf smt solvers.
we identify three application domains for our analysis.
first our analysis can be used to guarantee the predictable execution of embedded control software whose inputs come from physical sources and can su er from error and uncertainty.
a guarantee of robustness ensures that the system does not react disproportionately to such uncertainty.
second our analysis is directly applicable to approximate computation and can be used to provide foundations for a recently proposed program approximation scheme called loop perforation .
a third application is in database privacy this research was supported by nsf career award robustness analysis of uncertain programs theory algorithms and tools .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
this paper is a minor revision of the paper of the same name published in esec fse september szeged hungary.
copyright acm ... .
.proofs of robustness of queries are essential to di erential privacy the most popular notion of privacy for statistical databases.
categories and subject descriptors f. .
semantics of programming languages program analysis .
f. .
logics and meanings of programs specifying and verifying and reasoning about programs mechanical veri cation g. .
general error analysis general terms theory veri cation keywords lipschitz continuity quantitative program analysis sensitivity robustness uncertainty perturbations program approximation.
.
introduction uncertainty in computation has long been a topic of interest to computer science.
depending on the context uncertainty in the operation of programs can be a curse or a blessing.
on one hand uncertain operating environments may cause system failures consider for example an aircraft controller that reacts unpredictably to noisy sensor data and causes a crash.
on the other hand randomized and approximate algorithms deliberately inject uncertainty into their data to trade o quality of results for better performance.
uncertainty of both forms is rife in a world where cyber physical systems are ubiquitous and applications suited to approximation and randomization are ascendant.
love or hate uncertainty you increasingly cannot ignore it.
robustness is a system property critical to reasoning about program behavior under uncertainty.
a program is robust in the sense of this paper if a perturbation to its inputs can only lead to proportional changes in its outputs.
this means that a robust avionic controller reacts predictably to noise in the measurements made by the plane s sensors.
also if a program pis robust then the output p x ofpon an inputxcan be approximated safely by p x0 wherex0is a value close to x asxandx0are close so must be p x andp x0 .
if uncertainty is our enemy a proof of robustness shows that our program is relatively safe from it if we want to introduce uncertainty in our computation for performance gains robustness ensures that it is safe to do so.dijk g graph src node 1foreach nodeving 2d ?
prev undef 3d wl set of all nodes in g 4while wl6 choose node w2wlsuch thatd is minimal remove wfrom wl foreach neighbor vofw z d g ifz d thend z prev w figure dijkstra s shortest path algorithm a system to formally verify the robustness of everyday programs would then seem to be of considerable practical importance.
a step to this end was taken by chaudhuri et al who presented a program analysis to verify that a program encodes a continuous function .
a function is continuous if in nitesimal or arbitrarily small changes to its inputs can only cause in nitesimal changes to its outputs.
this makes such a function robust in a sense.
such a formulation of robustness is particularly valuable in the setting of programs where violation of robustness is often due to discontinuities introduced by control constructs like branches and loops.
a provably continuous program is free from violations of this sort.
at the same time continuity is too weak a robustness property for many settings as a small but nonin nitesimal change to the inputs of a continuous function can create disproportionately large changes to its outputs.
for example while the function exis continuous there is no bound on the change in its output on a small nite change to its input x. in this paper we investigate a stronger quantitative formulation of robustness of programs that does not su er from this limitation.
we believe that this formulation based on the analytic notion of lipschitz continuity is a canonical notion of robustness for programs.
by this de nition a program is robust if a change of to its inputs for any results in a change of k to its outputs where kdoes not depend on the values of the input variables.
the multiplierk known as the robustness parameter quanti es the extent of this robustness.
for example consider the implementation dijk of dijkstra s shortest paths algorithm in fig.
here gis a graph with real valued edge weights and nedges and srcis the source node.
the output of the program is the table dof shortest path distances in g. we note that dijk is robust with a robustness parameter n from now on n robust if each edge weight in gchanges by then each output d changes at most by n .
but how do we verify the above robustness property from the text of programs like dijk which use features like branches loops and arrays?
one way is to rst prove that dijk computes shortest paths and then to establish that the costs of these paths change proportionally on changes to the edge weights of g. such a proof however would be highly specialized and impossible to automate.
our goal instead is to develop a proof system that reasons about robustness without having to prove full functional correctness is applicable to a wide range of algorithms and is mostly automated.
to see how we achieve this goal consider programs like dijk whose inputs and outputs are from dense domains.
keyto our analysis of robustness for such programs pis the following metatheorem pisk robust if rst pencodes a continuous function and second each control ow path ofpcomputes a function that is linear in the values but not the size of the input and the magnitude of the slope of this line is bounded by k. the rst property accounts for the possibility of di erent control ow on the perturbed and unperturbed input and can be veri ed using an existing analysis .
as for the latter property we o er a new static analysis for it.
the nal outcome is a program analysis that can verify the robustness of programs over continuous data types can be automated using o the shelf smt solvers we provide an implementation on top of the z3 solver and can verify the robustness of many everyday programs.
for example we establish the property for the program dijk by showing that the e ect of each loop iteration on the arraydcan be written as d c1 d c2 a c3 whereais the weight of some edge of g d andd are elements of d andc1 c2 c3are constants with jc1j and jc2j and each edge weight of the input graph gis used only once as an operand during an addition.
we identify three application domains for our analysis.
first our analysis can be used to guarantee the predictable execution of embedded control programs whose inputs come from physical sources and can therefore be noisy or uncertain.
second we investigate the application of our system in approximate computations that trade o accuracy of results for resource savings.
in particular we demonstrate that a robustness analysis can be used to provide foundations for a recently proposed program approximation heuristic called loop perforation .
third our analysis can be used in the synthesis of information release mechanisms that satisfy differential privacy perhaps the most popular de nition of privacy for statistical databases.
summary of contributions and organization now we summarize this paper s contributions we give a canonical quantitative de nition of robustness of programs sec.
.
we present a sound program analysis that can be used to verify the robustness of a given program sec.
.
sec.
.
we present a prototype implementation of our proof system built on top of the z3 smt solver sec.
.
we identify three application domains for our analysis.
sec.
.
robustness of programs now we formalize our notion of robustness of programs.
we begin by xing a language impof imperative arithmetic programs.
for simplicity we allow imponly two data types reals real and arrays of reals realarr .
other popular types such as records tuples and functional lists trees can be added without changing the analysis signi cantly.
our robustness analysis can be extended to programs with discrete typed inputs such as integers.
we intend to present this extension in a future work.
also we assume that reals in impare in nite precision rather than oating point and treat arithmetic and comparison operations on them as unit time oracles.
thus our programs are equivalent to blum shub smale turing machines .
while this idealized semantics rules out reasoning about oating point rounding errors we can use it to prove the absence of robustness bugsdue to awed logic arguably it is this semantics that forms the mental model of programmers as they design numerical algorithms .
we intend to pursue a oating point modeling of continuous data in future work.
as for perturbations they can change the value of a datum but not its type or size the latter being if the datum is a real andnif it is an array of length n. we assume for each type and sizen ametric1d n. an change to a value x of type and sizenis assumed to result in a value y of type and sizen such that d n x y .
in particular the type real is associated with the euclidean metric de ned as dreal x y jx yj we let an change to an array consist of changes to any number of its elements.
formally the metric over arrays of length nwhose elements are of type is thel1 norm darray of n a b max ifd a b g now we o er the syntax of arithmetic expressions e boolean expressions b and programs pinimp e xjcje1 e2je1 e2ja b e 0je 0jb1 b2j b p skipjx eja ejifbthenp1elsep2 jwhilebdop1jp1 p2 herexis a variable cis a constant ais an array variable ian integer variable or constant and the arithmetic and boolean operators are as usual.
we let each statement be annotated with a distinct label.
as for semantics let us only consider programs pthat terminate on all inputs .
the semantics of pis the standard denotational semantics for imperative programs except as mentioned earlier we assume unit time operations on reals .
formally let us associate with each variable xa set cloc x ofconcrete memory locations .
astate ofpis a map that assigns a value in val to each program variable x of type .
we denote the set of all states of pby p .
each state induces in the usual way an assignment of contents to each location y2cloc x for each variable x. we use the notation y to denote the content of location yat state .
the semantics of the program p and an expression eof type appearing in it are now de ned by two functions p !
p and p !val where val is the set of values of type .
intuitively is the value ofeat state and is the state at which p terminates after starting execution from .
in addition we assume de nitions of control ow paths sequences of labels and executions sequences of states of p. these de nitions are all standard and hence omitted.
robustness of programs.
our de nition of robustness of programs is based on the analytic notion of lipschitz continuity .
intuitively a program pisk robust if any additive change to the input of pcan only change the output ofpby k .
note that is arbitrary so that the output of ak robust program changes proportionally on anychange to the inputs and not just small ones.
as a program can have multiple inputs and outputs we de ne robustness with respect to an input variable xinand anoutput variable xout.
ifpis robust with respect to xinand 1recall that a metric over a setsis a function d s s!
r f1g such that for all x y z we have d x y withd x y i x y d x y d y x and d x y d y z d x z .xout a change to the initial value of any xin while keeping the remaining variables xed must only cause a proportional change to the nal value of xout.
variables other than xout can change arbitrarily.
also we allow robustness parameters that are not just constants but depend on the size of the input .
for example suppose the size of xinisn and an change to it changes the output by n .
thenpisn robust with respect to xin.
we model this by letting a robustness parameter kbe a function of type n!r rather than just a real.
finally our de nition allows a program to be robust only within a certain subset 0of the input space without assertions about the e ect of perturbations on states outside capturing the fact that many realistic programs are robust only within certain regions of their input space .
formally for a variable x say of type and a state let size x be the size of the value of xat .
now let 2r also let p such that x size x n. the state 0is an x perturbation of and is denoted bypert x ifd n x x and for all other variablesy we have y y .
the states and 0are x close written as x ifd m x x .
now we de ne definition robustness of programs .
consider a functionk n!rand a set of states .
the programpisk robust within 0with respect to the input xin and the output xoutif for all 0and 2r we have pert xin m x out wherem k size xin definition continuity of programs .
the programpis continuous within with respect to the input xinand the output xoutif for all 2r there exists a 2r such that for all pert xin xout ifpis continuous by the above then in nitesimal perturbations toxin that keep the state within the set can only cause in nitesimal changes to xout.
not all continuous programs are robust.
for example a program computing x2 given arbitrary x2r is continuous but non robust.
now we consider a few everyday programs that are robust or continuous by the above de nitions example sorting .
consider a correct implementationpof a sorting algorithm that takes in an array ain of reals and returns a sorted array aout.
the program is robust with respect to input ainand output aout within p for any if each element of ainis perturbed at most by then the maximum change to an element of the outputaoutis as well.
note that this observation is not at all obvious as we are speaking of arbitrary changes to ainhere and as even the minutest change to aincan alter the position of a given item in aoutarbitrarily.
example shortest paths msts .
let sp be a correct implementation of a shortest path algorithm e.g.
dijk fig.
.
we view the graph gon which sp operates as a perturbable array of reals such that g is the weight of the i th edge.
an change to gthus amounts to a maximumkruskal g graph 1foreach nodevingdoc fvg 2wl set of all edges in g cost t 3while wl6 choose edge v w 2wl such thatg v w is minimal remove v w from wl ifc c then add edge v w tot cost cost g v w c c c figure kruskal s algorithm change of to any edge weight of g while keeping the node and edge structure intact.
one output of sp is the array dof shortest path distances ing i.e.
d is the length of the shortest path from the source node src to the i th nodeuiofg.
a second output is the array whosei th element is a sequence of nodes forming a minimal weight path between src and ui.
let the distance between two elements of be if they are identical and1otherwise.
as it happens sp is n robust everywhere within p with respect to the output d if each edge weight in gchanges by an amount a shortest path weight can change at most by n .
however an change to gmay add or subtract elements from i.e.
perturb by the amount1.
therefore sp is not k robust with respect to the output for any k. similar arguments apply to a program mst computing minimum spanning trees in a graph g kruskal s algorithm fig.
.
suppose the program has two outputs a sequence t of edges forming a minimum spanning tree and the cost of this tree.
mst is n robust within mst if the output is cost but not robust if the output is t. .
verifying robustness in this section we present our program analysis for robustness.
the inputs of the analysis are a program p symbolic encodings of a set 0of p and a function k n!r an input variable xin and an output variable xout.
our goal is to soundly judge p k robust within 0with respect to xin andxout.
.
piecewise k robustness and k linearity consider rst the simple scenario where phas a single real valued variable x. note that each control ow path of pcomputes a di erentiable function over the inputs.
now suppose we can show that each control ow path of prepresents a robust computation in this case pis said to be piecewisek robust .
piecewise robustness does not entail robustness a perturbation to the initial value of xcan cause pto execute along a di erent control ow path leading to a completely di erent nal state.
however if piscontinuous as well as piecewise k robust then pisk robust as well e.g.
the function abs x jxj wherex2r is continuous as well as piecewise robust hence robust.
on the other hand the continuous function if x thenx2elsex is nonrobust because x2is not piecewise robust within x2r.
the above observation can be generalized to settings wherephas multiple variables of di erent types.
our analysis exploits it to decompose the problem of robustness analysis into two independent subproblems that of verifying continuity and piecewise k robustness of p. for any program pand any set of states 0ofp let i denote the set of states 0such that starting from p executes along its i th control ow path we assume a global order on control ow paths .
let us now de ne definition piecewise k robustness .
letpbe a program p a set of states ka function of type n!r andxin xout2var p .pispiecewisek robust within p with respect to input xinand output xout if for alli pisk robust within i with respect to xinand xout.
we establish piecewise robustness using the weaker property ofpiecewisek linearity which says that the function computed by each control ow path of pis a linear function and that the absolute value of its slope is bounded by k definition piecewise k linearity .
letpbe a program p a set of states ka function of type n!r andxin xout2var p .pisk linear within w.r.t.
input xinand output xoutif for each z2cloc xin y2cloc xout we have the relationship y x z2cloc xin cz y z1 a where is an expression whose free variables range over the sets x06 xincloc x0 andp zjcz yj k size xin .pis piecewisek linear within p with respect to input xinand output xoutif for alli pisk linear within i with respect to xinandxout.
it is not hard to see that theorem .ifpis piecewise k linear then pis piecewisek robust.
example dijkstra s algorithm .
consider once again the procedure dijk in fig.
.
while the dependence betweenganddis complex dijk is piecewise n robust ing andd.
to see why consider any control ow path of dijk and view it as a straight line program.
suppose the addition operation in line of dijk is executed mtimes in this program.
as we only remove elements from the worklist wl a speci c edge g is used at most once as an operand of this addition.
consequently we have m n wheren is the size of g. letm0be the number of times line assigns the result of this addition to an element of d. we havem0 m n. it is easy to see that this means that isn linear with respect to input gand output d. as the set of control ow paths in dijk is countable and each path is n linear with respect to gandd dijk is piecewise n robust within dijk with respect to gandd.
.
robustness now we apply the notion of piecewise robustness and piecewise linearity in the analysis of robustness.
theorem .letpbe a program p andxin andxoutbe variables of dense types.
pisk robust withininsertion sort a realarr 1fori 1to jaj 2z a j i whilej anda z a a j j 5a z figure insertion sort 0with respect to input xinand output xoutif and only if pis continuous within 0w.r.t.
input xinand output xout and pis piecewise k robust within 0with respect to inputxinand output xout.
by theorem the problem of robustness analysis can be decomposed soundly and completely into the problems of verifying continuity and piecewise robustness.
we establish these conditions independently.
the rst criterion is proved using a sound program analysis due to chaudhuri et al from now on we call this system cont .
to prove the second property we prove pto be piecewise k linear and use theorem .
however for reasons outlined later no existing sound abstraction that we know of is suited to precise and e cient analysis of piecewise linearity a new solution is needed.
piecewise linearity using arithmetic freedom it is sometimes possible to establish piecewise linearity using traditional data ow analysis.
let a program qbe free of arithmetic operations i.e.
if x eis an assignment in the program then the evaluation of edoes not require arithmetic.
in this case each control ow path in qencodes a linear function which means that qis piecewise linear.
generalizing let a program pbearithmetic free with respect to input xinand outputs xoutif all data ows from xintoxoutare free of arithmetic operations.
a program can be shown arithmetic free in this sense using standard slicing techniques.
we can use a program like qabove as an abstraction of p. application in the veri cation of piecewise robustness stems from the fact that theorem .if a program pis arithmetic free within p with respect to input xinand output xout thenpis piecewise linear within 0with respect to input xinand outputxout.
example sorting .
the seemingly trivial abstraction of arithmetic freedom can in fact be used to prove the robustness of several challenging array manipulating algorithms.
consider insertion sort where the array ais the input as well as the output.
a lightweight analysis can prove this algorithm arithmetic free at all input states with respect to the input aand output a. while arithmetic does occur in the program it only updates the indexi whose value does not depend on the original contents ofa.
other algorithms like mergesort and bubblesort can be proved arithmetic free in the same way.
separately we prove these algorithms continuous using cont which gives us a proof of robustness.
piecewise linearity with robustness matrices in most realistic programs however arithmetic freedom will not su ce and some form of quantitative reasoning will be skip skip i assign xi e rwhere 8j k rjk e xk ifj iand e xkis constant ifj iand e xkdepends on the xm s ifj k6 i otherwise weaken p0 r 8i j rij r0 ij p0 r0 sequence p1 r 1p2 r p1 p2 r r1 ite p1 r 1p2 r ifbthenp1elsep2 max r1 r2 while p0 whilebdop00p00 r00bound p0 m 8i j r00 ij 0 r00 ij p0 r00 m while p0 whilebdop00p00 r00bound p0 m 8i j r00 ij p0 r00 m figure system robmat for propagating robustness matrices necessary.
a natural rst question is can we use a traditional numerical abstract domain such as polyhedra for such reasoning?
the answer unfortunately seems to be no.
consider the program if x y thenz x yelsez x y our goal is to prove this program piecewise linear with respect to input xand output y. unfortunately the best invariant that we can establish at the end of the branch using the polyhedra domain is z x y z x y .
these constraints permit zto be a linear function of xwith slope equal to1 hence the best we can say is that the program is1 robust!
the key issue here is that we need a form ofdisjunctive reasoning to track quantities absolute values of slopes computed along di erent paths.
while there is a plethora of abstract domains for disjunctive reasoning about programs none of them so far as we know is suitable for this purpose.
now we present a simple static analysis that ful ls our needs.
here an abstract state known as a robustness matrix tracks for each pair of memory locations xandy a bound on the slope of the expression relating the current value of xto the initial value of y. this information is propagated through the program using an abstract interpretation.
for brevity we make a few simplifying assumptions in this presentation.
first we assume that all variables of p are real valued.
the analysis that we have actually implemented can handle arrays by abstracting each unbounded array using a nite number of abstract memory locations.
as this array abstraction is standard but adds signi cantly to the notation we omit its details.
also we only show how to derive piecewise linearity judgments holding over the entire space p .
a generalization to judgments conditioned by p is however easy to construct.
finally we view a program state not as a map but as a vector hr1 rni whereriis the value of the i th variable xi.
the denotational semantics of any program qis thus a function1x afrx a 1g 2y bfrx a ry b 1g 3if x y thenz 2x y frx a ry b rz x rz y rz a rz b 1g elsez 3y x frx a ry b rz x rz y rz a rz b 3g frx a ry b rz x rz y rz a rz b 3g figure piecewise robustness using robustness matrices rn!rn.
now we de ne a robustness matrix rforp to be ann nmatrix whose elements rijare non negative reals.
to understand the interpretation of this matrix we recall the classic de nition of a jacobian from vector calculus.
the jacobian of a function f rn!rnwith inputs xin xin n2rand outputs x1 xn2ris the matrix jf b x1 xin x1 xinn xn xin xn xinn1 ca iffis a di erentiable function then for each xiandxin j it isk robust with respect to input xjand output xi where kis any upper bound on j xi xin jj.
in our setting the expression relating the inputs and outputs of a single control ow path is di erentiable consequently we can verify the robustness of this expression by propagating a jacobian along it strictly entries in the actual matrix that we carry are constant upper bounds on the absolute values of the terms xi xin j .
it is possible to carry out this propagation using the chain rule of di erentiation.
of course due to branches a program pneed not be di erentiable.
this is where abstract interpretation comes handy we merge multiple jacobians propagated along di erent paths into a robustness matrixthat overestimates the robustness parameter of p. such a merge demands an abstract join operator t for robustness matricesrandr0 we de ne rtr0 to be the matrix msuch that for all i j we havemij max rij r0 ij note that with the above strategy we will infer robustness matrices even for discontinuous programs.
this is of course acceptable as the present analysis only veri es piecewise robustness continuity is judged separately by cont .
the goal of our analysis call it robmat is to syntactically derive facts of the form p0 r read as ris the robustness matrix for the subprogram p0.
the structural rules for the analysis are shown in fig.
.
here iis the identity matrix.
the assertion bound p0 m states that mis an upper bound on the number of iterations of the whileloopp0 likewise bound p0 m states that the symbolic or numeric constant mis a lower bound on the number of iterations for which p0executes.
these conditions can be established either via an auxiliary checker or by manual annotation.
we observe that the robustness matrix for p1 p2obtained by multiplying the matrices for p1andp2 this rule follows from the chain rule of calculus.
this rule is now generalized into the rule while for while loops.
as the loop may terminate after m0 m iterations we require the following extra condition for the rule to be sound r00 i r00 i 1p hall syntactic forms in impijhthe formqbelowi l whileb nondeterministically chosen u2u r u xin xout figure the language limp prepresents programs .
for alli m .
this property is ensured by the condition 8i j r00 ij 0 r00 ij .
note that in the course of a proof we can weaken anyrobustness matrix that does not satisfy this condition to one that does using the weaken rule.
on the other hand the while rule applies to the special case when all matrix elements are less than that is the matrix represents a contraction.
we have theorem .if the system robmat derives the judgment p r then for all i j pis piecewiserij linear within p with respect to the input xjand the output xi.
example .fig.
shows the result of applying a data ow analysis based on robmat to a simple program.
the annotations depict the robustness matrices rpropagated to the various program points we use the more readable notation ry zto refer to the matrix entry rijifyandzare respectively thei th andj th variables.
observe in particular how the robustness matrices from the two branches of the program are merged.
piecewise linearity with linear loops a problem with the robustness matrix abstraction is that it does not satisfactorily handle loops iterating over unbounded data structures.
for example let us try to use it to prove dijkstra s algorithm piecewise linear w.r.t.
inputgand output d. here each iteration makes multiple assignments to dand is consequently piecewise k linear fork .
as the main loop iterates ntimes the complete algorithm is then piecewise o 2n robust.
however by the reasoning in ex.
dijkstra s algorithm is piecewise n linear.
now we present an abstraction that can establish this and similar facts.
a key insight here is to treat the locations of the input variable xinasresources and to establish an assertion of the form each location of xinis used at most once during the execution of the loop.
to express our conservative abstractions we extend the language impwith a syntactic form for loops with restricted nondeterministic choice.
we call this extended language limp .
its syntax is as in figure .
here uis a set the iteration space for the loop in the syntactic form q. its elements are called choices .
xinis an unbounded data structure e.g.
an array .
is a special variable called the current choice variable.
every iteration starts by picking an element of uand storing it in .
xoutis the output variable.
r u xin xout henceforth r is an impprogram that does not write to or use elements of xinother thanxin but can read and read or update the iteration space u elementxin and the output xout.
linloop useonce u q plin r k xin xout plin r xout xout plin q k n xin xout figure proof rule linloop qis an abstract loop we call a program of form qanabstract loop henceforth qdenotes an arbitrary xed abstract loop.
for simplicity we only consider the analysis of abstract loops an extension to all limp programs involves a combination of the present abstraction with the previous abstractions.
as before we restrict ourselves to programs that terminate on all inputs.
the main loops in figs.
and are abstract loops.
for example the workset wl the graph g the nodeu and the arraydin figure respectively correspond to the iteration spaceu the input variable xin the choice variable and the output variable xout.
now we present a rule for proving piecewise nlinearity of limp programs.
as before for brevity we only derive robustness judgments that hold over the entire p .
we denote by plin p k n xin xout the judgment pis piecewisek n linear within p with respect to xinand xout.
a key premise for the rule is the assertion useonce u q which states that the values of chosen during a complete execution of qare all distinct .
as the variable is used to index the data array xin we can also see this assertion to mean that each memory location in xinis used at most once during a run of q. we establish the property useonce u q using a few syntactic su cient conditions that apply to several common classes of programs.
for example if qis a for loop over the indices of xin and is the monotonically increasing or decreasing index variable then we have useonce u q .
for another example consider dijkstra s algorithm where an element wis removed from the workset wlin each iteration never to be re inserted again.
in this case letting qdijkbe the main loop lines of the program we have useonce w wl qdijk .
another example in this class is kruskal s algorithm where we iterate over a workset that initially contains all edges of the input graph.
because edges are removed from but never added to this set we have a use once invariant similar to that indijk.
lastly observe the premises plin r k xin xout andplin r xout xout .
these are typically derived using one of our other abstractions e.g.
robustness matrices.
to see the intuition behind the rule linloop consider the simple case where xoutis areal.
by the premises the e ect of each iteration on xoutcan be summarized by assignments xout c1 xout c2 xin c3 wherec1 c2 andc3are constants with jc1j andjc2j k. as each location in xinis used only once and our norm over arrays isl1 this means the complete loop is piecewise k nlinear with respect to output xout.2we can show that theorem soundness .
if the rule linloop infers the judgment plin q n xin xout then the abstract loop q is piecewise n linear within q with respect to input xin and output xout.
2interestingly if the metric for arrays were the l1norm rather than the l1 norm then the rule linloop would be sound even if we changed its conclusion to plin q k xin xout .calc trans slow torques angle real speed real limit pressure1 pressure2 2if angle angle then limit 3elseif angle angle then limit 4elseif angle angle then limit 5elseif angle then limit 6if speed limit then gear pressure1 else gear pressure1 9if gear then pressure2 figure code from a car transmission controller example kruskal s algorithm .
for an application of the rule linloop consider kruskal s algorithm whose main loop can be abstracted using an abstract loop.
to analyze this loop we establish the use once property as discussed earlier.
all that is left is to show that the loop body line is piecewise linear.
this is easy to do using the robustness matrix abstraction.
a similar strategy applies to several other examples such as dijkstra s or bellman ford s shortest path algorithms.
.
applications in this section we identify three motivating application domains for our analysis.
as this paper is primarily a foundational contribution our discussions here use small illustrative code fragments.
the challenges of scaling to large real world benchmarks is left for future work.
.
robustness of embedded control software robustness is a critical system property for many embedded control systems.
the sensor data that drives these systems is often prone to noise and errors and unpredictable changes to system behavior due to this sort of uncertainty can have catastrophic consequences.
a proof that the system reacts predictably to perturbations in its inputs is therefore of crucial practical importance.
unsurprisingly control theorists have studied the problem of robust controller design thoroughly .
however approaches to the problem in control theory are concerned with deriving abstractly dened laws for robust control rather than proving the robustness of the software that ultimately implements them.
this is a gap that a program analysis of robustness a la our paper can ll.
as an example of how to apply our analysis to this space we consider the code fragment in fig.
derived from a software implementation of a transmission shift control system .
robustness of this fragment under a di erent definition of robustness was previously studied by majumdar and saha .
given the car speed and the throttle angle the operator calc trans slow torques computes a pair of pressure values pressure1 and presure2 which are applied to actuators related to the car transmission system.
a careful analysis reveals that the output pressure1 is constant which means the function is robust in that output.
on the other hand it is not continuous in the second output pressure2 hence is not k robust for any k. sec.
reports on the results of our implementation on this example.
.
robustness in approximate computation another application for our analysis is in approximate computation where the goal is to trade o the accuracy of a1while h i if y7!p y wherey2 x is in table thent look up p y g y z t i elset p x tabulate x !p x g x z t i figure approximate memoization for loops computation for resource savings.
rather than approximate solutions for speci c problems language based program approximation involves program transformations that are just like traditional compiler optimizations but when applied to a program lead to an approximately equivalent program.
such approaches are especially applicable to domains like image and signal processing where programs compute continuous values with negotiable accuracy.
while such approximation schemes have been much discussed of late very little is understood at this time about their theoretical foundations.
now we show that a robustness analysis such as ours can provide foundations for one such scheme called loop perforation .
the loop perforation optimization is applicable to expensive computational loops over large datasets what it does is simply skip every alternate iteration in certain long running loops.
the empirical observation in many cases this bizarre and obviously unsound optimization does not signi cantly a ect the accuracy of the nal output.
in a pro ling compiler is proposed that exploits this fact and identi es loop iterations that can be skipped.
as for the theoretical foundations of loop perforation a recent paper shows that if the loop under consideration follows certain computational patterns and the dataset on which the loop operates follows certain probability distributions then loop perforation is probabilistically sound i.e.
the output of loop perforation is guaranteed to be within reasonable bounds with high probability.
now we show that such a guarantee is available for anyloop that satis es certain robustness requirements of the sort studied in this paper.
this means that our analysis can be used to identify loops that can be correctly perforated and can serve as a static guidance mechanism for a perforating compiler.
approximate memoization.
before we show how robustness relates to loop perforation let us o er a more general approximation scheme.
consider a loop qof form while h i ft p x g x z t i g herexis a large read only array that is the input variable for the loop for simplicity we let elements of xto be reals .
the variable zis the output variable tis a temporary variable handpare side e ect free computations and g is an imperative procedure that can only read the element x out ofx but can have other e ects.
the function pis expensive and we would like to eliminate calls to it.
our rst approximation of qconsists of a sort of approximate memoization ofp.
suppose that in a loop iteration prior to making a call to p x we nd that pwas previously evaluated on some x such that x x .
then rather than evaluating p x we simply use the cached valuep x .
the pseudocode for the optimized loop is given in fig.
.
robustness of qis needed for this approximation to be sound.
denote by q x the nal value of zon inputx also suppose qisk robust with respect to the input xand outputz.
in that case the scheme in fig.
is equivalent to a transformation that replaces qby a program q0that on any inputx perturbs xby an amount resulting in an array x0 and computes q x0 .
by the robustness of q the outputs q x andq x0 on xandx0di er at most by k .
if this value is suitably small and we can make it be by selecting suitably the optimization approximately preserves the semantics of q. but ifqis non robust the outputs of the optimization may be very di erent from the idealized output.
loop perforation.
one obvious objection to the above scheme is that the complexity of table lookup will make it impractical.
however we now demonstrate that under some extra assumptions this scheme reduces to a scheme that is almost exactly loop perforation.
first let us restrict ourselves to for loops iterating over an array x i.e.
we assume qto have the form for0 i n dot p x g x z t wheren jxj and the imperative procedure gdoes not modify the induction variable iof the loop.
second let us assume that the input dataset xexhibits locality i.e.
any two successive elements in xare approximately equal with high probability.
note that this property holds in most multimedia datasets for example in most images neighboring pixels for the most part have similar colors.
we formalize the above using a model de ned in misailovic et al that views xas a random variable that is generated by a random walk with independent increments.
in more detail the variable x is a xed constant and zi x x follows a normal distribution nwith mean and variance .
as successive elements in xare likely to be close in value we can replace qby a program bqthat usesx as a proxy for the value x and the cached value p x as a proxy forp x in the iteration i .
observe that we have now arrived at an approximation scheme that is quite like loop perforation!
there is however an important distinction between this scheme and the version of loop perforation presented in prior work .
as the latter scheme skips loop iterations entirely it is not applicable when the loop body performs discrete computations pointer updates etc.
in addition to callingp these computations are encapsulated within the routineg .
perforating these loops may lead not only to inaccurate results but to system crashes.
our approach on the other hand does not skip any iterations but only the call topinside the iterations and can be viewed as executing qon a perturbed input.
therefore if the original program qdoes not crash on any input then neither does bq.
as for the analysis of error produced by the above transformation let us de ne the output error for the transformation to be errq x d q x bq x now observe that bq x q x0 where for all i x x0 n .
because we use the l1norm as the distance measure over arrays we have for every a the property p p x0 j a n p x0 j a n n a n a where nis the cumulative distribution function of n.insideerror fgmap binaryimage samples error 2forcam toncams forcylndr tonparts s s2 vectors on sides of body part m vector connecting midpoints of s 1and s n jmj vstep n jmj hstep fori ton1 i n1 p cylndr s .x s1.y p cylndr s .x s2.y m p p1 forj ton2 j n p p m.x m.y error error fgmap p samples 17return error samples figure bodytrack s insideerror function let n a n a .
note that for decreases asaincreases and is approximately fora .
by thek robustness of q we have p n the above can be seen as a probabilistic soundness result for loop perforation if the loop qis robust with a low robustness parameter then the probability of loop perforation introducing a signi cant error is low.
indeed one can give an intuitive interpretation to perforation here it amounts to sampling the dataset xat a lower frequency which is acceptable if the process is robust.
what all of this means is that one can use a robustness analysis such as ours to determine whether a given loop is suitable for perforation.
for a concrete example consider the code fragment in fig.
from the computer vision application called bodytrack in the parsec benchmarks .
perforation of this application was studied in .
the goal of this application is to track the major body components of a moving subject the code in fig.
performs a sampling computation inside a cylinder a projected body part .
in this code the loops at lines and can be perforated with good results .
however we observe that the reason behind this is that the sampling process performed between lines to is robust.
this robustness property can be proved by our analysis.
.
differential privacy robustness analysis can also be helpful in guaranteeing privacy in statistical databases where a trusted party wants to disseminate aggregate data about a population while preserving the privacy of individual members of the population.
the dominant notion of privacy in this setting is di erential privacy which asserts that the result of a statistical query should not be a ected substantially by the presence or absence of a single individual.
a known strategy to privatize statistical queries is to add some noise to the result the amount of noise needed is related to how sensitive is the query to individual changes of the data set.
our notion of k robustness can be used to establish the sensitivity of the query.
suppose we have a query over six feet which returns the number of individuals that are over sixfeet tall in a population.
let us represent the set of rows in the database as two arrays of the same size heights an array of reals and rows an array of reals whose element values will range over representing its presence or absence in the populations.
the rst array heights contains the height of the individual while the second rows speci es whether a certain row is present or not in the set.
the row is present in the database if its corresponding array element in the rst array representing the rows is and absent if it is note that we allow all real values between and .
to compute the amount of noise to be used for di erential privacy one rst needs to determine the robustness parameter of the query with respect to a suitable metric.
in differential privacy we are only interested in determining the robustness of over six feet with respect to the rst parameter rows.
note that for this case we will need to use thel1 norm on the type realarray .
with this norm we can prove that over six feet is robust as removing or adding an element to the set will imply a change to only one of the elements of the rows array by making the l1norm of the di erence to be .
the rules needed for this proof can be obtained by a simple modi cation of the rules that we have presented which assume the l1norm .
according to random noise with variance will be needed so that the query over six feet is di erentially private.
thus our analysis can guide the amount of noise that needs to be added to ensure the di erential privacy guarantee.
over sixfeet rows realarray heights realarray result 2fori ton if heights then result result row figure a robust query .
experiments we implemented our robustness analysis on top of the z3 smt solver and used the tool to verify the robustness of several classic algorithms from an undergraduate computer science textbook as well as the code fragments in section .
now we report on some experiments using this tool.
sorting algorithms.
our tool was able to verify the robustness of several classic sorting algorithms that take an arrayainand return the sorted array aout.
in particular we considered insertionsort bubblesort selectionsort and mergesort .
in those four algorithms where proved continuous with respect to ainandaoutusing proof system cont .
this time we proved that the computation of aout is arithmetic free hence robust due to continuity.
shortest path algorithms.
we veri ed the robustness of several shortest path algorithms.
recall that single source shortest path is n robust with respect to the input array of edge weights.
the proof for the particular shortest path algorithms such as dijk and bellman ford consists of the following.
in we have proved these algorithms continuous on the input array.
to prove piecewise n robustness of the loop we prove that the loop body is piecewise robust with respect to the array variable and with respect to output variable.
this is done using the rule robmat on an abstraction of loop body.
it follows from our method thatafter executing the loop the output variable disn linear with respect to the array of edge waits.
given that it is piecewisen linear and continuous we can conclude that it isn robust.
it must be noted that the nested loop structure in dijk can be abstracted as one single loop in limp .
our proof system is unable to prove n robustness for some shortest path algorithms such as floyd warshall .
minimum spanning tree algorithms.
the minimun spanning tree problem is n robust as explained in example .
the proofs for the particular spanning tree algorithms kruskall and prim are similar to that of the shortest path algorithms.
continuity is proved using the cont proof system of .
piecewise n linearity follows by expressing the loop in limp and proving piecewise robustness of the loop body.
now we conclude that the aforementioned algorithms aren robust.
again our proof system can not prove nrobustness for some spanning tree algorithms like boruvka s .
knapsack algorithms.
the integer knapsack algorithm takes as input a weight array cand a value array v and a knapsack capacity budget and returns the set of items with maximum combined value totvsuch that their combined weight is less than the knapsack capacity.
clearly value of totvisn robust inv.
to prove n robustness of our recursive knapsack implementation we rst prove the algorithm continuous using cont .
the prover uses a xpoint procedure to prove piecewise k robustness assuming k robustness for the recursive function calls while probing for di erent values of k andn .
in order to prove piecewisen linearity the function was manually rewritten to make it explicit the array partitioning operation at each recursive call where the input arrays are partitioned in two one containing only the rst element and the other containing the rest.
the tool keeps track of this partitioning to proven linearity for the addition operation in line .
at each xpoint iteration linearity of the function body is established using proof system robmat .
car transmission controller example .
the algorithm produces two outputs in two variables pressure1 and pressure2.
the tool determines robustness on pressure1 and non robust on pressure2.
to arrive to that conclusion the tool uses the proof system robmat in conjunction to the smt solver to discharge proof obligations for each discontinuity.
these proof obligations arise due to the proof rule ite con presented in continuity analysis .
loop perforation examples.
our proof rules are able to establish robustness proofs for several other code segments from the parsec benchmark suite where loop perforation is empirically successful .
in particular our rules can prove the robustness of the loops for the imagemeasurement class in the bodytrack application including the one shown in fig.
where loop perforation is reported to work.
a second example comes from x264 a media application that performs h. encoding on a video stream.
two outermost loops in function pixel satd wxh are claimed to be amenable to perforation with good results by .
we looked at the code snippet inside the body of the nested loops similar to the example in bodytrack perforating these loops will result in sampling less points in a coarser way and the computation inside the body of the loop is a robust computation.
however not all loops that are empirically amenable toexample time smt proofsproof method bubblesort .
continuity arithmetic freedom insertionsort .
continuity arithmetic freedom selectionsort .
continuity arithmetic freedom mergesort .
continuity arithmetic freedom array partitioning dijkstra .
continuity robustness matrix linear loops bellman ford .
continuity robustness matrix linear loops kruskal .
continuity robustness matrix linear loops prim .
continuity robustness matrix linear loops knapsack .
continuity robustness matrix array partitioning controller .
continuity robustness matrix table benchmark examples loop perforation are provably robust by our analysis.
examples include the loop in the pfl routine in the streamcluster application and a loop in the particlefilter update method in bodytrack.
we leave for future work a proof principle that can explain why these and similar loops can be successfully perforated.
implementation and experimental setup.
our tool is implemented in c relying on the z3 smt solver to discharge proof obligations and the phoenix compiler framework to process the input program.
the bulk of the new analysis computes facts about linear dependences between variables and parameters and is implemented as a xpoint computation that nds the solution of data ow equations derived from the proof rules.
some proof obligations are discharged in the process by the smt solver.
in the future we plan to use an optimization toolbox to have better guesses for the minimum bound.
some proofs involving arrays e.g.
mergesort requires to keep track of the accesses to the array with purpose to ensure disjoint access to elements of the array.
finally as mentioned earlier we manually rewrote some of the programs to t the abstraction language limp.
the performance results reported in table were obtained on a core2 duo .
ghz with 4gb of ram.
.
related work robustness is a standard correctness property in control theory and there is an entire sub eld of control theory studying the design and analysis of robust control systems.
however the systems studied by this literature methods are abstractly de ned using di erential equations and hybrid automata rather than programs.
as far as we know the only e ort to generally de ne and study the robustness of embedded control software can be found in on test generation for robustness.
there robustness is formulated as if the input of the program pchanges by an amount less than where is a xed constant then the output changes by only slightly.
in contrast we verify the stronger property that anyperturbation to the inputs will change the output proportionally.
many applications e.g.
di erential privacy demand this stronger formulation.
in addition there are many e orts in the abstract interpretation literature that while not verifying robustness explicitly reason about the uncertainty in a program s behav ior due to oating point rounding and sensor errors .
several of these approaches have been successfully applied to large embedded code bases.
however none of them reason systematically about divergent control ow caused due to uncertainty which we can thanks to our continuity analysis.
also none of the abstractions developed in this space seem suitable for an analysis of piecewise robustness that is needed to verify robustness.
so far as we know hamlet was the rst to argue for a testing methodology for lipschitz continuity of software.
however he failed to o er new program analysis techniques.
reed and pierce have since given a type system that can verify the lipschitz continuity of functional programs as a component of a new language for di erential privacy .
while the system can seamlessly handle functional data structures such as lists and maps it does not unlike our analysis handle control ow and would deem any program containing a conditional branch to be nonrobust.
also this work does not consider any application other than di erential privacy.
robustness and stability of numerical algorithms are also well studied topics in the numerical analysis literature .
however the proofs studied there are manual and specialized to speci c numerical algorithms.
other related literatures include that on automatic di erentiation ad where the goal is to transform a program pinto a program that returns the derivative of pwhere it exists.
but ad does not attempt veri cation no attempt is made to certify a program as di erentiable or lipschitz.
finally language based approaches to program approximation are still very new .
in particular there is only one existing paper studying the theory of languagebased program approximation.
.
conclusion we have presented a program analysis to quantify the robustness of a program to uncertainty in its inputs.
our analysis is sound and decomposes the veri cation of robustness into the independent subproblems of verifying continuity and piecewise robustness.
in future work we intend to extend our robustness analysis to programs that manipulate discrete data types like integers and boolean arrays in addition to continuous ones like the ones studied here .
this extension is especially important as discrete types are often used in real world applications in particular embedded control code.
another interesting question is the generation of test inputs that trigger robustness bugs i.e.
pairs of inputs that are close in value but on which the program behaves very di erently.
a third interesting direction is a notion of robustness for reactive programs where we must consider perturbations not only in the program inputs but also in the environment with which the program interacts.
.