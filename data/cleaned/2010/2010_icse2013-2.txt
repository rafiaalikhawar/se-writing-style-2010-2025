strategies for product line verification case studies and experiments sven apel alexander von rhein philipp wendler armin gr linger and dirk beyer university of passau germany abstract product line technology is increasingly used in mission critical and safety critical applications.
hence researchers are developing verification approaches that follow different strategies to cope with the specific properties of product lines.
while the research community is discussing the mutual strengths and weaknesses of the different strategies mostly at a conceptual level there is a lack of evidence in terms of case studies tool implementations and experiments.
we have collected and prepared six product lines as subject systems for experimentation.
furthermore we have developed a modelchecking tool chain for c based and java based product lines called spl verifier which we use to compare sample based and family based strategies with regard to verification performance and the ability to find defects.
based on the experimental results and an analytical model we revisit the discussion of the strengths and weaknesses of product line verification strategies.
i. i ntroduction software product lines a.k.a.
product families are gaining momentum in academia and industry.
a product line is a family of software systems that are distinguished in terms of features i.e.
end user visible units of behavior .
the goal of systematic product line development is to facilitate reuse manage variability and support automated product generation .
companies and institutions such as general motors nasa hp boeing and nokia are applying product line technology to decrease time to market improve software quality and diversify their product portfolio cf.
product line hall of fame as product line technology is increasingly applied to safety critical and mission critical software projects e.g.
in the domain of automotive and healthcare systems analysis and verification techniques become important means to ensure correctness reliability and security.
recently researchers began to apply model checking technology to analyze and verify software product lines .
as a product line may comprise a multitude of products a number of products that is in the worst case exponential in the number of features it is imperative to tailor existing model checking technology to the specifics of product lines.
the brute force approach to verify an entire product line called product based strategy is to create and analyze every possible product individually.
an alternative approach called sample based strategy is to concentrate on a subset of possible products i.e.
for some selected feature combinations to reduce the verification problem and to identify defects faster.
a third approach called family based strategy is to analyze the design and implementation artifacts of a whole product line i.e.
product family in one single pass forexample by creating a simulator that simulates the behavior of all individual products .
conceptually the three strategies of product line verification have different strengths and weaknesses.
the product based strategy is a brute force approach as the number of products increases this strategy quickly becomes infeasible it is the base line for our investigation.
the sample based strategy is likely to find defects quickly depending on how large the sample is but it may miss defects due to the incompleteness of the approach.
the family based strategy is beneficial for product lines that comprise many products with substantial similarities because similar product behaviors are not re checked for every product.
however verification tasks may become more complex than for individual products which may exceed resource limits.
the research community began to discuss and weigh the strengths and weaknesses of sample based and family based strategies each in comparison to the product based strategy .
however there is no work that compares the sample based strategy with the family based strategy systematically in a controlled setting.
in general there is a lack of case studies and experiments in this field which was the motivation for us to collect and prepare existing and implement further case study product lines as well as to develop a model checking tool chain called spl verifier for the verification of product lines written in c and java.
specifically we conducted a series of experiments based on six case studies to compare the sample based strategy and the family based strategy with the product based strategy as a base line with regard to their verification performance and their ability to identify defects.
we have concentrated on undesired feature interactions a specific class of defects that is especially challenging for verification because they emerge between several features and not within individual features .
in summary we make the following contributions we provide the tool chain spl verifier for conducting experiments with product based sample based and familybased model checking of product lines written in c and java.
we collected and prepared six case studies written in the general purpose languages c and java to be used as benchmarks for product line verification.
based on the case studies we conducted experiments comparing the three verification strategies including three different sampling heuristics for feature interaction978 c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.482detection in terms of the verification performance and the ability to identify defects.
based on the experiments we revisit the discussion of the strengths and weaknesses of sample based and familybased strategies and put them into perspective and we provide an analytic model that describes the trade offs of the individual verification strategies.
a key result is that in our experiments the family based strategy outperforms the sample based strategy in terms of defect detection efficiency.
spl verifier all case studies and the experimental results are available on the project s web site v. ii.
p roduct lineverification we introduce product based sample based and family based verification strategies by means of an example.
a. running example and setting for illustration we use a simple e mail system as running example.
we used the example before in our work on featureinteraction detection but its roots lie in hall s work on modularity of e mail systems .
we implemented the features of the e mail system by feature modules in c and java and we compose them by superimposition .
basically superimposition merges the code of all feature modules recursively based on nominal and structural similarity.
feature composition is generally not commutative .
the composition tool expects a certain order over the features of a product line that determines the composition order for a particular feature selection the composition tool constructs exactly one corresponding product because the tool is bound to the specific order .
in fig.
we depict excerpts of four feature modules of the e mail system.
feature emailclient implements a basic email client feature encrypt encrypts outgoing e mails feature decrypt decrypts incoming e mails and feature forward forwards incoming e mails to another host.
note that encryption and decryption rely on the availability of proper keys a circumstance that gives rise to a feature interaction as we will explain shortly.
emailclient is the base feature in our example.
it introduces a structure email for representing e mails and the two functions outgoing and incoming for handling outgoing and incoming e mails.
composing it with feature encrypt the existing structure email is extended by the two new fields isencrypted and encryptionkey function encrypt is added and the existing function outgoing is overridden to intercept outgoing e mails and to encrypt them using function encrypt keyword original invokes the overridden function.
feature decrypt introduces a function decrypt and overrides the existing function incoming to intercept and decrypt incoming e mails.
feature forward introduces a function forward and overrides the existing function incoming to forward incoming e mails to another host.
for the purpose of the example let us assume that all features are optional except emailclient which is present in all products.
this flexibility gives rise to feature interactions a class offeature emailclient representation of e mail 2struct email intid char from char to char subject char body outgoing e mails are processed before they leave the system 7void outgoing struct client client struct email msg ... incoming e mails enter here and are stored in a mailbox 10void incoming struct client client struct email msg ... feature encrypt extending the e mail structure by information on encryption 12struct email intisencrypted char encryptionkey encrypt an e mail if the public key of the receiver is known 18void encrypt struct client client struct email msg ... override outgoing to encrypt e mails before they are sent 21void outgoing struct client client struct email msg encrypt client msg original client msg invoke the overridden function feature decrypt decrypt a given e mail 26void decrypt struct client client struct email msg ... override incoming to decrypt encrypted incoming e mails 29void incoming struct client client struct email msg decrypt client msg original client msg invoke the overridden function feature forward forward an e mail to another host 34void forward struct client client struct email msg ... override incoming to forward e mails automatically 37void incoming struct client client struct email msg forward client msg original client msg invoke the overridden function fig.
.
implementation of four features of our e mail client in c defects that are difficult to detect.
a feature interaction is a situation in which new behavior emerges from the composition of two or more features that cannot easily be deduced from the behavior of the individual involved features.
the emergent behavior can be undesired and associated with unexpected program states .
while the features encrypt and decrypt are designed to cooperate feature forward has been developed independently of the two only based on feature emailclient .
the composition of all four features leads to an undesired feature interaction.
the interaction occurs if one host sends an encrypted e mail to a second host that forwards the e mail automatically to a third host.
if the second host does not have the public key of the third host it forwards the e mail in plain text forward has been developed independently and thus does not take encryption into account .
this situation contradicts the requirement that encrypted e mails must never be sent in plain text over the network .483note that even if there is a feature model that describes the domain dependencies between features it typically does not cover hidden implementation level dependencies that may lead to inadvertent feature interactions at run time .
hence we need analysis and verification techniques that check whether a feature composition satisfies the specifications of the involved features.
in our case studies individual features come with their own specification s expressed in the form of assertions that indicate erroneous executions or by automata that are woven into the code in the form of assertions .
in fig.
we show the specification of feature encrypt expressed as an automaton when the client receives an encrypted e mail lines the status encrypted or not of the message is stored into a field line that has been attached as a shadow to the email structure line .
when an e mail that was encrypted leaves the system lines it must still be encrypted if not the e mail client reaches an error state flagged by fail line .
1automaton encryptspec introduce an auxiliary field to store the state of an e mail introduction shadow struct email intin encrypted if an e mail is encrypted when entering the system... before void incoming struct client msg struct email msg in encrypted isencrypted msg ...it must be encrypted as well when leaving the system after void outgoing struct client msg struct email if msg in encrypted !
isencrypted msg fail fig.
.
automaton based specification of feature encrypt b. verification strategies product based strategy pursuing a product based strategy all products of a product line are generated and analyzed each using a standard model checker.
in our example we compose the set pof all eight valid products emailclient is mandatory so it is present in all products of the remaining three features we form all possible combinations respecting the predefined composition order.
then we verify the implementation of each product based on the specifications of the involved features p p f p impl p spec f whereimpl p is the implementation of product p andspec f the specification of feature f. in our setting the implementation is made up of real c or java code specifications are mostly local to individual features and comprise safety properties that must hold if the corresponding features are selected.
if there is a global specification all products are checked against it.
sample based strategy generating and analyzing all products in a brute force fashion is feasible only for product lines with a small number of products.
hence the sample basedstrategy selects a restricted number of products usually based on some coverage criterion p sample p f p impl p spec f wheresample p selects a subset of all valid products according to a sampling heuristic.
in our experiments we use the following heuristic for n wise sampling of feature combinations where nis the minimal number of features in the sample for each subset f1 ... f n fofnfeatures select a small product p p withf1 p ... fn p wherefis the set of features of the product line and small product refers to a valid product with a small number of features n .
forn pair wise all binary feature interactions can be detected.
while this heuristic reduces the number of products to be generated and analyzed significantly from an exponential number in the worst case to a polynomial number interactions between more than two features cannot be detected so the analysis is incomplete.
using this heuristic we can reduce the number of products in our example from eight to three as emailclient is mandatory we form three pairs of the remaining three optional features.
however this way we do not detect interactions that occur only between all of the three optional features.
in our experiments we also use two other sampling heuristics single wise n and triple wise n .
our sampling heuristics are inspired by previous work on feature interaction detection prediction of nonfunctional properties and analysis of model weaving interference .
as they aim at small products that cover certain feature combinations they facilitate the process of detecting isolating and understanding individual feature interactions.
an alternative would be to aim at large products which decreases the sample size but makes identification of feature interactions and the set of all defective features difficult cf.
sect.
iv .
family based strategy typically there are many similarities between the products of a product line .
thus checking products individually leads to redundant analyses of execution paths that are similar among products.
to minimize effort the family based strategy analyzes the entire code base of a product line in one single pass.
this can be achieved by combining all code of all features in a single product simulator .
in a nutshell a product simulator simulates the behavior of all products of the corresponding product line depending on the values offeature variables that represent the presence or absence of individual features .
all necessary information on valid feature combinations and feature dependent execution paths is encoded in the code of the product simulator.
the model checker initializes the boolean feature variables within the product simulator using a non deterministic choice such that it must assume that all feature combinations that are allowed by the feature model may occur.
this way it checks allvalid execution paths of allproducts without the need of generating and checking any individual product.
technically the approach relies on the concept of variability encoding which is a modification of the regular484feature composition process.
basically the variability induced by different combinations of features is encoded in the form of conditional program executions using ifstatements allfeatures are composed according to the total composition order of the product line.
for each feature there is a global boolean feature variable defined initialized at program load time that models the presence or absence of the feature.
for each function refinement a dispatcher function is introduced that dispatches between the refined and the refining function depending on whether the feature that contains the refinement is selected.
dependencies between features i.e.
the feature model are encoded by means of a boolean formula over the feature variables that models the corresponding constraints.
the entire program execution is enclosed in a conditional block that is executed only if the constraints imposed by the feature model are satisfied this way execution paths that are associated with invalid feature combinations are not considered by the model checker.
the resulting product simulator can simulate the behavior of any product of the product line depending on the values of the feature variables.
more details about variability encoding including a formal model and a discussion of correctness are provided elsewhere .
using a family based strategy a product line can be checked in a single pass f f p f spec f wherefis the set of all features of the product line and p is the product simulator that results from variability encoding incorporating all valid combinations of features in f. figure shows the product simulator for the composition ofemailclient andforward as produced by the variability encoding of our tool chain cf.
sect.
iii .
function incoming lines dispatches between its variants with and without feature forward .
the feature model is encoded lines and the execution is guarded line .
in fig.
we show the effect of variability encoding on the state graph.
states that are associated with invalid feature combinations are not considered by the analysis left sub tree .
all other states are checked right sub tree .
hence it can be verified if none of the valid feature combinations exhibits an unsafe feature interaction or other defects .
also one can see how both alternative execution paths for products with and without feature forward are encoded in the state graph.
late splitting and early joining largely implicit in previous work there are two principles that allow the model checker to exploit similarities between products using a familybased strategy late splitting and early joining.
late splitting means that as long as the execution paths of different products are equal starting from the common program entry point they are explored by the model checker only once.
only if execution paths diverge i.e.
the values of feature variables differ in the subsequent program state the state space exploration is split.
one boolean variable per feature 2intemailclient forward encoding the feature model 5intfeature model return emailclient emailclient forward !forward dispatch between forward and !forward 10void incoming struct client client struct email msg if forward incoming forward client msg else incoming emailclient client msg refinement of method incoming by forward 16void incoming forward struct client client struct email msg forward client msg incoming emailclient client msg base implementation of method incoming by emailclient 22void incoming emailclient struct client client struct email msg ... base implementation of method forward by forward 25void forward struct client client struct email msg ... 27intmain intargc char argv if feature model start the e mail client return fig.
.
variability encoding of the features emailclient andforward main argc argv ... ... ...incoming client msg states associated with valid feature combinationsincoming forward client msg program incoming emailclient client msg termination fig.
.
state graph of the product simulator of fig.
early joining means that if two program states differ only in the values of their feature variables the execution paths are joined and explored from there only once until a further split .
because feature variables are boolean they can be efficiently checked for equivalence and joined using disjunction by binary decision diagrams bdds .
we refer to previous work for details on encoding feature variables in bdds and on bdd based software model checking .
iii.
c ase studies and experiments both sample based and family based strategies promise to significantly decrease verification time either by analyzing only a subset of products or by sharing analysis results among products.
to learn about the trade offs of the two strategies we compare them as defined in sect.
ii b in terms of their verification performance and their ability to identify defects we use the product based strategy as a base line.485a key hypothesis is that sample based strategies are faster than the family based strategy the fewer products are checked the less time is needed for verification but may miss defective products.
conversely the family based strategy consumes more verification time than sampling but is complete.
with regard to the sample based strategy we are interested in the tension between sample defect and detection rates and their influence on verification time.
for the family based strategy we are interested in the factors that influence verification performance.
especially we want to explore whether late splitting and early joining are the driving factors for the speedups observed by us and others using family based strategies.
we quantify the number of verification steps that are saved due to sharing analysis results among products.
for the experiments we collected and prepared six case studies which exceed the case studies used in previous work on product line verification substantially in terms of volume and complexity sect.
iv .
this corpus of case studies is also meant to serve as a benchmark suite in further work which is in itself a valuable contribution to the community.
a. tool chain we developed a tool chain for product line verification called spl verifier which consists of a number of tools for feature composition we use f eature house .
for model checking we use the tools cpa checker revision branch explicit for c and j avapathfinder revision for java.
both support the verification of safety properties by means of explicit state and symbolic model checking.
specifically we use the explicit analyses of cpa checker explicitanalysis and j ava pathfinder jpf core for product simulators we use additionally a bdd based treatment cf.
sect.
ii b of feature variables explicitanalysis featurevars for cpa checker and the jpf bdd extension for j ava pathfinder .
all specifications are woven into the target code in the form of assertions by means of aspect weaving cf.
sect.
ii a we use acc1for c code and a spect j2for java code.
variability encoding is implemented using f eature house s composition facilities.
more details on specification weaving and variability encoding in spl verifier are available on the project s web site v .
b. subject systems as subject systems we selected three product lines that have been used before to assess product line verification and developed implementations in c and java the e mail system of hall models an e mail communication suite.
it provides several features such as encryption automatic forwarding and e mail signatures which can be activated or deactivated.
the elevator system has been designed by plath and ryan .
it is an elevator model that is extensible by various features such as stopping if the elevator is empty or priority service for a special floor.
system is based on work in the conic project .
it simulates a water pump in a mining operation including several features that vary the pump s behavior.
the pump keeps the bottom of the mine shaft dry but must be deactivated if the mine contains combustible methane gas.
based on the respective original systems we created for each system a c and a java implementation obtaining six implementations in sum we used the c implementation of the e mail system in previous work .
note that the respective java and c implementations may differ in details.
although we aimed at comparability the differences of the languages as well as the corresponding support of the model checking tools forced us to diverge from a common implementation schema e.g.
the explicit value analysis of cpa checker did not yet support arrays and structures .
additionally we selected three existing java product lines from the f eature house repository.3all of them have been developed for other purposes.
the primary selection criterion was that the java code could be processed properly by j ava pathfinder .
ajstats is a product line of source code analysis tools.
it has been developed by the first author to explore the use of aspectj.
it provides several features to tailor the analysis process for example recognizing various syntactic program structures.
gpl is a product line of graph libraries developed by lopez herrejon and batory as a standard problem for the evaluation of product line techniques.
it allows a programmer to tailor graph data structures including optional support for weighted and directed edges as well as different traversal strategies and algorithms.
zipme is an open source zip compression library for java me.
it has been refactored into a product line by kuhlemann.
it includes features for computing check sums and different compression techniques.
for the product lines e mail elevator and mine pump we adapted the original specifications which have been distributed with their models.
mostly the specifications concern domainspecific safety properties such as that encrypted e mails are never transferred in plain text the elevator must refuse to operate if the maximum weight is exceeded or the mine pump must be deactivated when methane gas is detected.
furthermore all three case studies contain defects documented by the original authors violating at least one specification.
for the product lines ajstats gpl and zipme we included proper specifications based on domain knowledge two for ajstats two for gpl and one for zipme .
the systems ajstats and zipme do not contain defects for gpl we used defects introduced by others .
in table i we summarize relevant information on all case studies.
note that although the subject systems are implemented in c and java the implementations comprise only the key functionalities of the product lines.
in this sense the implemen3 i overview of subject systems system lang.
loc features specs products e mail java c elevator java c mine pump java c ajstats java gpl java zipme java tations are models of the respective product lines.
nevertheless we use software model checking technology to verify the code without the need of extracting intermediate models manually the software model checkers extract the models from the code automatically cf.
sect.
iii a .
c. experiments we performed all experiments on a ubuntu .
system that has an intel i7 cpu with .
ghz cores and gb ram.
for each subject system we created all products product based strategy product samples that cover all a single wise b pairwise and c triple wise combinations and a corresponding product simulator using variability encoding family based strategy .
the overall goal of the verification tasks is to identify all defective products which violate the specification of one feature at least of the given product line.
that is for each specification we have to run a sequence of verification tasks for the product based and sample based strategies one verification task per selected product for the family based strategy one verification task for the product simulator.
for the product based and sample based strategies we terminated the verification task after detecting a violation and continued with the next product to be checked.
for the familybased strategy we determined which products contributed to the detected violation and proceeded with the exploration of the remaining state space that was not associated with these products.
the composition time for our subject systems is negligible compared to the verification time thus we compare the verification times only including the generation of counterexamples .
that is we measure five values for each specification to be checked product based single wise pair wise triple wise family based .
additionally for the sample based strategies we determine what percentage of defective products has been identified i.e.
the detection rate and we log what percentage of products has been checked i.e.
the sample rate .
d. results in fig.
we illustrate the relative verification times of using the sample based and the family based strategies for 4we could have stopped the verification once a violation was identified but then we could not have been certain that we identified alldefective products.
verification time in percent 100product based single wise pair wise triple wise family based e mail java e mail c elevator java elevator c mine pump java mine pump c ajstats java gpl java zipme java fig.
.
comparison of average verification times product based strategy defines the .
.
.
.
.
.0detectionrate single wise pair wise triple wisesample rate single wise pair wise triple wise e mail java e mail c elevator java elevator c minepump java minepump c ajstats java gpl java zipme java fig.
.
detection and sample rates of the sample based strategies ajstats and zipme do not contain any defect each subject system compared to the product based strategy whose time defines the .
as expected sample based and family based strategies can improve verification performance significantly compared to a product based strategy except for triple wise sampling in zipme which effectively selects all possible products single wise by pair wise by triple wise by and family based by on average.
the family based strategy is in many cases faster than most of our sampling heuristics for six subject systems it outperforms even single wise sampling.
note that using a sample based strategy we may find only a fraction of all defective products.
in fig.
we provide sample and detection rates side by side for later comparison for the different sampling heuristics.
the detection rates for ajstats and zipme are omitted because they do not contain defects.
in table ii and iii cf.
appendix we provide all raw data for replication.
e. discussion we divide our discussion into three parts regarding the sample based strategy the family based strategy and a comparison of the two.
sample based strategy first we consider the probability of sample based strategies to identify defective products.
the detection rate depends on the defect and sample rates which are based on the set pof valid products of a product line the non empty subset pd p of defective products and the subsetps p of products that are selected by a sampling heuristic as well as the subset pf pd psof selected products that are actually defect detected defects .
the defect raterdis defined as pd p the sample rate rsas ps p and the detection rate rfas pf pd .
there are no special assumptions about p pd ps andpf.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
defect ratesample rate pall .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
defect ratesample rate psome .
.
.
.
.
fig.
.
probability of detecting alldefective products left and some defective products right the probability qito identify exactly idefective products derived from combinatorics5 is given as qi parenleftbigg pd i parenrightbigg parenleftbigg p p d ps i parenrightbigg parenleftbigg p ps parenrightbiggifi pd i ps and ps i p p d otherwise the probability qallto identify all defective products rf is thenq pd and the probability qsome to identify at least one defective product rf is1 q0.
in fig.
we illustrate the corresponding probabilities of detecting all and some defective products depending on varying defect and sample rates.
note that a single product may contain several defects and a single defect may be contained in several products.
so identifying a defective product and removing the defect from the product line s code base may remove the defect also from other products.
while this is an advantage for samplebased strategies which is more likely to detect some defective products quickly useful in early development stages it still does not help with verification which is about providing guarantees that all products are correct typically the goal in later development stages .
next we consider how the detection rate is related to the sample rate as illustrated in fig.
.
on the one hand the higher the detection rate is for some given fixed defect and sample rates the better is a sampling heuristic.
on the other hand the lower the sample rate is for some given fixed defect and detection rates the better is a sampling heuristic.
in this light triple wise sampling performs best because the ratio between detection rate and sample rate is large in many cases cf.
fig.
.
finally we consider how the detection rate is related to the time that is actually needed for verification.
ideally the goal is to achieve a high detection rate and a low fraction of verification time compared to the product based strategy.
in fig.
we show for each sample based verification of our experiments 5in the numerator we count all possible samples that contain exactly i defective products the first term counts all possible selections of idefective products the second term counts all possible selections of the remaining products.
in the denominator we count all possible samples.
the probability is0for all situations that cannot exist.
.
.
.
.
.
.0detectionrate single wise pair wise triple wisetimefraction single wise pair wise triple wise e mail java e mail c elevator java elevator c minepump java minepump c ajstats java gpl java zipme java fig.
.
detection rates versus fractions of verification time ajstats and zipme do not contain any defect .
.
.
.
.
.
.
.
.
.
.
.
fraction of verification stepsfractions of verification time e mail elevator mine pump ajstats gpl zipme fig.
.
fractions of verification steps and verification time using late splitting and early joining correlation coefficient .
p .
the detection rate and the corresponding time fraction.
the higher the detection rate is for a given time fraction that is needed for verification the better is the sampling heuristic.
in our experiments the triple wise sampling heuristic has high detection rates as compared to the time spent for verification the ratio between detection rate and fraction of verification time is large in many cases cf.
fig.
.
we get back to this ratio when we compare sample based and family based strategies.
family based strategy for the family based strategy it is more difficult to explain the observed verification times.
in our experiments we observed speedups of up to thirty times mine pump compared to a product based strategy.
a key question which has not been answered in previous work is whether late splitting and early joining are the driving factors for the observed speedups or whether other effects such as internal optimizations in the model checker or technical issues play a dominant role.
hence we instrumented jpf bdd to quantify the verification steps saved due to late splitting and early joining.
specifically for each transition t t where tis the set of transitions in the product line we computed the number of instructions that it contains cost ct and in how many products ptit would have been executed.
then summationtext t tct pt is the number of verification steps i.e.
executed instructions that are saved due to late splitting and early joining.
in fig.
we illustrate the fraction of verification steps in relation to the verification steps needed without late splitting and early joining and the fraction of verification time that the family based strategy needs in relation to the productbased strategy .
although the data points are not on the dotted line a statistical analysis reveals that the fraction of488detection efficiency log scale .
.
.
.
.0product based single wise pair wise triple wise family based e mail java e mail c elevator java elevator c mine pump java mine pump c gpl java fig.
.
detection efficiencies of different verification strategies ajstats and zipme omitted because they do not contain any defect verification steps and the fraction of verification time correlate pearson s product moment correlation cor .
p .
.
this correlation suggests that the principles of late splitting and early joining can explain similarity within product lines i.e.
the amount of shared instructions could be used as similarity degree .
however the time consumed by join operations depends on the size of the bdds a factor that causes the deviations in fig.
.
family based vs. sample based strategies our experimental data suggest that both the family based strategy and the sample based strategies outperform the product based strategy in terms of verification performance.
but which strategy is superior?
we cannot compare solely their verification times but we have to take into account that for sample based strategies the detection rate decreases with the sample rate.
hence we compare the strategies with regard to detection efficiency which we define as the ratio between detection rate and the time fraction both in relation to the product based strategy .
a verification strategy with a detection efficiency of one is similarly efficient as the product based strategy.
in fig.
we show the detection efficiencies for all our experiments grouped by subject systems.
it reveals that the family based strategy is the most detection efficient strategy.
the notion of detection efficiency can of course not be applied to ajstats and zipme which do not contain any defect.
of the sample based strategies only triple wise sampling exceeds in some cases the detection efficiency of product based verification.
the fact that the family based strategy is mostly superior in terms of detection efficiency over our samplebased heuristics is one of the main results of our experiments.
f .
threats to validity the kind and distribution of defects threatens internal validity because they affect the detection rate.
if defects occur only if many features interact then sampling heuristics such as pair wise are only of limited use.
however the subject systems under investigation contained only defects that occur within single features or among pairs of features which reflects what is known about the distribution and probability of feature interactions .
much like the kind and distribution of defects several other characteristics of a product line influence the benefitsof the individual strategies.
for example the number and distribution of dependencies among features as documented in the feature model can have an influence on the sample and detection rates the degree of code sharing among products can influence the potential for late splitting and early joining the granularity of variability may have an effect on the efficiency of join operations based on bdds .
further work should develop proper feature model or code measures to predict the benefits of sample based and family based strategies and possibly combinations thereof.
the choice of the subject systems threatens external validity.
hence we selected as many subject systems as we were able to locate including standard benchmarks that condense the state of the art in the field.
but the tool chain that we used as well as the availability of product lines that contain specifications and that are amenable to model checking were limiting factors.
nevertheless for the first time a substantial set of different subject systems written in different languages has been considered for evaluating strategies of product line verification.
iv.
r elated work so far sample based and family based strategies have not been compared systematically in a controlled setting.
we discuss related work that focused on either sample based or family based strategies.
for a comprehensive overview we recommend a survey report .
the sampling heuristics that we considered in this paper are inspired by previous work on feature interaction detection they are tailored to pin down execution paths of individual feature interactions without being distracted by other features i.e.
they aim at small sample products .
alternative sampling heuristics that are used in product line testing and bug finding have different characteristics and tradeoffs.
by means of case studies it has been shown that a sample based strategy can have significant performance benefits while still being able to make reasonable statements about the products of a product line e.g.
non functional properties and defects .
for example using a pair wise sampling strategy like ours the database product line sqlite could be analyzed in hours with a prediction accuracy of .
which was not feasible using a product based strategy.
the family based strategy has been used in several modelchecking approaches but there is less experience compared to sampling with respect to performance gains over using a product based strategy.
still it has been shown that substantial performance gains are possible for example an average speedup of two was observed by using a family based strategy compared to the product based strategy and a speedup of sometimes two orders of magnitude if using bdds for feature variables .
feature based verification which aims at verifying features as far as possible in isolation to minimize the verification effort upon feature composition was not considered in our489study because practical verification tools and corresponding case studies were not available.
our work is based on state of the art software modelchecking technology.
we used the explicit state verification algorithms in cpa checker and j ava pathfinder and we encode feature variables in bdds.
encoding of feature variables in bdds and bdd based software model checking of event condition action systems have been described before.
v. c onclusion approaches of product line verification use different strategies to cope with the specific properties of product lines.
because they all promise benefits we conducted experiments to compare them with regard to verification performance and the ability to identify defects.
our experiments are based on the spl verifier tool chain for product line model checking and six case studies that are implemented in c and java.
we found that the family based strategy is in almost all case studies superior the corresponding verification runs produced results faster and the analysis is exhaustive compared to the considered sample based strategies aiming at small sample products .
by means of our experimental data and an analytical model we have discussed the merits of the individual strategies.
the success of a sample based strategy depends on the defect and sample rates whereas the success of the family based strategy depends on the similarity between products represented by the potential for late splitting and early joining.
while sampling can reduce the verification time significantly this does not necessarily increase the effectiveness of verification because many defective products may be missed.
key results of our experiments are that triple wise outperformed pair wise sampling the family based strategy outperformed all samplebased strategies in terms of detection efficiency and that late splitting and early joining are the driving factors for the success of the family based strategy.