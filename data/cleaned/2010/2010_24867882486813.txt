interaction based test suite minimization dale blue ibm systems technology group south road poughkeepsie ny usa dblue us.ibm.comitai segall ibm haifa research lab haifa university campus haifa israel itais il.ibm.comrachel tzoref brill ibm haifa research lab haifa university campus haifa israel rachelt il.ibm.comaviad zlotnick ibm haifa research lab haifa university campus haifa israel aviad il.ibm.com abstract combinatorial test design ctd is an effective test planning technique that reveals faults resulting from feature interactions in a system.
the standard application of ctd requires manual modeling of the test space including a precise definition of restrictions between the test space parameters and produces a test suite that corresponds to new test cases to be implemented from scratch.
in this work we propose to use interaction based testsuite minimization itsm as a complementary approach to standard ctd.
itsm reduces a given test suite without impacting its coverage of feature interactions.
itsm requires much less modeling effort and does not require a definition of restrictions.
it is appealing where there has been a significant investment in an existing test suite where creating new tests is expensive and where restrictions are very complex.
we discuss the tradeoffs between standard ctd and itsm and suggest an efficient algorithm for solving the latter.
we also discuss the challenges and additional requirements that arise when applying itsm to real life test suites.
we introduce solutions to these challenges and demonstrate them through two real life case studies.
i. i ntroduction as software systems become increasingly complex verifying their correctness is more challenging.
for example in highly configurable systems which gain more and more attention in recent years the many coexisting optional features might unintentionally interact with each other in faulty ways.
while verification approaches such as formal verification and model based testing might require extremely expensive resources due to their sensitivity to the size and complexity of the software functional testing is prone to omissions as it always involves a selection of what to test from a possibly enormous test space.
therefore careful consideration of what to include in the testing is required.
the process of test planning refers to the definition and selection of tests out of the space of potential tests with the goals of eliminating redundancy and reducing the risk of bugs escaping to the field as much as possible.
combinatorial test design ctd also known as combinatorial testing is an effective test planning technique in which the test space is modeled by a set of parameters their respective values and restrictions on the value combinations.
the test space represented by this model is any assignment of one value to each parameter that does not violate the restrictions.
a the research leading to these results has received funding from the european community seventh framework programme under grant agreement fittest .subset of the space is then automatically constructed so that it covers all valid value combinations a.k.a interactions of every tparameters where tis usually a user input.
in other words for every set of tparameters any combination of tvalues to them will appear at least once in the test plan unless there is no valid test that contains it according to the restrictions .
in general one can require different levels of interaction for different subsets of parameters.
the most common application of ctd is known as pairwise testing in which the interaction of every pair of parameters must be covered.
each test in the result of ctd is an assignment of values to all the parameters and represents a high level test or a test scenario that needs to be translated to a concrete executable test.
the reasoning behind ctd is the observation that in most cases the appearance of a bug depends on the combination of a small number of parameter values of the system under test.
experiments show that a test set that covers all possible pairs of parameter values can typically detect to of the bugs in a program .
other experimental work has shown that typically of bugs can be revealed by covering the interaction of between and parameters .
as indicated by various studies and reports ctd is very effective for a variety of system types and testing domains and is considered best practice when the tested functionality depends on multiple factors such as inputs configuration elements and data items.
however we observe two main requirements of ctd that limit its application in practice.
the first is the requirement to precisely define the restrictions between the different parameters.
if the restrictions are not accurately defined or not defined at all there is a very high probability that ctd will generate tests that violate the relationships between the parameters and therefore do not translate to concrete tests that can be implemented and executed.
while the requirement to define restrictions is not a limitation for simple cases like configuration spaces in which the restrictions are obvious when the relationships between the parameters are complex e.g.
as in the healthcare insurance domain manually capturing the restrictions is a labor intensive task that might be infeasible in practice.
the second requirement has to do with the fact that the test suite constructed by ctd corresponds to new test cases that need to be implemented.
since the test space in real life cases is usually enormous the probability that ctd will produce a test that corresponds to an existing one is close to zero.
when978 .
c ieee icse san francisco ca usa182 the cost of implementing a test is high e.g.
when large and specific amounts of data are required for each test constructing a complete new test suite might be infeasible in practice.
in this work we propose to use interaction based test suite minimization itsm as a complementary approach to ctd for cases where standard ctd may be best practice but cannot be applied due to the requirements described above.
rather than constructing a new test suite that provides full interaction coverage itsm reduces an existing test suite while preserving its interaction coverage.
similarly to ctd itsm requires defining the parameters of the test space and their values but it does not require defining restrictions between the values.
it is then given a test suite where each test is in the form of an assignment of values to the parameters and selects a subset of the test suite that preserves its t wise value combinations.
clearly like other test minimization techniques itsm is applicable only when there is an existing test suite that is on the one hand extensive and representative enough so that omissions are not a concern and on the other hand is too large to run to completion and may contain redundant test cases.
since itsm is a test suite minimization technique rather than a test design technique it is not guaranteed to provide full interaction coverage of the test space any interactions that are missed by the original test suite will clearly be omitted also by the subset selected by itsm.
however itsm can be applied without the two potentially problematic requirements of ctd it does not require defining restrictions nor implementing new tests.
its result contains only existing tests and these are presumed to be valid i.e.
they do not violate the unspecified test space restrictions.
another point to consider is that while itsm does not require defining restrictions it does require translating test cases to combinations of parameter values.
when the original test cases are represented in a structured or semi structured format the values can be extracted automatically.
otherwise the translation might be a labor intensive manual effort.
ctd and itsm can also be combined to produce an optimized test plan while still reusing existing tests.
in this approach ctd is first applied to produce a complementary test suite that covers the t wise interactions that are not covered by the existing test suite .
the two test suites are then combined and itsm is applied to reduce it.
this approach is suitable when restrictions can be defined implementing new tests is costly but possible and there has been a significant investment in an existing test suite and thus reusing it is desirable.
this paper however focuses on the scenario where only itsm is applied.
we present two real life case studies that demonstrate the scenario where standard ctd was inapplicable and itsm was successfully used instead.
in the first case study from the healthcare insurance domain the restrictions were too complex to specify and implementation of new tests was highly costly.
however the existence of numerous insurance claims from field usage enabled the usage of itsm.
in the second case study we look at extending a legacy computer terminal interface via web services.
the test space in usewas represented explicitly test by test and translating it to restrictions between the test space parameters was too costly.
instead the original representation was used as input to itsm.
for both case studies we describe the challenges and requirements we encountered while applying itsm such as challenges related to translating existing tests to combinations of parameter values and non standard coverage requirements and introduce our solutions for them.
in addition we discuss different approaches for solving the itsm problem.
that is given a test suite in the form of parameter value combinations and interaction coverage requirements how to select a small subset of the test suite that preserves the same interaction coverage as the entire suite.
though it is possible to reduce an itsm problem to a ctd problem and apply existing ctd algorithms to solve it translating a test suite to a ctd model is very costly.
instead we propose an efficient algorithm for solving itsm directly.
a well known concern of test suite minimization techniques is that of loss of fault detection.
the effectiveness of minimization techniques is measured not only by their reduction power but also by their ability to maintain the same level of fault detection as the original suite.
since studying the fault detection capabilities of itsm is left for future work this is a threat to validity that needs to be considered.
studies that investigate the loss of fault detection concern have conflicting findings.
while some studies showed no significant decrease in fault detection effectiveness after test suite minimization in other empirical studies fault detection capabilities of test suites were severely compromised.
the reasoning behind our minimization approach is that most software faults are caused by an interaction between a small number of parameters as demonstrated in several studies .
therefore the fault detection effectiveness of the minimized test suite is expected to be similar to that of the original one.
however actual empirical data must be obtained to support these expectations.
the rest of the paper is organized as follows.
in section ii we introduce itsm via a simplified example.
section iii presents our algorithm for solving itsm.
in section iv we present in detail two case studies for itsm as well as additional results from applying itsm to various systems.
section v discusses related work.
finally section vi draws our conclusions and future research directions.
ii.
i nteraction based test suite minimization in this section we introduce the main idea of interactionbased test suite minimization via a simplified example.
consider testing the claims system of a healthcare insurance provider.
each filed claim consists of information about the patient and the treatment received.
each of these further expands to more detailed information.
for example the patient s information may consist of their age history e.g.
number of previous insurance claims and their general health status type of insurance etc.
similarly the treatment information may consist of the exact type of treatment given the geographic183location in which it was given the type of clinic the involved personnel etc.
table i depicts a highly simplified model for such a system.
table ii further lists a pairwise test plan for this model i.e.
ctd with t .
this test plan consists of tests and achieves full pairwise coverage of the model.
note that since no restrictions have been defined for the model all combinations in the model are considered valid.
table i example healthcare model parameter values gender female male age child adult elderly past claims none one many health healthy some non chronic history chronic disease caregiver doctor paramedic nurse treatment surgery vaccination emergency location home town home state out of state clinic hospital private clinic home in order to implement the test plan suggested in table ii one needs for each of the rows to either find or generate patients caregivers clinics etc.
that exactly match the characteristics defined by the tests.
for example in order to file the claim dictated by the first row one needs to have in the system a female child with many past claims who is healthy.
a claim should then be filed for her name for getting a surgery by a doctor in an out of state private clinic.
such a doctor and a clinic need to also exist in the system.
while this may seem possible for this small almost toy sized model for reallife cases the chances of finding patients doctors etc.
which exactly match the required characteristics are slim to none.
alternatively one may consider to generate this data in the system specifically for testing purposes.
however the effort of setting up the exact required data is also high and often impractical.
moreover the model as it is now contains no restrictions.
therefore some tests suggested by the ctd algorithm are not even valid ones.
for example in the last test in the table a claim is filed for a nurse performing surgery a case which should clearly be excluded.
for systems with complex business logic correctly identifying and defining the restrictions is a daunting task which is often infeasible or at least not costworthy.
we therefore propose to use interaction based test suite minimization.
the idea behind this approach is given a set of existing tests to select a subset that maintains the same coverage of value combinations as the existing set up to a certain user supplied interaction level t .
in the above healthcare example one could collect all claims filed in a certain period of time say a few months and select a subset of them to maintain as a test suite.
if a long enough period of time is taken then most interactions of interest would with high probability be covered by the existing set thus will also be covered by the minimized one.now consider table iii.
it illustrates a possible set of existing tests picked randomly from the model for illustration .
for our example let s assume that this table represents the set of claims filed in the last month in the system.
clearly all these claims are valid ones i.e.
ones that are implementable and executable.
after all these claims were indeed filed in the system recently .
moreover all patients participating in these tests actually do exist and similarly so do the caregivers clinics etc.
therefore it is easy to re execute each of these tests.
on the other hand this test plan might be too large and needs to be diluted.
is has been shown that most software defects are caused by an interaction of a small number of parameters.
therefore a reasonable criterion for choosing a subset of the tests to maintain is that the same set of interactions up to a small given size are covered.
for example one may require that all pairs of values that appear in the large set also appear in the selected one.
as mentioned above since the existing tests represent the set of claims filed in the system during a relatively long period it is reasonable to believe that most interesting interactions of parameters are covered by this set of tests.
therefore the sacrifice in coverage resulting from applying itsm as opposed to standard ctd is small.
moreover some of the interactions that do not appear in the existing tests are such that are in fact invalid.
our approach thus removes the need of explicitly specifying the invalid combinations i.e.
restrictions .
getting back to our example the set of tests in table iii consists of tests.
these tests cover out of the pairs of values in the model.
some of these pairs are uncovered since they are in fact invalid e.g.
a surgery performed at home or by a nurse while others are due to the fact that no claim including them has been filed during the collection period e.g.
an adult having surgery .
the test plan in table iv gives the result of running the itsm algorithm on this input with pairwise coverage requirement.
the table consists of only tests all chosen from the given which achieves the same pairwise coverage as the original .
iii.
i mplementation we now discuss the implementation of itsm.
we refer to the value combinations that are to be covered as coverage targets .
coverage targets may be given in different forms such as a cartesian product e.g.
every combination of size t just as in standard ctd or as explicit sets of value combinations to be covered.
we say that a test tcovers a coverage requirement cif the values specified by care used int.
given a suite of tests t ti i n a set of coverage targets c cj j m and a mapping m t!2cthat specifies the coverage targets that are covered by each test in t the objective of an interaction based test suite minimization algorithm is to find s si i k a subset of tthat covers all the targets that tcovers s ts t i nm ti i km si 184table ii pairwise test plan for the example healthcare model gender age pastclaims health caregiver treatment location clinic female child many healthy doctor surgery outofstate privateclinic male adult none somenonchronichistory doctor vaccination hometown home male child one chronicdisease nurse emergency homestate hospital female elderly none chronicdisease paramedic surgery outofstate home female elderly many healthy paramedic emergency hometown hospital male elderly one somenonchronichistory doctor emergency outofstate privateclinic female elderly none healthy nurse vaccination outofstate hospital male adult one healthy nurse surgery homestate home male elderly many somenonchronichistory paramedic vaccination homestate privateclinic female adult none somenonchronichistory nurse emergency outofstate privateclinic female adult none somenonchronichistory doctor surgery homestate hospital male child none somenonchronichistory paramedic emergency hometown home female adult one chronicdisease paramedic vaccination hometown privateclinic male child one chronicdisease doctor vaccination outofstate home male adult many chronicdisease nurse surgery hometown home a na ve approach to implementing test suite minimization would be by reduction to ctd where the set of tests that the ctd algorithm may choose from is limited to the input tests.
exact implementation details depend on the ctd algorithm used but common to all is the need to represent the set of possible tests or the complementary set of excluded tests .
unfortunately compact representations that are very efficient for ctd turn out to be inefficient for test suite minimization.
for example presents a bdd based algorithm for ctd.
in order to use it for itsm one needs to capture the set of existing tests as a bdd e.g.
by disjuncting the bdds representing the individual tests.
bdds are an effective data structure for representing structured sets i.e.
ones for which the characteristic formula is relatively simple.
since existing tests can very rarely be characterized by a simple formula this representation becomes very inefficient for large sets of existing tests.
alternatively one could try to capture the complementary set of excluded test using standard restriction notations.
this is typically also an infeasible approach.
to mitigate these problems we describe a fast algorithm that uses a low overhead data structure.
first consider the following simple and greedy algorithm fori n ifticovers a target that is not yet covered bysthen add titos.
it is easy to see that at the end of the loop scovers all the targets that tcovers.
however it is also easy to see that sis not always the best solution.
for example if the test suite has two tests the first of which covering one target and the second covering the same target and another one this algorithm will select both tests whereas the second test suffices.
this algorithm visits each test in tat most once.
its time complexity is o jtj jcj .
the following algorithm is less greedy produces better results but works harder while scovers less than t add to sthe test that covers the most targets that are covered by tbut not yet covered bys.this algorithm also computes a correct result that is in the end scovers the same targets as tdoes.
its result is not optimal but it works well for the example above.
this algorithm visits n itests in its i th iteration hence its time complexity is o jtj jcj jsj .
in the worst case jsj jtj but in practicejsjis frequently orders of magnitude less thanjtj.
we next explore three ways to improve this algorithm.
two reduce the constant factor in the o complexity expression of this algorithm and one results in a smaller output test suite.
avoiding unnecessary calculations test prioritization counting uncovered targets avoiding unnecessary calculations we introduce an improvement that significantly reduces the number of times that uncovered targets are counted.
note that the number of uncovered targets that a test can contribute in one iteration is never higher than the number it could contribute in a previous iteration.
hence if the current iteration has already found a test that contributes maxsofar new targets then the o jcj process of counting uncovered targets for any test that could contribute less than maxsofar in previous iterations can be skipped.
this is illustrated in algorithm where testi prevcount is the latest computed contribution for testi.
note that this value is not necessarily computed in every iteration.
1iftesti prevcount maxsofar then compute count the number of uncovered targets that testicovers testi prevcount count ifcount maxsofar then best testi maxsofar count end 8end algorithm skipping unnecessary counts185table iii test plan for the example healthcare model consisting of 50existing tests gender age pastclaims health caregiver treatment location clinic female child none chronicdisease paramedic emergency hometown hospital female elderly one healthy nurse vaccination outofstate privateclinic male child many healthy paramedic emergency outofstate hospital female adult many chronicdisease paramedic emergency outofstate home male child none somenonchronichistory nurse emergency homestate hospital male adult many somenonchronichistory paramedic emergency outofstate home male elderly one chronicdisease paramedic emergency homestate home female child none healthy nurse vaccination hometown home male adult one healthy nurse vaccination hometown privateclinic female adult many healthy nurse emergency outofstate home male elderly none chronicdisease doctor surgery outofstate hospital male elderly one somenonchronichistory doctor surgery outofstate privateclinic male adult many somenonchronichistory doctor emergency homestate home male elderly many healthy nurse emergency homestate hospital female elderly many chronicdisease doctor surgery outofstate privateclinic male child many chronicdisease nurse emergency outofstate home female adult one chronicdisease nurse vaccination hometown hospital male elderly many chronicdisease nurse vaccination outofstate hospital male adult none healthy nurse emergency hometown privateclinic male elderly many chronicdisease doctor surgery outofstate hospital male child many chronicdisease doctor surgery outofstate privateclinic male elderly none healthy paramedic emergency outofstate home male elderly one somenonchronichistory nurse emergency hometown privateclinic female elderly many somenonchronichistory nurse emergency outofstate hospital male elderly one chronicdisease paramedic emergency hometown privateclinic female elderly many chronicdisease paramedic emergency outofstate home male adult many chronicdisease paramedic emergency homestate home female elderly none chronicdisease nurse vaccination outofstate home male child none somenonchronichistory paramedic emergency homestate home male elderly none somenonchronichistory doctor emergency outofstate home female elderly many chronicdisease paramedic emergency outofstate home male adult many healthy paramedic emergency outofstate hospital female child many healthy doctor surgery outofstate privateclinic female adult none chronicdisease paramedic emergency hometown home female child many chronicdisease nurse vaccination homestate home female elderly many chronicdisease nurse emergency outofstate privateclinic male adult one somenonchronichistory paramedic emergency outofstate hospital female elderly none chronicdisease doctor emergency homestate privateclinic male child none healthy nurse vaccination outofstate home female child none somenonchronichistory paramedic emergency hometown privateclinic male elderly many somenonchronichistory doctor emergency hometown hospital male elderly one healthy paramedic emergency outofstate home male child one chronicdisease paramedic emergency hometown privateclinic male adult one chronicdisease nurse vaccination hometown home male elderly one healthy paramedic emergency outofstate home male elderly many chronicdisease doctor emergency outofstate hospital male elderly none somenonchronichistory nurse emergency homestate hospital male elderly many healthy paramedic emergency hometown privateclinic male elderly one healthy paramedic emergency outofstate home male child many chronicdisease nurse emergency homestate home table v shows that this improvement provides a significant speedup.
we show results for three data sets.
the second column tests shows the number of initial tests per data set.
the third column targets shows the number of targets that are to be covered.
the next two columns countswithoutskipping and timewithoutskipping show the total number of times that a test s possible contribution to coverage is computed and the total execution time in seconds without the above improvement respectively.
the last two columns show the same where the improvement is used.
for large datasets the improved algorithm is about times faster than the straightforward solution.
test prioritization changing the priority of selecting tests results in a smaller output test suite.
so far we only considered the number of uncovered targets in preferring one test over another.
typically this results in the algorithm ending with many iterations selecting tests that contribute only one target.
we experimented with several weighting schemes that give a higher weight to targets that appear less in the input and preferring higher weight tests to lower ones.186table iv itsm result for the example healthcare model consisting of 22out of the 50existing tests gender age pastclaims health caregiver treatment location clinic female child many healthy doctor surgery outofstate privateclinic male child none somenonchronichistory paramedic emergency homestate home female adult one chronicdisease nurse vaccination hometown hospital male elderly none chronicdisease doctor surgery outofstate hospital male elderly one healthy paramedic emergency outofstate home female child none somenonchronichistory paramedic emergency hometown privateclinic male elderly many healthy nurse emergency homestate hospital male adult many somenonchronichistory doctor emergency homestate home male adult none healthy nurse emergency hometown privateclinic female child many chronicdisease nurse vaccination homestate home female elderly many chronicdisease nurse emergency outofstate privateclinic male elderly one somenonchronichistory doctor surgery outofstate privateclinic female adult many chronicdisease paramedic emergency outofstate home male elderly many somenonchronichistory doctor emergency hometown hospital female child none healthy nurse vaccination hometown home female elderly none chronicdisease doctor emergency homestate privateclinic male elderly one chronicdisease paramedic emergency homestate home male child none somenonchronichistory nurse emergency homestate hospital male adult one somenonchronichistory paramedic emergency outofstate hospital female elderly one healthy nurse vaccination outofstate privateclinic male child one chronicdisease paramedic emergency hometown privateclinic male elderly many chronicdisease nurse vaccination outofstate hospital table v effect of the count skipping improvement dataset tests targets countswithoutskipping timewithoutskipping countswithskipping timewithskipping .
.
.
.
.
.
the intuition behind this approach is that when such weights are used the first iterations select tests that cover many hard to find targets and the last iterations easily find many easy to find targets.
indeed using weights may reduce the size of the selected suite by up to .
counting uncovered targets finally itsm can be speeded up by performing several bit operations at a time.
we maintain a mapping from each test to the targets that it covers.
covered targets are represented by bits in integer variables which we call elements and counting the number of set bits in a bitmap is done using a lookup table for an element at a time.
we get a significant speedup by using bit elements a short int in c c or a char in java.
such bitmaps are associated with each input test representing the targets that each test covers and are also used for intermediate results representing the targets that still have to be covered.
algorithm shows counting the number of uncovered targets that testicontributes.
testi covered jis the j th element in the bitmap that describes the targets covered by testi bitcount is a lookup table that is initialized to the count of set bits in every possible element and count is the number of uncovered targets that testican contribute.
this speed up can be combined with the priority criterion above by using nelementsinbitmap bitcount tables i.e.
using bitcount j instead of bitcount in line of algorithm .1count 2forj tonelementsinbitmap do new testi covered j uncovered j delta bitcount count count delta 6end algorithm counting uncovered targets in section iv and in table vi in particular we present results that compare variants of the proposed algorithm with and without the improvements suggested above.
iv.
e valuation interaction based test suite minimization has been applied in several real life cases within and outside of ibm.
while clearly we cannot share the exact details of these applications we do present two cases in some detail here as case studies.
we also give some results from several other applications.
a. case study healthcare the first case study is in fact the real life version of the example in section ii.
the system under test was a claims processing system of several large healthcare providers.
the model for testing this system consists of parameters some with only a few values and some with hundreds.
for this case both requirements presented in section i are problematic.
first 187the business logic in the system is very complex therefore it is practically impossible to correctly capture all the restrictions between values in the model.
moreover even if one could specify these restrictions generation of a test that corresponds to an arbitrary combination of values to the parameters even if valid requires generating all the corresponding data and is therefore a highly laborious task that was infeasible in this case.
due to these limitations we opted for applying itsm.
since many of the parameters in this case study have a very large number of values which cannot be abstracted in a reasonable way the standard practice of specifying coverage requirements as t way coverage of all parameters is infeasible since it will require too many tests in order to be fully satisfied.
therefore the following two types of coverage requirements were used a explicit values and combinations of interest which were defined manually b requirements such as cover the pairs of values for parameters a and b that correspond to of the claims .
a preprocessing step translated requirements of the latter type into concrete requirements.
the reasoning behind the latter type is that for huge amounts of data such as the ones dealt with in this case study it is often very hard to manually consider all combinations of values for parameters of interest.
on the other hand typically a small number of such combinations cover the most common cases so by requiring to cover a certain top percent of the claims one can with small effort make sure that the most frequently used combinations are covered with a relatively small number of tests.
table vi summarizes the reductions achieved for seven different healthcare providers.
in all of them claims were collected over a certain period of time and the itsm technology was used in order to select a subset of them that fully covers all the interactions that are defined as required and are covered by the complete sets.
the table shows the number of selected results for three variants of the greedy algorithm a the most na ve greedy algorithm referred to as simple greedy in the table b the less greedy algorithm without improvements referred to as uniform and c the improved algorithm including test prioritization prioritized .
the magnitude of reduction in all cases was from hundreds of thousands and even millions of claims four million for the largest case to around eight hundred with the most na ve algorithm and around three hundred for the prioritized one.
computation time for the prioritized algorithm is about .
seconds per input tests on a standard pc.
table vi itsm results for seven healthcare providers total claims claims after itsm simple greedy uniform prioritized 273note that some preprocessing had to be performed in order to translate the claims into parameters and values.
one example of a type of preprocessing operations is that of abstraction such as merging several different concrete values into the more abstract one e.g.
replacing the patient s concrete age with child adult elderly.
another example is table based replacements e.g.
looking up a caregiver in a table and replacing her code with the relevant parameter values.
as mentioned above the input to itsm is a set of claims collected over a relatively long period of time.
the reasoning behind using itsm for this case is that over such a period most relevant values and interactions of values are used at least once and will therefore be covered by the selected set.
in other words in this case the potential coverage omissions as opposed to using ctd which would have guaranteed full coverage are not a big concern especially given the significantly higher cost that ctd would have demanded which was unacceptable.
b. case study interface panels in the second case study a legacy computer terminal interface was extended via web services to work in a modern web browser environment.
because implementation was done in a fashion that made use of the existing legacy gui panel definitions the original requirement for testing was to verify every existing legacy panel.
with about panels this testing requirement was unrealistic especially since verification required visual inspection of the resulting web page.
the most unique aspect of this example was that the panels represented of the test combinations.
thus we had an existing test suite that was guaranteed to exercise all necessary combinations.
because of this the need to fully enumerate all restrictions as required in traditional ctd was not necessary.
we relied on the existing test suite to naturally reflect the restrictions.
having this set of all actually used test combinations also removed any incentive to write additional tests.
in light of these two factors the test challenge became one of test suite minimization.
one more consideration made the example a good candidate for itsm.
the panels were well suited for automation to be represented as tuples of parametervalues.
the model that was built consisted of parameters with a cartesian product test space size of .72e21 combinations.
amazingly traditional pairwise analysis with no restrictions reduced this to only tests due to the fact that most parameters were boolean having only values.
similar to the first example existing tests were available as several subsets.
each subset corresponded to the panels from a different product that made use of the terminal interface functionality.
table vii demonstrates the reduction achieved for each of the sets.
in this example the analysis was also taken one step further by performing an itsm reduction on the test suite combining all panels.
the result of that analysis appears as the last entry in the table.
the table also shows the percentage of all pairwise values that appear in the test suite for each product.
as expected we see that a higher percentage188of coverage is achieved by the combined test suite.
in addition an analysis of the tests selected in the combined case shows that panels from many different products were chosen.
table vii itsm results for the interface panels case study product id panels covered selected .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
all .
as a side effect of the combined analysis we see a clue about the number of restrictions that are associated with this data.
from the high coverage percentage of .
we can assume there are relatively few restrictions.
many restrictions would normally reduce the number of valid combinations as compared to the cartesian product size to a percentage lower than the plus that we observe here.
while pairwise coverage could have been accomplished with only tests we had no idea if those violated the unknown restrictions.
the higher number of tests selected using itsm were known not to violate restrictions.
this gives us an idea of the tradeoff in effort associated with the technique.
with the analytical pairwise optimization offered by traditional ctd missing a higher number of natural test scenarios were required to achieve the same pairwise coverage.
in the end while more tests had to be run itsm still represented less effort than would have been required to discover all of the restrictions associated with the model and to code new tests from scratch.
c. additional results we also applied itsm to several other projects from financial and health insurance domains.
the charts in figure summarize the results.
each chart depicts the original number of tests vs. the number of tests selected by itsm.
on average itsm reduced over of the tests.
the level of interaction coverage obtained by the test plans is also plotted.
as expected the coverage is identical before and after the reduction.
finally we revisit the claim from section iii that the na ve approach to itsm of reduction to a ctd problem does not scale.
in figure we present computation time for solving fig.
.
runtime of the prioritized algorithm vs reduction to standard ctd itsm comparing between reduction to the bdd based ctd algorithm presented in and the algorithm presented here.
it is easy to see that the bdd based algorithm explodes at problems that are orders of magnitude smaller than those deemed problematic for the approach presented here.
the inputs in this experiment are random subsets of the test suites mentioned in section iv a and the coverage requirements are to cover all values and for half of the parameters all pairs of values.
similar behavior was observed on other input sets and other coverage requirements.
v. r elated work test suite minimization is a well studied and widely used approach for increasing the efficiency of regression test suites that tend to grow over time.
this approach reduces the size of test suites by eliminating redundant test cases according to some criteria where the most common criterion is achieving the same code coverage as the original test suite.
problems related to test suite minimization are those of test case selection and test case prioritization.
in test case selection following a set of changes in the system under test relevant test cases to run are identified.
in test case prioritization the test cases are ordered in a way that is intended to achieve early fault detection.
a recent survey studies these three problems and lists related papers.
for test minimization most techniques described in the survey use either general black box requirements as the criterion or structural coverage level criteria.
however there are some other criteria described in the paper such as operational abstraction model based minimization and more.
in our work we choose to focus on interactions between values as the minimization criterion motivated by the studies such as that show that most software defects are caused by an interaction of a small number of parameters.
the survey in also states that only of the proposed techniques were applied on industrial scale examples.
as mentioned above in this paper we describe two industrial case studies and survey some results from other cases all from real life industrial applications.189fig.
.
test suite minimization results for seven different real life projects interaction based test suite minimization was introduced in .
the test minimization problem defined there receives an input test suite that already has percent t wise coverage.
in addition all value combinations must be considered valid by the test space which means that all t wise tuples between the set of parameters must appear in the input test suite.
in reality such test suites rarely exist which significantly limits the application of this minimization approach.
indeed no case studies were presented in .
we redefine the itsm problem as a minimization of an arbitrary set of tests while allowing any relationships between the different parameters of the test space.
we thus turn itsm into a widely applicable approach as demonstrated by the case studies that we present.
vi.
c onclusions and future work in this paper we present interaction based test suite minimization itsm a test suite minimization approach that maintains the same coverage of value combinations as the existing set up to a certain user supplied interaction level t .
the approach is backed by an efficient and effective algorithm and evaluated using two case studies and further experimental results.in the future we plan to further validate the approach by studying actual fault detection reports and fault escape reports in order to substantiate the motivating claim regarding fault discovery effectiveness.
it is often impractical to actually run the original suite and compare its fault detection to that of the minimized one therefore we plan to also take into consideration escapes to the field.
another interesting future direction is that of multiple test suites.
in the second case study presented in section iv b above test suites for multiple products were considered both separately and in conjunction.
in the latter case where all tests were considered as one test suite to be minimized we observed that our minimization technique indeed considered tests from many different products.
however the distribution between them was not even and some products were completely left out.
in the future we plan to extend our algorithm to better reflect the distribution of tests from multiple separate sources.
interaction based test suite augmentation or enhancement is the process of adding tests to the existing test suite in order to achieve full interaction coverage .
while it suffers from the same requirements as ctd need for precise restrictions and for generating tests it does allow users to reuse their190existing tests and reduce the number of new tests to be generated typically at the price of a larger final test suite .
we plan in the future to compare the effectiveness of the three approaches ctd itsm and enhancement in terms of test suite sizes fault detection and costs as well as to explore possibilities of combining these approaches.
finally itsm requires that the set of existing tests be represented as tuples of values to parameters.
often however test suites are written in much less structured form from relatively structured spreadsheets to free text.
automatic or semi automatic tool support for translation of tests from such unstructured forms into tuples of parameter values would be significant for the applicability of the itsm approach.