a program differencing algorithm for verilog hdl adam duley intel corporation austin tx usa adam.r.duley intel.comchris spandikow ibm corporation austin tx usa spandiko us.ibm.commiryung kim the university of texas at austin austin tx usa miryung ece.utexas.edu abstract during code review tasks comparing two versions of a hardware design description using existing program differencing tools such as diffis inherently limited because existing program differencing tools implicitly assume sequential execution semantics while hardware description languages are designed to model concurrent computation.
we designed a position independent differencing algorithm to robustly handle language constructs whose relative orderings do not matter.
this paper presents vdiff an instantiation of this position independent differencing algorithm for verilog hdl.
to help programmers reason about the differences at a high level vdiff outputs syntactic differences in terms of verilog specific change types.
we evaluated vdiff on two open source hardware design projects.
the evaluation result shows that vdiff is very accurate with overall .
precision and .
recall when using manually classified differences as a basis of comparison.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering general terms algorithms measurement experimentation keywords program differencing change types empirical study hardware description languages verilog .
introduction hardware description languages hdls are pervasively used by engineers to abstractly define hardware circuitry.
verilog one of the most widely used hdls uses a c like syntax to describe massively concurrent tasks verilog statepermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.ments can represent parallel execution threads propagation of signals and variable dependency .
hardware projects are in a constant state of change during the development process due to new feature requests bug fixes and demands to meet power reduction and performance requirements.
during code review tasks hardware engineers predominantly rely on diffwhich computes line level differences per file based on a textual representation of a program.
using existing program differencing tools for verilog programs has several limitations.
first line based differencing tools for verilog programs report many false positive differences because the longest common sequence algorithm maps code in order and thus is too sensitive for languages that model concurrent computation.
this is not only the problem with line based differencing tools abstract syntax tree based differencing algorithms such as cdiff often match nodes in the same level in order making it unsuitable for programming languages where concurrent execution is common.
second unlike java methods or c functions processes such as always blocks i.e.
event handlers do not have unique labels.
thus existing differencing algorithms such as umldiff cannot accurately handle positionindependent language constructs when they do not have unique labels that produce one to one matching based on name similarity.
third while verilog programs frequently use boolean expressions to define circuitry existing algorithms do not perform equivalence between these boolean expressions despite the availability of a mature technology to solve a boolean formula satisfiability problem.
to overcome these limitations we have developed vdiff that uses an intimate knowledge of verilog syntax and semantics.
our differencing algorithm takes two versions of a verilog design file and first extracts abstract syntax trees asts .
traversing the trees top down at each level it uses the longest common sequence algorithm to align nodes by the same label and uses a weighted bipartite graph matching algorithm to find out of order matching between similar subtrees to handle position independent language constructs.
to complement syntactic differencing we use an off the shelf sat solver to compare two boolean expressions in the process interface description i.e.
the sensitivity list of verilog s always block .
furthermore to help programmers better understand ast matching results it outputs differences in terms of verilog specific change types see section .
for a detail description on change types .
vdiff is instantiated as an eclipse plug in and available for download.
we applied vdiff to two open source project histories and miryung software vdiff.htmlcompared its accuracy with manually labeled differences.
we also compared our algorithm with three existing ast matching algorithms measured the types of changes common in verilog and assessed the impact of using similarity thresholds in matching ast nodes.
in summary vdiff makes the following contributions vdiff uses a position independent differencing algorithm to robustly handle language constructs whose relative orderings do not matter such as statements with concurrent execution semantics.
vdiff produces accurate differencing results with .
precision and .
recall when using manually classified differences as a basis of evaluation.
vdiff outputs syntactic differencing results in terms of verilog specific change types to help programmers better understand the differences.
vdiff has several implications for the software engineering research community.
first the hardware design industry is facing challenges in evolving existing design artifacts just as the software industry is facing the problems of evolving software.
yet support for evolving hardware designs is very limited compared to evolving software.
our goal is to develop a foundation for reasoning about differences in hardware design descriptions to enable various hardware evolution research such as regression analysis of hardware designs change impact analysis etc.
second the algorithm in vdiff could be applied to any language that provides ordering independent language constructs.
the rest of this paper is organized as follows.
section presents a motivating example for verilog specific program differencing.
section discusses related work.
section presents our algorithm and section describes our evaluation methods and results.
section discusses vdiff s limitations and threats to validity.
section concludes with a discussion of future work.
.
motivating example verilog is a hardware description language in which statements and structures map directly to hardware circuitry and its behavior.
because gates operate concurrently verilog models concurrency explicitly by providing language constructs such as always blocks continuous assignments assign or non blocking assignments .
to illustrate the key features of verilog figure provides a simple example extracted from the uart rfifo.v file in the opencores uart project.
this code is a simple implementation of a fifo queue in verilog.
the key items to note in this example are the module the always blocks the continuous assignments assign and the non blocking assignments.
the module uart rfifo sinput and output declarations define which inputs are required for the module and which output signals it produces.
registers and wires regand wire can be considered to be field declarations in the module.
functional specifications can be written either as an initialization block initial a procedure block always or continuous assignments assign .
always blocks are process definitions that are re evaluated when specified event conditions become true.
for example always posedge clk or posedge wb rsti is evaluated when either the clkorwbrstisignal transitions from to due to posedge .
verilog provides two different types of assignments and .
the blocking assignment is similar to an assignment statement in c with sequential execution semantics while the non blocking assignment denotes a non blocking operation that executes simultaneously.
in verilog nonblocking assignments are generally more common than blocking assignments.
thus inside the first always block the registers top bottom and count are all set to simultaneously unlike c. in other words the order in which top bottom and count are declared does not matter as long as they are in the same control hierarchy.
an ideal program differencing tool for verilog must not detect such reordering of non blocking statements as it does not change the execution semantics.
similarly the order of the always blocks does not matter because all always blocks are executed simultaneously.
likewise all continuous assignments assign in a module operate concurrently.
to draw an analogy between c like languages and verilog one may claim that each always block is treated like a function.
this idea however falls short since multiple blocks can be triggered by the same event list meaning that one cannot assume that each always block has a unique label.
figure contrasts what a human would consider to be differences and line level differences computed by diff added lines are marked in red text with and deleted lines are marked in blue text with .
in this code example the always blocks are reordered the two non blocking statements are reordered and the arguments in the first always block s sensitivity list are reordered.
a human will recognize that despite textual differences there are no semantic differences between the two versions.
however diffwill report several false positives addition and deletion of the second always block additions and deletions of two nonblocking assignments and addition and deletion of the second always block s sensitivity list.
furthermore as diff cannot recognize verilog syntax it will report differences that do not respect the boundaries of each always block.
the following list summarizes the unique characteristics of verilog from a program differencing perspective.
verilog models concurrent executions by using constructs such as non blocking assignments processes and continuous assignments.
thus ordering sensitive differencing algorithms designed for sequential execution semantics will report many false positive differences.
in verilog processes do not necessarily have unique labels even though it is thought to be a bad practice to use the same name for multiple processes.
thus differencing algorithms cannot rely on mapping code elements solely based on name similarity.
frequent usage of boolean expressions in verilog provides an opportunity to leverage a sat solver to compare process interface descriptions i.e.
sensitivity lists .
.
related work matching corresponding code elements between two program versions is a fundamental building block for version merging regression testing selection and prioritization and profile propagation.
existing differencing techniques often match code elements at a particular granularity based on include uart defines.v module uart rfifo clk wb rst i data in push pop data out overrun input clk output data out reg count wire top plus 1 top b1 ... always posedge clk or posedge wb rst i begin top bottom count fifo fifo ... end always always posedge clk or posedge wb rst i begin if wb rst i overrun b0 else if fifo reset reset status overrun b0 else if push pop count fifo depth overrun b1 end always assign data out fifo endmodule include uart defines.v module uart rfifo clk wb rst i data in push pop data out overrun input clk output data out reg count wire top plus 1 top b1 ... always posedge clk or posedge wb rst i begin if wb rst i overrun b0 else if fifo reset reset status overrun b0 else if push pop count fifo depth overrun b1 end always always posedge wb rst i or posedge clk begin top bottom count fifo fifo ... end always assign data out fifo endmodule figure line level diffresults and expected differences between two versions of a verilog program figure vdiff s output in eclipse idecloseness in name and structure such as lines and tokens abstract syntax tree nodes control flow graph nodes etc.
in the context of hardware development with hdls the state of thepractice in comparing two versions of verilog program is to use gnu diff or a graphic front end to diff which provides a side by side visualization that highlights deleted or added lines with different colors and provides navigation capability to review particular differences .
these line based differencing tools use the longest common subsequence algorithm that aligns program lines in sequence .
for software version merging yang developed an ast differencing algorithm.
given a pair of functions ft fr the algorithm creates two abstract syntax trees tandrand attempts to match the two tree roots.
once the two roots match the algorithm aligns t s subtrees t1 t2 ... t iandr s subtrees r1 r2 ...r jusing the lcs algorithm and maps subtrees recursively.
this type of tree matching respects the parent child relationship as well as the order between sibling nodes but is very sensitive to changes in nested blocks and control structures because tree roots must be matched for every level.
for dynamic software updating neamtiu et al.
built an ast based algorithm that tracks simple changes to variables types and functions.
neamtiu s algorithm assumes that function names are relatively stable over time.
it traverses two asts in parallel matches the asts of functions with the same name and incrementally adds one to one mappings as long as the asts have the same shape.
in contrast to yang s algorithm it cannot compare structurally different asts.
cottrell et al.
s breakaway automatically identifies detailed structural correspondences between two abstract syntax trees to help programmers generalize two pieces of similar code.
its twopass greedy algorithm is applied to ordered child list properties e.g.
statements in a block and then to unordered nodes e.g.
method declarations .
change distiller takes two abstract syntax trees as input and computes basic tree edit operations such as insert delete move orupdate of tree nodes.
it uses bi gram string similarity to match source code statements such as method invocations and subtree similarity to match source code structures such as if statements.
after identifying tree edit operations change distiller maps each tree edit to an atomic ast level change type such as parameter ordering change .
vdiff uses an approach similar to change distiller in that we identify similar subtrees by computing similarity measures and find the best matching among similar subtrees by selecting matches with the highest similarity one at a time.
in addition we also report ast level matching results in terms of verilog specific change types.
raghavan et al.
s dex compares two ordered asts using both top down matching and bottom up matching.
this algorithm gives preferences to ast node matches in the same level that do not results in moving or reordering nodes.
dex defines edit cost using fixed numbers instead of similarity between ast node labels.
the main difference between our ast comparison algorithm and existing ast matching algorithms is that our algorithm identifies syntactic differences robustly even when multiple ast nodes have similar labels and when they are reordered.
in addition to these several differencing algorithms compare model elements .
for example umldiff matches methods and classes between two program versions based on their name.
however these techniques assume that no code elements share the same name in a program and thus use name similarity to produce one to one code element matches.
our algorithm differs from these by not relying on one to one matching based on name similarity.
as different language semantics lead to different program differencing requirements some have developed a general meta model based configurable program differencing framework .
for example sidiff allows tool developers to configure various matching algorithms such as identity based matching structure based matching and signaturebased matching by defining how different types of elements need to be compared and by defining the weights for computing an overall similarity measure.
sudakrishnan et al.
studied the types of bugs that occur in verilog and compared those findings to a similar study in java.
they presented a categorization of changetypes that caused bugs and how often they occurred and found that the most common bug pattern was changes to assignment statements and if statements.
in our work we extended sudakrishnan s change types by adding changetypes to comprehensively describe code changes in two open source verilog projects that we studied.
while sudakrishnan s change type analysis is largely manual our program differencing tool automatically identifies change type level differences between two program versions.
.
approach vdiff accepts two versions of a verilog design file and outputs syntactic differences in terms of verilog specific change types.
it uses a hybrid program differencing approach that performs a syntactic comparison of two abstract syntax trees while checking semantic equivalence in limited cases using an off the shelf sat solver.
section .
discusses our abstract syntax tree matching algorithm that accounts for concurrent execution semantics such as non blocking assignments.
section .
presents verilog specific change types which are designed to help programmers better understand ast level matching results.
this section also describes when and how our algorithm performs a semantic comparison using a sat solver.
section .
describes our vdiff eclipse plug in.
.
position independent abstract syntax tree differencing our algorithm shown in algorithm takes as input the old and new versions of a verilog module and two thresholds used for determining text similarity.
for each verilog module it extracts an abstract syntax tree using the verilog syntax parser module provided by the veditor plugin .
then it marks ast nodes that correspond to nonblocking assignments continuous assignments and always blocks.
marking these nodes allows for the matching algorithm to carefully handle semantically equivalent reordering of such nodes.
the resulting abstract syntax tree allows certain concurrent nodes to be arranged in any sequence inside a module.
figure shows an example ast where unordered children are marked with a dotted edge.
once the trees landr are built for each file foandfn they are compared hierarchically from the top down using comparetrees .
the initial comparison is done by aligning nodes in the same level by the same labels using the longest common subsequence algorithm .
any unmatched nodeinris added to add and any unmatched node in lis added to del .
the step is recursively applied to all children of the matching nodes.
algorithm position independent ast matching input fo fn old and new versions ths thl similarity thresholds for short text and long text output add a set of nodes added to fn del a set of nodes deleted from f map a set of mapped node pairs l createast fo r createast fn add del map candidate comparetrees l r map add del findcandidate add del candidate thl ths repeat identify a weighted bipartite matching by selecting a candidate match with the highest likeness value and updating add and del accordingly candidate sort candidate foreach p candidate do ifp.a add andp.d del then map map p.a p.d comparetrees p.a p.d m a d add add p.a del del p.d removematches candidate p remove candidate matches that include p.aor p.d end add add a del del d map map m end findcandidate add del candidate thl ths until candidate negationslash interpret map add del function comparetrees l r m d a align land r s subtrees using the longest common subsequence algorithm based on their labels map alignlcs l s first level subtrees r s first level subtrees foreach l l s first level subtrees do ifl map .left then del del l end foreach r r s first level subtrees do ifr map .right then add add r end foreach l r map do comparetree l r map del add end once the initial add anddel have been populated the algorithm then tries to match nodes from add anddel using a greedy version of a weighted bipartite graph matching algorithm.
first for each pair in the cartesian product ofadd anddel we compute the pair s weight using the text similarity algorithm in umldiff which computes how many common adjacent character pairs are contained in two compared strings.
the weight calculation is based on the full content of the node s subtree.
for example when considering an always block node the text of its block declaration and its body is used.
if the similarity value is above a required threshold and the nodes are of the same syntactic type such as an always block mapping to an always block we add the pair to the set of potential matches candidate .function findcandidate a d candidate thl ths foreach a add do foreach d del do likeness textsimilarity a d if a.text.length or d.text.length and likeness th l or a.text.length and d.text.length and likeness th s then candidate candidate a d likeness end end end when computing text similarities we use two different thresholds.
for text that is less then characters a lower threshold thsis used because small changes have a relatively larger effect on the similarity calculation.
while most single line statements are kept under characters process blocks tend to be multi line statements requiring a larger threshold value to ensure a quality match.
once all pairs in add del have been evaluated the potential match set candidate is sorted in descending order based on the pair s text similarity.
then we use a greedy algorithm to select a subset of candidate .
in each iteration we take the highest weighted pair and add it to the set of matched nodes map and update candidate by removing all candidate matches that include either the selected pair s left or right hand side.
the children of the matched pair are recursively compared to find any more additions deletions or matches.
at the end of the iterations add del and candidate are updated to account for newly matched nodes.
this iteration continues until no new candidate matches are found.
for each pair a d inmap if the full text of a matches the full text of dexactly they share the same parent and their execution orders do not matter i.e.
always initial generate assign and then the pair is removed from map and marked as unchanged.
.
change types for verilog in order to provide differencing results at a higher abstraction level than simply listing add del and map we output syntactic differences in terms of change types.
this classification can potentially help users understand the differences quickly by providing a set of categories that the hardware designer can easily identify with.
furthermore change classification can enable quantitative and qualitative assessments of frequent change types in verilog by providing a detailed uniform description of code changes.
the initial set of change types are motivated from sudakrishnan s change types .
by manually inspecting all versions of opencores project uart16550 and the dram memory controller of the ramp project see section we created a new change type if the change did not fit within the classification list.
the resulting list of change types is shown in table .
each of the major categories in the list has to do with a specific syntactic element in verilog.
for example ifdeals with ifstatement mdand mideal with module declarations and instantiations respectively asg focuses on assignment statements alfocuses on always blocks etc.
figure shows an example of ifccand ifrmv changes.
as a part of a post processing step where vdiff interprets the matching results between two abstract syntax trees astable change types for verilog programs syntactic pattern description element always aladd always block added alrmv always block removed alse changes in the sensitivity list assignment asg add continuous assignment added statement asg ce continuous assignment changed asg rmv continuous assignment removed blocking badd blocking assignment added assignment bce blocking assignment changed brmv blocking assignment removed non blocking nbadd non blocking assignment added assignment nbce non blocking assignment changed nbrmv non blocking assignment removed if statement ifabr addition of else branch ifapc addition of if branch ifcc change of if condition expr ifrbr removal of else branch ifrmv removal of if branch switch swabrp changes to switch hierarchy statement swcadd addition of a case branch swcrmv removal of a case branch swchg changes to condition module mdchg changes in port type width declaration mddnp different number of ports module miadd module instantiation added instantiation mirmv module instantiation removed midcp different ports values midnp different number of ports midtyp different types initialization init add initial block added init rmv initial block removed parameter param add parameter added param chg parameter changed param rmv parameter removed register rgadd register added rgchg register changed rgrmv register removed wire wradd wire added wrchg wire changed wrrmv wire removed pre processor pattern description directives define define add define added define chg define changed define rmv define removed ifdef ifdef add ifdef added ifdef chg ifdef changed ifdef rmv ifdef removed include inc add include added inc rmv include removed generate gen add generate block added gen rmv generate block removed gen chg generate block changed others nc formatting changes figure ast of uart rfifo.v from figure 1verilog specific change types it refines the results in limited cases by extracting boolean expressions from ast nodes and checking their equivalence using a sat solver.
we used the sat4j public java library which takes boolean formula in a conjunctive normal form cnf and proves whether there exists a set of inputs that can satisfy the formula .
this is similar to person et al.
s differential symbolic execution technique in that syntactic differencing is complemented by using a decision procedure for checking semantic equivalence.
while person et al.
s technique computes symbolic summaries at a method or block and check equivalence between two methods vdiff checks equivalence between sensitivity lists i.e.
verilog s process interface descriptions written in boolean logic and does not perform extensive symbolic execution like person et al.
s technique.
for example the first always block sensitivity list in figure was reordered between versions.
from a syntactic point of view there has been a definite change to the sensitivity list however the change has no effect on the operation of the always block because the modified list is equivalent to the original list for every possible set of input signals.
we currently focus on checking changes to an always block sensitivity list alse to see if the original and modified lists areboolean equivalent .
in the future version of vdiff we plan to extend our sat solver based semantic comparison to include boolean expressions in blocking and non blocking assignments continuous assignments and if conditions.
.
vdiff eclipse plug in we implemented our differencing algorithm as an eclipse plug in.
the plug in is available for download.
vdiff plugin compares program revisions retrieved from a subversion repository using the subclipse interface .
figure shows the screen snapshot of our vdiff plug in.
its tree view visualizes ast matching results hierarchically its text view presents textual differences between two program versions using the eclipse compare plug in and its console outputs change type level differences with a pointer to word level differences.
for example changes to the sensitivity list are identified as textual differences in the side by side view but they are reported as alse sensitivity list changes .
as reordering input signals in the sensitivity list does not lead to any semantic differences the change is marked as boolean equivalent .
.
evaluation our evaluation addresses the following research questions rq1 what is the overall accuracy of vdiff in computing change type level differences?
rq2 how does vdiff s ast matching algorithm compare to existing ast matching algorithms?
rq3 what is the impact of using similarity thresholds in matching ast nodes?
subject programs.
to evaluate vdiff we acquired data from two verilog projects uart16550 and gatelib s dram controller project .
the uart16550 project contains the design for the core logic of a serial communication chip which provides communication capabilities with a modem or other external devices.
we also analyzed the ramp project s gatelib dram controller.
ramp is an infrastructure used to build simulators using fpgas.
to be abletable subject programs uart16550 gatelib loc files check ins avg.
modified lines .
.
avg.
modified files .
.
to access memory uniformly independent of a chosen platform gatelib s dram controller provides an abstract interface which includes a standard dram interface arbiter asynchronous adapter and remote memory access.
to evaluate the accuracy of vdiff output we created an evaluation data set through manual inspection.
we examined the individual svn diff s outputs and manually classified them into change types.
vdiff ran on the same version histories and produced change type level differences.
running vdiff took .
second per revision on average in comparison to .
second on average when running gnu diff on intel core duo thinkpad ghz with .
gb of ram running windows xp.
vdiff s output was then compared to the manually created evaluation data set.
.
precision and recall suppose that vis a set of change type level differences identified by vdiff and eis a set of manually identified change type level differences.
precision and recall are defined as follows precision the percentage of vdiff s change type level differences that are correct v e v recall the percentage of correct change type level differences that vdiff finds v e e .
figure shows the results on uart16550 project s check ins and gatelib project s check ins.
each row reports the number of revisions per file the size of an evaluation data set i.e.
manually inspected change types e the number of change type level differences reported by vdiff v the number of correct differences reported by vdiff v e and precision and recall per file.
our evaluation shows that vdiff is extremely accurate for most modules its precision and recall are .
and .
on uart16550 and .
and .
on gatelib s dram controller.
the inability to match nodes due to low text similarity led to false positives incorrect differences found by vdiff v e and false negatives correct differences that vdiff could not find e v .
figure shows an example of both false positives and false negatives.
in this example three changes were made an extra condition rstate sr idle was added before setting counter b ifcc the condition for decrementing count bwas modified by removing counter b !
hff ifcc and the else block with the rxlsrmask condition was removed ifrbr .
since the text similarity algorithm used by vdiff considers the first if condition different enough from its original the change is actually classified as a removal of an if statement ifrmv with an addition of a new if statement ifapc .
thus vdiff reports two incorrect change type level differences ifrmv ifapc and misses three expected differences as a result ifcc if cc if rbr .
to understand the types of changes common in verilog we plotted the distribution of identified change types in figure .
the two projects we analyzed had very different charac teristics uart16550 had a significant number of core logic changes during its development whereas gatelib s dram project evolved its abstract interface while hiding the actual implementation of the platform specific dram implementation.
in the uart16550 design changes were frequently made to non blocking assignments registers and always blocks.
gatelib project had many changes to generate blocks and parameters.
ubiquitous changes observed across both projects were wire additions changes to module instantiation ports and changes to assignments.
we hypothesize that by producing accurate syntactic differences in terms of change types verilog developers can better understand differences at a high level of abstraction.
we demonstrated vdiff to an engineer with years of experience in verilog.
the designer told us i can see a use for right away.
it would be great for team leads because they could look at this log of changes and understand what has changed between versions without having to look at the files .
we plan to study how engineers use vdiff on their codebase measure its accuracy with respect to the differences expected by the engineers and improve vdiff s algorithm based on their suggestions.
.
comparison of ast matching algorithms to assess the effectiveness of our weighted bipartite graph matching algorithm in matching ast nodes in the same level we constructed two alternative algorithms by borrowing ideas from existing ast matching algorithms .
.exact matching this is the most na ve version of ast matching algorithm that finds corresponding nodes in the same level using the exact same label.
it has the same effect of using neamtiu et al.
s ast matching algorithm that traverses two trees in parallel and matches corresponding nodes by the same label in the same syntactic position in the trees.
.in order matching this algorithm finds corresponding nodes in the same level in order it starts by examining each node in the left tree in order and searching a node in the right tree with the highest similarity.
this algorithm has the same effect of using the cottrell et al.
s ast matching algorithm which determines ordered correspondences between two sets of descendant nodes by considering nodes in the left tree in turn and finding the best corresponding node in the right tree using a linear search.
.greedy weighted bipartite matching our algorithm finds corresponding nodes in the same level using a weighted bipartite graph matching algorithm .
table shows the comparison of the precision and recall of in order matching algorithms column and column2 with our weighted bipartite matching which relaxes the constraint of linear search to prevent early selection of a match that leads sub optimal matching column .
as shown in table our algorithm improved the precision by .
and the recall by .
compared to the baseline column and improved the precision by .
and the recall by .
compared to an in order matching based on similar labels column .
this evaluation of differences from file revisions in two real world projects shows that the ordering of code actually matters in practice when it comes to computing differences between program versions.file revisions loc evaluation vdiff v e precision recall min max e v v e v v e e raminfr.v timescale.v uart debug if.v uart defines.v uart receiver.v .
.
uart regs.v .
.
uart rfifo.v uart sync flops.v uart tfifo.v uart top.v uart transmitter.v uart wb.v .
total uart .
.
dram.v .
.
dramarbiter.v .
.
dramarbiterinner.v .
.
dramexaminer.v .
.
dramrouter.v .
.
total gatelib .
.
total .
.
figure precision and recall of vdiff on subject programs ths .65and thl .
expected differences vdiff outputs old if !srx pad i if cc counter b d191 else if counter b !
b0 counter b !
hff if cc counter b counter b d1 else if rx lsr mask counter b hff if rmv if !srx pad i if rbr counter b d191 else if counter b !
b0 counter b !
hff counter b counter b d1 else if rx lsr mask counter b hff new if !srx pad i rstate sr idle if cc counter b d191 else if counter b !
b0 if cc counter b counter b d1 if !srx pad i rstate sr idle if apc counter b d191 else if counter b !
b0 counter b counter b d1 figure vdiff reported ifapcand ifrmv when two ifccs and one ifrbr were expected.
code with red shade represents removal code with gray shade represents modification and code with blue shade represents addition.
al add al rmv al se asg add asg ce asg rmv b add b ce b rmv nb add nb ce nb rmv if abr if apc if cc if rbr if rmv sw abrp sw cadd sw chg sw crmv md chg md dnp mi add mi rmv mi dcp mi dnp mi dtyp init add init rmv param add param chg param rmv rg add rg chg rg rmv wr add wr chg wr rmv define add define chg define rmv ifdef add ifdef chg ifdef rmv inc add inc rmv gen add gen chg gen rmv nc dram uart figure frequency of change typestable comparison between different algorithms for matching sibling nodes average label in order weighted matching matching bipartite precision .
.
.
recall .
.
.
in addition we also compared vdiff with the emf configurable program differencing framework by adapting it to work for verilog.
we mapped modules in verilog to classes always blocks and continuous assignments to operations wires registers and ports to fields and module instantiations to reference pointers in an emf ecore model.
on the same uart data set the emf compare tool reported the .
recall with the .
precision because the emf ecore modeling language could not model the implementation of always blocks including blocking and non blocking statements.
.
impact of similarity thresholds our algorithm uses ths threshold for short text and thl threshold for long text to determine the similarity between two ast subtrees.
if the similarity is above an input threshold then the difference will be classified as change otherwise they are considered an add or a delete.
we assessed the impact of these similarity thresholds by incrementing thsby .
from .
to .
while setting thlto its default value .
.
we also incremented thlby .
from .
to .
while setting thsto .
.
figures and show the resulting accuracy of varying these thresholds on theuart receiver.v file during its entire revision history.
the f measure is also plotted to reason about precision and recall together precision recall precision recall .
precision and recall generally increase as thsincreases due to more strict matching requirements.
if thsis too low unrelated nodes are incorrectly matched and reported as changes instead of additions and deletions adversely affecting accuracy.
however when thsreaches around .
its precision and recall decrease as the threshold requirement becomes too strict and many unmatched nodes are considered additions and deletions instead of expected changes.
the fmeasure reaches the maximum when thsis .
.
varying thl follows a similar trend for similar reasons.
however matching large blocks requires a more strict threshold for correct matching to occur as illustrated by the increase in precision from .
to .
.
the f measure reaches the maximum when thlis around .
and .
.
.
discussion this section discusses our vdiff algorithms limitations threats to validity and extensions necessary for applying vdiff to other hardware description languages.
limitations.
though we use two different thresholds our algorithm is still sensitive to subtle changes to variable names or if conditions and requires careful tuning of similarity thresholds.
further investigation of different name similarity measures such as n gram based matching is required.
renaming wires registers and modules often causes cascading false positives and false negatives by incorrectly matching ast nodes at a top level.
renaming detection techniques could be used to overcome this limitation.
the current algorithm cannot recover from mismatches at atop level as it matches parent nodes before matching their descendants.
the equivalence check using a sat solver is currently limited to only sensitivity lists and we plan to extend this check to all types of boolean expressions.
veditor struggled with parsing pre processor directives consequently we worked around ifdefs by creating a version where the if branch is true and another version where the else branch is true.
we first computed differences for these two versions separately and later merged the results to help programmers understand syntactic differences under two possible circumstances.
our results on precision recall and frequent change types are limited to uart and gatelib and do not necessarily generalize to other projects.
in addition the construction and manual identification of change types are subject to experimenter bias as they are done by the first two authors of this paper who have nine and six years of hardware design experience in industry respectively.
application of vdiff to other hdls.
while verilog is the most widely used hdl two other hdls are also prevalently used systemverilog and vhdl.
systemverilog extends the verilog standard to include several features commonly found in modern object oriented programming languages multi dimensional arrays enum data types struct union strings classes with inheritance assertions and synchronization primitives.
many of these features in systemverilog cannot be directly mapped to hardware circuitry but could be used for verification and simulation.
vhdl was initially developed in the 1980s around the same time verilog was created and it has features similar to ada.
vdiff could be easily extended to other hdls by plugging in a different parser and handling new change types such as changes to struct orenum in systemverilog.
.
conclusion most program differencing algorithms implicitly assume sequential ordering between code elements or assume that code elements can be matched based on their unique names regardless of their positions such as reordered java methods.
this limitation leads to poor accuracy when these techniques are applied to languages such as verilog where it is common to use non blocking statements and there is a lack of unique identifiers for process blocks.
this paper presented a position independent ast matching algorithm that is robust to reordering of code elements even when their labels are not unique.
based on this algorithm we developed vdiff a program differencing tool for verilog.
our evaluation shows that vdiff is accurate with a precision of .
and a recall of .
when using manually classified differences as a basis of evaluation.
acknowledgment we thank greg gibeling and derek chiou for providing accesses to the ramp repository and adnan aziz and anonymous reviewers for their detailed comments on our draft.
.