pie programming in eliza xiao liu college of information sciences and technology the pennsylvania state university xvl5190 ist.psu.edudinghao wu college of information sciences and technology the pennsylvania state university dwu ist.psu.edu abstract eliza a primitive example of natural language processing adopts a rule based method to conduct simple conversations with people.
in this paper we extend eliza for a novel application.
we propose a system to assist with program synthesis called programming in eliza pie .
according to a set of rules pie can automatically synthesize programs from natural language conversations between eliza and users.
pie is useful for programming in domain specific languages.
we have implemented pie to synthesize programs in the logo programming language and our experimental results show that on average the success ratio is .
for synthesizing logo programs from simple conversations with eliza.
pie also enables end users with no experience to program in logo with a smoother learning curve.
categories and subject descriptors i. .
i. .
natural language processing h. .
general terms design languages keywords eliza logo program synthesis natural language rule based .
introduction eliza is an early example of natural language processing that serves as a psychotherapist to interact with patients .
based on a rule based method eliza makes simple conversations with people in natural language.
flexibly people try to communicate with eliza in sentences with few constraints and eliza responds according to a set of rules based on keywords.
with such a system of intelligence we make an extension for a new application called programming in eliza pie with the assistance of which programs in target programming languages will be synthesized from the natural language commands provided by users.
pie demonstrates a new way for program synthesis.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
synthesis is a concept that comes from the earlier automatic programming the fundamental of which relies on the mechanical theorem proving techniques .
however the problem of automatic programming is much broader than expected since the proof of theorems involving existential quantifiers scarcely succeeds.
in this case some constraints have been appended to the automatic programming which is gradually considered as program synthesis .
program synthesis is more likely a concept that defines the automation of programs in some specific domains such as robotics and spreadsheet programming .
because of the versatility and applicability natural language programming has been widely discussed as an easy way for novices to learn how to program .
however the realization of natural language programming is based on ai complete which means that the machine is required to understand every natural language description.
definitely this goal has not been achieved yet but it is feasible for machine to partially understand people especially in a typically area.
thus in a specific domain programming in natural language is viable.
additionally smart devices perform better with natural language as the input.
v oice input has indeed advanced gradually in recent years.
however the accuracy of recognition for programming languages is still low .
for example for int i equals zero i less than ten i plus plus which should be translated into for int i i i is usually recognized as int eye equals aye less then ten i plus plus .
in this case when we target at coding with smart devices the accuracy of voice recognition of programming language cannot meet the bottom line.
but things may change when you say let s start a loop with integer i from to add in each turn .
the recognition accuracy can be much higher.
thus the demand for programming in natural language arises again.
aiming at lowering the entrance bar for novice programmers or children who cannot program we propose a domain specific program synthesis system called programming in eliza pie .
pie interactively takes natural language conversations from users and synthesizes programs in the logo programming language to draw graphs.
figure illustrates the working flow of the pie system.
the system consists of three parts eliza pie script and logo.
the core lies in the pie script which can be seen as a connector between the other two.
this script processes the natural language descriptions from users and synthesizes programs in the logo programming language which will be executed by the logo module.
meanwhile it provides a feedback in natural language to users via the eliza module.
with the proposed system we make the following contributions we propose a novel way for domain specific program synthesis based on eliza and recall the importance of natural language programming with gradually mature techniques in nlp and easy access to programming devices for end users.
we have realized program synthesis in the logo programming language from english conversations between users and computers.
programs can be synthesized with few constraints on the input natural language commands.
figure the pie system architecture we have achieved a preliminary step in natural language programming for education use.
program logic can be learned by end users with no experience during the interaction with the pie system regardless of using complicated programming languages like c or java.
the rest of this paper is structured as follows.
we first summarize the background of the pie system eliza and logo.
then we demonstrate an example to illustrate a complete working flow of the pie system.
next we introduce the pie script used in this specific domain that we design and elaborate the key techniques for program synthesis in our system.
to evaluate the system we use learning efficiency and success ratio.
related work and conclusion are presented in the last two sections.
.
background in this section we introduce the background on eliza and the logo programming language.
.
eliza and rule base method eliza a primitive prototype of natural language processing plays the role of a psychotherapist to communicate with patients .
the input sentences are processed with a pre defined script where there are two basic types of rules the decomposition rules and reassemble rules.
decomposition rules are made up of different combinations of keywords and for each decomposition rule there are a couple of reassemble rules corresponding to it.
when a sentence is typed in it will be decomposed into pieces according to the decomposition rules and then based on one of the reassemble rules a response in natural language will be generated automatically.
following is an example of how eliza works input it seems that you hate me.
decomposition rule any words you any words me .
decomposition it seems that you hate me.
reassemble rule what makes you think i you .
output what makes you think i hate you?
although eliza belongs to the first generation nlp techniques using a rule based method to understand users it works quite well in specific domains.
in this paper we extend eliza for a novel application program synthesis in the logo programming language.
.
logo logo is a graphic oriented education programming language .
the well known application of logo is the turtle graphics in which there is a turtle on the screen and commands from users will move the turtle in various ways and the trace left will be a special designed graph.
for example if a child wants the turtle to move forward steps she may use the command forward .
table shows the program with four lines of commands that can draw a square with the turtle.
in this paper we aim at building a system to automatically generate programs in the logo programming language.
to demonstrate the idea we have implemented a prototype called pie programming in eliza with python turtle to synthesize logo programs from natural language conversations in eliza.english logo commands draw with a black pen color black do this times repeat move forward paces drawing forward turn right degrees right table web turtle tutorial example draw a square .
example in this section we motivate our system with the same example from a web turtle tutorial as described in table .
the objective is to generate logo programs when the input are sentences in natural language with few constraints.
as described in table the user would like to draw a square in black with the turtle but it is her first time to program with logo.
however she knows that if she wants to draw a square in black she needs to pick up a black pen to draw four straight lines and make a degree turn after each line.
thus if she is allowed to manipulate the turtle in a natural language one possible description is .draw with a black pen .do this times .move forward paces drawing .turn right degrees every time a command in natural language is received by pie it will be decomposed word by word into text chunks denoted w1 w2 w n .
in the next step the lexical analysis will be conducted with the assistance of the pie script.
each of these text chunks will be tagged with a pre defined token in the pie script for example the predicate token or the number token by adopting regular expression matching.
then the analyzed sentence will be easily parsed into a structure.
for instance if all the descriptive sentences in the example are analyzed the structure of each sentence will be like this draw with a black pen predicatetok redundanttok numbertok do this times predicatetok redundanttok numbertok keywordtok move forward paces drawing redundanttok predicatetok numbertok redundanttok turn right degrees predicatetok keywordtok numbertok redundanttok in the following step the logo program will be synthesized based on the structure.
it is a many to one mapping from the natural language structures to a particular predicate in logo.
for each predicate token which can be treated as the key function words we can select the class of mapping rules.
mapping rules in one class contain the same predicate.
however there are more than one logo command for each predicate.
to synthesize the correct logo command for the input natural language instruction the structure of the sentence then plays a part.
the last step for the logo program synthesis is the substitution of parameters in the incomplete programs from .
in this step incomplete programs will be parsed by rule sequence and meanwhile the parameters in these commands will be substitute with the tokens from the input sentences.
.
pie script we have designed the pie script from an extensive study of the descriptions in natural language for each command in the web turtle from various online logo language tutorials.
note a script is a set of decomposition and reassemble rules defined in eliza.
.
pie logo pie logo is a domain specific language that can be ported to other platforms via syntax directed translation.
pie logo maintains the context free feature of the logo programming language.
the syntax of pie logo is shown in figure .
in pie logo we usesto denote a complete statement which consists of two parts predicate and parameter i. the parameter can be numbers directors or color names extracted from the natural language.
it can be omit when users forget to include some parameters in their descriptions.
such as draw a line with no mention of the length 696statements jt ijt parameteri numberjdirectionjcolor omission numberjdirectionjcolor predicate predicate a a2 ... an repeatr s j foreachx2a dos1 s2 ... sn od transformt t1 t2 ... tn t transform a jtransform i argumenta input a a2 ... an figure the syntax of pie logo or make a right turn without a concrete degree.
the transformer t a part of the eliza mechanism transforms predicates or parameters with the same meaning into a regular expression.
the repeat rdenotes loops in pie logo and adenotes input arguments.
the following examples describe the natural language commands and their corresponding synthesized scripts according to which we can achieve a better understanding of the pie script that we defined.
.
.
statement use a blue pen!
s pencolor blue transform blue .
.
function go forward steps turtle!
then turn left.
let step1 include the last two commands!
s1 forward number number s2 turn direction direction left step last number last foreach ninnumber step step1 last .
.
repeat repeat step1 four times s foreach ninnumber dostep1 number .
key components normally in each statement there are three key components predicate parameter and transform.
predicate the predicate is one of the most important components in the script and it represents the predicates in the logo programming language.
these predicates correspond with verbs in natural language commands for instance move ahead will be translated to forward let the color of the pen be will be translated to pencolor .
these predicates in the pie script are later mapped into the operators in the target languages using predefined rules.
parameter the parameter represents the object of the related predicate or the status of the object.
for example in forward or blue in pencolor blue .
parameters are identified using regular expression matching.
transform this component comes from the eliza mechanism as it categorizes predicates or parameters with the same meaning into a dedicated one.
for example move ahead go forward move on will all be translated to forward .
this component plays an important role in the semantic analysis of natural language commands.
.
synthesis techniques our goal is to map commands in natural language into pielogo which means after the decomposition of each sentencetoken regular expression number token d color token d s direction token leftjright predicate token forwardjbackwardjrepeatj... table regular expression matching move forward steps!
please go forward steps!
can you go straight on for steps!
move ahead steps little turtle!
turtle go ahead for steps!
move forth steps!
let s go forth steps!
move to the front steps!
go up for steps!
table natural command mapped to predicate forward in natural language every chunk can be mapped into a token in our script when we parse the sequence of tokens which is the result from the syntax analysis pie script is capable of handling all the possible syntax structures.
both tasks are quite complicated to be tackled.
this section elaborates on the techniques adopted in the pie system and the design of the pie script.
.
regular expression matching to perform lexical analysis we adopt regular expression matching.
taking advantage of regular expressions we are able to extract tokens like predicate token orparameter token in each command in english.
a set of regular expressions are designed manually to match all the structures consist of tokens.
in eliza the system recognize a sentence by using keywords but our system adopts regular expressions.
the regular expression matching in pie assists the system to analyze the syntax of the natural language and then each chunk of the natural commands is mapped into a token in the pie logo.
to some extent keywords matching can be seen as a special regular expression matching however eliza does not parse the input natural sentences into structures.
another advantage of regular expression matching in pie is that without a strictly designed ranking of the rules the matching process can be completed in linear time with respect to the size of the input sentence.
some examples of regular expressions and their corresponding tokens are shown in table .
.
mapping rules we have designed a set of rules to map natural language commands into pie logo.
as we described in the example programs in pie logo can be synthesized based on the parsed structure.
we generate a group of natural language commands by ourselves for each predicate.
table shows some specific examples of the natural commands that can be mapped into the forward function class.
as far as the contents in this table are considered it indicates that there are many expressions in natural language which have the same semantic meaning because of synonyms.
different verbs in natural language are used in these sentences but the structures are similar.
under this circumstance we adopt transform t which is borrowed from the eliza system to categorize predicates or parameters with the same meaning into a dedicated one.
take the forward class as an example move forward go forward move ahead go ahead go forth move to the front and go up are of the same semantic meanings.
thus they can be categorized into the same forward class and they can be replaced by the predicate forward .
based on the penguin edition of rogers thesaurus of english words and phrases we maintain a dictionary of words that can be transformed to tackle the challenge from synonyms.
the design enables pie to process flexible natural language syntax.
.
.
rule ranking since the number of the rules for the mapping function is large it is desirable to apply some ranking in the rule sequence to improve n forward a line of nd n in length n forward a line of nd n long n nd n forward n n forward n nd n n nd forward n n nd n forward n forward n nd n forward nd n table mapping rules to the forward class the effectiveness of the pie system.
we rank the rules in two steps by predicate order by complex order.
predicate order rules with the same predicate will be categorized into a class and then we sort the classes according to the frequency of the predicate occurrence.
we collected real logo commands from different logo programs among the most popular ones from web turtle and count the frequencies of each predicate.
for example by frequency order forward stays ahead of pencolor and thus the rule move forward nd n stays before the rule n color of the pen n n .
complexity order rules in the same class are sorted by the complexity order.
the rule with more tokens or redundant tokens are of more complexity.
for example for the forward class move forward nd n stays before n forward nd n .
this ranking algorithm not only helps shorten the time but also improves the accuracy of mapping.
.
.
rule prune at the very beginning we used the descriptions of online logo tutorials as the data set together with our own experience according to which we designed the first set of rules.
however there are many redundant rules in this set.
for example move forward nd n and go forward nd n are two rules at the very beginning.
after the rule prune these two can be merged into one n forward nd n .
to prune the rules we firstly sort the rules in a predicate class bycomplexity.
here the rules with more tokens or redundant tokens are of more complexity.
in this case the forward class is arranged as shown in table .
then we test if there exists any rule of less complexity that can replace the one of more complexity.
for example any sentence that can be matched with the rule n forward a line of nd n in length and n forward a line of nd n long can also be matched with n forward n nd n .
since this meets the prune requirement the former two can be pruned.
.
rule adaptation there are in total rules in the original library which are selfgenerated.
however to handle all the possible descriptions to manipulate the turtle the library should be made adaptable.
we realize this function by making the transform table adjustable.
the system will collect the natural language descriptions that cannot be matched up with any rule.
based on these left behind descriptions new words will be appended to the transform table which possess equal meaning as the words in the original table.
thus we can make new rules as an extension to improve the success ratio.
meanwhile in addition to maintaining the rule library users can add words in any predicate class via communicating with pie s function definition.
thus the rules in pie are extensible.
in the future with the increasing number of people that play with pie we would like to use crowd sourcing to improve the rule set.
whenever the system cannot understand the user it will ask the user to say in another way.
typically the user would change some words but not the whole sentence structure.
under this premise we may find out the transformable tokens in our rules and adaptively complete the library using this crowd sourcing method.
however there is still a chance when the sentence structure is changed.
to solve these problems pie will pop up with several words belong to different predicate classes.
the user will be asked whether or not adding a new word to one of these classes.
figure output graph of demo .
dialog interaction to make the interface more interesting we also present a rulebased natural language response as the feedback to each input sentence.
for each synthesized pie logo command there is one and only natural language feedback corresponding to it.
this feedback serves as the confirmation of program synthesized as well as the reminder of the mistakes if any.
in some cases when pie fails to respond to the user s command the interaction system will request an alternative description.the interaction between users and pie system makes this interface more user friendly.
.
ev aluation in this section we first provide an demonstration to show the process and result when playing with pie.
we then present evaluation in terms of learning efficiency for non programmers novices and experienced users in learning to program with pie logo and success ratio for synthesized programs.
we have implemented our system using the python turtle which is a standard library embedded in python .
.
each command in pie logo is implemented in python to move the turtle.
.
demonstration we choose a popular example the koch curve among many latest drawings from users who draw with turtle on the website papertlogo in your browser the input natural language is not case sensitive and by using regular expression matching the system can tolerate some spelling mistakes as well.
this demonstration is designed to show how complex tasks that pie can handle.
the program goes a little bit further than a beginner can understand but with a designed algorithm in hand she could make simple conversations with pie and draw a koch curve without much difficulty.
the interaction between the user and the pie system is shown in figure and the output graph is figure .
this demonstration shows a normal pattern of using recursion in drawing.
consider the education use of the pie system when using this system to learn how to program the non experienced learners especially for children may experience a better interaction than coding directly on their own.
the users enjoy the flexibility of natural languages without being required to memorize the strict and rigid syntax of programming languages.
.
learning efficiency back to the original intention of the pie system in addition to the purpose to simplify the process of learning to code we are aiming at describing a novel way for program synthesis.
nevertheless there is no benchmark for evaluation of the easiness to master a programming language.
we develop a notion called learning efficiency for learning how to program.
here we define learning efficiency as the extent to which time is well used for the intended programming task using a new programming language.
we provide users equal time to learn both the logo programming language and pie logo and test the time they spent on a certain task.
the less time they spent on programming the higher learning efficiency of a specific language.
six volunteers participated in our experiment.
among them two are non programmers graduate students who have learned logic in the previous math studies two are novices first year learners of the java programming language and the remaining two are experienced programmers with four and five years of programming 698user descriptions pie responses logo program thanks for trying pie.
how can i help you?
let s first draw a line okay what is the length of that line?
oh i mean to define a function called line i see what are the arguments of the function line?
they are count and n okay i have designed a function called line with input arguments called count and n. then?toline count n let the turtle move ahead n steps when the count equals to oneokay if the count is turtle will forward n steps ifelse count in other cases do the following things i see.
do what else?
let count decrease by one okay count equals to count make count count repeat the line function with new count i see.
function line is called with the new argument count line count n turn left degrees okay the turtle turns degrees to the left lt60 repeat the function line okay function line is called line count n turn right degree and repeat function line i see the turtle turns degrees to the right.
function line is called.
rt120line count n again turn but left degrees and repeat the function lineokay the turtle turns degrees to the left.
function line is called lt60line count n that is all for the function i see function line is end.
end start another function called koch i see what are the arguments of the function koch?
still count and n okay i have designed a function called koch with input arguments called count and n. then?tokoch count n first turn right degrees and execute the function linei see.
the turtle turns degrees to the right.
function line is called.
rt30line count n turn right degrees and execute the function linei see.
the turtle turns degrees to the right.
function line is called.rt120line count n repeat the last command i see.
the turtle turns degrees to the right.
function line is called.rt30line count n let s call it koch i see function koch is end.
end clear everything okay the canvas is clean.
clear let the turtle start from point i see turtle is moved to point .
setxy begin the function koch okay but what are the arguments?
count is and n is okay function koch is called with the argument count and n .
koch quit okay done!
done figure interaction with pie for demo experiences respectively .
all of them are not involved in the system design and they have not learned the logo programming language before.
before the experiment we start with six examples as the tutorial which include simply drawing an l shape defining a function and drawing repeated patterns.
it takes five minutes on average for them to go through the tutorial.
then equal time is provided to go through the tutorial of the logo programming language provided by the online tutorial as introduced in .
after reviewing both the tutorials of our pie system and the logo programming language the six participants are asked to draw a target shape as shown in figure .
they need to draw a base unit recursively and the base unit is a diamond as shown in figure .
the edge length of the diamond is steps and the two different angles are of and degrees respectively.
the angle between the two dash lines is degrees.
given these indications on how to draw a graph in figure the testers are asked to use both pie logo and logo to complete the task.
testers are separated into two groups one does pie logo first and the other does logo first.
the average time consumed is shown in table .
pie saves and22 of time respectively for non programmers novices and experienced programmers to draw the same graph.
the preliminary results indicate that pie creates a platform for them to program in a new language with a smoother learning curve.
in addition we may find that pie saves the most time for the non programmers in which case we could say that pie performs well as an introduction tutorial for those who want to learn basic programming skills.
another interesting fact in the experiment is that every experienced programmer checked the tutorial of the original logo during the programming task but that does not happen when using pie.
as a result pie relieves the burden of memorizing strict syntax and checking language