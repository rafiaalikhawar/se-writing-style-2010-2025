developer prioritization in bug repositor ies jifeng xuan xuan mail.dlut.edu.cn he jiang jianghe dlut.edu.cn zhilei ren ren mail.dlut.edu.cn weiqin zou zou mail.dlut.edu.cn school of software dalian university of technology dalian china abstract developers build all the software artifacts in d evelopment.
existing work has studied the social behavior in software repositories.
in one of the most important software repositor ies a bug repository developer s create and update bug reports to support software development and maintenance .
however no prior work has considered the priorities of deve lopers in bug repositor ies.
in this paper we address the pro blem of the developer prioritization which aims to rank the contributions of developers .
we mainly explore two aspects namely modeling the developer prioritization in a bug repos itory and assisting predictive tasks with o ur model.
first we model how to assign the priorit ies of developers based on a social network technique.
three problems are investigated including the developer ranking s in products the evolution over time and the tolerance of nois y comments .
second w e consider leveraging the developer prioritization to improve three predicted tasks in bug repositories i.e.
bug triage seve rity identification and reopened bug prediction.
we empirically investigate the performance of our model and its applications in bug repositories of eclipse and mozilla.
the results indicate that the developer prioritization can provide the knowledge of developer priorities to assist software tasks especially the task of bug triage.
keywords developer prioritization software evo lution bug triage severity identification reopened bug prediction i. introduction a bug repository is a vital database in modern software development .
many software projects create and maintain bug repositories for storing and updating the information of problems or suggestions about projects .
the widely available bug repositories have provided an important pla tform for investigating the quality of software .
with the growth in scale developers in large projects must handle a large number of bugs in bug repositories .
for example from oct. to dec. the bug repository of an open source project eclip se has recorded bugs which are totally commented for times by contributors around the world .
in peopleware demarco lister have proposed the major problems of our work are not so much techn ological as sociological in nature .
all the software artifacts in software repositories are created updated and studied b y people.
the social behavior of people has a significant i mpact on software development.
existing work has examined the social networks for some kinds of software repositories .
for mailing list repositories bird et al.
mine communication networks and discov er the communit y structure from email archives wolf et al.
predict software build failures using social networks measur es on the developer communication .
for change log repositories meneely et al.
and pinzger et al.
build developer networks to predict sof tware failures .
for bug repositories hong et al.
have divided the d eveloper network into several communities which identify the sub groups of develope r communication .
however no prior work has considered the priorities of develo pers in bug repositories and its applications .
in this paper we model the d eveloper prioritization using a socio technical approach to improve three predicting tasks centering on bug repositories.
in contrast to dividing the d eveloper network into communities in we generate the developer prioritization by ranking all the participa nt deve lopers of bug repositories.
based on our approach we further study four research questions rqs with the experiments on two typical open source projects namely eclipse and mozilla.
we analyze the characteristics of developer priorit ization to address the first three rqs which study the deve loper priorities in products the evolution over time and the tolerance of noise s respective ly on the other hand we address the last rq by leverag ing the developer prioritization to improve three typical tasks of bug repositories including bug triag e severity identif ication and reopened bug predi ction.
the experiments show that the developer prioritization is helpful to improve the predicting tasks in bug repositories.
especially for bug triag e the average accuracy is improve d up to by combining the developer prioritization .
the primary contributions of this paper are as foll ows .
we identify the developer prioritization of bug repos itories based on a socio technical approach .
in our work each developer is mapped to a probability to indicate the priority in software development .
to our knowledge this is the first work for ranking developers with social networks in bug repositories.
.
we present detailed analysis of our developer priorit ization .
in th e analysis we examine the characteristics of the developer prioritization in bug repositories including the developer priorities in products the evolution and the tolerance of noise s. .
we explore how to improve the tasks in bug reposit ories.
we present the results of three typical tasks i.e.
i mproving bug triage by mixing the developer priorities ident ifying bug severity by adding new feature s and predicting reopened bugs by changing metrics.
to our knowledge this is the first work to evaluate the results of socio techniques on bug related tasks .
the rem ainder of this paper is organized as follows.
se ction ii sta tes the background .
section iii shows the approach to recognize the developer prioritization.
in section iv we study the characteristics of developer prioritization on bug repositories.
in section v we describe how to improve software tasks by leveraging the developer prioritization.
section vi gives the threats to validity and section vii shows the related work.
section viii briefly summari zes this paper and presents the future work.
ii.
background bug repositor ies also known as bug tra cking systems are deployed in software projects for the storage and ma nagement of bugs.
a bug in bug repositories is recorded as a bug report which is filled with the information of a software problem.
based on the bug reports developers1 can collect and reproduce bugs for bug fixing .
in empirical software engineerin g many software tasks are investigated on bug repositories e.g.
assign ing bugs to correct developers to reduce the time of bug fixing summarizing a long bug report into a short abstract detecting duplicate bugs to avoid repetitive operation s and characterizing factors of bug fixing .
in bug repositor ies a bug report belongs to a component of a product.
a product consists of multiple components and some products may share a common component.
for exa mple products firefox and core in mozilla use a common compon ent file handling .
during the process of bug fixing developers label a bug report with various statuses to denote a bug report as new assigned resolved reopened etc .
once a bug report is created any developer who is interes ted in this bug can make comments to communicate with relevant developers.
in existing work on bug repositories developers are al ways treated equally.
however the priority of a developer play s an important role in the tasks.
for example an active developer may make more contribut ions on bug fixing than an inactive one an experienced tester may find bug s with higher severit ies than a common end user.
in this paper we rank all the developers of bug repositor ies to assist the tasks around bug repositories .
we denote th e process of generating the developer priorities as developer pr ioritization .
in this paper developer s refers to the people who contribute to a bug repository.
we follow existing work to use the term developers in a broad sense including reporters programmers testers and active end users.
we denote a developer with the user name in the email instead of the real name.
we take two bug reports bug ids and in eclipse a s examples to illustrate the developer prioritiz ation.
both of these bugs are fixed bugs in product plug in development environment pde .
in table i we list the details of these two bugs.
each bug report is reported by one developer and commented by developers for times.
we find that these two bugs share two common developers caniszczyk and cwindatt .
we illustrate the process of co mmenting among the developers in fig.
.
an arrow with a value in fig.
is called a link.
a question for us is how to prioritize the five developers for these two bug reports.
this question is not easy to answer.
intuitively both caniszczyk and cwindatt contribute to two bug reports while the other developers contribute to only one.
on the other hand ankur sharma cwindatt and bcabe are very active since there are links from each of them and links to each of them also a self link for cwindatt .
in this paper we aim to model the developer prioritization.
f urthermore since developer factors are import ant for the me trics of software quality another question is how to i mprove the software quality with the developer prioritization.
in our work we want to extract knowledge from the deve loper priorities to assist software development .
iii.
identifying the developer prioritization in this section we model t he developer prioritization by extending a social network technique.
we present the framework of developer prioritization and propose four r esearch questions for further studies.
a. framework of developer prioritiz ation motivated by fig.
we define the dev eloper prioritiz ation in our work .
developer prioritization is a process to assign a priority to each developer in a bug repository and to rank all the contributions of developers to assist software tasks.
we extend a recent socio technical approach proposed by l et al.
to identify the developer prioritization.
in their work a leadership network is proposed to in vestigate the social analysis between leaders and fans on an online boo kmarking website.
in our developer prioritization we transfer their work to developers in a bug repositor y. we contribute in two extensions.
first we adapt the original binary weights of links to integer weight s based on the number of comments.
table i two bug reports in eclipse commenter order bug id bug id developer date time developer date time reporter olivier thomann cwindatt comment er cwindatt cwindatt comment er bcabe ankur sharma comment er olivier thomann cwindatt comment er bcabe ankur sharma comment er olivier thomann caniszczyk comment er bcabe ankur sharma comment er caniszczyk cwindatt figure .
an illustration of the communication among developers.
a link denotes a comment and the value of a link denotes the times of comments e.g.
the link with a value from bcabe to caniszczyk means that caniszczyk has made one comment on bcabe based on commenters and in bug id .
caniszczyk cwindattankur sharmabcabe olivier thomann1 11bug id bug id 1second we propose a topic based prioritization by specif ying a product or a component .
we present the brief framework of the developer priorit ization in algorithm .
given developers in a b ug reposit ory the goal of developer prioritization is to generate a score for each developer and rank all the developers based on these scores .
a weight denotes the number of all the comments in a link from a developer to .
if no link e xists between and .
specially we remove all the self links since we omit the influence of comments from a developer to himself herself e.g.
the self link of cwindatt in fig.
.
to build a connected graph based on all the links a virtual developer is added to connect all the developers.
then we add a bi directional link between each original developer and .
the weights of this link and are set to for each .
for each developer let denote the out degree of .
note that both out degree s and in degree s are informative to study the s ocial networks in bug repositories .
in our work we use out degree s to reflect the influence s of both reporter s and commenters .
we consider that the developer prioritization is generated based on the changes of time series .
we denote as the score of developer at time .
thus we calc ulate this score the initial score for and .
l et al.
have proved that the above model can converge after finite time .
given the convergence time we generate the final score of where is a parameter for normalization and .
thus each developer in the bug repository is assign ed with a score .
we rank all the parti cipant developers by their scores in descending order .
in other words a developer in a top rank owns a higher priority than a developer in a bottom rank.
we apply the developer prioritization to the example in fig.
.
the score s of the five developers are and respectively the developer ankur sharma has the highest priority among these five developers .
the scores of these five developers illustrate that alg orithm can quantify the priorities of developers.
in contrast to the same value by measuring out degrees e.g.
the same out degree of ankur sharma cwindatt and bcabe alg orithm distinguish es the developers with the same out degree .
based on algorit hm the developer prioritization can be adapted to a topic based model.
in a bug repository we us ually focus on a specified product or component of the project.
a straightforward choice is to denot e a topic with a product or a component.
for example gi ven a product we can ge nerate the developer priorities based on the bug comments related to this product.
product based or component based developer prioritization is helpful to study the priorities of developers in a specified part of the project.
b. research questions we propose four research questions rqs to invest igate the developer prioritization .
these four rqs are divided into two categories namely the characteristic analysis and the application s. we answer these two categories of rqs in secti on iv rq1 rq3 and section v rq4 respectively.
rq1 .
does the developer prioritization for the whole project differ from the one for a product?
rq2 .
how does the developer prioritization evolve over time?
rq3 .
is the developer prioritization tolerant to noisy comments?
to analyze the characteristics of the developer prioritiz ation in rq1 we study the differences of the developer prio ritization between the products and the whole project in rq2 we study the evolution of the developer prioritization over time in rq3 we examine the tolerance of noise s for the developer prioritization.
rq4 .
can we use the developer prioritization to assist the existing tasks in bug repositories?
an important problem is to explore the applications of the developer prioritization.
in rq4 we investigate how to incorporate the developer prioritization to improve typical tasks in bug repositories .
iv.
analyzing the developer prioritization to explore the answers to the above four rqs we co nduct experiments on bug repositories of two open source projects eclipse and mozilla.
in this section we prese nt the details of the data collection and investigate the answer s to rq1 rq3.
a. data collection we analyze the characteristics of the developer prioritiz ation based on bug repositories of eclipse and mozilla.
these two projects have attracted wide interests since both of them are large scale and open source p rojects.
in our work we algorithm .
framework of developer prioritization input developer links amon g output final score for each developer add a virtual developer and add bi directional links with set initial scores and for to do is the time for convergence calculate the score of each at time with calculate the final score of each with .
table ii scale s of data sets projects bug reports developers comments products components period eclipse to mozilla to collect all the bug reports before i.e.
bugs in eclipse and bug s in mozilla.
the details of our data sets are listed in table ii.
note that the number of bug reports does not equal to the range of bug ids since some bug reports are removed in development e.g.
bug in eclipse or not anonymously accessible e.g.
bug in mozilla .
for each bug report we extract the bug id the reporter the fixer the summary the description the creating time and the comments.
for each comment on a bug report we extract the commenter and the commenting time.
since the fixer of a bug report is not always correct ly labeled the he uristics in are used to recognize the correct fixer s in bug repositor ies.
in this section we mainly focus on the co mments of bug reports while in section v we will further study the texts of bug reports e.g.
the summary and the d escription.
b. answer to rq1 developer prioritization in products most open source project s consist of multiple products each of which can be viewed as a sub project for a set of individual requirements.
in practice a developer can partic ipate in multiple products since the experience from one product may guide the development of another one.
in this sub section we examine the changes of developer prioritiz ation between the whole project and its products.
before studying the developer prioritization for p roducts we first illustrate the developer ranking s in the whole pr ojects in fig.
.
three indicators of developer s are used namely the rank in the developer prioritization the out degree in a bug repository and the number of fixed bugs.
we choose the out degree as an indicator since the developer prioritization is constructed based on the out degrees of d e velopers in algorithm .
note that since not all the bugs are fixed in bug repositories we only count the number of fixed bugs based on bug r eports with the resolution fixed to simplify the statistics .
in fig.
a developer with a large out degree leads to a high priority in developer ranking s. moreover m ost of d evelopers with high priorities have fixed a large amount of bugs e.g.
most of the largest circle s for developer s who have fixed over bugs lie in top ranks.
we can o bserve that the curve of eclipse is not as stable as that of mozilla.
in eclipse most of the out degrees are over .
in both eclipse and mozilla there are some developers who are dominant in both the priority and the number of fixed bugs i.e.
top developers in eclipse and top developers in mozilla.
these dominant developers may be the experienced expert s in soft ware development .
note that some deve lopers who have only fixed a small number of bugs also have high priorit ies e.g.
a developer in mozilla is ranked in top and has fixed less than bugs.
this fact is caused by the different duties of developers e.g.
an active develo per may be not a fixer but a tester.
to observe the differences of developer prioritization b etween the whole project and its products we show the rank s in products for developers in fig.
who are ranked as the top in the whole project i.e.
top developers in fig.
.
the curves for most developers have the similar trend e.g.
in mozi lla the developers have high priorities in product core and have low priorities in product calendar .
an exce ption is the rank for product wtp source editing in eclipse which widely distributes between and .
moreover a top developer in the whole project may contribute little to a product or not participate in a product e.g.
in eclipse the developer john arthorne has ranked around in product birt and the developer darin.eclipse has not contributed to birt.
a eclipse b mozilla figure .
out degrees for top developers.
the diameter of a circle denotes the number of bug reports for a developer.
for example the smallest circles denote developers who have fixed less than bugs.
note that the vertical axis is on a log scale.
a eclipse b mozilla figure .
ranks in active products for top developers in the whole project.
for each project the selected products are products which are contributed by most developers.
in horizontal axis the number following with a product name denotes the number of par ticipant developers.
note that values in the vertical axis are in reverse order.
100out degree of a developer rank and and 100out degree of a developer rank and and platform jdt cdt birt equinox pde community wtp source editing mylyn emf rankproduct name daniel megert darin.eclipse john arthorne eclipse david williams firefox core seamonkey thunderbird mailnews core toolkit tech evangelism core graveyard calendar bugzilla rankproduct name bzbarsky bugzilla dbaron timeless mattianswer to rq1 .
the developer prioritization in products differs from that in the whole project.
specially certain top developers in the whole project may contribute little or nothing to a product.
among the participated products top d evelopers contribute much to most of products.
c. answer to rq2 evolution of developer prioritization for a large scale software product personnel change s are common in development.
an active developer may be ina ctive in a period or even retire .
in this sub section we investigate the evolution of the developer prioritization over time.
based on table ii eclipse has been developed for over years and mozilla has been for over years.
to investigate the evolution we select bug reports in continuous years from jan. to dec. since eclipse is started from oct. .
we choos e half a year as the unit time by follo wing .
thus the time for each project is divided into periods .
we denote the first half of a year with f and the second half of a year with s .
for each unit time we gene rate the developer prioritization in the whole projects and analyze the evolution of leading developers over time.
we illustrate the changes of top developers in fig.
.
to simplify the expressions we denote the developer s who are ranked in top in the whole project as leaders .
given a period a developer is called an old leader or a new leader if he or she is a leader in the last period or not respectively.
as shown in fig.
the ratios in mozilla are more stable than those in eclipse.
moreover for both projects the changes after are stable.
in eclipse t he ratio of new developers who are also leaders is over in each unit time.
from 2002s to 2006s the ratio of old developers who are also old leaders increases with time.
in mozilla the ratio of new d evelopers who are leaders is less than .
in both eclipse and mozilla the developer prioritization changes over time.
we list two possible reasons for this fact.
one is that the developer prioritization always changes because of the complexity of such large projects the other is the unit time in our experiments is not short enough to re cognize the fixed developer priorit ization.
a further study is needed to explore the appropriate unit time to model unchanged developer prioritization in projects .
answer to rq .
the developer prioritization evolve s over time.
a new d eveloper can join the projects and become a developer with high priorities.
d. answer to rq tolerance of noisy comments the process of fixing and localizing bugs suffers from the bad quality of bug reports .
noises in bug reports are common in bug repertories .
for example in the bug report with id of eclipse comment is just a test of a user a ccount which has nothing to do with the content of the bug.
since the developer prioritization is built based on the bug comments we investigate whether the developer prioritiz ation is sensitive to noisy bug comments.
due to the lack of existing method to identify noisy comments we label nois y comments with a heuristic.
we consider two types of comments as noise s namely the co mments by inexperienced developers and the comments wri tten in very few words.
note that no t all the comments in these two types are nois y e.g.
comment of bug in eclipse only containing a full stop can be viewed as a noisy comment while comment of bug only containing a word verified is a useful comment.
in this paper w e directly treat the two types of bug reports as noisy comments without further identification .
in table iii we present the ratios of developers and comments for the data sets which are generated by removing two types of comments.
the seven columns denote three data sets by removing comments of a eclipse b mozilla figure .
percentage for developers and leaders over time.
the leaders top developers in each unit time is considered.
the ratio of a new developer who is a leader the ratio of an old developer who is a leader and the ratio of an old developer who is new as a leader are labeled in black light gray and dark gray respectively.
a eclipse b mozilla figure .
changes for the ranks of top developers among the original data set and new data sets after removing noises.
the selected developers are top developers in the original data set.
table iii ratios of developers and comments in data sets project ratio comments comments comments original words words words eclipse developer .
.
.
.
.
.
.
comment .
.
.
.
.
.
.
mozilla developer .
.
.
.
.
.
.
comment .
.
.
.
.
.
.
2002f 2002s 2003f 2003s 2004f 2004s 2005f 2005s 2006f 2006s 2007f 2007s 2008f 2008s 2009f 2009s 2010f 2010sratio time new developer leader old developer leader old developer new leader 2002f 2002s 2003f 2003s 2004f 2004s 2005f 2005s 2006f 2006s 2007f 2007s 2008f 2008s 2009f 2009s 2010f 2010sratio time new developer leader old developer leader old developer new leader comments comments comments original words words wordsrankdata set daniel megert darin.eclipse john arthorne eclipse david williams olivier thomann denis.roy webmaster tod creasey steve northover comments comments comments original words words wordsrankdata set bzbarsky bugzilla dbaron timeless matti gerv asa roc brendan neilinexperienced developers and the original data set and three data sets by removing comments written in few words and .
we illustrate the changes of the developer prioritization in fig.
.
we can find that our approach for the developer prioritization is tolerant to noisy comments.
the change among each data set is inconspicuous .
this fact coincides with our expecta tion since we always focus on the develo pers with high prioriti es who contribute many comments to bug repositories.
the noisy comments removed in our expe riments only affect the developers with few comments.
answer to rq .
the developer prioritization in our work is insensitive to noisy comments.
therefore the deve loper prioritization can be used to handle the real data sets which include noisy bug comments .
v. leveraging the developer prioritization in this section we explore the results of leveraging the developer prioritization to assist the tasks in bug repositories.
we answer rq4 by examining the effects on three typical tasks i.e.
bug triage severity identification and reopened bug prediction.
all these tasks have been addressed to i mprove the quality of software development.
we select such three tasks since th ey cover various aspects of predictive tasks .
in details bug triage is a multiple class task based on bug repositories severity identification is a binary class task based on bug repositories and reopened bug pr ediction is a binary class task based on both bug reposit ories and change log reposito ries.
in this section we combine the input or the output of a task with developer priorities obtained by the deve loper pr ioritization.
by combining with the input we add new fe atures to the predict ive model while by combining with the output we update the results of a task.
in fig.
we briefly summar ize the process for improving the results of the three tasks by combining the developer priorities .
a. bug triage bug triage is a typical problem in software maintenance which aims to predict a correct developer for a new coming bug .
traditionally a human developer also called triager assigns new bugs to candidate developers.
automatic a pproaches for bug triage have been developed to reduce time and labor cost.
most of existing work models bug triage as text classification and improves the accuracy of bug triage based on the knowledge from bug repositories .
in this paper we consider improv ing bug triage with the developer prioritization obtained from bug repositories.
for a predicted list of developers by a classifier we rank these developers by the priorities.
thus the developer prioritiz ation is used to discriminate the developers with similar pro babilities in the prediction.
we evaluate the results of bug triage with the increme ntal learning framework in which we chronologically sort all the bug reports and divide the se bug reports into folds .
thus we perform experiments in rounds.
in each round we generate the developer prioritization from the training set and combine the developer prioritie s with the predicted r esults of th e classifier s. in fig.
we present the evaluation framework in our work.
we validate our approach on the bugs from to for eclipse and bugs from to for mozilla .
we follow the existing work to remove the non fixed bug reports only bug reports with the resolution fixed are left and inactive developers in our work deve lopers who have fixed less than bugs are removed .
as a result bug reports of eclipse and bug reports of mozilla are left as data sets.
for each bug report the title and the description are extracted as an input text while the deve loper who has fixed this bug is extracted as a label for the classifier .
we convert the bug reports into vector space mo del by tokenizing the sentences into terms.
we perform the techniques of removing stop words stemming a nd tf idf a weighted term frequency approach to generate the final data sets.
we evaluate the experiments with the accuracy of top k predicted developers since a recommendation list is always employed .
the accuracy is calculated as based on a recommendation list with size k. we employ two typical classifiers i.e.
naive bayes nb and supporting vector machine svm .
these classifiers are implemented by weka .
figure .
leveraging the developer prioritization to predict tasks around bug repositories.
we use the developer pri oritization to assist three tasks.
a circle denotes an action of predicting.
figure .
bug triage combined with the developer prioritization based on the incremental learning.
in round r the first r folds are used for training a classifier and generating the developer prioritization while the r th fold is used for testing.
the developer prioritization is combined with the result of testing to form a new developer list.
developer commentsdeveloper prioritization combined fixer rankings candidate fixers severitycombined features reopened or notcombined metricsbug repositorybug reports bug reports bug metrics task bug triage task severity identification task reopened bug predictiondeveloper prioritiesdeveloper prioritiestriaging identifying predictingdeveloper priorities fold fold fold fold trainingtesting developer prioritizationcombined ranking training testing developer prioritizationcombined ranking training testing developer prioritizationcombined rankingfold fold ... ...round round round 10bug reportsin the following of this sub section we present the expe rimental results on bug triage.
to obtain a high accuracy we examine several ways to generate the developer prioritization from bug comments in training sets.
we consider this pro blem on two dimensions namely the source and the time per iod of developer prioritization.
on one hand in rq1 we have presented that the developer prioritization changes in diffe rent products.
thus w e gene rate the developer prioritization based on products components and products components respectively.
on the other hand in rq2 we have verified that the developer prioritization in two close periods can be very similar.
thus we consider two kinds of time periods for building the developer prioritization i.e.
the accumulative folds in the training set and the latest fold in the training set.
taken round in fig.
as an example folds and are used to build the developer prioritization by choosi ng the accumulative folds while only the fold is used by choosing the last fold.
to improve bug triage w e combine the product based and the component based developer prioritization with the predicted results of classifier s. given a new bug report we extract its product and its component .
we combine the pro babilit ies in prediction with the developer priorities which match its product and its component.
formally given a new bug report its product and its component the final score is where is the probability predicted for each developer by a classifier is the score in based developer prioritization is the score in based developer prioritization is the maximum value in developers for normalization .
the score or is set to zero if a developer never appears in a product or a component.
then we rank the developers by these final scores and select developers with highest scores as the final results.
to obtain the rankings of top k developers for a bug report we use a classifier to predict developers and rank these developers by the combined final scores.
then top k developers in th e new ranking s are s elected as the final predicted results.
in our work we examine the results of top developers.
in fig.
we present the accuracy of the top developer in each round.
in both eclipse and mozilla the approaches combined with the developer prioritization can obtain higher accuracy than directly using svm.
most of the results based on the latest fold are bette r than those based on the accum ulative folds.
as a result we observe that the recent changes of developers can be more helpful than the accumulative a eclipse b mozilla figure .
accuracy for the top predicted developer in round incremental learning.
svm denotes the accuracy only based on the classifier p and c denote the approach combining with the developer prioritization based on product s and component s respectively.
a and l denotes the approach based on the developer proritization which is extracted from the accumulative folds and the latest fold in the training set respectively .
12345678910accuracy roundsvm p a c a p c a p l c l p c l 12345678910accuracy roundsvm p a c a p c a p l c l p c l table iv preformance of bug triage on eclipse and mozilla project classifier size approach accuracy in each round average accuracy improvement eclipse svm top svm .
.
.
.
.
.
.
.
.
.
.
.
svm dp .
.
.
.
.
.
.
.
.
.
.
top svm .
.
.
.
.
.
.
.
.
.
.
.
svm dp .
.
.
.
.
.
.
.
.
.
.
top svm .
.
.
.
.
.
.
.
.
.
.
.
svm dp .
.
.
.
.
.
.
.
.
.
.
nb top nb .
.
.
.
.
.
.
.
.
.
.
.
nb dp .
.
.
.
.
.
.
.
.
.
.
top nb .
.
.
.
.
.
.
.
.
.
.
.
nb dp .
.
.
.
.
.
.
.
.
.
.
top nb .
.
.
.
.
.
.
.
.
.
.
.
nb dp .
.
.
.
.
.
.
.
.
.
.
mozilla svm top svm .
.
.
.
.
.
.
.
.
.
.
.
svm dp .
.
.
.
.
.
.
.
.
.
.
top svm .
.
.
.
.
.
.
.
.
.
.
.
svm dp .
.
.
.
.
.
.
.
.
.
.
top svm .
.
.
.
.
.
.
.
.
.
.
.
svm dp .
.
.
.
.
.
.
.
.
.
.
nb top nb .
.
.
.
.
.
.
.
.
.
.
.
nb dp .
.
.
.
.
.
.
.
.
.
.
top nb .
.
.
.
.
.
.
.
.
.
.
.
nb dp .
.
.
.
.
.
.
.
.
.
.
top nb .
.
.
.
.
.
.
.
.
.
.
.
nb dp .
.
.
.
.
.
.
.
.
.
.
changes.
this observation coincide s with the existing work that the latest activity of a developer is representative .
among seven approaches in each sub figure of fig.
the approach combined with the developer prioritization based on products and components has the highest accuracy.
in the rest of this sub section we choose such combination as the approach in the experiments.
in table iv we present t he results of bug triage by co mbining the developer prioritie s with the output of the classif ier in eclipse and mozilla.
svm dp and nb dp denote the result s which are ranked by combining the developer prior itization with the output of svm and nb respectively .
we can find that for both of svm and nb the accuracy is improved when combining with the developer prioritization .
the average improvement for svm is around while the average improvement for nb is only about .
the reason for such results is that the combination with the developer prioritization is based on the probability predicted by class ifiers and svm has stronger ability on discriminat ing diffe rent classes than nb.
thus for nb the rank s of developers may not change to o much by combining the developer prior itization.
as shown in table i v the improvement for the top is larger than that for top .
the improvement for svm in some rounds are over e.g.
round with top deve lopers in eclipse and round with top in mozilla.
b. severity identification since the number of daily bugs is large to handle new bugs in bug repositories are divided into different severities to process for different goals .
existing work robotic severity security severity and critical severity has identified bug severit ies with predictive techniques.
in this sub section we address the critical severity pro blem.
lamkanfi et al.
predict whether a new bug is severe by adapting a text classification technique.
in their work a set of bug reports including non severe or sev ere ones are divided into a training set and a test set.
the fold cross validation is used to evaluate the results of classification.
for a bug report with a self reported severity trivial or minor is considered as a non severe bug while major critical or blocker is considered as a severe one.
given a new bug report the title of this bug is extracted to build the vector space model.
the stop word r emoval stemming techniques are performed note that no tf idf technique is used .
based on the vector space of training sets naive bayes nb class ifier is employed to identify whether a bug is severe or not.
in existing work by lamkanfi et al.
the severity of a bug is predicted by the numeric vector which is converted from the bug title.
we consider add ing the factors of deve lopers to predict severities .
for new bugs the priorit ies of reporters may provide more infor mation to identify the s everity e.g.
a reporter with a high priority may pay more attentions to the severe bugs.
therefore for each bug report we add two features from the developer prioritization to the original numeric vector s. the se two features are two priority score s of reporter s based on the products and compone nts respectively.
then the predictive vector has two more n umeric features .
since values in predictive vectors may be imbalance we normalize all the features to the range from to for each training set .
in our work we extract the data sets from bug reposit ories of eclipse bugs and mozilla bugs .
for each project we select severe and non severe bugs in three components in accord ance with .
these data sets are presented in table v. we evaluate the severity identification with precision recall and f measure .
we present the experimental results in table vi.
for each component the first row denote s the classification based on the original vector s which are extracted from bug titles while the sec ond row denotes the classification based on the mixed vector s which are formed by adding two d eveloper scores.
a value in bold denotes a result which is over better than the other result on the same component.
as shown in table vi the prediction based on the mixed vectors can obtain better precision recall and f measure on bugs in mozilla while the difference of results in eclipse is not significant.
one possible reason for these results is the number of original numeric features is large and the effects of two new dimensions are not obvious to the predicti ve model .
c. reopen ed bug prediction reopened bug prediction aims to identify a bug report which will be incorrectly fixed in the future .
to our knowledge only shihab et al.
have proposed the method to predict a reopened bug.
in their work they extract fa ctors in dimensions to build the predictive model based on adaboost .
among the dimensions of factors one d imension is called people dimension which consists of factors about the developer information of a bug report i.e.
the reporter name the fixer nam e the reporter experience and the fixer experience.
in this paper we do not discuss the improvement of the predictive model of reopened bug prediction .
we only co n table v number of bugs for each severity project product component non severe bugs severe bugs eclipse platform ui jdt ui jdt text mozilla core layout camino bookmarks firefox general table vi performance on severity identification project product component non severe bugs severe bugs precision recall f measure precision recall f measure eclipse platform ui .
.
.
.
.
.
.
.
.
.
.
.
jdt ui .
.
.
.
.
.
.
.
.
.
.
.
jdt text .
.
.
.
.
.
.
.
.
.
.
.
mozilla core layout .
.
.
.
.
.
.
.
.
.
.
.
camino bookmarks .
.
.
.
.
.
.
.
.
.
.
.
firefox general .
.
.
.
.
.
.
.
.
.
.
.
sider whether our developer prioritization can provide sim ilar factors to th is model.
we evaluate the experiments with the fold cross validation on the benchmark data set in .
this data set consists of bugs are reopened bugs and are not which are extracted from bugs in eclipse.
we generate the developer prioritization without specifying a product or a component on the bug comments of bugs and extract the scores of reporters and fi xers who are specified in the data set.
note that we have not conducted experiments on mozilla since only the benchmark for eclipse is shared in .
in the experiments we add two factors to the people d imension namely the reporter priority score and the fixer priority score.
these factors can be divided into three groups i.e.
name experience and priority .
we list comb inations of these three groups of factors in the column factor in table v ii exp.
is short for the group of factors exper ience .
we run the algorithm adaboost in to examine the results.
as shown in table v ii by chang ing the original factors of name and experience with priority the performance is improved.
and the combination of all the three groups can provide the highest performance.
we summarize the results in table v ii that the factors based on the developer priorit ization can provide similar features to the model for predic ting reopened bugs and can slightly improve the existing r esults.
note that the improvement by adding the factors of priority score s is not significant .
this fact suffers from two possible reasons.
one is the small number of training set may limit the predictive ability of factors the other is the existing results may be good enough and hard to improve.
answer to rq4 .
by exam ining three typical tasks in bug repositories we conclude that the developer prioritization is helpful to improve the results of these tasks especially the task of bug triage.
vi.
threats to validity a. building the developer prioritization in our work w e build the developer prioritization from bug comments in bug repositories.
the developer rankings are obtained to denote the priorities of developers.
since there is no real ranking of developers in software projects it is hard to validate whether our obtained ranking s are coinc ident with the real collaboration in development .
to address this problem a good way is to conduct a case study to exa mine the difference s between the developer prioritization and the collaboration in development.
moreover the dev eloper prioritization in our work can enhance simple measure s e.g.
distinguishing the developers with the same out degree.
an experiment should be conducted to compare the priorities between our work and simply measuring out degrees.
besides the developer prioritization for a whole project we have also proposed product based and component based developer prioritization in our work.
we extract the products and components from the self reported terms of bug reports.
however such terms of products or components may mismatch the real terms since reporters lack experi ences to identify the correct products or components .
to completely avoid such mismatch a technique for identifying the correct product and components should be developed.
b. analysis of developer prioritization in section iv we explore the evolution of developer pr ioritization over time.
the time period is divided into several half years to study the changes in the process of development .
besides the time based evolution version based evolution of the developer prioritization may provide more information.
we do not investigate version based evolution in our work since the bug reports in different versions are hard to collect.
for example among bug s only bugs .
are identifi ed with version information which b elong to products.
to analyze the noise tolerance of developer prioritization we recognize noisy comments with a heuristic which view s the comments by inactive developers and the comments with few words as noise s. many of such comments consist of noisy information but some meaningf ul comments may also be viewed as noises such as comments with only one word fixed or verified .
to exactly recognize noisy comments manually labeling is m ore helpful than a heuristic.
c. assisting software tasks in this paper we show that the developer prioritization is effective to improve the tasks in bug repositories based on the empirical evaluation.
the developer prioritie s can add more information to the input features or update the output of classifiers.
however further questions may b e proposed for example wh at is the internal relationship between the deve loper prioritization and the goal of a task?
and why is the social behavior of developers helpful?
these questions are not easy to answer.
in this paper the developer prioritizati on can build a bridge from bug repositories to predictive tasks.
for further work a systematic al case study can provide more information to explore the correlation between the developer prioritization and the predictive tasks.
vii.
related work a. social network analysis in software repositories bird et al.
mine social networks from email achieves and analyze the developer activity based on social network measures.
their later work explores communities from the social networks which are representative of the collab oration of developer behavior.
wolf et al.
employ the team communication network to predict the failures of sof tware builds.
in th eir work the centrali ty measures in social networks are extracted as features in the predictive model.
table vii factors on reopen ed bug prediction in eclipse factor reopened bugs non reopened bugs accuracy precision recall f measure precision recall f measure original name exp.
.
.
.
.
.
.
.
exp.
priority .
.
.
.
.
.
.
name priority .
.
.
.
.
.
.
name exp.
priority .
.
.
.
.
.
.
social networks have been proposed to improve the software failure prediction.
to predict failures meneely et al.
construct developer networks on change log repositories and pinzger et al.
build developer module networks on binary repositories.
bird et al.
combine the topological properties with social networks and investigate multiple types of relatio nships to predict failure s. moreover bettenburg hassan study the impacts of socio technical measures through the failure detection.
since the social tech niques are effective for indicat ing software fai lures meneely williams empirically validate that the social network metrics can represent the collaboration relationship in software development .
by build ing a social networking service for developers begel et al.
introduce a codebook framework to discover the inter team coordination in development.
they have co nducted two applications to evaluate the effectiveness of their framework.
in bug repositor ies hong et al.
have examined the developer social networks in bug repositories.
they discover the sub communities of a developer network and investigate the evolution over time.
in this paper we also focus on the socio technical analysis on bug repositories.
in contrast to the community discovery in we explore the developer prioritization in bug repositories.
we analyze the developer rankings and improve three existing tasks in bug repositories .
b. bug repositories in this paper we investigate the developer prioritization in bug repositories.
in existing work on bug repositories fischer et al.
explore the proximity of software features.
in their work bug report analysis is used to study and visua lize the relations between software features.
the quality of bug reports is important for locating and fixing bugs.
hooimeijer weimer present the first work to model the quality of bug reports.
bettenburg et al.
point out that du plicate bugs contain extra information for bug fixing which are use ful to improve bug triage.
zimmermann et al.
study the evidence for the mismatch between d eveloper expectation and bug reports based on a systematic questionnaire survey .
xiao afzal propose a search based approach for the resource scheduling on bug fixing tasks .
most work on bug repositories treats developers and bug s separately .
our previous work proposes an integrat ed view of developers and bug reports.
we transfer the intera ctions between developers and bug reports to requirements engineering to supplement the lack of open requirements.
in this paper we extract the developer prioritization in bug repositories.
besides the multiple aspects of analysis we leverage the developer pr ioritization to predict software tasks.
c. predicting tasks in bug repositories the goal of bug triage is to automatically assign a new bug to the correct developer to avoid the expensive cost of maintenance .
ubrani murphy have proposed the first work of bug triage which transform s bug triage to a text categorization problem .
anvik et al.
extend the above work with a recommendation list and multiple classifiers.
jeong et al.
and bhattacha rya neamtiu propose a tossing graph based approach to improve bug triage with the previous assignment history of bug reports.
our previous work proposes a semi supervised learning approach to avoid the lack of qualified bug reports.
recent work by anvik murphy investigates the effects of recommen ders to assist bug triage for streamlining the development pr ocess.
other work also address es the problem of bug triage such as the training set reduction the fuzzy set and cache based approach and the cost aware bug triage .
severity identification is to detect the bug severit ies to guide the resource allocation and planning of bug fixing.
to date three types of severit ies are studie d. menzies macus first propose a text mining approach to detect the level robotic severity for bug reports in nasa databases.
gegick et al.
and lamkanfi et al.
have further predicted the security severity and the critical severity of bug reports .
reopened bug prediction is to detect whether a bug is fixed in a correct way.
shihab et al.
study and predict reopened bugs on factors in four dimensions which are extracted from both bug repositories and source code repos itories .
in an empirical study on characterizing which bugs get fixed guo et al.
present that the times of reopenings is a factor to indicate whether a bug can be fixed.
in this paper we empirically evaluate whether the deve loper prioritization can improve the results of the above three tasks.
besides the three mentioned tasks existing work i mprove s the software quality in bug repositories on other tasks .
for example rastkar et al.
summarize long bug reports to avoid redundanc ies and noise s in bug repositories runeson et al.
wang et al.
and sun et al.
detect duplicate bug reports to reduce the expense for handling bugs in large scale reposito ries.
viii.
conclusion and future work in this paper we model the developer prioritization in bug repositories by extending a socio technical approach.
we analyze three problems of the developer prioritization namely the characteristics in products the evolution and the tolerance of noise s. based on the analysis we investigate the ways to leverage the developer prioritization to improve three typical tasks in bug repositories .
the results are studied on over bug reports in eclipse and mozilla.
our fut ure work is to investigate a task based developer prioritization in bug repositories to improve a specified task with the developer ranking s. in contrast to the general model of the developer prioritization we want to provide a model to add more knowledge to handle the problems in a specified task.
for e xample fixers of bug reports should be added more weights in the developer prioritization to improve bug triage.
acknowledgment we greatly thank the anonymous reviewers for their i nsightful comments.
this work is partially supported by the national natur al science foundation of china under grants and and the software x funding of dalian university of technology.