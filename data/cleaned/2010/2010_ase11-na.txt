automated web application testing using search based software engineering nadia alshahwan and mark harman crest centre university college london london uk fnadia.alshahwan.
mark.harman g ucl.ac.uk abstract this paper introduces three related algorithms and a tool swat for automated web application testing using search based software testing sbst .
the algorithms significantly enhance the efficiency and effectiveness of traditional search based techniques exploiting both static and dynamic analysis.
the combined approach yields a increase in branch coverage and a reduction in test effort.
each improvement is separately evaluated in an empirical study on real world web applications.
index terms sbse automated test data generation web applications i. i ntroduction the importance of automated web application testing derives from the increasing reliance on these systems for business social organizational and governmental functions.
over the past ten years internet user numbers grew by approximately .
in online retail sales grew by compared to .
for all retail sales .
amazon the leading online retailer increased its sales by .
.
one of the advantages of web applications is their continual availability.
the service provided by a web application is not limited by location or time since geographically separated users may have concurrent access.
however these advantages impose a demand for high availability.
web time is considered to be to times faster than normal time web technologies change more frequently and their adopters seek early acquisition of market share.
this pressure on development time squeezes the testing phase especially when it is unautomated labour intensive and therefore slow.
however inadequate testing poses significant risks studies showed that trust and convenience are major factors affecting customer loyalty using web applications .
both recent and historical studies have shown that online shoppers exhibit impulsive purchasing habits indicating that downtime can prove costly.
for example downtime was estimated to cost amazon 25k per minute even as early as .
search based testing has been used widely as a way to automate test data generation for traditional stand alone applications thereby making testing less reliant on slow laborious processes.
search based test data generation has also proved to be effective and complementary to other techniques .
however of research papers on sbst 1only one mentions web application testing issues and none applies search based test data generation to automate web application testing.
popular web development languages such as php and python have characteristics that pose a challenge when applying search based techniques such as dynamic typing and identifying the input vector.
moreover the unique and rich nature of a web application s output can be exploited to aid the test generation process and potentially improve effectiveness and efficiency.
this was the motivation for our work we seek to develop a search based approach to automated web application testing that overcomes challenges and takes advantage of opportunities that web applications offer.
in this paper we introduce an automated search based algorithm and apply it to web applications.
we also introduce enhancements that seed the search process with constants collected statically and values collected dynamically and mined from the web pages provided by the application.
the primary contributions of the paper are as follows we introduce the first automated search based approach to web application testing and a tool that implements the approach.
we introduce the use of dynamically mined value seeding dmv into the search process.
our empirical study shows that this approach statistically significantly increases coverage in all applications studied and also significantly reduces effort in all but one.
these findings may prove useful for other sbst paradigms.
we report the results of an empirical study of effectiveness and efficiency of our algorithms in terms of branch coverage of server side code fitness evaluations execution times and fault finding ability.
the rest of this paper is organized as follows section ii provides a brief background on search based test data generation.
section iii introduces the proposed approach whilst section iv describes the implementation of the approach.
section v presents the evaluation together with a discussion of the results.
section vi presents related work and section vii concludes.
1source sbse repository at http crestweb .
cs .
ucl .
ac .
uk resources sbse repository ii.
b ackground search based software engineering sbse is an approach that reformulates software engineering problems into optimization problems .
first the possible solutions need to be encoded in a way that makes similar solutions preferably proximate in the search space.
then a fitness function needs to be defined and used to compare solutions.
finally operators that alter unsuccessful solutions need to be selected in a way that directs the search to a better solution.
hill climbing is a local search algorithm often used in sbse and found to be effective for testing .
a random solution is first chosen from the search space and evaluated.
the neighbouring solutions of that random solution are then evaluated to find a better solution.
if a better solution exists that solution is selected to replace the previous solution.
the process is repeated until a solution is found for which no further improvements can be made.
the approach has the advantage of being simple and fast.
however its success depends on the randomly chosen starting solution.
korel introduced the alternating variable method a vm into the search process.
this method makes changes to one input variable while fixing all other variables.
branch distance is used to measure how close an input comes to covering the traversal of a desired branch.
if the changes to a variable affect branch distance a vm applies a larger change in the same direction at the next iteration.
this acceleration could cause the approach to over shoot the nearest local optimum.
in this case a vm restarts its search at the previous best solution so far.
the approach will then cycle through variables repeating the same process until the branch is covered or no further improvement is possible.
a variety of scripting languages can be used to implement web applications including php perl java asp and jsp.
in this paper we shall focus on php one of the most popular web scripting languages in current use .
we focus on php in order to provide a concrete web application testing tool to implement and evaluate our approach.
however many aspects of our approach may also apply to other web application languages.
iii.
a pproach our approach aims to produce a test suite that maximizes branch coverage of the application under test.
the algorithm starts with a static analysis phase that collects static information to aid the subsequent search based phase.
the search based phase uses an algorithm that is derived from korel s alternating variable method a vm but which additionally incorporates constant seeding and dynamically mined values dmv from the execution and web pages constructed by the application as it executes.
the rest of this section describes our approach in more detail.
section iii a discusses issues in applying search based techniques to web applications and the solutions we adopt.
section iii b describes the fitness functions we used while section iii c introduces our algorithms.a.
issues and solutions in web application testing static and dynamic analysis phases are used to address the issues raised by web application testing and which are either absent or less pernicious in the traditional search based software testing paradigm.
issue interface determination description in various web scripting languages such as php asp and jsp the interface is not explicitly specified.
there is no program header that specifies how many inputs a program expects nor what their types are.
a number of global arrays e.g.get post request are usually set on the clientside before a request is submitted.
these global arrays use the input name as an array index and the input s value as the corresponding array element.
these arrays can be accessed by the server side code at any point in the program.
solution in order to determine the input interface automatically we perform static analysis on the source code to determine the required inputs.
we collect each call to the global arrays e.g.
get post request and then extract the names of the inputs and the associated submit method.
we also note the location where these inputs are accessed.
for every branch we seek to cover all input variables that are accessed before that branch are selected to form the input interface.
to determine input types we perform static analysis that determines the type of inputs based on the type of constants to which they are compared or from which they are assigned.
our approach is similar to that of halfond et al.
.
however our analysis does not as yet infer types for all inputs and needs to be augmented manually.
issue dynamic typing description web development languages such as php python and ruby are dynamically typed.
all variables are initially treated as strings.
if used in an arithmetic expression they are treated as numeric at that operation.
however the same input can be treated as numeric in one expression and as a string in a different expression within the same script.
this makes it hard to decide the type of variables involved in a predicate posing a problem when deciding which fitness function to use.
solution to solve this problem types of variables are checked dynamically at run time using built in php functions and then directed to the appropriate fitness function.
issue user simulation description in dynamic web applications the user s interactions with the application s dynamic content need to be simulated to test the application as a whole.
web applications usually have a top level entry page that the user accesses first.
user choices on the entry page are passed to the serverside code for processing.
a client side page is then generated and displayed to the user.
some applications have other top level pages that can be accessed only through these client side pages.
identifying these top level pages raises issues when trying to generate test data automatically for an application as a whole.
solution our static analysis identifies top level pages that expose new parts of the application accessible only throughclient pages during the static analysis phase.
a file that is not included by any other file is treated as a top level file.
the test data generation process is performed for each top level file.
issue dynamic includes description php supports dynamic includes where the name of the included file is computed at run time.
an example of this is when the user s choice determines the natural language to be used in the text of the application.
solution to deal with dynamic file includes we used a similar approach to the one proposed by wassermann and su for include statements that contain variables as part of the included filename we use a safe approximation that includes any file available to the application that matches the include expression.
b. fitness function the fitness function we use in our approach is similar to that used by tracy et al.
.
that is for a predicate aopb where opis a relational operator fitness is zero when the condition is true andja bjwhen the condition is false.
a fitness of zero denotes the situation where the test vector assessed by the fitness function covers the desired branch.
that is our approach seeks to minimize fitness values throughout the search process.
like tracey et al.
a value k in our case is added to penalize incorrect test data but we add that value only in case of and6 .
for strings we use levenshtein distance following alshraideh and bottaci .
the levenshtein distance is the minimum number of insert delete and substitute operations needed to convert one string to another string.
the levenshtein distance is suitable for and6 operators.
for other operators we convert the ascii code of a string to a decimal representation and use the same fitness used for normal numeric types following zhao et al.
.
as a pre processing step compound predicates involving logical operators are expanded using a pre transformation to simple relational predicates.
c. test data generation algorithms our algorithms for test data generation are all based on hill climbing using korel s a vm .
when a target branch is selected a vm is used to mutate each input in turn while all other inputs remain fixed.
when the selected mutation is found to improve fitness the change in the same direction is accelerated.
to avoid over shoot when fitness is close to zero we decelerate.
we note branches that we reached but failed to cover and target them on subsequent iterations.
that is a branch is reached if its immediately controlling predicate is executed while a branch is covered if the branch itself is traversed.
this exploration approach eliminates the need for calculating the so called approach level .
this is because we attempt to cover a branch only when it is reached i.e.
all transitively controlling predicates on some path have been satisfied.
we call this an exploration approach because the technique maintains a current frontier of reached but as yet uncovered branches seeking to push back this frontier at each top leveliteration.
a similar approach was used by michael et al.
for evolutionary testing.
algorithm nms overall test data generation algorithm top level units are extracted from the file tree analyser results.
each unit is called with no parameters to get an initial work list of reached branches.
for each work list branch the input vector is mutated iteratively until the branch is covered or the stopping criterion is satisfied.
near misses and collateral coverage are recorded for later use.
require application name appname require static analysis results analysisdb u queue of top level file units to be processed.
retrieved from the file tree analyser results.
b queue of branches reached but not covered.
c coverage table of all branches with the best achieved distance.
t test cases that achieved best distance for each reached or covered branch.
f set of branch and fitness values achieved for the executed test case.
input setof inputname value iv input vector consisting of setof input distance holds fitness value for a certain branch.
u gettestunits appname analysisdb t for alluinudo iv f executetestcase u iv t updatetestdata t u iv f c updatecoveragedata c f while first run or coverage improved do b getreachedbranches c for allbinbdo initstate iv setinputvector b analysisdb t input null currentdistance getbranchdist b c while currentdistance 0and not no improvements for tries do initilaizedb input mutateinputs iv input currentdistance previousdistance iv replaceinputvalue iv input f executetestcase u iv t updatetestdata t iv f c updatecoveragedata c f previousdistance currentdistance currentdistance getbranchdist b c end while end for end while end for returntat each iteration we also keep track of input values that cause any near misses .
a near miss is an input vector that causes fitness improvement for a branch other than the targeted branch.
near misses are used in place of random values when initializing a search to cover that branch.
we call this approach near miss seeding nms .
more formally our top level approach is described in algorithm which starts by calling the application with empty inputs for every top level file line .
every execution of a test case returns a list f of all branches in that execution together with the distance achieved for them.
this list is used to update a coverage table c and the test suite t for every branch that recorded an improvement in distance.
a work list of reached branches is extracted from the coverage table.
every branch in the work list is then processed in an attempt to cover it.
first the state and database are initialized and the user in this case our test tool is logged into the application line .
the input vector is then constructed using the analysis data.
values are initialized using the input values that caused the branch to be reached and random values for any additional inputs line .
one input is mutated at a time and the new test case executed until the branch is covered or no improvements are possible.
algorithm describes the mutation process.
if no input was selected for mutation or the last mutation did not affect distance a new input is selected.
if the last mutation caused distance to increase a new operator is selected.
if the last mutation caused distance to decrease the operation is accelerated.
finally the selected input is mutated line .
algorithms and describe our unaugmented search based approach.
we make a few modifications to use constants collected from the source code of the application in the search process.
constants are used to initialize inputs in line 12of algorithm instead of random values and assigned to the input in line 12of algorithm when the input type is string.
this approach was first proposed by alshraideh and bottaci in the context of testing traditional applications.
we call this process static constant seeding scs .
we also modify the algorithm to seed values dynamically mined during execution into the search space in a similar way to static constants.
we call this process dynamically mined value dmv seeding.
more details about dmv are given in the next section.
d. dynamically mined value seeding constants collected statically are specific to the application and therefore can aid in covering branches that depend on these constants.
in a similar way collecting values dynamically from predicates can also prove beneficial.
these collected values are not only specific to the application but also specific to the predicates from which they were collected.
we seed these values into the search space when targeting their associated branches.
web applications offer a wealth of valid input values in their dynamically generated html.
the output html is returned to the user in our case the tool in a structured form thatmakes it possible to extract these values and to associate them with their respective input fields.
the source of these values is form data and embedded urls.
form definitions can contain valid values in drop down menus check boxes radio buttons and hidden values.
embedded urls can also contain valid values in their query strings.
these fields are populated from different sources that can include databases configuration files and or external data sources.
the input fields associated with these values can affect coverage indirectly or through hard to cover branches.
an example that illustrates the potential ofdmv is the following predicate taken from one of the applications phpsysinfo we used in our study if file exists lng.
.php .. generating a value for input lng that would cover the true branch of the control statement might be hard since the condition is a flag condition that would not provide much guidance to the search process.
however a form in the dynamically generated html figure has a drop down menu that contains a list of language options available for the application i.e.
the language file exists in the application s file system .
using one of the values in the drop down menu for this input field would cover the branch.
algorithm mutation algorithm mutateinputs the algorithm determines the next input to which the search moves based on distance achieved by the last mutation.
it also decides when to change the mutation operator and when to accelerate the selected operation require iv input currentdistance previousdistance analysisdb ifinput is null or currentdistance previousdistance then input selectnewinput input iv else ifcurrentdistance previousdistance then changemutationoperator else ifcurrentdistance previousdistance then accelerateoperation end if end if end if input mutate input analysisdb return input in our approach we mine the html returned when executing test cases line of algorithm to collect such values and subsequently seed them into the search when mutating the inputs associated with them.
iv.
t heswat t ool we developed a tool called the search based web application tester swat to implement our approach andfig.
.
form taken from phpsysinfo embed it within an end to end testing infrastructure.
swat s architecture is illustrated in figure .
the tool is composed of a pre processing component the search based tester and the test harness.
the original source code is passed through the predicate expander and instrumenter.
this produces a transformed version of the code where predicates with logical operators are expanded and control statements are instrumented to calculate fitness in addition to the predicates original behaviour.
the code is also instrumented to collect run time values to be used in subsequent dynamically mined value seeding.
the static analyser performs the analysis needed to resolve the issues mentioned in section iii a. the results are stored in the analysis data repository and used later by the search based tester.
the constant extractor mines the code for constants to be used in subsequent static constant seeding.
the input format extractor analyses the code to extract the input vector.
the file tree analyser generates a tree in which nodes denote files and edges denote include relationships.
this information is used to determine the top level test units to be processed.
fig.
.
swat tool architecture the input type and login discoverer component performs a simple combination of static and dynamic analysis to infer input types and to identify the login process.
this is the only component for which results need to be augmented manually this is because the technique for type inference is unable to infer types for all inputs.
the login discoverer is used to dynamically extract the variables used to store the username password login url and any other inputs that need to be set for login.
the concrete values for username and password are provided to the tool.
stratego xt and php front were used to develop thepredicate expander the instrumenter the static analyser and the static analysis part of the input type and login discoverer.
stratego xt is a program transformation language and phpfront provides libraries for stratego xt supporting php.
the input format extractor was taken from the php front project with minor alterations.
all other transformation tools have been developed from scratch.
the dynamic part of the input type and login discoverer was developed using perl and java.
the search based tester uses the transformed source code and the analysis data to implement the input generation described by algorithms and the augmentations needed for scs anddmv .
the test harness uses the generated test data to run the tests on the original source code and to produce coverage and bug data.
when a test case is executed the generated html together with the web server s error logs are parsed for php execution errors.
the search based tester and test harness are implemented in perl and use the http html and lwp libraries.
v. e valuation for the evaluation we implemented three versions of the tool.
each version adds one of the enhancements described in section iii c in the following way nms implements the near miss seeding unaugmented approach described in algorithm in section iii c. scs isnms with static constant seeding.
dmv isscs with dynamically mined value seeding.
each branch was allocated the same budget of fitness evaluations for each version of the tool.
in this way we can evaluate the effects of each of our enhancements on the unaugmented traditional search based approach.
we designed our experiment to answer the following research questions rq1 how does each of our enhancements affect branch coverage?
to answer this question we compare branch coverage for each of the algorithms.
coverage was measured on the original untransformed application.
the original application was instrumented to record coverage without the transformations to expand predicates and calculate fitness.
rq2 how does each of our enhancements affect efficiency of the approach?
to answer this question we calculate the number of fitness evaluations needed per application and per branch.
we also report the elapsed time and cpu time used in testing per application and per branch.
rq3 how does each of our enhancements affect fault finding ability?
to answer this question we use an automated oracle to compare the fault finding ability of the test suites produced by each enhancement.
the automated oracle parses php error logs and the html output for execution errors and warnings.
we perform a wilcoxon unpaired one sided signed rank test at the confidence level to determine the statistical significance of the observed results.a.
web applications studied for the evaluation we used the same php applications used by other research on web testing using non search based approaches .
these applications range from small to mediumsized applications.
table i provides a brief quantitative and qualitative description of each application.
table i the web applications used in the study php php app name version files eloc description faqforge .
.
faq management tool schoolmate .
.
school admin system webchess .
.
online chess game phpsysinfo .
.
system monitoring tool timeclock .
.
employee time tracker phpbb2 .
.
customisable web forum b. experimental set up we ran each of the versions of the tool times on each of the php applications and collected coverage data.
we provide data for repeated runs in order to cater for the stochastic nature of the search based optimization that lies at the heart of our approach.
multiple runs are samples from the space of all possible runs.
with runs of each algorithm a sufficient sample size for statistical significance testing is provided.
the tool was executed on an intel core duo cpu running at ghz with gb ram.
the applications were installed and set up locally on the same machine used to generate inputs.
the database for each of these applications was set up following an identical systematic strategy as follows all tables are populated in a minimal manner but such that each table contains at least one record and a record is created for each possible value of a column of an enumerated type.
all applications except one phpsysinfo use a database.
for configurable applications all features were enabled where the application permitted it.
where login is required to use the web application a valid username and password pair was supplied to the tool.
c. branch coverage table ii summarizes the results obtained by the experiment.
coverage results are reported together with the number of test cases generated to achieve this coverage.
the number of covered branches increases with scs for all applications.
webchess displays the highest improvement with an increase in coverage.
overall scs recorded an average increase in coverage of .
compared to nms .
covered branches also increase with dmv for all applications studied.
an average improvement of .
was observed in branch coverage over all applications with faqforge showing the highest improvement.
figure shows the variation in branch coverage achieved over runs of each approach.
we notice that dmv s lowest coverage is higher than the highest coverage of other approaches for of the applications.
for of the applicationsnms shows little or no variation over runs.
for all applications studied we found a statistically significant increase in branch coverage at the confidence level for dmv compared to scs andnms .
in three applications running the same test suite twice can produce different branch coverage levels on each occasion.
eliminating this non determinism is not desirable because it manifests important aspects of the application.
investigating the branches covered we made the following observations when a new game is initiated in webchess the user can either choose his her preferred colour or choose random.
a similar issue is found in phpsysinfo where the user can select the template of the output or select random.
timeclock has a weather display feature that when enabled fetches the current weather information from the internet and displays it.
the current weather information affects coverage of the branches that control the format in which this weather information is displayed.
d. efficiency to measure efficiency we recorded average execution times and measured effort for each approach over runs.
our reported cpu time does not include time spent calling and processing the php application which our reported elapsed time does .
effort is the ratio between total number of fitness evaluations and branches covered.
effort is the more reliable empirical assessment of the search algorithm time complexity since it is unconfounded with difficulties of measuring time in a multi process environment.
however figures for elapsed time are more useful as a rough guide to likely overall test data generation time performance for each application which is affected by the system under test as well as the performance of the algorithms.
effort and time results are reported in table ii.
effort decreases with each of the two algorithmic enhancements for all applications except timeclock for which effort increases.
overall applications studied scs decreased effort per covered branch by an average of .
while dmv decreased effort by a further .
.
faqforge is processed the fastest min while phpbb2 is the slowest with an average of approximately minutes per run for dmv .
of course our tool is only a research prototype.
however even this worst case can be a accommodated within a daily build cycle with overnight automated test data generation.
e. fault finding ability in order to ensure that our determination of whether or not swat has found a fault is free from experimenter bias and subjectivity we use an automated oracle.
therefore our reported results for faults found are lower bounds guaranteed to be free from false positives.
our oracle parses php error log files and the output html page of each test case for faults.
only distinct faults counted.
in table ii crashes indicate php interpreter fatal execution errors these are errors that cause the execution of scriptstable ii average coverage and execution time results obtained by running each algorithm 30times for each application with the same budget of evaluations per branch for each version .
effort is the number of evaluations per branch covered .
results in bold are statistically significantly better than the results above them using the wilcoxon s test confidence level .
total test fitness covered branches elapsed time cpu time average faults found app name alg branches cases evals num effort time per br time per br crash error warning faqforgenms .
.
.
.
.
.
scs .
.
.
.
.
.
.
dmv .
.
.
.
.
.
.
schoolmatenms .
.
.
.
.
.
.
.
scs .
.
.
.
.
.
.
.
dmv .
.
.
.
.
.
.
.
webchessnms .
.
.
.
.
.
.
scs .
.
.
.
.
.
.
dmv .
.
.
.
.
.
.
phpsysinfonms .
.
.
.
.
.
scs .
.
.
.
.
.
.
dmv .
.
.
.
.
.
.
timeclocknms .
.
.
.
.
.
scs .
.
.
.
.
.
dmv .
.
.
.
.
.
.
phpbb2nms .
.
.
.
.
.
.
scs .
.
.
.
.
.
.
dmv .
.
.
.
.
.
.
a faqforge b schoolmate c webchess d phpsysinfo e timeclock f phpbb2 fig.
.
coverage results over runs of each of the algorithms on each of the web applications.
to abort.
errors indicate php interpreter warnings these are defined in the php manual as non fatal errors.2errors include those parsed from the output html.
warnings indicate php interpreter notices and strict warnings.
figure shows the variation in total faults found for each application over runs.
some of the faults found indicate a faqforge b schoolmate c webchess d phpsysinfo e timeclock f phpbb2 fig.
.
fault results over runs of each of the algorithms on each of the web applications.
a lack of adequate validation of inputs before use in critical operations such as database queries.
inputs are concatenated directly to sql statements which could cause a security threat.
in some cases where faults were parsed from the generated html the sql statement that caused the error was displayed to the user giving hackers the opportunity to analyse the statements and form an sql injection attack.
phpbb2 uses an input field to redirect requests to other parts of the site e.g.
after login .
this input field is displayed to the user in the query string and can be modified to potentially gain access to server files.
other faults found include inclusion of nonexistent files and wrong use of functions.
f .
answers to research questions in this section we answer the research questions we posed at the start of this section based on the empirical evidence from our experiments on the web applications.
answer to rq1 how does each of our enhancements affect branch coverage?
the results of the evaluation provide evidence to support the claim that each enhancement improved branch coverage for all of the applications under test.
in particular we note that dmv statistically significantly outperforms nms andscs for all applications studied.
scs also in turn achieved higher coverage than nms for all applications.
wilcoxon s test indicated these results tobe statistically significant for of the applications.
a closer look at the type of branches that were additionally covered by scs reveals that they are predominantly string predicates that involve constants.
in schoolmate and phpbb2 the improvement in branch coverage was not statistically significant.
this can be attributed to the fact that those two applications have relatively fewer constant using string predicates.
the average percentage of predicates that involve a string constant overall applications is while for schoolmate for example the average is only .
branch coverage results for dmv compared to scs statistically significantly increase for all applications.
by analysing additionally covered branches we find that dmv performs better than scs at covering constant using string predicates.
it also covers string predicates that are variable using rather than constant using.
as might be expected both algorithms appear to achieve higher coverage when the application contains key string predicates that uncover unexplored parts of the application under test.
our empirical results suggest that this situation may be sufficiently common for seeding to be very effective.
answer to rq2 how does each of our enhancements affect efficiency of the approach?
effort decreases statistically significantly by using scs rather than nms for all applications except one.
timeclock is the only application were effortincreased instead of decreasing.
this may be caused by the nature of constants mined from timeclock float constants mined from timeclock had a precision as high as decimal places while the highest for all other applications was decimal places.
assigning these constants to input variables when initializing the input vector may have in some cases not assisted and possibly even impeded the search process for timeclock.
using dmv caused effort to decrease for all applications except one.
wilcoxon s test indicated that this reduction was statistically significant in the cases where the reduction was observed.
like scs effort for timeclock increased with dmv .
this could be caused by the fact that the applications were transformed before running the tool to decompose and and or statements.
however coverage is measured on the untransformed version.
our transformation is merely an enabling testability transformation and it would be unreasonable to attach any importance to coverage of our own internal representation.
however this does account for the increase in effort for timeclock while for the untransformed version of timeclock the effort for nms is .
increasing to .
for dmv for the transformed version of timeclock this effort reduces from .
for nms to .
for dmv .
answer to rq3 how does each of our enhancements affect fault finding ability?
the number of errors and crashes statistically significantly increased by using scs for all applications where errors and crashes were found.
the same is observed for warnings for all applications except schoolmate.
this may be tied to the fact that coverage for schoolmate using scs does not increase statistically significantly.
all error types record an increase in numbers when using dmv for all applications where faults are found.
wilcoxon s test indicates that this increase is statistically significant for out of applications.
g. threats to validity and limitations the internal threats that could affect the validity of results depend on the set up of the applications.
results could be affected by database state and configuration.
to minimize bias a systematic procedure was defined for populating the database and configuring the application.
this procedure ensures that no prior knowledge about the applications under test can be exploited and is performed in the same manner for all applications.
external threats are related to the choice of applications and the degree to which one can generalize from the results obtained from those chosen for the study.
the applications were selected to provide compatibility with previous research on testing web applications.
however they are real applications used by real users as the high number of downloads from sourceforge indicates.
we took steps to insure that our results would be reproducible.
the state of the application was initialized before each test case is called.
the applications used are open source and thus publicly available.
bug reports are available online.
our overall aim is to produce a fully automated testing approach that generates tests runs them and reports faults found entirely automatically.
however there are some aspects of the overall approach that are not as yet fully automated.
deciding input types is partially manual.
username and password information also needs to be provided by the user.
some data types used in predicates are not yet supported by the instrumenter.
enhancing the tool to handle all data types and defining better fitness functions for arrays and objects may further improve coverage.
vi.
r elated work search based software engineering sbse has been widely used in testing both functional and non functional properties of applications .
however despite much work on sbse search based test data generation has not previously been applied to automated test data generation for web applications.
marchetto and tonella extended their state based approach for testing ajax web applications by using a search based technique to select test case sequences.
the approach used a hill climbing algorithm to construct test sequences that maximize the diversity of the test suite.
this is important because of the asynchronous nature of ajax application communication with the server which is absent from non ajax applications such as the ones we study.
in the present paper we applied search based testing to web applications and introduced using dynamically mined value to the search process.
we also imbued our work with ideas collected and adopted from several previous approaches in the sbst literature.
our approach retains the alternating variable method a vm introduced by korel in adopted form.
our approach to search exploration adopts a similar systematic technique for branch order to that used by michael et al.
for c programs using evolutionary algorithms.
michael et al.
also keep track of inputs that caused the branch to be reached to use as seeds.
however the overall algorithm and application domain being stand alone c applications was very different to ours.
seeding constants gathered from the source code to the search space and using the levenshtein distance to measure fitness for strings was first proposed by alshraideh and bottaci .
we used the same idea to enhance our tool and applied it to larger scale web applications implemented in php.
zhao et al.
also used search based techniques to generate string test data for boundary value testing.
halford et al.
introduced an algorithm that uses symbolic execution of the source code to group inputs into interfaces.
the approach was applied to java applications while our approach is applied to php applications.
wassermann et al.
also used symbolic execution to generate test data for web applications.
however their work focused on sql injection attacks and examined only functions that call database queries.
artzi et al.
automatically generated test cases for dynamic web applications using dynamic symbolic execution.
their approach also targeted php applications .
however thetwo approaches differ in the test adequacy criteria statement coverage vs. branch coverage .
their approach also produces a different number of test cases since all test cases generated during the run of the tool are collected.
their algorithm minimizes the test suite in regards of faults found using an automated oracle similar to the one we use in the evaluation for fault localization.
while our approach seeks to produce a test suite that achieves branch coverage.
using session data to test web applications was first proposed by elbaum et al.
and later extended by others .
in the study by elbaum et al.
a comparison between structural testing and testing using session data was performed.
the results showed that structural testing such as ours and reuse of session data can be expected to be complementary testing techniques.
the nature of web applications makes it easily possible for users to bypass input validations coded in the client side interface e.g.
javascript by submitting requests directly to the server.
this poses a threat that bypass testing exposes to help prevent such attacks.
therefore offutt et al.
introduced the idea of bypass testing.
in our work we also bypass the interface to generate data for the server side code directly.
the test data although not specifically generated for bypass testing could be used for that purpose.
vii.
c onclusion in this paper we introduced a set of related search based testing algorithms adapted for web application testing and augmented the approach with static and dynamic seeding.
we introduced a tool swat that implements our automated test data generation approach for php web applications.
our approach draws on more than ten years of results reported for search based testing as applied to conventional stand alone applications seeking to exploit and build upon best practice and proven results where possible.
however as the paper shows there are many issues raised by web application testing such as dynamic type binding and user interface inference that create novel challenges for search based testing that have not previously been addressed.
we also show how our novel dynamically mined value seeding approach can significantly reduce effort and increase effectiveness for web application testing.
we report on an empirical study that evaluates our approach on php web applications ranging in size up to 20k loc presenting results concerning coverage various measures of test effort and also an analysis of fault detection ability.
our tool detected an average of faults and warnings over all applications studied.