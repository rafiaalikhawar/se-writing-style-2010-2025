tracking down root causes of defects in simulink models johanna schneider daimler ag boeblingen germany johanna.schneider daimler.com abstract being confronted with a defect in software leads to the well known task correcting the software such that the defect does not occur anymore.
here the location of the defect and the corresponding root cause do not have to be identi cal.
thus before any correction can be done the reviewer has to detect the root cause for the defect.
in order to reduce the reviewing effort this paper presents a method toautomatically narrow down possible root causes for defects found in simulink models.
starting at a defect location a backward search is applied to detect all paths leading tothat defect.
each path is weighted by previously determined weights depending on the block types contained in the respectivepath.
thisweightingcorrelateswiththeprobabilityof a path containing the root cause.
categories and subject descriptors d. .
debugging aids general terms verification keywords root cause detection run time errors simulink models .
introduction consider the defect index exceeds matrix dimensions displayed by matlab when calling a array at index .
in this case one possible root cause for the returned de fect is obvious index is larger than the size of the array.the same defect becomes quickly more complicated.
if the index is not given explicitly as a constant value anymore but calculated during several mathematical steps it mightbe complicated to locate the root cause for the index being larger than .
another possible root cause may also be the size of the array.
there might have happened a fault while permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise orrepublish to post on servers or to redistribute to lists requires prior speci fic permission and or a fee.
request permissions from permissions acm.org.ase september vasteras sweden copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
figure two stage process.
generating the array.
during studies of simulink models in the automotive industry it turned out that several defectsare related and so are their root causes.
thus the idea is to learn from defects in already existing models and their known root causes.
this paper describes two processes offline phase calculation of block weights using already analyzed models online phase tracking down root causes for defects in currently analyzed models.
for the given models defects and root causes in process all paths leading to the respective defect are determined.
there are two kinds of paths those containing root causesand the remaining ones.
here the paths consist of simulinkblocks having different block types like addition switch etc.
the found paths are now weighted.
the weight of apath depends on its length and the contained block types.thus the block types shall be weighted such that those paths containing root causes get a higher weight than the remaining ones.
this calculation is formulated in form ofa nonlinear optimization problem.
in process again all pathsarefoundleadingtothecurrentdefectandalsoweighted.
the higher a path weight the higher the probability ofthe path containing the root cause.
the aim of this process is to reduce the manual effort while reviewing a simulink model.
during the whole process the model is not exe cuted thus the process is a static one.
after giving some general information about simulink the two stage process presented in figure is described.
the first stage is the cal culationof the block weights the second one the detection ofthe most likely root cause.
the second stage is then applied to two examples a simple one to demonstrate the method and a second one taken from the automotive industry.
sec tion finishes with remarks to the described method.
in section the results of the overall application are given.
it is shown that the effort of narrowing down the root causescan be reduced by .
compared to the worst case manual analysis.
related work is presented in section .
finally a summary is given combined with future work in section .
.
determining root causes as already mentioned simulink models are analyzed.
simulink by mathworks is a block diagram environment for multidomain simulation and model based design.
it supports system level design simulation automatic code generation and continuous test and verification of embedded sys tems .
in general a simulink model consists of blocks and lines.
the blocks represent actions like mathematical opera tions addition multiplication etc filter operations and soon.
one special kind of blocks is a subsystem.t h e yh e l p the developer to keep a system clearly structured i.e.
the system level design .
the blocks are connected by lines the signalflow.
withinthispaper abackwarddepth firstsearch is applied.
to do this the model is seen as a directed graph the blocks in the model become the nodes in the graph the signals become the directed edges.
in order to get one con nected graph instead of several connected components some block types like subsystem orgoto from have to be treated in a special way.
when talking about the backward depthfirst search the expression pathoccurs.
within this paper a path is a sequence of nodes with a directed edge in be tween.
thus in a simulink model a path consists of blocksand signal lines in the graph of nodes and edges.
for thesake of simplicity the lines or edges are not mentioned when describing a path.
two additional definitions are necessary here as well defectand root cause .
a defect is a weakness of the software that leads to unintended or unexpected behavior.
the root cause is the reason for this defect.
as an example a division by zero is a defect whereas the rootcause may be the command when the divisor becomes zero.
.
determining the defects before the search for the root cause can be applied defects and their location must be found.
there are severalapproachesingettingthosedefectsliketestingorstaticanal ysis.
here the latter one is chosen.
thus also the way ofdetermining the defects is a static process.
in this case c code is generated from the simulink model using the tool targetlink by dspace .
this generated code is ana lyzed by polyspace mathworks .
polyspace helps to detect and prove the absence of overflow divide by zero out of bounds array access and other run time errors in sourcecode.
polyspace products use static code analysis and formal methods with abstract interpretation to verify c and c or ada code.
you can use polyspace static analysis toolsto verify both handwritten and generated code for embedded software .
polyspace returns four kinds of messages during the analysis green no run time error found at this location red actual run time error found at this location orange potential run time error found may be because of imprecision of the tool since it overapproxi mates the code gray deadorineffectivecode i.e.
thosedefectstreatedwithin this paper .
note that dead code is not a defect like array out of bounds or division by zero.
however the maintainability is influenced in a negative way since there are redundant blocksused.
furthermore more memory is used than necessary.
there are also situations when a false block property leads to dead code.
thus it may help to find such defects.
some times dead code is desired for example in variant handling.the location of the defect can be mapped onto the corresponding block in the simulink model.
nowadays mathworks supports this mapping .
otherwise the commentsof the code generator targetlink can be used in order to get the block name.
based on the blocks obtained in this way the detection of the most likely root causes can be applied.
.
weighting of the blocks before the weights of the blocks can be determined already analyzed models of the automotiveindustryare taken.
thus the list of defects is known.
comparing the respective modelversionwithitssuccessor bugfixesbecomevisibleandthereby the root causes for the defects.
the defects are then mapped to the simulink model.
the mapped blocks are now taken as the starting blocks for the modified backwarddepth first search findpaths findpaths u path allpaths input node u current path path a l lp a t h s allpaths output all paths allpaths adj adj u adjacency list of node u ifadj u does not have adjacent nodes allpaths else for i 1tolength adj v adj i if v not in path v not yet in path path allpaths findpaths v path allpaths else v already in path path allpaths end end end this algorithm is based on the pseudo code described in and modified such that a block can be visited several times and such that the paths are saved.
the aim of this search is to determine all paths leading to the respectivedefect block.
when a loop is detected inside one path the search finishes for this path.
otherwise the search would be infinite.
however the block closing the loop is added to thepath to give the path an additional weight.
as an example in case of the defect type overflow the iterative addition of several signals within a loop may cause the defect with a higher probability than outside a loop.
600figure example offline phase environment.
figure example offline phase subsystem.
there are two kinds of paths those containing the actual root cause and the remaining ones.
for both kinds a matrix is generated respectively r root causes and p remaining paths .
while a row depicts a path each column represents ab l o c kt y p e r i j blocks of type jin path i b l o c k si np a t h i. thus each entry in the matrix is divided by the respec tive path length.
otherwise long paths would dominate thecalculation.
consider the example model in figure andfigure .
the corresponding code part is shown in figure .
the message reported by polyspace is if condition always evaluates to false marked by the cross i.e.
at the block logop a. because of the description of the bugfix it is known that the corresponding root cause denoted by the bug is the block memory u. there are four paths leading to the defect within the model p logop a logop n u u1 p2 logop a switch r iv iv1 p3 logop a switch r r r1 p4 logop a switch r memory u u u1.
figure example offline phase code.block type weight constant .
enableport .
gain0.
logic .
switch table extract of the scaled solution of .
the path p4is the one containing the root cause for this defect i.e.
this path has to be described by the matrix r r parenleftbiglogop switch inport unitdel const p41 parenrightbig .
the matrix pis built analogously p logop switch inport unitdel const p12 p21 p31 .
letxbe the array containing the weights for the blocks thus unknown yet.
for this example it yields x w logop w switch w inport w unitdel w const .
the idea is to calculate xin a way such that each entry of r xis larger than each entry of p x i.e.
r x min p x max.
here r x minrepresents the minimal entry of the matrix vector multiplication analogous is p x maxthe maximal value of the array p x. the equation states that the paths containing root causes shall get a higher weight than the remaining ones.
a solution for xis obtained by formulating this as a nonlinear optimization problem max x r x min p x max min x p x max r x min with constraint xi i n where nis the length of array x. the nonlinear optimization problem is solved using the matlab command fmincon.
the resulting array is subsequently scaled to which still satisfies .
until now defects of type unreach able ineffective code in models of the automotive industry are used for the calculation of the block weights.
there are paths leading to those defects thereof 27paths containing the respective root cause.
the matricesrandpare built like shown before r r p r19 .
the number of columns is since there are different block types contained within the paths.with those two matrices the nonlinear optimization problem is solved.
an extract of the solution is presented in table .
601figure example model.
.
detecting the most likely root causes in the previous section it is described how the weights for the different block types are calculated.
this is done only once during the offline phase.
thus these weights shall be valid for all models to be analyzed for a certain kindof defect.
in order to determine the most likely root causeswithin the online phase the first steps are the same like during the calculation of the block weights.
first the defects are determined and mapped to the corresponding simulinkblocks.
the following is done for each of these blocks successively.
again the backward depth first search is applied to the current block in order to detect all paths leading to it.in contrast to the process of the calculation of the weights only one matrix pis created now it is not yet known which of these paths contain the root causes .
most important is to keep the order of the block types i.e.
the columns the same as during the calculation of x. now the matrix pis multiplied by the weights x w p x. the entry iofwcorresponds to the weight of path p i.t h i s multiplication is equivalent to the expression w i summationtext bl p iw bl pi with bl pia block in pi w bl the weight of block bland pi t h en u m b e ro fb l o c k si np a t hp i. the paths leading to the highest entry of the returned array are the pathscontaining the most likely root cause.
as a last step the reviewer himself has to decide the final root cause.
thus the presented method reduces the reviewing effort in a huge dimension.
since this method is a heuristic process it may happen that the search for a root cause is not successful.
.
application consider the simulink model in figure .
polyspace returns a gray message for the code if if condition always evaluates to false .
a mapping to the model leads to the block enablein the subsystem called enabled subsystem the symbol at the top within enabled subsystem .
this means that the signal leaving the block switchalways has the same value in this example always .
thus the enableblock becomes the starting block for the described method.
first all paths leading to that block are detected p1 enable switch gain constant p2 enable switch constant1 p3 enable switch logical operator constant2 .figure environment of figure .
thematrix pdescribingtheblocktypesineachpathisbuilt like shown before.
due to lack of space only a reduced ma trix pispresentedhere theoriginalmatrixhas33columns .
thus only the columns representing block types containedwithin the path are shown p const enable gain logic switch p p211 p311 .
dividing each row by its sum leads to the matrix p const enable gain logic switch p p21 p31 .
this matrix is now multiplied by the reduced array x w const w enable w gain w logic w switch with weights taken from table p x p1 .
.
.
.
.
.
.
w p w p2 w p3 .
thus the path with highest path weight is p .
indeed this is the path influencing the result of the switchblock i.e.
the decision signal.
since the signal is constant always the same signal leaves the switchblock the outgoing signal of the block logical operator .
this signal is also constant and therefore the entry into to the enableblock is always the same.
hence path p2together with path p3 i.e.
the path with second highest weight contain the root cause forthe ineffective model part.a more complex example is presented in figure .
thecontained subsystem turnoffdelaytime is taken from the automotive industry and shown in figure .
the environ ment in figure is built up similar to a real model.
intable the returned messages by polyspace are presented.
since the blocks switch r1 and switch r2 depend on the outgoing signal of the block logop r only the latter one is taken for the analysis.
this situation is described in detailin section .
.
applying the presented method to the block logop r leads to paths with length of up to .
the minimum of the returned path weights is .
the maximal weight is .
followed by the weight .
.
the path having the maximal weight is the one containing themarked blocks in figure and logop r r constant .
602figure subsystem turnoffdelaytime of figure .
block corresponding code polyspace message logop r if r if condition always evaluates to false switch r1 if logop r if condition always evaluates to false switch r2 if logop r if condition always evaluates to false table defects in figure and figure .
because of the value 0of the constant block the result of theandoperation is always .
thus the root cause is the constant block which is contained within the path found by the presented method.
the average time based on runs of applying the method to this example is approximately0.
seconds.
.
outliers in the previous example only one reported message is pursued although three messages are reported.
the reason isthat the outgoing signal of logop r is the decision signal of the two switchblocks switch r1 and switch r2.t h u s if the signal of logop r does not change always the same signal is chosen within the switchblocks.
this yields to the messages by polyspace presented in line and in table .
so in this case it is useful to apply a kind of dependence analysis before a root cause is searched for a defect it is checked whether the reported message may arise because ofa preceding defect.
using a breadth first search a path from a defect xto a defect yis searched.
if such a path exists the defect yis negligible.
in the example above there exist paths from the block logop r to both switchblocks and therefore the two blocks are not considered.
the most im portant thing to keep in mind when applying the presented method the root cause does not have to be unique and it is also possible that several paths contain parts of the rootcause like the paths p 2and p3in figure .
.
results as described in section .
defects with overall paths leading to them are taken for the calculation of 33block weights during the offline phase.
during the onlinephase the presented process is applied to simulink modelsdescribingcomfortsystemswithincarslikepowerwindow controlorseatheatercontrol.
thosemodelscontainapprox imately between and blocks.
first c code is generated for all models using targetlink.
the analysis of this code by polyspace yields defects of kind unreach able code.
example reasons for reported unreachable code messages are the command a !
a or a constant decision signal entering a switchblock.
after the mapping to the simulink models all paths leading to those defects are figure distribution of paths per defect.
path p p a t h s reviewed found root causes of total paths max .
.
2ndmax .
.
3rdmax .
table review effort success during the online phase.
found.
thereare48 326paths wherebythenumberofpaths found per defect ranges between and approximately .
the precise distribution is presented in figure .
there are defects with only one path leading to it so their pathcontaining the root cause is obvious.
thus those defectsare neglected here.
hence defects and paths are remaining.
now the paths are weighted using the weights calculated during the offline phase.
afterwards the pathsare sorted by descending weight for each defect respectively.
the results of the review process is shown in table .
for each defect the path with highest weight path p max i s reviewed.
within those paths root causes are found i.e.
.
.
there are defects left with unknown root causes.
so for those defects also the paths with sec ond highest weight path p ndmax are reviewed.
this leads to additional root causes and left defects.
here the paths with third highest weight path p rdmax a r e additionally reviewed leading to all root causes.
overall paths are reviewed in order to find all root causes.
comparing this to the number of all found paths this method only takes .
of the worst casereview effort in searching for the root causes.
.
related work in and the authors search for root causes why a test case makes a program fail.
the first step is to eliminateeverything irrelevant for this failure.
this is nearly similarto the search for all paths leading to a defect presented in my approach.
then there is searched for a passing test case.
the difference between the failing and the passing test casesshall be minimal since this difference is declared to be theroot cause for the failure.
another approach to determine root causes is presented in .
the authors describe the cause of an unsat part as the union of all minimal un satisfiable subsets mus .
papers like or are about regression failures or software changes.
within those papers i found ideas which may help during the offline phase.
untilnow the different versions of the same model are compared manually in order to detect the corrections and root causes.
ifitispossibletotransferthepresentedmethodstosimulinkmodels this procedure can be automated and reduces the manual effort again.
.
conclusion this paper introduced a method to narrow down root causes for defects in simulink models in a static way.
first within the offline phase weights for different block types arecalculated based on experience of already analyzed models and nonlinear optimization.
this is done once independent from the current model.
for the current model the onlinephase is applied.
the defects are determined using abstractinterpretation for the generated code of the model.
then a mapping from the defects in the code to the corresponding blocks in the simulink model is done.
now all paths lead ing to such a block are found using a backward depth first search.
each path is weighted depending on the contained kinds of block types and the length of the path.
the pathswith highest weight are presented to the reviewer such that he finally has to decide which one s to choose.
so he only has to review a few paths instead of the whole model.
thismethod is successfully applied to several simulink models from the automotive industry with respect to the defect unreachable ineffectivecode.
pleasenotethatthereisnoguar antee that the method leads to the actual root cause because thedescribedprocessisbasedonaheuristicapproach.
additionally it may be possible that more information is neededin order to find the root cause like requirements which arenot given within the model.
this method has been developed since several defects and their root causes are related.
thus another approach would be to search for certain kindsof patterns instead of paths leading to the defects.
an additional aim is to extend this method to other kinds of runtime errors which can be found by polyspace like array outofbounds divisionbyzeroandso on.
here probablyorange messages by polyspace have to be analyzed in order to decide whether the message is an actual defect.
to reduce themanual effort abstract interpretation can be combined with bounded model checking like in .
if this method can be applied successfully also to those kinds of defects the maingoal is to develop an automated correction of the defects.another extension is a refinement of the block weights af ter each successful application of this process the analyzeddefects and paths are added to the list of defects for whichthe root causes are already known.
thus the nonlinear optimization can be applied again to obtain refined values for the block weights.
.