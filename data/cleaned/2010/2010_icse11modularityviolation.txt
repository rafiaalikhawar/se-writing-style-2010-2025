detecting software modularity violations sunny wong and yuanfang cai drexel university philadelphia pa usa sunny yfcai cs.drexel.edumiryung kim the university of texas at austin austin tx usa miryung ece.utexas.edumichael dalton drexel university philadelphia pa usa mcd45 cs.drexel.edu abstract this paper presents clio an approach that detects modularity violations which can cause software defects modularity decay or expensive refactorings.
clio computes the discrepancies between how components should change together based on the modular structure and how components actually change together as revealed in version history.
we evaluated clio using releases of hadoop common and releases of eclipse jdt .
the results show that hundreds of violations identified using clio were indeed recognized as design problems or refactored by the developers in later versions.
the identified violations exhibit multiple symptoms of poor design some of which are not easily detectable using existing approaches.
categories and subject descriptors d. .
maintenance and enhancement refactoring restructuring d. .
design modularity violation refactoring general terms design rule theory refactoring keywords modularity violation detection refactoring bad code smells design structure matrix .
introduction the essence of software modularity is to allow for independent module evolution and independent task assignment .
in reality however two modules that are supposed to be independent may always change together due to unwanted side effects caused by quick and dirty implementation.
for example inexperienced developers may forget to remove experimental scaffolding code that should not be kept in the final product and an application programming permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro fit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior speci fic permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.interface api may be accidentally defined using non api classes .
such activities cause modularity decay over time and may require expensive system wide refactoring.
though empirical studies have revealed a strong correlation between software defects and eroding design structure traditional verification and validation techniques do not find modularity violations because these violations do not always influence the functionality of software systems directly.
this paper presents clio an approach that detects and locates modularity violations .clio compares how components should change together based on the modular structure and how components actually change together as reflected in the revision history.
the rationale is that if two components consistently change together to accommodate modification requests 1but they belong to two separate modules that are supposed to evolve independently we consider this as a modularity violation .
clio has three components.
the first component calculates structural coupling how components should change together based on baldwin and clark s design rule theory and design structure matrix dsm modeling.
the second component extracts change coupling how components actually change together through mining the project s revision history.
the third component identifies modularity violations by comparing the results of structural coupling based impact scope analysis with the results of change coupling based impact scope analysis.
we applied clio to the version histories of two large scale open source software systems releases of hadoop common 2and releases of eclipse jdt.3our evaluation strategy was to identify violations for each pair of releases.
if a violation was indeed problematic it is possible that developers recognized and fixed it in a later release through a refactoring.
we considered a detected violation as beingconfirmed if it was indeed addressed or recognized by developers later.
we used two complementary evaluation methods.
first we compared the detected violations with refactorings automatically reconstructed using kim et al.
s api matching technique .
second we manually examined modification requests to see whether those violations were at least recognized by developers.
because it is possible that problems in recent versions are not yet recognized by the developers we also manually examined the corre1consistent with ying et al.
a modification request can be a bug fix or feature enhancement.
the set of files that resolve a modification request is called its solution .
code to determine whether the detected violations reveal symptoms of poor design.
we identified modularity violations from modification requests of hadoop of which violations were confirmed.
from modification request of eclipse jdt clio identified modularity violations which shows that the changes in eclipse better match its modular structure.
among these violations were confirmed.
the results also show that clio identifies modularity violations much earlier than manual identification by developers so that designers can be alerted to avoid accumulating modularity decay.
third the identified violations include symptoms of poor design some of which cannot be easily detected using existing approaches.
the rest of this paper is organized as follows.
section presents related work and how clio differs from existing approaches.
section describes our modularity violation detection approach and several background concepts.
section details our evaluation method and empirical results.
section discusses the strengths and limitations of clio and section concludes.
.
related work in this section we compare and contrast clio with other related research topics.
automatic detection of code smells.
fowler describes the concept of bad smell as a heuristic for identifying redesign and refactoring opportunities.
example bad smells include code clone and feature envy.
garcia et al.
proposed several architecture level bad smells.
to automate the identification of bad smells moha et al.
presented the decor tool and domain specific language dsl to automate the construction of desig n defect detection algorithms.
several other approaches automatically identify bad smells that indicate needs for refactorings.
for example tsantalis and chatzigeorgiou s technique identifies extract method refactoring opportunities using static slicing.
detection of some specific bad smells such as code duplication has also been extensively researched.
higo et al.
proposed the aries tool to identify possible clone refactoring candidates using structural metrics e.g.
the number of assigned variables the number of referred variables .
clio s modularity violation detection approach is different in several aspects.
first it is not confined to particular types of bad smells.
instead we hypothesize that multiple types of bad smells are instances of modularity violations that can be uniformly detected by clio.
for example when code clones change frequently together clio will detect this problem because the co change pattern deviates from the designed modular structure.
second by taking version histories as input clio detects the most recently and frequently occuring violations instead of bad smells detected in a single version without regard to the program s evolution context.
similar to clio ratzinger et al.
also detect bad smells by examining change coupling.
their approach leaves it to developers to identify violations from the visualization of change coupling while clio locates violations by comparing change coupling with structural coupling.
the detected violations thus either reflect the problem in the original design or introduced in the subsequent modification requests.
design structure matrix analysis.
some of the most widely used design structure matrix dsm tools in clude lattix 4struture 5and ndepend.6these tools support automatic derivation of dsms from source code modeling the syntactic dependencies between classes or files.
different from these tools the dsms used in clio are generated from augmented constraint networks acns which separate the interface and implementation of a class into two design dimensions and manifest implicit and indirect dependencies that cannot be revealed by a syntactical dsm .
sangal et al.
describe how to use lattix to identify undesired dependencies.
using lattix a user can specify which classes should not depend on i.e.
syntactically refer to which other classes.
the tool raises an alert if a predefined constraint is violated.
a key difference between clio s and lattix s detection techniques is that clio analyzes version histories to detect violations that occur during software evolution many of which are not in the form of syntactical dependencies and thus will not be detected by lattix.
another major difference is that clio takes recency and frequency into consideration when identifying modularity violations.
dependency structure and software defects.
the relation between software dependency structure and defects has been widely studied e.g.
selby and basili .
various metrics have been proposed e.g.
chidamber and kemerer to measure coupling and failure proneness of components.
the relation between change coupling and defects has also been recently studied.
cataldo et al.
s study reveal a strong correlation between density of change coupling and failure proneness.
fluri et al.
s study shows that a large number of change coupling relationships are not entailed by structural dependencies.
while the purpose of these studies are to statistically account for the relationship between software defects change coupling and syntactic dependencies clio s purpose is to locate modularity violations that may cause software decay and defects.
.
detection approach this section presents our modularity violation detection approach supported by the clio framework.7section .
provides an overview and the following subsections elaborate the major components and their background knowledge.
.
framework overview suppose that a number of modification requests mrs are fulfilled when a project evolves from version nton .
figure depicts how the project manager can use clio to determine whether these changes violate the designed modular structure so that modularity decay can be detected.
clio employs a plugin architecture and has three major components along with supporting tools.
the first major component dr predict computes a set of files that are likely to be changed together according to the designed modular structure section .
.
we leverage the design structure matrix dsm model which can be derived from an augmented constraint network acn a design model based on baldwin and clark s design rule theory .
an acn in turn can be derived from source code or design 7clio is the greek muse of history.models .
we introduce these background concepts in section .
.
figure shows that our framework provides a tool moka that can reverse engineer a uml class diagram from java binaries and a tool janus that convert the class diagram into an acn and a dsm to be used by the dr predict plugin.
the second major component logic predict plugin computes the components that are likely to be changed together according to change coupling derived by the extract plugin.
the extract plugin of clio first records the set of files changed together in transactions8of revision history and stores the support and confidence values of each change coupling into a database following the work of ying et al.
and zimmermann et al.
.
for the solution sof each modification request the logic predict plugin selects a subset of sthat exhibit the strongest change coupling with other files according to the change coupling database.
we call this selected set of files the starting change set .
the logic predict plugin predicts the change impact of as follows a file is predicted to be in the impact scope of if the corresponding association rule s support and confidence values are above the minimum support thsand confidence thcthresholds.9the impact scope of computed by logicpredict is noted as fileset b in figure .
the logic predict plugin shares the with dr predict so that both plugin components can compute the impact scope of the same set of files.
the modularity based impact scope of computed by the dr predict is noted as fileset a in figure .
since consists of files that reveal strongest change coupling with other files the discrepancy between s impact scopes based on structural couplings and change couplings is mostly likely to reveal modularity violations.
finally given aandb and a mr solution s the third major component of clio the detect plug in computes a set of discrepancies d b s a. by using b s the detect plugin filters out files that were accidentally changed together.
recurring discrepancies a subset of files in d are then reported to the users as violations .
since the logic predict plugin is a reimplementation of existing work in the following subsections we mainly elaborate the modularity based impact scope analysis approach embodied by the dr predict plugin section .
the necessary background of it section .
as well as the discrepancy calculation method embodied by the detect plugin section .
.
.
background this section introduces key background concepts of our modularity based impact scope analysis approach embodied by the dr predict plugin.
we first introduce the augmented constraint work acn model that is used to derive a design structure matrix dsm .
by clustering the dsm into a special form called the design rule hierarchy drh modules 8a transaction is defined as an atomic commit in a version control repository e.g.
subversion .
for repositories that do not natively support the concept of transactions e.g.
cvs heuristics and techniques e.g.
cvs2svn have been developed to reconstruct transactions.
9consistent with zimmermann et al.
the frequency of a set in a set of transactions tisfrq t x t t t x t .
the support of a rule x1 x2 by a set of transactions t issupp t x x2 frq t x x2 .
the confidence of a rule is conf t x x2 frq t x1 x2 frq t x1 .compiled binaries revision history modi cation requests solution sdiscrepancy dlogical depsmoka uml2acndr predict plugin extract plugin logic predict plugin detect pluginfile set bfile set a tool artifactdatabase figure approach overview the clio framework defined as independent task assignment can be automatically identified and visualized.
these modules form the basis of our change scope analysis approach.
figure depicts a uml class diagram for a maze game example used in our prior work .
a maze consists of a set of rooms that know their neighbors a wall or a door to another room.
the base class mapsite captures the commonality of all the maze components.
the diagram shows the abstract factory pattern to support two variations of the game an enchanted maze game and a bombed maze game.
we use this maze game as a running example to illustrate these concepts.mapsitewall door room maze bombedwall mazefactoryneedingspelldoor roomwitha enchanted room mazefactory mazefactorybombed enchantedbomb figure maze game uml class diagram augmented constraint network acn .
an acn consists of a constraint network and a dominance relation.
figure shows part of an acn derived from the above uml class diagram.
the constraint network models design deci sions as variables and model their assumption relations as logical constraints.
in the maze game example each class is modeled using two variables lines an interface variable10ending with interface and an implementation variable ending with impl .
each variable has a two value domain modeling a current decision and an unknown possibility.
lines to show several sample assumption relations.
for example since room inherits from mapsite its implementation makes assumption on both the interface and implementation of mapsite lines .
the dominance relation in an acn describe asymmetric dependency relationships among design decisions the essence of baldwin and clark s concept of design rules .
baldwin and clark coined the term design rules to refer to stable design decisions that decouple otherwise coupled design decisions hiding the details of subordinate components.
we emphasize that baldwin and clark s concept of design rule is different from the concept of rules used in other areas e.g.
the rules of not creating clones or cyclic dependencies but rather they are essentially generalized interfaces between components.
example design rules include abstract interfaces application programming interfaces apis or a shared data format agreed among development teams .
broadly speaking all non private parts of a class used by other classes can be seen as design rules.
for example line models that room s implementation decision cannot influence its interface design which is a design rule .
one should not arbitrarily change room s interface to improve its implementation because other components may depend on it.
in our previous work we defined eight heuristics to automatically derive dominance relations from reverse engineered uml diagrams.
dependencies of a uml class diagram such as method calls and object aggregations are used to derive constraints in the acn.
the details on all the heuristics is described in our prior work .
.
mapsite interface orig other .
mapsite impl orig other .
room interface orig other .
room impl orig other .
maze interface orig other .
maze impl orig other .
room impl orig mapsite interface orig .
room impl orig mapsite impl orig .
maze impl orig room interface orig .
mapsite impl mapsite interface .
room impl mapsite interface .
maze impl room interface figure partial maze game acn design structure matrix dsm .
figure shows a dsm automatically derived from the maze game acn.
a dsm is a square matrix whose columns and rows can be labeled with design variables of an acn.
each cell marked with x represents a pairwise dependency relation defined on acn if ydepends on x it means that ymust be changed 10aninterface variable in an acn represents the publicly accessible methods fields etc.
of a class.
it should not be confused with the programmatic interface construct provided by many object oriented languages.in one of multiple ways to restore the acn consistency that is broken by changes to x and that yis not a design rule ofx.
if so the cell on row y column xwill be marked.
for example cell r11 c2 indicates that room impl depends on mapsite interface .
design rule hierarchy drh .
in order to identify modules independent task assignments according to parnas definition our prior work defined a special clustering based on the acn called the design rule hierarchy drh .
using this clustering the columns and rows of the dsm can be reordered into layers that is a lower triangle form in which the top right corner is blank.
the first layer in a dsm l1 is the group of variables clustered at the top left corner and does not depend on any other layers.
a layer lnonly depends on layers ln 1tol1.
in a drh each layer contains a set of modules that are independent from each other.
in the dsm the modules are inner groups of variables along the diagonal and there are no dependencies between the modules within the same layer.
figure shows a dsm clustered into a drh with four layers outer rectangle in bold line along the diagonal in total the first layer r1 c1 contains the most influential design rules that must remain stable.
in other words changing the top level design rules maze interface andmapsite interface can have drastic effects on the system.
the second layer r3 c3 contains decisions that only depend on the top layer decisions r1 c1 .
similarly the third layer r713 c7 contains decisions that make assumptions about the decisions within the first two layers only.
within each layer there are inner rectangles along the diagonal line such as r1 c1 or r7 c7 .
they are modules containing decisions that can be made in parallel because there are no inter module dependencies within a layer.
for example mazefactory interface r7 and mazefactory impl r8 decisions can be made in parallel with other inner decisions of the same layer such as doorneedingspell interface r12 .
the modules in the last layer r14 c14 can be designed changed and replaced concurrently with each other not affecting the rest of the system.
for example the task of designing an enchanted maze game r16 and the task of designing a bombed maze game r20 can be independently accomplished.
.
modularity based impact scope analysis given a starting change set and a drh clustered dsm thedr predict plugin calculates the change impact of as follows all the files that belong to the same module of are within its impact scope if a file belongs to a module that depends on the module of then the more dependencies between the modules the more likely the dependent module is within the impact scope of the design rules of should never within its impact scope.
we leverage robillard s relevant artifact recommendation algorithm which identifies a subset of nodes in a graph relevant to the initial set of interests based on the graph s topology.
a drh clustered dsm can be represented as a directed acyclic graph where each vertex ucorresponds amodule in the dsm containing a set of decisions and each edge u v defines that changing a module umay affect a module v. to demonstrate our approach we depict a small subset of the maze game drh graph in figure for the purpose of illustration.
in figure we only show of the modules in layer modules each from layer andfigure maze game dsm and module from layer .
note that the edges of the drh graph are populated based on constraints in the acn as introduced in our prior work .
starting from the starting change set with shaded background and white text we assign a weight in the range to each vertex in a breadth first order.
the starting change set vertices are assigned the maximum weight of and added to a initial set of interests s. from vertex room interface we examine its neighbors the subordinate decisions that room interface influences and assign them a weight.
while traversing the graph to assign weights we ignore the starting change set s design rules because they are supposed to be stable.
for example since the room class is the starting change set row and row in the dsm in our example then its design rules mapsite s interface and implementation should not be within their impact scope.
robillard defines a formula for computing the weight of a vertex 0 sforward s sforward sbackward s sbackward using this formula we assign higher weights to vertices that share more edges with elements in the set of interest s. this allows us to identify the components that are likely to be affected by the starting change set due to the strengths of their design level dependencies.
is a weight and is a constant defined to determine the degree of relevancy propagation.
to start each iteration of the algorithm we take all the vertices that have just been assigned weights add them to the set of interest s and use them as the starting points for the next round of weight assignment.
we repeat this iterative process until the new weights fall below a certain threshold.
all vertices that were not assigned a weight are considered to have the minimum weight of .
figure shows 11following the results of robillard we use .
in our evaluation.
however the value of does not change the order of suggested elements so the choice of value is not important.the weights for each vertex after all weights are propagated.
the vertices whose weights are above the threshold thd e.g.
.
are then recommended as being in the impact scope depicted with a dashed enclosure .
.
discrepancy analysis given the impact scopes of the starting change set calculated by dr predict and logic predict the detect plugin ofclio calculates their discrepancies.
because the impact scope results vary with the thresholds selected our framework automatically chooses the thresholds with best accuracy measured u sing the standard f1value from information retrieval.
the dr predict plugin varies the minimum weight threshold thdfrom to .
in increment of .
to find a threshold that maximize f1.
similarly the logic predict plugin independently varies the support threshold from to and varies the confidence threshold from to .
in increment of .
to find the maximum f1.
given the most accurate predictions from dr predict and logic predict the detect plugin computes their discrepancies and identifies recurring discrepancies over multiple versions of the software using a frequent pattern mining algorithm .
the recu rring patterns among these discrepancies are called modularity violations .
consider two mrs with the same starting change set of a .
suppose that the set of discrepancies is a b c a b .
then we say that a b is a modularity violation that occurred twice and a b c is a modularity violation that occurred once.
for example enchantedmazefactory impl andbombedmazefactory impl are both located in the last layer of the drh meaning that they should evolve independently from each other.
clio sdr predict plugin would never report that they are within each other s impact scope.
if the revision history shows that they consistently change together e.g.
due to similar changes to cloned code clio would report that there is a modularity violation .
consider another example since mapsite interface is the design rule ofroom impl it is normal that mapsite interface changesroom interface room implmapsite interface enchantedroom interface enchantedmazefactory interface enchantedmazefactory impldoor interface mazefactory interface mazefactory implmapsite impl .84 .
.78layer layer layer layer figure maze game design rule hierarchy and influences room impl along with other dependent components.
but clio sdr predict plugin would never predict mapsite interface to be in the change scope of room impl .
if the revision history shows that mapsite always changes with room impl it is a violation because all other components that depend on mapsite may be affected causing unwanted side effects.
.
evaluation to assess the effectiveness of clio s modularity violation detection approach the evaluation aims to answer the following questions q1.
how accurate are the violations identified by clio?that is do the identified violations indeed indicate problems?
given the difficulty of finding the designers of the subject systems who can most accurately answer this question we evaluate clio retrospectively and conservatively we examine the project s version history to see how many violations we identified in earlier versions are indeed refactored in later versions or recognized as design problems by the developers e.g.
through modification requests source code comments .
the precision calculated this way is the most conservative lower bound estimation because it is possible that some violations we identified have not been recognized by the developers yet and could be refactored in the future.
we do not calculate the recall of our result because it is not possible to find all possible design issues in a system.
q2.
how early can clio identify problematic violations?
our purpose is to see if this approach can detect design problems early in the development process.
although it may not be necessary to fix a violation as soon as it appears making designers aware of violations as soon as possible can help to avoid accumulating modularity decay.
for each confirmed violation we compare the version where it was identified with where it was actually refactored or recognized by the developers.table characteristics of subject programs subjects sloc transactions releases mrs eclipse jdt 137k 222k hadoop 13k 64k q3.
what are the characteristics of violations identified by our approach?
we examined the detected violations corresponding code to see whether they show any symptoms of poor design and categorized the violations into four categories.
.
subjects we choose two large scale open source projects hadoop common and eclipse java development tools jdt as our evaluation subjects.
hadoop is a java based distributed computing system.
we applied our approach to the first releases .
.
to .
.
covering about three years of development.
eclipse jdt is a core ast analysis toolkit in the eclipse ide.
we studied releases of eclipse jdt from release .
to .
.
also covering about three years of development.
our evaluation used both their revision histories and source code.
for hadoop we investigated their svn repository to extract transactions.
eclipse jdt used cvs instead of svn so we use the cvs2svn12tool to derive the transactions.
in table we present some basic data regarding to hadoop and eclipse jdt that we studied.
we removed commits with only one file or more than files because they either do not contribute to clio s modularity violation detection or they include noise such as changes to license information.
for each release pair nandn we computed discrepancies between the results of structural coupling based impact scope analysis and the results of change coupling based impact scope analysis.
we then accumulated the discrepancies over the five most recent re leases to identify recurring violations.
the experiments showed that the results do not significantly differ if we aggregate discrepancies over more than five releases.
modularity violations that occurred at least twice in the last five releases v v r v m cv pr.
eclipse jdt hadoop .
evaluation procedure we ran our experiments on a linux server with two quadcore .6ghz intel xeon processors and 8gb of ram.
we evaluate the output of clio i.e.
a set of violations by checking the source code and mr records in later versions to see if they were indeed refactored or recognized as having a design problem.
if so we call such violation as being confirmed .
we use both automated method and manual inspection to confirm a violation.
first we compared the detected violations with refactorings that were automatically found by kim et al.
s api matching tool .
this api matching tool takes two program versions as input and detects nine different types of refactorings at a method header level.
it extracts methodheaders from both old and new versions respectively finds a set of seed matches based on name similarity generates candidate high level transformations based on the seed matches and iteratively selects the most likely high level transformation to find a set of method header level refactorings.
we chose this technique because it has a .
higher precision than other similar techniques according our recent comparative study .
as these automatically reconstructed refactorings are method header level refactorings we aggregated them up to a class level to compare with the violations clio identified.
we consider a violation as confirmed if it overlaps with any class level refactorings.
for each violation that is matched with a reconstructed refactoring we manually checked the refactoring to verify that it was indeed a correct refactoring that fixes design problems since the api matching tool can report false positive refactorings.
second to complement this automated validation approach we also manually inspected modification request descriptions and change logs in the version history to check whether programmers fixed or at least plan to fix these reported violations through redesign or refactoring activities.
for the rest of the reported violations we studied the corresponding source code to see whether they include any symptoms of poor design.
.
results we analyzed our results by answering the questions proposed at the beginning of the section.
.
.
q1.
accuracy of identi fied design violations table shows the total number of violations reported by clio v the total number of violations that match with automatically reconstructed refactorings v r the total number of remaining violations that were confirmed based on manual inspection v m the total number of confirmed violations cv which is v r v m and theprecision which is defined as the number of confirmed violations out of the number of reported violations cv v .clio reported violations that occur at least twice in a five release period in hadoop out of which were confirmed.
of them were automatically confirmed and were manually confirmed.
figure shows the precision for those violations that occur at least twice and the violations that occur at least three times.
with at least three occurrences we obtain a similar precision of but fewer reported violations.
for eclipse jdt clio reported violations of which were conservatively confirmed precision .
requiring violations to occur at least three times increased the precision to .
we only discuss the results of requiring at least two occurrences for the rest of the paper because the results of higher occurrence rates are its subsets.
by comparing the results of hadoop and eclipse jdt we first observe that eclipse is better modularized and more stable although eclipse jdt is about times larger than hadoop less than three times more refactorings were discovered from eclipse jdt tha n from hadoop showing that it has been less volatile.
this is consistent with the fact that only of all the eclipse mrs were detected to have violations in hadoop the number is out of the mrs showing that the changes to eclipse jdt matches its modular structure better.
because eclipse jdt is much larger and the violations found are much sparser it was much harder for us to determine if a violation indicates a problem hence leading to a lower precision.
figure precision hadoop in depth case study hadoop.
now we present an in depth study of hadoop to demonstrate examples of violations that are automatically confirmed violations manually confirmed violations false positives violations that are not confirmed and false negatives refactorings that are not identified as violations .
automatically confirmed violations in release .
.
clio identified a violation involving fsdirectory andfsnamesystem .fsnamesystem depends on fsdirectory.isvalidblock method but it often changes with fsnamesystem .
an api level refactoring was identified in release .
.
showing that the isvalidblock method was moved from fsdirectory tofsnamesystem .
upon further investigation we saw that in the subsequent release the method was made private .
in this case clio identified this violation releases prior to the actual refactoring.manually confirmed violations clio reported a violation in release .
.
involving tasktracker taskinprogress jobtracker jobinprogress and mapoutputfile that does not match with automatically reconstructed refactorings.
we searched hadoop s mrs and found an open request mapreduce entitled proposal for redesign refactoring of the jobtracker andtasktracker .
the mr states that these classes are hard to maintain brittle and merits some rework.
the mr also mentions that the poor design of these components have caused various defects.
false positive violations violations in this category cannot be confirmed either automatically or manually.
in most cases we cannot determine if there is a problem because we are not domain experts.
as an example in release .
.
clio reports a violation containing clientprotocol namenode fsnamesystem and datanode .clientprotocol contains a public field with the protocol version number and whenever the protocol changes this number needs to change.
since namenode datanode and fsnamesystem implement the protocol changes to them induce a change to clientprotocol .
although there may actually be a design problem we are not able to determine it for sure.
refactorings that are not violations some reconstructed refactorings are not matched to any violations identified by clio.
there are many micro refactorings that happen within a class and do not influence the macro structure of the system.
refactorings can also be performed for other purposes besides addressing modularity violations.
another reason is that some discrepancies only occur once soclio cannot tell if they are accidentally changed together or there is a problem but the developers may have realized and fixed it before it happens again.
for example in version .
.
the inode inner class of fsdirectory was refactored and extracted into a separate class and two of its sub types inodefile andinodedirectory were created so that the dfsfileinfo andblocksmap classes can be separated and use specific inode subtypes.
clio did not identify a violation between these classes because they were only involved in a single mr during the time frame we examined.
.
.
q2.
timing of violation detection in hadoop and eclipse jdt clio identifies a violation on average and releases respectively prior to the releases where the classes involved in the violation were actually refactored.
figure shows the distribution of the confirmed violations over hadoop releases.
each point in the plot represents a set of confirmed violations.
the horizontal axis shows the version that the violations were first identified by clio and the vertical axis shows the version that the violations were refactored or recognized by the developers.
points above in the vertical axis signify that the violations have been recognized by developers but not refactored yet.
most of the points in figure are above the line indicating that clio can identify design violations early in the development process so that the designers can be alarmed to avoid these problems accumulating into severe decay.
.
.
q3.
characteristics of identi fied violations we further analyzed the symptoms of design problems associated with the detected violations and categorized them into the following four types cyclic dependency code clone poor inheritance hierarchy and unnamed coupling.
the first three symptoms are both well defined and figure timing of violation detection hadoop table characteristics of the violations subjects cyclic clone inheritance coupling eclipse jdt hadoop can be detected using existing tools.
we call the fourth category unnamed because they are not easily detectable using existing techniques to the best of our knowledge.
table shows the number of confirmed violations under each category in hadoop and eclipse jdt.
the cyclic dependency code clone and unnamed coupling violations reported in the table are mutually exclusive from each other.
the symptoms of poor inheritance hierarchy often overlap with cyclic dependency or unnamed coupling.
next we provide examples from each category.
cyclic dependency.
both systems contain considerable number of cyclic dependencies.
for example in eclipse jdt we found that the javabuilder andabstractimagebuilder often change together and the code shows that javabuilder contains a subclass of abstractimagebuilder andabstractimagebuilder contains a javabuilder .
in a syntactical dsm there are no symmetric marks to alert the designer of this indirect cyclical dependency.
similarly we found that all of the following five files or their subsets often change together javaproject deltaprocessor javamodelmanager javamodel and javacore .
it turns out that these five classes form a strongly connected components if represented as a syntactic dependency graph.
code clone.
some modularity violations detected by clio involve code clones.
in hadoop version .
.
a detected violation involves the classes task maptask and reducetask .clio reported two violations one involving maptask and task and the other involving reducetask and task .
various methods and inner classes from reducetask and maptask were pulled up to the parent task class in versions .
.
.
.
and .
.
.
in eclipse jdt and hadoop there are and violations respectively that exhibit symptoms of code clones.
a traditional clone detector would likely identify more clones than clio but it may be too costly and unnecessary to refactor all of them.
clio highlights the ones that happen recently and frequently and hence provides more targeted candidates for refactoring.poor inheritance hierarchy.
the poor hierarchy violations we identified all have the symptoms that the subclasses causing the base class and or other subclasses to change for different reasons.
for example we identified in version .
.
of hadoop a violation involving the distributedfilesystem andfilesystem classes which was refactored in version .
.
several methods in distributedfilesystem were pulled up to its parent filesystem making them available to the other filesystem subtypes.
another reason is that the subclasses extensively use some methods in their parent class and a push down method refactoring should have been applied .
for example in hadoop version .
.
the gethints method was pushed down from theclientprotocol to its subclass dfsclient because it was the only user of this method.
they were detected as a violation in version .
.
.
in some cases the parent classes depend on the subclasses and form a cyclic dependency.
in hadoop version .
modification request describes changing the distributedfilesystem class but its parent class filesystem and another child of the filesystem localfilesystem are also part of its solution.
there are no syntactic dependencies between the two sibling classes.
by release .
clio reported that this modularity violation was observed more than three times already.
the code shows that the parent filesystem class contains methods to construct both of the two subclasses.
the parent class is thus very unstable because changes to a child require changes to itself and its other children.
our intuition that this is a problematic issue was confirmed when we looked forward through the revision history and found that by release .
the method to construct distributedfilesystem had been deprecated in filesystem in favor of a method in a external class.
as a similar example in eclipse scope is the parent of classscope and blockscope but it constructs both of it s children.
we categorized this types of violation as both poor inheritance and cyclic dependency.
unnamed coupling.
the files involved in violations of this category often change together but they either do not explicitly depend on each other and are not code clones or have asymmetric dependencies.
for example in hadoop datanodeinfo anddatanodereport were involved in a violation and was later refactored.
in the modification request comments the developer says that these classes seem to be similar and needed to be refactored.
the fsdirectory andfsnamesystem we mentioned earlier is also an example of unnamed coupling.
clio detected this violation because the only allowed change order is from the interface of fsdirectory tofsnamesystem .
but the revision history shows that changes to fsnamesystem often cause fsdirectory to change.
in the corresponding syntactical dsm these two classes reside in the same package andfsnamesystem depends on fsdirectory .
using a lattix dsm the user can mark that fsdirectory should not depend on fsnamesystem so that if fsdirectory explicitly refers to fsnamesystem lattix will raise an alarm.
however in reality fsdirectory never explicitly refers to fsnamesystem although it often changes with fsnamesystem .
table shows that in hadoop out of of the confirmed violations fall into this category in eclipse the number is out of .
we are not aware of existing techniques that detect these violations that do not fit to pre defined symptoms of poor design5.
discussion the quality of our modularity violation detection approach depends heavily on the availability of modifications requests and their solutions.
for small scale projects or projects without version control systems it is hard to apply clio.
when calculating change coupling how long a version history is enough?
the answer depends on the specific project and how to determine the best threshold is our ongoing work.
in the evaluation we used all available revision histories to determine change coupling.
changing the number of versions used for analysis may alter the results.
our decision of only considering the five most recent releases in evaluation when determining violations is based on the fact that the results do not signifiantly differ when we consider more versions.
again this heuristic may vary with different projects.
the selection of a starting change set can significantly affect the accuracy of violation detection.
we use the most highly coupled elements in a mr solution as the starting change set.
however other heuristics can be used for selecting a starting change set.
identifying such heuristics and seeing how they affect the accuracy of violation detection is an ongoing future work.
automatically recovering the original starting change set of an mr is an active but immature area of research e.g.
antoniol et al.
.
such techniques try to reconstruct what developers would have first modified in fulfilling the mr. as these techniques mature we can evaluate their effectiveness in improving our approach.
since we only applied clio to two subject systems we cannot conclude that the effectiveness of clio generalizes to all software systems however we did choose projects of different sizes and domains to begin addressing this issue.
in addition we cannot guarantee that the modification requests used in the evaluation are not biased.
as bird et al.
showed the mrs that have associated change sets may not be representative of all the mrs in the system.
for example although we claim to identify design violations for actively developed parts of a system the collected mrs may not include the most active parts of the system.
some violations detected using clio may not embody any design problems but reveal valid semantic dependency as shown in previous work .
but our experiments show that considerable number of violations indeed reflect design problems.
the accuracy of clio also depends on how accurate the acn model embodies design decisions and their assumption relations.
the acn model we used in this paper were automatically generated from uml class diagrams derived from code.
some dependencies can only be reflected in other design models such as an architectural description.
it is possible that these dependencies are missing from the acn model hence causing false positives.
the violation we discussed in the previous section that contains clientprotocol namenode fsnamesystem and datanode is such an example.
a future work is to improve clio by using highlevel architectural models in addition to reverse engineered source models.
.
conclusion parnas s original definition of a module means an independent task assignment and his information hiding principle advocates separating internal design decisions using an interface to allow for independent evolution of other modules.
problems occur if modules that are designed to be inde pendent always have to change together.
this paper proposes a novel approach of identifying eroding design structure by computing the discrepancies between how components should change together and how they actually change together.
we evaluated clio using the version histories of hadoop common and eclipse jdt.
we conservatively confirmed hundreds of reported violations to be correct.
the result also shows that detected modularity violations exhibit various symptoms of poor design showing clio s advantages in contrast to bad code smell detection techniques that find only pre defined set of poor design symptoms without regard to the system s original design structure nor its evolution history.
.