understanding understanding source code with functional magnetic resonance imaging janet siegmund christian k stner!
sven apel chris parnin anja bethmann thomas leich gunter saake and andr brechmann university of passau germany!carnegie mellon university usa georgia institute of technology usa leibniz inst.
for neurobiology magdeburg germany metop research institute magdeburg germany university of magdeburg germany abstract program comprehension is an important cognitive process that inherently eludes direct measurement.
thus researchers are struggling with providing suitable programming languages tools or coding conventions to support developers in their everyday work.
in this paper we explore whether functional magnetic resonance imaging fmri which is well established in cognitive neuroscience is feasible to soundly measure program comprehension.
in a controlled experiment we observed participants inside an fmri scanner while they were comprehending short source code snippets which we contrasted with locating syntax errors.
we found a clear distinct activation pattern of five brain regions which are related to working memory attention and language processing all processes that fit well to our understanding of program comprehension.
our results encourage us and hopefully other researchers to use fmri in future studies to measure program comprehension and in the long run answer questions such as can we predict whether someone will be an excellent programmer?
how effective are new languages and tools for program understanding?
how should we train programmers?
categories and subject descriptors h. .
user machine systems general terms experimentation human factors keywords functional magnetic resonance imaging program comprehension .
introduction as the world becomes increasingly dependent on the billions lines of code written by software developers little comfort can be taken in the fact that we still have no fundamental understanding of how programmers understand source code.
understanding program comprehension is not limited to theory building but can have real downstream effects in improving education training and the design and evaluation of tools and languages this author published previous work as janet feigenspan.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.
mirror screen head coil while .... that s a loop ... currvalue ... ... ... a prestudy b fmri measurement c activation pattern d cognitive proc.
e other fmri studies f interpretation for program comprehension figure workflow of our fmri study.
for programmers.
if direct measures of cognitive effort and difficulty could be obtained and correlated with programming activity then researchers could identify and quantify which types of activities segments of code or kinds of problem solving are troublesome or improved with the introduction of a new language or tool.
in studying programmers decades of psychological and observational experiments have relied on indirect techniques such as comparing task performance or having programmers articulate their thoughts in think aloud protocols.
each method when skillfully applied can yield important insights.
however these common techniques are not without problems.
in human studies of programming individual and task variance in performance often mask any significant effects hoping to be found when evaluating say a new tool.
think aloud protocols and surveys rely on selfreporting and require considerable manual transcription and analysis that garner valuable but indefinite and inconsistent insight.
in the past few decades psychologists and cognitive neuroscientists have collectively embraced methods that measure physiological correlates of cognition as a standard practice.
one such method is functional magnetic resonance imaging fmri a noninvasive means of measuring blood oxygenation levels that change as a result of localized brain activity.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
in this paper we report on results and experience from applying fmri in a program comprehension experiment.
while our experiment is a first step toward measuring program comprehension with fmri and as such inherently limited we believe it illuminates a path for future studies that systematically explore hypotheses and that will help to build stronger theories of program comprehension.
in our experiment participants performed two kinds of tasks inside an fmri scanner.
in the first kind referred to as comprehension tasks developers comprehended code snippets and identified the program s output.
in the second kind referred to as syntax tasks developers identified syntax errors in code snippets which is similar to the comprehension tasks but does not require actual understanding of the program.
as a result of our study we found evidence that distinct cognitive processes took place when performing the comprehension tasks activation of functional areas related to working memory attention and language comprehension and a left hemisphere lateralization.
our results provide direct evidence of the involvement of working memory and language processing in program comprehension and suggest that while learning programming training working memory necessary for many cognitive tasks and language skills which dijkstra already claimed as relevant for programming might also be essential for programming skills.
furthermore our results can help to validate or invalidate particular theories of program comprehension.
although a single study is not sufficient to answer general questions we can raise some further probing questions if program comprehension is linked to language comprehension does learning and understanding a programming language require the same struggles and challenges as learning another natural language?
if program comprehension only activates the left hemisphere often referred to as analytical can we derive better guidelines on how to train students?
taking a broader perspective our study demonstrates the feasibility of using fmri experiments in software engineering research.
although we believe this is only a first step our experience and experimental design is meant to be a template for other researchers to adopt and improve.
with decreasing costs of fmri studies we believe that such studies will become a standard tool also in softwareengineering research.
there are still many interesting unanswered questions that follow this line of research how do people use domain knowledge during comprehension?
to what extent is implementing source code a creative process?
can we train anybody to become an excellent programmer?
how should we design programming languages and tools for optimal developer support?
can software metrics predict the comprehensibility of source code?
in summary we make the following contributions we designed the first fmri study to observe brain activity during program comprehension tasks.
we share our design and experiences.
we conducted the study with participants and observed activation in five distinct brain regions.
this demonstrates the potential of fmri studies in software engineering research.
we interpret how the identified cognitive processes contribute to program comprehension and discuss future research directions.
this paper builds on our previous proposal in which we described our planning stage and conducted only preliminary studies with traditional controlled experiements .
in this paper we now report on the actual experiments inside an fmri scanner that we conducted subsequently.
.
fmri studies in a nutshell in this section we give a high level view of our study we describe the details in section .
rationale of fmri studies.
when studying cognitive processes in the brain scientists often follow a pattern of research that begins with a single case of brain injury that interferes with a cognitive behavior followed by further studies locating and isolating brain activity.
to identify a region of the brain scientists use instruments with high spatial precision such as fmri scanners.
after having established a general idea of where brain activity is occurring scientists further try identifying the timing and interaction of brain activity among brain regions.
for example scientists will try to measure the time to process a color or a word.
complex behaviors such as understanding a spoken sentence require interactions among multiple areas of the brain.
eventually to create a model of behavior scientists use techniques to dissociate activated brain areas to understand how a particular brain area contributes to a behavior.
for instance scientists found that the left medial extra striate cortex was associated with visual processing of words and pseudo words that obey english spelling but not activated by unfamiliar strings of letters or letter like forms .
to reference an identified brain location brodmann areas have proved useful as classification system.
there are brodmann area some are divided further each associated with cognitive processes such as seeing words or retrieving meaning from memory.
through extensive research in this field over the past twenty years there is a detailed and continuously growing map between brodmann areas and associated cognitive processes e.g.
shows an atlas .
due to its success we selected fmri to evaluate whether it is feasible to measure program comprehension.
given such map if we study a new task such as program comprehension we can identify which brain regions are activated and consequently hypothesize which cognitive processes are involved.
for example we found that one of the activated regions in our study is related to language recognition so we can hypothesize that language recognition is an integral part of program comprehension which was not certain a priori see section .
.
general challenges of fmri studies.
studies using fmri face general challenges due to the technologies involved which are very different from say controlled experiments in empirical software engineering.
fmri measures differences in blood oxygen levels in the brain.
if a brain region becomes active its oxygen need increases and the amount of oxygenated blood in that region increases while the amount of deoxygenated blood decreases known as the bold blood oxygenation level dependent effect.
oxygenated and deoxygenated blood have different magnetic properties which are measured by fmri scanners to identify active brain regions.
the bold effect needs a few seconds to manifest.
typically after about seconds it peaks after a task is finished the oxygen level returns to the baseline level after seconds.
often before returning to the baseline the oxygen level drops below the baseline .
thus the length of the experiment has to be planned carefully.
for optimal measurement of the bold effect task durations between and seconds have proved useful followed by a rest condition of about to seconds.
a longer task duration allows the bold signal to accumulate which produces better differences between tasks.
furthermore we need several measurements so an experiment consists of several similar tasks to average3791public static void main string args 2string word hello 3string result new string 5for int j word.length j j result result word.charat j 8system.out.println result figure source code for one comprehension task with expected output olleh .1public static void main string 2string word hello 3string result new string 5for int j word.length j j result result word.charat j 8system.out.println result figure source code for a syntax task with errors in line and .
the bold effect over all tasks.
this way we can make statistically sound conjectures about the bold effect.
to unambiguously determine the brain region in which the bold effect took place we need to avoid motion artifacts that is noise that occurs when participants move their head.
to this end participants are instructed to lie as motionless as possible during the measurement and their head is fixed with cushions.
furthermore communication and interaction with participants is limited because speaking or pressing buttons also causes motion artifacts.
in such a restricted setting the experiment duration should not exceed one hour because after that participants start getting restless.
additionally participants can see a relatively small screen reflected through a mirror illustrated in figure 1b which cannot reasonably show more than lines of text.
finally we need to distinguish brain activations caused by the experimental tasks from other activations.
in tasks that require participants to watch a screen or listen to a signal there will be activations caused by visual or audio processing.
to filter activations that are not specific for the experimental tasks we need to design control tasks that are as similar as possible to the experimental tasks and differ only in the absence of the targeted cognitive process.
requirements for our fmri study.
for a study on program comprehension the general fmri challenges translate into a specific set of requirements.
first due to the small mirror in the fmri scanner we can show only a limited amount of source code at a time.
technically it is possible to let participants scroll but that would cause motion artifacts and we wanted to avoid any bias as far as possible.
second we need source code fragments with a suitable difficulty.
if source code is too easy to understand participants may finish too early such that the bold activation returns to the baseline before the end of a trial.
on the other hand if source code is too difficult participants cannot finish understanding it.
in this case we cannot be sure that the cognitive process actually took place long enough to be measured.
the challenge is to find the right level of difficulty short code fragments that require to seconds to understand.
in a one hour experiment we can perform about a dozen repetitions for which we need comparable tasks.
finally to filter out irrelevant activation we need control tasks that ideally differ from the comprehension tasks only in the absence of comprehension nothing else.
in our context control tasks are different from typical control tasks in software engineering experiments where a baseline tool or language is used in fmri the similarity is defined at a low fine grained level such that we can observe the activation caused by comprehension only.
these constraints short code fragments of controlled difficulty and limited repetitions impair external validity as we discuss in section .
results of fmri studies can be generalized to realistic situations only with care.overview of our fmri study.
given the constraints we selected short algorithms that are taught in first year undergraduate computer science courses as comprehension tasks such as the string reversal code in figure .
we asked participants to determine the output of the program olleh in our example which they can accomplish only if they understand the source code.
the programs we used included sorting and searching in arrays string operations and simple integer arithmetic.
to account for different domain knowledge of participants we excluded its influence by obfuscating identifiers and enforcing program comprehension that required understanding code from the bottom up that is from syntax to semantics see sec .
.
as control tasks syntax tasks we introduced syntax errors such as quotation marks or parentheses that do not match and missing semicolons or identifiers into the same code fragments as for the comprehension tasks illustrated in figure .
then we asked participants to find syntax errors lines and .
comprehension and syntax tasks are similar yet sufficiently different both require the participants to look at almost identical pieces of text but for the syntax tasks participants do not need to understand the code.
to find suitable comprehension and syntax tasks we conducted pilot studies in a computer lab figure 1a .
we let a total of participants solve comprehension tasks and search for more than syntax errors.
for the syntax error tasks we asked participants whether they understood the source code to locate the errors which occurred only occasionally.
based on our observations we selected source code snippets and corresponding syntax errors with suitable duration and difficulty.
for the actual study figure 1b we conducted the experiment with participants inside an fmri scanner.
although initial fmri studies often do not yield conclusive results because of missing empirical evidence e.g.
related studies hypotheses about involved areas we measured a clear activation pattern figure 1c which is an encouraging result that we discuss in section .
.
study design having provided a high level overview we now present the technical details of our study.
additional material e.g.
all source code snippets is available at the project s website.1readers interested only in the big picture and the results may skip section .
.
objective to the best of our knowledge we performed the first fmri study to measure program comprehension.
since we are exploring our options we do not state specific research hypotheses about activated brain regions but instead pose a research question rq which brain regions are activated during program comprehension?
1tinyurl.com programcomprehensionandfmri 380to answer this question we need to take a look at the complexity of the comprehension process.
there are roughly two classes of comprehension models top down comprehension and bottom up comprehension see for an overview of program comprehension models .
top down comprehension means that when programmers are familiar with a program s domain they use their domain knowledge to understand source code.
during that process beacons e.g.
familiar identifier names help to form hypotheses about a program s purpose.
if developers cannot apply their domain knowledge they use bottom up comprehension so they understand source code statement by statement.
since differences in domain knowledge are hard to control we expect more noise in top down comprehension.
to avoid any possible additional activation we focus on bottom up comprehension.
.
experimental design all participants completed the experiment in the same order.
before the measurement we explained the procedure to each participant and they signed an informed consent form.
each session started with an anatomical measurement stage that lasted minutes.
this was necessary to map the observed activation to the correct brain regions.
next participants solved tasks inside the fmri scanner in the leibniz institute for neurobiology in magdeburg.
we had trials each consisting of a comprehension task and a syntax task separated by rest periods .
comprehension task .
rest .
syntax task .
rest the rest periods in which participants were instructed to do nothing was our baseline i.e.
the activation pattern when no specific cognitive processes take place .
to familiarize participants with the setting we started with a warming up trial a hello world example that was not analyzed.
instead of saying or entering the output of source code snippets participants indicated when they have determined the output in their mind or located all syntax errors by using the left of two keys of a response box with their right index finger.
directly after the scanning session participants saw the source code again on a laptop and entered their answer to ensure that comprehension took place.
with this procedure we minimized motion artifacts during the fmri measurement.
.
material initially we selected standard algorithms that are typically taught in first year undergraduate computer science education at german universities.
for example we had algorithms for sorting or searching in arrays string operations cf.
fig.
and simple integer arithmetic such as computing a power function see project s website for all initially selected source code snippets .
the selected algorithms were different enough to avoid learning effects from one algorithm to another but yet similar enough e.g.
regarding length difficulty to elicit similar activation which is necessary for averaging the bold effects over all tasks.
we created a main program for each algorithm printing the output for a sample input.
all algorithms are written in imperative java code inside a single main function without recursion and with light usage of standard api functions.
to minimize cognitive load caused by complex operations that are not inherent to program comprehension we used small inputs and simple arithmetic e.g.
to the power of .
to avoid influences due to domain knowledge and possible brain activation caused by memory retrieval we obfuscated identifier names such that participants needed bottomup comprehension to understand the source code.
for example infigure the variable result does not give a hint about its content i.e.
that it holds the reversed word but only about its purpose i.e.
that it contains the result .
we injected three syntax errors into every program to derive control tasks that are otherwise identical to the corresponding comprehension tasks as illustrated in figure .
the syntax errors we introduced can be located without understanding the execution of the program they merely require some kind of pattern matching.
in a first pilot study we determined whether the tasks have suitable difficulty and length.
in a lab session we asked participants to determine the output of the source code snippets and measured time and correctness.
undergraduate computer science students of the university of passau participated.
to simulate the situation in the fmri scanner participants were not allowed to make any notes during comprehension.
based on the response time of the participants we excluded six snippets with a too high mean response time seconds and one snippet with a too low response time seconds .
regarding correctness we found that on average of the participants correctly determined the output so none of the snippets had to be excluded based on difficulty.
in a second pilot study we evaluated the suitability of syntax tasks so that we can isolate the activation caused only by comprehension.
undergraduate students from the university of marburg and magdeburg as well as one professional java programmer located syntax errors.
we analyzed response time and correctness to select suitable syntax tasks.
all response times were within the necessary range and most participants found at least two syntax errors.
thus the syntax tasks had a suitable level of difficulty.
for the session in the fmri scanner we further excluded four tasks to keep the experiment time within hour.
we excluded one task with the shortest and one with the longest response time.
we also excluded two tasks that are similar to other tasks e.g.
adding vs. multiplying numbers .
we defined a fixed order for the sourcecode snippets.
whenever possible we let participants first comprehend a snippet then in a later trial locate syntax errors in the corresponding snippets with a large as possible distance between both.
this way we minimized learning effects.
furthermore we assessed the programming experience of participants with an empirically developed questionnaire to assure a homogeneous level of programming experience and we assessed the handedness of our participants with the edinburgh handedness inventory because the handedness correlates with the role of the brain hemispheres and thus is necessary to correctly analyze the activation patterns.
.
participants to recruit participants we used message boards of the university of magdeburg.
we recruited computer science and mathematics students two of them female all with an undergraduate level of programming experience and java experience see projects website for details comparable to our pilot study participants.
thus we can assume that our participants were able to understand the algorithms within the given time frame.
we selected students because they are rather homogeneous this way the influence of different backgrounds is minimized.
all participants had normal or corrected to normal vision.
one participant was left handed but showed the same lateralization as right handers as we determined by a standard lateralization test .
the participants gave written informed consent to the study which was approved by the ethics committee of the university of magdeburg.
as compensation the participants received euros.
the participants were aware that they could end the experiment at any time.
.
imaging methods the imaging methods are standard procedure of fmri studies.
source code presentation.
for source code presentation and participant response recording we used the presentation software running on a standard pc.
source code was back projected onto a screen that could be viewed via a mirror mounted on the head coil cf.
fig.
1b .
the distance between the participant s eyes and the screen was 59cm with a screen size of 260mm which is appropriate for an angle of .
the source code snippets were presented in the center of the screen with a font size of as defined in the presentation software.
the longest source code snippet had 18lines of code.
data acquisition.
we carried out the measurements on a tesla scanner siemens trio erlangen germany equipped with an eight channel head coil.
the 3d anatomical data set of the participant s brain 192slices of 1mm each was obtained before the fmri measurement.
additionally we acquired an inversionrecovery echo planar imaging ir epi scan with the identical geometry as in the fmri measurement to obtain a more precise alignment of the functional to the 3d anatomical data set.
for fmri we acquired functional volumes in minutes and seconds using an echo planar imaging epi sequence echo time te ms repetition time tr ms flip angel matrix size field of view 2cm 2cm 33slices of 3mm thickness with 45mm gaps .
during the scans participants wore earplugs for noise protection.
data preparation.
we analyzed the functional data with brainv oyagertmqx .
.
.
we started a standard sequence of preprocessing steps including 3d motion correction where each functional volume is coregistered to the first volume of the series linear trend removal and filtering with a high pass of three cycles per scan.
this way we reduced the influence of artifacts that are unavoidable in fmri studies e.g.
minimal movement of participants .
furthermore we transformed the anatomical data of each participant to a standard talairach brain .
this way we can average the bold effect over all participants see next paragraph .
analysis procedure.
we projected the functional data set to the ir epi images and co registered these with the 3d data set.
then we transformed the fmri data to talairach space and spatially smoothed them with a gaussian filter fwhm 4mm .
for the random effects glm analysis we defined one predictor for the comprehension tasks and one for the syntax tasks.
these were convolved with the two gamma hemodynamic response function using the default parameters implemented in brainv oyagertmqx.
we averaged the hemodynamic response for each condition comprehension syntax across the repetitions.
furthermore we normalized the bold response to the baseline that is defined by averaging the bold amplitude seconds before the onset of the comprehension and syntax condition respectively.
then we averaged the bold response over all participants.
next we contrasted comprehension with the rest condition using a significance level of p fdr corrected to determine the voxels that indeed showed a positive deflection of the bold response compared to the rest period a negative deflection does not show a real activation so only the positive deflections are of interest .
these voxels comprised a mask which was used in the subsequent contrast where we directly compared comprehension withsyntax tasks at a significance level of p fdr corrected and a minimum cluster size of 64mm3.
as the last step we determined the brodmann areas based on the talairach coordinates with the talairach daemon client version available online at .
the talairach space is used for the technical details of the analysis and the brodmann areas are used to map activated areas to cognitive processes.
.
results in figure we show the resulting activation pattern of the analysis including the time course of the bold responses for each cluster.
the activation picture and bold responses are averaged over all tasks per condition comprehension syntax and participants the gray area around the time courses shows the standard deviation based on the participants averaging.
we included the data of all participants since all showed comprehension of the source code snippets by one of three ways entering the correct output of the source code after the experiment correctly describing what the source code was or by ensuring that they attempted to comprehend the source code based on the questionnaire after the measurement see project s website for details .
in essence we found five relevant activation clusters all in the left hemisphere.
for each cluster we show talairach coordinates the size of the cluster related brodmann areas and relevant associated cognitive processes note that deciding which cognitive processes are relevant belongs to the interpretation not results see section .
thus we can answer our research question rq during program comprehension brodmann areas and are activated.
.
discussion having presented our results we now interpret the activation pattern.
as is standard in fmri studies we start with relating relevant cognitive processes and brodmann areas figure 1d .
next we look at tasks of other fmri studies in which similar brodmann areas have been identified and we relate our findings to previous findings figure 1e .
last we abstract from brodmann areas and hypothesize how the cognitive processes involved contribute to program comprehension.
we conclude with a discussion about what cognitive processes are relevant for program comprehension based on our and other findings of fmri studies figure 1f .
in our study we observed activation in five of the brodmann areas that are associated with cognitive processes cf.
section .
thus finding five activated clusters which are related to activities that fit well to our understanding of the comprehension process especially in an initial study is a promising result.
however individual brodmann areas are often associated with multiple cognitive processes.
thus as part of the interpretation we discussed among the author team which included a psychologist a neurobiologist a linguist as well as computer scientists and software engineers whether a process is relevant or irrelevant for program comprehension.
for example brodmann area is typically activated when humans give a spoken response.
however our setting did not include a spoken response so this process and according studies were not relevant for us.
still for completeness and replication we mention all associated activities.
note that since we look only at the difference of activation pattern between the comprehension and syntax tasks we consider only activation caused by comprehension.
for example we do not expect and did not find activations regarding the visual perception of source code or locating syntax errors i.e.
syntax error location382ba21 ba6 ba40 ba47 ba44 ba middle frontal gyrus talairach coord.
cluster size time in seconds bold signal in .
.
.
attention division of attention language silent word reading working memory verbal numeric problem solving ba middle temporal gyrus talairach coord.
cluster size time in seconds bold signal in .
.
.
semantic memory retrieval categorization ba inferior parietal lobule talairach coord.
cluster size time in seconds bold signal in .
.
.
working memory verbal numeric problem solving ba inferior frontal gyrus talairach coord.
cluster size time in seconds bold signal in .
.
.
working memory verbal numeric ba inferior frontal gyrus talairach coord.
cluster size time in seconds bold signal in .
.
.
language silent word reading working memory problem solving figure observed activation pattern for program comprehension and time courses of the bold response for each cluster.
the gray area around the time courses depicts the standard deviation based on the participants.
ba brodmann area.did not activate any areas that are not activated for program comprehension .
.
brodmann areas and similar cognitive processes are associated with brodmann areas ba and so we discuss them together.
in the context of our study the processes division of attention silent word reading working memory for verbal and or numerical material and problem solving are particularly relevant.2when discussing each relevant activity we also describe results of related neuro imaging studies and the relationship to program comprehension.
division of attention.
division of attention describes that attention has to be distributed among more than one cognitive activity.
other studies of divided attention also found both ba and ba activated.
for example vandenberghe and others let participants discriminate visually presented objects regarding two features orientation and location .
these activities are similar to what participants did in our study that is dealing at the same time with understanding statements of the source code and the numbers or words that the source code was manipulating.
in the syntax tasks participants were looking only for syntax errors and did not have to divide their attention to hold any values or words.
silent word reading.
in our study participants read words and in the comprehension task needed to understand their meaning e.g.
for denotes a loop .
other studies also found both areas activated when participants understood the meaning of sentences compared to deciding whether a sentence or word is grammatically correct .
this is in line with understanding the meaning of source code statements compared to analyzing syntactical correctness of statements in our syntax tasks.
verbal numerical working memory.
working memory is relevant for many cognitive tasks.
one part of working memory the phonological loop allows us to memorize spoken information such as telephone numbers as long as we repeat it either spoken aloud or silently .
numerous studies that let participants use verbal rehearsal found the same brodmann areas and activated.
for example smith and others let participants keep letters in mind awh and others additionally let participants compare target letters with letters that have been shown two letters earlier in a sequence of letters .
in our study participants had to keep the values of variables that the source code was manipulating in mind to understand the source code.
additionally when loops were part of the source code participants had to reason and maintain information about loop iterations whether mentally stepping through the loop or inductively determining its effect on output.
both activities were not necessary when identifying syntax errors.
thus the phonological loop fits well to our understanding of bottom up program comprehension.
problem solving.
problem solving is a broad term that is related to several similar tasks for example the wisconsin card sorting test or raven s progressive matrices .
both tests require participants to abstract from presented patterns and discover the 2other associated activities that do not appear relevant are a attention regarding orientation and stimulus response compatibility b space motion perception and imagery c spatial and objectrelated working memory d episodic memory encoding of objects and space e episodic memory retrieval of context information as well as retrieval effort and f skill learning of unpracticed non motor skills.383rules that construct the material.
this is similar to our comprehension tasks in which participants need to abstract from statements in source code and discover how and why these statements work together which is not necessary for locating syntax errors.
other fmri studies also found ba and for example when using the above mentioned wisconsin card sorting test or raven s progressive matrices .
overall ba and fit well into our understanding of program comprehension.
by consulting related studies we found related processes that capture the multiple facets of understanding source code.
the remaining three brodmann areas are often found in language based experiments so we discuss them together.
.
brodmann areas and in addition to other cognitive processes 3ba and are related to different facets of language processing.
numerous studies showed the involvement of all three brodmann areas in artificial as well as natural language processing .
in particular artificial language processing is interesting because artificial languages are based on formal grammars and limited sets of symbols such as words or graphemes from which letter or word sequences are created.
participants of typical artificial language studies should decide based on their intuition after a learning period whether sequences are grammatical or not resulting in activation in ba and .
artificial language processing and program comprehension are similar since both usually built on a limited set of elements and rules in the syntax tasks participants had to do some kind of pattern matching to locate the syntax errors.
based on the similarity of program comprehension to artificial language processing which is in turn similar to natural language processing we conjecture that one part of program comprehension involves language processing.
theposterior middle temporal gyrus mtg ba is closely associated with semantic processing at the word level.
both imaging and lesion studies suggest an intimate relation between the success or failure to access semantic information and the posterior mtg .
in our study participants also needed to identify the meaning of written words in the source code to successfully understand the source code and its output which was not necessary for the syntax tasks.
thus we found evidence that understanding the meaning of single words is a necessary part of program comprehension.
this may not sound too surprising but we actually observed it in a controlled setting.
the inferior frontal gyrus ifg ba and is related to combinatorial aspects in language processing for example processing of complex grammatical dependencies in sentences during syntactic processing .
several studies suggest that real time combinatorial operations in the ifg incorporate the current state of processing and incoming information into a new state of processing .
hence the ifg was proposed to be involved in the unification of individual semantic features into an overall representation at the multi word level .
this is closely related to bottomup program comprehension where participants combine words and statements to semantic chunks to understand what the source code 3again all areas are activated during different cognitive processes.
most likely irrelevant processes are a object perception b spoken word recognition c written word recognition with spoken response d object related working memory e episodic memory encoding of objects f episodic memory retrieval of nonverbal material regarding retrieval mode and effort g conceptual priming and h skill learning of unpracticed motor skills.is in the syntax tasks participants did not need to group anything to succeed.
in addition to the individual brodmann areas there is evidence for a direct interaction among the activated areas of our comprehension task.
two separate clusters were activated in the ifg one in ba and one in ba which is also suggested by other fmri studies.
ba was mainly associated with core syntactic processes such as syntactic structure building .
in contrast ba is assumed to serve as a semantic executive system that regulates and controls retrieval selection and evaluation of semantic information .
accordingly program comprehension requires the participants to build up the underlying syntactic structures to retrieve the meanings of the words and symbols and to compare and evaluate possible alternatives none of these processes is necessary to locate syntax errors.
moreover reciprocal connections via a strong fiber pathway between ba and the posterior mtg the inferior occipito frontal fasciculus have been claimed to support the interaction between these areas such that appropriate lexical semantic representation are selected sustained in short term memory throughout sentence processing and integrated into the overall context .
regarding program comprehension we conjecture that to combine words or symbols to statements and statements to semantic chunks the neural pathway between the mtg and ifg is involved.
.
implications for program comprehension having identified the clusters and related them to other fmri studies and specific activities of program comprehension we now combine all findings to a high level understanding of bottom up program comprehension.
working memory and divided attention.
first we found areas related to working memory especially the phonological loop of verbal numerical material and problem solving.
regarding the phonological loop we assume that participants needed to keep the value of numbers or words in mind while going through the source code statement by statement dividing their attention during this process.
furthermore we found a relationship to problem solving activities.
in our experiment we enforced bottom up comprehension by obfuscating identifier names which shows similarities to the wisconsin card sorting test and raven s progressive matrices .
in both tests as well as during bottom up comprehension participants need to understand underlying rules how cards are sorted how figures are created or how loops terminate and when how and where characters or numbers are modified.
furthermore participants need to apply these rules such that they can sort cards continue rows of figures or determine the correct output.
thus our findings align well with the common understanding of bottom up comprehension in which rules and relationships in source code have to be discovered and applied.
consequently to become excellent in bottom up comprehension we might need to train working memory capacity divided attention and problem solving ability.
language processing.
second we found a strong relation to language processing.
to understand source code participants had to process single words and symbols as well as statements that consist of single words located in the posterior mtg .
for example in figure line the participants needed to process result word and charat and combine all to understand what this statement does i.e.
adding a single character to the result .
addi 384public static void main string args string word hello string result new string for int j word.length j j result result word.charat j system.out.println result analyze words and symbolskeep values in mind integrate to state ments and chunksfigure visualization of how bottom up program comprehension might take place.
tionally participants had to integrate all statements into a semantic chunk that reverses a word.
via strong neural pathways both areas are connected which is necessary to integrate words symbols to statements and statements to semantic chunks.
hence our results support dijkstra s claim that an exceptionally good mastery of one s native tongue is the most vital asset of a competent programmer .
consequently focus on language learning in early childhood might facilitate learning programming.
toward a model of bottom up comprehension.
we can hypothesize what a cognitive model of bottom up program comprehension can look like participants analyze words symbols of source code combine symbols to statements then statements to semantic chunks.
simultaneously to comprehending and integrating words symbols and statements participants keep the values of words and numbers in their phonological loop to correctly understand the source code.
in figure we illustrate this process.
based on this model we can hypothesize what influences program comprehension.
for example if we increase the number of variables beyond the capacity of the phonological loop program comprehension should be impaired more discussion in section .
.
threats to v alidity the challenges and requirements of fmri studies give rise to several threats to validity.
first we performed several steps to interpret the data.
especially when deciding which cognitive processes for each brodmann area are relevant we might have missed important processes.
as a consequence our interpretation might have led to a different comprehension model.
to reduce this threat we discussed among the author team which combines expertise from psychology neurobiology linguistics as well as computer science and software engineering for each process whether it might be related to our comprehension tasks.
furthermore we mentioned all processes that are known to be associated with these brodmann areas footnotes and so that readers can make their own judgment about relevant processes.
second the source code snippets that we selected were comparatively short at most lines of code.
furthermore we focused on bottom up comprehension and we explicitly avoided scrolling or typing to reduce any noise as far as possible.
thus we focused on only one aspect of the complex comprehension process and cannot generalize our results to programming in the large clearly more studies have to follow.
nevertheless it is conceptually possible to use a more complex setting even tasks that last for several hours and our results encourage us to try such larger settings in future studies possibly also with other neuro imaging techniques e.g.
single photon emission computed tomography .
furthermore we cannot be entirely certain to what extent we ensured bottom up comprehension.
it is possible that participants recognized some algorithms as they were taken from typical introductory courses.
however since we obfuscated identifier names and the time per source code snippet was relatively short partici pants used bottom up comprehension most of the time this conjecture is supported by the fact that we did not observe activation in typical memory related areas.
another threat to external validity is that we kept the background of our participants such as their programming experience and culture constant to reduce any noise during measurement.
furthermore we did not control for gender of participants which might bias the results in that women show a tendency to prefer bottomup comprehension .
thus we can generalize our results only carefully.
in the next section we outline among others how such personal differences might affect program comprehension.
.
future directions with our study we showed that measuring program comprehension with an fmri scanner is feasible and can result in a plausible activation pattern.
but how does our study contribute to softwareengineering research education and practice?
having shown that measuring program comprehension with fmri is feasible we encourage other researchers to apply fmri in their research.
with careful planning and by consulting experts fmri can be a valuable tool also in software engineering research.
as the costs and inaccessibility of fmri studies will decrease over time we believe that they will become a standard tool in the software engineering researcher s toolbox.
we hope that other researchers can profit from our experience learn about requirements and pitfalls of such studies or even reuse experimental material so they do not have to start from scratch.
while our study provides only limited direct answers it raises many interesting and substantial questions for future research what are the underlying cognitive processes during top down comprehension or the implementation of source code?
how should we train programmers?
how should we design programming languages and tools?
can software metrics capture how difficult source code will be to comprehend?
top down comprehension.
in our experiment we focused on bottom up comprehension to minimize additional activation.
in future experiments we shall create more complex source code snippets in a familiar domain such that participants use top down comprehension and their memory to understand source code.
for example we can show the same source code snippets without obfuscating identifier names and observe to what extent they serve as beacons for participants.
additionally we shall select programs that participants are familiar with.
in such a setting we would expect activation of typical memory areas such as brodmann areas and in the inferior frontal gyrus or brodmann area in the anterior prefrontal cortex .
in conjunction with an eye tracker we shall evaluate whether participants fixate on beacons or familiar elements shorter or longer than unfamiliar statements and how that gazing is related to neural activity.
digging deeper we may ask at which experience level beginners start using their previous knowledge?
to what extent does the knowledge of the domain and other concepts such as design patterns influence activation patterns?
implementing source code.
what happens when people implement source code instead of only understanding it?
writing source code is a form of synthesizing new information compared to analytical program comprehension.
consequently we might observe activation of several right hemispheric regions such as right ba and for speech production.
it would be interesting to study whether and how writing source code is similar to and differ 385ent from speech production.
initial evidence suggests that developers had high levels of subvocal speech while editing code .
training.
there are many discussions about the best way to teach computer science and software engineering .
the close relationship to language processing raises the question of whether it is beneficial to learn a programming language at an early age or to learn multiple programming languages right from the beginning which is often a controversial issue in designing computer science curricula.
the involvement of working memory and attention may indicate that both should be trained during programming education.
so it is certainly worth exploring whether program comprehension can be improved by training specific cognitive abilities e.g.
through puzzle games .
however researchers disagree to what extent both can be learned or are rather inborn .
thus a test prior to programming education might reveal which students might struggle with learning programming.
especially when thinking of dyslexics who often have poorer short term memory and reading skills compared to non dyslexics we may expect they struggle however many dyslexics report that they can work focused during programming for example because of syntax highlighting .
thus unraveling the mind of dyslexics might give us interesting insights into program comprehension.
having found a strong involvement of language processing suggests that we need excellent language skills to become excellent programmers.
thus if we loved learning new languages we might also more easily learn new programming languages.
it may be worthwhile to start learning a new programming language early during childhood because studies showed that learning a second language early can have benefits regarding cognitive flexibility metalinguistic divergent thinking skills and creativity .
similarly training computational thinking a fundamental skill for computer scientists prior to learning programming might also give novices a better start with learning programming for example to correctly specify unexpected states in a program .
furthermore despite similar education or experience researchers have observed a significant gap between top developers and average developers typically reported as a factor of in terms of productivity .
however nobody knows exactly how these top developers became top developers they just areexcellent.
this raises many questions about to what extent we can train programmers at all.
alternatively we can ask whether it is possible to predict whether somebody is inclined to become a great programmer.
to answer such questions we need to know how an excellent programmer differs from a normal programmer.
interestingly characteristics of experts have been studied in many fields.
for example in an fmri study musicians showed a much lower activation in motor areas when executing hand tapping than nonmusicians and expert golfers compared to novices showed a considerably smaller activation pattern when imagining hitting a golf ball because they have somewhat abstracted the activity .
in the same rein excellent programmers may approach program comprehension differently.
again understanding the differences may offer us insights into how to teach beginners and in the long run develop guidelines for teaching programming.
programming language design.
traditionally programming language design does only marginally involve programmers and how they work with source code.
instead experience and plausibility are used such as as the world consists of objects object oriented programming is an intuitive way to program as recursion is counter intuitive recursive algorithms are difficult tounderstand or java shall be similar to c c such that many developers can easily learn it.
while experience and common sense are certainly valuable and may hint some direction on how to design programming languages many design decisions that arise from them have to the best of our knowledge only rarely been tested empirically e.g.
.
in our experiment we have explored only small imperative code fragments with only few language constructs.
it would be interesting to investigate whether there are fundamentally different activations when using more complex language constructs or using a functional or object oriented style.
for example when we let developers understand object oriented source code we should observe activation in typical object processing areas e.g.
ba or if real world objects and object oriented programming are similar which is a frequently stated claim.
the design of individual programming languages as well as entire programming paradigms may greatly benefit from insights about program comprehension gained by fmri.
furthermore having identified a close similarity to language processing we can further investigate how different or similar both processes are.
to this end we envision letting participants read and comprehend natural language descriptions as control tasks instead of finding syntax errors computing the difference in activation pattern we will see how reading comprehension and program comprehension differ if they differ at all .
we also envision studies to explore the impact of natural programming languages on comprehension and how comprehension of natural languages dead languages e.g.
latin and programming languages differ.
additionally some researchers believe that the mother tongue influences how native speakers perceive the world sapir whorf hypothesis .
since programming languages are typically based on english western cultures compared to asian cultures might have a headstart when learning programming .
taking a closer look at how developers from both cultures understand source code might give us valuable insights for teaching programming.
software and tool design.
many questions regarding software design modularity and development tools arise in software engineering.
for instance the typical approach to hierarchically decompose a software system is challenged by the presence of crosscutting concerns but the extent to which developers naturally decompose a software system is unknown.
ostermann and others argued that traditional notions of modularity assume a model based on classical logic that differs from how humans process information e.g.
humans use inductive reasoning closed world reasoning and default reasoning which are all unsound in classical logic .
thus we may need more natural concepts of modularity.
there has been considerable research in tool based solutions for organizing and navigating software .
considering navigation support understanding how to support cognitive processes related to spatial abilities and to determine whether a given tool actually does support those abilities might improve comprehension provide a more disciplined framework for designing tools and influence how we design software.
software metrics.
many attempts have been made to measure the complexity of source code.
following initial proposals such as mccabe s cyclomatic complexity and halstead s difficulty a plethora of code and software metrics has been proposed .
despite some success stories it is still largely unclear why a certain metric works in a certain context and how to design a comprehensive and feasible set of metrics to assist software engineering.
which properties should a metric address?
syntactic386properties control flow data flow semantic dependencies and so forth?
fmri may give us a tool to answer these questions for example by analyzing whether complex data flows e.g.
as targeted by the depdegree metric give rise to distinct or stronger activations that correspond with complex comprehension activities.
.
related work we are not aware of any fmri studies examining program comprehension.
a few studies have used other physiological measures to study program comprehension such as eye tracking or electromyography to measure the effort during programcomprehension tasks.
in the neuroscience domain several studies exist that also study tasks related to comprehension and detection of syntax errors.
however these studies several of which were discussed in section use tasks involving only english words and sentences not programs.
the following studies are particularly interesting because they revealed the same brodmann areas as our study in studies related to reading comprehension and language processing participants had to understand text passages or decide whether sequences of letters can be produced with rules of a formal grammar .
regarding working memory participants had to identify and apply rules or memorize verbal numerical material .
in divided attention tasks participants had to detect two features of objects at the same time .
further work is needed to distinguish and dissociate brain activity related to program comprehension from other similar activities such as word comprehension and to allow us to develop a full model of program comprehension.
some researchers have already begun to theorize what a brain based model of program comprehension would look like.
hansen and others propose to use the cognitive framework act r to model program comprehension .
parnin compiled a literature review of cognitive neuroscience and proposed a model for understanding different memory types and brain areas exercised by different types of programming tasks .
both approaches are similar to our work by exploring knowledge of the neuroscience domain.
.
conclusion to shed light on the process of program comprehension we used a relatively new technique functional magnetic resonance imaging fmri .
while in cognitive neuroscience it has been used for more than years now we explored how fmri can be applied to measure the complex cognitive process of comprehending source code.
to this end we selected twelve source code snippets that participants should comprehend which we contrasted with locating syntax errors.
the key results are a clear activation pattern of five different brain regions which are associated with working memory ba ba attention ba and language processing ba ba ba all fit well to our understanding of bottom up program comprehension.
language processing seems to be essential for program comprehension which dijkstra already noted.
with our study we found first empirical evidence that dijstra was right which may have implications for teaching such that training language skills in addition to working memory and problem solving might make programming education more efficient.
as a further contribution we shared our experiences and design to lower the barrier for further fmri studies.
we hope that fmribecomes a standard research tool in empirical software engineering so that we and other researchers can understand how developers understand source code and refine existing models of program comprehension to a unified theory so that we can eventually tackle the really interesting questions how do people use domain knowledge?
to what extent is implementing source code a creative process?
can we train someone to become an excellent programmer?
how should we design programming languages and tools for optimal developer support?
can software metrics predict the comprehensibility of source code?
.