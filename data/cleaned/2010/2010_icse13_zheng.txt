path sensitive static analysis of web applications for remote code execution vulnerability detection yunhui zheng xiangyu zhang department of computer science purdue university abstract remote code execution rce attacks are one of the most prominent security threats for web applications.
i t is a special kind of cross site scripting xss attack that al lows client inputs to be stored and executed as server side script s. rce attacks often require coordination of multiple request s and manipulation of string and non string inputs from the clien t side to nullify the access control protocol and induce unusual ex ecution paths on the server side.
we propose a path and contextsensitive interprocedural analysis to detect rce vulnerab ilities.
the analysis features a novel way of reasoning both the strin g and non string behavior of a web application in a path sensit ive fashion.
it thoroughly handles the practical challenges en tailed by modeling rce attacks.
we develop a prototype system and evaluate it on ten real world php applications.
we have iden tified true rce vulnerabilities with unreported before.
i. i ntroduction the internet has been an important social and business platform for many daily activities which are usually performed through web applications apps .
once a web app is put online it can be accessed and used by anyone around the world.
a large volume of valuable and sensitive user data are process ed and stored by web apps making them attractive targets of security attacks.
according to a risk report from ibm in the past a few years security attacks to web apps have become the dominant kind of attacks i.e.
of all the attacks reported in .
among the web app attacks remote code execution rce is one of the most harmful threats .
it takes advantage of defects of a web app to inject and execute malicious serverside script in the context of the targeted app.
consequently the attacker could gain accesses to resources authorized to the app e.g.
user data in a database .
according to a report from theopen web application security project owasp php rce is the most widespread php security issue since july and thus has been ranked the number one threat on the web apps security problem list .
we have also observed popular apps suffering from rce defects.
one of them has been downloaded for over six million times.
essentially rce is a special kind of cross site scripting xss attacks.
the root cause is the same as the typical xss and sql injection attacks which is that invalid clientside inputs are undesirably converted to scripts and execut ed.
however rce attacks are usually much more sophisticated.
a successful rce attack may require coordinations between multiple requests to more than one server side scripts.
ther e may also be requirements on the session of these requests.
in other words the attacks are stateful crossing multiple ro undsof communication between a server and a client.
furthermore it demands manipulating both the string and non string part s of the client side inputs.
in some cases the inputs have to be so crafted that they are not even legitimate inputs allowed b y the client side interface.
there have been a lot of works on detecting sql injection xss and http request tampering attacks.
however due to the unique characteristics of rce attacks they fall shor t in detecting and confirming these attacks.
dynamic tainting based techniques can monitor information flow inside web app execution to determine if any client side inputs can flow to critical places.
they can be use d to detect runtime instances of rce attacks but cannot expos e vulnerabilities before real attacks are launched.
while static analysis has the potential of exposing vulnerabilities most of them cannot cohesively reason about the string and non string pa rts of an application and many lack path sensitivity whereas rce attacks require satisfying intriguing path conditions involving both strings and non strings.
recently researc hers have proposed techniques that can model both strings and non strings in dynamic symbolic execution of web apps .
however they focus on modeling only the executed path whereas vulnerability detection requires modeling a ll program paths.
a more thorough discussion of the limitation s of existing techniques can be found in section iii.
in this paper we propose a path and context sensitive inte rprocedural static analysis that detects rce vulnerabiliti es in php scripts.
it features the capabilities of reasoning both the string and non string parts of an application in a cohesive a nd efficient manner and reasoning across multiple scripts and requests.
it is able to guide exploit generation i.e.
gener ating requests with concrete inputs to confirm the reported vulnerabilities.
it analyzes and encodes php scripts as two kinds of constraints non string and string constraints.
a novel algorithm is developed to solve these constraints in an iter ative and alternative fashion.
real exploits can be composed from the satisfying solutions.
the contributions of the paper are summarized as follows.
we develop a static analysis to automatically detect rce vulnerabilities in php code.
the analysis is interprocedural context and path sensitive leveraging a string solver and a smt solver.
we propose to abstract a web app into two separate subprograms one capturing the non string semantics andsession name phpmyadmin ... if get file put contents .
config config.inc.php getconfigfile setup config.php public static function getconfigfile c getconfig foreach c as id server ret .
... .
id .... return ret setup lib configgenerator.class.php public function getconfig c session return c setup lib configgenerator.class.php if get parse str parses the argument into var assignment s .
parse str server index.php execute the php script injected send a exploit steps b code snippets relevant to step c code snippets relevant to ste p session poisoning set code urlencode arbitrary php script send rs session to unset script injection save the poisoned session in a php file send session name phpmyadmin require swekey.auth.lib.php swekey.auth.lib.php fig.
rce in phpmyadmin v3.
.
simplified the other modeling the string related behavior.
the two sub programs are encoded separately.
we also develop a novel algorithm that solves the two sets of constraints simultaneously.
we address a number of practical challenges including analyzing across scripts and requests to simulate stateful attacks handling dynamic conditional script inclusion and modeling session constraints.
we have evaluated the technique on real world web applications.
we successfully identify rce vulnerabilities with that have not been reported in the past.
we have confirmed all these vulnerabilities by constructing real exploits based on the analysis results.
the overhead of our technique is reasonable.
ii.
m otivating example we use two examples to motivate our approach.
a. rce in phpmyadmin recently a rce vulnerability was reported for phpmyadmin v3.
.
which is a mysql database management tool using a web interface.
the vulnerable versions have been downloaded over six million times according to sourceforge .
fig.
a describes an exploit to the vulnerability which consists of three steps.
the first two are session poisoning and script injection .
in the first step a crafted request is sent to index.php to change the configuration of the server.
instructed by the command session tounset a key value pair is stored to a special session array session that is supposed to store the list of servers under administration.
the key value pair co ntains a piece of php script code as the key which gets stored to the current session.
in the second step another request is sent to config.php to save the current configuration including the information stored in the session array session by the previous step.
1cve 2506consequently the provided code piece is stored to a php file which gets executed by the request in the third step.
the relevant code snippets are shown in fig.
b c .
fig.
b shows the relevant snippets in index.php and swekey.auth.lib.php that are executed in the session poisoning step.
index.php first specifies the current session name.
then it executes the included script swekey.auth.lib.php .
depending on the value of the incoming parameter session tounset method parse str is called at line parsing its argument to variable assignments.
for example parse str a b has the same effect as that of executing a b .
the variable server stores the query string from the client.
hence the invocation at line defines session to .
as php treats arrays as hash mappings indexed by keys the key value code is stored to the session array.
fig.
c shows the relevant snippets in config.php that are executed in the script injection step.
at line there i s a write to a php file guarded by a predicate at line .
in the file write the string returned by getconfigfile is written.
at line41inside getconfigfile c is aliased to session .
then in the foreach loop the previously stored key value code is assigned to idand defined as part of the return value ret.
in this way the string code composed by the client in the previous request is written to a php script.
a hidden complexity is that the session of the requests have to be identical.
in handling client side requests if not exp licitly specified a default session name phpsession is assigned.
therefore in the session poisoning step one cannot direct ly send the request to swekey.auth.lib.php even though the request can be correctly parsed and the arguments can be stored into the default session.
because the default sess ion is different from the session specified in the second step.
we have to call index.php instead to ensure we are referring to the same named session phpmyadmin as inconfig.php in the second step.
accessing directly is allowed in common.php require once common.php cmd request switch cmd case debug ...... default script cmd cmd .
.php ...... include script cmd cmd.php a exploit direct scripts array cmd.php ... server is the script client req uesting script running server foreach direct scripts as script if preg match script script running scriptok true ...... if script requested is not in app deny if !
scriptok die common.php this page not directly accessible require once common.php if request masort ... request ...... function masort data sortby foreach split sortby as key code .
... key ... turn the string held by code into a dynamic fu nction cache create function ... code uasort ... cache query engine.php set code urlencode arbitrary php script send ngine search orderby code b relevant code snippets call edge file inclusion fig.
rce in phpldapadmin v1.
.
.
simplified from the example we make a number of observations.
first determining if a vulnerability is a true positive dem ands reasoning both string and non string parts.
observe that th e path conditions at line in config.php and line in swekey.auth.lib.php entail non string reasoning while the file name and the file content at line in config.php require string reasoning.
second we have to reason across requests and scripts and handle sessions properly.
neithe r index.php norconfig.php is vulnerable by itself.
third in order to successfully construct an exploit to confirm the v ulnerability we need to know the concrete inputs to satisfy th e path conditions.
for instance the parameter session tounset in the step request in fig.
a is to satisfy the condition at line .
the parameter in the step request is to satisf y the condition at line .
in other words the analysis ought t o be path sensitive.
b. rce in phpldapadmin another type of rce vulnerabilities is related to eval that executes a string provided as its parameter.
there is a vulnerability2inphpldapadmin v1.
.
.
rated critical by the developer.
phpldapadmin provides user friendly web interfaces to manage a ldap server.
it is a popular tool and has been installed for more than 242thousand times.
as shown in fig.
a the vulnerability is exploited by a request tocmd.php which is supposed to accept and execute a command from the client.
in the exploit an invalid command is provided such that a php script named by the command i.e.
query engine.php gets executed.
the script is supposed to be internal and cannot be requested directly.
it can accep t the rest of the parameters in the exploit request and execute the malicious script provided by variable code .
the relevant code snippets are shown in fig.
b .
the scriptcmd.php first gets executed.
it includes common.php for access control which is a common design pattern for php programs.
the access control is conducted by comparing the current script acquired from server at line with a white list specified in array direct scripts .
observe that at line in common.php cmd.php is listed and the execution is allowed to proceed.
lines in cmd.php determine the command indicated by the client request.
if it 2cve 4075is not a pre defined command such as debug the code constructs a php file name with the command argument line and tries to load and execute the file at line .
in this case the script query engine.php is executed.
inside query engine.php common.php is again included and executed for access control.
since query engine.php is included by cmd.php it inherits all its privileges.
hence despite the script itself is not in the while list the execu tion is allowed to continue.
at line in query engine.php if the client parameter search is set the masort function is called to execute a sorting function constructed dynamical ly by lines .
the construction allows the string provid ed in the client parameter orderby to be included as part of the constructed function and executed at line .
note tha t variable sortby is an alias to orderby and uasort at line is equivalent to eval .
note that the root cause of the defect is not just the masort function because executing a dynamically constructed func tion is the intended semantics of masort .
it is the combination of the mistake in access control i.e.
allowing the client to indirectly invoke query engine.php and the masort function that constitutes the vulnerability.
hence our te chnique ought to be able to analyze access control mechanism which is essentially through predicates.
for this example the request is so crafted i.e.
the cmd parameter has to be query engine not even a legitimate command to get through the access control.
it is unlikely that an analysis incapabl e of modeling path conditions would identify the exploit.
the example also illustrates the necessity of handling dynamic file inclusion line .
we have to model the fact that the name of the file to be included is a variable in the program.
based on the value of the variable different files need to be modeled and encoded as part of the constraints.
iii.
p roblems in existing static analysis existing static techniques fall short in rce vulnerability detection and exploit generation.
string analysis is needed.
web apps are different from regular programs in that they heavily rely on string operati ons.
inputs from the client side are mostly strings.
the outputs o f web apps are mainly strings as well such as sql queries html pages and javascript code pieces.
in some sense the main functionality of a web app is often string processing.
howev er php script non string abstraction string abstraction if post role visitor log v else if post role user log post else role admin log a if role admin writefile f.php log b1 post a if b t r t l else b post a if b2 t r t l else t r t l if b assert1 tl if b1 role visitor log v else if b2 role user log post msg else role admin log a b compare role admin if b3 assert2 f.php in .php fig.
constraint generation example cfg log1 v cfg role1 visitor line cfg log2 post msg cfg role2 user line cfg log3 a cfg role3 admin line cfg log4 log2 log3 cfg role4 role2 role line cfg log5 log1 log4 cfg role5 role1 role line assert f.php in .php assertions not in hampi format assert log5 post msg simplified for reading fig.
path insensitive encoding a lot of existing static analysis for regular programs do not focus on properly modeling strings.
string analysis alone is not sufficient.
on the other hand string analysis alone is not sufficient as most web apps still have substantial non string operations which a re for execution path control access control and arithmetic com putation.
the string and non string operations cohesively de pend on each other.
most existing string analysis are based on context free grammar cfg and only model string operations abstracting away the non string part of a web app.
this could lead to false positives.
moreover since they do not reason about path conditions users can hardly use them to construc t exploits because that requires knowing the inputs satisfyi ng various path conditions.
hampi.
hampi is a string analysis engine developed in the past.
a lot of recent web app analysis are built upon it .
it models a string assignment as a grammar rule definition.
assignments to the same variable in the two branches of a conditional statement become alternatives in the right han d side of a rule.
take the script in the left column of fig.
3as an example.
it determines the role of the client according to the value of post defines the content in log and finally writes to a php file if the role is admin .
to detect if the file write is vulnerable to rce attacks at line we assert that the file written is a php file and the content written to the file is from post provided by the client.
the first assertion is trivially true.
however path sensitive and path insensi tive analysis yield different answers to the second one.
in standard string analysis such as hampi the cfg generated for the program is shown in fig.
4and the second assertion is satisfiable with the cfg.
therefore a vulnerab ility is reported.
however it is a false positive.
consider the predicate at line the reachability condition of line 16requires role admin which implies log a .
this can only be prevented by a path sensitive analysis modeling bot h string and non string behavior.
solving string and non string constraints together is difficult.
while we need to reason about string and nonstring behavior together existing solutions are not adequ ate.
one class of solutions models strings as bit vectors which c an be handled by existing smt solvers to achieve solving string and non string constraints together.
however a precondit ion in bit vector logic is that the lengths of bit vectors are fix ed and decidable.
however this does not hold for strings.
for example str post msg is a cfg rule.
the length ofstrvaries depending on the alternatives.
in one of the alternatives it is determined by the client side input whi ch is uncertain.
this causes difficulty in reasoning about constr aints built on top of str.
most existing techniques in this category are developed in the context of dynamic symbolic execution .
since they only need to model the executed path string lengths or strong hints of string lengths can be acquired fro m the execution.
these techniques can hardly be applied in our context as we need to model all possible paths.
another plausible solution is to translate both string and non stri ng constraints to a third party constraint language and solve them together.
however third party languages are often lim ited in expressiveness.
for example in the m2l constraint language used can only model a very small set of arithmetic operations namely addition and subtraction and it does no t allow more than one variables in an expression.
incapabilities in modeling rce specific characteristics.
as we can observe from the two cases in the previous section rce attacks have specific characteristics that need to be properly handled.
for example multiple requests to more than one scripts need to be analyzed together dynamic file inclusion needs to be modeled.
as far as we know none of the existing techniques can meet the challenges.
iv.
d esign given a web app we first identify the operations sensitive to rce attacks called sinks .
we consider two kinds of sinks file writes and dynamic script evaluations e.g.
eval .
for a file write if we can determine along some feasible path it writes to a.php file and the content contains values from the client it is considered problematic.
for a dynamic script evaluation if the string evaluated as a script contains values from the cli ent along some feasible path it is considered problematic.
our technique is an inter procedural context sensitive a nd path sensitive static analysis.
it reasons about both stri ng and non string behavior.
to begin with the technique creat es two abstractions of the given app one for the string related behavior and the other for the non string related behavior.
the non string abstraction includes additional taint sema ntics to reason about the input correlation for each variable.
the two abstractions are encoded separately.
then we solve them together via a novel and sound iterative and alternative algorithm.
for a potentially vulnerable file write we query the string constraints if the file name ends with the php extensio nand query the non string constraints to determine if the wri tten content is tainted and the file write is reachable.
the soluti on has to consistently satisfy all these queries.
a. abstractions for each php script we create two abstractions string and non string abstractions.
intuitively one can consider th ey are simplifications of the original program that handle only str ing type and non string types respectively.
to facilitate abs traction we have implemented a number of auxiliary analysis.
one is type inference as php programs are dynamically typed.
it leverage the known interface of string operations .
for example if a statement is a string concatenation the varia ble holding the return value as well as the arguments are of strin g type.
transitively other correlated variables can be type d. the second is a standard context sensitive alias analysis.
the third one is a field name analysis that identifies all the field names or constant indices for an array.
we assume a program is normalized such that the predicate in a conditional stateme nt is a singleton boolean variable.
table i string abstraction rules.
operator represents definition and .
concatenation.
variables s1 s2 s3 are of st ring type a a1 and a2 are of array type and b is of boolean type.
f1 ... an d fn are constant field names of a a1 and a2 identified through the field name analysis.
statements abstraction s1 s2 s1 s2 s1 concat s2 s3 s1 s2.s3 s1 s2 s1c s2 s1 s2 s1 s2 c a1 a2 a1f1 a2 f1 ... a1fn a2 fn b s1 s2 b compare s1 s2 if b ... else ... if b ... else ... foreach aas s1 s2 s1 f1 s2 a f1 loop body loop body ... s1 fn s2 a fn loop body string abstraction.
the abstraction retains the control flow structure statements of string type and string compariso ns in the original program.
other statements are abstracted away .
it thus models the string related behavior in the program.
the detailed abstraction rules are presented in table i. string copies and concatenations rules and are straightf orward.
for an array access indexed by a constant field name such as a we create a new variable acto denote the field rules and .
currently we have limited support for dynamically constructed field names indices we use fre e variables to denote such accesses.
for an array copy rule we generate the definitions for the fields identified by the fiel d name analysis.
for a string comparison rule we retain the same boolean result variable and make use of the compare primitive that compares two strings.
we will explain in late r sections how this will be turned into string constraints and solved by hampi.
rule means that we retain the structure of a conditional statement.
for a regular loop we unroll the loop body once and turn it into a conditional statement.
this is a standard solution to handling loops in constraint based analysis .
a foreach loop involving strings foreach a as s1 s2 means that a is a mapping and the loop iteratesover each entry of the mapping and instantiates s1 with a key and s2 the corresponding value.
we unroll the loop n times for the n fields we have identified for the array rule .
in each iteration the field name is associated with s1 and the field value is associated with s2.
note that the string abstraction is incomplete due to the dynamic nature of the language.
for example it is difficult to reason about string values in field accesses through dynamically constructed field names indices.
fortunately f rom our experience most field accesses have constant names.
for example in phpldapadmin out of field accesses have constant names.
in our experiments this has not led to any false positives.
the third column in fig.
3shows the string abstraction for the program in the first column.
it is essentially a simplified version of the original program with the integer comparison s excluded and some unbounded boolean variables used.
table ii non string abstraction rules.
variables x y z are of non string type a is of array type s1 s2 and s3 are of string type and b is of boolean type.
operator denotes a binary operation.
txrepresents the boolean taint bit of x. f1 ... and fn are constant indic es identified through the field name analysis.
statements abstraction x y x y tx ty x y z x y z tx ty tz x a x a c tx ta tac if b ... else ... if b ... else ... foreach aas x y x f1 y a f1 tx ta loop body ty ta taf1 loop body ... x fn y a fn tx ta ty ta tafn loop body s1 s2 ts1 ts2 s1 concat s2 s3 ts1 ts2 ts3 foreach aas s1 s2 tx ta ty ta taf1 loop body loop body ... tx ta ty ta tafn ... non string abstraction.
the non string abstraction retains the same control flow structure as the original program and all the statements of a non string type.
it also introduces t aint semantics into the abstracted program.
the taint semantics is standard that is a resulting variable is tainted if any o f the operands are tainted.
this is to model the correlations t o client inputs.
hence variables and statements of string ty pe are not completely abstracted away.
instead a boolean vari able is introduced to represent the taint of a string variable.
st ring operations are abstracted to corresponding taint operatio ns.
table.
iipresents the rules.
rules and are standard.
in rule the result variable x is tainted if either the a rray a is tainted or the specific field is tainted.
intuitively it means if the entire array comes from the client an array field comes from the client.
this allows us to model the taint propagatio n semantics of array accesses with dynamically constructed fi eld names indices.
for instance in the sample code in fig.
.
statically we don t know what variables are written by line without knowing the concrete request.
however it is straightforward to assume that the session array is tainted.
according to rule cis tainted at line which leads to idbeing tainted at line disclosing that idcould comefrom the client.
rule abstracts foreach loops with nonstring operands.
similar to that in string abstraction it u nrolls the loop n times for the n constant fields identified through th e field name analysis.
observe that the taint propagation of y is similar to rule .
rules are for string operati ons which are abstracted to taint operations.
there are some operations that have string operands but non string results such as getting the index of a string in a nother string our implementation currently uses free varia bles to denote the results of such operations.
the second column in fig.
3shows the non string abstraction of the sample program.
observe that the two abstraction s use the same set of predicate variables which allows us to reason about the two parts together.
b. constraint encoding and solving with the two abstractions the next step is to encode them separately and then solve them together.
we develop a novel algorithm to drive the solution process.
the algorith m queries the stp solver and the hampi string solver iterative ly and alternatively to derive a consistent path sensitive so lution for both sets of constraints.
intuitively one can consider the algorithm first solves the non string constraints and pr oduces a solution for the path conditions the solution is the n used to derive the hampi encoding for that path from the string abstraction.
so the imprecision caused by pat hinsensitivity can be avoided.
if hampi fails to resolve the constraints for the path it means that the solution is infea sible.
the algorithm alternates to the stp solver to explore a new solution.
in the algorithm we leverage the observation tha t string constraints are strong in pruning search space.
in ma ny cases a not fully path sensitive string encoding may not have any solutions so that we can completely avoid exploring the individual paths in that sub space.
the encoding of the non string part is standard i.e.
first translates the program to its ssa form and models individual statements to bit vector operations and hence omitted.
encoding and solving string constraints.
before encoding the abstracted program is translated to its ssa form in which a unique variable name is assigned to each definition and operators are used at joint points to multiplex the differen t values along different branches.
the encoding is driven by the assignment for the boolean variables in the abstraction .
the process is detailed in algorithm .
function genstrcstr generates hampi constraints i.e.
a cfg for a statement in the ssa form.
it is a recursive function driven by the abstract syntax tree ast of the statement.
in particular for an assignment statement lin es a hampi cfg definition denoted by keyword cfg is inserted to the cfg.
for a conditional statement lines depending on the value assignment of the predicate variable one of the branch is encoded.
if the variable value is not specified both branches are encoded.
note that if all predicate variables are specified we essentially encod e a full program path.
if only some are specified we say that we encode a partial path denoting a set of full paths.
inlines operators are encoded which may introduce alternatives in the resulting grammar line .
lines encode string comparisons.
because hampi doesn t support direct comparison of two strings we use rules assert v in s1 assert v in s2 to query the equivalence of s1ands2withv a free variable.
note that hampi will instantiate vwhen it finds a satisfying solution.
algorithm generate and solve string constraints input s a statement in the string abstraction in ssa form r assignment to boolean variables indexed by var.
output the cfg cstr.
genstrcstr s r ifs s1 s2 then cstr cstr cfg s1 s2 ifs if b s1elses2 then ifr true then genstrcstr s1 r else ifr false then genstrcstr s2 r else genstrcstr s1 r genstrcstr s2 r ifs s1 b s2 s3 then ifr true then cstr cstr cfg s1 s2 else ifr false then cstr cstr cfg s1 s3 else cstr cstr cfg s1 s2 s3 ifs b compare s1 s2 then ifr istrue then cstr cstr assert v in s assert v in s else cstr cstr assert v in s assert v not in s input p string abstraction r assignment to boolean variables.
output sat or unsat.
solvestrcstr p r generate hampi cfg foreach top level statement s pdo genstrcstr s r return queryhampi cstr function solvestrcstr determines if a partial path denoted by the partial specification of path conditions r is feasible from the perspective of the string abstraction p. it builds the cfg by calling genstrcstr on all the top level statements and then solves it by calling hampi.
iterative solving.
the iterative driver algorithm is presented in algorithm .
function driver takes the non string constraintsn the conjunction of the non string encoding the reachability assertions and the taint assertions and th e string abstraction p then produces a satisfying solution sif there is one.
a reachability assertion dictates a sink under conside ration is reachable e.g.
asserting line is reachable in fi g. .
a taint assertion dictates the content of a file write or eval is tainted e.g.
the assertion at in fig.
.
lines are the fast path to detect unsatisfying cases.
not e that the invocation of the string solver at line considers t he path insensitive encoding.
lines are also the fast path checking if the fully path sensitive string encoding with t he path specified by ris satisfiable.
if so we simply terminate withr.
if neither fast path can be taken the recursive method itersolver is called to derive a path sensitive solution.
algorithm iterative and alternative solving input n non string constraints.
p string abstraction.
output a satisfying solution or unsat.
driver n p satn r querystp n ifsatn unsat then exit unsat ifsolvestrcstr p unsat then exit unsat ifsolvestrcstr p r sat then exitr itersolver n p r input r a known satisfying solution for n s the generated final solution output function returns implies unsat itersolver n p r s ifr then exits b select r bv r ifsolvestrcstr p s b bv sat then itersolver n assert b bv p r b s b bv satn r querystp n assert b bv ifsatn unsat then return ifsolvestrcstr p s b bv unsat then return itersolver n assert b bv p r b s b bv method itersolver takes an existing solution rto the nonstring part nas a reference to derive the final solution s. the algorithm tries to speculate a true false solution fo r a selected predicate at one iteration.
the speculation is gui ded by the provided solution r. in other words it tries to follow the satisfying path for the non string part as much as possible u ntil the string constraints become unsatisfiable.
then it backtr acks and tries a different speculation.
lines are the termination condition it means that if we have successfully speculated all predicates we acquire a s olution.
line selects a predicate from the provided solution r. right now our selection is based on the dependence distance t o the sink under consideration.
line speculates its value b ased onrand queries the string solver.
note that scontains all the predicates that have been speculated thus far and it does not specify any predicate that has not been speculated.
essenti ally it is equivalent to querying the string engine with partial path stepb1b2b3 stp hampi f sat f t unsat f f unsat t unsat table iii solving the example in fig.
.
sensitivity .
this is to leverage the observation that in many cases even partial path sensitive string constraints are d ifficult to satisfy allowing us to prune search space.
at line we continue speculation by recursively calling itersolver .
note that nis updated with the speculation the predicate is removed from r and the speculated path the final solution sis lengthened with the speculation.
in lines when mis speculation occurs the negation of the selected predicate is explored.
if both branches of th e selected predicate have been tried but a satisfying solutio n could not be found the method returns which is equivalent to backtracking to the previous iteration.
our experience shows that the algorithm can quickly converge in both the sat and unsat cases section vi .
example.
consider the example in fig.
.
the stp solver first generate a solution b1 f b2 t b3 t line in algorithm .
the path insensitive string encoding i.e.
the one in fig.
has a satisfying solution too.
but the path sensitive hampi encoding shown as follows is not satisfiable disclosing the path is not a correct solution.
var v .. cfg role1 user line cfg log1 post msg line assert f.php in .php assert v in role1 assert v in admin hence the algorithm resorts to the iterative solver.
table iii shows the process.
at the beginning it tries to follow the sat solution by stp.
at step the string constraints with onlyb1 fspecified are sat.
so that the algorithm tries to further speculate b2 t but this time the string constraints are unsat.
it then alternates to the stp solver exploring b2 f which turns out to be unsat.
it backtracks and exploresb1 twith the stp solver which is unsat too.
it then terminates with unsat.
our technique analyzes sinks one by one.
to reduce complexity for each vulnerable candidate sink we use a php slicer which was implemented in our prior work to prune the irrelevant parts before abstraction and encoding.
sinc e our technique does not handle some string operations such asindexof it is unsound.
however in practice the number of false positives is low section vi .
v. h andling practical challenges in this section we discuss how to overcome a number of practical challenges for rce vulnerability detection.
handling dynamic inclusion.
at runtime through dynamic file inclusion several php scripts may be combined together as the running script.
we need to model such effects.
for example in fig.
at lines 2inindex.php based on the value of request different script files may be admin.php user.php function accesscontrol if session !
admin header location login.php function editdata ... accesscontrol function editdata ... index.php if request admin include ad min.php else require user.php editdata fig.
example to illustrate dynamic inclusion and access control .
b request admin if b inc inlining admin.php b session !
admin if b exit else inc b3 inc if b inlining editdata in admin.php b4 inc if b inlining editdata in admin.php lines and line fig.
the non string abstraction of the program in fig.
.
included at runtime.
as a result the function invoked at lin e 3may refer to different code bodies.
the solution is to have conditional inlining at the call site that has multiple method bodies e.g.
line in fig.
.
however we need to model the fact that the condition of inlining is not the reachability condition of the call but r ather the reachability condition of the inclusion site.
we handle it by introducing a dummy variable at the inclusion site to denote the choice and later using the variable to guard the invocati on.
example .
fig.
6shows the non string abstraction of the program in fig.
.
lines abstract lines in the original code and lines abstract the original line .
note that t he definitions of b1andb2are not in the non string abstraction but rather the string abstraction.
the page redirection at l ine in fig.
5is abstracted as exitbecause when the page is redirected none of the following statements gets executed .
we introduce a dummy variable incto denote the inclusion option and use it to guide the inlining in lines .
reasoning across requests.
rce attacks may require coordination of multiple requests.
since in php requests are pro cessed independently cross request attacks usually leve rage sessions to preserve data.
in php a session can be determine d by two parts the session name and the session id .
when a server and a client communicate the session name and id are set in the http header.
the session name can be explicitly defined in a php script otherwise the default val ue phpsessid is used.
also a unique session id is assigned to each new visiting client.
in order to reason about dependenc es across requests we need to ensure the relevant requests are referring to the same session.
note that as long as the attack er ensures exploit requests are sent within the session expira tion window the session ids of these requests are automatically identical.
therefore we only need to check if the sessionstatement abstraction string non string initially snname f1 phpsessid session name c snname f1 c parsestr ... b s snname f1 tsn b?
x session s snname f2 tx tsn table iv session abstraction.
names of these requests can be made identical.
our solution is that for a statement in which a session value may be set such as line in the phpmyadmin example in fig.
we abstract the statement to a taint bit set operation guarded by a condition that the session name from the other request must be identical to the current session na me.
therefore any read from session in the other request is tain ted only when it has the same session name.
table ivexplains the process.
the 1st column lists the relevant statements wi th f1 f2 the script.
the 2nd and 3rd columns show the string and non string abstractions respectively.
initially ea ch script has a default session name 1st row .
any invocation to session name is abstracted as setting the current session name 2nd row .
a statement or library call that allows the client to set session values is abstracted as a guarded taint bit set 3rd row .
a session read in the other request f2 sets the global variable sto its session and copies the session taint bit.
vi.
e valuation our system makes use of llvm the php compiler phc the stp solver and the hampi string solver .phc is used to translate php to c allowing us to leverage the existi ng analysis in llvm e.g.
alias analysis .
the main analysis is implemented in llvm.
it takes the c program and transforms it to constraints.
the solving algorithm is implemented in c .
we apply our technique on a set of real world applications as listed in table v. observe that some of them are large with a few hundred files and over 200k loc.
these web apps are selected as we were able find some rce reports about them on the internet.
one of our goals is to see if we can identify these reported vulnerabilities.
all experiments are run on an intel dual core i5 .5ghz machine with 8gb memory.
the experimental results are publicly available at .
table v program characteristics.
php php loc application files avg stdev max total aidicms v3.
phpmyfaq v2.
.
zingiri webshop v2.
.
phpmyadmin v3.
.
phpldapadmin v1.
.
.
phpscheduleit v1.
.
freewebshop v2.
.
r2 ignition v1.
monalbum v0.
.
webportal v0.
.
table vipresents the detection results.
constraint presents the average number of variables and constraints in the formula.
sink is the number of the places that are potential vulnerable.
they are the number of file writes and dynamic script evaluations.
they are analyzed one by one.
report is the number of vulnerable sinks that our technique reports.
among those reported fppresents the number of falsetable vi analysis result.
constraint avg avg solve avg non string string application variable constraint iteration time s sink report fp known new report fp report fp aidicms v3.
.
.
.
.
phpmyfaq v2.
.
.
.
.
.
zingiri webshop v2.
.
.
.
.
.
phpmyadmin v3.
.
.
.
.
.
phpldapadmin v1.
.
.
.
.
.
.
phpscheduleit v1.
.
.
.
.
.
freewebshop v2.
.
r2 .
.
.
.
ignition v1.
.
.
.
.
monalbum v0.
.
.
.
.
.
webportal v0.
.
.
.
.
.
total table vii constraint solving comparison.
algo.
non guided solving application iteration time s iteration time s aidicms v3.
.
.
phpmyfaq v2.
.
.
.
zingiri webshop v2.
.
.
.
phpmyadmin v3.
.
.
.
phpldapadmin v1.
.
.
.
.
phpscheduleit v1.
.
.
.
freewebshop v2.
.
r2 .
.
ignition v1.
.
.
monalbum v0.
.
.
.
webportal v0.
.
.
.
one unsat case times out.
it cannot be solved in minutes.
positives known is how many of them have been reported.
new presents those that have not been reported in the past.
iteration reports the average number of iterations needed to determine sat unsat precluding the cases that are unsat for either the string or the non string constraints alone .
time is the average analysis time including the abstraction and constraint solving time.
for comparison in the last four columns we also present the results generated by considering only the string part w hich is equivalent to using hampi alone for detection and only the non string part which is equivalent to a path sens itive static taint analysis .
for the new true positive reports we have constructed exploits from the sat solutions for path conditions to confirm them.
the exploits are also available at .
they are concrete http requests that can execute an arbitrary piece o f payload script.
we have the following observations from the results.
our technique is effective.
its false positive rate is only .
it identifies real rce vulnerabilities including al l the reported ones and new ones.
its overhead is reasonable.
observe that the average number of iterations is small.
sometimes it is zero if the solut ions can be found in the fast path.
it indicates our algorithm can quickly converge for both sat and unsat cases.
another performance study can be found later.
considering either the string or the non string part alone produces a lot of fps indicating the need of reasoning both parts cohesively.
false positive .
our technique produces fps.
currently we cannot model some environment related library functions su ch asfileexists because they require dynamic information.
we have limited support for string functions such as substr and getextension due to the limit of hampi.
we introduce free modul tinymce plugins ajaxfilemanager ajax save te xt.php path not important .
post if getfileext post php ... else if file exists path ... else fp fopen path w fwrite fp post ... fig.
fp in adidcms variables in the constraints to denote the outcome of these functions.
this leads to false positives sometimes.
a false positive in adidcms is presented in fig.
.
this piece code saves the content post posted by the client into a file whose name post is also provided by the client.
if we don t consider the path conditions the file write at line 38can write the content from the client into a php file named by the client.
however if the file name ends with .php the predicate at line 21will capture the dangerous behavior.
however we currently cannot model getfileext andfileexists leading to the false positive.
evaluating the constraint solving algorithm.
we perform another experiment to evaluate our solving algorithm.
reca ll we use the stp solution to guide the overall process and leverage the string solver to prune search space algorithm .
we compare the algorithm with a simple algorithm that also solves string and non string constraints.
the simple algor ithm acquires a sat solution from stp and then validates it using hampi.
if unsat it acquires a different sat solution from stp until a solution is found or stp reports unsat.
the results are shown in table vii.
the iteration number and time in the table are the sum of those for analyzing individual sinks for each benchmark.
the runtime is the solving time not including the abstraction time.
observe that our algori thm is in general much better.
the simple algorithm may run into deep troubles for unsat cases e.g.
freewebshop when the search space is large.
vii.
r elated works the work in also statically models the string and nonstring behavior of a program.
it translates both to a common m2l constraint language.
however m2l has limited expressiveness section iii .
researchers have also modeled both strings and non strings in the context of dynamic symbolic execution .
however they require knowing stringlengths beforehand and they only model the executed path whereas we need to encode all possible paths.
string operations can also be modeled as finite state transducers fst .
the work in introduces symbolic representations in automata to handle the infinite alphabets problem in the classical fst.
in string constraint solving is used to repair html generation errors.
viewpoints applies static string analysis to compute inconsistency between client s ide and server server input validation functions.
however th ey all have very limited support for non string behavior.
rce attacks are a special kind of cross site scripting xss attack and thus our work is related to detecting sql injection xss and http request parameter tampering attacks.
among these works the dynamic analysis based approaches require running the program.
the effectiveness of these techniques is dependen t on the concrete executions monitored.
static techniques consider all possible executions.
in particular abstract away non string computation and reason about string manipulati ons in a path insensitive way.
in researchers used a static constraint solving based technique to precisely identify t he interface of a web app.
in a path context and fieldsensitive static analysis was proposed to detect resource c ontention problems.
however both works have limited support for string reasoning and only consider constant strings.
similar to our work researchers in also observed that modeling session is important in analyzing web application s. however the work aimed at test suite generation.
viii.
c onclusion we propose a path and context sensitive analysis to detect remote code execution rce attacks in web apps.
the analysis reasons about the string and non string behavior o f a program cohesively.
it first creates two abstractions of the program to model the string and non string behavior respectiv ely which are encoded to constraints separately.
a novel algori thm is developed to resolve the two sets of constraints together .
the technique handles a lot of rce specific challenges by extending the abstractions.
our experiment shows that the technique is very effective in detecting rce vulnerabiliti es in real world php applications producing much fewer false positives compared to alternative techniques.
and the unde rlying constraint solving algorithm is very efficient.