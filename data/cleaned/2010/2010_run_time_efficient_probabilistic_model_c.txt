run time efficient probabilistic model checking antonio filieri politecnico di milano deepse group at dei piazza l. da vinci milano italy filieri elet.polimi.itcarlo ghezzi politecnico di milano deepse group at dei piazza l. da vinci milano italy ghezzi elet.polimi.itgiordano tamburrelli politecnico di milano deepse group at dei piazza l. da vinci milano italy tamburrelli elet.polimi.it abstract unpredictable changes continuously affect software systems and may have a severe impact on their quality of service potentiallyjeopardizingthesystem sabilitytomeetthedesire d requirements.
changes may occur in critical components of the system clients operational profiles requirements or deployment environments.
theadoptionofsoftwaremodelsandmodelcheckingtechniques at run time may support automatic reasoning about such changes detect harmful configurations and potentially enableappropriate self reactions.
however traditionalmode l checking techniques and tools may not be simply applied as they are at run time since they hardly meet the constraints imposed by on the fly analysis in terms of execution time and memory occupation.
this paper precisely addresses this issue and focuses on reliability models given in terms of discrete time markov chains and probabilistic model checking.
it develops a mathematical framework for run time probabilistic model checking that given a reliability model and a set of requirements statically generates a set of expressions which can beefficientlyusedatrun timetoverifysystemrequirements.
an experimental comparison of our approach with existing probabilistic model checkers shows its practical applicabili ty in run time verification.
categories and subject descriptors d. .
software program verification model checking reliability c. performance of systems modeling techniques performance attributes general terms probabilistic model checking reliability keywords discrete time markov chains run time model checking permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.
.
introduction often software systems are designed developed and implemented to operate in a completely known and immutable environment with stable requirements and unvaried operationalprofiles.
inthissetting eachchangeisunexpectedan d may jeopardize the ability of the system to meet its requirements.
whenever a software has to be changed a complete maintenance lifecycle design development and deployme nt of a new version of the system has to be planned.
in this scenario changes are considered harmful and lead to costly maintenance activities and unsatisfactory time to market.
increasingly however changes occur very frequently and constitute one of the dominant factors of current software systems.
today s software is often built through composition of components operated by independent organizations e.g.
web services integrated in a larger system which may evolve unpredictably clients operational profiles and deployment environments may also change over time.
as a consequence software engineers are increasingly required to design software as an adaptive system which automatically detects and reacts to changes.
many current research proposals describe methodologies and techniques to design adaptive systems.
in this paper we focus on software systems that try to adapt themselves to keep satisfying reliability requirements in the presence of changes.
the most promising solutions build on top of two complementary techniques monitoring andmodels e.g.
.
the former aims at interpreting data extracted at run time from instances of the system.
the data collected by the monitor are analyzed to continuously update the parameters of the model e.g.
failure probability of an external service to keep the model consistent over time with the changing behavior of the environment.
the updated model may be analyzed by model checking tools which verify the compliance between the current behavior of the system and the desired requirements.
because of our focus on reliability the models we consider here are discrete time markov chains dtmcs .
unfortunately traditional model checking techniques and tools are conceived for design time use and can hardly satisfytheexecutiontimeconstraintsnormallyimposedbyruntime analyses because of the well known problem of state explosion which occurs in analyzing the model.
in particular the use of model checking tools at run time leads to unsatisfactory execution time.
indeed traditional model checking techniques take as input a model of the system and a property expressed in an appropriate formalism i.e.
the requirement and verify if the former is compliant with respect totraditional run time model checking system modelsystem requirement violations model checker monitoring requirement a use of conventional model checker.
verificationpre computation system modelrequirement expressions systemrequirement violations monitoring expressions b the proposed approach.
figure run time model checking techniques thelatter i.e.
therequirementismetbythemodel .
aspreviously introduced the monitoring continuously updates the system model at run time and the model checking process is periodically activated.
this run time procedure is computationally expensive and requires the exhaustive exploration of the model s state space which may be very large and the analysis of the property which may be arbitrarily complex.
figure a summarizes such approach.
the details concerning the complexity of traditional probabilistic model checking can be found in .
this paper focuses on efficiently evaluating the satisfaction of reliability requirements at run time.
the key concept of the proposed solution relies on separating the modelchecking activity in two distinct steps executed at design time and run time respectively.
we refer to the design time step aspre computation and to the run time step as verification.
the pre computation step takes as input the model of the system as a dtmc a set of transition variables and thereliabilityrequirementsofthesystem.
the transition variables are the parameters of the model whose value becomes known only at run time and may change over time.
for example a transition may connect a state modeling a service invocation to a failure state and the transition variable is a literal representing the changing value of the service s failure rate.
the output produced by the pre computation step is a set of symbolic expressions which represent satisfaction of the requirements.
the verification step performed at run time simply evaluates the formulae by replacing the variables with the real values gathered by monitoring the system.
in the example the monitor would yield the real value of the failure rate of the service and the formulae representing the requirements would evaluate to either true or false in case of a violation .
figure b describes the two steps involved in the proposed approach.
the main advantage of our approach relies on shifting the cost of model analysis at design time.
the computationally expensive design time transformation of reliability properties into symbolic formulae reduces run time model checking to substituting variables with values and evaluating the expression which is computationally inexpensive and does not require model exploration.
the rationale behind the approach is that we are willing to pay for an expensive trans formation step at design time if run time analysis becomes efficient and amenable to on line processing.
we measured the speed up obtained by our run time model checking approach with respect to existing probabilistic model checkers prism and mrmc pointing out advantages and threats to validity of both the approaches.
as shown in section our method outperforms existing probabilistic model checkersundertheassumptionthatpotentialchangescanbe anticipated and the number of variable transitions is small.
in the extremecase one may of course assume all transitions to be variable but this would make our approach impractical.
the rest of the paper is organized as follows section provides the necessary background.
section describes the proposedapproach.
section4illustratesthesimulationsperformed through a tool we implemented and reports the experimental results we obtained.
section discusses related work.
section concludes the paper describing some current limitations of our approach and future work.
.
grounding the problem we assume the system under development to be modeled as a discrete time markov chain dtmc .
dtmcs a widely accepted formalism to model reliability of component service based systems.
in particular they proved to be useful for an early assessment or prediction of reliability .
the adoption of dtmcs implies that the modeled system meets with some tolerable approximation the markov property described later on in section .
.
this issue can be easily verified as discussed in .
as for most design approaches based on dtmcs consider for example in our work we assume that the model depscribes behaviors that depend on interaction profile and failure probabilities which are used to label dtmc transitions.
these values may be hard to predict at design time.
in practice a software designer may rely on estimates for interaction and failure probabilities gathered by running instances of similar systems as discussed in .
some of these values in addition may change over time after the system has been developed and deployed.
we make the assumption that through careful designtime analysis we can restrict run time variability to a subset ofenvironmentparameters.
precisely weassumethat we can anticipate the variable transitions in the model and they are a small fraction of the total number of transitions.
these assumptions are valid in many practical cases.
if they do not hold our approach may still be applied but simply would not yield its expected benefits in terms of speed up of run time verification.
in the next section we briefly introduce dtmcs.
afterwards we describe pctl a probabilistic temporal logic adopted here to express reliability requirements.
.
discrete time markov chains dtmcsaredefinedasstate transitionsystemsaugmented with probabilities.
statesrepresent possible configurations of the system.
transitions among states occur at discrete time and have an associated probability.
dtmcs are discrete stochastic processes with the markov property according to which the probability distribution of future states depend only upon the current state.
formally a labeled dtmc is tuple s s0 p l where sis a finite set of states s0 sis a set of initial states p s s isastochasticmatrix s sp s s s s .
an element p si sj represents the probability that the next state of the process will be sjgiven that the current state is si.
l s 2apis a labeling function which assigns to each state the set of atomic propositions which are true in that state.
in this paper we will implicitly extend this definition by also allowing transitions to be labeled with variables in the range .. instead of constants.
a state s sis said to be anabsorbing state ifp s s .
if a dtmc contains at least one absorbing state the dtmc itself is said to be an absorbing dtmc .
inanabsorbingdtmcwith rabsorbingstatesand ttransientstates rowsandcolumnsofthetransitionmatrix pcan be reordered such that pis in the following canonical form p q r 0i whereiis anrbyridentity matrix is an rbytzero matrix ris a nonzero tbyrmatrix and qis atbytmatrix.
consider now two distinct transient states siandsj.
the probability of moving from sitosjin exactly steps is sx sp si sx p sx sj .
generalizing for a k steps path and recalling the definition of matrix product it follows that the probability of moving from any transient state sito any other transient state sjin exactlyksteps corresponds to the entry si sj of the matrix qk.
as a natural generalization we can define q0 representing the probability of moving from each state sitosjin steps as the identity tbyt matrix whose elements are iff si sj .
due to the fact that rmust be a nonzero matrix and p is a stochastic matrix qhas uniform norm strictly less than thusqn asn which implies that eventually the process will be absorbed with probability .
in the simplest model for reliability analysis the dtmc will have two absorbing states representing the correct accomplishment of the task and the task s failure respectively.
the use of absorbing states is commonly extended to modeling different failure conditions.
for example different failure states may be associated with the invocation of different external services.
once the model is in place we may be interested in estimating the probability of reaching an absorbing state or in stating the property that the probability of reaching an absorbing failure state should be less than a certain threshold.
in the next section we discuss how these and other interesting properties of systems modeled by a dtmc can be expresses and how they can be evaluated.
let us consider for example the dtmc in figure which represents a system sending authenticated messages over the network.
states5 and7areabsorbingstates states6and represent failures associated respectively to the authentication and to message sending.
we use variables as transition labels to indicate that the value of the corresponding probability is unknown and may change over time.
in matrix form the same dtmc would be characterized success init1 2login msgfail6 authenticationfail10.
logout 71y1 x0.
zsendmsg z end1 x y figure dtmc example.
by the following matrices qandr q 0y0 x y z0 .
.
r 0x0 0z this is a toy example that we use to introduce the proposed approach.
however the concepts described hereafter apply to real systems which might have thousands of states and failures as we discuss in section .
.
pctl and reliability properties formal languages to express properties of systems modeled through dtmcs have been studied in the past and several proposals are supported by model checkers to prove that a model satisfies a given property.
in this paper we focus on pctl a logic which can be used to express a number of interesting reliability properties.
pctl is a logic language inspired by ctl .
in place of the existential and universal quantification of ctl pctl provides the probabilistic operator p p wherep is a probability bound and .
pctl is defined by the following syntax true a p p x u u t formulae are named state formulae and can be evaluated over a boolean domain true false in each state.
formulae are named path formulae and describe a pattern over the set of all possible paths originating in the state where they are evaluated.
the satisfaction relation for pctl is defined for a state s as s true s aiffa l s s iffs s 1 2iffs 1and s 2 s p p iffpr s p a formal definition of how to compute pr s is presented in .
the intuition is that its value corresponds to the fraction of paths originating in sand satisfying over the entire set of paths originating in s. the satisfaction relation for a path formula with respect to a path originating ins s is defined as x iff u iff j .
k j. u t iff j t. k j. pctlisanexpressivelanguagethatallowsmanyinterestingreliability relatedpropertiestobespecified.
ataxonomy of all possible reliability properties is out of the scope of thi s paper.
the most important case is a reachability property .
a reachability property states that a state where a certain characteristic property holds is eventually reached from a given initial state.
in most cases the state to be reached is an absorbing state.
such state may represent a failure state in which a transaction executed by the system modeled by the dtmc eventually terminates or a success state .
reachability properties are expressed as p p true u which expresses the fact that the probability of reaching any state satisfying has to be in the interval defined by constraint p. is assumed to be a simple state formula that does not include any nested path formula.
in most cases it just corresponds to the atomic proposition that is true in an absorbing state of the dtmc.
in the case of a failure state the probability bound is expressed as x wherexrepresents the upper bound for the failure probability for a success state it would be instead expressed as x wherexis the lower bound for success.
pctl is an expressive language through which more complex properties than plain reachability may be expressed.
such properties would be typically domain dependent and their definition is delegated to system designers.
for example referring to the example in figure we express the following reliability requirements r1 the probability that a msgfail failure happens is lower than .
r2 the probability of successfully sending at least one message for a logged in user before logging out is greater than0.
r3 the probability of successfully logging in and immediately logging out is greater than .
r4 the probability of sending at least messages before logging out is greater than or equal to .
these requirements can be translated into pctl as shown in table .
notice that r1is an example of reachability property.
also notice that these requirements have different sets of initial states r1 r3 andr4must be evaluated starting from state i.e.
s0 whiler2must be evaluated starting from state .
in the next section we present a mathematical procedure to compute a symbolic formula i.e.
an analytic expression for the properties we want to verify at run time.
we start by analyzing reachability properties and then we progressively show how to cover all of pctl formulae.
.
the approach in this section we illustrate how pctl formulae may be pre computed at design time.
pre computation produces 1note that this is often expressed as p pf using the finallyoperator.table requirements translation in pctl.
req.
pctl r1p .
true u s p .
f s r2 p .
s 2u s r3 p .
x s r4 p .
s 3u 5s a formula for each pctl property.
the formula is an analytic expression that contains variables which become known at run time.
variables correspond to transition probabilities that are unknown or uncertain at design time.
note that there must be at least two variable transitions exiting a state since the sum of probabilities must be .
in general we may assume that if there is a variability all the transitions exiting a node are variable.
we refer to such states asvariable states .
we start this section by discussing how reachability formulae may be pre computed.
we then discuss how to extend our approach to cover the entire pctl.
.
reachability formulae the most commonly studied property for reliability analysis is the probability of reaching a certain state which typically represents the success of the system or some failure condition.
both success and failure are modeled by absorbing states.
the reachability formula in this case has the following form p pfl wherelis the label of the target absorbing state.
let us start our discussion by showing how to pre compute at design time a reachability formula for an absorbing state of a dtmc.
for an absorbing dtmc the matrix i qhas an inverse nandn i q q2 ... i 0qi .
the entry nijof nrepresentstheexpectednumberoftimesthemarkovchain reaches state sj given that it started from state si before getting absorbed.
instead qijrepresents the probability of moving from the transient state sito the transient state sj in exactly one step.
given that qn whenn as discussed in section .
the process will always be absorbed with probability after a large enough number of steps no matter which state it started in.
hence our interest is to compute the probability distribution over the set of absorbing states.
this distribution can be computed in matrix form as b n r whererikis the probability of being absorbed in state sk given that the process started in state si.
bis at rmatrix and it can be used to evaluate the probability of each termination condition starting from any dtmc state as an initial state.
in particular the element bij of the matrix brepresents the probability of being absorbed into statesjgiven that the execution started in state si.
the design time computation of an entry bijin general can only be done symbolically since variable states may be traversed to reach state sj.
let us evaluate the complexity of such computation.
inverting matrix i qby means of the gauss jordan elimination algorithm requires t3 operations.
the computation of the entry bijoncenhas beencomputedrequires tmoreproducts thusthetotalcomplexity ist3 talgebraic operations on polynomials.
the computation could be further optimized by exploiting thesparsity of i q. notice that the symbolic nature of the computation makes the design time phase quite costly .
the complexity can be significantly reduced if the number of variable components cis small and the matrix describing the dtmc is sparse as very frequently happens in practice.
letw i q. the elements of its inverse nare defined as follows nij det w ji w where ji w is the cofactor of the element wji.
thus bik x ..t 1nix rxj det w x ..t 1 xi w rxj computing bikrequires the computation of tdeterminants of square matrices with size t .
let be the average number of outgoing transitions from each state nby assumption .
each of the determinants can be computed by means of laplace expansion.
precisely by expanding first thecrows representing the variable states each has symbolic terms we need to compute at most cdeterminants and then linearly combine them.
each submatrix of size t cdoes not contain any variable symbol by construction thus its determinant can be computed with t c 3operations among constant numbers lu decomposition thus much faster than the corresponding ones among polynomials.
the final complexity is thus c t c c t3 whichsignificantlyreducestheoriginalcomplexityandmakes the design time pre computation of reachability properties feasible in a reasonable time even for large values of t. as a point of comparison the computation of reachability properties performed by probabilistic model checkers is based on the solution of a system of nequations in nvariables which has in a sequential computational model a complexity equal to n3 .
summing up we discussed the computation of properties in the form p p fsk whereskis an absorbing state starting in any initial transient state of the system2.
with this procedure it is possible to obtain closed formulae for a number of interesting reliability properties.
for example evaluating r1on our example system that is the probability of reaching the state msgfail failure in any number of execution steps corresponds to evaluating b07as r1 yz .
.15z .
let us now consider the computation of the probability of successfully reaching a certain state sjthat is not an absorbing state3.
the quantity we are interested in is fij the probability of ever making a transition into state sjgiven that the process started in state si sican be any transient state taken as initial state .
formally let fn ijrepresent the probability of moving from the transient state sito the transient statesjfor the first time in exactly nsteps 2actually we discussed the computation of the probability associated with the property to which the constraint p has to be applied.
3ourmathematicaldescriptionfollowsthe treatmentin to which we direct the reader for a more detailed discussion.
f0 ij i j f0 ij i j fn ij pr xn sj xk sj k n x0 si wherexkis the state of the system at execution step k. then fij n 0fn ij it is possible to compute the value fijfrom the matrix n by conditioning the entry nij the expected number of times the dtmc on whether state sjis ever entered nij njjfij thus fij nij njj ji w jj w hence computingtheprobabilityofmovingfromatransient statesito a transient state sjis reduced to the computation of the determinants of two matrices with size t .
again by the fact that only a few rows of nare symbolic i.e.
only a few states are variable the actual complexity of the computation is approximately the same as in expression .
the approach we described so far supports the definition of properties which represent requirements that speak about the probability of reaching state sjwithout reaching any failure or the probability of a successfully performing a certain operation or service .
in our example the probability of reaching the logoutstate after any number of steps4corresponds to the entry f04 .
.85x .15z .15xz yz .
.15z.
once again we stress that our approach is especially practical under the assumption that the number of parameters of the system is reasonably small.
design time computational effort could be further reduced by adopting state of the art parallel matrix calculus algorithms .
.
extending to full pctl in the previous section we described a solution limited to reachability properties.
even though reachability represents the most widely adopted pattern for reliability analysis it does not cover all the requirements that engineers need to express for real world applications consider for example requirements r2 r4of our example.
in this section we incrementally extend the approach to handle all of pctl.
noticethatreachabilitypropertiescorrespondtorestricted until formulae p p 1 2 where 1corresponds to true i.e.
1is satisfied in any state and 2does not include any nested path formula we refer to this subset of pctl which does not allow the nesting of path operators as theflat subset .
sections .
.
and .
.
discuss our approach for each pctl operator in the case of flat formulae.
section .
.
then describes how to extend the approach to nested formulae thus covering the entire pctl.
.
.
flat until formulae the procedure to support requirements in the flat form 1 2relies on reducing them to reachability properties and applying the technique described in sect.
.
.
4note that this probability is not what is needed for r3 which in turn requires to reach logout in a single step.
see section .
.
.the reduction procedure starts with the construction of a dtmc ddefined as follows.
we refer to the set of states of dass d. the set is the union of three non overlapping subsets sgoal s goalandstransient respectivelydefinedas all the absorbing states of the original dtmc in which 2is true plus an additional auxiliary state sgoal all the absorbing states of the original dtmc in which 2is false plus anadditionalauxiliarystate s goal and alltheremaining statesoftheoriginaldtmc stransient s sgoal s goal .
the following algorithm defines the transitions of dstarting from the transitions of the original dtmc .
deletealltheoutgoingtransitionsfromallthetransient statesoftheoriginaldtmcinwhich 1 2 istrue and add a single outgoing transition directed to s goal with a labelling probability equal to .
.
attach to all the transient states of the original dtmc where 2is true a single outgoing transition directed tosgoalwith a labelling probability equal to .
recallingour example of figure and considering requirementr2we have that sgoal sgoal s goal s goal stransient figure illustrates the resulting dtmc d. figure resulting dtmc d. goal states in sgoalrepresent the satisfaction of the formula.
in fact all the path formulae in the form 1u 2 are satisfied in all the states in which 2is true and those states in d are directly connected to goal states.
moreover the predecessor states on any path that leads to a state where 2is true are such that 2is false otherwise from there we would reach sgoalwith probability and is true otherwise it would have been deleted by step of our algorithm .
conversely states in s goalcan be reached directly and with probability by all the states in which the formula is not satisfied i.e.
1 2 istrue.
hence we reduced the evaluation of a general until property to a reachability property such as p p f s sgoal .
for example evaluating r2on the original dtmc is equivalent to evaluating the reachability property p p f s sgoal over d which corresponds to the entry b18 where is the index of state sgoal computed over the transition matrix of d r2 y yz .
.
.
flat next and bounded until formulaelet us consider again the flat subset of pctl and let us focus on the pre computation of formulae that use the next and the bounded until operators which require analyzing paths of finite length.
the set of paths to be considered in order to evaluate the formula x 1in statesiis composed by all step long paths exiting si.
the maximum size of such set is n i.e.
the number of states which is also the worst case complexity of our design time pre computation procedure.
the probability thatsi x 1is pr x 1 sj 1 pij for example in order to evaluate r3 we first notice that s is satisfied only in state logout.
thus the probability of satisfying s in exactly one step from state login is expressed by the formula x y andr3becomes r3 x y .
a similar procedure applies to the bounded until.
a path originating in si which satisfies the formula 1u v 2 at a certain step k vsatisfies 2and for all the states l k satisfies .
we therefore need to consider all the paths with lengthk v. if we exploit the dtmc dbuilt as explained in the previous section all these paths correspond to paths of dwhose length is equal to exactly v and which reach a transient state satisfying 2invsteps and then end in any of the states insgoal.
indeed if a path reaches an absorbing state afterksteps it remains in that state with probability equal to thus the tail of the path will be composed of v k self transitions with probability exiting a state in sgoal.
the probability of moving in v steps from a state si to a statesjcorresponds to the entry pv ijof the v th power of the transition matrix pof the dtmc d. hence pr 1u v 2 sj sgoalpv ij in our example let us consider r4.
after constructing d it is possible to compute the probability of reaching any of the goal states from the loginstate.
in this case there is only one goal state sgoalbecause the formula s is false in any other absorbing state.
thus we need to compute the entryp6 where is the index of sgoal and such a value is r4 x y .85y z .1275y z .
to assess design time complexity in this case we should consider that we need to compute the matrix pv .
since the complexity of a matrix dot product is approximately n3 a non optimized algorithm has complexity vn3.
at runtime both next and bounded until only require to evaluate a polynomial by substituting values to transition variables as in the case of reachability formulae.
.
.
handling nested path formulae we have shown that for all kinds of flat pctl formulae it is possible to generate a corresponding symbolic expression at design time.
in the case of nested path operators that is for formulae p p where at least one subformula of is again a path formula some information needed to compute the expression might be unavailable at design time.
for example the actual violation of requirements r1 r4 will be known only at run time when parameter values willbe available.
if any of those formulae is for example part of the right hand operand of an until formula the construction of the reduced dtmc dmust be delayed to run time when the set of states which satisfies and becomes known from the values bound to the parameters.
thus in general to evaluate a formula with nested p p operators we need toknow in which states its subformulae are satisfied andthe definition of this set may depend on parameter values.
the same observation can be applied recursively to subformulae of a subformula until we reach a flat formula for which we can immediately construct an equivalent expression.
to develop a solution we need a way to delay the evaluation of a formula to run time when all of its subformulae will be already evaluated providing the missing knowledge.
in order to support this process we add some extra parameters at design time which will account for the lack of information concerning subformulae s satisfaction.
those parametersconstituteascaffoldingintroducedatdesigntime which is removed as subformulae are evaluated.
let us first focus on until formulae like 1u 2. recalling the procedure in section .
.
the construction of drequires two basic operations besides the introduction of absorbing states sgoalands goal replacing all outgoing transitions from states where 1 2 holds by a single one toward s goal and replacing all outgoing transitions from states where 2is true by a single one toward sgoal.
from a mathematical viewpoint deleting a transition is equivalent to labeling it with probability.
by multiplying each non zero transition pijof the original dtmc by a coefficientmij it is thus possible to delay the decision whether a transition should be deleted or not by later assigning0or1tothecorrespondingcoefficient mij.
toconstruct d we also need to be able to connect a transient state tosgoalors goal.
in order to do that we complete our scaffolding by introducing two transitions labelled aisgoaland ais goal to connect each state ito the newly introduced sgoalands goal respectively.
these labels can be assigned at run time value in case the construction of drequires to connect the transient state itosgoalors goal respectively.
by applying the scaffolding procedure to our example we obtain for matrices qandr q 0m0 m1 2y 0m1 x y m2 z 0m3 .
m3 .
r a0 8a0 0m1 x0a1 8a1 m2 z a2 8a2 a3 8a3 m4 a4 8a4 the last phase of the decision procedure in section .
.
requires to sum the probabilities of reaching every absorbing state insgoal.
this set will be known at run time when the subformula 2can be evaluated.
at design time we simply compute the entire matrix b the probabilities of goingfromeachtransientstatetoeachabsorbingstate from the original dtmc instrumented with the just presented scaffolding.
at run time when the set sgoalbecomes known we assign a value to mijandaijcoherently with what we did in section .
.
and sum all the bijfrom the transient i in which the formula is being evaluated to a state j sgoal.
concerning next and bounded until operators the methods described in section .
.
are still valid though theyhave to be applied to the matrix pinstrumented with the scaffolding sothat atruntime itispossibletoassignvalu es tomijandaijto account for the newly acquired knowledge.
in the case of nested path operators at design time it is not possible to exploit the mixed symbolic expanded via laplace and numeric computation of bijpresented in section .
.
nevertheless being mijandaijboolean instead of floating point multiplications with constant values it is po ssible to use faster bitwise and while multiplying a polynomialby1hasnocostandmultiplyingitby0triviallyreturns .
thus the introduction of the scaffolding does not affect significantly the complexity of the design time analysis we illustrated in section .
.
at run time in the case of nested path operators the pctl formula cannot be evaluated in a single step as we didforflatformulae.
neverthelessthenumberofexpressions to compute is linearin the number of path operators and each formula has to be evaluated at most for all transient states.
each evaluation still works on a polynomial.
the run time efficiency gain over conventional model checkers is discussed next for all pctl formulae.
.
v alidation the main goal of this work is to find an efficient way of computing reliability properties in frequently changing environments.
we described a solution that performs a designtime computationally expensive derivation of verification formulae that can be evaluated very efficiently at run time when parameter values become known.
the approach fits the very frequent situation in which time consumption during development is not critical but run time evaluation of verification formulae is subject to tight time constraints.
concerning run time evaluation5 we compared the performance of a simple java c prototype implementation of our approach with the outputs produced by two widely used probabilistic model checkers prism and mrmc and with a numerical computation of results of formulae by matlab.
all the tools were required to produce an approximation of at most 15and to run with its default solution strategy.
the test suite is composed of samples.
each sample is a randomly generated dtmc with a number of states varying from to with step with absorbing states namely correct completion andfailure .
each state has a number of outgoing transitions randomly sampled from a gaussian distribution with mean and standard deviation .
the number of variable states is for all the samples and when a state is variable so are all its outgoing transitions.
we did not consider the process spawning time and we report as execution time the one provided by each tool.
theexecutionenvironmentisadedicatedmachinewith2intel r xeon r cpu e5530 .40ghz and 8gb of ram.
the operating system is ubuntu server .
.
64bit.
matlab version is 2008a release .
.
.
prism version3.
.
and mrmc .
.
both compiled at 64bit with default compiling options.
our prototype generates the input files for all of these tools and a c program computing our formulae.
concerning prism here we consider model checking time only which does not take into account the model construction 5the software used for the experimental assessment and the datasets are available at up to secs for a states dtmc .
the empirical validation focused on reachability formulae.
in practice most useful reliability properties are expressed as reachability formulae.
in addition as we showed in section reachability is at the core of analysis for also other pctl properties.
computa on time us dtmc size states matlab prism mrmc us figure runtime verification.
the result of our comparison is shown in figure we use a logarithmic scale for time .
computation time growth quickly as the size of the dtmc raises both for prism and mrmc.
prism exhibits serious performance problems probablyduetothefactthatitisunabletotakeadvantageof its symbolic engine which instead performs pretty well in the reduction of complex pctl formulae to reachability problems.
the state space reduction approach adopted by mrmc seems to be more successful for our samples.
prism becomes an order of magnitude worse than our approach after states while mrmc after states.
with states prism takes an order of 106 sand mrmc still 104 s. we also used matlab to compute the same procedure based on linear algebra that was adopted in our methodology but with numerical methods.
input matrices were declared as sparse so that the matlab numerical engine chooses the best algorithm to perform computation.
the runtime performance of our tool is close to a constant for reachability formulae.
independent of the size of the input dtmc computation time is in the order of 103 s with a maximum of s an average of .27 sand a standard deviation of .77 s. fluctuations in the values are due to the topology of the matrices which can lead to longer or shorter polynomial forms in our mathematical formulae depending on how they scatter variable symbols during computation.
the gap between and is essentially due to some outliers in the dataset whose effect can be reduced by extending the sample set available on the web .
in any case the number of possible combination of those symbols is always bounded.
remember that we are considering the case in which only a few states are variable and their number is the most influent parameter for our complexity determining how many variables appear in our mathematical formulae.
our approach is independent of the size of the dtmc and the resulting mathematical formula can be implemented directly in any programming language without any need to integrate with external tools or libraries.
notice that the mathematical formula we produce is not optimized neither at the computation level by grouping terms of factorizing polynomials nor at the compilation level e.g.
via optimization flags for mathematica lcomputation as in gcc6 .
the price for such a fast run time evaluation has to be paid at design time though only once.
as explained in section the three parameters on which design time computation depends are the size of the system the number of variable states and the number of transitions outgoing from variable states.
our prototype design time symbolic manipulation engine is not optimized thus the execution times reported hereafter are just an indicative order of magnitude of the complexity scale of the problem in a non parallel execution environment.
all the following experiments were conducted in the same execution environment described above for run time performance evaluation.
execution on a parallel machine might bring a drastic reduction of execution time.
all dtmcs in the following test suites have absorbing states representing successful termination and failure of a hypothetical system.
the dtmc are generated randomly with variable states and an average of outgoing transitions standard deviation .
as before if a state is variable so are all of its outgoing transitions.the reliability property is expressed as the reachability of a successful termination state.
y 4e 07x3 .0021x2 .5862x .
computa on time s dtmc size states 3me size poly.
3me size figure precomputation time over dtmc s size.
figure describes how pre computation time varies according to the size of the system.
the grey line shows an interpolated trend line whose equation is also shown in the figure.
the expected complexity in this case was n3 where nis the number of states in the dtmc.
as a matter of fact the use of jama7for the numerical part of the computation slightly reduced the expected computation time which is still a low order polynomial.
the number of variable states is the most critical parameter for design time pre computation.
figure reports precomputation time for a number of variable states from to .
all the sample dtmcs per class are composed by states each of those with an average of outgoing transitions standard deviation .
the time axis in figure is in logarithmic scale.
the diagram shows that time complexity is exponential and roughly in the order of 14c wherecis the number of variable states which is consistent with what one expects considering the randomness of the number of .0862e2.6372x .
computa on time s variable components 0me components expon.
0me components figure precomputation time over variable states.
transitions of the input samples.
thelastparameterwhichaffectsdesign timepre computation is the average number of transitions from variable states.
figure shows the results of our experiments.
for simplicity we sampled the number of outgoing transitions for all the states both variable and not from a gaussian distribution having as mean the number of transitions on the abscissa and standard deviation equal to mean rounded to the closest integer .
the dtmc has states of which are variable.
hence the expected complexity is in the order of 2 which was confirmed by the empirical results.
y .4601x2 .9737x .
computa on time s average outgoing transi ons 1me transi1ons poly.
1me transi1ons figure precomputation time over .
.
related work in this paper we focused on reliability requirements for dtmc based models.
based on the seminal work described in dtmcs become the most widely adopted modeling formalism to deal with reliability at architecture level.
a number of approaches have been proposed in this direction .
the latter presents a framework for component reliability prediction whose objective is to construct and solve a stochastic reliability model allowing software architects to explore competing alternatives.
specifically the authors tackle the definition of reliability models at architectural level and the problems related with parameter estimation.
besides the basic estimation of failure occurrence there are a number of advanced reliability properties that can be analyzed by means of dtmc based techniques e.g.
failure propagation and failure evolution and transformation in presence of multiple failure modes .an important problem shared by all design approaches based on dtmcs is how to get interaction and failure probability values .
many solutions came out from the research community from accelerated test to mining of bug repositiories up to the estimation of failure probabilities even in case no failure has been observed and so and so on.
to make our methodology worthy one must be able to estimate relevant system parameters on the fly by monitoring the system.
many methods exist to support reasoning on non functional properties of software based on models that are analyzed at run time by relying on monitoring such as but for all of them the tighter bottleneck is how to realize that a requirement is being violated in a time short enough to allow effective reactions.
probabilistic model checking plays a crucial role in evaluating reliability properties typically expressed in pctl over dtmc models of the running system.
in practice however they require minutes or more to evaluate properties over large models thus hindering planning and reconfiguration capabilities that must respond to tighter time bounds.
in daws proposed a procedure to first convert the dtmc into a finite automaton from which it is possible to obtain a corresponding regular expression.
this expression can be evaluated to a mathematical formula which represents any arbitrary reachability property.
daws approach is restricted to formulae without nested probabilistic operators and the outcoming regular expression grows quickly with the number of states composing the dtmc nlog n .
in hahn et al.
propose a refinement of the approach presented in for reachability formulae which combines state space reduction techniques and early evaluation of the regular expression in order to improve actual execution times when only a few variable parameters appear in the model.
the improvement in requires n3 arithmetic operations among polynomials performing better than in most practical cases although still leading to anlog n long expression in the worst case.
as opposed to our approach only deals with reachability properties.
for reachability properties by applying our approach in a sequential environment and considering each parametric transition as a polynomial expression one can obtain approximately the same complexity as without resorting to particularly efficient determinant computation methods .
for example by applying the coppersmith winograd algorithm we could reduce complexity to n2.
.
parallelization as well as exploitation of sparsity of matrix w see section .
would lead to an even higher improvement in design time computation performance.
.
conclusions and future work weaddressedtheproblemofefficientrun timemodelchecking of reliability models expressed as dtmcs.
we provided a mathematical approach that divides the model checking process in two steps to be computed respectively at design timeandruntime improvingconsiderablytherun timeperformance of analysis.
the approach which is particularly valuable for systems with a limited number of variability points provides full support to pctl and is particularly efficient for reachability properties.
we implemented the approach in a prototype tool which will be made available as an open source artifact.
we performed extended simulations but for space reasons we could only report on selected cases.
we focused on comparingour solution with state of the art tools like prism and mrmc .
an empirical comparison with param8 the tool implementing the approach of concerning reachability properties is also planned after we will develop an optimized implementation of our tool.
our approach is a solution based on linear algebra and well known algorithms that can be highly parallelized to make our approach more efficient.
in the future we plan to complement simulationbased validation with real world case studies to stress the scalability and effectiveness of the approach.
in addition we plan to reduce design time complexity by means of state space reduction and partial order reduction techniques.
finally the approach might be extended both to other logics such as pctl and to other markov models such as continuous time markov chains for performance analysis.