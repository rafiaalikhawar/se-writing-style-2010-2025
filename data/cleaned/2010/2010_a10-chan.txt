searching connected api subgraph via text phrases w ing kwan chan hong cheng department of systems engineering and engineering management the chinese university of hong kong chanwk hcheng se.cuhk.edu.hkdavid lo school of information systems singapore management university davidlo smu.edu.sg abstract reusing apis of existing libraries is a common practice during software development but searching suitable apis and their usages can be time consuming .
in this paper we study a new and more practical approach to help users find usages of apis given only simple text phrases when users have limited knowledge about an api library.
we model api invocations as an api graph and aim to find an optimum connected subgraph that meets users search needs.
the problem is challenging since the search space in an api graph is very huge.
we start with a greedy subgraph search algorithm which returns a connected subgraph containing nodes with high textual similarity to the query phrases.
two refinement techniques are proposed to improve the quality of the returned subgraph.
furthermore as the greedy subgraph search algorithm relies on online query of shortest path between two graph nodes we propose a spaceefficient compressed shortest path indexing scheme that can efficiently recover the exact shortest path.
we conduct extensive experiments to show that the proposed subgraph search approach for api recommendation is very effective in that it boosts the average f measure of the state of theart approach portfolio on two groups of real life queries by and respectively.
categories and subject descriptors d. .
management productivity d. .
reusable software reusable libraries keywords api graph api recommendation subgraph searching .
introduction application programming interfaces apis from thirdparty libraries provide many of the needed functions for programmers.
re implementing these functions from scratch permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.is obviously very costly in both time and money.
besides these apis are usually reliable and bug free since they are well tested with many test cases before releasing to the public.
therefore reusing apis of existing libraries is a common practice during software development.
if a programmer locates suitable apis and discovers rules in using them he she can accomplish a task efficiently.
however this is not an easy task especially when the api library is large and complex .
for example the object oriented library javatmplatform standard edition v1.
jse .
provides more than classes and methods.
from the study of query logs of a search engine in developers spend much time and effort in searching related apis.
it is because the learning curve of re using apis can be steep due to several barriers.
two of them are selection barrier and coordination barrier .
first a programmer attempts to overcome selection barrier by finding suitable apis that are appropriate for a particular task.
afterwards the programmer attempts to overcome coordination barrier to find the usages of the selected apis by referring to sample code or method invocations in the documentation.
there are many api and code recommendation methods to facilitate re using apis code .
some approaches group such as aim at solving selection barrier only but they enable users to use high level natural language as the query.
other approaches group such as aim at solving coordination barrier by providing method invocation context but they start with exact signature of method s .
a user may want to pass through both barriers at the same time and a simple way is to glue existing approaches.
but this is time consuming as a user has to decide suitable functions to be the inputs of a group approach after issuing a series of queries in natural language to a group approach.
in this paper we consider a new attempt for helping a user to pass through both barriers with minimum human interventions.
the proposed approach allows a user to use a set of short text phrases as the query and returns a connected subgraph where its nodes represent classes or methods exhibiting high textual similarity with the query phrases and its edges indicate the invocation relationship between the nodes.
we first model classes and methods in an api library as well as their invocation relationships as an api graph.
given a query after locating the initial api candidates methods or classes based on textual similarity we try to find an optimum subgraph with the highest score from the api graph among all possible connected subgraphs.
a possible connected subgraph is a graph where each phrase in the query can be similar to 1at least one of its nodes methods or classes .
a subgraph s cores higher if the accumulated textual similarity is higher while the total number of nodes is smaller.
let us first illustrate the benefits and challenges of the new problem setting with a sample query qconsisting of short phrases q0 database connection q1 create sql statement and q2 get result .
these phrases in qconcisely describe that the goal of the task is connect to database issue a sql and get the result .
figure shows the query qtogether with a small api graph1constructed from a snapshot of classes and methods in java.sql package of jse .
.
the dashed edges link each phrase in qto corresponding candidate classes methods nodes if their textual similarity is above a certain threshold.
the optimum subgraph for qonly consists of nodes and illustrating a typical api usage w.r.t.
the query q i.e.
a connection object invokes its member function createstatement which then returns a statement object.
the statement object then invokes its member function getresultset .
the new problem setting has two benefits.
first forming a high level query consisting of phrases in natural language is flexible because it allows a user to issue the query without getting familiar with the names of methods classes.
second a connected subgraph indicates clear relationships among methods classes of interest.
on the other hand it has two challenges which are mainly related to finding connected subgraphs.
first an api library is usually large and complex.
as a result the constructed api graph usually forms a huge search space.
exhaustively enumerating all the possible connected subgraphs is not feasible due to exponential runtime when the number of phrases in qincreases especially given a low textual similarity threshold.
second existing greedy subgraph search algorithms rely on online query of shortest path between two graph nodes.
it is necessary to precompute and store all pairwise shortest paths between graph nodes in memory to support efficient subgraph search with a small distance.
however it takes at leasto n2 space to index all pairwise shortest paths for a graph with nnodes.
when an api graph contains a large number of nodes this is prohibitively expensive.
at a first glance we can reuse an existing code recommendation approach portfolio to solve the new problem details of the approach are in section .
however it does not guarantee a connected subgraph since it only outputs top kmost similar nodes to the query.
for example for the query in figure if k nodes and will be returned.
but these isolated nodes do not reveal the invocation relationships among methods and classes thus they are less useful.
in contrast in our problem formulation we bear the consideration of subgraph connectivity in mind and aim to find a connected subgraph such that it has high textual similarity to the query phrases contains very few irrelevant nodes and shows clear invocation relationships among methods and classes.
our contributions include .
we start from a greedy subgraph search algorithm which was originally designed for the team formation problem in an expertise network .
we identify two limitations in this basic solution and propose refinement techniques to improve the quality of the subgraph 1for visualization purpose the api graph shown here is directed.
in section we formally define an api graph as undirected.for api recommendation.
the improved solution has the same time complexity of o n2 as that of the original approach where nis the number of nodes in the api graph.
.
to enable efficient online query of shortest paths between graph nodes we propose a space efficient domainspecific indexing scheme that only indexes pairwise shortest paths between classes.
the indexing scheme can recover the exact shortest path efficiently with two supplementary indexing structures.
it is applicable to any object oriented libraries.
.
we conducted extensive experiments using two groups of real life queries to compare the proposed approach withportfolio .
the results show that the average f 1measure of the proposed approach is group i and group ii higher than that of portfolio .
the rest of the paper is organized as follows.
section defines preliminary concepts and the problem statement.
section describes the basic greedy subgraph search algorithm for finding a connected subgraph and our proposed refinement techniques.
section introduces the space efficient shortest path indexing scheme.
we present our experimental results in section and discuss related work in section .
finally section concludes our study.
.
problem statement there are two kinds of components in an object oriented api library namely classes interfaces denoted as c and methods and constructors denoted as m. the sizes ofcandmare c and m respectively.
besides there are four kinds of relationships between classes and methods inheritance of a child class from its parent denoted as inh a class to its member methods denoted as mem an input parameter to a method if any denoted as inp and a method to its output parameter if any denoted as out.
we use rel inh mem inp out to denote these four kinds of relationships among candm.
anapi graph defined below can be constructed from an object oriented api library.
definition .
api graph an api graph g vg eg is an unweighted and undirected graph.
the node set vg c mcorresponds to all classes and methods and its size is vg c m .
each node v vgis associated with a bag of words bow v. there is an edge e u v eg foru v vgiff rel u v rel.
example .
figure shows a sample api graph where the nodes in oval shape are classes in java.sql packages and the other nodes in box shape are member methods of the class nodes.
edges e and e represent the relationships mem i.e.
method createstatement is a member of class connection and out i.e.
the output of method createstatement is class statement respectively.
definition .
query a query qconsists of a set of required phrases qi q i q where q is the size of the query q. each phrase q qis associated with a bag of words bow q. for each phrase q q we need to pick at least one node from the api graph gwith high textual similarity to qin the resultant subgraph.
we use dice s coefficient in eq.
to 2api graph query connection1 createstatement preparestatement createstatement int int statement executequery getresultset getgeneratedkeys resultset databasemetadata10 getschemas getresultsetholdability q0 database connection .
.4q1 create sql statement0.
.
.
.
q2 get result0.
.
.
figure sample query and api graph from a snapshot of java.sq l package for simplicity and clarity we only show the input parameters of method nodes and measure the textual similarity between a phrase q qand a node v vgbased on their bows2.
in addition we set a textual similarity threshold .
given a query phrase q for any v vg ifsim q v vis a candidate match node for q. sim q v bow v bow q b ow v bow q next how to measure the goodness of a subgraph w.r.t.
a query qfor api recommendation?
intuitively if the accumulated textual similarity between nodes in a subgraph g and phrases in the query is higher g is a better choice.
for convenience we refer to the node set in g with highest similarity to each of the query phrases as necessary nodes vo and other nodes vg voasdummy nodes .
a better subgraph shall contain less dummy nodes that are not textually similar to any phrases in the query.
therefore we use gain in definition to measure the goodness of a subgraph.
definition .
gain for a subgraph g g the gain of g gain g q w.r.t.
a query qis measured by eq.
.
gain g q summationtext qi qsim qi v i q vg vo where v i arg max v vg sim qi v is the best matching node of phrase qi vo v i i q is the set of best matching necessary nodes to each of the query phrases and is the dummy node penalty.
example .
consider figure .
bows of node are and bows of phrase q1 create sql statement of the query qare .
thus sim q1 v1 .
.
given .
and .
the subgraph in figure b has a gain of .
w.r.t.
q. now we formally define our api recommendation in problem which contains three conditions for an optimum subgraph g w.r.t.
a query.
problem .
searching api subgraph given a query q an api graph g vg eg a similarity threshold and a dummy node penalty the problem of searching api subgraph is to find a subgraph g vg eg gs.t.
the following three conditions hold 2bows represent textual information for a node or a query phrase.
in our implementation we split the name identifier of a node by camel case to obtain bows for a node.
.g is connected .
q q v vg s.t.
sim q v .gain g q max h ggain h q .
condition states that g shall be connected.
condition states that for every phrase in the query we can find a node ing that is textually similar to this phrase by passing the similarity threshold .
condition states that g shall have the highest gain among all possible subgraphs satisfying conditions and .
.
api subgraph search according to problem finding a subgraph with the highestgain for the api recommendation task is very hard as we need to exhaustively enumerate all the possible connected subgraphs consisting of candidate nodes whose textual similarity with the query phrases is above .
this time complexity increases exponentially with the number of phrases in a query q especially when is low i.e.
the number of candidate nodes which pass the similarity threshold is large.
.
a greedy subgraph search algorithm considering the prohibitive computational cost in finding the optimum api subgraph we resort to a greedy algorithm called rarestfirst rf which was proposed in the work of lappas et al.
.
the problem studied in is given a tasktwhich requires a set of skills and an expertise network where each expert node possesses one or more skills and there is some communication cost between two experts the goal is to find a team of experts who can jointly fulfill all required skills in twith the minimum communication cost among them.
in our problem setting nodes in an api graph correspond to experts and the query corresponds to the task.
our problem setting is a little different in that we account for textual similarity between nodes classes or methods and required phrases of the query.
the modified rf method to suit our problem setting is in algorithm .
we explain the main idea of algorithm rf.
it first invokes a procedure findsupport line which for each query phrase q q finds all candidate match nodes v vgwhose textual similarity with qis above i.e.
sim q v .
the set of candidate match nodes for qis denoted as s q .
then we find the query phrase qwith the smallest cardinality s q and denote it as qrare i.e.
the query phrase with the smallest number of match nodes.
for each candidate c s qrare it finds the closest node v s q tocfor all 3other q q lines .
finally it picks a c s qrare with the smallest diameter to form a connected subgraph lines .
the subgraph is formed by connecting c with the closest node v q s q for all other q qby the shortest path from c tov q. the diameter w.r.t.
a center cis defined as diameter c max q qmin v s q dist v c by the smallest diameter we hope the resultant subgraph involves very few dummy nodes that are not similar to any query phrase.
example .
let us reconsider the query qconsisting of short phrases q0 database connection q1 create sql statement and q2 get result .
for the api graph in figure given similarity threshold .
we compute the candidate match nodes for each phrase in qas s q0 s q1 s q2 therefore q0is the rarest phrase qrare with two candidate match nodes and .
for node the closest node in s q1 is any of nodes and with the same shortest distance of the closest node in s q2 is node and the shortest distance is .
thus diameter v0 according to eq.
.
similarly if we start from node the closest node in s q1 is node and the shortest distance is the closest node ins q2 is node and the shortest distance is .
thus diameter v9 .
therefore algorithm rf will pick node asc to form an api subgraph as it has the smallest diameter in s q0 .
node can also be regarded as the center of the subgraph.
next rf will arbitrarily choose any one of nodes and for q1as they have the same shortest distance of to node .
suppose node is selected and connected to node .
for q2 rf will choose node as it is the closest node ins q2 to node .
note that there are three shortest paths from node to node and .
suppose rf picks path as a shortest path from nodes to .
the resultant api subgraph is shown in figure a .
when compared with the optimum subgraph in figure b the solution of rf contains an extra node which is redundant to node as both of them match query phrase q1 create sql statement .
a solution of rf0 b optimum f igure the solution of greedy algorithm rf versus optimum solution for the query in figure .
selecting node with high textual similarity a problem of rf is that it considers any node v vgas a candidate match of a query phrase q as long as sim q v .
for all candidates in s q rf does not differentiate them according to the textual similarity however some of them may have higher similarity and some others have lower similarity.
in example rf selects node in the answer subgraph.
but sim q1 v2 .
which is lower thansim q1 v1 sim q1 v3 .
.
to address this problem we formally define a new node selection measure called localgain in definition .algorithm rarestfirst q g input query q api graph g vg eg similarity threshold output subgraph g g qrare s findsupport q g foreach c s qrare do foreach q qandq e atio slash qraredo rcq min v s q dist v c end rc max qrcq end7 c arg min rc g c path c v q q q v q arg min v s q dist v c return g procedure findsupport q g foreach q qdo s q v sim q v v vg end qrare arg min q q s q return qrare s q q q definition .
local gain given a center cand a query phrase q q for a candidate match node v s q the local gain gain l v q c of connecting vwithcis measured by eq.
.
gain l v q c sim q v dist v c where is the dummy node penalty.
given a fixed center c localgain prefers a node v s q having a high textual similarity with the phrase q and having a small distance to c. we add the dummy node penalty for flexibility.
with a lower or higher value of we give a lower or higher penalty for the distance dist v c between a node vand the center c. accordingly we propose an improved algorithm called rarestgainfirst rgf in algorithm which uses the localgain as the criterion to select the best node v froms q q qandq e atio slash qrare line .
then a shortest path path c v is added to the resultant subgraph to connect v toc.
example .
consider figure for the center node and q1 create sql statement gain l v1 q1 v0 gain l v3 q1 v0 .
gain l v2 q1 v0 .
for any value of .
thus rgf will select node or according to localgain .
moreover algorithm rf finds a subgraph with the smallest diameter according to eq.
.
however the subgraph with the smallest diameter does not necessarily have the highest gain defined in eq.
.
it is necessary to form a subgraph for each center node c s qrare and return the one with the highest gain.
therefore algorithm rgf searches a subgraph lcfor each center c s qrare .
finally the subgraph with the highest gain according to eq.
is returned as the answer lines .
.
handling multiple shortest paths problem algorithm rgf can find a better subgraph in terms of gain by selecting nodes with high textual similarity for each phrase.
however rgf still faces the problem of multiple shortest path i.e.
the shortest path between two nodes in a 4algorithm rarestgainfirst q g input query q api graph g vg eg similarity threshold node penalty output subgraph g g qrare s findsupport q g foreach c s qrare do lc foreach q qandq e atio slash qraredo v arg max v s q gain l v q c lc lc path c v end end8 l c arg max lcgain lc q return g l c graph is not unique.
consider the query qi n figure .
from the center node for the phrase q1 rgf may select node or as gain l v1 q1 v0 gain l v3 q1 v0 .
are the highest.
suppose node is selected and then node is connected to node .
next for q2 it will select node according to localgain .
however the shortest path path is not unique in figure .
as mentioned previously there are three shortest paths and all of which have the same distance of .
suppose rgf chooses path to add to the subgraph.
figure shows the resultant subgraph found by rgf.
this subgraph is less optimum as dashed node is redundant to node .
this is due to the multiple shortest path phenomenon when there are multiple shortest paths from a source node to a destination node an arbitrary one will be selected to add to the resultant subgraph.
if the pairwise shortest paths are pre computed and stored to support queries only one path between a pair of nodes will be retained.
it is hard to decide which shortest path should be stored among multiple choices because at the pre computation phase we know nothing about a query.
figure less optimum subgraph from rgf t o address the multiple shortest path problem we propose a refinement technique using steiner tree .
the steiner tree problem is to find a minimum weight tree connecting a given subset of nodes of a graph.
we name this refinement technique as localregionrefine lrr as shown in algorithm .
initially we start with a subgraph g returned by algorithm rgf line .
then from the node set vg we select a subset of nodes as vbest by including nodes with highest textual similarity to each phrase q q lines .
then we invoke the steinertree procedure to find a refined graph g line where vbestis the input as the set of necessary nodes for a steiner tree.
the graph can be refined as steinertree is multiple pathaware it always connects any covered node in vg to an uncovered necessary node in vo through a shortest path with the smallest distance.
example .
consider the graph g returned by rgf in figure .
necessary nodes are vbest from nodes .
node has a higher textual similarity than node .
vs. .
to the phrase q1 create sql statement so we choose node accordingly.
by feeding vbest to the steinertree procedure we can get an optimum subgraph as shown in figure b .
the refinement is possible because steinertree can tell that the shortest path path is shorter than path when adding path from the covered node to the uncovered necessary node to g. note that another possible necessary node set can be vbest as node has the same textual similarity .
as node .
in this case the refined graph should contain nodes which is essentially the same has the same gain as figure b .
algorithm localregionrefine q g input query q api graph g vg eg similarity threshold node penalty output subgraph g g g rarestgainfirst q g vbest foreach q qdo vq v v s q v vg v arg max v vqsim q v vbest vbest v end7 v arg min v vbest u vbest u negationslash vdist u v g steinertree vbest g v return g procedure steinertree vo g v vo vo v g v while vo e atio slash do u v arg min u vg v vodist u v ifpath u v e atio slash then g g path u v vo vo v end end return g .
class only path indexing o ur proposed approaches rely on online query of shortest distances and paths between two graph nodes.
the time complexity of single source shortest paths to all other destination nodes is o n m using breadth first search bfs for unweighted graphs and o nlogn m using dijkstra s algorithm implemented with fibonacci heaps for positive weighted graphs where nandmare the number of nodes and edges of a graph respectively.
in our application an api graph constructed from java se .
has a large n .
algorithm lrr needs to compute shortest paths and distances between many pairs of graph nodes before returning a resultant subgraph so online shortest path computation is not feasible given limited query response time for a large n. on the other extreme storing all pairs of shortest paths and distances in the main memory is not feasible given limited memory space as the space complexity is at least o n2 to index all pairwise shortest paths distances.
there have been numerous studies on approximate shortest distance estimation.
a representative approach is landmark embedding which pre computes and stores shortest distances or paths from a subset of graph nodes called 5landmarks t o every node in the graph .
during on line query an approximate shortest distance between two nodes uandvis obtained indirectly using triangular inequality by tildewidedist u v min w vldist u w dist w v where vlis the landmark set.
in general graphs the approximation can have an error bound on the estimated shortest distances .
although landmark embedding uses less indexing space than full path distance indexing this approximate distance estimation approach may affect the quality of the resultant graph in our problem as the estimated shortest distances and paths are not precise.
to design an effective scheme to index exact shortest distances paths instead of approximate ones we can have some observations from the api graph gin figure .
ghas two types of nodes classes c and methods m .
moreover there is no direct interaction between methods i.e.
the adjacent nodes of a method node must be class nodes.
therefore we propose to only index paths among class nodes in an api graph which is more space efficient and can support full recovery of exact shortest paths between any type of nodes.
note that shortest distance can be computed trivially from a shortest path.
.
three indexing structures figure class graph of figure f irst we construct a class graph gc vgc egc from the original api graph g vg eg .
the formal construction process is in definition .
figure shows the class graph of the api graph in figure .
definition .
class graph a class graph for an api graph g vg eg is a weighted undirected graph gc vgc egc where vgc v v vg v c and edgee u v egcforu v vgcwith an edge weight dist u v iff1 dist u v 2ing.
finally based on the class graph gc we construct three space efficient indexing structures .parent for every class node pair s d in the class graph parent stores the precedent node of don the shortest path from stod.
.adj a mapping from a method node m mto its adjacent hop neighbor class nodes.
.con a mapping from a hop class node pair o p to only one and any one of their in between connector method nodes if any .
here o p cand dist o p in the original api graph.
as the api graph is an undirected graph we only store con foro p according to their node ids.
con will be the same and thus not stored.
among the three indexing structures parent requires more memory space o c as it indexes the shortest paths between class nodes in cwith size of c .
as the number of classes is usually much smaller than that of methods in an api library our class only path indexing scheme ismore space efficient than path indexing on the original api graph full graph indexing .
example .
in the class graph in figure path .
so parent i.e.
the precedent node of is node on path .
some adj mappings include adj adj andadj .
some con mappings include con con andcon according to figure .
.
exact path recovery algorithm shows how to recover the exact path between two nodes.
there are three cases in path recovery between classes between method and class and between methods.
since the indexing is based on the class graph for any case we have to query con to add the connector method back to the actual path between two class nodes line .
for case if one of the two nodes is a method node denoted as v we use adj to map vto its adjacent class nodes as