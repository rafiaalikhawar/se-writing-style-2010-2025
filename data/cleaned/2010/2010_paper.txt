modeling the html dom and browser api in static analysis of javascript web applications simon holm jensen aarhus university simonhj cs.au.dkmagnus madsen aarhus university magnusm cs.au.dkanders m ller aarhus university amoeller cs.au.dk abstract developers of javascript web applications have little tool support for catching errors early in development.
in comparison an abundance of tools exist for statically typed languages including sophisticated integrated developme nt environments and specialized static analyses.
transferri ng such technologies to the domain of javascript web applications is challenging.
in this paper we discuss the challenges which include the dynamic aspects of javascript and the complex interactions between javascript html and the browser.
from this we present the first static analysis that is capable of reasoning about the flow of control and data in modern javascript applications that interact with the html dom and browser api.
one application of such a static analysis is to detect typerelated anddataflow related programmingerrors.
wereport on experiments with a range of modern web applications including chrome experiments and ie test drive applications to measure the precision and performance of the technique.
the experiments indicate that the analysis is able to show absence of errors related to missing object properties and to identify dead and unreachable code.
by measuring the precision of the types inferred for object properties t he analysis is precise enough to show that most expressions have unique types.
by also producing precise call graphs the analysis additionally shows that most invocations in th e programs are monomorphic.
we furthermore study the usefulness of the analysis to detect spelling errors in the code .
despite the encouraging results not all problems are solve d and some of the experiments indicate a potential for improvement which allows us to identify central remaining challenges and outline directions for future work.
categories andsubject descriptors d. .
testing and debugging general terms languages algorithms verification supportedbythe danish research council for technology and production grant no.
.
permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
copyright 20xx acm x xxxxx xx x xx xx ... .
.
.
introduction a javascript web application is in essence an html page with javascript code and other resources such as css stylesheets and image files.
program execution is driven by events in the user s browser the page is initially loaded t he user interacts with the mouse and keyboard timeouts occur ajax response messages are received from the server etc.
the event handler code reacts by modifying the program state and the html page via its dom document object model and by interacting with the browser api for example to register new event handlers.
compared to other software platforms the state of the art in development of such web applications is rather primitive which makes it difficul t to write and maintain robust applications.
statically type d languages such as java and c have long benefited from advancedidesandstaticanalysis techniqueswithrichcapa bilities oflocating likely programmingerrors duringdeve lopment.
examples ofsuchtools include eclipse visual studio findbugs and klocwork.
in contrast existing tool support for javascript web application development is mostly limited to syntax highlighting and primitive code completion in ides such as eclipse netbeans and visual studio often combined with record play testing frameworks such as selenium watir and sahi.
the goal of our research is to develop static program analysis techniques that can detect or show absence of potential programming errors in javascript web applications.
we focus on general errors that can be detected without the use of application specific code annotations.
examples of such errors are dead or unreachable code which often indicates unintended behavior calls to built in functions with a wrong number of arguments or with arguments of unexpected types and uses of the special javascript value undefined which appears when attempting to read a missing object property at dereferences or at function calls.
the existence of the undefined value and implicit type coercions in the language means that even minor spelling errors for example in a property name often has surprising consequences at runtime.
with statically typed languages the type systems provide a strong foundation for detecting such errors.
in contrast because of the dynamic natureof javascriptweb application code our analysis mus t be capable of reasoning about the flow of control and data throughout the applications.
we strive to make the analysis sound meaning that all control flow and dataflow that is possible in the program being analyzed is captured by the analysis such that guarantees can be made about absence of errors.
also it mustbe sufficiently preciseandfastsuch that the user is not overwhelmed with spurious warnings and that the analysis can be integrated into the development cycle.
as an example figure shows excerpts from a modern javascript web application.
if one wants to detect or show absence oferrors ofthekindsdiscussedabove astatic anal ysis must reason about the subtle flow of control and data between thejavascript code the html code and thebrowser event system as explained in the figure text.
tajs is a program analysis tool for javascript .
to this point tajs has been developed to faithfully model the javascript language and the core library as specified in the ecmascript standard .
most real javascript programs however exist in the context of an html page and operate in browsers where they access the html dom and the browser api which causes considerable challenges to the analysis of the flow of control and data .
we now take the step of extending tajs to also model these aspects of javascript web applications.
in summary the contributions of this paper are the following we discuss the key challenges section and suggest an approach toward modeling the javascript web application platform in static analysis section .
in particular this involves considerations about modeling the html pages and the event system.
we show how the tajs analysis section .
can be extended to accommodate for the html dom and the browser api.
as result we obtain the first static analysistool thatiscapableofreasoningabouttheflow of control and data in javascript web applications.
through experimental evaluation we demonstrate that our model is sufficient to show absence of errors and to detect dead and unreachable code.
in addition we evaluate the precision of the types and call graphs inferredbytheanalysis section5 .
weidentifystrengths and weaknesses of the approaches we have taken and suggest directions for future work section .
several program analysis tools and techniques for javascript have been developed however non e of them provide a detailed model of the html dom and the browser api although all javascript web applications utilize those mechanisms.
we describe connections to related work in section .
.
challenges we begin with a brief tour of the technologies involved and explain the central challenges that exist when developing static analyses for javascript web applications.
experienced javascript programmers who are used to reasoning manually about the behavior of their programs will recognize the issues brought forth here.
.
the javascriptlanguage the first obstacle we face is the javascript language itself.
javascript has higher order functions and closures exceptions extensive type coercion rules and a flexible obje ct model where methods and fields can be added or change types and inheritance relations can be modified during execution.
as shown by richards et al.
commonly made in the research literature about javascript pr ograms are often violated by the code actually being written by programmers and javascript is described as a harsh terrain for static analysis .
implementations largely follow the ecmascript standard however there are subtle deviations.
one such example is that many browsers for performance reasons do not implement the specified behavior of deleting properties of thearguments object as indelete arguments .
another example is that many browsers for security reasons do not correctly invoke the currently defined objectfunction when constructing objects from literals as in x .
other peculiar javascript features and incompatibility issues a re discussed in the paper on javascript semantics by maffeis et al.
.
one choice we must make is whether to model the standard or one or more of the existingimplementations.
we return to this issue in section .
on top of the language ecmascript contains a standard library consisting of functions and other objects that all need to be modeled somehow by any tool that analyzes javascript web applications.
of particular interest is the evalfunction and its variant function that allow dynamic construction of program code from text strings.
reasoning statically about the behavior of such code obviously requir es knowledgeaboutwhichstringsmayappear.
evenso studies of how these constructs are used in practice indicate that many cases are amenable to static analysis .
for now we focus on the 3rd edition of ecmascript ecma which is currently the most widely used version.
supporting the more recent 5th edition requires the analysis to also reason about getters and setters sealed an d frozen objects stronger reflection capabilities and the s ocalled strict mode semantics in addition to a range of new standard library functions.
.
the html domandbrowser api the browser environment gives rise to additional challenges.
the javascript representation of html documents css properties and the event system is specified by the w3c dom standards2.
the html5 specification is currently being developed bythe whatwg group3.
together these specifications contribute additional hundreds of fun ctions and other objects to the program state.
it is well known to all web application programmers that browsers do not adhere to these standards.
browsers provide nonstandard functionality and many standard features are not supported4.
in particular the event systems differ between browsers.
another problem is that no standard exists for thewindowobject that acts as the global javascript object.
incompatibilities in the underlying javascript interpret ers mostly involve subtle corner cases in the language as discussed above and often go unnoticed by the programmers.
in contrast incompatibilities in the browser environment s are a major concern.
when developing a program analysis we need to choose which of these variations to model.
a typical workaround is seen in the following function addevent from the google chrome experiment tetris5.
head script type text javascript 4window.p3d 5texture null 6g null 9p3d.clear function f w h 10var g this.g 11g.beginpath 12g.fillstyle f 13g.fillrect w h 16function touchapp 17var this this 19this.canvas document.getelementbyid cv 20p3d.g this.canvas.getcontext 2d ... 23this.mviewport 24this.mviewport.w 25this.mviewport.h ... 28var tex new image 29this.ipod.texture tex 30tex.onload function this.start 31tex.src .png ... 35touchapp.prototype 36start function ... 38this.oninterval 41oninterval function ... 43p3d.clear this.mviewport.w this.mviewport.h ... 47settimeout function 48 this.oninterval ... ... script head body onload void new touchapp canvas id cv width height ... body html the code at the left is an excerpt from the google chrome exper imentjs touch where ...indicates omitted code .
it displays a 3d model of an iphone and allows the user to interact with it by mo ving the mouse.
the application is written in pure javascript and uses the new html5 canvasobject.
obviously many things could go wrong when programming such an application.
three examples of correctness properties t hat the programmer may consider are is the parameter gon line always an object with a beginpath function?
if not a runtime error will occur when that line is executed.
in the call to the fu nction fillrect on line are the arguments always numeric?
if not the function call will not have the desired effect.
is the func tion p3d.clear on line reachable in some execution?
if not presumably there is an error in the control flow.
to catch such errors or to show their absence a static analy sis must know about the flow of control and data in the program.
in brief the browser first loads the html page and executes the t oplevel javascript code and loadevent handlers.
it then executes other event handlers for user input timeouts and other events th at occur.
in this example application the code on line in the onload attribute of the bodyelement creates a new touchapp object and invokes its constructor function defined on line .
this fun ction looks up the javascript dom object representing the can vas element on line and then stores a reference to its associat ed canvasrenderingcontext2d in thegproperty of thep3dobject on line .
note that p3dis a globally available object.
next on line the constructor function creates a new imageobject sets itsloadevent handler to the startfunction and finally sets its src property.
the browser loads the requested image and fires the load handler.
thestartfunction defined on line does some work and then invokes the oninterval function.
this function defined on line calls p3d.clear with appropriate arguments taken from thethis.mviewport object.
finally using a call to settimeout it registers itself to be invoked by the browser 20ms later.
by automating this kind of reasoning a static analysis can d etect likely errors in the application code.
analyzing a complex j avascript program such as this one requires a precise model of the jav ascript language the html dom and the browser api.
for this application our analysis tool is capable of showing in seconds a mong many other properties that the variable gdoes always hold an object with abeginpath function the fillrect function is always called with numeric arguments and the function p3d.clear is likely to be reachable.
in addition the analysis reports th at .
of all property access operations are guaranteed free from typeerror exceptions caused by dereferencing undefined ornulland that all calls to browser api functions are given arguments of meaningful t ypes.
more statistics for the unabridged experiment is in section .
figure excerpts from the google chrome experiment js touch1.
function addevent el event handler if el.addeventlistener el.addeventlistener event handler false else if el.attachevent el.attachevent on event handler reasoning statically about the behavior of such code requires not only modeling of different browsers but also flow sensitivity i.e.
taking statement order into account and even path sensitivity i.e.
considering the branch conditi ons to see that the calls to addeventlistener andattachevent do not causetypeerror exceptions.since all execution is driven by events the analysis must also model the event system which includes the dynamic registration and removal of different kinds of event handler s as in theaddevent function above the event bubbling and capturing mechanism and the event object properties that depend on the specific kind of event.
the event handlers work as callbacks which often leads to fragmented code with unclear flow of control that the static analysis must resolve.
a small example is seen in the chrome experiment aquarium6 abbreviated for presentation mmouse event mousex event.pagex mousey event.pagey function work var dx mousex pesti .x var dy mousey pesti .y ... setinterval work the functionmmouse which is elsewhere registered as an event handler stores information about the event in two global variables mousexandmousey that are read in another event handler work.
unless these two variables are properly initialized dxanddywill get the special value nan if theworkfunction happens to be triggered before mmouse which will likely result in an error later in the execution.
foreventhandlersdefinedashtmlattributes thehtml documentstructureinterfereswiththeexecutionscopecha ins that are used when resolving variables.
if an event handler defined literally as an attribute in an html element is triggered the scope chain includes all the dom objects that make up the path from the html element to the root of the document.
this means that dataflow in the javascript code in general cannot be analyzed separately from the html code.
the following example illustrates this mechanism script type text javascript var src foo.png script img src bar.png onclick alert src the value ofsrcinside theonclick event handler is that of thesrcattribute of theimgelement notfoo.png as one might have expected.
many properties in the ecmascript native objects have special attributes such as readonly which also must be accounted for unless sacrificing either soundness or precision.
likewise many dom objects behave differently from ordinary objects.
as an example a new formelement is created withdocument.createelement form not withnew htmlformelement although allformelements inherit from htmlformelement.prototype .
besides the extent and the variations of browser environments other concerns when developing a static analysis too l relate to the prevalence of nontrivial built in setters th at is assignment operations that involve complex conversions or otherside effects.
forexample writingtothe onclick propertyofanhtmlelementobject causesastringtobetreated as event handler code.
another example is the use of value correspondence where html element attributes are represented in multiple javascript objects.
for instance the src attribute value of an imgelement appears both directly as a property of theimgelement object and indirectly as a property of an object that can be reached via the attributes property of theimgelement object.
these are essentially aliases although the former is always an absolute url even when the latter is a relative url and modifications to one also affect the other much like the connection between ordinary javascript function parameters and the arguments object.
consider also the window.location property which holds alocation object.
assigning a new url string to this property causes the browser to go to that url after the current event handler and various unload handlers have been executed.
as yet another example writing a string to the also nonstandard but widely used innerhtml property of an element object causes thestring tobe parsed as htmland converted to a dom object structure which then replaces the element contents.
a related issue is the element lookup mechanism which provides support for getelementbyid and related functions.
ifan element with an idattribute is inserted into thehtml document itisautomatically addedtothebrowser s elemen t id table for quick lookup.
similarly documents.images automatically contains