scalable and precise symbolic analysis for atomicity violations malay k. ganai nec labs america princeton usa malay nec labs.com abstract we present a symbolic testing tool best for finding atomicity violations.
we automatically infer and gener ate potential atomicity properties from an observed run of a mul tithreaded program and use precise modeling and constraintbased symbolic search to find atomicity violating schedules in the most generalization of the observed run.
we focus mainly on t he tool scalability by devising various simplification steps t o reduce theformula andthe search space byorders of magnitude.to that effect we also introduce a new notion of atomicity that is us eful and simple to check.
we demonstrate the effectiveness of the combined techniques on several public c c java benchmar ks in finding known unknown atomicity bugs.
i. introduction the growth of cheap and ubiquitous multi processor systems and concurrent library support are making concurrent programming very attractive.
however verification of mult ithreaded concurrent systems remains a daunting task especially due to complex and unexpected interactions between asynchronous threads.
concurrencybugsoftenariseduetoatomicityviolation i. e. non atomic execution of code regions that are intended to be atomic.
atomicity is a semantic correctness of the concurre nt programs and is meant to capturethe programmersintention s. a recent study of real concurrency bugs depicts the following distribution order violation deadlo cks and atomicity violation .
on one hand atomicity violation is one of the most commonly occurring causes for concurrency related failures and on the other hand it is one of the hardest correctness criteria to infer or specify prec isely as it requires guessing user intentions.
in this paper we focus specifically on finding and checking atomicity violation.
there have been efforts in the past to specify atomicity violation conditions concisely althou gh for specific notions of atomicity such as method atomicity view conflict atomicity atomic set atomicity commit atomicity and causal atomicity .
in a set of eleven data access scenarios interleavings over singl e and dual variables have been identified that completely specif y atomic set atomicity violation.
even with marked atomic boundaries checking atomicity violation is a challenging task due to a large interleavin g search space b non trivial violation condition that may involve multiple variable shared accesses and multiple in terleavings and c various notions of atomicity.
the same bug study shows that of the examined non deadlock concurrency bugs involve multiple variables and remainin g concurrencybugs involvesingle variable.although som eefforts were made there are still no good tools to address such multi variable atomicity bugs.
to expose a concurrency bug a test case should not only provideabug exposinginput butalsoprovideabug trigge ring execution interleaving.
unfortunately testing a program for every interleaving on every test input is often practically impossible.
even for a given concrete trace there can be exponentiallymanyalternateinterleavings i.e.
genera lization of the observed events in the trace.
to overcome the issue of exponential interleaving space the current testing methodology is focused on exploring a meaningful subset of thread interleaving for a given test input.
tools such as atomfuzzer ctrigger attempt to explore low probability interleavings using random sle ep delays.
although that helps reduce the set the unexplored s et may still be exponential and may include many errors.
to overcome the issue tools such as jpredictor have and penelope predict atomicity violation in a generalization of the observedtrace.
however the used generaliza tion is too restrictive i.e.
may miss errors predictionis im precise i.e.
may predict spurious schedules due to data abstracti on and search method is enumerative.
to address the above mentioned issues we propose a tool best b inary instrumentation based e rror directed s ymbolic testing for finding atomicity violation in the most generalization of an observed trace.
specifically it misses no errors by using a complete generalization reduces spurious schedules using precise modeling of data and synchronization primitives predictsatomicityviolationbasedon constraint basedsymbolic non enumerative search handles various notions of atomicity infers atomicity properties automatically and dynamically instruments unmodified binary of the program for recording events and does not rely on source code availability.
best framework overview the main components of the framework as shown in figure are divided in four stages i record trace events and build a concurrent trace model ctm ii simplify ctm by reducing transitions and context switches iii inf er and generate atomicity properties and iv find atomicity violation with property specific symbolic analysis.
.
c ieee ase lawrence ks usa123 g28 g121 g28 g18 g104 g100 g28 g4 g69 g24 g90 g28 g18 g75 g90 g24 g17 g104 g47 g62 g24 g18 g75 g69 g18 g104 g90 g90 g28 g69 g100 g100 g90 g4 g18 g28 g68 g75 g24 g28 g62 g894 g18 g100 g68 g895 g38 g47 g69 g24 g4 g115 g894 g24 g28 g18 g47 g94 g47 g75 g69 g87 g90 g75 g18 g28 g24 g104 g90 g28 g895 g39 g28 g69 g28 g90 g4 g100 g28 g4 g115 g3 g94 g18 g44 g28 g24 g104 g62 g28 g94 g28 g69 g18 g75 g24 g28 g87 g90 g75 g87 g28 g90 g100 g122 g4 g115 g3 g18 g75 g69 g24 g47 g100 g47 g75 g69 g94 g28 g69 g18 g75 g24 g28 g94 g18 g44 g28 g24 g104 g62 g28 g94 g38 g28 g4 g94 g47 g17 g62 g28 g1085 g3 g90 g28 g87 g90 g28 g94 g28 g69 g100 g4 g100 g47 g115 g28 g100 g4 g90 g39 g28 g100 g17 g47 g69 g4 g90 g122 g920 g100 g28 g94 g100 g44 g4 g90 g69 g28 g94 g94 g68 g28 g90 g39 g28 g68 g28 g90 g39 g28 g62 g75 g18 g4 g62 g100 g90 g4 g69 g94 g47 g100 g47 g75 g69 g94 g62 g75 g18 g60 g94 g28 g100 g920 g3 g44 g17 g3 g4 g69 g4 g62 g122 g94 g47 g94 g28 g62 g47 g68 g47 g69 g4 g100 g28 g47 g69 g38 g28 g4 g94 g47 g17 g62 g28 g18 g75 g69 g100 g28 g121 g100 g94 g116 g47 g100 g18 g44 g28 g94 g87 g75 g90 g3 g4 g69 g4 g62 g122 g94 g47 g94 g28 g62 g47 g68 g47 g69 g4 g100 g28 g90 g28 g24 g104 g69 g24 g4 g69 g100 g18 g75 g69 g100 g28 g121 g100 g94 g116 g47 g100 g18 g44 g28 g94 g47 g69 g38 g28 g90 g4 g100 g75 g68 g47 g18 g90 g28 g39 g47 g75 g69 g94 g104 g94 g28 g24 g28 g17 g104 g39 g47 g69 g38 g75 g856 g3 g894 g75 g17 g58 g24 g104 g68 g87 g895 g104 g94 g28 g94 g75 g104 g90 g18 g28 g882 g62 g47 g69 g28 g87 g90 g75 g121 g47 g68 g47 g100 g122 g87 g90 g104 g69 g28 g4 g100 g75 g68 g47 g18 g90 g28 g39 g47 g75 g69 g94 g90 g28 g68 g75 g115 g28 g493 g493 g87 g90 g75 g115 g28 g24 g859 g859 g3 g4 g100 g75 g68 g47 g18 g90 g28 g68 g75 g115 g28 g493 g493 g75 g17 g94 g28 g90 g115 g28 g24 g859 g859 g3 g69 g75 g69 g882 g4 g100 g75 g68 g47 g18 g39 g28 g69 g28 g90 g4 g100 g28 g4 g100 g75 g68 g47 g18 g47 g100 g122 g87 g90 g75 g87 g28 g90 g100 g47 g28 g94 g18 g4 g104 g94 g4 g62 g4 g100 g75 g68 g47 g18 g47 g100 g122 g894 g18 g4 g895 g3 g853 g3 g75 g90 g18 g4 g104 g94 g4 g62 g68 g104 g100 g104 g4 g62 g4 g100 g75 g68 g47 g18 g47 g100 g122 g894 g18 g68 g4 g895 g94 g28 g62 g28 g18 g100 g4 g69 g4 g100 g75 g68 g47 g18 g47 g100 g122 g87 g90 g75 g87 g28 g90 g100 g122 g87 g90 g75 g87 g28 g90 g100 g122 g94 g62 g47 g18 g47 g69 g39 g68 g28 g90 g39 g28 g894 g87 g28 g90 g87 g90 g75 g87 g28 g90 g100 g122 g895 g87 g75 g90 g3 g4 g69 g4 g62 g122 g94 g47 g94 g894 g87 g28 g90 g87 g90 g75 g87 g28 g90 g100 g122 g895 g94 g100 g4 g39 g28 g47 g47 g855 g3 g94 g47 g68 g87 g62 g47 g38 g122 g18 g100 g68 g94 g100 g4 g39 g28 g47 g47 g47 g855 g3 g47 g69 g38 g28 g90 g90 g47 g69 g39 g4 g100 g75 g68 g47 g18 g47 g100 g122 g94 g87 g28 g18 g47 g38 g47 g18 g4 g100 g47 g75 g69 g94 g100 g4 g39 g28 g47 g115 g855 g3 g87 g90 g75 g87 g28 g90 g100 g122 g882 g94 g87 g28 g18 g47 g38 g47 g18 g94 g122 g68 g17 g75 g62 g47 g18 g4 g69 g4 g62 g122 g94 g47 g94 g87 g90 g75 g87 g28 g90 g100 g122 g882 g94 g87 g28 g18 g47 g38 g47 g18 g94 g47 g68 g87 g62 g47 g38 g47 g18 g4 g100 g47 g75 g69 g28 g69 g18 g75 g24 g28 g920 g3 g94 g75 g62 g115 g28 g116 g47 g100 g69 g28 g94 g94 g115 g47 g28 g116 g28 g90 g894 g44 g100 g68 g62 g895 g94 g100 g4 g39 g28 g47 g855 g3 g100 g90 g4 g18 g28 g39 g28 g69 g28 g90 g4 g62 g47 g127 g4 g100 g47 g75 g69 g4 g115 g3 g94 g18 g44 g28 g24 g104 g62 g28 g94 g90 g28 g87 g62 g4 g122 g94 g100 g4 g39 g28 g115 g855 g3 g24 g28 g17 g104 g39 g100 g90 g4 g18 g28 g94 fig.
.
best architecture stage i. during an execution of a multi threaded program under a test harness we instrument the binary dynamically using pin to record various events such as synchronization and memory accesses.
from these recorded events we construct a concurrent trace model ctm .
such a model can be viewed as generalizer of the observed trace.
for practical reasons we do not record all local accesses such as stack reads writes.
in such cases ctm would bean abstractionof the actualprogramexecution.
stage ii.
we perform following steps to simplify ctm.
we firstidentifylocal i.e.
unshared variablesandmergeth elocal transitions.
this step gives a reduction of up to 3x in the number of transitions.
we use lockset and happen before hb analysis to identify the lock protected transitions and causal transitions such as fork join and eliminate infeasible context switches.
thi s step gives a reduction of up to two orders of magnitude in the number of context switches.
we then use a por analysis to eliminate context switches corresponding to redundant interleavings i.e.
which are equivalent to admitted interleavings.
this step g ives up to three orders of magnitude additional reduction in th e number of context switches over lockset hb analysis.
stage iii .
on a simplified ctm we infer atomic regions that may involve multiple variable accesses based on code layou t. we prune out those regions which are observed to be not conflict serializable in the given trace and those which are proved atomic using stage ii results .
from the remainin g regions we derive atomicity properties.
we introduce causal mutual atomicity cma which is found to be more useful in finding more violations and simpler to check more scalable than the other notions such as causal atomicity ca .
stage iv.
for each derived atomicity property ca or cma we first carry out property preserving i.e.
sound slicing of the ctm obtained in stage ii .
this is followed by soundsimplification steps such as merging and por analysis on the sliced ctm.
these steps give additional orders of magnitu de reduction in the number of context switches more for a cma than a ca property .
we devise an algorithm findav for finding and checking atomicity violation av precisely.
for a given atomicity property we encode the av condition along with a symbolic set of schedules feasible in the sliced ctm in a quantifierfree smt satisfiability modulo theory decision problem.
we use a soundandcomplete decision procedure to find a feasible schedule violating the atomicity property i.e.
if and only ifone exists in the sliced ctm w.r.t.
the property.
as ctm is abstraction of the actual program execution the av schedules although feasible in ctm may be spurious i.e.
not replayable.
currently we suppress reporting suc h spurious schedules 1although we did not see such a case in our experimentation due to precise modeling .
contributions .
although several runtime tools for predicting atomicity violation exists namely jpredictor have sidetrack ctrigger and penelope our tool provides a unique combination of the following generalization our scope of generalization is complete.
there is no restriction on admitted schedules such as nested locking race freedom and matched wait notify.
precision ourmodelingofsynchronizationanddatapath variables is precise.
our symbolic encoding captures all and only feasible schedules.
scalability our por based simplification steps reduces both the size of decision problems and the search space by orders of magnitude.
our prediction is based on constraint based symbolic search and avoids explicit enumeration of a prohibitively large set of schedules.
flexibility our atomicity checking algorithm handles various notions of atomicity violation.
evaluation .
we evaluate various reduction strategies enabling 1alternately one can re execute the binary with the non rep layable av schedule build a different ctm and then apply stages i iv.
we keep these as a future extension to our work.124the scalability of the symbolic analysis.
we also evaluate t he combined effect of formula size simplification interleavi ng space reduction new notion of atomicity and decision proc edure in finding atomicity bugs.
ii.
relatedwork runtime concurrency testing techniques can be broadly classified into fuzzing based and tracebased predictive analysis .
fuzzing based tools such as atomfuzzer and ctrigger focus on improvingthe interleaving coverageof som e meaningful set.
specific instances of atomicity such as are integrated into a test harness as monitors.
the goal is to trigger the bug monitor by explicitly searching over the interleaving space either exhaustively or using random s leep delays between atomic accesses and or synchronization poi nts that have low probability of being interleaved.
the trace based predictive analysis tools detect and predi ct program errors from an observed trace either using offline search or using online analysis .
the trace based predictive tools such as have and penelope suffer from generating many false warnings due to abstraction of program data and imprecise handling of synchronization primitives such as semaphores.
some other predictive tools such as jpredictor and sidetrack can miss real violations due to restricted generalization res tricted to causal models of the observed trace.
besides these anal ysis do not produce a concrete execution exhibiting a violation.
precise runtime analysis overcome above mentioned issues by searching for violations in all feasible in terleavings of the observed trace and thereby report a tru e violation if and only if one exists.
the main focus is to reduc e false alarms although at increased complexity.
there are tw o types of precise runtime analysis used for finding concurren cy bugs i.e.
exploration based non symbolic runtime ana lysis such as dynamic model checking and satisfiability bas ed symbolic analysis .
in dynamicmodel checking for a given test input systematic exploration of a program under all possible thre ad interleavings is performed by explicit execution.
althoug h partial order reduction techniques por reduce the se t of necessary interleavings to explore the reduced set ofte n remains prohibitively large.
trace based symbolic approaches such as use smtbased encoding and precise modeling of trace events.
these approaches were demonstrated over short traces not beyond a few hundred trace events.
we compare our tool vis a vis a few representative runtime tools foratomicityviolationassummarizedintab lei.
outline the rest of the paper is outlined as follows.
in section iii we provide necessary backgroundand used notation s. in section iv we present ctm and trace generalization.
we discuss automatic inference of atomic regions in section v introduce causal mutual atomicity and generation of atomic ity properties in section vi and por based simplification in section vii.
we discuss findav algorithm in section viii followed by experiments in section ix and conclusion in section x. iii.
background a multi threaded concurrent program pcomprises a set of nthreads and a set of shared variables some of which such as locks are used for synchronization.
let mi i n denote a thread represented by a control and data flow graph of the sequential program it executes.
for each mi letvibe a set of local variables cibe a set of control states and pci denote its thread program counter taking values from ci.
let vbe a set of global shared variables.
let sbe the set of global states of the system where a state s sis a valuation of all local and global variables and thread program counte rs.
athreadtransition tisa4 tuple an bracketle tc g u c an bracketri htthatcorresponds to a thread mi where c c cirepresent the control states of mi gis an enabling condition or guard defined on vi v anduis a set of update assignments of the form v exp where variable vand variables in expression expbelong to the set vi v. let tid t denote the corresponding thread of the transition t. we assume each transition tis atomic i.e.
uninterruptible.
aschedule of the concurrent program pis an interleaving sequence of thread transitions t1 tk.
an event eoccurs when a unique transition tis fired which we refer to as the generator for that event and denote it as t gen p e .
arun or concrete trace e1 ekof a concurrent program pis an ordered sequence of events where an event eicorresponds to firing of a unique transition ti gen p ei .
firing of generator transitions may correspond to instances of the sa me thread transition when fired in a thread loop.
in the sequel w e use a thread transition to refer to such an instance.
given a run e1 ekfor a program pwe say eihappens before ej denoted as ei ejifi j. let t gen p e andt gen p e .
we say t t iffe e .
for some ife e andtid t tid t we say e poe andt pot i.e.
the events and the transitions are in thread program order .
if t t always and tid t ne ationslash tid t we refer to such a relation as must happen before or must hb in short and denote it as t hbt .
we observe such musthb relation during fork join.
in the sequel we restrict the use of must hb relation to inter thread events transitions on ly.
dependency relation d given a set tof transitions we say a pair of transitions t t t tis dependent i.e.
t t diff one of the following holds a t pot b t hbt c t t is conflicting i.e.
accesses are on the sameglobalvariable andatleast oneofthemisawriteacces s. if t t ne ationslash d we say the pair is independent .
equivalency relation we say two schedules 1 t1 ti ti tnand 2 t1 ti ti tnare equivalent if ti ti ne ationslash d. an equivalence class of schedules can be obtained by iteratively swapping the consecutive independ ent transitions in a given schedule.
a representative schedule refers to one of such an equivalence class.
atransaction is an uninterrupted sequence of transitions of a particular thread as observed in a system execution.
we saya transaction ofa thread is atomicw.r.t.a schedule if the corresponding sequence of transitions are executed125table i comparing tools for predicting atomicity violations features jpredictor have sidetrack ctrigger penelope best this work icse fase padtad asplos fse language java java java c c java c c java instrumentation bytecode source bytecode dynamic binary bytecode dynamic binary prediction offline offline online online offline offline generalization scopewithin causal runs.
beyond unobserved runs.within causal runs race free programslow probability unexplored interleavings.beyond causal runs incomplete .beyond causal runs complete .
atomicity property11 access patterns single dual vars conflict atomicity pattern used is thread acquires same lock twice within a transaction.
access patterns single var with inferred low probability of occurrences.
access patterns single var .causal causalmutual atomicity infers atomic regions automatically .
schedule generationall causal schedules are explicitly generated with data abstraction and are tested with monitors.static summary information are used to speculate executions which are analyzed for potential violation.runtime information is used and analyzed for feasible violation.random time delays are inserted to explore low probability interleaving.potential violating schedules are generated assuming nested locking with data abstraction.potential violating schedules are generated using a decision procedure with precise modeling.
false negative miss error in generalization ?yes.
causal model is too restrictive.no.
yes.
causal model is too restrictive.yes.
search is ad hoc and is based on random delays at chosen locations.no assuming matched wait notify nested locking no.
false positive spurious generated?yes.
due to partial recording and data abstraction.yes.
due to overapprox.
static summary of schedules.no.
no.
yes due to partial recording and data abstraction.yes due to partial recording but fewer occurrences due to precise modeling.
inherent limitationexplicit enumeration data abstractiondata abstraction no replay able schedules.limited generalization assumes race freedom no semaphores.hit and trial not systematic.nested locking no semaphores data abstraction.size of decision problem.
uninterrupted in the schedule i.e.
without an interleavi ng context switch of another thread in between.
when a transaction is expected specified explicitly or inferred implicitly to be executed by a thread atomically we refer to it as an e transaction.
we use to denote the beginning and ending of an e transaction.
for example denote an e transaction starting with transition ti and ending with transition tj and including all transitions tk s such that ti potk potj.
for a given set of schedules if a transaction is atomic w.r.t .
all the schedules in the set we refer to it as an independent transaction denoted as i transaction w.r.t.
the set.
ageneralization of an observed trace is defined as a set of schedules with the same events as the observed trace but with relaxed i.e.
re ordered inter thread event order.
iv.
concurrent tracemodel before we proceed further we present an example to guide the rest of our discussion.
consider a run of statement sequence s1 s16of a concurrent program p comprising interacting threads maandmbwith local variables aiand bi respectively and shared global data variables x y z and synchronization variables s l l2.
this is shown in figure a where threads are synchronized with lock unlock andwait notify .
from the run we obtain a ctm as shown in figure b where a thread transition such as 2a true z z 3a also represented as 2az z 3a can be viewed as a generator of access event rw z corresponding to the atomic read and write access of the shared variable z. we model each synchronizationtransition as indicated in tabl e ii.
2i transactions correspond to the observation of the system which may not correspond to the user intended e transactions.
note e transactions are atomicity specification that we want to validate whereas i transactions are derived from the given system under test and are used to redu ce the search space of symbolic analysis.forwait s l statement we use the semantically equivalent consecutive transitions wait pre s l and wait pst s l .
a ctm can be viewed as a generalizer of the observed trace.
alternatively it is a generator for both the original run and all the other runs obtained by interleaving the generato r transitions t t of the respective events of provided t pot ort hbt .
in the sequel we use the terms ctm generator andgeneralizer interchangeably.
table ii modeling of synchronization primitives sync.
transition primitives guard update lock l l l unlock l l l wait pre s l l l s wait pst s l l s 0l s s notify s true s notifyall s true s n sem post p true p p sem wait p p p p trace generalization .
the lattice in figure c represents a complete generalization of the observed trace.
each node i n the lattice denotes a global control state shown as a pair of the thread local control states.
an edge denotes a shared eve nt write read both access es of global variable labeled wi th w .
r .
rw .
lock .
unlock .
andwait notify .
note some interleavings are infeasible due to lock unlock which we crossed out in the figure.
although the observed run does not show any violation various concurrency related bugs such as deadlock mismatc h wait notify data races and atomicity violation can occur in its generalization.
for example an alternate run 1 s6 s8 s1 s2 s12 s13 s3causes mismatched wait notify and data race and atomicity violation as we see later .
another run126thread ma thread mb s1 lock l2 s2 a z s3 x malloc a s4 lock l1 s5 wait s l s6 lock l1 s7 notify s s8 unlock l1 s9 unlock l2 s10 y s11 unlock l1 s12 lock l1 s13 y x s14 lock l2 s15 unlock l2 s16 unlock l1 lock l2 1a 2a 3a 4a 5a1b 2b 3b 4b 5bz z a1 z x malloc a1 lock l1 lock l1 unlock l1 lock l1 s 6a 7a 8aunlock l1 s g lock l1 s s 9a 10aunlock l2 y 11a6bb1 z b2 x 7b 8by b1 b2 9block l2 10bunlock l2 11bunlock l1 unlock l1 waitpre waitpst atomic intendednotify atomic intendedta1 ta2 ta3 ta4tb1 tb2 tb3 tb4 a b c fig.
.
a executed statements in a run b concurrent trace model ctm c lattice representin g generalization of the trace 2 s1 s8 s12 s13leads to a deadlockat control state pair 7a 8b as shown by the square box in the lattice.
deadlock at 5a 8b can also occur due to a mismatched wait notify.
happen before causality analysis do not admit all the feasible schedules in the lattice and ther efore leads to an incomplete generalization i.e.
can miss real errors .
the generalized model in admits only schedules where the inter thread events have the same causa l order as in the observed trace i.e.
the same conflicting read write order.
for the runningexample all but schedules are rejected and therefore all the errors are missed.
the generalization used in although admits non cau sal runs it rejects schedules with mismatched wait notify suc h as 1. the deadlock at 5a 8b is also missed.
a caveat in using a complete generalization is inclusion of infeasible schedules.
in our approach however we use precise symbolic encoding that admits all and only schedules of the generalization that are feasible in the ctm.
merging and slicing .
if a transitions thas no shared access wemergeitwith thefollowingtransitioninthethreadprogr am order and rewrite the update expressions.
we apply this transformation recursively to obtain a merged ctm.
givenaproperty andactm weobtainasoundslice i.e.
property preserving that includes all the property transitions i.e.
transitions relevant to the property and all the relevant transitions i.e.
transitions on which the property transitions depends transitively as follows if a transition tis in the slice t is included3in the slice provided t pot and tis control or data dependent on t or t hbt inter thread happens before or 3weinclude only therelevant guarded and updateexpressions ofatransition when we say a transition is included in the slice.
t tare conflicting different thread transitions and t must not happen before t i.e.
t ne ationslash hbt .
these steps are applied recursively followed by merging of transitions that have no accesses or have only local accesse s. note the sliced ctm so obtained include non causal schedules that are rejected by sliced causality .
v. inferring atomicregions as noted previously multiple variableaccesses are often intended to be atomic.
for example cpredicate expressions such as s t.c !
b t.c multiple update assignments such as s len s buf b and shared accesses with in lock unlock regions involve multi plevariable accesses.
we inferuser intended atomic regions denoted as e transactions that may involve multiple variable accesses based on code structure.
each atomic region should satisfy the following there should be at least one shared access on a nonsynchronization variable and the first and or last shared accesses should be on non synchronization variable s the shared accesses should be within a procedure boundary may include call sites or system calls returns the source lines corresponding to shared accesses should be less than threshold maxddistance code statement proximity no happen before transition such as thread creation join or wait within the region notify is allowed fromagivenbinary assumingadebugversion onecanuse a gnu utility such as objdump to obtain a mapping between processor instruction and corresponding source file and lin e information.
we use this information to tageach transition with a tuple an bracketle tfile line an bracketri ht.
following the above guidelines we then inferatomicregions i.e.
e transactions as illustrated with the following example.
....... .
atom.c pthread mutex lock l2 ....... e8 c1 fd ff ff call 804853c .
atom.c z 804877b a1 9a mov 0x8049a28 eax c0 add 0x1 e ax a3 9a mov eax 0x8049 a28 .
atom.c x char malloc z a1 9a mov 0x8049a28 eax 804878d mov eax esp e8 fd ff ff call 804852c a3 2c 9a mov eax 0x8049 a2c .
atom.c pthread mutex lock l1 80487a1 e8 fd ff ff call 804853c ....... g862 g4 g410 g381 g373 g349 g272 g863 g349 g374 g410 g286 g374 g282 g286 g282 fig.
.
inferring atomicity with objdump using code proximity consider an objectdump shown in figure for the statements s1 s4of our running example.
the transition corresponding to s1 i.e.
2a 3a is assigned a tag an bracketle tatom.c an bracketri ht.
similarly the transitions corresponding to s2 i.e.
3a 4a and 4a 5a are both assigned the tag an bracketle tatom.c an bracketri ht.
using the above guidelines we infer that the transitions corresponding to statements s2ands3are expected to be atomic.
similarly we infer that the transitions correspon ding tos13 ands10 are expected to be atomic.
a set of inferred atomic regions marked in figure b is given by e at tr1 bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright tr2 bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright tr3 bracehtipdownleft bracehtipupright bracehtipupleft bracehtipdownright vi.
atomicity specification we now define the semantic correctness of a schedule or a run for a given set of e transactions denoted as e at.
a schedule is serialw.r.t.e atif each e transactionis executed atomically i.e.
without interruption by other threads.
two schedules are conflict equivalent iff they involve the same actions of the same transactions and every pair of conflicting actions is ordered the same way.
a schedule sis conflict serializable w.r.t.
e atifsis conflict equivalent to some serial schedule.
a set e atisconflict atomic iff every schedule of e atis conflict serializable w.r.t e at.
although conflict atomicityis very useful it is often hard to check in practice.
a set of eatiscasual atomic iffeveryscheduleof e atisrequired tobeconflict serializablew.r.t.each e transaction individually .
a ca property corresponds to each e transaction in e at.
causal mutual atomicity causal atomicity violation is simpler to find compared to conflict atomicity violation however it may miss pair w ise atomicity violation as shown in the following example.
consider a small example as shown in figure .
let the set e atbe .
a run rw z c r z c r x d r z d w x c is not conflict serializable w.r.t.
to the set and thus the set e atis not conflict atomic.
however one can not say e atisnotcausal atomic as is conflict serializable w.r.t.
each e transaction separately.
the1d 2d d1 x d2 z 3d 2c 3c c1 z x malloc c 4c 1c z z y d d 4d fig.
.
threads mcandmdwith shared variables x and z run is a serial schedulew.r.t.
to .
its conflictequivalent equivalent schedule r x d rw z c r z c w x c r z dis a serial schedulew.r.t.
to rw z c r z c w x c .
to detect such non conflict atomicity and yet keep the violation check simpler we introduce a new notion of atomicity .
a set of e transactions is causal mutually atomic cma in short iff for each e transaction tr tr every trace of e atis conflict equivalent to a trace where onlytrandtr areboth needed to be serial w.r.t.
each other.
given a set e at we obtain a set of cma properties where each property is a pair of e transactions such that the pair a corresponds to different threads and b has at lea st two conflicting transitions.
for the inferred set e at eqn we obtain only one cma property represented as tr1 tr2 corresponding to the pair tr1 tr2that satisfies the above criteria.
ca vs. cma property checking .
intuitively checking a cma property is simpler compared to a ca property as reasoned below in a cma property checking only two atomic regions need to be included in the property while in a ca property checking all the atomic regions of different thread conflictingwiththeconcernedatomicregionneedto be includedin the property.consequently a sliced ctm obtain ed w.r.t.
a ca property generally tends to be larger than that obtained w.r.t.
a cma property which also makes the ca checking per property more resource intensive.
we confirmed this observation in our experimental results.
vii.
mat basedpor a nalysis we discuss and highlight the important features of matbased por analysis that we use to simplify the atomicity checking.
before we proceed we explain mat using the lattice of the running example figure .
consider a transaction pair tam1 tbm1 shown as the shaded rectangle m1in figure where tam1 lock l2 a wait pre aand tbm1 lock l1 b unlock l1 bare transactions of threads maandmb respectively.
from the control state pair 1a 1b the pair 7a 4b can be reached by one of the two representative interleavings tam1 tbm1andtbm1 tam1 highlighted with bold arrows .
such a transaction pair tam1 tbm1 isatomic pair wise as one avoids interleaving themin between and hence referred as mutually atomic transaction mat for short.
formally it is defined as follows 4as one may notice that there can be more cma properties to chec k compared to ca properties.
one can address this with task par allelization using distributed resources.128mutuallyatomictransactions mat two transactions tr tf tlandtr t f t lcorresponding to thread m andm aremutually atomic iff except for the last pair i.e.
tl t l allothertransitionpairsinthecorrespondingtransacti ons are independent.
all the interleavings of these transactio ns are equivalent to interleaving either tr tr ortr tr and thus one can avoid interleaving them in between.note tr tr ne ationslash tr tr.
in a mat only the last transition pair have shared accesses on the same variable maybe co enabled and at least one of them being write.
other possible candidates such as 6a 3b are not considered as they are unreachable due to synchronizationsemantics .othermats m2 m6areshown similarly as shaded rectangle.for mat m5 andm6 onlyone interleavingisfeasible highlightedwithonlyoneboldar row .
the basic idea of mat based partial order reduction is to restrict context switching only between the two transactio ns of a mat.
a context switch as indicated with can only occur from the ending of a transaction to the beginning of the other transaction in the same mat.
note that there are exactl y two context switches for any given mat.
for example for the mat m1 tam1 tbm1andtbm1 tam1are the only two context switches allowed.
such restriction reduce the set o f necessary thread interleavingsto explore and at the same t ime includes any feasible interleaving or its equivalent.
a ge neral procedure to find such a set of context switches for two or more threads is provided in .
given a set of reduced context switches denoted as cxt ctm we derive i transactions as follows we obtain a set of i transactions for each thread mi denoted as ati by splitting the sequence of program ordered transitions of miinto transactions such that context switches occur at the begin end control state of such transactions.
for the running example we obtain the sets ataand atbas follows ata ta1 1a 3a ta tb1 tb2 tb3 tb4 ta1 ta2 ta3 ta4m1 m3m2m4tbm1tbm2tam2tam1 tam3tbm3m5 m6m3 fig.
.
mats m1 m63a 5a ta 5a 7a ta 7a 10a andatb tb1 1b 4b tb 4b 6b tb 6b 7b tb 7b 11b .
these are shown as bold arrows in figures b and .
a set of i transactions i at uniontextn i 1ati.
viii.
s ymbolic atomicity checking before we delve into the details we present the underlying idea for the symbolic atomicity checking.
proving atomicity .
given an e transaction we obtain a set 1 i where iis an i transaction and is the length of the e transaction in terms of the number of i transactions so that for each transition t i .
t i. we use the mat analysis to prove atomicity and prune atomic regions accordingly in stage iii i.e.
if the atomicity of the e transaction is guaranteed w.r.t.
the generalized traces.
example for the inferred e at eqn we obtain corresponding i transactions as follows for tr1 tr2andtr3we obtain i transactionssets ta1 ta2 tb2 tb3 tb4 and ta4 respectively.
thus we prove the atomicity of tr3.
from the remaining e transactions we derive two ca properties namely ca tr1 andca tr2 and one cma property namely cma tr1 tr2 .
the following schedules a cviolate these atomicity propertiesas indicated.
note a care missed by other generalized models .
a tb1 ta1 tb2 tb3 ta2 violates ca ca cma b tb1 tb2 ta1 ta2 tb3 tb4 violates ca cma c tb1 tb2 tb3 ta1 ta2 violates ca cma .
in the following we discuss how we encode the violation condition of the atomicity properties and find the violating schedules.
encodingatomicityviolation .givenanatomicityproperty prp as a set of e transactions denoted as e atprp a necessary condition for the atomicity violation denoted as nav is an existence of a non serial schedule i.e.
nav logicalordisplay e atprp logicalordisplay i nc i i where nci jis boolean condition when truedenotes itransaction iis followed immediately by i transaction jin a thread program order.
as an example the navcondition forcma 1property i.e.
tr1 tr2 is given by nav ncta1 ta2 nctb2 tb3 nctb3 tb4 a set of cxt ctmadmits all and only representative schedules of ctm however not all representative schedules captured are serial w.r.t.
to a given set e at.
in other words navmay not be sufficient condition for atomicity violation.
for the running example the schedule tb1 tb2 tb3 ta1 ta2 tb4is not serial w.r.t.
tr1 tr2 as tb3 tb4is interrupted by ta1 ta2.
however it is conflictserializable as it is conflict equivalent to a serial schedu le tb1 tb2 tb3 tb4 ta1 ta2w.r.t.
tr1 tr2 .
findav.
we now present the sound and complete procedure algorithm for finding atomicity violation.
it iterative ly129strengthens the navcondition by eliminating non serial schedules that are conflict equivalentto some serial sched ules.
given a set e atprp corresponding to an atomic property prp we first obtain the necessary violation condition nav as per eqn.
.
we then use a symbolic encoding as discussed in to obtain an smt formula schedthat represents a set of all and only feasible schedules in ctm.
we then use an smt solver to check if sched nav is satisfiable where nav is initialized to nav.
if the check returns unsat it returns nullas there is no violation possible i.e.
property holds .
on the other hand if the check returns sat with a schedule we use a procedure is serializable to check if is conflict serializable.
if the procedurefails we found a true violation and the schedu le isreturned.otherwise weuseaprocedure blocking cls to generate a blocking clause clsas follows cls logicalordisplay e atprp logicalordisplay i 1nc i i nc i i nc i i true ?nc i i c i j ck i where c i j ck i 1denotes all the intermediate context switches from ito i 1through i transactions j k. we use x to denote the boolean satisfying assignment to variablex and?
ternary operatorfor the conditional expression.
we use ci jto denote a boolean condition when truedenotes thati transaction icontext switches to i transaction jof another thread.
we add this clstonav constraints and continue with the smt check .
at every step we prune the set of non serial schedules by eliminating conflict serializable schedules .
the algorithm findav can be used to check ca or cma atomicity violation by plugging the appropriate is serializable procedure for the corresponding notion of atomicity.
special case .
if each e transaction of e atprphas either all write accesses or all read accesses on a single shared variable then one can show that navcondition is both necessary and sufficient condition for atomicity violation .
in such a case we do not require more than one smt check procedure call.
ix.
experiment we have implemented stages i to iv in our tool best.
we usegcc g gcj compilers to transform c c java programs to x86 binaries.
at runtime we instrument the application binary and dynamically loadable libraries suc h aspthread using pin to record the synchronization events such as wait notify lock unlock fork jo in semwait sem post and heapmemoryaccesses.
we use smt solver yices .
.
in our decision procedure.
we use the smt encoding as described in to obtain a set of feasible schedules.
we experimented on a bit linux workstation with a .4ghz intel xeon cpu and 4gb ram.
benchmarks .
we used multi threaded publicly available applications written in c c java with 1k 33k loc.
table iii gives a short description of these applications.algorithm findav find atomicity violation input given a set e atprp nav sched output av schedule or null property holds nav nav initialize violation constraint whiletruedo issat smt check sched nav if issat true if is serializable false cls blocking cls as per eqn nav nav cls else return found a violation else return null property holds endif end while table iii short description of the benchmarks used in experiments .
name loc lang description account java handles banking transactions concurrently.
tsp java solves traveling salesman problem using multi threading.
aget .2k c a multi threaded http download accelerator.
fastspy .5k c a multithreaded network port scanner.
finalsolution 2k c a distributed multiprotocol multithreaded audit tool.
prozilla .7k c a multithreaded http ftp downloader with multiple connections to multiple servers.
axel .1k c a multithreaded replacement of wget.
bzip2smp .4k c a multithreaded parallelizer of bzip2 for smp machines.
alsaplayer 33k c a multithreaded pcm player for unix linux using alsa library.
a. results of atomicity analysis reported in table iv trace information .
we ran each application with different thread settings.
the trace information corresponding to ea ch run are shown in the columns as follows the number of threads n the number of events recorded e the number of local variables l the number of global variables g and the number of global accesses a .
inferringatomicityspecification .foreachrunof thebenchmarks we inferintendedatomicregions e transactions using maxd .
the results of atomicity inference are shown in columns as follows the number of atomic regions inferred ia the number of atomic regions remained after removing those that are proved atomic ra the number of atomic regions remained after removing those that are observed non conflict serializable ra and the average number of shared variables per atomic region vavg .
finding ca atomicity violation .
we obtain a set of ca properties each corresponding to a remaining atomic region ra .
the results of ca atomic checking are shown in columns the number of ca properties ca the number of ca violations found v or proved p by findav and average time taken in sec per property tavg .
finding cma atomicity violation .
we obtain a set of cma propertiesfromremainingatomicregions ra asdescribed in section vi .
the results of cma atomicity checking are shown in columns the number of cma properties cma number of cma violations in the observed trace obs the number of cma violations found v or proved130 p byfindav and the average time taken in sec per property tavg .
for both ca and cma atomicity checking we gave hour time limit per run.
in column we present the number of atomicity bugs found.
discussion .
we observe that a significant number of atomic regionsareprovedatomic ia ra whileonlyafew ra ra are found to be not conflict serializable.
most atomic regions involve multiple variable accesses.
ti me per check i.e.
tavg is mostly around a few seconds.
the number of iterations in findav per property range from one to few hundreds with most checks requiring only one iteration.
cma checking generally is more robust compared to ca checking which aborted in aget finalsolution andprozilla due to resource limitation.
we foundseveralpreviouslyknown unknownav bugs bug list can be found here .
all the found av schedules were feasible.althougheachatomicityviolationfoundtobe unique multiple violations corresponded to the execution of the sa me buggysourcelines.
we discussthese avbugsin thefollowing.
inaget all the reported violations correspond to two distinct atomicity bugs.
one corresponds to a previously known bug where a shared variable bwritten is updated and read non atomically.
the other bug not reported before was due non atomic update and read of an unprotected variable prev in a function updateprogressbar .
in the application finalsolution all the reported atomicity violations correspond to non atomic accesses of a statically defined variable in a function pwdnumdiv and which can generate password strings of unintendedlength.
w e found several atomicity bugs in axel each corresponding to non atomic updates of fields of a structure during set up of http ftp connections.
we found two atomicity bugs in prozilla each corresponding to non atomic update of a structureconnection err .
inaccount the atomicity violations correspond to known atomicity bugs.
b. results of reductions steps reported in table v globalreduction .theproperty independentreductionsteps in stage ii took on average minutes per run mostly dominated by mat based por analysis.
the results of reduction in the number of context switches are shown in rows as follows factor reduction using lockset and hb analysis a and factor reduction using mat analysis b .
similarly factor reduction in the number of transitions using merging d is shown in row .
property specific reduction .
the factor reduction in the number of context switches per cma property using mat analysis c1 post slicing is shown in row .
in row we present the total reduction per cma property combining the net effect product of a b andc1reductions.
similarly the factor reduction in the number of transition per cma property using merging e1 post slicing is shown in row .
in row we present the total reduction per cma property combining the net effect product of d ande1reductions.
similar reduction results are presented for ca properties i n rows and .
discussion .
we observe that the combination of the reduction steps in stages ii and iv help in reducing the contextswitches by a few orders of magnitude.
similarly these step s reducethe numberof transitionssignificantly.we also obse rve that the reduction in the number of context switches per cma property is at least an order of magnitude more compared to per ca property.
overall these reductions steps are crucia l in improving the scalability of the approach.
x. conclusion futurework we presented a tool for predicting atomicity violation in the most generalization of the observed trace.
the salient feature of our tool are effective staged simplification and reductionenablingscalable symbolicprediction automat ically inferring atomic regions from a concrete execution using a more useful and practical notion of atomicity generating atomicity violating schedules that exhibit real bugs and sc ope for task parallelization.
we demonstrated the practicalit y and usefulness of the combined techniques on a set of publicly available benchmarks in finding known unknown bugs.
in conclusion we believe that such an approach has the potential to improve the scalability of precise runtime ana lysis and therefore improvesoverallqualityofconcurrencyte sting.
infuture wewouldliketoaddsupportforhandlingspurious schedules and distribute search for further scalability.