search based inference of polynomial metamorphic relations jie zhang junjie chen dan hao yingfei xiong bing xie lu zhang hong mei key laboratory of high confidence software technologies peking university moe china institute of software school of eecs peking university china zhangjie12 chenjj14 haod xiongyf04 xiebing zhanglu meih sei.pku.edu.cn abstract metamorphic testing mt is an e ective methodology for testing those so called non testable programs e.g.
scienti c programs where it is sometimes very di cult for testers to know whether the outputs are correct.
in metamorphic testing metamorphic relations mrs which specify how particular changes to the input of the program under test would change the output play an essential role.
however testers may typically have to obtain mrs manually.
in this paper we propose a search based approach to automatic inference of polynomial mrs for a program under test.
in particular we use a set of parameters to represent a particular class of mrs which we refer to as polynomial mrs and turn the problem of inferring mrs into a problem of searching for suitable values of the parameters.
we then dynamically analyze multiple executions of the program and use particle swarm optimization to solve the search problem.
to improve the quality of inferred mrs we further use mr ltering to remove some inferred mrs. we also conducted three empirical studies to evaluate our approach using four scienti c libraries including scienti c functions .
from our empirical results our approach is able to infer many high quality mrs in acceptable time i.e.
from .
seconds to .
seconds which are e ective in detecting faults with no false detection.
categories and subject descriptors d. .
testing and debugging testing tools general terms algorithm experimentation veri cation keywords metamorphic testing invariant inference particle swarm optimization corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september sweden copyright acm ... .
.
introduction in software testing a test oracle is needed to determine whether the program under test exhibits an acceptable behavior.
typically it is very costly for testers to obtain a suitable test oracle for the program under test .
for some programs e.g.
scienti c programs which weyuker refers to as non testable programs obtaining test oracles may be extremely di cult or even impossible.
in such a circumstance testers may be unable to decide whether the program outputs are correct for most given inputs.
to facilitate testing the so called non testable programs chen et al.
proposed metamorphic testing mt which detects program faults in by looking for violations of metamorphic relations mrs .
typically an mr speci es how a particular change to the input would change the output.
for example to test the sinprogram in metamorphic testing the tester can check whether sin x is equal to sin x without knowing the exact value of sin x .
that is the mr sin x sin x can be used to test the sinfunction.
typically testers need to manually acquire mrs. however many mrs may be di cult to acquire due to the lack of thorough knowledge of the program under test.
as scienti c programs usually deal with complex computation it is even more di cult to manually acquire mrs for scienti c computing without thorough knowledge of such programs.
for example for the sinprogram some mrs like sin x sin x are easy to infer but some mrs like sin2 x sin2 x are not.
as demonstrated by chen et al.
more mrs may help achieve more adequate testing.
such manual acquisition of a number of mrs may become a bottleneck of metamorphic testing.
to facilitate this labor intensive work kanewala and bieman proposed a machine learning based technique to predict whether a program contains some forms of mrs. for example for the sinprogram this technique predicts whether it contains a form of mr like sin x c1sin x c2 where c1andc2are constants but does not generate the values of constants c1andc2.
di erent from their technique in this paper we aim to automatically infer speci c mrs instead.
as it is di cult to infer arbitrary relations automatically we need to consider a particular class of relations.
after manually studying mrs reported in the literature we found that .
mrs are polynomial i.e.
the relations between inputs and the relations between outputs are both polynomial equations.
therefore in this paper we focus on inferring only such polynomial mrs. in particular we propose a novel search based approach to inferring polynomial mrs1by analyzing multiple executions of the program under test.
our approach aims to infer polynomial metamorphic relations in particular forms which can be represented as a series of parameters.
for those parameterized mrs our approach uses particle swarm optimization to search for suitable values of the parameters.
that is our approach tries to nd a set of parameter values that characterize the analyzed executions in the form of an mr. furthermore to improve the quality of mrs our approach applies statistics based ltering to the inferred mrs. based on our study on the literature of mrs .
polynomial mrs are simple polynomial mrs whose relations between inputs are linear equations and whose relations between outputs are linear or quadratic equations.
therefore in the current stage our approach focuses on inferring these particular polynomial mrs. however our approach is general and can be used to infer other polynomial mrs which is illustrated in section .
as an extension to our approach.
based on our approach we implemented a tool named mri i.e.
metamorphic relation inferrer and conducted three empirical studies on mri to evaluate our approach using scienti c functions from apache jdk gsl and matlab.
the rst study investigates the feasibility of our approach.
the second study investigates the quality of mrs inferred by our approach.
the third study investigates whether mr ltering in our approach may improve the quality of inferred mrs. our empirical results demonstrate that our approach is able to infer many high quality mrs in acceptable time.
furthermore mr ltering in our approach actually improves the quality of inferred mrs. in summary this paper makes the following contributions.
a novel search based2approach to inferring polynomial mrs via dynamically analyzing multiple executions using particle swarm optimization.
an evaluation on four scienti c libraries demonstrating the feasibility of our approach and the quality of inferred mrs. .
examples to further motivate our research we use some example metamorphic relations for three trigonometric functions to demonstrate that even for some widely known functions there may be some unfamiliar metamorphic relations.
to most people the sinfunction is one of the most popular trigonometric functions.
let us consider the metamorphic relation sin2 x sin2 x .
at a glance this metamorphic relation looks quite unfamiliar but as we know that cos2 x sin2 x and cos x sin x we may derive this metamorphic relation by ourselves.
for thecosfunction cos 2x 2cos2 x is a metamorphic relation.
deriving this metamorphic relation would be much more di cult because it involves complex mathematical deductions.
furthermore it may be even more di cult to derive the metamorphic relation tan2 x 2tan x tan 2x 1strictly speaking the mrs our approach inferred are likely mrs. 2search based software engineering is an important branch of software engineering which applies search techniques to solve various software engineering problems .
to our knowledge our approach is the rst application of search based software engineering in mr inference.
for the tanfunction as tanis much less used thansinandcos.
as mathematicians have thoroughly investigated all the preceding trigonometric functions testers may nd the preceding metamorphic relations by searching in a textbook or the internet.
however when the program under test does not exactly match some thoroughly investigated function it may be painful for testers to derive its metamorphic relations.
previously kanewala and bieman proposed a machine learning based approach to predicting likely metamorphic relations by some features which are extracted from the control ow graph of a program.
however this approach can only predict whether the program has a particular metamorphic relation or not.
let us take the sinfunction as an example.
by analyzing the source code implementing the sin function this machine learning based approach may predict that this function has an mr whose input change and output change are both additive3.
that is for the sinfunction this machine learning based approach may infer metamorphic relations like sin x c1sin x c2 where c1and c2are constants and xis the input parameter of the function sin.
however this approach does not provide the values of constantsc1andc2at all.
.
approach before presenting our approach we present some background information of particle swarm optimization pso in section .
.
in our approach we present de nitions of mrs in their parameterized forms in section .
our psobased search algorithm for determining the parameters in section .
and our statistical based technique for ltering mrs in section .
.
.
background particle swarm optimization pso originally proposed by kennedy and eberhart in is a swarm intelligence optimization algorithm simulating the birds foraging behavior.
in pso each candidate solution is called a particle and multiple particles coexist and optimize cooperatively to achieve the optimal solution.
in particular each particle has a velocity and a location which keep changing during the search.
there is a tness function to evaluate how close the location of a particle is to an optimal location.
consider searching in a d dimensional space with nparticles.
we use vt i vt i1 vt i2 vt id andlt i lt i1 lt i2 lt id to denote the velocity and the location of the i th i n particle at moment t t wherevt idandlt iddenote the values of vt iandlt iin thed th d d dimension respectively.
then formula calculates the velocity of the i th particle in the next moment i.e.
moment t .
vt id !vt id 1r1 pt id lt id 2r2 pt gd lt id in formula !
and 2are three weights in positive numbers where !is referred to as the inertia weight and the other two weights referred to as the acceleration factors r1 andr2are two random numbers between and pt idis the d th dimension of the personal optimum location that the 3if the input to a program is modi ed by adding or subtracting a constant its output will remain or increase.
kanewala and bieman de ned such a change to an input output as additive.
702i th particle has reached on and before moment t andpt gd is thed th dimension of the global optimum location that all particles have reached on and before moment t. in other words besides the two random numbers r1andr2 there are three factors that may impact the velocity of a particle in moment t the velocity in moment t the personal optimal location that the particle has ever reached and the global optimal location that any particle has ever reached.
based on its velocity in moment t the location of the i th particle can be calculated with formula .
lt id lt id vt id in the beginning i.e.
moment the nparticles are assigned with locations and velocities randomly.
the nparticles keep updating their velocities and locations according to formulae and until reaching moment t which is a termination threshold .
then the global optimum location that any particle has ever reached is returned as the nal solution.
typically each dimension is given a range and if the location of any particle at any moment during the search is out of range the location value in the corresponding dimension is set to the boundary values.
.
parameterizing mrs as a metamorphic relation mr usually speci es how a change to the input would result in a change to the output we formalize an mr4as formula .
ri i1 i2 ro o1 o2 in formula i1andi2are the original input and the changed input o1ando2are the outputs corresponding toi1andi2 riis a relation between input i1and input i2 androis a relation between output o1and output o2.
without loss of generality either i1ori2represents a vector of values but either o1oro2represents only one value.
the reason is that we can treat each output value individually when the program under test has more than one output value.
although formula can exactly characterize an mr it still cannot be directly used for mr inference because both riandrocan be in any form.
as most mrs studied in the literature are polynomial we further con ne riandro in formula to polynomial equations.
with this con nement an mr can be characterized with the values of the parameters in the two polynomial equations.
furthermore as mentioned in the introduction most polynomial metamorphic relations are simple polynomial metamorphic relations whose relations between inputs are linear equations and whose relations between outputs are linear equations or quadratic equations.
that is many mrs discussed in the literature are typically in much simpler forms than mrs involving two arbitrary polynomial equations.
therefore in the current stage of our research there are two cases under investigation riis a linear equation androis a linear equation too.
riis a linear equation while rois a quadratic equation.
we will give a formula denoting mrs with each case.
suppose that there are ninput values for each input with x1 x2 x n and y1 y2 y n representing the two in4chen et al.
further generalized an mr as an expected relation among the inputs and outputs of multiple executions .
we will investigate these generalized mrs in our future work.puts i.e.
i1andi2 .
as we mentioned i1is the original input andi2is the input derived from i1.
asriis a linear equation that represents the relation between i1andi2 every input value of i2 i.e.
yi can be denoted as a linear combination of all input values of i1 i.e.
yi pn j 1aijxj bi.
when rois a linear equation we can represent roby c1o1 c2o2 d where o1ando2are the two outputs.
given a program under test denoted as p let us use p x1 x2 x n to denote output o1 andp pn j 1a1jxj b1 pn j 1anjxj bn to denote output o2.
then rocan be further represented as c1p x1 x2 x n c2p nx j 1a1jxj b1 nx j 1anjxj bn d similarly we can have a formula denoting mrs with rito be a linear equation and roto be quadratic.
as rois quadratic we can represent robyc1o2 c2o1o2 c3o2 d1o d2o e where o1ando2are the two outputs.
for simplicity we use p i1 andp i to denote the two outputso1ando2 where represents the matrix a and represents the vector b1 b2 b n .
formula denotes mrs with roto be quadratic.
c1p2 i1 c2p i1 p i c3p2 i d1p i1 d2p i e it should be noted that formula is actually a degenerate form of formula where the three coe cients of the three terms with degree are all zero.
however in our search algorithm discussed in section .
we need to force the algorithm to produce non degenerate mrs. for example if we allow the algorithm to produce degenerate mrs it may produce all zero for all the parameters.
therefore we use both formulae in our search algorithm without allowing any degenerate mrs. in the following we demonstrate that all the mrs discussed previously can be represented with our two formulae.
for sin x sin x when a11 b1 c1 c2 andd formula actually represents this mr. using formula when a11 b1 c1 c3 c2 d1 d2 ande it represents sin2 x sin2 x when a11 b1 c1 c2 c3 d1 d2 ande it represents cos 2x 2cos2 x .
similarly we can also use formula to represent tan2 x 2tan x tan 2x .
in fact given a program under test the number of mrs that can be represented in formula or formula might still be in nite.
thus it might still be infeasible to infer all the mrs satisfying the two formulae.
for ease of presentation we refer to an mr inferred by using formula a type one mr denoted as mr whereas an mr inferred by using formula is called a type two mr denoted as mr .
.
searching for mr parameters given a program under test denoted as p andminputs denoted as i1 i2 ... im ofp the problem of inferring a polynomial mr for pcan be turned into a search problem of nding some vector of parameter values in formula or formula such that for almost every input ii i m 703the vector of parameter values and iisatisfy formula or formula .
to solve the preceding search problem we adopt a pso algorithm due to the following reasons.
first as pso is very e ective to search in continuous space it may help nd parameter values in real numbers.
second as the location updating mechanism in pso can keep particles from swaying among multiple optimal locations it is suitable for the situation that there may be many mrs satisfying formula and or formula .
however when there are not many mrs pso is also e ective due to the global optimal location and the velocity of the previous iteration can lead a particle to escape local optimal locations.
for simplicity of presentation we focus on formula in the rest of this subsection.
it is straightforward to extend to formula .
in our pso a candidate solution i.e.
a particle is a set of parameter values i.e.
values of c1 c2 aij biand d .
for every set of parameter values the tness function counts the number of inputs that satisfy formula .
formally we de ne the tness function for formula as follows.
given a vector denoted as l of values for c1 c2 aij i j n bi i n andd ifland input ik k m satisfy formula we de ne f l k otherwise we de ne f l k .
thus the tness of vector lcan be de ned as formula which actually counts the number of inputs that satisfy formula for l. fitness l mx k 1f l k as the location of every particle keeps changing sometimes the values of c1andc2may be close to zero which will make our mr pointless.
to prevent our pso algorithm from producing mrs in degenerate forms when both values of c1 andc2in a particle are close to zero we reset them to a new value.
in particular we use a threshold denoted as .
when both c1andc2are between and we set them to or depending on their being positive or negative.
as one execution of our pso algorithm generates only one possible mr we need to execute our pso algorithm many times to obtain a number of mrs. due to the random initialization of locations and velocities of the particles and the random factors i.e.
r1andr2 in formula di erent executions may produce di erent mrs. it is possible that an execution of our pso algorithm may not always produce a good enough solution whose tness is lower than a threshold denoted as f .
in such cases we drop all not good enough solutions.
speci c parameter setting e.g.
f of our pso algorithm is presented in section .
.
mr filtering our pso algorithm infers mrs based on the multiple executions of the program and thus the quality of inferred mrs may be dependent on the test inputs of a program.
intuitively our pso algorithm tends to produce high quality mrs if many test inputs are used.
however it is costly to conduct our pso algorithm with a large number of test inputs.
therefore our proposed approach uses statistics based ltering to remove low quality mrs. for each mrs inferred by our pso algorithm the statistics based ltering algorithm applies a large number of randomly generated test inputs to program p and records whether this mr is violated by each test input.
if an mr is violated by an unignorable percentage which is denotedass of test inputs we deem such an mr as a low quality mr and remove it from the set of inferred mrs. by repeating the preceding process several times which is denoted asnof we deliver a set of high quality mrs by removing some low quality mrs. .
implementation based on the approach described in section we implemented a tool named mri metamorphic relation inferrer .
for our pso algorithm we use the following settings as recommended in the literature of pso we set the two acceleration factors i.e.
1and 2in formula as .
the number of particles i.e.
n as and the termination threshold i.e.
the total number of moments t as .
the inertia weight i.e.
!in formula is a changing value for di erent moments.
we set the value of !
for moment t denoted as !t according to formula also recommended in pso literature where !s which is the value for moment is .
and !e which is the value for momentt is .
.
!t !s !s !e t t we set which is the threshold to avoid degenerate mrs as .
andf which is the threshold to select good enough solutions as m. note that in formula parameters c1 c2 anddcan be in ated.
if we multiply the three parameters with a common factor we can have another mr that is semantically equivalent to the original mr. thus there can be a large number of mrs with the values of c1 c2 and dclose to zero.
therefore using a value signi cantly larger than zero for would also help save the e orts of inferring too many semantically equivalent mrs. of course .
may not be the best value to achieve this goal.
the setting of f as m is to due to statistical considerations as such a setting implies that it is highly probable that an input can satisfy the inferred mr. similarly we also set sas .
as pso algorithm requires to set the boundary values for the parameters c1 c2 c3 d1 d2 ande we conducted a trial using the sinfunction of apache .
to decide the proper boundary values of these parameters with which mri may infer high quality mrs. in particular we varied the boundary values for these parameters and applied mri with any speci ed values of these parameters to the sinfunction.
after manually checking their inferred mrs for the sin function we determined the boundary values for these parameters based on the e ectiveness of their inferred mrs. as a result in our implementation the boundary values for c1 c2 c3 d1 d2 and are from to the boundary value for is from to and the boundary value for eis from to .
moreover in mri as the test inputs used in our pso algorithm and mr ltering are randomly generated we set the range of test inputs to be from to .
besides the number of test inputs used in our pso algorithm is set to the number of test inputs used in mr ltering is set to andnof is set to .
.
empirical setup to evaluate our approach we conducted three empirical studies on scienti c functions from four scienti c libraries to answer the following research questions 704in the rst study we investigate the feasibility of our approach.
in this study we are interested in the following research question rq1 is our approach able to infer mrs?
in the second study we investigate the quality of inferred mrs. in this study we are interested in the following research question rq2 how is the quality of mrs inferred by our approach?
in the third study we investigate the impact of mr ltering in our approach.
in this study we are interested in the following research question rq3 does mr ltering improve the quality of inferred mrs?
.
subjects our approach infers mrs by analyzing multiple executions of a program rather than its source code.
that is our approach is a black box technique which requires no source code under test and may be applied to scienti c functions in various languages.
therefore in our empirical studies we used four scienti c libraries which are written in java and c c .
the four scienti c libraries are apache commons mathematics library the math class of java development kit the gnu scienti c library and the scienti c library of matlab.
apache commons mathematics library5 abbreviated as apache in this paper is a library of self contained mathematical and statistical components in java.
the math class of java development kit6 abbreviated as jdk in this paper provides methods for numeric operations in the java platform.
the gnu scienti c library7 abbreviated as gsl in this paper is a numeric library of mathematical routines in c c language.
matlab8is a powerful computing environment developed by mathworks which also contains a very large number of scienti c functions.
among the four libraries apache and gsl are open source scienti c libraries whereas jdk and matlab are commercial scienti c libraries.
that is the source code of the latter two libraries is not available.
as each scienti c library contains a very large number of scienti c functions it is impossible for us to run our approach on all the scienti c functions due to time limit on experimentation so we further selected the packages that perform plain mathematical computations e.g.
not matrix operations or statistical functions .
in particular we used the scienti c programs in fastmath.java of apache.
for jdk and matlab we used their same scienti c programs as apache.
for gsl we used the scienti c programs in the specfunc directory.
as a result we got a dataset consisting of scienti c functions of apache .
scienti c functions of jdk .
scienti c functions of gsl .
and scienti c functions of matlab r2012b.
table presents the basic information of these scienti c functions where the last three columns present the version information the total number of scienti c functions and the total number of lines of code used in the studies.
more information on these functions can be found in the project webpage .
as the source code of jdk .
and that of matlab r2012b is not available we do not list its number of lines of code in this table.
downloads index.html subjects library version function loc apache .
jdk .
gsl .
matlab r2012b .
process in this subsection we present the details of how we conducted the three empirical studies.
.
.
study i in the rst study for each function we repeated our pso algorithm times.
after mr ltering mri inferred a set of mrs and mrs for each subject.
we also recorded the total time spent on mr inference for each subject.
.
.
study ii first we investigated the correctness of mrs inferred in the rst study.
as sin cos andtanare typical scienti c functions which are available through many mathematics books we chose the three functions implemented in di erent libraries as representative subjects and manually checked the correctness of their inferred mrs as follows.
for each of these inferred mrs we looked through wikipedia9and a mathematics book to check whether it is correct.
some inferred mrs can be deduced by others.
for example sin x sin x can be deduced by sin x sin x and sin x sin x .
in software testing if developers have already used the latter two mrs they may not run again the sinfunction with the former mr i.e.
sin x sin x because faults detected by the former mr may also be detected by the latter mrs. to acquire the set of mrs that cannot be deduced by each other we de ne a set of representative mrs for any set of inferred mrs. in particular for any given set of inferred mrs i.e.
mrs or mrs of a subject its set of representative mrs is the minimized subset of the given set and each mr of the given set can be deduced by using one or more mrs in its representative set.
for example for a set of inferred mrsfsin x sin x sin x sin x sin x sin x 0g its set of representative mrs is fsin x sin x sin x sin x 0g.
in this study for each trigonometric function we manually summarized its set of representative mrs and mrs respectively.
if multiple minimal subsets exist we chose one that has the smallest size.
besides apache .
jdk .
and matlab r2012b implement some common scienti c functions.
for each common scienti c function e.g.
exp we compared the number of mrs inferred from di erent libraries.
second we investigated the fault detection capability of mrs inferred in the rst study through regression testing .
in particular to simulate the regression testing in software evolution we applied the mrs inferred from the correct version of a project on detecting faults in its subsequent version.
among the functions used in the empirical studies functions i.e.
sin cos tan log10 loglp asinh atan and fourabsfunctions with various inputs have changed from apache .
to apache .
.
the other functions used in the functions sine.2c cosine and tangent 705empirical studies have no change during software evolution.
therefore in the second study we used these functions of apache .
to investigate the fault detection capability of mrs inferred from the rst study.
as the functions of apache have been widely used in practical software development they hardly contain any faults.
therefore for these functions we constructed faults using program mutation following procedure similar to prior work .
the di erence between versions shows the developers modi cation on the previous version and thus we generated faults only in such di erence so as to simulate most developers faults in software evolution.
in particular for each of the functions of apache .
we applied muclipse to generate a number of mutants whose mutation operators10occur only on the di erent statements between apache .
and apache .
.
each mutant which is the result of applying a mutation operator on the source code is viewed as a faulty program in our second study.
if an mr is violated by a faulty program we deem the mr detects the fault.
however if the mr is also violated by the original unseeded program of apache .
we deem this mr is of low quality and the detection is a false detection.
for each of the functions of apache .
we randomly generated test inputs.
then we ran these test inputs on both the generated faulty versions of apache .
and the original version of apache .
for each mr inferred from apache .
.
as our approach infers mrs that are supported by at least inputs the inferred mrs should be used in a statistical way of metamorphic testing which is referred to as statistical metamorphic testing in this paper.
in statistical metamorphic testing only when the violation of an inferred mr become statistically non trivial we deem the program to be likely to contain faults.
in particular we consider an mr was violated when at least of the test inputs were violated considering anomaly detection.
.
.
study iii to learn whether mr ltering improves the quality of inferred mrs we compared the quality of mrs inferred with mr ltering and the quality of mrs inferred without mr ltering in regression testing following the same procedure of the second study.
in this study for each faulty program of apache .
we used statistical metamorphic testing to evaluate the quality of these mrs recording the number of true detections and the number of false detections.
finally we compared the numbers of true detections and false detections between mrs inferred with mr ltering and mrs inferred without mr ltering.
.
threats to validity the threat to internal validity lies in the implementation of our approach.
to reduce the threat from implementing errors the authors of this paper reviewed the source code after implementing the proposed approach.
the main threats to external validity lie in the subjects and faults.
first similar to prior work in metamorphic testing we used four scienti c libraries consisting of small11 10mutation operators de ne some operations like statement deletion statement replacement and so on.
11after manually studying the scienti c functions used in the literature of software engineering we found that the scienti c functions used in their evaluation are usually very small which are usually smaller than lines of code.table basic statistics on mr inference number of mrs for each scienti c program library mrs mrs avg.
max.
min.
avg.
max.
min.
apache .
.
jdk .
.
gsl .
.
matlab .
.
execution time of mr inference for each scienti c program library mrs seconds mrs seconds avg.
max.
min.
avg.
max.
min.
apache .
.
.
.
.
.
jdk .
.
.
.
.
.
gsl .
.
.
.
.
.
matlab .
.
.
.
.
.
scienti c functions whose mrs may be manually checked.
as our approach is a black box technique that does not analyze the source code whether the scienti c functions are small or large does not a ect the feasibility of our approach.
however the functionality of scienti c functions has much impact on the feasibility of our approach because our approach infers mrs based on their executions.
to reduce this threat we used a large number of scienti c programs from di erent libraries.
moreover although our approach is evaluated based on scienti c programs the approach has no such restrictions and can be applied to any programs.
to reduce this threat we will evaluate our approach by other programs in the future.
second the faults were generated by using a mutation tool because prior work shows that such faults can be used in the empirical studies of software testing.
as these faults may be not representative of real faults we will conduct more empirical studies on more programs with real faults in the future.
furthermore in the evaluation we used the implementation of our approach introduced in section whose value for each parameter is set based on the literature of pso and our trial on the sinfunction.
however as our approach does not have any restrictions on the values of the parameters in future work we will conduct empirical studies to evaluate the e ectiveness of our approach with other values of these parameters.
.
results .
rq1 mr inference table presents the basic statistics on mr inference including the number of inferred mrs for each scienti c function and the execution time of our approach on inferring mrs for each scienti c function.
the complete results can be found in .
from this table for each scienti c function the number of mrs is from to whereas the number of mrs is from to .
that is our approach infers an unignorable number of mrs and mrs for scienti c functions.
the execution time of our approach on inferring mrs for each scienti c function is from .
seconds to .
seconds which is acceptable.
therefore our approach is able to infer many mrs quickly.
.
rq2 quality of inferred mrs .
.
correctness table presents typical mrs of the three trigonometric functionssin cos andtan.
our approach generates mrs 706table mrs inferred from three trigonometric functions function library mrs mrs sin x sin x sin2 x sin2 x sin x sin x sin2 5x 5sin x apache sin x sin x sin2 x sin2 x 2sin x sin x sin x sin x ... sin2 x sin2 x 2sin x sin x ... sin x sin x sin2 x sin2 x sin x sin x sin2 x 5sin 2x sin jdk sin x sin x sin2 x sin2 x 2sin x sin x sin x sin x ... sin2 x sin2 x 2sin x sin x ... sin x sin x sin2 x sin2 x sin x sin x sin x sin x sin x 5sin2 x 5sin x sin x 5sin x 5sin x gsl sin x sin x sin2 x sin x sin x sin x sin x sin x sin x ...sin2 x sin2 x 2sin x sin x ... sin x sin x sin2 x sin2 x sin x sin x sin2 x sin2 x 2sin x sin x matlab sin x sin x sin2 x sin x sin x 2sin x 2sin x sin x sin x ... sin2 x 5sin 2x ... cos x cos x cos2 x cos2 x cos x cos x cos2 5x 5cos x apache cos x cos x cos2 x cos2 x cos x cos x ... cos2 x cos2 x 2cos x cos x ... cos x cos x cos2 x cos2 x cos x cos x cos2 5x 5cos x cos jdk cos x cos x cos2 x cos x cos x cos x cos x cos x cos x ... cos2 x cos x cos x ... cos x cos x cos2 x 5cos2 x 5cos x cos x 5cos x 5cos x cos x cos x cos2 x cos x cos x cos x cos x gsl cos x cos x cos2 5x 5cos x cos x cos x ...cos2 x cos2 x 2cos x cos x ... cos x cos x cos2 5x 5cos x cos x cos x cos2 x 3cos2 x 4cos x cos x matlab cos x cos x cos2 x cos2 x cos x cos x ... cos2 x cos2 x cos x cos x ... tan x tan x tan2 5x 2tan x tan 5x tan x tan x tan2 x tan2 x 2tan x tan x apache tan x tan x tan2 x tan2 x tan x tan x tan x tan x ... tan2 x tan2 x 2tan x tan x ... tan x tan x tan2 x 2tan x tan 2x tan x tan x tan2 x tan2 x tan jdk tan x tan x tan2 x tan2 x tan x tan x tan x tan x ... tan2 x tan2 x 2tan x tan x ... tan x tan x tan2 x tan2 x 2tan x tan x tan x tan x tan2 x 5tan2 x 5tan x tan x 5tan x 5tan x matlab tan x tan x 0tan2 x tan2 x 2tan x tan x tan x tan x ... tan2 5x 2tan x tan 5x ... table comparison of some inferred mrs in the rst study mrs absdabsfabsiabslacosacoshasinasinhatanrounddcbrt ceilcos apache jdk matlab mrs todegrees signumfexpm 1floorgedgefloglog10log1pnextupdnextupfrintatanh apache jdk matlab mrs roundfsignumdexpsinsinhsqrttantanhcoshtoradians ulpdulpf apache jdk matlab mrs absdabsfabsiabslacosacoshasinasinhatanrounddcbrt ceilcos apache jdk matlab mrs todegrees signumfexpm 1floorgedgefloglog10log1pnextupdnextupfrintatanh apache jdk matlab mrs roundfsignumdexpsinsinhsqrttantanhcoshtoradians ulpdulpf apache jdk matlab 707by assigning values to the parameters in the formulae with some precision.
to ease understanding we present the inferred mrs in this table by using the estimation of these values.
for example in the sinfunction we use to denote .
.
gsl does not implement the tanfunction and thus we do not list its inferred mrs in this table.
for each subject we use the bold font to depict its complete sets of representative mrs. the left columns give mrs inferred by our approach using formula whereas the right columns give mrs inferred by our approach using formula .
from this table these typical mrs include most important mrs of the three trigonometric functions.
for example our approach infers series of mrs and mrs for thecosfunction of the four scienti c libraries.
these inferred mrs represented by cos x cos x and cos x cos x show that the cosfunction is a symmetric and periodical function.
the inferred mrs represented bycos2 x cos2 x cos2 5x 5cos x cos2 x cos2 x andcos2 x cos2 x 2cos x cos x show the relation between cos x cos 2x andcos x besides the symmetric and periodical characteristics of the cosfunction.
furthermore our approach infers the complex mrs sin2 x sin2 x for the sinfunction and tan2 x 2tan 2x tan x for the tanfunction from the libraries.
table presents the total number of mrs inferred from the common scienti c functions.
for each function the numbers of inferred mrs from di erent libraries are close.
this observation is as expected because these functions have the same functionality suggesting the correctness of the inferred mrs. for the same scienti c function the average execution time of our approach for di erent libraries is close.
that is although di erent libraries may implement a scienti c function in di erent ways13 i.e.
resulting in di erent programs their kernel source code may not di er much in e ciency and thus the execution time of our approach for the same scienti c functions of di erent libraries is close.
from table the number of inferred mrs is larger than that of the representative mrs. for example our approach generated mrs for the sinfunction of apache but only of them are representative.
the other mrs can be deduced by these representative mrs. as chen et al.
demonstrate that more mrs may help to achieve more adequate testing the mrs that can be deduced by some representative mrs may not be redundant.
moreover more mrs may reduce the cost in software testing.
for example in order to reveal the faults that can be detected only bysin x sin x it may be more costly to check the two representative mrs i.e.
sin x sin x andsin x sin x rather than one mr. to check the former mr developers may run the sinfunction twice whereas checking the latter two mrs developers may run thesinfunction four times.
.
.
fault detection capability table gives the results of the second study where the second column gives the total number of mutation faults 12the complete list of inferred mrs for these functions can be found in the project webpage.
13as the source code of jdk and matlab is not available we cannot check the di erence between the source code of the three libraries.table fault detection capability of mrs seeded by mrs by mrs faults total fd td total fd td sin cos tan log10 log1p asinh atan absd absf absi absl in each scienti c function of apache .
fd presents the number of false detections by the corresponding mrs td presents the number of true detections by the corresponding mrs and total is the sum of its previous two columns.
from the fth and eighth columns the numbers of true detections for mrs and mrs are usually larger than .
that is the inferred mrs are able to detect faults.
from the fourth and seventh columns the numbers of false detections for mrs and mrs are .
that is the inferred mrs always make correct detection.
on the other hand for most scienti c functions including sin cos tan absd absf absi andabsl the inferred mrs detect about half of the faults.
the only exception is asinh in which only one fault is detected out of faults.
by further investigating the injected faults we found that this is probably because the rest faults were not triggered by the test inputs the mutated statements of all the faults will be executed only when a strict condition i.e.
variable a is smaller than .
is satis ed .
overall our inferred mrs were e ective in detecting faults and produced no false detection.
comparing the results of the two types of mrs i.e.
1mrs and mrs the number of faults detected by the former is close to that of the latter.
after reviewing these inferred mrs and their detected faults we found the reason to be that our approach always infers some important mrs that can detect a large number of faults no matter which formula i.e.
formula and formula it used.
.
rq3 necessity of mr filtering table presents the fault detection capability of mrs inferred by our approach without mr ltering.
for each scienti c function the number of false detections of mrs inferred without mr ltering is usually larger than .
for example the mrs for the tanfunction have false detections.
as the functionality of these subjects does not change from apache .
to apache .
these inferred mrs should not be violated.
that is the false detections in this table result from low quality mrs which are inferred by our approach without mr ltering.
as the number of false detections detected by the mrs inferred with mr ltering is shown by table mr ltering actually improves the quality of mrs by removing low quality mrs. on the other hand the ltering did reduce the number of true detections but the reduced number was small.
overall the reduction on fault detection occurred only on out of functions and in total only .
true detections were ltered out.
considering the large number of false detections removed we believe the ltering procedure is e ective and necessary.
708table fault detection capability of mrs without mr ltering seeded by mrs by mrs faults total fd td total fd td sin cos tan log10 log1p asinh atan absd absf absi absl figure a dimension solution space .
discussion .
limitations first our approach requires the input of the program under test to be of numerical values.
for example our approach in the current stage may not be suitable for programs whose inputs are pointers or arrays.
therefore we may improve the existing pso algorithms by transforming these inputs into numerical values.
second our approach requires that the program under test should always produce the same output for the same input.
that is to say the behavior of the program under test should not depend on some external state.
thus our approach may not be suitable for testing a program involving a database or a method in an object oriented program relying on the state of the object.
.
extensions according to chen et al.
an mr are supposed to hold among multiple executions.
based on this we can change our formula to a more general form depicted in formula .
ri i1 i2 im ro o1 o2 o m similar to the treatment presented in section we can also parameterize this generalized de nition of mrs by conning riandroto be polynomial equations.
in fact we can further relax the requirement of polynomial equations to polynomial inequalities.
therefore the whole solution space of the extension can be depicted in figure where p1andp2represent the two cases our approach has solved.
in this solution space there are three major directions for further extending our approach.first the rirelation on inputs can be extended to a polynomial with a higher degree i.e.
greater than .
for example using a polynomial with a degree of for rimay help infer log10 x2 2log x for the log10 function.
second the rorelation on outputs can also be extended to a polynomial with a higher degree i.e.
greater than .
for example using a polynomial with a degree of for ro may help infer sin 3x 3sin x 4sin3 x forsin.
third the number of involved inputs can be extended to more than .
for example involving inputs may help infer sin 2x 2sin x sin x for the sinfunction.
as our approach in this paper cannot deal with these extensions we will improve our pso algorithm for further investigating these situations.
.
related work .
metamorphic testing chen et al.
originally proposed the methodology of metamorphic testing and formally established the methodology .
besides application of metamorphic testing on various areas some researchers focus on the selection of good mrs which is related to our work.
chen et al.
demonstrated that it is better to select mrs that make the multiple executions of the program as di erent as possible.
mayer and guderlei identi ed some mrs and classi ed them using mutation analysis.
they also evaluated mrs according to their potential usefulness.
recently liu et al.
proposed to systematically construct mrs based on some already identi ed mrs. di erently our approach aims to automatically infer mrs without any existing mrs. our work is mostly related to the technique proposed by kanewala and bieman which automatically predicts the existence of some forms of mrs for a program using machine learning.
di erent from our approach their technique does not produce speci c mrs but tells whether a program may have a particular form of mrs or not.
their technique and our approach may be viewed as complement to each other.
in particular we may use their technique to predict the existence of a form of mr and use our technique to produce the speci c mr by giving the values of parameters.
furthermore their technique is a white box technique which extracts features for prediction by analyzing the source code of the program under test whereas our technique is a blackbox technique.
that is with the source code of the program under test our technique may be further improved to produce better mrs. .
program invariant inference as program invariants are important for fault detection and program repairing researchers proposed to infer program invariants through analysis especially dynamic analysis.
for example ernst et al.
developed a tool named daikon to discover program invariants for supporting program evolution.
jiang et al.
proposed a novel technique to automatically model and search relationships between the ow intensities that can be regarded as invariants.
csallner et al.
proposed to infer invariants using dynamic symbolic execution.
llano et al.
proposed to use theory formation to discover invariants.
recently nguyen et al.
inferred disjunctive invariants with a hybrid approach.
furthermore as speci cations tell the usage of api and may be used to detect faults many researchers focus 709on inferring speci cations which can be viewed as program invariants as well.
besides work on invariant generation some researchers focused on using invariants to facilitate software testing e.g.
test case generation and test suite reduction software veri cation model inference and transformation speci cations mining and so on.
our work is related to program invariant inference because mrs can also be regarded as program invariants both of them may be applied to reveal faults in software testing .
however traditional program invariants are supposed to hold during each single execution whereas mrs are supposed to hold across multiple executions.
similar to dynamic invariant inference our approach is also based on the analysis of program executions.
however our approach is to search for the values of the parameters in an mr whereas dynamic variant inference is to discover invariants that satisfying executions.
.
particle swarm optimization particle swarm optimization pso is a swarm intelligence optimization algorithm simulating the birds foraging behavior.
due to the e ciency of pso in solving optimization problems pso has been applied to various areas including multi objective optimization pattern recognition signal processing classi cation and data clustering.
recently pso is applied to some speci c areas of software engineering e.g.
automated test case generation .
in this paper we use pso for mr inference.
to our knowledge it is the rst application of pso in metamorphic testing.
.
search based software engineering harman and jones coined the term search based software engineering sbse and argued that software engineering is ideal for the application of metaheuristic search techniques such as genetic algorithms.
typically hill climbing simulated annealing and genetic algorithms are the three main metaheuristic search techniques that have been widely used in software engineering .
search based optimization techniques have been widely applied to software testing including test suite generation and optimization .
besides software testing search based optimization techniques have also been applied to fault localization program analysis software refactoring cost estimation project scheduling decisions design optimization automated negotiation source code parallelization requirement engineering variability management and so on.
although search based software engineering is important and promising very little research in search based software engineering has used pso as a metaheuristic search technique.
our work is the rst application of search based software engineering for program invariant inference.
.
conclusion and future work in this paper we propose a novel approach to automatically inferring polynomial metamorphic relations by analyzing multiple executions of the same program under test.
to our knowledge this is the rst automatic approach to mr inference.
in particular we view the problem of mr inference as a searching problem and thus use a typical optimization algorithm pso to solve the problem.
then weconducted three empirical studies and got the nding that our approach is able to infer many mrs with high quality in acceptable time which are e ective in detecting faults with no false detection.
in our future we plan to investigate the following issuers.
first we will extend types of mrs in future work.
besides polynomial equations studied in this paper some mrs may be represented by polynomial inequalities.
for the scienti c function log10 x ifx1is larger than x2 log10 x1 is larger than log10 x2 .
relations between programs e.g.
sin2 x cos2 x may also help detect faults in the functionssinandcos.
in future work we will extend the de nition of mrs and investigate how to infer these mrs. second we will improve our approach by investigating other pso algorithms or optimization algorithms.
besides the pso algorithm used in this paper there exist many other optimization algorithms like hill climbing which have been used to solve similar search problems e.g.
testsuite reduction in software testing.
in future work we will investigate some other pso algorithms for the mr inference problem or optimization algorithms in mr inference.
.