beyond the rainbow self adaptive failure avoidance in configurable systems jacob swanson myra b. cohen matthew b. dwyer brady j. garvin and justin firestone dept.
of computer science and engineering university of nebraska lincoln lincoln ne usa jswanson myra dwyer bgarvin jfiresto cse.unl.edu abstract self adaptive software systems monitor their state and then adapt when certain conditions are met guided by a global utility function.
in prior work we developed algorithms and conducted a post hoc analysis demonstrating the possibility of adapting to software failures by judiciously changing con gurations.
in this paper we present the refract framework that realizes this idea in practice by building on the self adaptive rainbow architecture.
refract extends rainbow with new components and algorithms targeting failure avoidance.
we use refract in a case study running four independently executing firefox clients with passing test cases and seeded faults.
the study show that workarounds for all but one of the seeded faults are found and the one that is not found never fails it is guarded from failing by a related workaround.
moreover refract nds workarounds for eight con guration related unseeded failures from tests that were expected to pass and did under the default con guration .
finally the data show that when a failure and its workaround are found con guration guards prevent the failure from appearing again.
in a simulation lasting hours we see over guard activations and no failures with workarounds remaining beyond hours.
categories and subject descriptors d. .
testing and debugging general terms veri cation experimentation keywords self adaptive software con gurable software .
introduction many programs provide users with the option of selecting a custom set of features that can be combined almost arbitrarily at runtime.
for instance a web server like apache permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.provides options to con gure for example permissions serverside include support access logging host name lookup bu er sizes and server capacity.
adding or removing features may improve the robustness of a system improve performance or simply improve the user experience.
a typical con gurable system may have hundreds or thousands of options and this leads to billions or trillions of possible customizations apache has more than 1055possible con gurations .
research on testing con gurable systems has focused on a particular type of fault called a feature interaction fault .
such a fault triggers only under a speci c combination of features .
the problem of feature interaction faults has existed for years .
these types of faults are di cult to detect and therefore often hide in released software.
once deployed they may trigger infrequently making them hard to reliably detect and repair.
self adaptive software systems are a new breed of software that provide adaptation mechanisms that allow continued operation when the system environment changes.
for example if an application utilizes too much cpu it may recon gure resource settings to achieve a desired maximum utilization.
most work on self adaptation has focused on continuous quality attributes allowing techniques from feedbackcontrol to be applied .
recent work by carzaniga et al.
uses self adaptation in a di erent way to avoid executing faulty code after a failure is observed.
their code adaptation automates a kind of workaround avoiding rather than repairing the fault by modifying the code to use alternative libraries.
this approach suggests that self adaptation may successfully utilize discrete events to drive adaptation in addition to using continuous measures of quality attributes.
in prior work we also explored the use of failures to drive adaptation .
in our approach adaptation is performed by recon guring the system through its pre de ned con guration options.
we developed several algorithms for adaptive recon guration and performed a case study using the fault history of the gnu gcccompiler accessed through its bug database.
our ndings demonstrate that the algorithms we developed are able to avoid failures in con gurable systems through adaptive recon guration.
in this paper we take this work further by building a exible framework for failure avoidance via recon guration on top of an existing self adaptive system.
our framework refract recon guration based failure avoidance technique extends the rainbow self adaptive system with new meth permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
fse november hong kong china copyright acm ... .
monitor analyze plan execute observe inputs and outputs check for failures?replay under sampled con gurations?
prepare a guard on con gurationsdistribute the guard choose an untried recon gurationrecon gure and retry detect con guration or guard changesconsult guards?
choose a reversionrevert the con gurationserver client figure refract mape loops ods to monitor for discrete failures strategies for recon guring to avoid failures and to guard against future failures.
refract is able to observe and drive fault adaptation in a set of simultaneously executing target applications.
in this paper we use refract to avoid failures in independently executing instances of firefox.
refract is instantiated with a model of the firefox con guration space and failure avoidance strategies as well as methods that restart the application in a new con guration.
in a case study we evaluate the e ectiveness of refract on a set of real faults for the firefox web browser.
we show that self adaptation for avoidance of con guration dependent failures does nd and then subsequently avoid failures in the system.
while refract is not yet highly optimized it demonstrates the feasibility of the approach failures are diagnosed and firefox is recon gured to avoid them in a matter of minutes.
moreover over time refract can collect information from a set of deployed firefox instances and distribute that information back to those instances.
this allows all of the deployed instances to be protected against future failures when just a single instance encounters a failure.
we also see protection derived from one workaround that incidentally protects against a di erent failure.
the contributions of this paper are a framework refract for self adaptation to avoid feature related failures a prototype instance of refract that supports the firefox browser and the results of a case study using refract to avoid failures in firefox that uses real faults to show the feasibility and potential of the approach.
we describe the main use cases and background for our work in the next section.
we follow that with a description of our framework in section .
we then present our case study and results in sections and .
we discuss related work in section and conclude and present future work in section .
.
overview and background consider a con gurable target application such as firefox running under the control of refract which we gfail pfail econfig e.g.
failure avoid.
select conf.
strategy evalfail target system e1 e2 ... em g1 g2 ... gn p1 p2 ... pn environ.
model arch.
model architectural evaluator adaptadon manager strategy executor knowledge effectors gauges probes feature model faulty avoid config.
figure refract rainbow extension will call firefox refract.
figure illustrates the three self adaptive behaviors that refract supports as mape monitor analyze plan and execute loops .
the top two rows with solid arrows depict firefoxrefract reacting to a failure starting with the client side firefox encountering the bug.
there refract monitors firefox by observing inputs and outputs during execution and checking for failures we focus just on failures in this explanation for simplicity.
when a failure is detected the recorded inputs and the current con guration are sent to the server where the problem is analyzed by replaying it under sampled con gurations .
if the failure can be recreated as reported but the execution passes under some con gurations in the sample the server prepares a guard on con gurations based on the di erences between the passing and failing congurations.
finally it distributes the guard toallrunning firefox refract clients so that they can use it to avoid both the original and similar failures.
because of the way the guard is encoded it can also suggest recon gurations that will take a client out of the situations it deems dangerous.
while the server is characterizing the issue the client looks for a single alternative con guration in which it can retry the problematic inputs.
choosing an untried recon guration can either mean requesting a recon guration from historically e ective guards or if the client can a ord to wait for the server pausing until the new guard s suggestions are available.
once a recon guration is chosen the client recon gures and retries the failure triggering inputs.
monitoring is still in e ect so if the same failure recurs the client side portion of the process may be repeated.
as long as the server optimizes away analysis of duplicate failures the server side portion will not repeat.
the bottom row with dashed arrows depicts the proactive portion of firefox refract.
in the monitor phase the client code detects con guration or guard changes which may indicate that the client is now in violation of one of its con guration guards.
accordingly it consults those guards and if necessary chooses a reversion from those that the guards suggest.
then it immediately reverts its con guration bringing its con guration back to a state the guards consider safe.378the ows in figure execute many times and for many firefox refract clients.
this will drive the system to accumulate a set of guards that characterize the failing congurations for a population of potentially diverse clients.
.
building on rainbow refract s use of the mape loop led us to to leverage an existing mape oriented infrastructure rainbow .
rainbow was designed to check the conformance of system execution against architectural and design assumptions.
rainbow is organized as shown in figure into two layers a a translation layer which is embedded into the target system and b an adaptation and strategy layer which is decoupled from the target.
the translation layer distinguishes three components probes monitor the target system to gather information gauges measure that information to facilitate judgments at the adaptation layer and e ectors modify the target system s behavior.
the higher level layer captures relevant knowledge that is needed to drive adaptation.
typically rainbow keeps a model of the execution environment and the system architecture the latter de nes how the target system can be restructured.
the knowledge and measurements reported by gauges are evaluated to determine if adaptation is warranted e.g.
gauge measurements may lie below thresholds that trigger adaptation.
if adaptation is required a manager selects from a suite of adaptation strategies and tasks the executor with achieving an adaptation.
we describe refract s extensions to rainbow in section .
.
finding workarounds an important component of refract is nding workarounds.
we discuss our prior work in this domain here.
figure is a simpli ed feature model for the firefox web browser.
there are three optional features keyword.enabled privacy.sanitizeonshutdown and browser.autofocus .
we also have a feature browser.startup.page that is required in all instances but that must take only one of three values or .
suppose the system has the following starting con guration.
it has enabled both privacy.sanitizeonshutdown and browser.autofocus but has disabled keyword.enabled .
in addition browser.startup.page is set to .
if a failure is encountered at runtime we want to move to another con guration to avoid this problem.
garvin et al.
proposed a brute force n hop algorithm that tries each possible con guration n hops away from the starting one.
for instance a hop variant of this algorithm would rst include keyword.enabled leaving all other features as is.
then it would remove this feature again and remove privacy.sanitizeonshutdown etc.
at each step it would re run the use case to determine if it now passes and keep track of all passing con gurations.
these are possible workarounds.
assume that the setting of for browser.startup.page is a faulty con guration option.
two passing con gurations would be detected by the hop algorithm.
this would include two con gurations with the original settings but browser.startup.page set to either or .
thus the setting of is determined to be potentially faulty and it can be guarded against it in future runs.
recon guring the browser to one of the two passing con gurations allows execution to proceed from the failure.
this single option con guration is a simple case for illustration purposes but con gurations firefox keyword.enabled!privacy.sani zeonshutdown!browser.autofocus!brrowser.startup.page!
!
!
!
optional mandatory exclusive or figure example feature model requiring as many as option changes have been found in our studies .
one of the advantages of a brute force approach is that we stay close to the original con guration and will maintain most system functionality from prior to the failure.
in preliminary work we found the hop algorithm to be e ective in avoiding a large number of failures.
the hop variant found additional workarounds but only for failures that already had hop solutions.
however scalability is limited.
the n hop algorithm grows exponentially with respect to n hop applied to a large con gurable system was times slower than hop.
refract is designed to run online and to be applied to clients with large complex feature models.
consequently we explore the use of new con guration sampling algorithms to better balance cost e ectiveness in searching for con guration workarounds in the next section.
.
implementing refract in this section we rst present refract as pseudocode and elaborate on the sub algorithms responsible for characterizing failures and suggesting workarounds.
then we detail how refract is realized within rainbow building on the concepts in figure .
.
failure avoidance in refract algorithm shows refract at a high level.
the system as a whole maintains a set of deployed clients line a feature model line and a set of guards line the client and guard sets are initially empty.
when clients come online their probes and gauges are initialized line and their guard sets are synchronized with the server s line before they are added line .
likewise probes and gauges are torn down line after clients are removed line .
failures are handled by verifying replicability lines and and calling a customizable sub algorithm findguards line which we discuss in section .
to create new guards.
the guard update triggers a reaction to the failure on the corresponding client as well as proactive avoidance on other clients via a test for guard violating con gurations line .
the subalgorithm suggestions corresponding to the findguards implementation produces possible ways out of such con gurations the best chosen according to a client speci c tness function line and applied line .
.
sampling techniques to find workarounds forfindguards we have explored four di erent sampling strategies.
one outlined in considers all con gurations within a xed number of hops single feature con guration changes from the reported failing con guration.
in this379algorithm refract failure avoidance initially let d ?
the set of deployed client systems let m the feature model let g ?
the set of con guration guards when a client dcomes online instantiate an error probe and gauge on d match d s copy of gto the server s let d d fdg when a client dgoes o ine d dnfdg tear down the error probe and gauge on d when a client dencounters a failure from inputs iunder con guration c replay iunder con the server ifa failure is observed then let g on both the server and the clients g findguards i c m computed on the server end if when a client dchanges to con guration cor a client s copy of gchanges ifcviolates a nonempty set of guards g0 gthen let r a recon guration chosen from suggestions g apply rtoc end if strategy we systematically change all n feature options one by one.
two more random sampling and covering array sampling initially sample independently of the failing con guration either randomly or using a covering array and then if a workaround is found move to recon gurations closer to the original via a recon guration minimization step.
the last a genetic algorithm whose tness function aimed for con gurations near the failing one did no better than random sampling with minimization and so is not presented here.
random sampling.
random sampling repeatedly generates a random con guration from the feature model ignoring the current con guration resampling in cases where feature constraints are violated.
in preliminary work we experimented with this algorithm and found that small samples around congurations found fewer workarounds overall than a one hop sample but occasionally found some workarounds that neither one nor two hop samples could nd.
while three times slower than the one hop algorithm random sampling was times faster than two hop exploration.
increasing the number of iterations up to random found more workarounds overall than either one or two hop sampling and still maintained an order of magnitude performance advantage over the two hop approach.
thus for the types of conguration spaces we experimented with random seemed to strike a good cost e ectiveness trade o .covering array sampling.
covering arrays have been used extensively for testing highly con gurable software systems .
a covering array is a sample that ensures at least one t combination of con guration options for all possible valid t combinations in the con guration space.
in the simplest case tis and such a sample is often called a pairwise sample.
for the covering array variant of our failure avoidance algorithm we generate a t way covering array for the feature model and this constitutes our sample of workarounds to try.
there has been research on combining delta debugging with covering arrays and using covering arrays to nd a minimal failing test for which reason we believe that this approach makes sense.
in our preliminary work we found that way covering arrays did not work as well as random sampling.
but when we combined two di erent way arrays together more workarounds were found than with random sampling and in less time.
our best sampling strength for nding new workarounds consistently was a 3way covering array but this signi cantly increased cost.
as with the number of iterations for random here sampling strength exposed a cost e ectiveness trade o .
minimizing workarounds.
because the random and covering array sampling techniques can move a client arbitrarily far away from the conguration it started in we have implemented a minimizer using the delta debugging technique but adjusted to seek a minimal recon guration that passes not fails a test case.
to illustrate minimization consider the feature model in figure and a failure caused by browser.startup.page set to .
suppose we randomly select a con guration where privacy.sanitizeonshutdown andbrowser.autofocus are toggled and browser.startup.page is changed to .
since browser.
startup.page must be for failure this con guration allows the system to pass the test case.
unfortunately it is three hops from the starting con guration.
the minimizer divides the recon gurations into two groups.
in this example the workaround the leaves a value of for browser.startup.page from the starting con guration will fail the other con guration will pass.
in that latter con guration some of the previously changed values were left untouched so the hop count is decreased.
the process is repeated until the minimal one hop workaround is found.
in this simple example the minimization is actually more expensive than one hop sampling.
but as the feature model scales sparse sampling and minimization scales better than the direct n hop technique.
.
modifications made to rainbow refract extends rainbow to support detection of system errors and failures their evaluation and their avoidance via system recon guration.
refract extends rainbow s translation layer.
new probes pfail can either detect system failures e.g.
uncaught exceptions oracle violations or internal errors which might be caught as contract or assertion violations that remain enabled during deployment.
this arrangement provides a means of avoiding failures by recon guring before errors propagate to output.
new gauges gfail assess the severity of a failure error.
for failures a binary measure might be appropriate but ner measures may be appropri 380ate for internal errors or when developers have information about the impact of classes of failure error.
finally conguration e ectors econfig function by modifying con guration settings e.g.
in les and performing micro reboot of a ected system components or by modifying target con guration through programmatic apis .
one of the major bene ts of the e ector is that the results of searching for a workaround can be shared across all clients.
this means that if one client encounters an error and nds a workaround another client will gain knowledge of the workaround and improved its guard.
sharing information allows for failure avoidance without needing a user to actually encounter the failure themselves.
refract enriches the knowledge sources to include the target feature model local preferences of con gurations to avoid and accumulated global information on faulty con gurations .
unlike rainbow in refract this knowledge is maintained by communication among multiple refract instances there can be a set of distributed communicating client side refract components.
to date refract has evaluated failures eval fail to determine the need for adaptation by applying an eager strategy the presence of any failure gauge reading triggers adaptation.
failure evaluation that incorporates error failure severity measures and history permits controlling tradeo s between the cost of recon guration and the exposure to future failures.
this is also supported.
refract might select from a range of con guration strategies .
for example refract may also compute a safe con guration based on all target client failure reports that could be switched into for rapid failure adaptation.
to date refract has focused on executing a failure avoidance strategy that seeks to nd failure avoiding con gurations that are close to the current target con guration.
the intuition is that this will preserve behavior while avoiding failures.
this behavior can also be modi ed.
.
case study in this section we present a case study to evaluate the feasibility of refract.
we answer three primary research questions.
associated artifacts from this study can be found on our website.
rq1 how e ective is refract in nding workarounds for failures?
rq2 to what extent can guards protect against previously seen failures?
rq3 how does the number of system failures vary over time with refract?
.
client program we selected a highly con gurable system for this study firefox version .
firefox is widely deployed has a large bug database and automated testing framework and has been used in prior research on testing con gurable systems .
it also has an automated testing framework mozmill that comes with regression tests and can simulate clients running firefox use cases.
extracted the firefox feature model see our webpage for the complete model by pruning from the con guration options found in the preferences page about config .
options removed from this set were the hardware speci c security we leave evaluation of security features as future work within a controlled sandbox plugin extension and font options as well as string and integer valued preferences for which a clear set of allowable values was not obvious such as those that change storage space or time delays.
a core set of options remained binary and ternary.
the total con guration space therefore has an order of around .
.
client use cases each client use case in our study is based on a firefox test case.
we selected the functional category of tests from the most recent version of firefox version and ran all tests on firefox .
did not pass due to requirements changes between the two versions applicable tests remained.
to these we added seven that include assertions about which features are enabled tests that give the same e ect as a seeded con guration dependent fault.
each assertion corresponds to a fault in version whose report in the firefox bug repository included a recon guration workaround some of which were taken from .
the full set of test cases is on our website.
as an example one of the added seven is based on firefox bug in which firefox displays a tab bar on popups when browser.tabs.drawintitlebar is set to true the tab bar should only be displayed on a main window .
.
failure avoidance algorithms in our initial study on gcc the random algorithm and a way covering array were the two top contenders when combined with the minimizer.
we also found that the brute force one and two hop algorithms work well but can be more costly time wise.
but our gcc feature model had only options and the test cases averaged less than .
seconds whereas firefox has nearly twice as many options and tests taking roughly seconds each.
the hop based algorithms would not be suitable when the clients wait for replies from the server.
therefore we chose random sampling stopping at the rst workaround found in up to ten iterations and a way covering array with con gurations.
additionally our setup prefaces each server side analysis with a loop over the already found workarounds.
if one succeeds then the e ector will report that a workaround has already been discovered and bypass the failure avoidance algorithm.
.
simulation details we implemented a prototype of refract using four firefox clients each with its own instance of mozmill built on top of a version of rainbow provided by the developers at cmu .
in the simulation the rainbow master starts rst followed by each of the clients.
once all of the delegates are instantiated the gauges activate and the monitoring begins.
whenever a mozmill instance reports a failure the corresponding monitor creates an error le and records the con guration under which that failure occurred.
the le s update triggers the analysis phase and the mape loop proceeds as described before.381algorithm algorithm for running simulation on client let c the current con guration let g ?
the set of guards let f false a failure has not been discovered while time remains do update gfrom the server let r a random single option recon guration applying to c ifgpermits rthen change cbyr end if let m a random mozmill test let f whether mfails under c iff a failure has been discovered then send mandcto the server and wait for a reply ifa workaround con guration c0was found then log c0as workaround for m else if the failure could not be replicated then log the failure of munder cas not replicable else if a workaround could not be found then log that munder chas no current workaround end if let f false end if end while we ran the simulation on a cluster of amd cpus running centos linux.
each firefox client and the master were run on di erent nodes and housed in separate directories to ensure independence of con gurations.
algorithm shows the client side portion of the simulation process.
each client keeps track of its current con guration line the known guards line and whether a failure has been encountered line .
to simulate gradual changes in client con gurations random single option recon gurations are periodically applied line though they may be prevented and thus e ectively reverted by the known guards lines which are kept up to date line .
to simulate ongoing use cases clients randomly select and run tests from the mozmill test suite lines and .
in case of a failure the client opts to wait for a guard from the server line logging the corresponding workaround if it exists lines and or the reason why one was not found if not lines .
the whole process repeats until the allotted time expires line .
we note that it is possible in a real scenario for a user to continue working once a failure has been encountered however for the purpose of this simulation we wanted to keep the clients with failed tests isolated to ensure we can analyze the data with more accuracy.
future work will implement this additional aspect of the work.
we are also only using a single master and one failure avoidance algorithm per run.
this means that failures can only be addressed one at a time in the order they are received.
this can cause performance bottlenecks but the algorithm can be parallelized in the future.
the starting con guration is kept as default for one of the clients and randomly varied by up to ve con guration options for the other three clients.
we want to simulate what we consider a realistic user client base and do not think that real users will be very far from the default con guration.table count of workarounds found for the seeded failures by technique.
data is accumulated over ve runs except the hour run which was run once.
firefox bug r10 3hr r10 24hr 2ca 3hr as workarounds are found the con guration information is deployed to each of the clients which allows them to update their own personal guard.
.
metrics to answer each of our questions we mine the logs to keep track of the the run time the errors encountered and whether a workaround is found.
we also count the number of guards associated with particular failing combinations and map these back to the test that would have created that guard guards are not necessarily related to a speci c use case but we can tell which use case created them .
in addition when a non seeded failure is found we evaluate whether or not it is a real failure workaround if not we consider this a false positive .
.
threats to validity we have several threats to validity of this study.
first we have only run this on firefox so we do not know if it will generalize.
however we have evidence from the prior work on gcc that it behaves similarly with respect to a post hoc analysis.
second our faults are seeded and most are due to a single con guration option.
but these are all based on real faults that have been reported in the eld and the last seeded fault see our discussion of this threat later is caused by the combination of two options.
to reduce the threat that our implementation is in error we re ran experiments several times and three of the co authors cross checked results manually.
our data is available online so that the community can check our results as well.
finally di erent metrics could have been used but the ones we have selected address our research questions in a very direct way.
.
results we ran simulations for both the random with ten iterations r10 and way covering array 2ca workaround algorithms ve times for three hours.
we also ran a longer hour run of the r10 algorithm.
we use this data to answer each of our research questions in turn.
.
rq1 how effective is refract in finding workarounds for failures?
we rst examine data from the seeded test cases labeled by the firefox bug number that they simulate .
table shows the data from random failure avoidance with iterations on ve hour runs r10 3hr as well as a single hour run r10 24hr and way covering array failure avoidance on ve hour runs 2ca 3hr .
for each run we evaluate whether or not it found at least one workaround and total across all ve runs.
for the hour run we have382table unexpected failures with workarounds for mozmill tests.
an fp indicates a false positive.
the number indicates how many times this was found across all runs of the technique.
mozilla test workarounds fps r10 r10 2ca 3hr 24hr 3hr plockupsblocked popupsallowed clearformhistory ssldisablederrorpage fp addmozsearchprovider opensearchautodiscovery restorehomepagetodefault.
fp submitunencryptedwarning autocompleteo pastelocationbar fp settocurrentpage fp enableprivilege table time in minutes to rst workaround and to workaround not found for hour runs.
there are con gurations in the 2ca.
sim run time to w time to n r10 3hr .
n a r10 3hr .
n a r10 3hr .
.
r10 3hr .
.
r10 3hr .
n a avg.
r10 3hr .
.
2ca 3hr .
.
2ca 3hr .
.
2ca 3hr .
.
2ca 3hr .
n a 2ca 3hr .
.
avg.
2ca 3hr .
.
only one data point.
for six of the seven bugs workarounds are found at least once.
the hour run using random recon gurations nds six of these.
the r10 3hr and 2ca3hr always nd workarounds for the rst and third bug.
the 2ca also nds workarounds every time for the second bug .
for the others some of the runs nd workarounds and others do not.
the covering array has slightly better consistency.
the last bug in the list never ran a test that failed during our simulations and therefore it never looked for a workaround.
in fact in each instance where we did not nd a workaround it was because the test did not fail during the span of the simulation.
finding a failure requires the user to select a con guration and test combination that will fail.
like a long running deployed execution the longer simulation provided more chances for this to happen.
we examined bug more closely.
first this bug requires two con guration options to be used together before it will fail.
therefore it may take longer to trigger a failure.
we also saw that one of the con guration options that is required to make this test fail is in the guard created by bug speci cally the con guration setting of browser.startup.page as .
this means that once bug has been seen and a workaround is found bug will always be prevented from failing so we should not expect to see it fail as long a has put this guard in place.
thisconcurs with the results in garvin et al.
on feature locality i.e.
that failures will be localized among a small number of feature options.
therefore one failure guard should help prevent other failures as well.
in addition to the workarounds we found for the seeded failures we also obtained a set of workarounds for tests that were not supposed to fail these were from the passing mozmill regression test suite .
we examined each workaround reproducing the tests several times to determine if it is a true workaround i.e.
the test actually fails and then the new con guration allows it to pass .
in some cases we determined that the original test should not have failed during a run and its failure was an anomaly for some reason it did not setup and run correctly .
we mark these as false positives.
in the case of a false positive the rst change to a new con guration will pass since the test should not have failed anyway and will create an unnecessary guard.
we want to avoid these since it might reduce the usable conguration space by guarding valid con gurations.
table shows the tests that failed and indicates whether or not they are real failures or false positives.
over all of our runs we found workarounds for tests that were unexpected four were false positives.
we also see an interesting locality result here as well.
the guard for addmozsearchprovider and opensearchautodiscovery both fail with bidi.direction set to and pass when the value is set to .
therefore once we nd one workaround we guard against the other.
table shows the time to nd a workaround w or the time taken to nd no workaround n for the hour runs in minutes.
the top half of the table shows the time to workaround for each of the r10 runs with an average of .
minutes.
to determine that a workaround is not found we need on average .
minutes.
this can be a performance bottleneck and suggests the need for parallelism in the execution of tests for our samples fortunately this is embarrassingly parallel so we would expect the r10 times to be reduced by a factor of or better.
if we now examine the data for the 2cas we see that the average time to workaround is only slightly longer than the r10 samples.
considering that the ca has more than twice as many con gurations this is encouraging.
since we are stopping at the rst workaround we seem to be able to nd a passing one within a similar amount of time.
however the time to workaround not found is minutes on average.
again this implementation bottleneck can be alleviated through parallelism where we would expect similar or better reductions than for r10 since there are more con gurations here.
summary for rq1 based on this data we conclude that we can nd workarounds for all but one of the seeded failures but that one is guarded against and in addition we nd additional failures with workarounds that we can reproduce.
the 2ca is slightly more e ective than the r10 runs when the system runs for hours.
however the time to nd that a workaround is not possible with the current implementation is twice as expensive for 2ca than r10.
.
rq2 to what extent can guards protect against previously seen failures?
tables through show data for our simulations broken down into time blocks.
we parsed the data for each of our hour runs into minute time blocks and into hour time periods for our hour run.
we show two runs for the r103 hour and 2ca 3hour runs and for the r10 hour run383table random hour run two worst .
minute intervals shown.
p pass f failure w workaround a workaround already found n no workaround found g guard.
test guards expected to fail fw 2p 4p 5p pg 4p 2p 8p g7pg3p 3p 4pg2p p 2p p 5p 5p 3p 3p 4p 2p p 5p 5p fwp 3p2gp 2p 3p 5p 3p 5p 2p 6p 2pgp pg5pg p 3p p 4p 5p p p 3p 4p 4p 6p p 2p 4p 2p 3p 4p 6p 3p 8p 4p 2p 6p p 2p 4p p 4p p 3p 2p 5p 2p 2p 5p 7p 7p 4p 5p 4p 4p 3p 2p 6p 6p 3p not expected to fail clearformhistory 4p 3p 4p 3p fpw5p 3p p 5p p 3pg 4p gp popupsblocked 5p 3p p 4p p pf2pwp 6p 3p 5p 6p 2p 5p addmozsearchprovider 3p 3pf pw2p p 4p 4p 7p 6p 5p 4p 4p 3p total guards table random hour run one best .
minute intervals shown.
p pass f failure w workaround a workaround already found n no workaround found g guard test guards expected to fail fw 2p 2p p p 2p 3p 3p g 3p 5p 3p f fwapg 3p p pg 4p 4p 4p 2p pg 2p 6p fwpg g 5p 3p 4p 2p 2p 2p 4p 3p 3p pg p p 2p p 4p p pfw 2p 3p p 3p 2p 5p fpw2p 3p 6p p pg 3p pg 3p 2p p 2p 2p 2p 2p p 3p 2p 4p 3p 4p 3p 4p 2p p 2p 2p p 2p not expected to fail opensearchautodiscovery p p 6p 5p 3p 2p 3p 2p 5p pf w3p 2p ssldisablederrorpage fp pa 2p 3p 2p 2p 5p 4p p 3p 3p untrustedconnectionerrorpage fn p 3p 4p 3p p 2p p 2p 3p 2p 2p total guards other data is online and appears to be similar .
we tried to pick one run that was best in terms of nding the most workarounds and one that was worst for each technique.
in these tables we use a pto mean that a test ran and passed an fto mean that a failure occurred during that time an n to show that no workaround was found and a w to mean that a workaround was found.
finally we use a g to represent that a guard was activated.
we use numbers to summarize the times each occurred within that block of time.
for instance fw2g would indicate that during this period a failure was seen once a workaround was found and the guard was activated times.
we only show data for the seven seeded faults and any additional unexpected failures with or without workarounds that were seen.
we have shaded the cell where the rst workaround or a workaround already found is seen to help visually see the timeline.
in most cases once we nd a workaround we do not see a failure again.
we often do see the guard activated at least once showing us that the guard is working.
one anomaly in this data is seen in the rst of the two 2ca tables table .
for bug and bug workarounds are found within the rst minutes.
in we also see a guard activated at minutes.
but we see a new failure with no workaround for these in the and time periods.
we examined our logs and saw that these are both on the same client.
we ran the failing tests and con gurations manually several times and we could not reproduce the failure.
we do not know what caused this to happen but we were able to con rm that these failures werenot related to con gurations that should have been guarded.
consequently we consider these false failure reports.
we show the sum of guards activated for each test during the simulation in the last column.
we see at least and as many as guard activations in a hour period.
in the hour run we see guard activations.
this indicates times that a client was prevented from entering a bad con guration.
summary for rq2 we can conclude that the guards are activated and appear to be preventing target applications from experiencing failures after a workaround was previously found.
.
rq3 how does the number of system failures vary over time with refract?
to answer our last research question we examine tables through again.
we see that the number of failures is reduced over time as the guards start to activate .
in particular for the hour run after hours all of the workarounds are found for the seeded faults one more workaround is found at hours for an unexpected failing test that is difcult to expose.
there are some failures lower part of the table for which we do not nd workarounds and these are the only remaining failures after hours.
figure depicts the trends of these data aggregated across all of the hour runs.
the trends are clear.
early in the runs failures occur but they are reduced rather quickly and the activation of guards can be seen as the mechanism for achieving that reduction.384table 2ca hour run one best .
minute intervals shown.
p pass f failure w workaround a workaround already found n no workaround found g guard test guards expected to fail f wp 2pg 5p 2p 3p p 2pf3pnp 5p 5p pg fw p p 4p 2p 4p 2p 3pfp pn3p 3pg 3p 5p f 2f w2a5p 2pgp 4p 2p 7p 2p 5p 2p 6p 2p p p 3p 2p fwp p 2p 3p 4p 2p 5p pgp fw 2p g4p gp 5p 3p 3pg pg2p g4p gp 2p p fwp 2p 5p 2p p p 3p 2p 6p 2p 2p 2p 3p 2p 5p 4p p 3p 3p 2p 4p not expected to fail clearformhistory 4p p 2p 2p 3pf 3p pn2pfp pw3p 4p pg 2p 4p submitunencryptedinfo p 6p 3p p 6p 3p 3pf pw 6p 3p total guards table 2ca hour run one worst .
minute intervals shown.
p pass f failure w workaround a workaround already found n no workaround found g guard test guards expected to fail fw p 3p 2p 2p 2p 3p p p 2f wpa gp 2pg 2p 2fwa 3p 2p 3p 2p p 3p 2p 2p p 2pf2p wp 2pgp 3p p 2p p 3p 2p 3p 3p p p 2p p 2p 2p p p p p 3p p not expected to fail autocompleteo p 2p fpw3p p p p disableformmanager 3p fn 2p p 4p 2p total guards summary for rq3 we conclude that refract s combination of failure adaptive recon guration and guarding of con guration changes reduces the failures experienced by target applications over time.
moreover this study suggests that the failure rate for con guration related faults drops relatively quickly over time and stabilizes with executions that are free of con guration related failures .
related work there is a large body of research on both self adaptive systems and on testing highlycon gurable software .
self adaptive software came out of research on autonomic computing .
early work focused on self healing such as that of dashofy et al.
.
other work aims to improve the adaptation process particularly in dealing with uncertainty .
the work of georgas et al.
looks at support fo architectural con gurations and zhang et al.
and garlan et al.
focus on validation.
in the work by elkhodary et al.
they adapt based on features.
while these features are similar to ours the adaptation uses quality of service attributes.
rainbow is a framework that uses the mape loop and architectural constraints to adapt .
the work of uses self adaptation in software product lines a type of con gurable software system.
the most closely related work on con guration aware adaptation is our own but we did not implement our techniques on a running system.
fixing faults automatically is a related thread of work.
perkins et al.
deploys patches to running systems.
there has also been work on adapting software to avoid failures using standard apis or using alternative but equivalentexecution sequences .
weimer et al.
nds faults in systems using test cases and then uses an extended form of genetic programming to x the code.
carzaniga et al nd workarounds which are code level alternate library calls.
this technique is similar to ours in its goal and the requirements to nd a workaround.
but our technique uses a feature model and is external we do not touch the code .
in recent work casanova et al.
use rainbow to diagnose faults on web pages.
this is closely related however they are not using con gurations as a workaround strategy.
there is also research on testing highly con gurable system .
many sampling techniques have been used for selecting a subset of con gurations for testing such as covering arrays for sampling con gurable systems and software product lines reisner et al.
use symbolic execution of con gurable software systems to gather evidence that we have a much smaller feasible con guration space possible then previously thought.
last there has been work on distributed quality assurance that uses a central client to distribute tests and gather data on faults across many sites and locations.
the work of yilmaz et al.
uses this for fault characterization but does not adapt to nd new passing con gurations.
our framework is unique in that we do not target the client code but adapts externally we use discrete failures to trigger adaptation and we guard against future recongurations into known bad states by using the distributed nature of our system to improve community knowledge.
finally we have built a working implementation that uses the mape loop to monitor analyze plan and execute.385table r10 hour hour intervals shown.
passes are not shown.
f failure w workaround a workaround already found n no workaround found g guard test guards expected to fail 2fwag g 2g g g 2g g 2g 2fwag 3g 5g 3g g 4g 2g 3g 2g 2fwag 2g g g g g g 3g fwg 5g 2g g 2g 3g 2g 2g fw 4g g g f wg g 4g g 2g 2g g g g g g not expected to fail clearformhistory fwg 3g 5g g g g 3g 3g 2g g 3g popupsallowed f w2g 2g g 4g g g 3g g 2g 4g addmozsearchprovider 2g fwf a2g 4g 2g g 3g 3g 3g restorehomepagetodefault fw g g 5g not expected to fail no workaround found gobutton.js fn closedownloadmanager fn fn fn autocompleteo fn disableformmanager f nfn fn fn opensearchautodiscovery fn defaultsecurityprefs fn searchviafocus fn ssldisablederrorpage fn homebutton fn total guards figure percent passing and failing tests over time.
line shows number of guards activated.
all data accumulated over runs.
.
conclusions in this paper we have presented refract a self adaptive framework for avoiding failures in con gurable systems.
refract monitors the system for failures and then triggers an algorithm to search for a passing recon guration close to the original.
it then updates a guard which prevents future clients from recon guring into known bad states.
in a case study using firefox clients we were able to nd workarounds for all but one of our seven seeded faults and for eight native failures.
the only missed seeded fault never manifested as a failure in our study.
that missed fault was related to another and by encountering the other failure guards would be put in place to block clients from the conguration necessary to expose the missed fault.
in future work we will explore ways to parallelize the workaround algorithm so to use more clients and to come to asteady state sooner.
we will also explore alternative algorithms examine making the utility function continuous by weighting the error rather than using a binary value and apply refract to other client applications.
finally we plan to incorporate user input into our decisions with respect to guards.
.