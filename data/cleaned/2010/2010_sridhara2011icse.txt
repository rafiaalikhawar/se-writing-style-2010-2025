automatically detecting and describing high level actions within methods giriprasad sridhara lori pollock and k. vijay shanker department of computer and information sciences university of delaware newark de usa gsridhar pollock vijay cis.udel.edu abstract one approach to easing program comprehension is to reduce the amount of code that a developer has to read.
describing the high level abstract algorithmic actions associated with code fragments using succinct natural language phrases potentially enables a newcomer to focus on fewer and more abstract concepts when trying to understand a given method.
unfortunately such descriptions are typically missing because it is tedious to create them manually.
we present an automatic technique for identifying code fragments that implement high level abstractions of actions and expressing them as a natural language description.
our studies of java programs indicate that our heuristics for identifying code fragments implementing high level actions are widely applicable.
judgements of our generated descriptions by experienced java programmers strongly suggest that indeed they view the fragments that we identify as representing high level actions and our synthesized descriptions accurately express the abstraction.
categories and subject descriptors d. .
distribution maintenance and enhancement documentation general terms algorithms documentation keywords program comprehension documentation .
introduction it is almost axiomatic that software maintenance is resource intensive and program comprehension required for maintenance is difficult and time consuming especially for a newcomer i.e.
a developer faced with an unfamiliar system or an unfamiliar component of a known system.
one approach to helping program comprehension is to reduce the amount of code that a human has to read.
for a given method a human could potentially focus on fewer and more abstract actions at a time to understand the code if the code this material is based upon work supported by the national science foundation grant no.
ccf and ccf .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.segments that implement higher level algorithmic steps were delineated and described at a more abstract level.
however such internal documentation is often missing or obsolete because it is tedious to manually create and keep current.
additionally extract method refactoring could also condense a method s code size by replacing the extracted method body statements by a method call however this transformation requires tedious analysis to maintain the original semantics.
in this paper we present the first known technique to automatically identify groupings of statements i.e.
code fragments that collectively implement high level actions and to then synthesize a succinct natural language description to express each high level abstraction.
by a high level action we mean a high level abstract algorithmic step of a method.
for example our algorithm will automatically deduce that the code fragment from lines to in listing implements a more abstract action and then synthesize the natural language description to represent that action 9for int x x vattacks .
s i z e x weaponattackaction waa vattacks .
elementat x float fdanger getexpecteddamage g waa i f fdanger fhighest fhighest fdanger waahighest waa 17return waahighest listing lines implement high level action synthesized description get weapon attack action object in vectorattacks with highest expected damage the resulting phrase reduces and factors out the details of the set of individual statements that implement the high level algorithmic step being performed.
our algorithm takes a java method as input and outputs the method with natural language phrases associated with blocks of statements identified as implementing high level actions.
we separately analyze sequences of statements conditional statement blocks and loops within the method.
to delineate a grouping of statements that collectively implements an identifiable high level action we leverage both programming language syntax and semantic information as well as linguistic clues embedded in the developers naming of entities.
to synthesize succinct natural language descriptions to express the abstraction we utilize advanced text 1for each of the listings that we use to illustrate challenges and aspects of our technique throughout this paper we provide the automatically synthesized description.permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
101generation techniques.
our automatic system involves analysis of source code only requiring no execution information and thus can be applied to incorrect incomplete and unexecutable legacy systems.
since the analysis is local to a method this capability can be integrated easily into an ide to provide current descriptions as the software developer begins editing a given method.
our synthesized descriptions have many uses for software maintenance beyond a tool to help with program understanding.
we are able to identify potential candidates for theextractmethod refactoring and additionally to suggest a good name for the extracted method using the action theme i.e.
direct object and other arguments i.e.
indirect objects prepositional phrases ... that are identified to synthesize a description.
this same information can be used to identify poor method names and suggest better naming that includes both action and theme.
the phrases could be used to verify traceability results as well as to generate internal comments for legacy codes.
the high level actions that are extracted and expressed as phrases can be used to generate smoother more succinct method summaries than previous work .
we also believe that code search can be improved by using the high level action descriptions to associate higher level actions with the methods containing them providing new verbs for the queries to match in the code.
for example it might be easier to locate code that performs a max after identifying and describing a given code fragment within a method that implements this higher level action.
the main contributions of this paper are a set of algorithms to identify code fragments of sequences conditionals and loops within a method that implement high level abstract actions rules to synthesize succinct accurate natural language descriptions expressing the high level actions validation of the prevalence and potential reduction in detail with our system applied to .
million methods from java programs and developer judged precision of the automatically identified high level actions and associated descriptions.
independent judgements among experienced java developers on identified code fragments strongly confirm that the code fragments we identify as high level actions are indeed abstractions and that our synthesized descriptions accurately express these abstractions.
illustrations of how the synthesized descriptions can improve four client tools for software maintenance .
problem statement in this paper we are addressing the problem given the signature and body for a method m automatically discover each code fragment that implements a high level abstract action comprising the overall algorithm of m and accurately express each high level action as a succinct natural language description.
consider the example makeline in listing .
this method is composed of three high level actions create a horizontal box add the given components to the box and return the box.
one can view any method as representinga high level action itself especially from the perspective of its callers.
since there is nothing to be gained by labeling individual method calls or statements as a high level action we instead focus on the problem of grouping multiple statements that collectively implement a high level abstract action.
in the example we seek to automatically capture that the three statements together implement the second algorithmic step of the method.
box makeline jcomponent f jcomponent s jcomponent t box onelinebox box .
createhorizontalbox add components onelinebox .
add f onelinebox .
add s onelinebox .
add t 8return onelinebox listing high level action as a sequence lines to add given components to oneline box there may be a myriad of types of statement groups that might represent high level actions.
this paper examines three kinds of statement groups corresponding to major control structures within a method a sequence of statements that when taken together represents a single high level action a conditional block that performs an action with subtle variations based on the condition code patterns that are commonly implemented using loop constructs that constitute a high level action in this paper we focus on identifying arbitrary statement sequences in which each statement is performing a similar action.
we do not solve the problem of identifying groupings of statements where each statement performs a different kind of sub action of a given high level action such as a swap operation.
these sequences require looking for a specific known syntactic template or domain knowledge.
instead we focus on identifying high level actions composed of a set of similar actions with some differences in the actions arguments such as in listing without a predefined set of syntactic templates.
we focus on similar kinds of high level actions in conditionals except the similar actions now occur in different branches creating a different set of challenges for identification and synthesis.
for loops we examine specific high level actions based on templates the major challenge for handling loops is synthesizing a good description for the high level action from the loop information.
identification and text representation synthesis have challenges specific to each of these types of statement groups.
we describe the specific challenges within each subsection below.
note that techniques for identifying fragments representing high level actions this work and those statements important for summaries are mutually exclusive.
additionally rules for generating text for a code fragment are different from those for a single statement .
text generation for a sequence builds on single statements with extension for a combined phrase however loops and conditionals go beyond combining phrases for component statements instead having to address control structures used in different ways ex getmaximum in listing .
.
detecting and describing high level actions our approach to automatically detecting and documenting high level actions follows the process illustrated in figure .
the first phase a preprocessing phase involves traditional program analysis to build the program representations that capture program syntax and semantics and linguistic information used by our analysis.
we then traverse the method s abstract syntax tree and use both program structure and linguistic information to identify code fragment candidates for high level action abstraction.
for each candidate high level action fragment we analyze the code fragment to identify the action theme and secondary arguments to describe the high level action and then generate the natural language phrase based on the kind of code fragment sequence conditional or loop.
each remaining subsection describes the individual phases of our approach.
.
structure and linguistic information both the analysis to detect code fragments implementing high level actions and analysis to synthesize descriptions use information in the abstract syntax tree and control flow graph representations of the method under analysis.
both analyses also use information from naming conventions and linguistic knowledge gained from observations of thousands of java programs.
in particular we use information from the control flow graph and data and control dependences along with textual clues which we obtain from the software word usage model swum of the program.
before any word usage information can be extracted from names used in the program identifiers must be split into component words.
we use camel case splitting which splits words based on capital letters underscores and numbers e.g.
childxmlelement would be split into child xml element and aspects of more advanced splitting .
as in any system that uses linguistic information our technique will be hindered if the source code does not include at least some meaningful variable method and type names.
we believe this requirement is reasonable given that developers tend to choose long and descriptive names for highly visible program entities such as methods and types .
abbreviations in variable and type names can reduce the readability of the generated description and accuracy of our analysis e.g.
button butselectall mouseevent evt .
we use techniques from prior work to automatically identify and expand abbreviations in code.
the software word usage model swum provides us with the necessary linguistic information beyond individual word frequencies necessary to both identify and express high level actions.
swum not only captures the occurrences of words in code but also their linguistic and structural relationships.
swum has been successfully used in concern location and summary comment generation for java methods .
particularly we use swum to obtain the action theme and optional secondary arguments of a statement grouping to generate succinct and smooth descriptions and in conjunction with program structure we use this information to identify code fragments that implement a high level action.
consider the example method signature list.add item i which can be captured by the phrase add item to list.
in this example the action is add the theme is item and the secondary argument is to list .
further in this example buildgamemenu buildviewmenu buildordersmenu buildreportmenu buildcolopediamenu listing different method calls can form a fragment in a sequence lines build menus contentpane .
add endedpanel contentpane .
add bidpanel contentpane .
add endingpanel contentpane .
add buttonok listing same method calls need not form a fragment in a sequence fragment is lines only add panels to content panel the location of the theme is the given parameter while the location of the secondary argument is the receiver object.
in addition to these locations a theme or secondary argument can be the method name itself e.g.
buildmenu lastly we leverage our previous work in which develops a strategy for variable lexicalization in which descriptive noun phrases describing variables are generated with modifiers extracted through type information.
.
sequence as single action challenges.
we focus on identifying sequences of statements with similar actions indicated by similar method calls.
the basic identification challenge is to determine whether a given statement is similar to its successor statement and thus can be integrated with it to build a fragment.
to integrate two statements we need to define a notion of similarity between the statements actions.
from listing one might think that statements with the same method being called can be integrated to form a fragment.
however as shown in listing the individual method names are different yet there is a high level action implemented by lines synthesized as build menus orbuild different menus .
conversely a sequence of the same method being called may not be integrable.
in listing we claim that lines to have a high level action of add panels to content panel .
it is not clear if line should be included in this fragment as the type of the actual parameter to addin line is jbutton while the type of the actual parameter to the addcalls on lines to is a jpanel .
a description of lines to is likely to mention two different kinds of addition and hence our belief that lines to represent two individual steps.
while one could use the formal parameter of addto include with to the resulting abstraction of add components to content panel is too vague.
as shown above common actions alone do not suffice in integrating two statements.
thus we take into account the fact that there could be differences among the method calls in the name parameter or receiver object.
even among the differences we strive to find some commonality to integrate statements into a fragment.
the next challenge is to synthesize a phrase that represents an abstraction of the fragment.
to generate such a phrase we need to identify the common and different parts103figure high level view of process detect high level action code fragments and synthesize descriptions among the integrable statements and find a way to express the differences in a concise manner without being overly generic.
identifying fragments.
we focus on integrating statements with one or more method calls as this is the general case.
for a given method we build a fragment in an incremental manner.
we determine if pairs of statements are integrable starting with the first statement in the method.
we build a fragment of such integrable statements with maximum possible length.
a given method can have several such fragments.
figure shows the heuristic for integrable used to integrate any two statements in a sequence.
we illustrate the execution of the algorithm in figure with the example in listing .
the first task is to generate succinct verb phrases for the given two statements using templates defined in .
averb phrase begins with a verb followed by a noun phrase np and optional prepositional phrases pp .
a prepositional phrase begins with a preposition followed by an np.
in an english np the last word is typically the head word and is important because it bears the type of the object it refers to whereas preceding words modify or describe the head word.
consider line and line in listing .
our system generates the verb phrases add ended panel to content panel and add bid panel to content panel for lines and respectively.
the verbs in the verb phrases are the same.
the pps are the same to content panel .
the nps have the same head word panel .
thus we decide that lines and can be integrated.
similarly lines and can be integrated.
however for line the generated phrase is add okbutton to content panel .
now the head words of the np in the phrases for lines and are not the same.
thus we do not integrate lines and and the fragment only consists of lines and .
synthesizing the description.
in an identified fragment we synthesize the description by beginning with the common verb.
to generate a single phrase for np1 and np2 figure we use the plural form of the common head word of np1 and np2 if the nps differ or use the common noun phrase.
for the pp we use the common preposition and use our previous work on lexicalization of variables to synthesize the np part of the pp.
finally if the nps do not share the head word but correspond to fields of the same class we synthesize all attributes or different attributes based on whether all or some fields of the class appear in the different statements of the fragment.
figure integrating statements in a sequence .
abstracting conditionals challenges.
in the case of a sequence we only focused on a series of statements with method calls.
however for conditionals we need to integrate additional kinds of statements.
additionally there can be multiple statements along different branches which are not integrable as a sequence but some or all of the statements can be integrated with a corresponding statement in the other branch es .
in addition to unifying the statements along the different branches we need to handle the integration of the conditional expressions guarding the different branches as shown in listing .
synthesizing the description poses new challenges due to the new types of statements that can be unified the handling of multiple statements as described above and the need to describe succinctly the guarding conditional expressions.
for example there may be opportunities to integrate return statements that occur along different paths of a conditional.
when integrating return statements all the return expressions may be literals or similar method calls in which case we need strategies to synthesize a more precise phrase as shown in listing .
identifying and describing conditionals.
here we describe our approach for integrating statements in the then and elsebranches of an if else statement.
we handle if .
.
.
else if .
.
.
else .
.
.
by integrating the statements of the second ifelseand then recursively integrating with the parent if.
this strategy also generalizes to switch statements.
we compare each statement in the then block with each statement in the elsebranch to build a fragment.
when the statements involve only method calls the fragment identi i f nothingjrb .
i s s e l e c t e d configurationmanager .
setproperty .
.
.
else i f l a s t j r b .
i s s e l e c t e d configurationmanager .
setproperty .
.
.
else i f lastkeepposjrb .
i s s e l e c t e d configurationmanager .
setproperty .
.
.
listing higher level action in a conditional lines to set property based on which radio button is selected 6switch movementtype 7case ientitymovementtype .move none return n 8case ientitymovementtype .move walk return w 9case ientitymovementtype .move run return r listing theme inference for return lines to return movement abbreviation based on movement type fication and abstraction follows the same algorithm as for statement sequences.
the crucial difference is in synthesizing a description where instead of the plural used in the sequence case we use the corresponding singular form.
listing lines demonstrate this basic case.
additionally we can also detect potential opportunities to integrate return statements and assignments to the same variable along the different branches.
these two types do not manifest in the sequence abstraction case where the integrable actions will occur along the same path a programmer would not correctly have two exact same assignments to the same variable along the same path.
here we describe the integration of the different statement types we could encounter in identifying and describing high level actions in different conditional branches.
for returnstatements we integrate based on the actual return expressions.
if each return expression is a literal e.g.
return we infer a name for the theme as shown in listing based on the theme of the enclosing method.
our strategy enables the synthesis of movement abbreviation in place of the generic string in the abstraction.
for variables we first generate an appropriate noun phrase for each variable v via the process called lexicalize v defined in .
we then check if the lexicalized variables can be integrated.
for method calls we check if the generated phrases for the calls can be integrated and if so use the synthesized phrase for the abstraction.
for assignments to the same variable v if the assignment is not due to a method call we abstract the fragment as update lexicalize v .
when the assignment is due to a create or get method we abstract the assignment statements in the different branches as create or get lexicalize v as shown in listing .
describing conditional expressions.
in addition to integrating the statements in the different branches we also need to integrate and synthesize a phrase for the guarding conditional expressions.
our strategy is similar to the strategy we follow for statements except for the fact that we now need to consider clauses of the form subject predicate object generated for the conditional expressions instead of verb3i f type pt http t e s t e r new networkadminhttptester core l else i f type pt tcp t e s t e r new networkadmintcptester core l else t e s t e r new networkadminudptester core l listing similar assignment lines create network administration protocol tester based on type phrases .
the clauses are generated using .
we compare the generated clause for each conditional expression to see if the expressions are integrable.
if the subject andpredicate of each clause is the same then we integrate the expressions and synthesize an abstraction as based on what subject predicate an example is shown in figure a in section lines and .
the synthesized abstraction is based on what os name starts with .
notice the use of what in the abstraction.
the individual clauses for each expression are propositions of the form osname starts with .
.
.
.
we use what to transform these propositions into corresponding questions what does osname start with?
the heuristic uses what because the predicate startswith begins with a verb in the third person singular.
if only the head word of the subject in each clause is the same then we integrate the conditional expressions and synthesize the abstraction as based on which head word predicate object for example in listing the abstraction for isbased on which radiobutton is selected .
again notice the use of which in the abstraction to help transform the proposition into a corresponding question.
also observe the use of radiobutton in the synthesized phrase obtained from the type name of the receiver object in the expression method calls.
finally the heuristic uses which because the predicate isselected begins with the auxiliary verb is.
in the default case we integrate the expressions and synthesize an abstraction based on different conditions .
.
finding traceable patterns in loops challenges.
our first challenge is to identify loops that perform common algorithmic steps like finding counting copying e.g.
listing .
this involves developing identification templates for each common algorithmic step in a loop which are general enough to capture a range of code fragments that carry out these algorithmic steps.
the second challenge is to develop heuristics to synthesize a smooth and succinct phrase for each identified type.
strategy loop fragment identification and abstraction.
we examined many loops across diverse open source programs and developed heuristics to identify common high level actions performed by loops.
as a proof of concept we have developed and implemented rules for five different common high level actions implemented by loops.
these patterns are max min get an item in a collection with a maximum minimum value computed using some specified criteria e.g.
listing 105count count items in a collection that meet a specified criteria contains check if a collection contains an item that has some specified property find find an item in a collection that meets some specified criteria copy copy one or more items in a collection that have a desired attribute s to another collection some other algorithmic loop patterns follow immediately from the above.
for example sum can be seen an extension of count .
we can extend our work by looking for other algorithmic patterns in sources like the c standard template library and the java library.
we can also add to the catalog of common patterns by looking at introductory data structure or programming courses.
identifying fragments with any of the five patterns.
we have developed templates representing the general code structure of the five patterns described above.
for example figure is the general form of listing .
for a given loop within a method we check if the loop can map to any of the algorithm templates.
figure template for the get maximum algorithm pattern synthesizing description for an identified pattern.
for each of the five patterns we developed synthesis templates to express the abstraction in a succinct manner.
these synthesis templates rely upon the corresponding algorithmic template for the pattern.
for example the synthesis template for the max min pattern is shown in figure .
once a loop maps to a particular algorithmic template we generate succinct phrases for each statement in the actual loop using rules from .
we then look at the corresponding synthesis template for the pattern and extract elements of the synthesis template from the mapping of the actual loop values to the algorithm template.
we have defined extraction rules for each algorithm pattern.
extraction rules.
for the max min pattern the extraction rules are extract item and collection from the actual loop using rules defined in .
rules in handle different ways of looping over each item in a collection such as using an iterator or an index from to n where n is the size of the collection.
to extract adjective scan the individual words in the words of the variable in the actual loop that corresponds to maxitem in the algorithm template.
to extract criteria scan the verb phrase generated for the2for drawingview v views i f v .
getcomponent c return v listing use of relative clause lines to find return drawing view whose component equals given container statement that assigns to the variable in the actual loop corresponding to current in the algorithm template.
the noun phrase in this generated phrase supplies the criteria .
putting it all together.
consider figure and listing .
our first step of mapping the actual loop to an algorithm template succeeds for the loop in listing which maps to the algorithm template for get maximum .
to synthesize an abstraction for the loop we extract the following based on the extraction rules item isweaponattackaction object collection isvectorattacks adjective ishighest from the variable on line in listing current isfdanger phrase generated for the assignment to fdanger isget expected damage criteria isexpected damage i.e.
noun phrase in the phrase generated for the assignment to fdanger .
combining these extracted entities yields the phrase shown in listing .
slight variations in the synthesis template.
we have a slightly different synthesis template in cases where we can use a relative clause to synthesize a more succinct phrase.
consider the snippet shown in listing .
the loop maps to the algorithm template for find.
the synthesis template forfind is find item in collection whose which such that criteria .
the relative pronoun whose which is decided as follows given an item and a clause for the criteria of the form subject predicate object ifitem is the subject then the relative pronoun is which .
ifan attribute of item is the subject then the relative pronoun is whose .
the default uses such that .
for listing item isdrawing view and the clause generated for the criteria line is component of drawing view equals given container .
thus in this clause an attribute ofitem i.e.
component is the subject hence the relative pronoun is whose as shown in listing .
.
ev aluation we have implemented the algorithm described in section .
in a prototype tool for identifying and describing high level actions in java methods.
in this section we evaluate the output of our tool and examine how often our tool actually identifies high level actions when executed on .
million methods across java programs.
specifically we designed studies to answer the questions prevalence how prevalent are the high level actions implemented as sequence conditional and loops identified by our algorithm in java software?106detail reduction what is the reduction in the number of statements that need to be read by abstracting code fragments into succinct descriptions with our technique?
precision how precisely do we identify code fragments that implement a high level action and how well does the synthesized description represent the high level action?
.
prevalence of identified high level actions we selected a random sample of open source java programs from sourceforge.
cumulatively these programs contain over .
million methods with a median of and maximum of methods per project.
we executed our prototype tool on the .
million methods and gathered statistics on the frequency that the sequence conditional and loop high level actions were automatically detected.
sequence.
since high level actions implemented as a simple sequence occur infrequently in small methods we examined the frequency of detecting these sequences in methods with at least statements.
.
of the .
million methods contain at least statements.
among these methods our prototype detected methods with at least one high level action implemented as a simple sequence.
conditional.
the corpus contains if else statements and switch statements.
our prototype automatically discovered of these if else blocks and of the switch blocks as high level actions.
loop.
there are loops in the corpus of which we automatically classify as iterating over all items in a collection .
of these iterator loops were detected as implementing an algorithmic pattern.
for this large corpus of java methods the frequency of the identified code fragments ranges from for sequences within methods larger than statements to of if else blocks.
we believe these numbers are high enough to demonstrate that our automatic identification algorithm for high level actions has wide applicability.
.
potential reduction in reading detail one measure of the effectiveness of our technique is to quantify how much code a human can potentially avoid reading by instead reading our synthesized high level descriptions.
we focus here on how much detail is reduced or collapsed into our descriptions for each kind of statement grouping sequence conditional and loop.
thus each time we synthesize a description we count the number of statements that were captured by our description and the number of phrases in the resulting description.
while each sequence is reduced to a single phrase conditionals are typically described by one phrase for the body then and else parts combined and one phrase for the set of guarding conditions.
the number of phrases for the patterns implemented by loops varies with the pattern.
across the .
million methods of the programs we computed the following detail reduction information about the reduction in reading detail achieved by our prototype sequence.
of the sequences implementing a high level action there were statements originally which were synthesized to phrases of the original size .
conditional.
the conditionals identified as a high levelaction contained statements.
these were reduced to phrases of original size .
loop.
loops with patterns originally contained statements which were synthesized to phrases of original size.
these results demonstrate that a significant reduction in detail can be obtained with our technique.
.
precision of identification and description procedure.
we asked human evaluators to judge the precision of our prototype on identifying and describing high level actions targeted by our technique.
the programming experience of this group ranges from to years with a median of years.
eleven of the evaluators consider themselves as expert or advanced programmers.
seven evaluators have software industry experience ranging from to years.
project m kloc project m kloc freecol freemind ganttproject hibernate hsqldb jabref jajuk javahmo jbidwatcher jftp jhotdraw megamek planetamessenger vuze sweethome3d table subject programs in precision study.
m methods kloc lines of code.
from the open source java programs we selected methods from projects of different domains and executed our prototype on these methods see selection method below .
table shows the characteristics of these projects.
we gave each evaluator code fragments identified as a high level action by our prototype.
these code fragments were drawn randomly across the methods analyzed by our tool.
each human evaluated sequences conditionals and loops.
to account for variation in human opinion we gathered three separate judgements for each code fragment.
thus we obtained independent judgements on identified code fragments by developers evaluating independently in groups of .
to control for learning effects the evaluators in a group did not examine the code fragments in the same order.
although we are identifying and abstracting code fragments an evaluator might need to read the entire method to judge the tool s identification and abstraction.
thus to avoid burdening the evaluators we selected code fragments from methods with at most statements.
thus we executed our tool on each method with up to statements across the programs and collected the methods in which our tool identified a high level action.
we then randomly chose fragments each of sequence conditional and loop from this collection of methods.
for loops we randomly chose fragments from each of the patterns.
each group of evaluators had one fragment of each loop pattern.
we showed evaluators each code fragment assigned to them and asked them first to write an abstraction i.e.
english description of the code fragment.
to avoid bias we deliberately did not provide an explicit definition or examples of an abstraction .
they were allowed to use any resource to help write a description such as the method containing the fragment any existing comments or the signatures of107called methods.
we then asked for their opinion on the following two propositions p1 the fragment of statements from lines x to y reflects a high level action that could be expressed as a succinct phrase by a human.
i.e.
there are no other statement s in the method that you would include in the fragment and there are no statement s in the fragment that you would exclude from the fragment .
p2 the description represents an abstraction of the block.
to reduce bias we showed our synthesized description to the evaluators after they answered p1and before they responded to p2.
the evaluators were asked to respond to the above two propositions via the widely used five point likert scale strongly disagree disagree unsure neither agree nor disagree agree strongly agree.
results and discussion.
table shows the number of individual developer responses along the likert scale.
the results quite strongly suggest that the code fragments that we automatically identify as a high level action are indeed viewed as high level actions by humans.
similarly the results indicate that we are able to synthesize descriptions that accurately represent the high level action.
in of responses humans strongly agreed that the identified code fragment represented an abstractable high level action.
only in cases did humans not agree with our proposition.
similarly of human responses strongly agreed that the synthesized description represented an abstraction of the fragment.
in only of responses developers did not agree or strongly agree with this proposition.
when considering the majority of the three opinions for a given code fragment for all fragments examined the majority agreed or strongly agreed that the fragment reflected a high level action p1 .
for of fragments the majority agreed or strongly agreed with p2 that the synthesized description represented the high level action.
identification description response sq co lp all sq co lp all s disagree disagree neutral agree s agree total table precision results distribution of human judgements of high level action identification and description.
sq sequence co conditional lp loop.
while the results are very encouraging we analyzed the few fragments for which a majority of the evaluators did not agree or strongly agree with the proposition p2.
in one loop we identified the count pattern but there is an additional object creation action which we did not include in the description.
in a conditional fragment the then has multiple statements each of which has a corresponding similar statement in the elsebranch.
this is challenging to our current tool when attempting to produce a succinct description and two evaluators thus responded with the unsure response.
we also examined the fragments where any one evaluator did not agree or strongly agree with the propositions.
foridentification p1 there were such cases.
the interesting cases were those fragments where the evaluator wanted us to include the declaration of the variable used in a conditional or loop expression in our description.
for description p2 responses had an evaluator who did not agree or strongly agree with the proposition.
responses were when an evaluator did not agree or strongly agree with our proposition.
among these the unsure or disagree was mainly due to the evaluator wanting additional information in the description.
usually this information was found in the parameter of a method call in the statement.
.
summary of results our study of the prevalence of detected high level actions in over .
million methods indicates that our algorithm for automatically identifying code fragments that implement high level actions has wide applicability.
measuring the size of the statement groupings when we synthesize descriptions suggests a significant reduction in the details is obtained.
finally human judgements by developers strongly suggest indeed they view the code fragments that we identify as high level actions and our synthesized descriptions accurately express the abstraction.
.
threats to validity our results may not generalize to other java programs or languages.
to mitigate this we downloaded most popular projects from sourceforge and the programs were drawn from this set.
we chose our samples for study from across diverse projects.
in the precision study the code fragments were drawn from methods with or fewer statements for human judgement thus our results might vary on larger programs.
all our evaluators were non novices so our results might not hold with novices.
our reduction in reading detail provides one way to measure the amount of code that a developer may be able to avoid reading given a high level description.
it is still possible a developer would want to read at that level of detail.
.
improving client tools another measure of this work s contribution is the impact on client tools for software maintenance.
while we briefly mention other uses in the introduction this section details some examples of how our technique can contribute to refactoring automatic internal documentation method renaming and improving on our previous work in generating summary comments for methods.
extract method refactoring.
fowler states you have a code fragment that can be grouped together turn the fragment into a method whose name explains the purpose of the method .
the key steps are .
identify code fragment to extract into a separate method .
identify input parameters and return type for extracted method create a new method and replace fragment in the original method by a call to the extracted method .
provide a descriptive name for the extracted method while ides like eclipse support the middle step i.e.
the actual extraction process there are no proven automated techniques to achieve the other two tasks.
we believe that the fragments identified by our technique will broadly correspond to some of the fragments described by fowler.
more a original method b after extract method refactoring figure using our system for refactoring over the abstraction phrase generated by our tool for the fragment can be used to name the extracted method.
figure shows a method main from the open source project jhotdraw.
our technique identifies two abstractable fragments in this method.
the first fragment is the conditional from line to while the second fragment is the statement sequence from line to .
a developer could use this output to select the two fragments to extract into methods.
our system generates the description create application based on what os starts with for the first fragment and produces the abstraction set different attributes of svgapplicationmodel for the second fragment.
the extracted method can be named using the action and the theme in the generated abstraction for the fragment from which the method was extracted.
thus lines to can be replaced by a method call createapplication while lines to can be replaced by a method call setdifferentattributes .
the method main after refactoring is also shown in figure .
internal comment generation.
studies have shown the utility of comments including internal comments for understanding software .
however few software projects adequately document the code to reduce future maintenance costs .
fowler recommends extractmethod refactoring over the usage of comments within a method body.
however if a developer does not want too many small methods as a result of the extractmethod refactoring he can use our tool to automatically identify fragments and use the generated abstraction as a comment within the body of the method for the fragment.
this is particularly useful for inserting internal comments into infrequently commented legacy code.
our tool could also be used to add empty lines between fragments to delineate the fragments and enhance readability by achieving a text document paragraph like structure.
suggesting more informative method names.
the benefits of having informative method names is well known.
unfortunately it is also well known that many methods are not suitably named.
we believe that our technique could beused to identify methods whose name could be made more informative.
more importantly our technique can be used toprovide abetter name for some methods.
our work could be used to make the theme of a method more descriptive.
instead of changing the method name a developer could simply use the suggested name by our system as a comment at the call sites.
from the project xml cml consider the method with the signature getatom list cmlatom newatomvector .
our system identifies the high level action get maximum in this method.
thus the system synthesizes get atom with heaviest atomic number for the high level action.
from this description one can automatically derive a better name getheaviestatom for the original method.
improving automatically generated summary comments for a method.
previously we presented a novel technique to automatically generate comments that summarize the major actions of a java method .
our current work can be used to significantly improve the summarization.
consider listing .
using the high level action identification in this paper we can produce the summary create oneline box.
add the given components to it and return it .
recognizing the high level actions in a loop can also help generate succinct summaries.
in the method getconnectionsize from project vuze azureus by recognizing the count pattern and using our synthesis process a summary comment generator can produce the summary count transfers that have started and return count .
we believe that this summary is a very good adjunct to the method name.
.
related work to our knowledge this is the first automatic technique to identify source code fragments that implement a high level action and synthesize a natural language description to express that abstraction.
however there is work on automatically extracting topic words and phrases from source code and clustering program elements that share similar phrases .
host et al.
automatically extracted a verb lexicon from source code to help new programmers understand typical verb usage in practice.
hill et al.
developed an algorithm to automatically extract and generate verb noun and prepositional phrases from method and field signatures.
the phrases are used to capture word context of natural language queries for software search.
in this paper we go beyond this by generating phrases for various length code fragments involving different types of statements.
additionally these techniques do not identify code fragments that collectively implement a particular high level action within a given method.
existing research into design recovery and reuse has also used information from identifiers .
however all of these approaches require an expert defined domain model or knowledge base which is not available for all software systems or domains.
our work might sound similar to finding beacons .
a beacon can be a well known coding pattern e.g.
lines for swapping array elements meaningful identifiers program structure or comment statements that signal something to the code reader wants to know about the code segment s functionality.
beacons only represent a name given to a visually recognizable entity or pattern.
our work automatically finds some of these fragments in code and generates an abstraction for the fragment.
gil and maman define109the notion of traceable patterns which are similar to design patterns except that they are mechanically recognizable and represent lower level abstraction e.g.
data manager or pool .
particularly they present a catalog of micro patterns that is class level traceable patterns for java intended for design assessment.
in contrast our work focuses on identifying high level actions within methods providing support for different client tools.
method extraction is primarily based on slicing blockbased slicing or program transformations with slicing to make the dependence related statements contiguous for extract method refactoring.
our approach would potentially identify candidate fragments not identified through dependencies does not require code transformations to make contiguous and can identify good names for the extracted method using the phrases we generate.
host and ostvold developed name specific implementation rules mined from a large corpus of java programs applied the rules to identify method names that do not match their implementation and then suggest better method names.
to the best of our understanding their work is restricted to checking if the action verb in the method name is appropriate.
our work can help in identifying if the the theme of the action is appropriate and can make suggestions to improve the theme part of the method name.
lastly this work enables automatically generated comments well beyond our previous work in summary comment generation in several important ways.
our previous comment generation focused on identifying important content for the method summary and then generating text for each selected statement in isolation.
this paper addresses the problem of identifying which blocks of statements form a single high level step which is a different problem from identifying the important content for a summary.
additionally our text generation in this work takes into account the set of statements to generate a single cohesive phrase for that step.
each statement in the identified code fragment is not analyzed in isolation but instead the set is analyzed as a group for text generation.
thus we can now generate internal comments for statement blocks as well as use the phrases generated for high level steps to improve the abstraction level of summary comments.
other documentation generation work has focused on specific aspects of source code .
.
conclusions and future work to our knowledge we have presented the first technique for identifying code fragments of statement sequences conditionals and loops that can be abstracted as a high level action with the capability of also automatically synthesizing a natural language description of the abstraction.
based on experienced java programmers opinions we are quite encouraged by both our success in accurately identifying a widely applicable set of code fragments and in synthesizing descriptions that humans believe accurately express the high level action.
in the future we will continue to augment our system by examining additional potential code patterns in loops and non loop constructs with different characteristics observed in our corpus with attention to both identification and synthesis of succinct informative descriptions.
we plan to integrate our work in this paper into our summary comment generator to investigate the improvements made possible.
wewill also integrate the techniques into eclipse and investigate usefulness for refactoring with human study.
there are several other client tools that we believe we can build upon the descriptions that we synthesize for code fragments.
.