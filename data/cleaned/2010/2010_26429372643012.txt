derailer interactive security analysis for web applications joseph p .
near daniel jackson computer science and artificial intelligence lab massachusetts institute of technology cambridge ma jnear csail.mit.edu dnj mit.edu abstract derailer is an interactive tool for nding security bugs in web applications.
using symbolic execution it enumerates the ways in which application data might be exposed.
the user is asked to examine these exposures and classify the conditions under which they occur as security related or not in so the user e ectively constructs a speci cation of the application s security policy.
the tool then highlights exposures missing security checks which tend to be security bugs.
we have tested derailer s scalability on several large opensource ruby on rails applications.
we have also applied it to a large number of student projects designed with di erent security policies in mind exposing a variety of security bugs that eluded human reviewers.
categories and subject descriptors d. .
software program veri cation keywords web applications security static analysis.
.
introduction the web is fast becoming the most popular platform for application programming but web applications continue to be prone to security bugs.
web apps are often implemented in dynamic languages using relatively fragile frameworks based on metaprogramming.
most importantly security policies themselves tend to be ad hoc and many security bugs are the result of programmers simply forgetting to include vital security checks.
we propose a solution that avoids the need for new frameworks or speci cations.
instead it uses a combination of symbolic evaluation and user interaction to help the programmer discover mistakes.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
particular combination is motivated by two hypotheses.
first web applications di er from traditional programs in ways that improve the scalability of symbolic execution.
in particular web applications typically use fewer loops and simpler branching structures than traditional programs minimizing the exponential behavior of symbolic execution.
second security policies tend to be uniform sensitive data is usually subject to security checks everywhere it is used so an access that is missing one of those checks is likely to be a mistake.
our approach considers web applications that accept requests and respond with sets of resources obtained by querying the database.
each response is characterized by the path through the database leading to the resource and the control ow of the application s code imposes a set of constraints under which a particular resource is exposed to a client.
we call the combination of a path and a set of constraints an exposure .
an automatic strategy for nding security bugs might enforce that all exposures with the same path also share the same set of constraints if a security check is forgotten a constraint will be missing.
but many constraints like those used to lter sets of results for pagination have nothing to do with security and would cause an automatic strategy to report many false positives.
our approach therefore asks the user to separate constraints into those representing security checks and those that are not security related.
in making this separation the user e ectively constructs a speci cation of the desired security policy but by selecting examples rather than writing a speci cation manually.
our tool makes this process easy allowing the user to drag and drop constraints to build the policy.
the tool then highlights exposures missing a constraint from the security policy precisely those that might represent security bugs.
we have built a prototype tool implementing our proposed approach.
called derailer1 it performs symbolic execution of a ruby on rails application to produce a set of exposures.
derailer s symbolic execution is based on rubicon a tool we previously built for specifying and checking security properties of rails applications.
rubicon was e ective at checking security policies but our experience suggested that completely specifying a security policy is di cult.
derailer is therefore motivated by the desire to nd security problems without requiring an explicit written speci cation.
1available for download at jnear derailer we evaluated derailer on ve open source rails applications and student projects.
the largest of the opensource applications diaspora has more than 40k lines of code and our analysis ran in seconds.
the student projects were taken from an access control assignment in a web application design course at mit.
derailer found bugs in over half of these projects about half of those bugs were missed during manual grading.
the bugs we found supported our hypothesis most bugs were the result of either a failure to consider alternate access paths to sensitive data or forgotten access control checks.
the contributions of this paper include a lightweight scheme for detecting security vulnerabilities in web applications which involves constructing an abstraction of an application s behavior that indexes the constraints under which resources can be accessed by access path and action asking a user to identify which constraints are security related and displaying discrepancies that show cases in which the same resource is guarded inconsistently across different actions.
derailer an implementation of this analysis for ruby on rails applications with an interactive interface for interpreting its results.
two case studies one providing evidence that derailer scales to real world applications and the other indicating that derailer is helpful in nding security bugs.
a lightweight static analysis based on our previous work that enumerates the ways in which data can ow from the database to rendered pages in a web application.
section introduces our approach by describing the use of derailer to discover a security bug in an example application.
section formalizes our analysis while section contains details of derailer s implementation.
section contains our case studies evaluating derailer s scalability and e ectiveness and section discusses related work.
finally section relates some conclusions.
.
using derailer derailer uses an automatic static analysis to produce an interactive visual representation of the exposures produced by a ruby on rails web application.
the tool displays the constraints associated with each exposure and allows the user to separate the security related ones from those unrelated to security.
then derailer highlights inconsistencies in the implemented security policy by displaying exposures lacking some security related constraints.
to see how this works consider the controller code in figure ?
?
taken from a student project.
the application s purpose is to allow users to create note objects and share them with other users users should not be able to view notes whose creators have not given them permission.
this code however has a security bug the index action correctly builds a list in line of notes the current user has permission to view but the show action displays a requested note without checking its permissions line .
the application s programmer assumed that users would follow links from the index page which does correctly enforce access control to1 def index notes note.where user current user .
id note.permissions.
nd byuser id current user .
id respond todojformatj format.html index.html.erb format.
jsonfrender json notes g end end defshow note note.
nd params respond todojformatj format.html show.html.erb format.
jsonfrender json note g end end figure example controller code from student project view notes and neglected the case in which the user requests bypasses the index action and requests a speci c note directly using the show action.
figure contains a sequence of screenshots demonstrating the use of derailer to nd this security bug.
in shot the user has expanded the note node which represents the note resource type and then the fnote note jnote.id in params g.content node which is a resource path rooted at the note type representing a note s contents.
the user node represents the programmer de ned user resource while session and env are system de ned resource types containing information about the current session and con guration environment.
then in shot the user picks the index action from the list of actions resulting in that exposure.
when an action is selected the set of constraints governing the release of that data by that action is displayed in the constraints area.
in this case the displayed constraint is note.
user current user ornote.
permissions .
nd byuser id current user .
id which says that the currently logged in user must either be the creator of or have permission to view all visible notes.
the user drags security related constraints to the filtered constraints area which will eventually contain the complete security policy of the application.
dragging constraints to the filtered constraints area causes the nodes subject to those constraints to disappear as in shot .
once the filtered constraints area contains all security related constraints remaining exposures of sensitive information represent inconsistencies in the implemented security policies and are likely to be bugs.
in shot the show action remains despite the ltered constraint selecting it the user discovers that it is not subject to any constraints at all.
we took the approach described in this section in using derailer to analyze similar student projects from the same course and found bugs in nearly half of them.
the results of that experiment are described in section .
.
model this section explains the fundamental model that underlies our approach.
the model is important for several reasons.
first understanding the model is a prerequisite to the user has expanded the note node and its child node representing the note s content since this node represents sensitive data.
the user has selected the notescontroller index action which can result in a note s content appearing on a page.
a constraint representing the security policy on a note s content appears in the constraints area.
the user has dragged the constraint that appears into the filtered constraints area.
the notescontroller index action disappears because it is subject to a ltered constraint.
the user has selected the remaining action which remains visible because it is notsubject to the ltered constraint.
in fact it is not subject to any constraints at all.
this represents a security bug in the application.
figure example bug nding session using derailer 589understanding the results the tool produces.
second the model is the basis of our implementation strategy and informs the assumptions made in our implementation.
third the model makes clear which aspects of web applications make this problem more tractable than it would be for arbitrary applications.
clients issue requests that contain a binding of parameters to values and a choice of action2 sigrequestf params param!value action action g there is no need to distinguish clients or represent clientside state such as cookies since the analysis must be conservative and assume the worst e.g.
that a client could manipulate a cookie .
the model does not currently allow for access control through client side certi cates or reliance on signed cookies.
the choice of http method eg get or post need not be modeled nor whether the request is synchronous or asynchronous since these factors do not impact what we seek to analyze namely what data is released in response to a query .
nor do we need to distinguish how the parameters are passed in a form query string or json object eg in rails and many other web frameworks the request is accessed homogeneously through a single hashmap.
the response to a request is just a set of resources to be elaborated shortly sigresponsefresources set resource g the internal state of the application is just a database mapping paths to resources sigdatabasefresources dbpath !resourceg a path is an abstraction of a general database query representing a navigation through the database s tables using only the relational join.
such queries can be used to extract any resource the database contains and ltered to contain only the desired results.
to represent these lters we introduce constraints.
a constraint has a left and right side each of which may be a path a parameter or a value and a comparison operator sigconstraintf left right dbpath param value operator operator g 2the model is given in alloy .
for readers unfamiliar with alloy the following points may help.
a signature introduced by keyword sig introduces a set of objects each eld of a signature introduces a relation whose rst column is the set associated with the signature and whose remaining columns are as declared.
thus the declaration sigrequestfparams param!valueg introduces a set request of request objects and a ternary relation params on the sets request param and value this relation can viewed as a table with three columns.
a tuple r p v in this relation would indicate that in request r parameter p has value v. equivalently the signature can be thought of as a class with the elds as instance variables thus this eld declaration introduces for each request r a mapping r.params from parameters to values.
signature extension introduces subsets.
thus sigvalueresource extends resourcefvalue valueg says that some resources are value resources and introduces a relation called value from value resources to values.
equivalently the subsignature can be viewed as if it were a subclass thus a value resource vr has a value vr.value.
in fact constraints can have logical structure and our implementation puts constraints into conjunctive normal form.
this detail is not relevant however to understanding the essence of the approach.
the behavior of an application can now be described in terms of two relations.
both involve a database representing the pre state before execution of the action and an incoming request.
the rst relates these to the resulting response and the second to a database representing the post state after execution of the action sigappf response database !request!response update database !request!database g an approximation to this behavior is inferred by static analysis of the code and consists of a set of exposures of resources with an exposure consisting of a path an action and a set of constraints sigreportf exposures set exposure g sigexposuref path dbpath action action constraints set constraint g the presence of an exposure in the report means that a set of resources might be exposed under the given constraints.
example.
the exposure with path user.notes.content action update and constraints user.notes.
title notetitle and user.notes.owner session.
user would represent the set of content strings that might be exposed when the update action is executed.
the constraints limit the notes to those with a title matching the notetitle parameter and that are owned by the currently logged in user.
the set of notes u.notes associated with a user uneed not of course have user uas their owner a constraint such as the one we have here would typically be used to ensure that while a user can read notes shared by others she can only modify notes she owns.
.
analysis our analysis uses the application s code to obtain a set of exposures.
more precisely it produces a superset of the exposures for which some concrete database and request exists such that the application produces the concrete results represented by the exposure.
fun symbolic analysis set exposure f fe exposurej some db database request request f db.
resources inapp.response db request .
resources request .
action e.action e. constraints fc constraintjholds g g g this speci cation says that for each exposure some concrete database and request exist such that the application responds with the same resource as speci ed by the exposure the exposure s action matches that of the request and the constraints associated with the exposure are those enforced by the application s code.
our model 590does not de ne the holds predicate since it depends on the semantics of the application s implementation language and on the particular representation of constraints.
symbolic execution satis es this speci cation since it uses the application code directly to build the set of exposed resources and the constraints associated with them.
.
filtering our approach uses interaction with the user to build the desired security policy and discover exposures that do not obey it.
we allow the user to choose a set of constraints representing a candidate security policy and lter the set of exposures based on those constraints.
the result is exactly the set of exposures missing one of the ltered constraints in other words exposures for which a security check is missing.
fun lter es set exposure cs set constraint set exposure f fe exposurej some c csjc !ine .
constraintsg g our implementation satis es this speci cation by simply comparing each exposure s constraints against the ltered set and displaying those exposures missing a constraint from that set.
.
implementation derailer is implemented as a library for ruby.
derailer enumerates the application s actions runs each one symbolically to obtain a set of exposures and organizes the exposures for presentation to the user.
rather than implement a standalone symbolic evaluator a di cult task for a large under speci ed dynamic environment like rails we hijacked the existing ruby runtime to do symbolic execution.
derailer uses ruby s metaprogramming features to wrap the standard libraries of ruby and rails in a thin layer that allows the existing code to compute with symbolic values.
we pioneered this technique in our previous work on rubicon which performed bounded veri cation of userde ned properties on rails applications.
a more detailed description of our symbolic evaluator is available as part of that work a formal description of our technique including an embedding in a simpli ed ruby like language with a formal semantics and a proof that our technique produces the same results as the standard approach to symbolic execution is available in .
for completeness we present a brief explanation of our approach to symbolic execution with a focus on the strategy derailer uses to explore all possible page requests and extract the resulting exposures.
.
symbolic values to add symbolic values to ruby we de ne a class of symbolic objects to represent the paths and constraints of section .class symbolicobject defmethod missing meth args exp.new meth args end def oth exp.new end endclass exp symbolicobject def initialize meth args meth meth args args end end these objects use ruby s method missing feature to return new symbolic objects whenever methods are invoked on them.
x symbolicobject.new y symbolicobject.new x.foo y exp foo x y y x exp exp code rewriting.
when a conditional expression depends on a symbolic value symbolic execution requires that we execute both branches of the conditional and record both possible results.
unfortunately ruby does not allow the programmer to attach special behavior to conditionals so derailer rewrites the application s code transforming ifexpressions into calls to derailer s own de nition.
x symbolicobject.new ifx.even?
then x .odd?
end exp if exp odd?
side e ects.
to support side e ects our symbolic evaluator must consider the fact that both branches of a conditional may contain updates to the same variable.
as such our strategy for executing conditionals must split the current state and save both results.
the new de nition of if introduced in our code rewriting performs this step splitting the current state and recording the side e ects of each branch separately.
it uses a choice object to record the path constraint causing the split and the results of both branches.
x symbolicobject.new ifx.even?
then x else x end x choice exp even?
.
rails figure summarizes derailer s symbolic execution architecture.
derailer enumerates the actions de ned by the application for each one derailer constructs a symbolic request and runs the action symbolically.
the set of symbolic objects present on the resulting rendered pages is the set of possible exposures for that action which derailer normalizes and groups by resource type.
wrapping activerecord.
rails applications interact with the database through activerecord an object relational mapper.
activerecord provides methods like nd and all to query the database.
given a user class extending activerecord the following code nds users with the name joe.
591wrappersymbolic request action standard librariespaths constraints normalization grouping exposuresfigure derailer s architecture user.
nd name joe derailer s analysis must produce results valid for allvalues of the database so database queries must return symbolic values during analysis.
to accomplish this derailer wraps the rails api to ignore the concrete database and return symbolic objects instead.
the query above for example evaluates to exp rendering.
a rails action serves a request in two steps rst the code de ned in the controller populates a set of instance variables then rails evaluates an appropriate template which may reference those instance variables to produce an html string.
derailer wraps the rails renderer to extract the set of symbolic values that appear on each rendered page.
these values along with the constraints attached to them contribute to the set of exposures resulting from the action being executed.
normalization.
derailer s interface allows the user to explore candidate security policies through ltering which compares constraints syntactically.
since two constraints can be logically equivalent but syntactically di erent derailer attempts to normalize the set of constraints so that whenever possible two logically equivalent constraints will also be syntactically equal.
derailer uses two basic methods to accomplish its normalization.
first calls to the activerecord api are rewritten in terms of the ndmethod and queries are merged when possible.
for example user.
nd name joe .
lter role admin becomes user.
nd name joe role admin .
second derailer converts all constraints to conjunctive normal form eliminating issues like double negation.
.
challenges both the dynamic nature of ruby and the size of the rails library pose signi cant challenges to standard symbolic execution strategies.
these challenges motivated our unique solution.rails is large and complicated.
the rails framework is notoriously complicated for many years it was compatible only with the standard mri ruby interpreter due to its use of undocumented features.
this provided the strongest motivation for implementing our symbolic evaluator as a ruby library.
it allows some code such as rails s con guration code to be run concretely and at full speed.
in addition using the standard ruby interpreter gives us condence that derailer is faithful to the semantics of ruby and rails since it runs the actual implementations of both.
ruby does not allow the rede nition of conditionals.ruby provides facilities for metaprogramming but they are limited.
when a conditional expression depends on a symbolic value symbolic execution requires that we execute both branches but ruby does not allow the programmer to attach special behavior to conditionals.
derailer rewrites the application s code transforming ifexpressions into calls to derailer code that runs both branches.
this can result in the exponential blowup characteristic of symbolic execution so derailer executes only the appropriate branch when a conditional s condition is concrete.
rails plugins use metaprogramming.
rails plugins are extra libraries that can be included in applications to provide additional functionality.
the cancan plugin for example provides user authentication and access control features not built into rails.
unfortunately the use of metaprogramming in plugins often con icts with our own use of the same technique.
cancan for example replaces many of activerecord s query methods with versions that perform security checks.
since derailer s versions of the same methods are essentially speci cations of the default rails behavior derailer s replacement methods eliminate the extra security checks introduced by cancan.
our solution is to allow derailer s speci cations to be extended to match the functionality added by plugins.
using this technique adding cancan s security checks is accomplished in just a few lines of ruby code.
rendering makes it di cult to extract the set of symbolic values the user will actually see.
rails s rendering mechanism is complicated so we prefer to run its implementation rather than specify its semantics manually since the output of rendering is a string containing html however it is also di cult to reconstruct the set of symbolic values from the renderer s output.
our solution assumes that the set of objects receiving the tosmethod which converts an object into a string during rendering is exactly the set of objects appearing on the resulting page.
this is a conservative assumption since while a template may convert an object into a string and then discard it a situation we have yet to encounter in practice rails always calls toson objects appearing in templates.
under this assumption we modify the tosmethod of symbolic values so that each value keeps track of whether or not it has been converted into a string and run rails s renderer unmodi ed.
after rendering has nished derailer collects the set of symbolic values that have been converted to strings and returns them as the set of results.
.
assumptions limitations our strategy for symbolic execution relies on several assumptions.
while we consider these assumptions reasonable some of them do imply corresponding limitations of our analysis.
592app lication slo c ana lysis time exp osures con straints path s const.
redmine .5s .
fatfreecrm .8s .
diaspora .8s .
amahi .1s .
selfstarter .1s .
figure results of analyzing five popular opensource rails applications derailer assumes that tosis called on exposed objects.
but since the rails rendering engine calls tosautomatically on every object that appears in a template we consider this a reasonable assumption.
derailer doesn t handle symbolic string manipulation.
derailer records manipulations performed on symbolic strings but cannot solve them.
fortunately rails applications tend to perform few string manipulations especially on objects drawn from the database and almost never base control ow on the results of those manipulations.
we have therefore not found derailer s inability to solve string manipulation constraints to be a problem in practice.
derailer assumes that all actions are reachable.
rails uses routes to de ne the mapping between urls and actions.
derailer ignores routes and simply analyzes all actions de ned by the application.
this strategy is an overapproximation it is possible for an action to exist without a corresponding route making the action dead code.
but the converse is nottrue it is impossible for derailer to miss an exposure by ignoring some code that is actually live derailer simply analyzes allthe code.
derailer s ltering assumes that logically equivalent constraints are syntactically equal.
determining logical equivalence is a di cult problem.
fortunately rails applications tend to focus on querying the database and formatting the results they typically do not perform complex arithmetic or string operations so normalization of database queries is usually enough to make logically equivalent constraints also syntactically equal.
and like the other assumptions this one is conservative if the user lters based on a constraint that is logically equivalent but notsyntactically equal to another one the associated exposure will be highlighted as notsatisfying the desired security policy so it is impossible to miss a security bug due to this assumption.
derailer assumes that the application under analysis uses activerecord.
derailer wraps the activerecord api to make database queries symbolic but an application that uses a di erent method to make database queries may bypass this wrapping.
the application may therefore have access to concrete database data during analysis meaning the results will not generalize to all database values.
but since derailer is intended for use by an application s developer we assume that he or she will know whether or not the application uses a database api other than activerecord and if so derailer has a simple mechanism to provide a speci cation of that api.
.
evaluation in evaluating derailer we sought answers to two basic questions does derailer s analysis scale to real world applications?
to answer this question the authors ran derailer on ve popular open source rails applications.
since all applications are well tested and we do not know their intended security policies we did not expect to nd bugs.
the results show that derailer s analysis scales to even quite large realworld rails applications.
is derailer useful in nding security bugs?
to answer this question the authors used derailer to examine student assignments from a web application design course at mit.
the assignment was open ended so the applications had similar but not identical intended security policies.
the results show that derailer was able to highlight significantly more security bugs than were found by the course s teaching assistants during grading.
.
scalability we tested derailer s scalability on ve open source web applications redmine a content management system fat free crm a customer relationship management system diaspora a social networking platform amahi a personal media server selfstarter a crowdfunding platform the results are summarized in figure .
all analyses nished in less than two minutes even in the case of diaspora which has more than lines of code.
all ve applications are popular and mature.
the diaspora project for example has been in development for more than three years has more than contributors and has addressed more than led bugs.
as such we did not expect to discover security bugs in these applications.
however we did nd one bug in diaspora a situation that causes a crash when the current user is not a friend of the owner of a requested piece of data.
if the bug causing the crash were xed a security bug would remain the sensitive data would be visible to the non friend.
the larger open source applications produced many exposures more than in the case of diaspora.
the relatively small number of constraints however made constraint ltering e ective.
filtering by a single constraint often resulted in a huge reduction in the number of visible paths since so many paths share some common constraints.
the large ratio of paths to constraints supports our hypothesis that applications typically access data in only a small number of consistent ways.
.
bug finding to evaluate derailer s ability to nd security bugs we applied it to student assignments from .
a web application design course at mit.
the course teaches design principles and implementation strategies and evaluates students on a series of open ended projects in which students 593type of bug no.
no access control implemented no write control implemented no read control implemented security bug in read control security bug in write control figure types of bugs found during analysis of student projects 25no .
projects an alysis time seconds figure analysis times for student projects implement actual applications.
students are taught and expected to use rails and one of the topics covered is security.
the project asks students to implement access control for a notes application which allows users to log in write short textual posts and share them with others.
the assignment requirements are purposefully vague students are expected both to design a security policy and to implement that policy.
each assignment must therefore be graded against its own intended security policy making it impossible to write a single speci cation for all assignments.
the existing grading process consists of a teaching assistant running the application and experimenting with its capabilities in a browser along with extensive code reivew.
the teaching assitants estimated that they spent an average of minutes grading each project.
the rst author who was not a teaching assistant for this course used derailer to evaluate all student submissions for this assignment.
we used the constraints present on note accesses to infer the security policy the student intended to implement and then we looked for situations in which those constraints were not applied.
our goal was not to evaluate the policies the students had chosen though we found some that did not seem reasonable but rather to determine whether or not the students correctly implemented those policies.
these are the kind of bugs derailer is intended to nd situations in which the programmer has simply forgotten to enforce the intended security policy.
it took about ve minutes per student submission to interpret the results of derailer s analysis.
for most projects we were able to determine the intended security policy after examining only one or two exposures we spent roughly a024681012141618 16no .
projects rat io of exposures to constraints figure ratio of exposures to constraints in student projects minute assembling constraints into a description of that policy and then another couple of minutes to decide whether the highlighted exposures were security bugs.
since derailer points directly to the action responsible for each exposure con rming each bug in the student s code also took only a couple of minutes.
.
.
results figure contains information about our analysis including average minimums and maximums for lines of source code analysis time number of exposures generated during analysis and number of unique constraints applied to those exposures.
figure contains a histogram of analysis times showing that the vast majority of analyses took fewer than seconds.
the average number of exposures generated by the analysis was .
projects with very few generated exposures were instances in which the student had not completed the project.
projects with a very large number of exposures the maximum was generally used many di erent ways to query the database for similar kinds of information.
we found it easy to distinguish these cases because the rails api places heavy emphasis on making database queries humanreadable.
the average number of unique constraints was only and the average ratio of exposures to constraints was .
meaning that for each unique constraint there were more than three exposures on average .
figure contains a histogram showing that the majority of assignments had exposureto constraint ratios close to the average.
while these ratios are lower than those for the open source applications they are still overwhelmingly greater than one again supporting our hypothesis that similar data is accessed in similar ways.
.
.
bugs found figure contains a summary of the bugs we found in student projects using derailer.
roughly of the students failed to complete the project they did not implement access control .
another did implement access control but failed to implement a consistent security policy.
in other 594metric avg.
max.
min.
lines of code analysis time .37s .28s .23s exposures unique constraints figure results of analyzing student projects words less than of the student assignments were correct.
the most common issue seemed to be that students considered only the most common method of accessing a piece of data and failed to consider other ways of accessing it.
for example many students correctly checked for permission when a user loads the edit page for a note but failed to check again when the user issues a post request to the update action for that note.
most of the time users will issue the post request only after loading the edit page and so will be shown the access denied message instead of the editing form.
however a malicious user can construct a post request directly to the update action bypassing the security check.
since the student did not consider this access path he or she did not secure it.
derailer is perfect for nding this kind of problem since it considers allthe ways data can be accessed.
.
.
comparison with teaching assistants we also compared the set of bugs we found in student assignments with the grading reports given to those students by their teaching assistants.
out of grade reports we obtained or agreed with our analysis.
in cases we found a bug using derailer that the teaching assistants missed.
only one assignment contained a bug that the teaching assistants found but that we missed.
in this case it was possible for a user to grant permissions to a non existant user id which might later be associated with some new user.
this situation does not cause a sensitive exposure at the time it occurs.
since derailer only reports exposures which by de nition require some output to the user our analysis was unable to uncover this bug.
we asked the teaching assistants to validate the security bugs we found and in each case they agreed that the additional bugs we found were indeed violations of the student s intended security policy.
.
threats to validity internal validity.
our experimental results may not support our ndings for several reasons.
if our analysis incorrectly skips some code or misses some constraints then it might report incorrect results.
if our timing strategy was not accurate then our scalability results might be incorrect.
and if we misinterpreted the analysis results then the set of bugs reported might be incorrect.
we mitigated these factors by testing our tool extensively on small applications with seeded bugs by timing each scalability experiment three times and by checking our interpretation of each bug in the student projects with the teaching assistant who graded it.
external validity.
similarly our ndings may not generalize to real world applications.
if our assumptions about rails applications that they typically use activerecord have few branches and iterate only over collections do not hold then our scalability results may not be indicative of derailer s real world performance.
if the types of security bugs that occur in the real world are not similar to the ones in our experimental subjects then our tool may be less useful for those applications.
we have collected evidence to mitigate the rst factor.
we examined the most starred rails projects on github.
we found that all projects used activerecord exclusively to access the database.
and in a combined lines of ruby code these applications contain a total of just loops and more than half contain no loops at all.
when derailer s analysis encounters a loop with a symbolic constraint it unrolls the loop to the bound speci ed by the user and marks the resulting exposures for special review so the user is unlikely to miss security bugs due to loops in controller code.
the second factor is more di cult to mitigate because determining the prevalence of each type of security bug rst requires that those bugs be found.
our experience teaching web application design as well as the collective experience of the security community seems to support the idea that the kind of bugs derailer is designed to nd are among the most common.
.
related work derailer combines static analysis with human interaction to nd security bugs.
in this section we discuss the related work in each of these areas and compare derailer to other existing solutions.
.
interactive analyses we share the idea of using human insight as part of a semantic program analysis with daikon and diduce which use runtime traces to produce possible program invariants and ask the user to verify their correctness.
like derailer these tools do not require a speci cation.
however both systems rely on dynamic analysis e.g.
collecting traces during execution of a test suite and therefore may miss uncommon cases.
derailer by contrast uses symbolic execution to ensure coverage.
teoh et.
al apply a similar strategy to the problem of network intrusion detection producing visual representations of the current state of the network.
over time users of the tool learn to recognize normal network states by their visual representations and can therefore quickly determine when an intrusion has occurred.
.
automatic anomaly detection in addition to producing candidate invariants diduce raises errors at runtime when these invariants are violated allowing it to run in a completely unsupervised mode.
this approach is a type of automatic anomaly detection an area which has received much attention .
most approaches to anomaly detection use machine learning techniques to learn the appearance of normal operation and then use the resulting classi er to automatically nd anomalies at runtime.
these techniques have not often been applied to code however since software speci cations are often specialized and di cult to learn.
it may be possible to use an automatic anomaly detection technique along with derailer s analysis to detect security problems without human input.
however anomaly detec595tion techniques rely on a large training set of examples often spread across many applications in the same domain derailer s results by contrast usually contain only a handful of elements per data type and since security policies are not common across applications pooling results from many applications is not likely to be helpful.
.
symbolic evaluation king and clarke developed the rst symbolic execution systems in and modern systems have been used to do many types of program analyses.
two notable examples are the symbolic extension of java pathfinder which has been used to analyze java code used by nasa and cute a concolic testing tool for c that interleaves invocations of a symbolic and concrete execution.
the recent popularity of dynamic languages has lead to a number of tools for executing these languages symbolically for example saxena et.
al rozzle and kudzu for javascript and rubyx for ruby.
in contrast to derailer all of these use standalone symbolic evaluators.
like derailer yang et.
al and k oskal et.
al both embed symbolic values in the host language in this case scala to enforce security policies and perform constraint programming respectively.
both require that symbolic values interact only with a short list of symbolic library functions however and do not allow symbolic values to ow through arbitrary program code.
.
static analysis of web applications existing work on the application of static analysis to web applications focuses on modeling applications and especially on building navigation models.
bordbar and anastasakis for example model a user s interaction with a web application using uml and perform bounded veri cation of properties of that interaction by translating the uml model into alloy using uml2alloy other approaches perform similar tasks but provide less automation.
nijjar and bultan translate rails data models into alloy to nd inconsistencies.
techniques that do not require the programmer to build a model of the application tend to focus on the elimination of a certain class of bugs rather than on full veri cation.
chlipala s ur web statically veri es user de ned security properties of web applications and chaudhuri and foster verify the absence of some particular security vulnerabilities for rails applications.
.
conclusions this project explores two hypotheses.
first that web applications despite their widespread deployment and apparent exibility are in some key respects simpler than traditional applications making new lightweight analyses possible.
these include the conventional structure of the rails framework with the database typically accessed through activerecord a simpler interface than full sql the lack of loops in controller actions which makes symbolic evaluation straightforward that request parameters are named consistently across actions so that conditions are often identical rather than just isomorphic and the statelessness of http which makes analysis across actions unnecessary since the programmer must encode all relevant security context in persistent state .at the same time performing a symbolic evaluation on the code of a web application is challenging.
web frameworks such as rails are elaborate and make extensive use of language and api features that are not always well de ned.
execution begins with complex system wide con guration.
to address these issues we implemented a symbolic evaluator that runs the standard interpreter intercepting calls to crucial interfaces such as activerecord using method overriding.
this not only simpli ed the task of handling a complex language and framework whose full formalization in a conventional symbolic evaluator would be burdensome but also allows for hybrid evaluation in which some aspects notably con guration settings are executed concretely.
the second hypothesis is that security policies tend to be highly uniform and that many vulnerabilities result simply from failing to implement security checks consistently for di erent actions formats and so on.
our initial experiments seem to support this with average ratios of exposures to constraints overwhelmingly greater than one.
the uniformity of security policies suggests that it would be pro table to pursue designs with a stronger separation of concerns with policy more cleanly separated from functionality and indeed this is the direction seen in many new developments both in our own group and elsewhere that allow policies to be expressed declaratively in one place and enforced globally .
such a move would of course make our analysis less useful but this seems to us the inevitable push pull between synthesis and analysis.
we suspect that for a long time yet there will be systems that do not achieve such a separation that might bene t from the kind of analysis we have described here.
our tool seems to strike a reasonable balance between automation and user intervention as the case studies suggest the burden on the user in identifying security related constraints seems to be reasonable.
nevertheless we are keen to try to automate the analysis fully perhaps by identifying some reliable heuristics or by incorporating some kind of machine learning.
we also plan to look at other kinds of security problems both static and dynamic to see if the ideas we have explored might have broader application.