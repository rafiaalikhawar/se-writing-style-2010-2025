university of groningen how do developers react to api deprecation?
the case of a smalltalk ecosystem robbes romain lungu mircea roethlisberger david published in proceedings of the 20th international symposium on the foundations of software engineering fse .
.
important note you are advised to consult the publisher s version publisher s pdf if you wish to cite from it.
please check the document version below.
document version publisher s pdf also known as version of record publication date link to publication in university of groningen umcg research database citation for published version apa robbes r. lungu m. roethlisberger d. .
how do developers react to api deprecation?
the case of a smalltalk ecosystem.
in proceedings of the 20th international symposium on the foundations of software engineering fse pp.
.
acm press.
copyright other than for strictly personal use it is not permitted to download or to forward distribute the text or part of it without the consent of the author s and or copyright holder s unless the work is under an open content license like creative commons .
the publication may also be distributed here under the terms of article 25fa of the dutch copyright act indicated by the taverne license.
more information can be found on the university of groningen website take down policy if you believe that this document breaches copyright please contact us providing details and we will remove access to the work immediately and investigate your claim.
downloaded from the university of groningen umcg research database pure for technical reasons the number of authors shown on this cover page is limited to maximum.
download date 2025how do developers react to api deprecation?
the case of a smalltalk ecosystem romain robbes pleiad dcc university of chile rrobbes dcc.uchile.clmircea lungu software composition group university of bern lungu iam.unibe.chdavid r thlisberger pleiad dcc university of chile roethlis dcc.uchile.cl abstract when the application programming interface api of a framework or library changes its clients must be adapted.
this change propagation known as a ripple effect is a problem that has garnered interest several approaches have been proposed in the literature to react to these changes.
although studies of ripple effects exist at the single system level no study has been performed on the actual extent and impact of these api changes in practice on an entire software ecosystem associated with a community of developers.
this paper reports on an empirical study of api deprecations that led to ripple effects across an entire ecosystem.
our case study subject is the development community gravitating around the squeak and pharo software ecosystems seven years of evolution more than contributors and more than distinct systems.
we analyzed methods and classes that were deprecated and answer research questions regarding the frequency magnitude duration adaptation and consistency of the ripple effects triggered by api changes.
categories and subject descriptors d. .
restructuring reverse engineering and reengineering keywords ecosystems mining software repositories empirical studies .
introduction most of the software engineering research focuses on tools and techniques for analyzing individual systems quality assessment defect prediction automated test generation impact analysis all are techniques that aim at supporting the developer and improving the resulting software.
however a software system does not exist in isolation but instead it is frequently part of a bigger software ecosystem in which it usually depends on other systems and sometimes other systems are dependent on it.
ecosystems usually exist in large companies organizations or open source communities.
as more and more of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.our society s infrastructure runs on software the size and number of such ecosystems increases.
in this context research should also focus on designing tools and techniques to support developers working in software ecosystems.
a number of problems that are relevant for individual system analysis are likely to remain relevant at the ecosystem level and the importance of some problems might even augment.
in this article we set out to discover whether the problem of impact analysis and prediction that has been studied already at the level of individual systems is also relevant at the ecosystem level.
when a project that contains functionality reused by many others in the ecosystem changes this might trigger a wave of changes in the ecosystem.
at the moment there is no tool support for predicting such changes so the developers often do not know whether their change will impact other systems or not.
two anecdotal examples illustrate the problems and opportunities associated with the lack of tool support for change impact analysis at the ecosystem level .while discussing with developers of a large corporation we discovered that sometimes a developer would make a change but he would only find out whether his change impacted some other systems multiple days later.
this was a result of a very long build cycle.
.while studying the mailing list archives of the seaside project part of the squeak pharo ecosystem we discovered an email in which one developer was asking about several classes that his application was depending on but he could not find in the latest version of the framework.
one of the seaside maintainers answers1 they have been dropped.
a mail went out to this list if anybody still used them and nobody replied.
personally i don t know of any application that uses these dialogs.
but how often do such changes that impact other systems happen and how broad is their impact?
take the example of the following event in the squeak pharo ecosystem at some point the fillintheblank class a broadly used utility class was deprecated and its responsibilities moved to the uimanager class.
figure 1shows how the usage of fillintheblank initially increased and then abruptly de creased as all the clients were moving towards using the uimanager instead.
more than projects were impacted by the deprecation.
these examples hint at the necessity of providing tool support for maintaining a continuous awareness of the potential impact of a change at the level of the ecosystem.
however they are only anecdo tal.
to the best of our knowledge there has been no large scale study 1entire exchange available at the usage over time of classes fillintheblank left and uimanager right which takes over its responsibilities that would quantify how severe is the problem of change impact at the ecosystem level.
the only studies available are performed at smaller scales studying frameworks in isolation without taking their clients into account .
research goals the goals of this article are to determine whether there is enough evidence for the necessity of building automated supportfor impact analysis at the ecosystem level if needed provide a sketch of a solution and whether we can provide immediate actionable information to alleviate the problem.
to do this we set out to quantify how often a change in a system will trigger changes in the other systems of the ecosystem.
in this study we focus on the special case of deprecated entities i.e.
api elements that are explicitly marked to indicate they are scheduled for later removal.
this paper reports on an empirical study on the impact of api changes in the squeak pharo software ecosystem.
we analyzed methods and classes that were indicated as deprecated in various frameworks and core libraries by squeak and pharo developers.
in each case we recorded how projects in the ecosystem reactedto the deprecation of the method we determined that method deprecations and class deprecations caused ripple effects in client projects later on.
we investigate the following research questions in order to better characterize the ripple effect phenomenon frequency.
rq1.
how often do deprecated api methods cause ripple effects in the ecosystem?
magnitude.
rq2.
how many projects react to the api changes in the ecosystem and how many developers are involved?
duration.
rq3.
how long does it take for projects to notice and adapt to a change to an api they use?
adaptations.
rq4.
do all the projects in the ecosystem adapt to the api changes?
consistency.
rq5.
do the projects adapt to an api change in the same way?
rq6.
how helpful was the deprecation message if any?
structure of the paper.
we start with a review of related work section .
we then present a list of challenges for api change analysis section and the characteristics of our case study the squeak pharo ecosystem section .
we then introduce our ecosystem model and the way we model api changes and ripple effects section .
we describe our methodology to detect ripple effects triggered by deprecation section before presenting our results section .
we close the paper with a presentation of the implications of our study section a discussion of the threats to its validity section and conclude in section .
.
related work our work directly relates and builds on three research areas analyses of software ecosystems and large collections of software projects studies about ripple effects and the evolution of apis and approaches that assist developer confronted with api changes.
.
software ecosystems analysis the term software ecosystem has several meanings some focus on the business aspect others focus on the analysis of multiple software systems aspect .
for the purpose of this work use the latter meaning and more precisely we consider an ecosystem to be a collection of software projects which are developed and co evolve in the same environment .
the environment can be an organization or an open source community.
the focus is on analyzing multiple systems which have common underlying components technology and social norms .
ecosystem analysis research has two facets the study of the social aspects embodied in the developer collaboration and the study of the source code of the component systems.
jergensen et al.
study the way the developers migrate across the projects in an ecosystem .
in previous work we focused on reverse engineering a software ecosystem by generating high level views capturing various aspects of its structure and evolution .
other approaches focus on discovering and comparing methods extracting dependencies between the projects in an ecosystem .
gonzalez barahona et al.
performed a study of the debian linux distribution in terms of the evolution of its size and of its programming languages .
the analysis of large source code data does not necessarily involve an ecosystem.
code search was the first application of source code analysis beyond the scope of the individual system the first academic search engine sourcerer was followed by several other efforts .
in mockus studied the phenomenon of large scale software reuse in a selected group of open source projects .
two years later mockus reported on his experience in amassing a very large index of version control systems .
gruska et al.
mined a large sample of linux projects to extract usage properties from their source code to subsequently detect usage anomalies .
they do not consider the evolution.
.
ripple effects and api evolution in this paper we investigate how clients react to changes in frameworks and libraries they use.
our goal is to understand the propagation of the changes in the ecosystem as a whole and to examine whether we can predict and support their propagation.
similar studies have been performed at smaller scales.
the work of haney yau et al.
and black investigated ripple effects and possible methodologies to address them at the scaleof a single system.
one of them is impact analysis .
later studies were performed on frameworks libraries and their clients in particular.
dig and johnson studied the evolution of the api of four frameworks and one library and concluded that in of the cases the changes that break clients of a library or framework are refactorings .
similar earlier work was performed by opdyke onrefactorings and graver on the evolution of an object oriented compiler framework .
graver used refactorings successfully during the evolution of a compiler when extending it to incorporate types he does not comment on whether the documented changes impacted the api of the framework.
likewise tokuda and batory applied refactoring operations on two object oriented designs in order to recreate the changes between versions of these systems.
in their case the api changes were extensive .
to our knowledge we are the first to undertake a study on the effect of api changes on actual clients of libraries and frameworks.
.
reacting to api changes several automated approaches have been proposed to react to external changes.
zeller introduced delta debugging which partitions the change sets in a version control archive in order to pinpoint the change being the cause of a bug .
later both henkel and diwan and ekman and asklund proposed to record the refactorings performed in an ide on the source code ofthe framework in order to replay them in the client .
dig et al.
built a refactoring aware versioning system storing the refactorings and the other source code changes in a single repository .
in the absence of recorded refactorings several approaches detect them from several versions of a library.
weissgerber and diehl used a technique based on signature changes and clone detection in the method bodies while dig et al.
use shingle encoding of asts to quickly compute the similarity between candidates across versions and then used semantic analyses to refine the candidates .
taneja et al.
expanded dig s technique to work for library apis that do not have callers .
kim and notkin identify systematic changes including refactorings based on a logic engine .
several approaches go further and recommend changes to be made in order to recover from the api change.
dagenais and ro billard observe how the framework itself adapted to its changes while schaffer et al.
observe how other clients adapted .
wuet al.
introduced an approach incorporating text similarity and handling more complex cases .
dig et al.
adopt the opposite approach and introduce a layer between the client and the new version of the library so that the client is shielded from the changes .
holmes and walker also adopt a different viewpoint and monitor the versioning system of libraries used by a system and filterchanges according to how relevant they are for the system i.e.
whether the system uses the entities that were modified or not .
in all cases the approaches were validated on a selected number of frameworks for statistically typed programming languages.
.
challenges in ecosystem and api change analysis to analyze api changes and determine if they trigger ripple effects we need a reliable process to detect them in the large amount of data at our disposal.
this process has three main steps curating the data building a model of the ecosystem and generating a list of candidate api changes and their impact on clients.
this process is subject to a set of challenges .curating the data.
determining which projects are part of the ecosystem can prove to be a challenge in itself.
some communities especially larger ones may spread over multiple websites that need to be individually crawled to gather the data.
in our case this problem is simpler since the squeak pharo community mainly uses a single web site to store source code.
.modeling thousands of evolving systems.
an evolving ecosystem contains a large amount of data that must be handled appropriately with the correct level of abstraction.
in the case of ripple effect detection we must model changes to the api of systems and do so between individual versions of systems theecco meta model is our proposed solution.
.detecting ripple effects.
after the model of the ecosystem is built the ripple effects themselves original api change and reactions and adaptation of the clients over time must be modeled and detected.
the next three section detail how we addressed these challenges.
.
the squeak pharo ecosystem our first task was selecting an adequate ecosystem that would provide support for answering our research questions.
we chose the ecosystem built around the squeak and pharo open source development communities pharo is a fork of squeak .
it is hosted by the squeaksource2source code repository.
since squeaksource hosts a large number of individual repositories of a distributed language aware version control system named monticello.
squeaksource is the foundation for the software ecosystem that the squeak and pharo communities have built over the years.
as of march squeaksource hosts systems in which contributors performed more than source code commits.
the combined size of all the versions is more than .4gb of compressed source code monticello stores versions as zip files .
.
the squeak and pharo communities squeak is a dialect of smalltalk as well as an implementation of its programming environment.
it was created in and has gathered around it an active community.
the one laptop per child initiative delivered the laptops with the etoys end user programming implemented in squeak.
the seaside web development framework the main competitor for ruby on rails as the framework of choice for rapid web prototyping is developed by the squeak community.
the moose analysis platform has been ported to the pharo platform.
pharo forked from squeak in early .
it is now a distinct smalltalk distribution with a distinct but somewhat overlapping community.
one of the main goals of pharo has been to provide a distribution of smalltalk with a wide set of libraries an ide and other applications which are all open source and liberally licensed.
as a sign of the distinction between the two communities pharo has a distinct mailing list a separate web presence 3and is rapidly evolving.
if squeak s goal is to be an inclusive development platform featuring multimedia facilities an environment for children programming etc pharo is geared towards being a development platform more catering to the industry and the academia.
as such since the fork the pharo community has been a large amount of refactoring and cleanup of its code base.
if these two communities are growing apart they still share the same version control infrastructure monticello for version control and the squeaksource repository.
.
the monticello version control system monticello is a distributed language aware version control system.4when performing a commit of a project with monticello a snapshot of the source code is stored.
since this process does notinvolve computing deltas with the previous version a monticello repository is simply a file system directory.
besides the snapshot of the source code monticello versions record meta information such as author time stamp commit comment and particularly useful for evolution analysis version information each monticello version contains the list of all its ancestor version referenced by name.
monticello is also language aware it is designed to version smalltalk source code only.
as such versioning is not performed at the level of files and lines but at the level of packages classes and methods.
this allows the differencing and merging algorithms to use much richer information than more conventional versioning systems easing the process for the developer and for our analyses at the price that other resources beyond source code need to be handled separately .
the squeaksource super repository squeaksource is an online source forge built with the seaside smalltalk framework which is the foundation for the software ecosystem that the squeak and pharo community have built over the years.5squeaksource has been operational since late and publicly announced in early .
it has quickly become the de facto platform for sharing open source code for the squeak and pharo communities.
today the overwhelming majority of squeak and pharo developers use squeaksource as their source code repository making it a nearly complete view of the squeak and pharo software ecosystem.
at its core squeaksource is simply a set of monticello repositories hence a super repository accessible via http where people can commit their source code.
squeaksource provides accounts for developers who can define projects on the web site and specify who can access their projects ie.
granting read write access to the project s individual repository .
it also provides services such as perproject presentation pages rss feeds wikis and overall statistics and enables one to browse the source code of any version stored on the web site provided one has access rights to do so.
an alternative to our choice would have been to analyze a development community centered on a more popular language such as java developers.
this would have implied a distinct set of trade offs.
even if monticello and squeaksource have shortcomings they are extremely convenient to process as the data is centralized on one server and is simply structured in file directories and we can reuse monticello s language awareness to work with object oriented concepts instead of text files.
to summarize the reasons for the choice of the squeak pharo ecosystem as a case study are squeaksource is the de facto source code repository for the overwhelming majority of the open source code produced by the squeak and pharo communities.
the community more than contributors strong is large enough to be relevant.
the versioning system used by the community monticello is a high level versioning system working at the level ofpackages classes and methods instead of files and lines of code thus considerably simplifying our analysis.
several large and widely used frameworks are hosted onsqueaksource as well as a variety of smaller ones.
overall several hundred projects can be classified as frameworks.
the fact that the community has forked is a factor that con tributes to the frequency of api changes and ripple effects.pharo wants to clean up its code base incurring a lot ofchanges making it less compatible with squeak code and triggering frequent updates for pharo developers.
this may or may not affect squeak developers.
.
modeling evolving ecosystems .
the ecco evol metamodel there are two conflicting requirements that need to be addressed by an ecosystem model that allows the detection of api changes and ripple effects in ecosystems on the one hand the model should be lightweight enough to allow the modeling of a large number of projects each of which might in turn have a large numbers of versions on the other hand the model should represent ecosystem and record the details of each of the versions such that the structural changes between versions can be tracked and used to determine the occurrences of ripple effects.
to build such a model we drew inspiration from two previous ecosystem models that we proposed in previous work ecco is a lightweight language independent representation of the data in ecosystem snapshots providing full language dependent access to the details on demand.
ecco s main unit of abstraction is the system.
each system maintains lists of provided defined in the system and required used by the system entities over its lifetime.
based on these lists of provided and required entities one can recover dependencies between systems e.g.
if system b requires a set of entities and system a is the only provider of these entities in the ecosystem we can infer that b depends on a .
ecco does not represent multiple versions of a system.
revenge is a meta model that supports modeling the structural evolution of an ecosystem in our previous work we have proposed it as a generic language independent ecosystem meta model which supports evolutionary analysis.
the model uses a full famix model to represent every version of theindividual systems.
this turns out that is very expensive both in terms of building the models maintaining them and executing operations on them.
we enhanced ecco with a model of versions inspired by revenge we model an ecosystem with systems and versions but for each pair of successive versions we only keep a delta.
we call this new meta model ecco evol .
added removed required provided...system history version version version i version n ... version i figure ecco evol models every version as a delta figure 2shows that in ecco evol each version keeps track of the changes between itself and its predecessor.
these changes are highlevel and consist in sets of additions and removals of required and provided entities methods and classes .
in addition to changes the meta model keeps track of metadata author time stamp and links to ancestors and successors versions.
the model allows more than a single link to ancestors and successors in order to accommodate forks and merge operations.
the model allows details on demand each version contains a link to its original snapshot on the file system and can use monticello s infrastructure to inspect the definitions contained in it as well as performing differences with its ancestors and successors.
.
detecting api changes and ripple effects at the level of the ecosystem a ripple effect is determined by a change to a system s api which originates in one system and propagates to other systems.
a ripple effect is a pair of two elements co ci i n co an original source code change in an original project po .
this change must mutate in some way the api of the project e.g.
by adding removing or modifying artifacts ci i n a set of changes which belong to projects that are distinct from the original project po which are performed as the direct consequence of the original change co and mutate the source code of the impacted project e.g.
by adding removing or modifying artifacts .
we simplify the problem of ripple effects in the ecosystem in two ways.
first we consider that ripples propagate only one level from the source.
ripples of higher degrees where a change triggers other changes which in turn trigger yet other changes remain for future work.
second we consider the ripple effects based only on a very specific semantic change deprecation even detailed static analysis may not always be able to infer whether a generic semantic change will affect other artifacts.
this becomes even harder at the scale of an entire ecosystem.
in contrast a deprecation is an explicit statement of intent that the api is changing.
when looking at the syntactic changes of the original source code change we consider two types of artifacts classes and methods.
for each type of entity there are three elementary changes that one can introduce in a project that can later propagate to other projects .addition of provider.
the change introduces a new entity that will be provided by a project.
in most of the cases this means extending the api of the system.
.removal of provider.
the change removes an entity that was provided by the project.
in most cases this means removing a method from the api of the project.
.modification of provider .
this changes the provided entity in some way.
a special case of this is annotating a method or class as deprecated tagging it for later removal.
a provider addition does not render the client incompatible with the provider and therefore does not force him to react.
therefore we can not be sure that simple additions will introduce ripple effects.on the other hand removing or renaming a provided entity that a client uses effectively forces them to update or use the outdated version of the framework.
a search for ripple effects based on method removals and renames will provide a lower bounds on the number of api changes causing ripple effects in the ecosystem.
the case of removal must be treated with attention.
the developers of a library or a framework might decide to never actually remove a provided artifact but instead just mark it as deprecated through annotations or special method calls signaling in this way that in future versions of the system that artifact is likely not to be supported anymore.
in fact this is the most disciplined way to remove a method while allowing the clients time to react to thechange.
in this article we focus on changes to the provider that deprecates it as this is the clearer indication that an api change is taking place.
.
methodology to build and validate the list of api changes causing ripple effects occurring in the ecosystem as a result of method deprecations we employ the following methodology.
generate a list of candidates we query the model of the ecosystem for every usage of a given method.
to generate our list of candidate changes to analyze we operated under the assumption thatdeprecated methods are a marker of api changes and as sucha likely cause of ripple effects.
indeed deprecated methods are explicitly tagged for later removal.
when deprecating a method smalltalk users insert a call to a deprecation method in the body of the deprecated method.
each call to the deprecated method will output a warning at run time.
the following method in moose a reverse engineering environment was deprecated the deprecation message indicates the preferred alternative addentity anelement self deprecated use add instead .
self add anelement.
we query the ecosystem for all the commits that introduce a requirement to one of the deprecation methods the actual deprecated method is then extracted from the differences between the two snapshots.
in total methods were deprecated in the ecosystem in the period from to .
in addition we expanded the scope of our search by also considering the classes that featured a deprecated method.
in some cases a deprecated method is moved from one class to another if we do not consider the classes we do not see this kind of changes if the name of the method stays identical.
assess usage of each candidate we filtered the initial set of deprecated methods leaving only the ones for which the method has been removed in at least transactions over time.
this filters a portion of the methods that are removed as a result of the natural evolution of the system6.
we manually inspected each of the remaining candidates to assess whether they caused a ripple effect.
to do so we assessed the following parameters number of projects using the candidate at least two distinct projects must be using the method class the originating project and a client .
evolution of the usage of the candidate over time as shown in the graphs of figure .
deprecated api elements causing ripple effects experience a drop of usage after a point whereas others will usually grow in usage continuously or stabilize.
methods or classes that are replacements of other entities may sometimes see their popularity surge.
inspect changes to confirm and determine replacements for each candidate we analyze the related changes.
we retrieve the list of changes between each two versions in which the candidate was involved using monticello s infrastructure filter the list of changes keeping the list of methods that were changed and who have