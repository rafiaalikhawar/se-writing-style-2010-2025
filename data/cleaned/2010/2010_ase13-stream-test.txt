testing properties of dataflow program operators zhihong xu university of nebraska lincoln ne zxu cse.unl.edumartin hirzel ibm watson research yorktown heights ny hirzel us.ibm.comgregg rothermel university of nebraska lincoln ne grother cse.unl.edukun lung wu ibm watson research yorktown heights ny klwu us.ibm.com abstract dataflow programming languages which represent programs as graphs of data streams and operators are becoming increasingly popular and being used to create a wide array of commercial software applications.
the dependability of programs written in these languages as well as the systems used to compile and run these programs hinges on the correctness of the semantic properties associated with operators.
unfortunately these properties are often poorly defined and frequently are not checked and this can lead to a wide range of problems in the programs that use the operators.
in this paper we present an approach for improving the dependability of dataflow programs by checking operators for necessary properties.
our approach is dynamic and involves generating tests whose results are checked to determine whether specific properties hold or not.
we present empirical data that shows that our approach is both effective and efficient at assessing the status of properties.
i. i ntroduction dataflow programming languages represent programs as graphs of data streams and operators.
this representation facilitates parallelization since each operator can run independently subject only to availability of data on its input streams.
furthermore these languages feel natural to programmers who wish to process large amounts of data.
dataflow languages have been the subject of much research as chronicled by several survey papers .
moreover thanks to the advantages of parallelism and a data centric paradigm dataflow languages have received a lot of commercial attention for their ability to analyze big data .
there are many examples of dataflow programming languages and systems for executing dataflow programs.
pig latin flumejava and other languages compile to mapreduce a system that parallelizes programs over hundreds of machines and has been used in building google s search index.
while mapreduce provides a batch approach for executing dataflow programs another execution approach is stream processing which continuously analyzes data streams online as they are produced.
languages that support stream processing include streamit which emphasizes optimizations for media streaming kernels and the streams processing language spl which has use cases in telecommunications healthcare financial trading and several other domains .
systems for executing stream processing dataflow programs include borealis and ibm s infosphere streams both of which run on clusters.
the semantics of dataflow programs depend on the semantic properties of the individual operators they employ.
theseproperties include determinism selectivity blocking statefulness commutativity and partition isolation we define these in section iii .
unfortunately in current research and practice operator properties frequently remain unchecked.
this can have serious consequences.
for example aconfluent dataflow graph is a graph in which two paths converge on a single operator.
this operator must either be commutative or enforce data ordering using blocking or state .
if none of these properties hold the entire program is non deterministic.
furthermore blocking operators may cause deadlocks .
themapreduce programming model assumes that the map operator which is used to filter data and partition it into subsets by key is stateless and the reduce operator which is used to aggregate data is partition isolated .
languages meant to run on mapreduce do not check these properties for user defined code .
if the properties do not hold mapreduce may yield unpredictable results.
compiler optimizations for dataflow programs rely on operator properties.
for instance synchronous dataflow languages use operator selectivity for scheduling and buffer allocation .
some parallelizers require stateless operators while others accommodate stateful operators that satisfy partition isolation .
if properties are unknown the program cannot be optimized if properties are unreliable the program may be optimized incorrectly.
these examples illustrate that operator properties offer clear benefits.
further operator properties are not overly difficult to specify because an operator developer need only indicate whether a property holds for an operator or not.
even so once specified the correctness of operator properties should be verified and in the absence of specifications it would still be useful to have a means for determining whether particular properties hold for given operators.
one approach that might be used to check operator properties for dataflow programs is static analysis.
this is challenging for several reasons.
operator code often uses pointers and multi threading leading to a large analysis state.
this causes static analyses to be expensive and to produce overly conservative results.
another issue is that real world dataflow programs tend to be multi lingual.
for example spl programs often use operators written in spl c or java .
static analyzers need to handle each language involved as well as cross language interactions.
a third impediment to static analysis is code generation.
for example operators for978 .
c ieee ase palo alto usa103xml processing or composite event detection are actually mini compilers and it is difficult to statically analyze a compiler to determine properties of the code it generates.
this paper presents a dynamic analysis approach for verifying properties of dataflow operators .
given a property and an operator our technique generates tests and checks their results to observe whether the property is violated.
the analysis results are easy to understand they either indicate that no counter evidence for the property was found or if the property is violated they include a concise concrete input as evidence for why it does not hold.
our approach is analogous to the unit testing of individual components that make up a traditional software system.
in dataflow programs these components are operators supplied with dataflow processing systems or created by engineers to enact particular operations.
by applying our approach to these operators engineers can help ensure that the building blocks on which their programs are founded behave appropriately prior to fielding entire programs in which failures can be more difficult to detect and faults can be more difficult to localize.
in this paper we make three significant contributions we are the first to formally define core properties of operators in dataflow languages including the properties of determinism selectivity blocking statefulness commutativity and partition isolation.
we describe a testing methodology for checking whether these operator properties hold.
our methodology requires only the operator under test.
no prior test inputs are needed and the operator may be written in any language and may even use code generation.
our methodology gains efficiency by sequencing the consideration of properties intelligently in a manner that allows us to check fewer properties overall.
we present empirical results on a suite of spl operators that are widely used by engineers to create dataflow programs.
our results compare several test generation techniques across our target properties and show that our approach is both effective and efficient.
ii.
b ackground and related work a. dataflow program terminology dataflow programs involve streams and operators.
we distinguish between operator instances and operator definitions .
an operator instance at the program level is a vertex in a dataflow graph.
an operator definition is a configurable blueprint for operator instances.
figure shows a simple financial streaming application.
operator instance septq separates a market feed into trades and quotes.
the instance avgprice of the aggregate operator computes for each stock symbol the average price over the last seconds.
the instance match of the join operator finds deals higher than average quotes .
the instance sumprice of the average operator adds the profit from all deals not partitioned by stock symbol.
different instances of the same operator can have different properties.
for example in figure the avgprice instance of aggregate is partitioned whereas the sumprice instance is not.
septq custom avgprice aggregate match join sumprice aggregate stream operator instance operator definition port feed quotes deals profit fig.
.
sample application therefore the objects of analysis in this paper are operator instances not operator definitions.
that is to say operator instances constitute the basic unit of dataflow programs that our approach tests individually.
the point at which a stream connects to an operator is called aport as shown in figure .
we are concerned only with operators that have at least one input and one output port.
astream is an ordered sequence of data items and punctuations.
a data item is a stream element that carries payload information of interest to the application.
in this paper we are not concerned with the format or representation of data items they may be as simple as integers or as complicated as records with deeply nested data structures.
a punctuation is a control signal that carries no further information it is used to separate batches of data items for example to indicate window boundaries.
because streams are conceptually infinite reliable first in first out communication channels many operators use the window concept to limit the number of data items in the stream.
for example avgprice in figure uses data items from the most recent seconds.
we assume a model in which the arrival of a data item or a punctuation at an input port of an operator triggers an operator firing .
when an operator fires it performs some computation which may cause data items and punctuations to be submitted to some or all of its output ports.
b. related work in our review of prior work we could find no attempts to formally define the properties of dataflow operators.
further while we found some static analyses capable of checking some properties we found no dynamic analyses or testing techniques for determining semantic properties of operators.
olston et al.
present a technique for generating example data for dataflow programs.
they use a dynamic test case generation approach as we do.
while they create example data relevant to the entire behavior of a whole dataflow graph we focus on specific properties of single operator instances.
one drawback of their technique is that it requires sample data as well as elaborate specifications for each operator equivalence classes and inverting computation .
in contrast our technique requires only the subject operator instance.
most of the remaining related work on checking properties of dataflow operators uses static analysis.
static analysis can produce false positives while dynamic analysis can produce false negatives.
it is meaningless to say that one or the other is better in general for our task either could be useful.
we begin with dynamic analysis because we need to analyze multiple languages including generated code which would be difficult with static analysis.
another advantage of dynamic analysis in our setting is that it can easily generate concrete evidence for a true positive.
this is more difficult with static analysis.104rinard and diniz present a static analysis for commutativity in a c subset which they use for auto parallelization.
raman et al.
describe an analysis that breaks the body of a c loop into dataflow operators and also discovers operator statefulness which they use for auto parallelization.
jayaram and eugster analyze eventjava to discover inter operator properties that help reduce communication overhead in contrast we focus on properties of individual operators.
hueske et al.
statically analyze java code for selectivity readsets and write sets.
schneider et al.
statically analyze spl code to discover selectivity statefulness and partition isolation for use in auto parallelization.
an attractive alternative to static and dynamic analysis is to establish dataflow operator properties by construction in the language design.
in streamit selectivity and statefulness are immediately obvious from the code and the compiler exploits that for scheduling buffering and auto parallelization .
dryadlinq can use annotations to establish a property they call associativedecomposable used for the partial aggregation hoisting optimization .
in general however dataflow applications often call out to traditional languages like c or java for some of their functionality at which point the design of the dataflow language alone cannot establish semantic properties.
iii.
p roperties for this work we selected six operator properties that are particularly important for reliability and optimization of dataflow programs.
we left some less important properties such as idempotence associativity and attribute forwarding to future work.
this section introduces the six properties.
we consider only properties for which our approach can potentially find certain evidence via testing so we define each property with existential quantifiers .
a. notation and wellformedness before introducing the properties we define the notation used in their formal definitions.
square brackets denote lists curly bracesf g denote sets and angle brackets h i denote tuples.
the underscore is a don t care binding a wild card .
the remaining notation comes from first order predicate logic.
the definitions use the following domains data domain d dataitems f g. each d2dis either a data item a punctuation denoted or a divergence denoted meaning that no more input can be sent to a given port of an operator due to blocking .
input domain i d n. each input i2ito an operator firing is a pair consisting of a stream element and an input port number.
for example h1 0iindicates stream element 1on input port .
output domain o list d n .
each output o2ofrom an operator firing is a list of hstream element output port numberipairs.
for example indicates stream element 2on output port 0and then output port .
execution trace domain trc op list i o .
each trace t2trc op for an operator opis a list ofhinput outputi pairs.
for example trace hh1 0i i hh1 0i i has twooperator firings each consisting of an input stream element on port and an empty output .
the formal definition of a property pis specified as a predicate p op of an operator instance op.
variables must be bound as formal parameters or via quantifiers 9or8 or by appearing on the left side of a pattern match whose right side is fully bound for example if tandjare bound then hi i t binds i .
b. non determinism a deterministic operator always generates the same output sequences for a given input sequence.
if an operator generates two different output sequences for the same inputs it is nondeterministic.
for example an aggregate operator instance with a window based on physical machine time may generate different outputs if it receives the same inputs with different inter arrival times.
definition.
isnondeterministicop op 9t t02trc op sameinput t t0 differentoutput t t0 sameinput t t0 8j2dom t hi i t hi0 i t0 i i0 differentoutput t t0 9j2dom t h oi t h o0i t0 o6 o0 for example traces i and i for an operator have different outputs for the same input stream these provide evidence that the operator is non deterministic.
motivation.
whether or not determinism is required depends on the application.
knowing about non determinism is important especially when users require an application s outputs to be repeatable.
if any operator in an application is nondeterministic the entire application may be non deterministic.
if the outputs from the application differ for the same input data simply diffing outputs is insufficient for correctness checking.
thus engineers using our approach can detect potential faults in operators and debug them more effectively.
c. selectivity selectivity constrains the number of data items produced by an operator per data items consumed.
if an operator produces 1data items for at least one firing it is prolific for example this is the case for a split operator configured to duplicate its input data items on multiple output ports.
if an operator produces 1data items for all firings and none for at least one firing it is selective for example this is the case for a filter operator configured to output data items meeting some criterion.
if an operator produces exactly data item for each firing it is one to one for example this is the case for a custom operator configured to count the number of input data items received and output the current count each time it fires.
definition.
isprolificop op 9t2trc op isprolific t isprolific t 9j2dom t h oi t multipletuples o multipletuples o 9k k02dom o k6 k0 hd i o hd0 i o d2tuples d02tuples105isselectiveop op isprolificop op 9t2trc op isselective t isselective t 9j2dom t h oi t notuples o notuples o 8k2dom o hd i o d 2tuples isonetooneop op isprolific op isselective op for example since trace i has one input h1 0iwith two outputs h1 0i h1 1i it is evidence for an operator being definitely prolific.
on the other hand trace i hh2 0i i has no output for input h2 0i which is evidence for being potentially selective.
motivation.
selectivity can be used for scheduling and allocating buffers to improve performance .
it can also help in parallelization since it can simplify sequence numbers for ordering .
providing correct selectivity specifications thus enables safe optimization.
operator developers can use our technique to increase their confidence that they have specified selectivity correctly.
d. blocking unlike the previous two properties blocking is specific to an input port.
input port pis blocking if a firing can get stuck partway so no further firings are possible at puntil it is unblocked.
for example the gate operator in spl blocks one input port until it receives an acknowledgment from another input port.
definition.
isblockingop op p 9t2trc op isblocking t p isblocking t p 9j2dom t hh pi oi t 9k2dom o h i o for example trace i hh1 0i i provides evidence that the operator is blocking on input port p .
motivation.
blocking can help ensure that stream elements are placed in proper order.
a stream graph with a confluence but without a blocking or stateful operator may behave unpredictably.
however blocking is also the main source of deadlock in dataflow applications .
a developer trying to locate the root cause of a deadlock can use knowledge about blocking operators as a starting point.
e. statefulness an operator is stateful if its current output is affected by input stream elements earlier in the same trace.
an example in spl is a custom operator configured to count input stream elements and output the current count each time it fires.
definition.
isstatefulop op 9t2trc op isstateful t isstateful t 9j j02dom t j6 j0 hi oi t hi o0i t o6 o0 for example trace i hh1 0i i shows that for the same input stream element there are two different output stream elements this provides evidence that the operator is stateful.
motivation.
a stateless operator is easy to parallelize for better performance and easy to restart or migrate for betterfault tolerance.
on the other hand a stateful operator can buffer out of order stream elements in a confluent graph.
an application developer can use knowledge of which operators are stateful to help establish whether the entire program has predictable behavior.
furthermore many applications inherently need stateful operators for instance for aggregation.
f .
non commutativity non commutativity like blocking is specific to an input port.
an input port pis commutative if a change in the order of input data items sent to pwithin some range such as within a window does not change the outputs.
for example anaggregate operator configured to find the maximum of five input data items is commutative since the order of the five data items does not affect the maximum.
in contrast an aggregate operator configured to find the last of five input data items is non commutative.
definition.
isnoncommutativeop op p 9t2trc op isnoncommutative t p isnoncommutative t p 9j k n2dom t j k endswindow t j endswindow t j n endswindow t k endswindow t k n onlyusesport t j k j n p samesetofinputs t j k n differentoutput t j k n endswindow t j j 1 h oi t 9k2dom o h i o onlyusesport t l n p 8j2dom t l j j l n hh p0i i t p p0 samesetofinputs t j k n fi l2dom t j l l j n hi i t g fi l2dom t k l l k n hi i t g differentoutput t j k n h oi t h o0i t o6 o0 for example i hh2 0i i followed by i hh1 0i i shows that after changing the order of two input data items the output data items are different before the window punctuation this trace provides evidence that the operator is non commutative.
motivation.
when two paths in a dataflow graph converge on a single operator differences in the speed and scheduling of upstream operators can cause data items to be out of order.
in general this can lead to application level non determinism even if all individual operators are deterministic.
an application developer can use commutativity to find out whether an operator tolerates disorder.
g. partition interference a partitioning keyis a part of each input data item used for processing subsets of the stream separately.
keys are often simply record attributes but to keep the definition general we write read d k for reading key kfrom data item d. in spl such keys are specified by configuring an operator with106operator under test analyzer property of interest property value and evidence spl compiler and runtime environment test program and input test output fig.
.
testing framework apartitionby parameter.
in a partition isolated operator output data items for one key are not affected by input data items with different keys.
if data items with different key values can affect each other the operator is partition interfering.
for example anaggregate operator configured to compute the average price of a stream of stock trades separately for each stock symbol is partition isolated.
on the other hand an aggregate configured to add the prices of a stream of deals irrespective of stock symbol is partition interfering.
definition.
ispartitioninterferingop op k 9t t02trc op 9c2d sameinputs t t0 k c differentoutputs t t0 k c sameinputs t t0 k c differentoutputs t t0 k c for example in the traces i hh2 ci 0i i and i hhh1 c0i 0i i hh2 ci 0i i an input data item whose key c0differs from the key cof the other two input data items affected the output.
this pair of traces provides evidence that the operator is partition interfering.
motivation.
partition isolation is useful for parallelization .
an optimizer can parallelize partition isolated operators by using a hash split thus giving each operator replica a disjoint partition of the key domain.
operator developers can use our approach to test whether they mistakenly created operators that are partition interfering.
iv.
t esting methodology the desired value of an operator property in the context of a dataflow program depends on the intent of the program s developer.
for example a developer could use a stateful operator on purpose to compute an average or use a stateless operator on purpose to simplify parallelization.
in either case a mismatch between the developer s intent and the actual fact is a defect.
this section introduces a testing framework for determining operator properties.
a. testing framework figure shows our testing framework.
the main component is the analyzer which takes as input the property that userswant to test and an operator under test out .
the analyzer generates a test program wrapping the out and sends it to the spl compiler to generate an executable program.
the analyzer then generates inputs appropriate for the property and executes the program using the spl runtime environment.
execution results are returned to the analyzer which checks whether evidence is found to show that the property holds.
if evidence is found the analyzer presents users with that evidence.
if evidence is not found the analyzer generates additional tests until it reaches a technique time limit and on reaching that limit reports that the property potentially does not hold.
the analyzer can also report statistical information that can help users assess the extent of the evidence provided.
for example suppose that a developer creates an operator op that is required due to expected compiler optimizations e.g.
as per to be stateless.
suppose the analyzer generates test cases that serve as evidence that opis stateful.
presented with this evidence the developer can correct their code or take other necessary steps to ensure that incorrect optimization does not occur.
if on the other hand the analyzer finds no test cases that indicate that opis stateful the developer can have some confidence even if not certainty that opis stateless.
we now describe how the analyzer wraps an out to form a test program that produces output as part of test oracles.
figure shows the dataflow graph of a test program that contains four operator instances source controller the out andsink.source reads in a test from a file.
controller sends input stream elements from source to the appropriate input port of the out .
most out s have exactly one input port and one output port but an out can have multiple input and output ports.
the out receives the stream s from controller and executes to generate output stream s .
sink reads the stream s from out and prints them out.
the printed information from controller andsink is used by the analyzer to make decisions.
source controller operator under test sink fig.
.
dataflow graph of test program b. testing order the order in which operator properties are tested is important the status of certain properties can preclude the need to check others.
thus we have analyzed the relationships between properties in order to identify a testing order that maximizes testing efficiency.
our testing order is the partial order shown in figure .
the numbers shown in the figure are discussed later.
as the figure shows the first and most important property to test for is non determinism.
if an out is non deterministic it is less important to test for other properties in practice because they are harder to exploit.
from the definition of selectivity we can see that it focuses on the out s behavior after each single input stream element while other properties focus on two or more stream elements so selectivity is independent of other properties.
thus we can test for selectivity before after or in parallel with other properties.107selectivity prolific selective one to one non determinism yes no blocking yes no statefulness yes no non commutativity yes no partition interference yes no fig.
.
testing order next we check whether the out has two or more input ports.
if it does we check blocking first because blocking situations in spl occur only when one input port is stalled while the operator instance waits for data on another input port.
if the out is blocking it is stateful so we can skip the check for statefulness and directly check for non commutativity and partition interference.
if the out is non blocking or if it has only one input port we check whether it is stateful first.
if it is not stateful it is commutative and partition isolated and requires no further checking.
if it is stateful we check noncommutativity and partition interference.
c. testing each property the formal definitions of the properties given in section iii provide insights into ways to design testing strategies.
algorithm describes our general testing strategy encapsulating property specific details in calls to four functions initialize generatetest checkproperty and evidencevalue .
table i shows the functions for each of the six properties in detail.
below we provide additional comments on the specific design choices used to perform property testing for spl.
algorithm algorithm for checking properties evidence null initialize property while evidence null techniquetimelimit reached do test generatetest property evidence checkproperty property test end while return evidencevalue property evidence non determinism the main cause of operator nondeterminism in spl is the inter arrival time of stream elements so we need to include this factor in tests.
an input for non determinism thus includes stream elements and port numbers as well as delays between those stream elements.
selectivity the functions for testing selectivity in table i follow directly from the formal definition.
blocking in spl blocking occurs in operators with more than one input port.
such operators can block one port for synchronization until an expected stream element arrives at another port.
therefore our tests contain stream elements for only the input port under test.
for blocking we compile the test program into a single process not distributed so thatstream communication is a simple function call.
we check whether the submit function in the upstream operator instance the controller in figure returns within blockingtimelimit .
statefulness the functions for testing selectivity in table i follow directly from the formal definition but for simplicity we input the same data item to each firing.
non commutativity commutativity is specific to a particular input port p. we begin by checking whether submitting data items to this input port eventually causes punctuations to appear on an output port.
let wbe the number of input data items seen before an output punctuation appears.
we generate permutations of wdata items and check whether any two permutations generate different outputs.
partition interference in spl programmers declare partitioning by configuring operators with a partitionby parameter so we need only check those operators for the specified key.
we check two traces one in which all input data items have the same key and the other for the same input data items but interspersed with data items whose keys are different.
d. test generation for this work we created test generation techniques that are particularly appropriate given the characteristics of dataflow operators and our testing methodology along with techniques that facilitate the empirical comparison of techniques.
to create test generation techniques we must first generate tests and there are many approaches that could be utilized to do this.
in this work we begin with a random test generation approach in which for each input to an operator values are randomly chosen within a range appropriate for its type.
we chose this approach because it is relatively simple to implement and provides a baseline for comparison.
random test generation involves a huge search space and thus we sought test generation approaches that reduce that search space.
the second approach that we consider leverages the fact that in spl code there are many comparisons between attributes and constants.
for example some operators will submit data items if one attribute of an input data item equals a number.
if tests cover both sides of those comparisons true and false properties may be revealed.
to create such tests we created a scanner to extract constants such as strings integers and floating point numbers from the code and place this information in pools.
we then randomly select values from these pools.
we call this approach pool based generation.
the third approach that we consider leverages the fact that in spl code there are many operators that use combinations of predicates e.g.
x.y x.name smith .
in this case the selection space for the pool selection approach can still be inordinately large so we apply an approach widely used in combinatorial testing to further reduce the space pairwise testing .
pairwise generated tests cover all combinations of two.
this makes their numbers much smaller than the number of possible random or pool generated tests.
we call this approach pair based generation.
to employ the foregoing approaches in the context of spl we considered two orthogonal features of stream processing108table i function implementations for properties property initialize generatetest checkproperty evidencevalue nondeterminismreturn two lists l1andl2of triples hdelay d piwith the same values for dandp but different delay values.runl1 2withd p values as inputs timed by the delay values.
if the outputs differ return hl1 l2i else return null.ifevidence null return definitely non deterministic else return potentially deterministic .
selectivity setselectiveevidence null.
return list lof pairs hd pi.
runl.
if any firing has output data items return l. if any firing has 0output data items set selectiveevidence l. return null.ifevidence null return definitely prolific else if selectiveevidence null return potentially selective else return potentially one to one .
blocking return list lof pairs hd pi where all pvalues are the portunder test.run l. if any firing stalls forblockingtimelimit return l else return null.ifevidence null return potentially blocking else return potentially non blocking .
statefulness return list lof pairs hd pi where all dvalues are the same for simplicity.runl.
if any two firings produce different outputs return l else return null.ifevidence null return definitely stateful else return potentially stateless .
noncommutativitygenerate and run tests lof increasing length until a window punctuation is generated.
let w be the length of such a list.generate list lofwpairshd pi return permutations of l.run each permutation.
if any two permutations produce different outputs return them else return null.ifevidence null return definitely non commutative else return potentially commutative .
partitioninterferencegenerate list l1of pairs hd pi with the same read d k for alld.
create l2containing elements from l1interspersed with data items with different keys.runl1andl2.
if any of the outputs for corresponding data items differ return hl1 l2i else return null.if evidence null return definitely partitioninterfering else return potentially partition isolated .
languages dataflow operators and our testing methodology.
first we often need to check output data items from the out thus we require tests for which the output is non empty before we can check for properties.
for example when checking for commutativity we first need a test that generates output data items and then we can try permutations of the input data items to see whether the output changes.
this suggests that the application of mutation may be helful in our context.
specifically we apply mutation to existing tests that do not generate output data items.
in our approach we add additional input data items by mutating a single character of string attributes adding one and minus one for numeric attributes and acting similarly for enumeration constants and timestamps.
in this way we expect to be able to trigger comparisons that generate output data items.
the second additional feature we consider involves test reuse .
when we follow the order of property testing displayed in figure we generate tests while checking properties earlier in the order.
since these tests are ready to use we may save time by reusing them thus improving testing efficiency.
note that when using this approach and when checking properties earlier in the order we cannot save every generated test thus we save only those that actually generate output data items.
the three approaches for generating test inputs that we have described can be combined with these two orthogonal factors to create different test generation techniques.
these techniques combine the three possible test input generation approaches random pool based and pair based with mutation usage with and without and reuse of tests with and without .
we believe that these techniques may have different strengths across different properties and operators and thus in our empirical studies we investigate all of them.
finally when resources permit test engineers may simultaneously apply multiple testing techniques and in sotake advantage of the relative strengths and weaknesses of individual techniques.
to investigate this approach in addition to studying the techniques individually we created a hybrid technique that applies all techniques simultaneously in parallel for a given out.
as soon as any technique finds evidence to show that a tested property definitely holds it stops and returns the answer and evidence.
if no single technique finds evidence all techniques reach the technique time limit and the property potentially does not hold.
v. e mpirical study to evaluate our approach to verifying properties there are several dimensions that we need to assess.
the first dimension involves how effective the approach is at determining whether properties hold or not.
here we are interested in the precision of the approach how often we report no evidence when indeed no evidence exists on the potentially side of a property and the recall of the approach how often it finds evidence when such evidence does in fact exist on the definitely side of a property .
the second dimension of interest involves theefficiency of the approach that is how quickly it returns results.
the third dimension of interest involves the tradeoffs between the different test generation techniques that we have proposed.
to investigate these dimensions of our approach we pose the following research questions rq1 how do the test generation techniques fare in terms of precision and recall in testing the six properties considered.
rq2 how do the test generation techniques fare in terms of efficiency in testing the six properties considered.
note that by addressing these questions we also obtain data that allows us to discuss differences that occur in assessing the six different properties we consider.109a.
objects of analysis we selected operator instances from the standard toolkit of ibm s infosphere streams and from examples found in online tutorials for that product.
we selected these operators in part because infosphere streams is a widely used commercial product most of the operators are in commercial use and the properties we selected for study are the most helpful for optimizations and correctness arguments in that programming environment.
furthermore the operator instances we selected cover all operator definitions in the standard toolkit that have at least one input and one output port including relational and utility operator definitions.
they also include primitive operators written in java and primitive operators written in c .
the lines of code per operator instance are between and and the average is .
.
when applying our approach we utilized the testing order described in section iv b figure indicates the numbers of operator instances that needed to be considered at each step.
if we did not use the testing order we would have needed to check all instances for each property checks altogether the use of the ordering reduced the number of checks to .
b. variables and measures independent variable.
our experiment manipulated one independent variable testing technique.
we applied each of the test generation techniques on all properties except nondeterminism.
for non determinism given the order in which we considered properties there were no existing tests for reuse so only seven techniques were applicable.
ideally we would like to compare our techniques to some baseline.
unfortunately there are currently no automated techniques that could serve as such baselines.
a second way to compare techniques is to use a theoretical optimal approach to judge whether properties hold.
such an approach yields correct answers allowing the precision and recall of techniques to be assessed relative to those correct answers.
this approach can be approximated by using human judgment and code inspection to determine whether properties hold however this process is also expensive a primary motivation for developing our automated methodology .
thus to determine whether properties held we began by running our techniques on all properties.
if we found evidence for a property we were certain about that case.
we then investigated remaining cases in which the techniques found no evidence one by one.
in these cases the first author inspected each of the operators relative to each remaining property and determined whether the property held.
the second author then did the same and then the two authors met and came to a consensus opinion.
in this latter step the authors found a single case in which their judgments disagreed.
in our experiments our techniques also ultimately revealed the correct answer for this case .
dependent variables.
we measured the precision recall and efficiency of each technique as follows.
let pbe a property letopspbe the set of operator instances on which pis tested lettbe a technique and let hbe the human expert baseline.dv1 precision.
precision measures the extent to which a technique does not find false evidence when indeed no evidence exists.
we calculated the precision of tas op2opsp evidence op p t evidence op p h op2opsp evidence op p h dv2 recall.
recall measures the extent to which a technique finds evidence when indeed such evidence exists.
we calculated the recall for tas op2opsp evidence op p t evidence op p h op2opsp evidence op p h dv3 efficiency.
for any application of a technique to a property we hope to obtain evidence as to whether that property holds as quickly as possible.
thus to measure the efficiency of a technique t we measured the time used by t to find evidence for each property pin the set of positive operator instances fop2opsp evidence op p h g. c. experiment setup and operation in theory we can let techniques run forever since evidence that a property holds can be found at any time.
in practice of course time limits are required.
to determine what technique runtime limits might be reasonable we conducted preliminary trials using our techniques.
we began with a technique runtime limit of one minute and increased it by multiplying it by three.
when we failed to gain more than a improvement on effectiveness for a technique runtime limit on all operators and properties we stopped and chose the previous limit.
since we reached the point of diminishing returns at nine minutes we chose three minutes as the techniquetimelimit in algorithm .
we chose two seconds as the blockingtimelimit in table i because preliminary trials showed that a one second threshold did not work well whereas two seconds allowed us to draw correct conclusions.
to check each property we began with a small number of input data items since it is easier for people to understand shorter evidence and tests.
we chose to start with two input stream elements in l since for checking statefulness we need at least two input stream elements.
finally because each technique that we considered can act differently in individual runs due to non determinism in the test generation approach we applied each technique times to each operator.
our experiments were run on a redhat linux box with an intel core2duo at .4ghz.
we used infosphere streams .
.
.
.
d. threats to validity where external validity is concerned the operators we studied were all drawn from one pool of operators associated with the infosphere streams product and different operators might yield different results.
further we studied only six properties.
however the operators we used are in wide commercial use and thus represent operators of particular interest.110table ii recall propertywithout reuse with reuse hybrid without mutation with mutation without mutation with mutation rand pool pair rand pool pair rand pool pair rand pool pair non determinism .
.
.
.
.
.
.
selectivity .
.
.
.
.
.
.
.
.
.
.
.
.
blocking .
.
.
.
.
.
.
.
.
.
.
.
.
statefulness .
.
.
.
.
.
.
.
.
.
.
.
.
non commutativity .
.
.
.
.
.
.
.
.
.
.
.
.
partition interference .
.
.
.
.
.
.
.
.
.
.
.
.
table iii efficiency propertywithout reuse with reuse hybrid without mutation with mutation without mutation with mutation rand pool pair rand pool pair rand pool pair rand pool pair non determinism .
.
.
.
.
.
.
selectivity .
.
.
.
.
.
.
.
.
.
.
.
.
blocking .
.
.
.
.
.
.
.
.
.
.
.
.
statefulness .
.
.
.
.
.
.
.
.
.
.
.
.
non commutativity .
.
.
.
.
.
.
.
.
.
.
.
.
partition interference .
.
.
.
.
.
.
.
.
.
.
.
.
our greatest concern for internal validity involves our implementations of properties and scripts used to gather data.
to reduce these threats we carefully evaluated our properties and scripts on a wide range of examples.
furthermore while our testing order obviates the need to run all techniques on all properties as an additional check on our implementations we did also apply all techniques in those cases in which they were not required and verified that they returned correct results in these cases as well.
another potential threat involves the time limits chosen for use in testing properties.
as detailed above however we based our time limit choices on preliminary trials.
where construct validity is concerned as a baseline for comparing our results we used property determinations performed by humans which could have been incorrect.
also additional measures such as the usefulness of the property determinations could be valuable.
e. results rq1 technique effectiveness precision.
as expected in our study no cases occurred in which a technique found false evidence.
therefore all techniques achieved precision.
recall.
table ii presents recall data.
the first column indicates the property name.
columns are divided into two sections the first six present data on techniques without test reuse and the next six present data on techniques with test reuse.
within each of these sections the first three columns present data on techniques without mutation and the last three present data on techniques with mutation.
within each set of three columns the columns represent random rand poolbased pool and pair based pair test generation techniques respectively.
the rightmost column shows the data on the hybrid technique.
each cell shows the average recall rate percentage over all ten runs.
bold font indicates which technique s were most effective for a given property.
from the data we can see that the most effective technique was or included the hybrid technique it was the most effective on all six properties and it achieved a recall rateranging from .
to .
.
for selectivity using pool and pairwise techniques with mutation achieved the same effectiveness as the hybrid technique .
for blocking all techniques achieved the same recall rate .
.
for all properties pair based or pool based test generation approaches were at least as effective as and on five properties more effective than random test generation.
also as noted techniques that use mutation were at least as effective as those that do not on three of six properties.
finally techniques that use test reuse were at least as effective as those that do not on three of six properties.
rq2 technique efficiency table iii presents efficiency data.
the table has the same structure as table ii but here each cell represents the average time in seconds required by each technique to find evidence.
to be consistent with table ii we report data only for operators on which there exists evidence.
as the data shows average times for each technique were all relatively small ranging from .
to .
seconds.
the hybrid technique was the most efficient for all properties.
finally random test generation required at least the same amount of time as the other two test generation approaches given the same mutation and reuse approaches.
vi.
d iscussion and implications we now provide additional insights into the results of our study and comment on implications.
failed cases our techniques failed to determine correct answers for properties on only seven operators in other cases at least one technique in one run returned a correct answer.
when checking for non determinism there were two cases in which none of our techniques found evidence that the property held.
one is a deduplicate operator using seconds as its timeout.
if we control the number of stream elements arriving at the operator in seconds we can find evidence to show that it is non deterministic.
to do this we could use an inter element delay period of seconds.
in our implementation however we limited inter element delay111periods to five seconds and we limited the number of delay periods on an input stream to three so that we could try more tests in a given time.
in general any operator having a window or timeout based on a large physical time interval will present such challenges.
to address this problem we could ask users to provide delay period times.
the second case in which checking for non determinism failed involved a join operator that generates output only when a concatenation of three strings equals a fourth string.
in general this is a difficult constraint to satisfy.
asking users for sample input data could help in this case.
when checking for blocking our techniques missed one case a gate operator with buffer size .
as implemented none of our techniques generates test inputs with stream elements in three minutes.
to find evidence for this operator the techniques need to run longer or begin with a larger number of input stream elements.
when checking for statefulness our techniques missed three cases two aggregate instances and a sort instance.
these instances are configured with a delta window in which the difference for an attribute between the first and the last stream element in the window is specified.
our techniques are not likely to find stream elements satisfying such a condition.
asking users for sample input data could help.
when checking for partition interference our techniques missed one case a c primitive operator.
except on very specific inputs this operator is typically blocking in which case its outputs cannot be checked for partition interference.
generating appropriate inputs in this case is difficult.
again asking users for sample data could help.
test generation approaches table ii shows that random test generation was less effective than the other test generation techniques.
because random generation performs an unguided search its search space is too large to let it select useful values.
comparing the pair based and pool based techniques there were only six cases in which pair based was more effective and only four in which pool based was more effective.
as mentioned in section iv pair based generation benefits when multiple conditions need to be satisfied to obtain an output.
on inspection we found that only two of the operators we tested contained this type of code.
mutation strategy for selectivity and statefulness techniques that used mutation performed better than those that did not.
however when checking for non determinism mutation missed operators with time based windows greater than two seconds.
on such operators with mutation the time required is too large to allow techniques to generate sufficiently long input streams.
therefore in these cases none of the techniques generates an output and they report that the operator is potentially deterministic.
for non commutativity and partitioninterference mutation did not seem to be helpful.
mutation is used to generate a test that is able to produce some output.
if existing tests already generate outputs mutation will waste time and then fail to find evidence in a technique time limit.
test reuse for selectivity and statefulness techniques with reuse were more effective and efficient than those without because they can use existing tests directly.
in particular when checking for statefulness the testing strategy described in section iv uses the same input stream elements.
this strategy can miss cases in which we require different input stream elements to reveal the property while test reuse can help with this.
for non commutativity and partition interference however techniques with reuse displayed no advantage over those without.
these properties have more strict requirements for tests so existing tests may not satisfy them.
for blocking we deleted the input stream elements for the input port that was not under test thus test reuse did not provide efficiency advantages in this case.
technique comparisons given our data and the foregoing discussion it is clear that among the non hybrid techniques there is no consistent winner.
mutation and reuse were not always helpful.
thus it is difficult to recommend any single technique as appropriate in all cases.
this emphasizes the importance of the hybrid technique.
the hybrid technique is able to produce more varied test cases which help it succeed on operators on which single techniques could not.
essentially the approach achieves greater search diversity in a manner similar to that discussed in .
of course in some sense the hybrid technique achieves its effectiveness because it allots additional time to testing than the other techniques through its use of additional resources e.g.
multiple processors .
nonetheless if a user wishes to obtain a more accurate answer more quickly and has access to such resources the hybrid technique is the best choice.
vii.
c onclusions and future work dataflow programming is a widely used paradigm and with the rise of big data it has gained significant commercial importance.
in this work we have presented an approach for testing dataflow program operators and provided empirical data that shows that this approach can be effective and efficient at providing evidence that properties of operators do or do not hold.
by assisting with the verification of operator properties our approach can help software engineers create more dependable operators and dataflow programs.
we have focused on testing individual spl operator instances.
in follow up work we adapted our approach to mapreduce and applied it to characterize semantic properties of mapreduce workloads .
as future work we intend to consider the next stages of dataflow program validation in which testing approaches analogous to integration and system testing are needed.
we also plan to expand on the scope of our empirical study and to examine the potential usefulness of the methodology in the hands of engineers.