grail context aware fixing of concurrency bugs peng liu1 lpxz ust.hkomer tripp2 otripp us.ibm.comcharles zhang3 charlesz cse.ust.hk 1state key laboratory of software engineering2ibm research3hkust wuhan university china united states china abstract writing e cient synchronization for multithreaded programs is notoriously hard.
the resulting code often contains subtle concurrency bugs.
even worse many bug xes introduce new bugs.
a classic example seen widely in practice is deadlocks resulting from xing of an atomicity violation.
these complexities have motivated the development of automated xing techniques.
current techniques generate xes that are typically conservative giving up on available parallelism.
moreover some of the techniques cannot guarantee the correctness of a x and may introduce deadlocks similarly to manual x whereas techniques that ensure correctness do so at the expense of even greater performance loss.
we present grail a novel xing algorithm that departs from previous techniques by simultaneously providing both correctness and optimality guarantees.
grail synthesizes bugfree yet optimal lock based synchronization.
to achieve this grail builds an analysis model of the buggy code that is both contextual distinguishing di erent aliasing contexts to ensure e ciency and global accounting for the entire synchronization behavior of the involved threads to ensure correctness.
evaluation of grail on bugs from popular codebases con rms its practical advantages especially compared with existing techniques grail patches are in general more e cient than the patches produced by other techniques and incur only overhead.
categories and subject descriptors d. .
concurrent programming general terms algorithms reliability performance keywords context aware xing concurrency bugs this research is supported by rgc grf grant rgc621912.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.
.
introduction concurrency bugs are elusive.
not only are they hard to reproduce and understand but also xing a bug often introduces new bugs.
a typical example is that xing an atomicity violation requires insertion of additional synchronization which leads to new deadlocks.
a recent study of bug xes in large software systems such as linux and freebsd reports that of the manual xes committed by programmers are incorrect and .
of the incorrect xes introduce deadlocks.
these statistics clearly con rm the hardness of manually xing concurrency bugs marking the need for automation.
several di erent approaches have been proposed recently to automatically x concurrency bugs .
these address concurrency problems resulting from inadequate synchronization including atomicity violations deadlocks and data races .
roughly speaking in all of these cases the x amounts to inserting additional synchronization to inhibit bad interleaving scenarios.
the goal naturally is to insert tight synchronization which prevents all bad executions correctness while permitting most of the good executions performance .
existing approaches.
to illustrate the behavior and limitations of existing techniques we refer to a real world concurrency bug reported on the niotcpserver class in the apache mina framework.1the buggy code is shown in figure 1a.
concurrent execution of methods bind and unbindall can result in a concurrentmodificationexception ifbind adds an element to the addresses collection while unbindall iterates over the contents of addresses .
the bug is likely due to the wrong assumption that a synchronizedset instance guarantees atomic iteration over its elements.
the bug report is available as bug in jira issue tracker.
existing xing techniques are context oblivious .
they focus solely on the statements involved in the bug without accounting for the context i.e.
the aliasing con guration of shared variables and locks that leads to the manifestation of the bug.
we illustrate the consequences of context oblivious xing by reference to the two most recent and advanced xing techniques.
the rst afix disallows concurrent execution of the statements involved in the bug in all contexts including contexts that do not expose the bug.
the afix patch shown in figure 1b essentially encloses accesses to addresses inside an atomic region guarded by the fixl lock which serializes evaluation of the statements even if the threads read di erent addresses collections and there is no threat of atomicity in method bind localaddr synchronized this a ... b addresses .add localaddr in method unbindall c for addr addresses synchronized this d strategy.unbind addr addresses collections.synchronizedset new hashset a original mina code with latent atomicity violation bind localaddr synchronized this a ... synchronized fixl b addresses .add localaddr unbindall synchronized fixl c for addr addresses synchronized this d strategy.unbind addr static object fixl new object b mina code following the afix x bind localaddr synchronized deadlockl synchronized this a ... synchronized fixl b addresses .add localaddr unbindall synchronized deadlockl synchronized fixl c for addr addresses synchronized this d strategy.unbind addr static object fixl new object static object deadlockl new object c mina code following the axis x bind localaddr synchronized contextl addresses this synchronized this a ... synchronized addresses b addresses .add localaddr unbindall synchronized contextl addresses this synchronized addresses c for addr addresses synchronized this d strategy.unbind addr contextl addresses this return hash addresses hash this .intern d mina code following the grail x figure motivating example buggy code from the apache mina tcpnioserver class a and xed versions of the code b d violation.
moreover afix cannot guarantee a deadlock free x and indeed in this case a deadlock is introduced between the x and the existing synchronization over this.
the second approach axis is even more conservative.
it ensures deadlock freedom2by turning the bug xing into an iterative process in each round of this process deadlocks introduced during the previous round are eliminated.
the resulting code is given in figure 1c.
the temporary deadlock due to the insertion of fixl is eliminated thanks to a second lock deadlockl which essentially serializes the executions ofbind and unbindall completely sacri cing any available parallelism.
our approach.
the insight underlying our approach is that quality xes for concurrency bugs must account not only for the buggy statements themselves but also for the execution context so that mutual exclusion is enforced only when absolutely necessary.
it is nontrivial to realize such context aware bug xing.
for example if we merely introduce the lock on addresses to x the atomicity violation then a deadlock may occur between the x and the existing this lock.
these challenges call for a principled algorithmic framework to realize context aware bug xing.
we have designed such a framework based on the theory of petri net which creates an analysis model that is simultaneously contextual distinguishing between di erent runtime con gurations to pinpoint the exact conditions under which the bug manifests for optimal performance and global accounting for the complete synchronization behavior of threads for correctness to guarantee that no new deadlocks are introduced.
compared to both afix and axis grail is strictly better.
any bug that afix or axis are able to remedy is also handled bygrail.
in addition grail guarantees deadlock freedom which afix cannot guarantee as we have shown above.
the di erence from axis which also guarantees deadlock freedom is that grail guarantees at least the same concurrency level if not higher.
indeed grail guarantees an optimal x under the assumptions that i the bug involves two threads and 2throughout this paper deadlock freedom does not mean the whole program deadlock freedom instead it means that the xes do not introduce new deadlocks.
ii the x is in the form of mutual exclusion.
both afix and axis are governed by these assumptions and none of these techniques ensures optimality neither in theory nor in practice.
as an illustration we refer the reader to figure 1d which presents the x produced by our approach.
we defer technical detail to section and instead focus on the intuition for now.
a thread th1executing method bind would acquire a lock on addresses after it has already acquired a lock on this.
the opposite is true of a thread th2transitioning into the program point with label dinunbindall .
a deadlock would thus arise if and only if this th1 this th2 addresses th1 addresses th2 note that the symbol denotes equality in terms of memory addresses and not values.
therefore the minimal synchronization i.e.
the most permissive synchronization that can be synthesized to simultaneously i x the original bug and ii ensure deadlock freedom is to i govern transition into the code blocks accessing addresses with an instance lock on addresses which coordinates threads only when they access the same addresses instance and ii apply mutual exclusion to avoid the deadlock i two concurrent threads have both this and addresses aliased.
grail enforces this solution by creating synchronization objects of type string that capture the needed conditions as the implementation of contextl in figure 1d demonstrates.
this factory method computes a hash value for both addresses and this and concatentates these values.
while hash values are not guaranteed to be unique we rely on system.identityhashcode abbreviated as hash which su ces in practice.
note importantly the use of the intern method on the resulting string object ensures that if two synchronization objects have the same value then they also point to the same memory.
otherwise strings representing the same context do not necessarily enforce mutual exclusion.
this solution cannot be gleaned by inspection of the buggy statements alone.
it requires contextual reasoning which accounts for the conditions under which the above bug manifests as well as global reasoning which accounts for the locks acquired by threads and the constraints they cast onconcurrency in every possible concurrent execution of bind and unbindall .
our approach is born out of this insight and implements this type of analysis model to simultaneously achieve both correctness and e ciency.
a comparative study of our approach with two state of the art approaches afix and axis on bugs from popular java applications including e.g.
tomcat andderby indicates that this mode of reasoning is essential leading in most cases to a performance improvement of over compared to the competing approaches.
this paper makes the following principal contributions .context aware bug xing we introduce a novel approach for xing concurrency bugs which factors into the x precise modeling of contextual information yielding a x that is both optimal and provably correct.
.formalization and proofs we provide full formalization of our approach including proofs highlighting interesting aspects of our modeling.
.implementation and evaluation we have implemented a prototype system grail that realizes our approach and conducted experiments on con rmed bugs in popular real world applications to evaluate the quality of the xes.
the patches generated by grail are almost all signi cantly more e cient than competing approaches while also being provably correct.
.
technical overview in this section we de ne the scope of our approach walk the reader through a high level description of the grail workow and conclude by highlighting points of interest and limitations of our approach.
when describing the work ow we start with a simpli ed version and later explain how we deal with challenges that we initially glossed over.
.
scope similarly to past studies our work addresses concurrency bugs involving two threads.
according to a recent study the vast majority of real world concurrency bugs fall into this class.
we concentrate on any combination of the following three bug categories i data races ii atomicity violations and iii deadlocks .
these are described in more detail as well as illustrated in an accompanying technical report tr .
see figure there.
we assume that patches are in the form of additional mutual exclusion based synchronization.
we preclude other transformations such as code reordering from consideration.
in this setting correctness translates into avoiding from introducing new deadlocks between pairs of threads and optimality translates into introducing the least amount of synchronization needed to eliminate the reported bug.
.
simplified flow we assume as input a multithreaded program along with bug reports given in terms of the involved code statements.
see section .
for the given bugs the rst step of our technique is to model the lexical scopes enclosing the buggy statements as a concurrent controlow graph .
we soon explain how the graph is built but rst we start from the scopes it represents.
these are essentially the methods containing the buggy statements along with their transitive caller and methods.
this selected fragment of the entire program su ces for correct xing of the bug since all relevant lock acquisitions and releases are contained within this subprogram.
by reasoning about them we avoid from introducing new deadlocks between pairs of threads theorem .
.
according to our experience the resulting program fragment is relatively small and constrained.
the ow graph we mentioned earlier is more accurately a petri net .
stated simply a petri net is a graph containing two types of nodes places which denote statements and transitions which denote control ow between statements.
a petri net is thus similar to a control ow graph except that controlow edges are represented as transition nodes.
in addition the petri net has a mathematical representation that permits formal modeling and reasoning about x synthesis.
to simulate thread execution the petri net maintains a controlow token for each of the threads.
the token is associated with a place and denotes the current statement a thread is executing.
the state of a petri net is tantamount to the token con guration capturing a snapshot during concurrent execution of the respective threads.
reasoning about multithreaded execution under the petri net model amounts to combining the controlow graphs of nitely many threads into a uni ed graph which is essentially the product of the controlow graphs.
for our needs it su ces to combine the graphs of two threads such that every concurrent execution as modeled by the petri net state corresponds to the product of two statements that are being executed by the threads.
in the resulting graph we distinguish between three kinds of concurrent executions infeasible execution refers to the concurrent execution of a pair of statements that cannot arise at runtime due to existing synchronization code.
as an example the control locations with labels aand din figure 1a cannot be visited simultaneously by two parallel threads when their this