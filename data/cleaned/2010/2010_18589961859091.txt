matching dependence related queries in the system dependence graph xiaoyin wang1 d a v i dl o2 jiefeng cheng3 lu zhang1 hong mei1 jeffrey xu yu3 1key laboratory of high confidence software technologies peking university ministry of education beijing china 2school of information systems singapore management university 3the chinese university of hong kong china wangxy06 zhanglu meih sei.pku.edu.cn davidlo smu.edu.sg jfcheng yu se.cuhk.edu.hk abstract in software maintenance and evolution it is common that developers want to apply a change to a number of similar places.
due to thesize and complexity of the code base it is challenging for develop ers to locate all the places that need the change.
a main challenge in locating the places that need the change is that these places share certain common dependence conditions but existing code searching techniques can hardly handle dependence relations satisfactorily.in this paper we propose a technique that enables developers tomake queries involving dependence conditions and textual conditions on the system dependence graph of the program.
we carried out an empirical evaluation on four searching tasks taken from thedevelopment history of two real world projects.
the results of ourevaluation indicate that compared with code clone detection ourtechnique is able to locate many required code elements that codeclone detection cannot locate and compared with text search our technique is able to effectively reduce false positives without losing any required code elements.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms reliability standardization keywords system dependence graph code search graph indexing .
introduction in software development developers often need to apply one change to a number of similar places in the code.
such a situation occurs typically when developers want to make a programmingstyle change or want to change the environment e.g.
the databasesystem and the user interface of a software system.
for example when a developer wants to extract a common code pattern to form a new method he or she should try to locate all the instances of thecode pattern and change them to invocations of the new method.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted w ithout fee provided that copies are not made or distributed for profit or c ommercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redist ribute to lists requires prior specific permission and or a fee.ase september antwerp belgium.
copyright acm ... .
.it is usually easy for a developer to locate one or a few places for change but it is challenging for he or she to locate all the places that require the same change.
since the code base of a modern softwareapplication is large and usually many developers have been cod ing for the application it may be infeasible for the developer to remember all the similar places without missing any one.
thus a tool that helps developers locate all the similar places requiring the same change may save much development time.
one possible way to achieve the preceding purpose is to use techniques for code clone detection.
techniques for code clone detection are able to detect all the places in the code that are similarto the known places that need change.
however techniques for code clone detection rely on a pre defined uniform similarity metric to measure the similarity between two places.
but the similarity in the preceding problem is actually some common characteristics that similar code elements should have and a different change mayimply different common characteristics.
for instance as shown in example in section the two code elements are similar for only the change at hand but should not be similar in any techniquefor code clone detection.
another possible way to achieve the pre ceding purpose is to use text search.
in a typical text search tool a developer can represent the common characteristics as a regularexpression and search in the code for matched code elements.
however text search tools cannot always represent common characteristics as regular expressions.
for instance as shown in example2 in section the common characteristics of the need to changecode elements are based on control and data dependence relation ships and cannot be represented as a regular expression.
in this paper we propose a novel technique to locating code elements with common dependence related properties in source code.
the basic idea of our technique is as follows.
our technique allowsa developer to write a query using a language named the depen dence query language dql presented in section .
.
dqlallows a developer to describe dependence properties on top of tex tual properties.
then our technique transforms the query into a series of graph reachability patterns and matches them in the system dependence graph sdg of the source code using a fast algorithmfor graph pattern matching .
we empirically evaluated our tech nique using four searching tasks in two real world projects.
ourempirical results indicate that our technique is more effective than both code clone detection and text search for these searching tasks.
as a general approach that locates code elements with common dependence related properties our technique can be applied to a number of software maintenance tasks.
for example provided witha list of error patterns our technique can be incorporated in a bugfinding tool to locate the error patterns.
another scenario is that when developers want to perform refactorings they can use our dql perhaps with some extensions to define the code places to be changed in the refactorings.
our technique can also be adapted to solve to some specific problems such as locating the strings flowing to the gui in software internationalization or locating the variables whose values come from or are compared with sensitivedata in security analysis.
this paper makes the following main contributions a demonstration of challenges in locating all the code elements requiring the same change.
a query language i.e.
dql that allows developers to describe dependence related properties involving multiple program points.
a technique that locates code elements with certain dependencerelated properties via graph matching.
an empirical evaluation demonstrating the effectiveness andthe cost of our technique.
.
examples in this section we present two examples to demonstrate the challenges in locating all the need to change code elements when developers want to apply a change to similar code elements.
the first example comes from code changes made to the expat1 project cvs version .
in the code changes the devel opers want to fix some memory leaks that may happen when a callof the malloc function fails.
one of the changes is as below.
example original code tag malloc sizeof tag if !tag return xml error no memory tag buf malloc init tag buf size if !tag buf return xml error no memory changed code tag malloc sizeof tag if !tag return xml error no memory tag buf malloc init tag buf size if !tag buf free tag return xml error no memory from the preceding two code portions we can see that the developers want to find cases where a field i.e.
tag buf in the code of a struct variable i.e.
tag in the code is initialized after the struct variable is initialized.
the aim is to add a free function when the initialization of the field is failed to avoid memory leak.
the key characteristic is two calls of the malloc function one call is to acquire memory for the entire struct variable and theother call is to acquire memory for a field of the struct variable.as the name of the struct variable and the name of the field may vary in other places it is difficult to find these places with codeclone detection.
furthermore in text search as it is impossible toexpress the constraint between the struct variable and the field wecannot use this constraint to confine the searching results.
the following gives another location exhibiting the memory leak patternmentioned above newe element type lookup newdtd elementtypes name sizeof element type if !newe return if olde ndefaultatts newe defaultatts default attribute malloc olde ndefaultatts sizeof default attribute if !newe defaultatts return 1expat is a popular xml document handling library.in the preceding code portion the name of the struct variable is newe and the name of the filed is newe defaultatts .f u r t h e r more this code portion only depicts one call of malloc a n dt h e other call of malloc is inside the implementation of the lookup function.
to make the situation even worse there is an extra ifstructure i.e.
if olde ndefaultatts in this code portion.
this example demonstrates that neither code clone detection nor text search allows developers to express some important constraints when searching for need to change code elements.
the second example is from code changes in the gpsbabel2project cvs version .
in these changes the developers try tofind copying operations between two arrays of type ucin the form of loops.
the aim is to replace each such copying operation with a call of a specially defined function i.e.
arraycopy .
the following two code portions depict the code before and after such a change.
the code in the italicized parts highlights the change.
example original code uc p str ... for i i i str p changed code uc p str ... arraycopy str p the key characteristics is a series of assignments between elements in two arrays and each element is of type uc.
in this example the main challenge is to express both the following constraints the constraint between the loop structure and the content inside the loop structure and the constraint on the type of the elements in the two arrays.
neither code clone detection nor text search allows developers to express both constraints in one search.
from the preceding two examples we have the following observations.
first when locating similar code elements for change developers often need to express searching conditions as dependencerelated properties.
code clone detection may be ineffective sincecode elements satisfying such a searching condition may not looksimilar.
text search may be ineffective since such a search con dition contains dependence properties besides textual properties.second dependence properties described in such a search condition may include both control dependencies and data dependencies.
based on the preceding observations we propose a new technique to locating code elements with common dependence related properties in source code.
our technique allows developers to ex press combinations of textual conditions data dependence condi tions and control dependence conditions in individual queries.
to deal with the dependence conditions our technique transforms the queries to graph reachability patterns and matches the patterns inthe system dependence graph sdg of the source code.
.
background .
system dependence graph the system dependence graph sdg is a graph that describes the dependence relationships between program points in the source code .
in an sdg generated by codesurfer3 each node corresponds to a program point in the code.
there are types of program points in total in an sdg generated by codesurfer.
the 2gpsbabel is a processing system of gps information 3codesurfer is a static program analyzer and it can extract a system dependence graph from source code.
codesurfer can be obtained from 458figure an example system dependence graph figure a example graph and b query edges in an sdg correspond to the dependence relationships between program points.
there are two kinds of dependence relationships data dependence relationships and control dependencerelationships.
table depicts the most commonly used types of program points in sdgs.
in our current technique we only consider searching for the structures consisting of program points of these most commonly used types.
however it is possible to ex tend our technique to search for other program points by extendingour dependence query language see section .
and the querytransformation rules see section .
.
note that program points of other types may be intermediate nodes in various dependence relations between the common program points in the sdg.
given a c program codesurfer can extract an sdg automatically during the compilation of the program.
for example for the following program codesurfer provides an sdg in figure .
inthe figure each node is labeled with its program point type and we also provide the textual representation of each node.
hollow arrows refer to data dependencies and solid arrows refer to control de pendencies.
solid lines refer to intra procedure dependencies anddotted lines refer to inter procedure dependencies.
static int add int a int b return a b sum through .
void main int sum i sum i while i sum add sum i i add i table commonly used types of program points program point type description expression value assignment or value return control point any kind of branch condition e.g.
if for while ... call site function invocation actual in actual argument in a function invocation actual out returned value of a function invocation declaration declaration of a variable entry entry of a function .
graph reachablity indexing and querying as stated in section our technique transforms a dependence related query to a graph reachability pattern.
the problem of matching such a pattern in a large graph is computationally expensive.first the reachability calculation between all pairs of nodes in a graph has a complexity cubic to the size of the graph.
second a naive algorithm for matching a graph pattern in a graph has a complexity of n x w h e r e nis the size of the graph and xis the size of the graph pattern.
fast graph reachability indexing and querying is a new achievement in the area of graph databases which makes graph reachability pattern matching on large graphs computationally acceptable.
a graph reachablity indexing algorithm takes a labeled di rected graph as input.
in a labeled graph each node has one andonly one label from a known label set.
the algorithm indexes all the reachability relati onships between node labels.
with the indices one can query and obtain all the instances of a reachability pattern represented as a query graph .
for example for the graph in figure a containing the label set a b c d e f a queryin figure b can be made.
to distinguish nodes labeled with thesame label in figure a we add numbers to the end of the label.for example a1 a2 and a3 are three nodes labeled with a. thequery in figure b denotes sub graphs having the following conditions first in such a sub graph there is at least one node labeled with a one node labeled with b and one node labeled with f. sec ond in such a sub graph it is reachable from the node labeled witha to either the node labeled with b or the node labeled with f. notethat edges between nodes in the que ry graph repre sent reachability relations instead of immediate connections.
the three matched instances a1 b2 f1 a2 b2 f1 a3 b1 f2 are marked with triangles squares and stars respectively.
.
approach to help developers perform dependence related queries we design a language named the dependence query language dql for developers to describe the common characteristics of target code elements.
section .
presents the details of dql.
with a query written in dql our technique searches for code elements that satisfy the common characteristics described in the query using thefollowing four steps.
first we extract the system dependencegraph sdg from the source code using codesurfer.
second wetransform dependence conditions in the query to a series of graph reachability patterns.
third we search in the sdg to locate subgraphs matching the graph reachability patterns.
finally we usethe textual constraints in the query to filter the located sub graphsand trace back to code elements in the source code.
sections .2to .
presents the details of the preceding four steps respectively.
.
dependence query language a query in our dependence query language has four parts formally presented as below.
query querydeclaration nodedescriptions relationdescriptions wanted 459thequerydeclaration part is formally defined below.
querydeclaration querydeclaration nodedeclaration nodedeclaration nodedeclaration types identifier identifier types types type type type function variable assignment declaration control point this part allows a developer to declare a list of program points involved in the search.
besides an identifier the developer must give each program point a list of t ypes.
if one program point has more than one type the meaning is to declare a program point whose actual type can be any one of the listed types.
dql supports five types of program points function variable assignment declaration a n d control point .
these five types are abstraction of the types of program points in sdg.
we describe the mapping between types in dql and types in sdg in section .
.
the function type corresponds to any invocations of functions.
the variable type corresponds to single variables.
the assignment type corresponds to assignments or returns of invocations passing the return values4.
thedeclaration type corresponds to declarations of variables.
the control point type corresponds to all branch conditions.
thenodedescriptions part is formally defined as below.
nodedescriptions nodedescriptions nodedescription nodedescription nodedescription identifier conditions conditions conditions orcondition condition condition notunitcondition unitcondition unitcondition contains string unitcondition infile string unitcondition infunction string unitcondition atline number unitcondition declaretype string unitcondition declaretype native unitcondition controltype ctype ctype for while switch if in the preceding definition number corresponds to a positive number.
string corresponds to a character sequence inside quotation marks native corresponds to the set of built in types of the c language including char float etc.
this part allows a developer to describe the properties related to a single program point.
for each progr am point a developer can add three kinds of properties as conditions.
first a developer can use contains to demand the textual representation of a program point to have a particular substring.
second a developer can describe thelocation of a program point by providing its exact line number or by providing the substrings contained in the textual representation of its enclosing files or functions.
third for certain types of pro gram points a developer can also describe the declared type or thecontrol type of a given program point.
a developer can also addnotororto the conditions for a program point.
note that our dql does not support the disjunction of c onditions of the r elationships between different program points.
in such a case a developer needs to generate more than one queries.
therelationdescriptions part is formally defined as below.
relationdescriptions relationdescriptions relationdescription relationdescription relationdescription identifier op identifier op dependop textualop structuralop dependop onestep subdependop subdependop datadepends controls calls textualop textual contains structuralop isfieldof structuralop iselementof this part allows a developer to describe three kinds of dependence relationships between program points datadepends controls andcalls .
specifically a datadepends b means that a is 4we merge these two kinds of elements for simplicity a developer can demand an assignment to be a return statement using a textual condition.data dependent on b a controls b means that b is control dependent on a and a calls b means that there is a chain of function invocations from a to b. a developer can also use modifier onestep before a relationship to demand that the dependence must happen in one step in the sdg.
our dql also allows a developer to add textual conditions between the textual representations of two program points.
specifically a textual contains b means that the textual representation of b is a substring of the textual representation of a. sometimes program points may have structural relationships such as the relationship between a struct variable and its fields or the relationship between an array variable and its elements.
so dqlalso supports structural c onditions.
in particular a isfieldof b means that a is a field of struct variable b and a iselementof b means that a is an element of array variable b. for example a.b isfieldof a holds a iselementof a holds.
thewanted part is formally defined as below.
this part allows a developer to indicate which program points in the query are the actual target.
wanted want identifiers identifiers identifiers identifier identifier note that the syntax of dql allows developers to write meaningless queries e.g.
defining a function a with control type if o r defining function a calls variable b .
the meaningless queries are checked and deemed as errors when we transform the queries to graph patterns see section .
.
.
we next give a dql query for example in section .
in the example since the only place requiring change is the initialization of the field of the struct variable the developer can set only the program points corres ponding to the initialization of the field as the targets.
in particular a query for this example is as below function a function b variable c variable d a contains malloc or contains realloc b contains malloc or contains relloc c datadepends a d datadepends b c onestep datadependsd c isfieldof d want c in the query acorresponds to the initia lization of the struct variable bcorresponds to the initia lization of the field ccorresponds to the field and dcorresponds to the struct variable.
we usedatadepends to describe the relationship from the initialization of the variable to the variable itself.
we further use onestep datadepends andisfieldof to describe the relationship between a struct variable and its fields.
.
sdg extraction in our technique we obtain the system dependence graph sdg as follows.
first we use codesurfer to generate an initial sdg from the code.
second we check each node to see whether thenode is a program point of one of the types listed in table .
foreach such node we extract its type e.g.
actual in call site e t c .
textual presentation and location in the code and label the node with its type.
for other nodes we also label each node with its type but do not extract further information.
we keep these nodes in the sdg to transit dependence relationships between nodes of themost commonly used types.
third we extract all the edges betweennodes and label them as control dependence or data dependence.here we do not differentiate inter procedure dependence and intraprocedure dependence since a developer usually does not know whether the target he or she is searching for is in a function orscattered in different functions.
fourth we give each node in thesdg a unique number as its identifier.
.
query transformation to use graph reachability querying to search in the sdg we need to transform a query described in dql into one or more queries for 460graph reachability querying.
first as graph reachability querying accepts only query graphs we need to transform queries in dql into query graphs.
second as a query graph in graph querying allows only the conjunction of label conditions and reachability con ditions we need to split a query with disjunctions of conditions in dql into several query graphs.
third for conditions such as structural relationships textual relationships program point properties described in the nodedescriptions part and the onestep conditions supported by dql but not supported by graph reachability querying we do not transform them into query graphs but usethem to filter the results of graph reachability querying.
we presentthe details of filtering in section .
.
.
.
splitting queries in a query written in dql there are two places that may contain disjunctions of conditions and the conditions in both places are conditions for single program points.
the first place is the querydeclaration part where a program point may have multiple possible types.
the second place is the nodedescriptions part where the properties of a program point may be the disjunction of several conditions.
to deal with the disjunctions of conditions we split thequery into the disjunction of a series of sub queries each of whichcontains only conjunctions of conditions.
this process is similar tothe process of normalizing a logic expression into the disjunctive normal form.
when querying the sdg we use each conjunctive sub query to obtain a set of results and use the union of all the re sult sets as the results of the original query.
for example for the query described as function control point a variable b a contains abc or contains de a datadepends b want a we can split the query into the following four subqueries function a variable b a contains abc a datadepends b want a control point a variable b a contains abc a datadepends b want a function a variable b a contains de a datadepends b want a and control point a variable b a contains de a datadepends b want a .
none of the sub queries includes any disjunctions of conditions.
.
.
transforming conjunctive queries for a query containing only conjunctions of conditions we transform the query into a query graph in the following way.
first we transform each program point in the querydeclaration part into a node in the query graph.
second we do not consider the conditions for filtering e.g.
properties described in the nodedescriptions part in query transformation.
third we transform the type of eachprogram point into the label of the corresponding node and the relationships between program points into edges between nodes.
note that there is no straightforward one to one mapping between the types of program points in dql and the types in the sdg andthere is no straightforward one to one mapping between the rela tionships in dql and the reachability relationships in the sdg.
inthe following we present the details of transforming program point types and relationships between program points.
figure depicts the rules for the preceding transformation.
each rule corresponds to the transformation of two program points including their types and their relationship described in dql intothe corresponding sub graph including node labels in the querygraph.
in the figure hollow arrows denote data dependence and solid arrows denote control dependence.
note that some rules result in adding extra nodes into the query graph.
for brevity in figure we merge rules when the relationship in dql is the same and the structure of the transformed sub graph is similar.
as a result we have four generic rules in figure and ineach rule a program point in dql may have more than one type and a node in the transformed sub graph may have more than onefigure rules for dependence relation descriptions label.
in such a case we use to separate the program point types and the node labels.
details of the four generic rules are as below.
acalls b. according to the sdg generated by codesurfer such a situation requires that bshould be control dependent on the entry of aand the entry of ashould be control dependent on the call site of a. so we add two control dependence edges and an intermediate entry node from atob figure a .
both aandbshould be functions.
the newly added node should have an identifier not used by other nodes and we use aito indicate that it is the ithadded node.
acontrols b. we transform this relationship to a control dependence edge from atob figure b .
ashould be a control point and bcan be an assignment a function call or another control point.
furthermore if bis a function call we need to transform the function type into the call site label.
as neither declarations nor