inferring project specific bug pattern s for detecting sibling bugs guangtai li ang1 qianxiang wang1 tao xie2 hong mei1 1institute of software school of electronics engineering and computer science key laboratory of high confidence software technologie s peking university ministry of education peking university beijing china lianggt08 wqx meih sei.pku.edu.cn 2department of computer science university of illinois at urbana champaign urbana il usa taoxie illinois.edu abstra ct lightweight s tatic bug detection tool s such as findbugs pmd jlint and lint4j detect bugs with the knowledge of generic bug pattern s e.g.
objects of java.io.inputstream are not closed in time after used .
beside s generic bug patterns different projects under analysis may have some project specific bug patterns .
for example in a revision of the xerces project the class field fdtdhandl er is dereferenced without proper null check s while it could actually be null at runtime .
we name such bug patter ns directly related to objects instantiated in specific projects as project specific bug patterns psbp s .
due to lack of such psbp knowledge existing tools usually fail in effectively detecting most of this kind of bugs.
we name bugs belong ing to the same project and sharing the same psbp as sibling bug s. if some sibling bugs are fixed in a fix revision but some others remain we treat such fix as an incomplete fix .
to address such incomplete fixes we propose a psbp based approach for detecting sibling bugs and implement a tool called sibling bug detector sbd .
given a fix revision sbd first infer s the psbps implie d by the fix revision .
then based on the inferred psbps sbd detects their related sibling bugs in the same project .
to evaluat e sbd we apply it to seven popular open source project s. among the warnings reported by sbd of them have been confirmed as real bugs by the project developers while two existing popular static detectors findbugs and pmd cannot report most of them.
categori es and subject descriptors d. .
software program verification f. .
specifying and ve rifying and reasoning about pro grams general terms languages reliability verification .
keywords project specific bug patterns sibling bug detection incomplete fixes.
.
introduction lightweight static bug detection tool s such as findbugs pmd jlint and lint4j detect b ugs with the knowledge of generic bug patterns.
for example for java projects under analysis there is a generic bug pattern objects of java.io.inputstream are not closed in time after used .
as shown in this exa mple most generic bug patterns are related to classes provided by common third party libraries e.g.
jdk for ja va projects and are usually applicable for all projects based on the same third party libraries.
beside s generic bug patterns different projects under analysis may have various project specific bug patterns.
when writing object oriented code for a proj ect developers would define many project specific objects in their newly written interfaces classes or methods.
those user defined objects may also need to be used under some certain constraints.
for example in a revision of the xerces project the object fdtdhandl er an object of the c lass xmldtdhandler defined within xerces is dereferenced without proper null check s while it could actually be null at runtime .
as another example in a revision of the tomcat project the local object cometeven t an object of the class cometeventimpl define d within tomcat is not closed after used in a certain method .
we name such patterns directly related to objects instantiated in specific projects as project specific bug patterns psbps .
note that focused ob jects in psbps could also be objects of classes defined in some third party library .
existing tools usually fail in detecting most of those bugs sharing psbps due to the lack of related psbp knowledge.
bugs sharing the same psbp are typically related involved with the same object of the same class.
we name such bugs sharing the same psbp as sibling bugs in this paper .
if some sibling bugs are fixed in a fix revision but some other s remain such fix can be considered as an incomplete fix.
recent studies h ave revealed that incomplete bug fixes are common in bug fixing process es.
for example kim et al.
identified that among attempted fixes four three null pointer exception npe fixes are incomplete in the ant lucene project .
figure shows an incomplete fix example from the xerces project .
the lines added by commits are in bold underlined and labeled with the symbols.
in this example the first fix revision revision fixes a n npe bug on the class field object fdtdhandler in the method setinputsource of the class xmldtdscannerimpl .
however a sibling npe bug on the same object remains in the method startentity of the same class.
four months later the remaining bug is finally fixed in a later commit revision .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advant age and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersbur g russia copyright acm ... .
.
figure .
an incomplete npe fix from xerces .
based on such incomplete fix phenomenon we find that static analysis techniques actually could leverage existing fixes to infer psbp s and then detect their r elated remaining sibling bugs for the projects under analysis .
for exampl e based on the first fix shown in figure we can infer a psbp the class field fdtdhandl er could be null at runtime but it is dereferenc ed without proper null check s .
then w ith the help of such inferred psbp we can easily detect a sibling bug fdtdhandl er is still dereferenced directl y without a proper null check in the method startentity .
to automatically detect such remaining sibling bugs i n this paper we propos e a psbp based approach and implement a static analysis tool called sibling bug detector sbd .
given a fix revision sbd first leverages bug pattern templates to effectively identify its actually fixed bugs and then infers psbp s based on the identified bugs.
after that based on the inferred psbps sbd detects whether some other sibling bugs still remain .
to evaluate sbd we apply sbd to seven popular well maintained open source project s. sbd identifies sibling bug s and of the m have been confirmed as real bugs by the project developers while two existing popular static bug detection tool s findbugs and pmd cannot report most of them.
this paper makes the following main contributions the first to propose the concept of project specific bug pattern s psbp s .
an effective technique for inf erring psbps based on bugpattern template s. a psbp based sibling bug detector sbd which applies the inferred psbps to detect sibling bugs for the project under analysis .
empirical evaluations on seven popular real world open source project s to demons trate the effectiveness of sbd.
.
approach this section presents the proposed approach.
figure illustrates the approach overview.
given a fix revision our approach first infer s psbp s based on its actual fix activities and then applies the inferred psbps to detect whether some other sibling bugs remain in the project under analysis .
section .
describes the bug pattern templates predefined for different well known bug types in our approach.
sections .
and .
describe the pro cess of inferring project specific bug pattern s and the process of detecting sibling bugs.
figure .
approach overview .
.
defining bug pattern template s since directly inferring arbitrary psbp s from a given fix revision could be ch allenging we leverage bug pattern templates to help infer psbps .
in our approach a bug pattern template contains two parts featured statements and usage scenarios .
featured statements are important statement changes additions and or deletions introdu ced by the given fix revision .
such featured statements can provide strong hints to understand the actually fixed bug .
note that not all those statement changes introduced by the fix revision are equally important to characterize the actually fixed bug.
usage scenarios are characterized with finite state automata fsa to summarize typical usage scenarios for the focused objects of a bug pattern template .
such usage scenarios can further help understand fix revisions .
figure and figure visually illustrate the bug pattern template s currently implemented for our approach the npe template and the resource leak template.
their corresponding formal specification files can be found on the project website1.
for the npe template its featured statements are the newly added null check statements since developers typically introduce them on the npe triggering objects to avoid npe bugs.
meanwhile its usage scenarios summarize typical usage scenarios of npe related objects.
in usage scenarios an expression between and describe s the precondition that the corresponding state transition event should satisfy and a black color ed gray colored state represent s a buggy correct state.
the buggy usage scenari o for an npe related object a is that a is dereferenced directly when a is null from state to state while the correct usage scenarios include a is dereferenced when it is not null from state to state a is first null checked from state to state and then safely dereferenced from state to state .
for the resource leak template its featured statements include the newly added object releasing method calls since developers typically call such methods on resource object s to avoid leaks.
meanwhile its usage scenarios summarize the typical usage scenarios of the leak related objects.
its correct usage scenarios include the focused object a is first created by constructors or other method calls from state to state and then it is safely released with a release method from state to state a is first assigned and then returned as a return value from state to state a is first assigned and then it will not be closed since it is null from st ate to state .
while its buggy usage scenario is that after a is assigned a is not closed and also not returned when a is not null from state to state .
figure .
the bug pattern template for npe bugs .
figure .
the bu g pattern template for resource leak bugs .
.
inferring project specific bug pattern s with the help of the predefined bug pattern templates we infer psbps based on each given fix revision with three steps featured statemen t identification section .
.
focused path extraction section .
.
and pattern generation section .
.
.
.
.
featured statement identification given a fix revision the first step of our psbp inference is to identify its featured statements among it s newly added statements currently we do not handle fix revisions containing only statement deletions which we plan to support in future work .
in this step w e first retrieve all of its newly added statements .
then we try to syntactically match them wi th the featured statements defined in each template .
based on such matching we treat the matched statements as the featured statements of the given fix revision .
figure shows a nother npe fix example which is from the fix revision revision on the class file listlevel.java in the poi project .
in figure the added deleted lines are labeled with the symbols .
for this example we first identify its newly added statements lines and .
then we try to match each of them with the predefined featured statements of each bug pattern template .
based on such matching we identify if numbertext null line as a f eatured statement since it matches with the featured statemen t if a null of the npe template .
meanwhile we treat numbertext as its focused object.
.
.
focused path extraction in this step guided by each featured statement identified by the previous step we first extract a limited number of its covered paths e.g.
up to the first five traversed paths that include the featured statement and then slice each of them based on the variable corresponding to the focused object of the featured statement .
in this step we treat such sliced paths covered by feature d statements as focused paths .
figure .
an npe fix example from the fix revision revision on the file listlevel.java in poi .
algorithm shows the algorithm for extracting focused paths.
it takes the revision number rev of a fix revision under analysis and the locations l of the featured statements of the fix revision as inputs and produces the extracted focused path s p as output.
in the algorithm we first locate the methods where the featured statement s reside as the featured methods m line .
for each featured method m in m we first generate its control flow graph line .
after that for each featured statement sf in m we extract up to the first five traversed paths of its covered paths as pcovered line and then we get the focused object os of sf line .
based on os we slice each of its covered paths as a focused path pfeatured without considering control dependencies line starting with sf we first sl ice backward the path portion preceding sf and then sl ice forward the path portion succeed ing sf the backward forward slicing is based on os.
during the intraprocedural slicing process the statements irrelevant to os with respect to the concept of slicing a re discarded resulting in that each f ocused path include s only the statements relevant to os.
finally we save the extracted focused path pfeatured into p line .
figure .
the extracted focused path for the fix example shown in figure .
figure shows an example about the focused path extraction for the fix revision shown in figure .
in it one of the paths covered by the featured statement if numbertext null line is illustrated.
the internal flow edges of the path are labeled with numbers among the control flow graph of the example method tobytearray .
based on the focused object o numbertext of the featured statement we slic e the covered path as a focused path.
the focused path includes only five st atements underlined in figure and their line numbers ar e and the return statements would be forcedly kept during the slicing .
.
.
pattern generation in this step we first try to match each focused path with the predefined usage scenarios of each bug pattern template .
based on such matching we further confirm whether the given fix revision fixes some real bug instance s conforming to some certain bug pattern template s .
based on the confirmed bug instances we then generate project specific bug patterns correspondingly .
algorithm shows the pattern generation algorithm.
in the algorithm we take a focused path p and its included f eatured statement sf as inputs and pro duce the generated project specific bug pattern s psbp s as output.
in particular w e first load the proper bug pattern template based on the featured statement sf line .
for example if sf is a null check statement we would load the predefined npe templ ate as bpt since sf is a featured statement for npe bugs.
after that guided by the usage scenarios sce of the loaded template bpt we track the usage states of the objects used in p lines .
in the state tracking process we set the initial state of each focused object as state and then update its states by visiting forward the statements in p. for each statement s in p we repeat the same analysis process as follows .
if statement sp preceding s tries but fails to create an object o the flow edge between these two statements in the cfg is an exception throwing edge the effects of sp impacting previously on the points to information and the usage state of o are actually invalid.
in such case we would roll back such invalid effects lines .
i f s dereferences an object o we use the dereference event e and its current precondition to update the usage state of o lines .
in the algorithm such state updating processes are all guided by sce we determine whether and how to update the state of o by checking whether and how the corresponding state of sce is transited under the same certain event and precondition .
if s calls a method m on an object o we use the method call event e and its current precondition to update the usage state of o line s .
if s makes a n equal ity check i.e.
using operator on an object o we first check whether the subsequent statement of s is located in the false branch of s. if yes we negate the equal ity operator of the if statement lines .
after th at we use the equal ity check event e and its current precondition to update the usage state of o lines .
if s assigns some value to an object o we first update points to information according to s and then use the assign ment event e to update the usage state of o lines .
if s returns an object o we use the return event e and its current precondition to update the usage state of o lines .
after analyzing the statements in p for each focused object o we check whether it is in a corre ct usage state at the exit of p and also whether its state transition process involves at least one featured statement lines .
if yes we affirm that a bug instance on o conforming to bpt is really fixed in the given path .
based on such identified real bug instance we further generate a project specific bug pattern bsbp by concretizing bpt with o and save it into bsbp s. note that when sf calls a method m we would also generate project specific bug patterns by concretizing bpt with the inner2 and outer2 objects of o that also define a method named as m. for example the typical featured statement for the resource leak bugs calls the method close .
if the given fix revision fixes a resource leak bug on a resource object ob we generate project specific bug patterns not only for ob but also for its inner and outer objects that also define the same method named as close .
the reason is that once a resource object is closed its inner and outer resource objects usually should also be closed safely sharing the same bug pattern .
for the fix example shown in figure we would match its focused path shown in figure with the usage scenarios of the npe template.
the focused path includes five statements lines and .
after visiting line we update the usage state of the object o numbertext that the variable numbertext points to as state since o numbertext is null checked in the statement .
after visiting line we update the usage state of o numbertext as state since o numbertext is dereferenced in the statement .
however visiting the remaining statements does not change the usage state of o numbertext further.
therefore o numbertext is finally in state a correct usage state at the exit of the focused path.
therefore we affirm that the fix example fixes an npe bug on o numbertext .
based on such bug instance we concretize the npe template with o numbertext to generate a project specific bug pattern show n in figure the class field when an object o is initiated if another object o is assigned to a field of o we say that o is nested into o o nests o o is an inner object of o and o is an outer object of o .
numbertext could be null at runtime and dereferencing it without proper null check s would lead to npe bugs .
.
detecting sibling bugs in this phase based on the inferred psbps we detect sibling bugs remaining in the same project under analysis.
to collect basic program information for sibling bug detection we first conduct some basic analys es object nesting analysis points to analysis and precondition analysis.
the object nesting analysis performs a forward intra procedural dataflow analysis to identify the information on nesting2 relationships between objects.
the points to analysis performs a forward inter procedural context sensitive dataflow analysis to identify the points to informatio n for all reference variables.
the points to information of a variable provides the potential object s that it may point to its potential actual type s and its potential aliases.
the precondition analysis performs a forward intra procedural dataflow an alysis to identify the execution preconditions i.e.
groups of predicates for each statement.
sibling bug detection performs a flow sensitive inter procedural cfg based dataflow analysis whose algorithm is similar to the defect analysis algorithm descr ibed in our previous work .
by matching cfg paths of the method under analysis with the usage scenarios sce of each inferred psbp we track the usage state of each focused object at any path point guided by sce.
if any focused object is in a buggy sta te at the exit of a path we treat the path as a buggy one and then report a sibling bug warning for the focused object.
for each method under analysis we use a forward worklist algorithm over its cfg blocks to iteratively compute a fixed point over the usage states of all focused objects.
in order to flexibly control the precision cost tradeoff we define the maximum depth of inter procedural analysis as maxdepth and the maximum number of intra procedural iterations as maxiter .
before rea ching the fixed point we iteratively visit cfg blocks in the reverse post order until maxiter is reached.
for each block b of cfg we update its inflow value dbin the possible usage states of all focused objects at the inflow side of b by merging all t he outflow values of its inflow blocks.
however if some inflow block tries to create an object o but fails we would roll back its previous impact on the points to information and the usage state of o. after computing dbin we visit each statement s in b forward to propagate their impacts on dbin guided by sce.
in this process we propagate impacts for five types of statements the method call statement the equal ity check statement the object dereference statement the assignment statement and the return statement.
moreover we propagate the impact of a statement only if its precondition does satisfy the required effect taking precondition .
in our predefined templates a state transition statement can be assigned with an effect taking precondition only under which the statement takes effect.
for example in the resource leak bug pattern template the return statement takes effect only when the focused object is null.
after the analysis for each method under analysis we check whether any focused object o is still in a buggy state at the exit of the method.
if yes we report a sibling bug warning for the corresponding buggy path.
to improve the efficiency w e detect sibling bugs within proper scope s if the focused object ob of psbp is a local object of a specific method we detect bugs only within the method if it is a private class field we detect bugs within its belonging class file if it is a protected class field we detect bugs with in its belonging package if it is a public class field we dete ct within the whole project under analysis .
figure .
the inferred project specific npe bug pattern from the fix revision shown in figure .
.
evaluation s based on the propose d approach we implement ed a psbp based sibling bug detector sbd and conduct evaluations on it .
this section presents our evaluation setup and evaluation results on sbd.
.
evaluation setup we design our evaluations to address the following research questions rq1 detect ion effec tiveness can sbd effectively detect sibling bugs for real world projects?
rq2 tool complementarity how high percentage of true sbd warnings can not be detected by traditional bug detectors e.g.
findbugs and pmd ?
rq3 bug fixability how difficult is it to fix sbd warnings?
in our evaluation s we select seven projects including lucene tomcat ant james maven xerces and poi as the projects under analysis.
we choose these projects because they are commonly used in the literature and they are relatively mature and well maintained open source project s under the apache software foundation.
to detect sibling bugs for these projects we pre define two bugpattern templates in sbd the npe bug pattern template and the resource leak bug pattern template shown in section .
.
we predefine these two bug pattern templates for two reasons.
first these two types of bugs tend to introduce multiple fixes .
for a resource leak or npe bug its focused object can potentially leak or be null dereferenced in many code locations resulting in many sibling bugs .
therefore fixing a resource leak or npe bug completely usually needs to handle all of its sibling bugs .
however developers can easily miss fixing some sibling bugs resulting in submitting incomplete fix revisions .
second traditional bug detectors are usually ineffect ive in detecting resource leak or npe bugs .
theoretically all kinds of objects resource objects instantiated in any method under analysis may throw null pointer exc eptions lead to resource leaks .
however in real world projects only a certain subset of objects resource objects shou ld be null checked released .
without such concrete knowledge traditiona l bug detectors usually produce too many false negatives show n in section .
as well as false positives .
.
detection effectiveness in this section we evaluate the detection effectiveness of sbd by measuring the number of sibling bugs that sbd can effectively detect .
figure shows the evaluation methodology.
guided by the fix revisions whose log messages contain the keyword npe or resource leak we randomly select npe fix revisions and resource leak fix revisions from the source code repositories of the su bjects d uring this process i f a fix revision involves multiple change d files we treat each file change as a standalone fix revision .
based on the selected fix revisions we run sbd to detect sibling bugs within proper scopes.
then we manually verify t he reported sibling bug warnings based on the following process .
we first check whether they have been fixed in subsequent historical revision s. if some warning has been fixed we treat it as a true warning .
if some warning has not been fixed and remain s in the head revision we report it as a new bug issue to the project community .
if a reported warning is confirmed or fixed by developers we also treat it as a true warning .
figure .
evaluation methodology .
table .
the result summary for the sbd warnings on the selected fix revisions on npe or resource leak bugs.
bug type sibling bug w arnings all already fixed reported confirmed npe resource leak all table summarizes the sbd warnings on the subjects.
for each bug type column s all already fixed reported and confirmed represent the total number of the related warnings the number of the related warnings that have been already fixed by subsequent historical revisions in source code repositories the number of the related warnings that are reported as new bug issues and the number of the related newly reported warnings that have been confirmed or fixed by developers respectively .
sbd totally report s npe warnings .
through manual verification we confirm that eight of them have already been fixed in subsequent historical revisions .
we report warnings remaining in head revisions as new bug issues to the related project issue tracking systems.
so far of the newly reported issues have been confirmed or fixed by developers.
similarly sbd reports resource leak warnings.
we confirm that of these warnings have already been fixed in subsequent revisions .
we report warnings remaining in head revisions as new issues.
among the newly reported warnings of them have been confirmed or fixed by their developers.
table shows the details of the already fixed warnings.
columns bug type subject and fixed location present the fixed bug type the project name and the fixed location of each fix revision under analysis respectively .
column of sbd warnings presents the number of the warnings that are reported by sbd on each fix revision .
column already f ixed i n shows information about the subsequent revision s that the corresponding warnings were fixed in.
for example the revision of the poi project fixed an npe bug in the method tostring of the class lbsdatasubrecord .
based on such revision sbd report s one npe warning and the warning has been fixed by a subsequent revision revision .
table shows the details of the bug issues that we newly report for the sbd warnings note that we may report several warnings in an issue and their resolution statuses .
for each subject c olumn w presents the number of the sbd warnings that still exist in the head revision column reported issue id presents the id information of the issue that we report for the corresponding warnings and column status presents the resolution status of the related issue.
table .
the already fixed sbd sibling bug warnings .
fix revision of sbd warning s already fixed in bug type subject fixed location null pointer except ion npe poi lbsdatasubrecord tostring rev892461 poi listlevel getsizeinbytes rev1022456 xerces abstractdomparser startdocument rev318567 xerces xmldtdscannerimpl setinputsource rev318859 lucene segme ntinfos run rev602055 maven abstractjavadocmojo getsourcepaths rev562714 resource leak xerces xincludehandler handleincludeelement rev319304 tomcat webappclassloader findresourceinternal rev915581 tomcat standardserver await rev1066310 maven latexbookrenderer writesection rev1003021 james mimemessagejdbcsource getinputstream rev107975 ant fixcrlf execute rev269909 ant replace processfile rev269961 ant replaceregexp doreplace rev272826 table .
the newly reported sbd sibling bug warnings reported in bug issues .
fix revision w reported issue id status bug type subject fixed location null pointer exception npe poi characterrun getfontname fixed poi mapimessage set7bitencoding fixed poi zipfilezipentrysource close fixed xerces xswildcarddecl getnsconstraint list xercesj need test case xerces rangetoken dumpranges xercesj need test case xerces identityconstraint getselectorstr xercesj confirmed already avoided lucene multipletermpositions skipto lucene in progress lucene parallelreader gettermfreqvector lucene in progress lucene parallelreader next read skipto close lucene in progress lucene directory clearlock lucene in progress lucene nears pansunordered ispayloadavailable lucene in progress maven abstractjavadocmojo getsourcepaths mjavadoc fixed maven webappstructure getdependencies mwar in progress resource leak ant xmlresultaggreg ator writedomtree fixed ant javadoc execute fixed ant replace execute fixed ant replaceregexp doreplace fixed james nntphandl er handleconnection james confirmed james pop3handler handleconnection james confirmed james remotemanagerhandler handleconnection james confirmed james smtphandler handleconnection james confirmed tomcat catalina stopserver load fixed tomcat memoryuserdatabase open fixed tomcat hostcon g deploywar fixed tomcat cometconnectionmanagervalve lifecycl eeven t fixed tomcat jdtcompiler getcontents fixed tomcat expressionfactory getclassnameservices fixed tomcat nioendpoint run in progress tomcat web appclassloader validatejarfile fixed tomcat managerbase run setrandomfile confirmed tomcat standardcontext cachecontext no need to fix unused code now tomcat htmlmanagerservlet c achecontext invalid tomcat standardmanager dounload fixed xerces objectfactory findjarserviceprovider xercesj in progress maven pmdreport execute mpmd fixed maven pmdreporttest readfile mpmd fixed maven cpdreport writenonhtml mpmd fixed maven verifier loadfile displaylogfile mverifier in progress maven latexbookrenderer writesection doxia in progress maven xdocbookrenderer rendersection doxia in progress maven xhtmlbookrenderer renderbook doxia in progress maven testutils readfile mplugintesting in progress for example for the fix revisi on revision of the poi project there is one sbd warning that still exist s in the head revision.
we report it as a new issue with id as .
based on the issue a poi developer fixes it with a new fix revision revision and also expres ses his appreciation to us on reporting the issue .
for the warnings in xerces and tomcat the developers reply that the warnings have already been avoided by historical code changes so there is no need to fix them in the head rev ision s. however some warning s are not confirmed.
for xerces we report one warning but the xerces developers require us to table .
detection effectiveness result s of findbugs and pmd on the sbd warnings already fixed or confirmed by developers.
fix revision sbd findbugs pmd bug type subject fixed location null pointer exception npe poi lbsdatasubrecord tostring poi listlevel getsizeinbytes poi characterrun getfontname poi mapimessage set7bitencoding poi zipfilezipentrysource close xerces abstractdomparser startdocument xerces xmldtdscannerimpl setinputsource xerces identityconstraint ge tselectorstr lucene segmentinfos run maven abstractjavadocmojo getsourcepaths maven abstractjavadocmojo getsourcepaths resource leak ant fixcrlf execute ant replace processfile ant replaceregexp doreplace ant xmlresultaggregator writedomtree ant javadoc execute xerces xincludehandler handleincludeelement tomcat webappclassloader findresourceinternal tomcat standardserver await tomcat webappclassloader validatejarfile tomcat standardcontext cachecontext tomcat memoryuserdatabase open tomcat managerbase run setrandomfile tomcat standardmanager dounload tomcat catalina stopserver load tomcat cometconnectionmanagervalve lifecycleevent tomcat jdtcompiler getcontents tomcat expressionfactory getclas snameservices maven latexbookrenderer writesection maven pmdreport execute maven pmdreporttest readfile maven cpdreport writenonhtml james mimemessagejdbcsource getinputstream james nntphandler handleconnection james pop3handler handleconnection james remotemanagerhandler handleconnection james smtphandler handleconnection total of detected sbd warnings already fixed or confirmed provide test cases to demonstrate the related bug s existence at runtime .
for the warning in tomcat a tomcat developer resolves it as invalid because he considers that the corresponding resource leak would never happen at runtime .
other warnings are still in process and have not been resolved by their developers yet.
in summary a s shown in table sbd report s a total of sibling bug warnings for all subjects.
among these warnings warning s have already been fixed in their subsequent historical revisions .
such result directly confirm s that these warnings are true.
in addition of the newly reported sbd warnings have also been confirmed or fixed by their developers.
note that although open source project s are usually well maintained sbd reports new real bugs in their head revisions.
overall at least .
of the sbd warnings are true.
table indicate that the remaining sibling bugs are common for the two well known bug types and sbd can effectively locate remaining sibling bugs for these well known bug types.
table shows that sbd warnings have been fixed by community developers with new fix revisions i.e.
the warnings shown in the rows with column status as fixed note that a row representing a newly reported issue may correspo nd to multiple warnings warnings have been confirmed as real bugs i.e.
the warnings shown in the rows with column status as confirmed and issue s are still in progress of being investigated i.e.
the issue s shown in the rows with column status as in progress .
such result indicates that at least .
of the newly reported warnings are true.
among the true warnings about .
of them have been fixed by community developers.
the evaluation results show that sbd can effectively locate sibling bugs for real world projects based on their existing fix revisions .
with the help of sbd developers can fix bugs more comprehensively and systematically.
.
tool complementarity section .
shows that sbd can effectively dete ct npe and resource leak sibling bugs .
in this section we investigate how well sbd compleme nts two existing widely used tools findbugs and pmd by measuring how high percentage of true sbd warnings can not be detected by these two existing bug detectors.
in this evaluation we first run findbugs and pmd on the subjects to collect their reported npe and resource leak warnings .
then we manually check whether each of the true sbd warning s is also reported by findbugs or pmd .
during this process we consider only the already fixed or confirmed sbd warnings shown in table s and as true sbd warnings.
table summarizes the number of the true sbd warnings for each related fix revision and also the number of the true sbd warnings that findbugs or pmd also report s for the related fix revision when the number is we leave the table cell as em pty .
for example for james sbd reports true npe warnings for the class file mimemessagejdbcsource.java .
however findbugs reports none of the true warnings and pmd reports only of the true warnings .
for tomcat sbd reports true resource leak warnings while findbugs reports only of the true warnings and pmd reports only of the true warnings .
in total findbugs and pmd report only of the true sbd warnings .
among the true sbd warnings findbugs cannot report .
of them and pmd cannot report .
of them .
such result shows that sbd is complementary with these existing tools since most of the true warnings that sbd reports cannot be detected by thes e existing tools .
.
bug fixability in this section we investigate the difficulty to fix sbd warning s. the difficulty of fixing bugs is indeed case by case.
however we believe that fixing sbd warnings would not be difficult since these warnings are detect ed based on existing f ixes which can provide good reference s to fix these warnings .
this section uses two examples of actual fixes to show the simplicity of the fixing process for sbd warnings .
for the example from the poi project figure shows the first fix revision the sibling bug identified by sbd and the second fix revision .
the added lines of each revision are in bold and labeled with the symbols while the deleted lines are labeled with the symbols .
the first fix revision fixes an npe bug on the class field nameidchunks in the method set7bitencodin g .
such fix indicates that nameidchunks could be null at runtime and should be null checked before dereferenced.
however it is still dereferenced directly without a null check in the method has7bitencodingstrings .
based on such fix revision sbd report s an npe warning on the nameidchunks field.
after we report the warning as a new issue for the poi project a poi developer fixes it with a new fix revision by si mply committing the same fix activities as the first fix.
figure shows another example from tomcat.
the first fix revision fixed a resource leak bug on the local object cometevent in the method lifecycleevent .
however when the statements in the try block e.g.
commetevent.setevent type ... throw exceptions the statement cometevent.close would have no chance to be execute d. in such case s the cometevent object would leak.
based on such fix revision sbd report s a res ource leak warning on cometevent .
after we report the warning as a new issue for the tomcat project a tomcat developer fixes it by just simply closing the resource object cometevent in the finally block instead of the try .
these two examples of actua l fixes show that the fixing process on a sbd warning would not be difficult to fix a sbd warning developers tend to easily imitate one of its related existing fixes by simply replicating it or making a similar fix around the reported location s .
figure .
an example of actual fixes from the poi project on an npe sibling bug warning reported by sbd.
figure .
an example of actual fixes from the tomcat project on a resource leak sibling bug warning reported by sbd.
.
threats to validity in this section we summarize main threats to external int ernal and construct validit y of our evaluations .
there are two main threats to external validity.
the first one is about the representativeness of the subjec t projects that we select in the evaluation s. the results of our evaluation s may be specific only to these projects.
to reduce this threat we choose different types of projects as subjects and evaluate sbd on multiple subjects.
the second one is about the extendability of sbd on other bug type s. in the evaluation s we show that sbd can effectively detect sibling bugs for npe bugs and resource leak bug s. however sbd may not be applied easily for other bug type s. to reduce this threat we separate the speci fication process of bug pattern templates for different bug types from the detection logic implementation in sbd .
we also propose a specification notation for bug pattern template s and such notation is applicable or can be easily extended to support other bug types e.g.
array index out of bounds uninitialized variable read s and unmatched lock unlock pairs .
based on the notation we define a bug pattern template for each bug type with a standalone xml file in sbd .
the main threat to internal validity i s about the predefined bugpattern templates for npe and resource leak bugs.
in the evaluation s we manually summarize the featured statements and the usage scenarios for the two well known bug type s. however our summarization may not be complete or accur ate enough.
to reduce this threat we carry out the summarization by studying plenty of actual fix revisions for npe and resource leak bugs.
the main threa t to construct validity is that in the evaluation s we treat a warning as a true one if a real devel oper commit s an actual fix on it.
however since typical fixes for some warnings are quite simple e.g.
adding a guarding if statement or invoking a resource releasing method on a resource object in a finally block and harmless developer s may choose to fix these warnings conservatively even if the fixes could be redundant or unnecessary.
in such cases the related warnings would be mistreated as true ones.
.
related work identification of incomplete fix es.
kim et al.
propose an approach to identif y incomplete fixes for exc eption bugs e.g.
null pointer exception bugs with the concept of bug neighborhood .
a bug neighborhood refers to a set of related flows of invalid values .
their approach requires external users to pinpoint concrete statem ent pairs that can introduce bugs in a program under analysis .
based on each statement pair their approach detect s whether the statement pair has been fixed in the modified version of the program .
in contrast our approach does not require users to manual ly pinpoint anything and our approach can systematically detect remaining sibling bugs for subject programs.
in addition our approach is general purpose and exten sible for various well known bug types.
mining of generic bug pattern s. various specificati on mining approaches have been proposed in the literature.
specifications mined by these approaches can be used to guide the bug pattern extraction each violation to a specification can be treated as a bug pattern.
existing approaches mine s pecifications for api libraries mainly from three kinds of sources api client programs api library source code and historical revisions and api library document s. however the specifications that these approaches can produce are mainly about the usage r ules of classes defined in third party libraries .
specifications that are mined by these approaches on a certain library would be applicable for all programs relying on the same library .
therefore these approaches are suitable for mining generic bug patte rns.
in contrast our psbp inference process aims to infer project specific bug patterns which are directly related to objects instantiated in specific projects under analysis .
static detection of npe s and resource leak s. most existing static bug detecti on tools e.g.
esc java findbugs pmd jlint and lint4j also provide npe and resource leak detectors.
among th em esc java is a specification based violation checker which requires specifications to be manually provided by develo pers.
esc java tries to find all violations to a specified null non null annotation and usually produces too many false positives.
other tools use typical static analysis techniques to detect npe or resource leak warnings based on generic defect patterns.
these tools usually report too many false positives or negatives.
besides these popular tools various research approaches on detecting npe and resource leak bug s have been proposed.
spoto et al.
propose a technique for inferring nonnull annotation s to improve the precision of their null pointer analysis.
their inference of non null annotation s is based on some heuristics e.g.
the initialized instances or static fields are treated as always non null .
hovemeyer et al.
propose a n approach based on non standard npe analysis.
in their approach they also use annotations as a convenient lightweight mechanism to improve the precision of their analysis.
weimer and necula propose an approach for detecting system resource leak problems in java pro grams result ed from incorrect exception handling s. their approach includes an unsound but simple path sensitive intra procedural static analysis to find resource leaks.
shaham et al.
propose a conservative static analysis based on canonical abstracti on to verify the safety of the synthesized free operations for dynamically allocated objects.
their analysis could be used to automatically insert resource releasing operations to prevent resource leaks.
charem and rugina propose a similar approach wit h a less expensive analysis.
dillig et al.
propose the closer approach to perform a modular and flow sensitive analysis to determine live system resources at each program point.
torlak et al.
propose a scalable flow sensitive context sensitive i nter procedural resource leak analysis which relies on less expensive alias abstractions.
compared with these approaches our approach infers psbps from actual fix revisions and then applies the inferred psbps to detect the remaining sibling bugs.
.
concl usion in this paper we have proposed a general purpose approach for detecting sibling bugs for various bug types and implement ed a tool called sibling bug detector sbd .
based on existing fix revisions our approach first automatically infer s project specific bug patterns psbps hidden and reflected by the fix revisions and then applies the inferred psbps to detect their related remaining sibling bugs for the projects under analysis .
through evaluation s we have shown that sbd effectively report s tr ue sibling bug warnings for seven real world open source projects while two existing popular static bug detectors findbugs and pmd cannot report most of them.
although our approach has been shown to be effective the approach still has some limitations .
first our proposed specification notation for bug pattern template s is general purpose for bug types involving only one single object.
currently for each bug type we use a finite state automaton fsa to summarize the typical usage scenarios of its fo cused object.
however once a bug type involves multiple interacting objects e.g.
an array list of java.util.arraylist cannot be updated when it is being traversed by an iterator of java.util.iterator our approach is not applicable.
second in sbd the predefined bug pattern templates are still limited.
with more pattern templates predefined and applied the generality of sbd could be further improved.
to make sbd more practical we plan to extend sbd to locate sibling bugs for more well known bu g type s e.g.
data race dead lock and buffer overflow in our future work.
during this process we plan to keep exploring better approaches to specifying bug pattern template s inferring psbps and detecting sibling bug s. .