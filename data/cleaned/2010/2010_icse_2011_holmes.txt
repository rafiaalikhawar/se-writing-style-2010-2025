identifying program test and environmental changes that affect behaviour reid holmes school of computer science university of waterloo waterloo on n2l 3g1 canada rtholmes cs.uwaterloo.cadavid notkin computer science engineering university of washington seattle wa usa notkin cs.washington.edu abstract developers evolve a software system by changing the program source code by modifying its context by updating libraries or changing its con guration and by improving its test suite.
any of these changes can cause di erences in program behaviour.
in general program paths may appear or disappear between executions of two subsequent versions of a system.
some of these behavioural di erences are expected by a developer for example executing new program paths is often precisely what is intended when adding a new test.
other behavioural di erences may or may not be expected or benign.
for example changing an xml con guration le may cause a previously executed path to disappear which may or may not be expected and could be problematic.
furthermore the degree to which a behavioural change might be problematic may only become apparent over time as the new behaviour interacts with other changes.
we present an approach to identify speci c program call dependencies where the programmer s changes to the program source code its tests or its environment are not apparent in the system s behaviour or vice versa.
using a static and a dynamic call graph from each of two program versions we partition dependencies based on their presence in each of the four graphs.
particular partitions contain dependencies that help a programmer develop insights about often subtle behavioural changes.
categories and subject descriptors d. .
tools and techniques d. .
programming environments general terms measurement keywords static analysis dynamic impact analysis comparative analyses software behaviour permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may honolulu hawaii usa copyright acm ... .
.
.
introduction when developers make a change they focus on two primary questions did i successfully implement the intended change?
and did i break anything else?
most variations in behaviours between the original and modi ed executables provide evidence useful for answering these questions.
con dence that a change performs as expected may for example be increased when tests for the newly added feature pass.
concern that a change may have inadvertently broken something is raised for example when a regression test fails.
some behavioural variations however may not be easily isolated or identi ed as pertinent to either question.
such a variation may be benign may represent a subtle bug or may only manifest as benign or buggy over time as it interacts with other behaviours.
our approach intends to help developers more easily identify speci c variations of this kind allowing them to thoughtfully decide whether the variations of immediate or long term concern.
a developer can evolve a software system s behaviour in at least three ways changing the program source code modifying the test suite and altering the environment.
given a set of changes in one or more of these dimensions we extract both a static and a dynamic call graph from each of two program versions and partition the calls based on their presence in each of the four graphs.
some partitions contain dependencies that are unlikely to concern the developer for example if new tests are added alongside new methods in the program source these will be captured in the partition that contains pairs that are not observed in the original version but are observed both statically and dynamically in the new version.
other partitions isolate pairs that likely deserve more scrutiny for example a call that appears dynamically without any corresponding change to the program source may occur because of a change to a con guration le that is not apparent in the source code.
our contributions include de ning and implementing a simple but novel mechanism for partitioning program changes in terms of static and dynamic method calls.
identifying which of these partitions represent consistent inconsistent unchanged unlikely and unexecuted changes to the program s dependencies the inconsistent category represents those changes that likely deserve deeper developer attention.
by focusing on a developer s current change rather than the aggregation of all past changes we are able to return a small subset of pertinent dependencies for the developer to examine.
evaluating our approach over versions of three different open source systems demonstrating various quantitative and qualitative properties of our approach.
for example we show that fewer than of the extracted pairs are of likely interest to the programmer with respect to behavioural changes.
applying our approach to an industrial code base for one complete development sprint.
the limited feedback we received suggests that the behavioural information can provide a useful alternative view for tracking system evolution.
our industrial partner valued the information that our approach provided enough to request that it be incorporated into their existing nightly build system.
section details our approach for de ning these partitions and categorizations it also provides a concrete scenario to illustrate our partitioning approach.
section presents the static and dynamic extraction tools we use and how we reconcile static and dynamic calls with one another.
section reports on application of our approach to three open source systems describes our initial industrial application and discusses threats to validity.
section covers key related work and section concludes.
.
approach we model a program s structure using call graphs denoting a program s methods and the calls between them.
we extract four dependence graphs a static call graph from before and after a change v1sandv2s each of these caller callee pairs is statically observed and a dynamic call graph from before and after the same change v1dand v2d each of these pairs is dynamically observed .
this classi cation depends on the speci c analyses that are used our prototype uses the lightweight analysis tools described in more detail in section .
our exposition generally focuses on source code changes but our approach does not restrict the kinds of changes the developer can make in addition to the source code we also explicitly address changes to test suites and the environment of the program.
like all other approaches our approach cannot provide guarantees about how a source change will e ect subsequent executable behaviour.
we believe it to provide a complementary perspective that developers can use to help determine if a static change is likely to a ect the program s runtime execution in unforeseen and perhaps troublesome ways.
we use static dependencies to approximate some dimensions of programmer expectation.
in particular we consider changes to the static call dependencies as expected changes because the programmer explicitly modi es the program source.
for example if a programmer adds a method call and a corresponding test to a program we consider it unsurprising that there are new corresponding static and dynamic call dependencies in the modi ed program.
thus we model the notion of unforeseen consequences of a source change in terms of static and dynamic call dependences.
we hypothesize that variations in the dynamic dependences between two program versions suggest unforeseen behaviours when related changes are not found in the static dependences.
that is when a programmer makes a change some set of dynamic dependences may be expected to appear if those behaviours do not appear or if other apparently unrelated behaviours appear or disappear then the programmer should consider those deviations in more depth.
dd s s d s d s dsdsd sds s d sd s d s dv2dv1dv1sv2sfigure analysis partitions with descriptive labels and coloured by their categorization.
from these four graphs we compute all set intersections as shown in figure using a standard four set venn diagram.
the circle in the centre represents the statically observed pairs from the rst version v1s the barbell shape represents the statically observed pairs from the second version v2s the vertically oriented rectangle on the right represents the dynamically observed pairs from the rst version v1d and the horizontally oriented rectangle at the bottom represents the dynamically observed pairs from the second version v2d .
each partition containing at least one statically observed pair is marked with an sif its members are statically observed in both versions with an s if its members are not statically observed in the rst version but are in the second and with an s if its members are statically observed in the rst version but not in the second version.
analogously a partition containing at least one dynamically observed pair is marked with d d ord .
by convention we mark the static property of the partition if any exist followed by the dynamic property of the partition if any exist.
the partition containing no pairs from any of the four graphs is uninteresting and has no label.
for example partition s includes only those pairs that were statically observed in the initial version v1s but not in the modi ed version v s2 and that were not dynamic observed in either version v1dandv2d .
similarly partitions d contains only those pairs extracted statically and dynamically in the second version but not extracted by either analysis in the original version.
illustrative scenario.
a developer adding caching functionality to an application might structure code as shown in figure a with the original source code shown in orange and the new code shown in green.
the statically observed pairs the dynamically observed pairs and the combination of those pairs are shown in figures b c and d respectively.
the three method calls the developer added appear in partition s d the developer would likely be more surprised at their absence than at their presence because the calls were explicitly added to source code that was exercised by the test suite.
if however one of the new pairs was not observed dy b statically observed calls in the source code before and after the change.
d combined partitions for the statically and dynamically observed calls.c dynamically observed calls in the executing system before and after the change.private void genstore int val compute cache val private void cache int val localtype l new localtype val collection.add l ...a source code.
original code is orange new code is green.genstore compute cache int localtype int collection.add int s s s s s d dd s d s s s d dsdsd sddsd gs co ca lt adabbreviationsfigure scenario partitions.
namically for instance an exception might interrupt the computation it would instead appear in partition s .
partition d contains a dynamically observed callback from collections.add ... tolocaltype.equals ... this pair is executed when the system tries to add a localtype object to the cache that has been previously cached.
this causes a key collision since the cache is a hashset requiring hashsetto check the equality of the two localtype objects.
by looking at both versions of the source code the developer would likely not expect this method call to occur.
a dynamic di erencing approach would identify this element but the developer would be responsible for discriminating the oned callback from pairs appearing in s d .
.
categorizing dependency partitions we categorize the above partitions based on two related assumptions.
first we assume that a developer modi es code with clear intention.
for example inserting a method call carries with it the expectation that it will sometimes be executed in the modi ed version.
second a developer generally focuses on the part of the program relevant to the intended change rather than trying to understand the program in its entirety .
based on these assumptions we group the partitions into ve categories inconsistent consistent not executed unchanged andunlikely .
figure shows the partition assignment colouring the categories blue green grey orange and white respectively.
while this categorization of the partitions make the most sense in terms of the source code changing it is also pertinent when the test suite changes or the environment is altered.
inconsistent.
dependencies in the inconsistent partitions d d sd and sd represent divergences between statically and dynamically observed pairs.
a method call appearing in d represents a pair that became dynamically observed after a change was made even though a corresponding call was not statically observed in the code before or after the change.
conversely a method call found in d represents a call no longer observed dynamically even though no corresponding method call was statically removed from the source code.
a method call appearing in sd represents a newly observed invocation without a corresponding static change.
this can happen for example if a change in the program s control ow or the addition of a test case allows pre existing but previously unexecuted code to execute.
partition sd represents a statically observed pair that remains unchanged across versions but where it is no longer dynamically observed in the second version.
we posit that the partitions in this category are the most likely to capture unforeseen behavioural changes.
if the test suite were changed sd andsd would represent previouslyexisting method calls that the tests either newly exercise or cease to exercise while these elements may not be inconsistent in this case the developer is still relieved from the task of di erentiating them from s d ands d .
environmental changes e.g.
changing a non source resource can sometimes be detected through new relationships appearing in the d andd partitions in these cases as the source code itself is held constant these partitions contain the dynamic di erences between two executions that are not statically obvious.
consistent.
dependencies in the consistent partitions s d and s d represent changes that are coherent in their static and dynamic representations.
s d represents the static addition of new method calls that dynamically execute in the second version.
conversely s d represents a method call that was deleted and whose corresponding executions disappeared after the change was made.
these changes can be made to either the program source or its test suite.
not executed.
dependencies that are not executed s ands represent method calls that were statically added or removed from the source but were not observed dynamically in either ver sion.
this might arise if for instance if a developer added a new junit test case but forgot to add the test annotation to it in this case the added calls would appear in s rather than in s d .
incongruities between the consistent and not executed may help a developer who expects a static change to be dynamically corroborated.
unchanged.
partitions s d and sdrepresent pairs that were unchanged between the two versions.
pairs observed consistently statically dynamically or both statically and dynamically before and after a change are likely to be unsurprising to a developer.
the overwhelming majority of the dependencies in the system fall into these partitions see section .
unchanged partitions can be viewed as aggregating past changes across a sequence of versions.
that is once a pair appears in an unchanged partition it will remain there across future changes unless that pair is modi ed again.
for example a method call added and executed in the fth version of a program would appear in s d but an analysis of the sixth version would nd this same fact appearing in sdunless that call was changed again.
unlikely.
theunlikely partitions s d s d s d and s d represent states that are highly unlikely or not possible given our analysis tools described immediately below and thus will likely never be populated.
for example it would be bizarre to statically delete a call that is only dynamically observed after the deletion s d .
we have not observed these unlikely partitions in practice.
.
partitioning non source changes our approach can also be used to detect behavioural differences brought about by modi cations to libraries or noncode resources.
developers can use our approach to hold their source code constant and change their environment.
in these cases the consistent andnot executed partitions would always be empty because the source would not have changed.
elements in the inconsistent partitions would be especially interesting because they would represent behavioural changes in an environment the developer would likely expect there to be none.
for example a developer updating a third party library expecting their system to behave the same would be surprised to nd dependencies in sd orsd these dependencies would indicate that the control ow of their program has changed as a consequence of the library update.
section shows a real example of this when the system is run on two di erent jdks.
as another example if the developer changes a con guration xml le they may nd dependencies appearing in the d partitions as some callbacks stopped executing as a consequence of the metadata change.
.
expressiveness by di erencing two dynamic and and two static analyses our approach provides developers with an expressive set of partitions enabling them to interpret each partition as appropriate for their task.
consider a pair in the d partition in a dynamic only approach all the developer would know was that there is a new method call executing.
in contrast in our approach the developer can di erentiate between there is a new method call being executed that i explicitly added s d a method call that was previouslywritten is now being executed sd and an unexpected method call that is now being executed d this resolution allows them to focus on only those elements that they are interested in and easily ignore the rest.
each of our partitions can be directly related to a developer s day to day development activities.
greater partitioning allows developers to focus their attention on the partitions relevant to their task.
.
dependency graph generation our implementation uses dependence graphs that contain nodes that represent methods and edges that represent calls between methods.
static analysis.
we generate the static dependence graph using robillard s eclipse based jayfx tool with the class hierarchy analysis option disabled.1jayfx reports static dependencies for a given project but does not consider external library code.
as such its results approximate what a developer might generate through a manual code inspection of their own project s code.
this static analysis is approximate not all calls that can arise at run time are reported and not all calls that are reported can be executed at run time.
for realistic systems this notion of approximation is pervasive.
few if any static analysis tools for widely used programming languages report all possible calls common stumbling blocks include eventbased invocation calls through the re ection interface calls made based on xml descriptions that link middleware layers calls that arise through external libraries that are hard to analyze etc.
even if provided with a genuinely sound static analysis the categorization of pairs would remain stable.
the soundness of the analysis would ensure that partitions d d and d would be empty.
any pairs that another static analysis would have missed would shift into the corresponding partitions sd sd andsd which appear in the same category asd d andd respectively.
dynamic analysis.
our prototype dynamic graph is generated using a custom tracer written using aspectj.2the tracer maintains a call stack as the system executes and creates a method call relation at every call site as the program executes.
the tracer is not applied to any call within an external library this means that edges to a library e.g.
mymethod !hashset.
add .. are traced and this may result in another call edge e.g.
hashset.add .. !localtype.equals .. even ifadd .. does not call equals .. directly from the developer s point of view these alternatives are equivalent.
the dynamic traces are generally collected by running a test suite the developer could use our approach to compare the execution of a single test the system s entire test suite or any arbitrary execution of the system.
reconciling analyses.
matching elements between analyses is done by comparing the signatures of the caller and the callee for each method call.
for like analyses this is straightforward between static and dynamic we perform some straightforward signature ma1 swevo jayfx to ensure the signatures align correctly.
reconciling the analyses and constructing the partitions is linear in the size of the program being analyzed consisting mainly of simple set di erencing .
our current signature matching approach is brittle with respect to type hierarchies.
for example jayfx might extract a call to new vector collection whereas dynamically our dynamic tracer could detect this as new vector arraylist .
while this misregistration would cause some calls to appear in the wrong partitions e.g.
in this case one call in sand one call in d instead of one call in sd we have not yet xed this problem because these three partitions are still in the same unchanged category.
.
evaluation our evaluation has two parts.
first we applied our approach to three existing open source software systems to see how our approach partitioned behavioural changes.
second we ran our prototype tool on an industrial code base for one complete development sprint as a basis for an industrial perspective on our approach.
.
retrospective evaluation we retrospectively applied our approach pairwise to ten consecutive versions of three existing systems.
the intent of this evaluation was to see if the partitions of interest were small enough to allow developers to reasonably study the actual dependencies and to qualitatively examine the dependencies to see if they were useful and non obvious.
in this study we focused on a per commit granularity.
in the next section we instead consider end of day versions.
each of the three systems we used had open repositories and some form of a test suite.
the open repository requirement allowed us access to past versions at per commit granularity.
the test suite requirement allowed us to observe dynamic calls without constructing potentially biased tests of our own.
the three systems we evaluated were the google visualization data source library jodatime and the google rfc library.3table provides basic information about the most recent version of each system we analyzed.
project kloc tests last version visualization jodatime rfc table evaluation systems indicating their size number of tests and the nal version we used in our analysis.
.
.
methodology we selected the most recent change sets from each project s source repository that involved committing a modication to a source code le a few changes to documentationonly les were ignored.
to analyze the e ects of each commit we compared all consecutive pairs of versions for each of the systems that is we considered changes across three ten of these changes involved xing a bug and updating a test three involved adding a feature and updating a test two involved xing a bug without a test three involved adding a feature without a test two changed source code documentation and the rest were simple refactorings or code cleanups.
we extracted the static dependence graph from each version and collected the dynamic dependence graph by running each project s entire test suite using the tools described in section .
the external environment libraries and runtime environment for every version of the same system was held constant.
the unlikely partitions were always empty as expected and thus we do not discuss them further .
.
.
quantitative results key results for the pairwise evaluation are in table which shows the number of dependencies in key partitions.
the table has three horizontal sections arranged by project the rst column of each project s section indicates the checkin identi er for each associated commit.
for each of these projects the table has ve vertical sections the rst describes the number of edges in the graphs captured by the four analyses.
each category described previously is displayed in the next four vertical sections.
the sections are ordered in terms of their potential interest to the developer.
theinconsistent partitions were non empty for of the pairs of versions we investigated.
in total we identi ed unexpected behavioural changes an average of .
unforeseen dependencies per program version for a developer to investigate.
theconsistent partitions were non empty for of the pairs of versions.
in total method calls were identied as being consistent between the static change and their runtime behaviour.
the not executed partitions were nonempty for of the pairs of versions.
in total method calls were added or removed but not executed at runtime.
even if the developer were to consider all of the elements in the inconsistent consistent and not expected partitions they would only have to examine an average of calls per commit.
we do not expect that developers would often if ever examine all of these dependencies in practice.
small sets of dependencies.
by providing developers a means for focusing only on the behavioural e ects of their current change we are able to greatly reduce the number of elements they might otherwise have to consider.
for the pairs of program versions we analyzed the unchanged partitions representing those elements not a ected by the current change aggregated a total of dependencies whereas the inconsistent consistent and not executed partitions contained only dependencies and respectively a .
reduction.
the distribution of these aggregated totals is shown in figure .
the minimum reduction for any individual program run we analyzed was .
and the average reduction was .
.
from the programmers point of view this means that the number of dependencies that our approach suggests they look at is manageable in practice.
4for simplicity we only include counts of edges dependencies between pairs of program elements and omit counts of the program elements themselves.edgesedgesedgesedgesinconsistentinconsistentinconsistentinconsistentconsistentconsistentnot executednot executedunchangedunchangedunchangedv1sv2sv1dv2dd d sd sd s d s d s s sdsdvisualizer17 30rfc 22jodatime1366 141table quantitative results demonstrating the sizes of each of the partitions for the pairs of program versions we analyzed.
compared to a static or dynamic only approach.
to provide a quantitative sense of the di erence between our approach with a purely static or purely dynamic approach we performed a comparison using the data from table .
the static call graphs resulted in pairs in s and in s while our approach only returned pairs for these partitions in s and in s a reduction.
the dynamic call graphs resulted in pairs in d and in d in contrast our approach only returned pairs for these partitions in d and in d a reduction in the number of elements the developer would have to consider.
the majority of the reduction comes from elements being split between d ands d and the splitting ofs ands d by our approach.
.
.
qualitative results the quantitative analysis argues that our approach e ectively identi es small sets of incongruous dependencies in practice however the numbers tell only one part of the story.
our approach attempts to provide pertinent information to the developer about the source behaviour relation as they make changes to their source code.
by identifying speci cdependencies in each partition locating the source code associated with each dependence is straightforward enabling the developer to quickly determine if an element is indeed interesting.
the kinds of insight a developer would consider interesting depends on their role and the nature of their change.
in this section we examine key partitions from our experiment describing pertinent examples from these systems.
inconsistent partitions.
partitions d andd represent a kind of information that is both di cult to identify through static code inspections and problematic while debugging a system.
in visualizer v22!v23 a call from an external library ordering.
givenorder list into the developer s code aggregationcolumn.equals object disappeared.
through static inspection the developer cannot tell that the call from the external givenorder .. to their equals .. method isn t happening anymore.
additionally as givenorder .. and the developer s equals .. method are not obviously related it is more likely that they could inadvertently make a change that would cause this edge to disappear for instancev2dv1dv1sv2sdd s s d sdsd sds s d sd counts31591221765868 019figure aggregate totals for each partition from the pairs of program versions in our analysis.
by removing the equals .. method because it does not seem to be needed .
edges appear in d for the opposite reasons of d that is when statically opaque calls are added to the system.
one common cause of these edges is when a new test is added to the system for example in jodatime v1366!v1367 three new test methods are added to an existing class junit uses re ection to identify these methods and executes them at runtime while these edges are not statically obvious they clearly e ect the system s behaviour.
in another jodatime change v1379!v1380 an unexpected call from localdate.plusdays int toprecisedurationfield.add long int is reported.
looking at the code precisedurationfield is one of subtypes of durationfield and is two levels down the type hierarchy.
by highlighting this previously non existent and statically opaque element the developer can decide if this call was intentional.
consistent and not executed partitions.
from a test manager s point of view s represents additions not exercised by the test suite.
using v2dto differentiate s from s d enables the developer to quickly ensure that the dependencies they added to their system are exercised as they intended.
for example in jodatime v1366!v1367 the programmer added a new feature and corresponding test cases the s d edges are unlikely to be surprising as the programmer would expect the new code to execute but the one s edge a call to assert.fail could be unexpected.
this dependency appears in s because one of the tests throws an exception that causes the program exit before reaching the expected method call.
in general we do not expect developers will consider the results contained in the consistent partitions except when they are numerically anomalous compared to other partitions they are investigating.
in summary each inconsistent behaviour surfaced by our approach was non obvious by manual inspection of the source code alone.
while each of them could have been identi ed by inspecting the program with a debugger at exactly the right statement in the program they would not have been easily otherwise isolated.
.
.
non code and environmental changes changes to dependencies such as external libraries cancause subtle changes in the behaviour of a system as a consequence systems often ship with outdated versions of libraries as a way to reduce risk.
our approach can be used in situations where the developer wishes to compare how their system behaves with non code changes applied.
to test this idea we executed jodatime v1367 on jdk and jdk .
our tool reported interesting and related dependencies in partitions sd andsd .
speci cally.
in jdk an exception is thrown via re ection when jodatime tries to call a method that does not exist the sd represents the re ective method working in jdk while the sd captures the alternate call jodatime made to compensate for the re ective method s absence in jdk .
.
industrial code base study we also applied our tool to an industrial code base comprising of approximately kncsl5that provide a widelyused online marketing platform.
this code base is under active development using an agile methodology that delivers milestone builds after every three week development sprint.
our objective was to gain insight into how an industrial developer would consider applying the information provided by our approach.
we applied our approach to one sprint lasting july to july during this time change sets were committed to the repository.
we computed the behavioural differences at the end of each day to correspond to execution of their nightly test suite.
the code base involves dozens of external libraries and employs many di erent development techniques including mock objects aspects and a large amount of parallelization we had to make some improvements to our tools section to e ciently accommodate some of these techniques.
table shows the scale of the partitions over this time period less interesting columns have been elided .
as with the the open source systems in section .
more than of elements are in partitions s d and sd since our industrial developer was only investigating the impact of a speci c change he never sought out the information from these partitions.
table also shows that the consistent andnot executed partitions are the most heavily populated while the inconsistent partitions remain at a manageable scale.
our participant is a development manager with more than years of industrial development experience.
while he frequently commits changes to the system his primary role is to oversee the project and development team.
to present the data to him we created a web page for each of the analyzed revisions each page consisted of a tabular overview of the partitions and a speci c listing of the changes.
when investigating change !
table row he noted oh that s interesting we have been creating a new implementation of this code but it s all in the s partitions.
if we wanted to do this right and have con dence in the new code we should be creating tests here.
while considering how the approach could provide data to his team in the future he said that right now upgrading our libraries is an ad hoc operation where we just try things out and hope they work could give us one more data point to help us consider whether a new component behaves as the old one did.
and in terms of code reviews he said i think that the partitioned information would be helpful especially in the context of a single known change and 5thousands of non comment source linesinconsistentinconsistentinconsistentinconsistentconsistentconsistentnot executednot executedunchangedunchangedunchangedd d sd sd s d s d s s sdsd15477 .
.
.
.
.
.
.
.
.
.
.
.
.25812721avg .
.2581235980491min .44767table study results over week code sprint.
a code review.
an encouraging outcome of this study was that the development manager felt there was enough value to the data we generated that they requested we integrate our approach with their nightly build routine so his team can continue to use this data in the future.
.
threats to validity the main threat to the external validity of our ndings is our use of a small set of systems over a limited sequence of versions.
one commonality of the four systems we evaluated was their investment in unit testing it is unclear how our approach would fare without a reliable way of executing the target system.
a conspicuous risk to the construct validity of our qualitative evaluation is our reliance on our own experience and judgment as programmers and researchers to interpret the whether an inconsistent dependency could be easily identi ed statically.
the projects we investigated retrospectively were at different points in their development lifecycle.
jodatime is a mature project as can be seen by the very few code deletions s ands d as well as comparatively more elements in the consistent partitions than the not executed partitions due to its high level of testing .
conversely rfc is a project undergoing active development with many additions and deletions.
the visualizer is also fairly stable as evidenced by their lack of code churn.
these distinctions may be material in ways our evaluation did not identify.
a less serious threat to the construct validity of our evaluation is the use of the two analyzers jayfx and our own aspectj tracer to produce dependence graphs.
our tracer is straightforward unconcerned at present with performance and we doubt that another dynamic tracer would give signi cantly di erent results.
it is clear that a di erent static analyzer would surely reshape our partitions to some degree.
for instance a more precise static analysis approach would decrease the size of d d and d indeed removing unexecutable dependencies is the core objective of increasing the precision of static analyses.
similarly a less conservative analysis could decrease the size of s. we speculate but have not con rmed that these di erences in precision would change the partition but not the category in whicheach dependency is placed.
the reason for this speculation is that the more precise static analysis would likely capture the same dependencies in both versions and most of these would be cancelled out by the di erencing approach.
in any case our tool does not require a speci c static or dynamic analysis to generate the four call graphs.
further research is needed to determine the degree to which the analysis matters in practice.
.
related work software changes.
literature arguing that changes to behaviours are especially daunting includes brooks observation that defects tend to arise from changes that have nonobvious system wide rami cations ko et al.
s evidence that feedback about the delity of their changes proved to be the developers most sought piece of information and sillito et al.
s study documenting that developers are keenly interested in the impact of their changes .
by providing developers feedback as they modify their system we aim to help them identify dependencies that are otherwise di cult to isolate and that are likely to help build con dence in their understanding of these questions.
unintended consequences of changes to programs are widely documented.
since the risks digest has documented thousands of computer related risks to the public 6many of these with e ects from trivial to catastrophic have been traced to unintended consequences of changes to programs.
the observation that xing errors is itself an erroneous process often called imperfect debugging has been modelled as part of software reliability engineering since the mid1970 s .
belady and lehman have argued empirically that program change is inevitable in part because the needs of users evolve.
their law of increasing complexity asserts that as programs change they become increasingly less structured unless such entropy is consciously counteracted .
repeated behavioural changes alongside structural degradation naturally lead to a progressively opaque relationship between the static and the dynamic structures.
exceptions in logical structural di erencing identify static changes that may have not been made consistently and completely.
a study of refactoring argues that in practice some urries of refactorings lead to an increase in bugs while other urries do not .
not all program changes cause problems.
purushothaman perry based on an extensive study of a major commercial system have shown that about of changes altered a single line of code and of these about resulted in additional faults.
they also showed that approximately of all changes resulted in additional faults.
although rarely observed in the literature these data mean that at least in this study roughly of all changes and of one line changes improve or at least do not harm to the program.
nonetheless few if any would argue that programmers make changes with absolute certainty about their possible consequences when the program is executed.
our approach like all other approaches does not and never will lead to a situation in which programmers can attain such certainty.
rather our approach is meant to provide one way among many in which programmers can increase their con dence that a change improves a program in intended ways.
analysis.
another very broad area of related work is impact analysis which is generally concerned with identifying possible consequences of program changes .
a number of impact analysis approaches can be contrasted to our approach based on our partitions.
one common approach to impact analysis for regression testing relies on comparing two static dependence graphs most techniques select tests based on information about the code of the program and the modi ed version .
a classic example is safe regression test algorithms that eliminate all tests from an original program s test suite that cannot under speci ed conditions expose a fault in the modi ed program rothermel harrold have analyzed many variants and a meta analysis of empirical results is available as well .
another example is test prioritization which orders a test suite to increase the likelihood that newly introduced paths in the modi ed program are tested before unchanged paths.
an example is echelon which exploits binary di erencing of versions to identify paths and tests to exercise.
we believe that our technique augments existing regression testing approaches by recording more behavioural data that can be further analyzed in the future regardless of whether an explicit assertion in a regression test failed.
person et al.
apply di erential symbolic execution to characterize the behavioural aspects of a code change more precisely than traditional di based mechanisms .
while the focus of their work is proving whether a change a ected the behaviour of a system our approach focuses on partitioning and implicitly ranking behavioural changes albeit with less precision in a lightweight way that developers can easily reason about.
any analysis based on comparing static dependence graphs across two versions can distinguish precisely three combinations of partitions those with a label including s that is s sd sd andsd as well as those with a label including s and those including s .
regardless of the kind of static dependence graphs that are extracted and regardless of the algorithm used to compare the two static call graphs other distinctions cannot be made for example a dynamic dependence that appears or disappears cannot be determined using this approach.
another collection of impact analysis approaches execute two distinct test suites across a single program.
software reconnaissance uses this approach to identify parts of a program that implement a particular feature the feature is exercised by the rst test suite but not the second .
eisenberg and de volder have extended this approach to relax the explicit requirement of exhibiting and non exhibiting test suites .
reps et al.
used a similar approach to identify programs that might be susceptible to problems such as y2k.
the tripoli system can be used to compare two arbitrary executions of a system and determine their coverage di erences assuming that the source code remains unchanged.
this class of approaches based on two dynamic graphs and one static graph can exploit up to eight partitions.
some distinctions available in our approach however cannot be made using these partitions.
as an example s cannot be distinguished from s as only one static dependence graph is present.
the degree to which this matters is empirical if distinctions like this one arise in practice and represent useful information for the programmer then our approach can provide additional information over theseapproaches.
in addition while traditional coverage metrics would report the same coverage percentage if one statement was removed and another added to the same method our approach would capture both of these changes for the developer to consider.
ren chesley and ryder present an approach to help perform root cause analysis rca to identify the change that caused a test case to fail .
the ava technique further extends rca to include rationale that can di erentiate between successful and passing tests to di erentiate passing behaviour from failing behaviour.
our approach aims to detect behavioural changes whether the test suite succeeds or fails but does not try to determine the root cause of any behavioural change.
raghavan et al.
s dex tool extracts a variety of metrics about c patches using syntactic and semantic di erencing in contrast to our approach dex enables defect classi cation to enhance test prioritization .
one form of impact analysis that is incomparable using our partitioning is that based on historical information .
these approaches generally look for patterns in source code repositories that likely represent co dependences among for instance checked in les a programmer could be alerted upon attempting to commit a set of les that omit a resource that has usually been edited and checked in alongside those les.
these approaches are complementary exploiting historical information not directly related to the sourcebehaviour relation.
several previous approaches have used mixed analysis using both static and dynamic dependence analysis in concert.
they generally and very reasonably apply static and dynamic dependences to distinct parts of the problem exploiting the strengths and weaknesses of each style of analysis.
for example chen et al.
perform selective retesting of a system by using static analysis to determine which parts of a system changed and then comparing this to dynamicallyderived coverage data.
rohatgi et al.
perform a software reconnaissance like approach to extract features by comparing dynamic traces following up by ordering the returned components based on their static relationships to one another.
in contrast our approach treats and manipulates the static and dynamic dependence graphs as peers instead leveraging them by labelling speci c partitions in terms of the underlying program source and its behaviour.
.
conclusion software derives enormous power from its malleability.
experience shows that this power is often harder to harness in practice than in theory.
one particular way in which this exibility is often compromised arises when the behaviours of the executable program are hard to understand from the program s source.
even when this association is clear in a program s initial design and implementation this relationship tends to becoming increasingly opaque as successive changes are made to the system.
we have presented an approach intended to concisely identify speci c dependencies that suggest to programmers when a program change and the subsequent program behaviours may be less consistent than they may have intended.
the approach relies on existing techniques and tools to extract static and dynamic dependence graphs from pairs of versions along with set based manipulations that partition these dependencies based on their absence or presence in the four graphs.
we have argued theoretically that this partitioningprovides an opportunity for ner grained and more concise results than classes of existing approaches and we have argued empirically that the partitioning identi es a small set of apparently useful dependencies that can be di cult to succinctly identify using current analysis approaches.