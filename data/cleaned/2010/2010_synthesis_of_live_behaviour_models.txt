synthesisof live behaviour models nicol s d ippolito victor braberman nir piterman sebasti n uchitel imperial college london london united kingdom npiterma su2 imperial.ac.uk universidad debuenos aires buenos aires argentina ndippolito vbraber dc.uba.ar abstract we present a novel technique for synthesising behaviour models that works for an expressive subset of liveness properties and conforms to the foundational requirements engineering world machine model dealing explicitly with as sumptions on environment behaviour and distinguishing con trolled and monitored actions.
this is the first technique that conforms to what is considered best practice in requirements specifications distinguishing prescriptive a nd descriptive assertions.
most previous attempts at using sy nthesis of behavioural models were restricted to handling on ly safety properties.
those that did support liveness were inadequate for synthesis of operational event based models as they did not include the bespoke distinction between system goals and environment assumptions.
categories andsubject descriptors d. general terms design algorithms keywords controller synthesis behavioural modelling .
introduction automated construction of event based operational models of intended system behaviour has been extensively studied in the software engineering community for some time.
synthesis of such models from scenario based specification s e.g.
allows integrating a fragmented examplebased specification into a model which can be analysed via this work was partially supported grants pict pae erc pbm fimbse ubacyt x021 conicet and pip112 .
np is supported by grant uk epsrc ep e028985 permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
fse november santa fe new mexico usa.
copyright acm ... .
.model checking simulation animation and inspection the latter aided by automated slicing and abstraction techniqu es.
synthesis from formal declarative specification e.g.
temp oral logics has also been studied with the aim of providing an operational model on which to further support requirements elicitation and analysis.
behaviour model synthesis is also used to automatically construct plans that are then straightforwardly enacted by some software component.
for instance synthesis of glue code and component adaptors has been studied in order to achieve safe composition at the architecture level and in particular in service oriented architectures .
more r ecently there has been an increasing interest in self adapt ive systems which must be capable of designing at runtime adaptation strategies.
consequently such systems re ly heavily on automated synthesis of behaviour models that will guarantee the satisfaction of requirements under the constraints enforced by the environment and the capabilities offered by the self adaptive system.
a limitation that existing behaviour model synthesis techniques have is that they are restricted to safety properties and do not support liveness.
hence synthesis can be posed as a backward error propagation variant where a behaviour model is pruned by disabling controllable actions that can lead to undesirable states.
in many domains and particularly in the realm of reactive systems liveness requirements can be of importance an d having synthesis techniques capable of dealing with them is desirable.
however very few approaches to behaviour model synthesis that support liveness have been proposed notably which have been applied in self adaptive systems.
the problem with these approaches is that the distinction between controlled and monitored actions and between descriptive and prescriptive behaviour is not made explicit.
as a consequence the behaviour models they synthesise in order to enact self adaptation may not b e realisable by the self adaptive system or unexpected resul ts may be obtained when the self adaptive system interacts with its environment due to non valid assumptions that were not made explicit.
making assumptions explicit is crucial and even more so with liveness system goals.
jackson and others e.g.
have argued the importance of distinguishing between descriptive and prescriptive assertions between so ftware requirements system goals and environment assumptions and the key role that the latter play in the validation process.
when dealing with liveness assumptions play an even more prominent role typically reasoning aboutliveness in behaviour models is performed under specific assumptions which correspond to liveness properties themselves.
for instance it is common to reason under some general notion of fairness or some domain specific property regarding the responsiveness of the environment to certain stimuli.
given the central role that liveness assumptions have for reasoning about liveness requirements the use of approaches to synthesis that leave such assumptions implicit and do not allow for user tailored liveness assumptions entails some important risks and limitations for user s. in this paper we propose a technique for synthesising behaviour models that works for an expressive subset of liveness properties that distinguishes between controlled an d monitored actions and differentiates between system goals and environment assumptions.
the technique adapts and extends recent advances in synthesis of controllers fo r discrete event systems .
more specifically we adapt the controller synthesis technique gr to work in the context of event based specifications using lts semantics parallel composition and to support safety properties as part of the specification.
the synthesis procedure given a descriptive specification of t he environment in the form of an lts and a set of controllable actions constructs a behaviour model that when composed with the environment satisfies a given fltl formula of the form bci vn i bc bdai vm j bc bdgj where bciis a safety system goal bc bdairepresents a liveness assumption on the behaviour of the environment bc bdgj models a liveness goal for the system and aiandgjare non temporal fluent expressions while iis a system safety goal expressed as a fluent linear temporal logic formula .
technical contributions of this paper include i the presentation of the event based control problem which gives a high level description of a certain kind of controller synth esis problems which aims to work under a theoretical framework adequate for event based models ii the grounding of the event based control problem for labelled transitions systems and parallel composition in the definition of the lts control problem iii the definition of a restricted lts control problem named sgr lts that supports safety and gr like properties iv the restrictions that an eventbased setting requires in order to guarantee correctness of the synthesis procedure and to avoid anomalous controllers .
interestingly and perhaps not surprisingly the restrict ions to achieve the latter correspond to following the methodolo gical and theoretical guidelines dictated by the goal orien ted requirements engineering approach .
this paper is organised as follows.
in section we present our running example and provide an overview of the approach from a black box perspective.
we provide the necessary background in section to then present the lts control problems in section where we also discuss anomalous controllers and links to the notion of realisability in requ irements engineering.
we show how sgr lts control can be solved in section .
we finish with a short description of a case study discussion related work and conclusions.
due to lack of space proofs are omitted.
.
overview in this section we provide a black box overview of our approach.
technical details are provided in the next sections .
3put.drill drill.process get.drill figure drill.
consider the following variation of the production cell case study a factory manufactures several kinds of products each of which requires a production process which involves different tools applied in a specified order.
the fac tory production system is expected to adapt its production process depending on a number of factors such as the available tools which is subject to change when a tool breaks or a new instance of an existing tool type is introduced for example the specification of how to process each product type which can change because the production requirements for a product type changes and other constraints for example an energy consumption requirements that constrains th e concurrent use of certain tools .
given its potential for co ncurrent processing the production should be scheduled in such a way that no product type is indefinitely postponed.
in addition to the tools the factory has an in tray an out tray and a robot arm.
the robot arm is used to move products to and from tools and trays.
raw products arrive on the in tray the robot arm must process them according to their specification and place the finished products on the out tray.
the trays can hold products of any kind simultaneously.
to simplify the presentation assume that the factory must produce two types of products namely aandb with three different tools an oven a drill and a press.
products of typearequire using the oven then the drill and finally the press while products of type bare processed in the following order drill press oven.
in addition there is a constrain t on concurrent use of tools the drill and the press cannot be used simultaneously.
finally a liveness condition on th e production of products of type aandbis also required that is the production of one kind of product cannot postpone indefinitely the production of products of the other kind.
we now describe how these requirements can be specified in our approach and comment on the production strategy automatically generated by our controller synthesis algorit hm.
the environment model is the result of the parallel composition of ltss modelling the robot arm the tools and the products being processed.
in figure we show the behaviour model for the drill tool any product i.e.
idfrom tomax can be putinto the drill tool by the robot arm put.drill and subsequently that product is processed drill.process by the drill and can then be taken from the drill by the robot arm get.drill .
in figure we show a model that describes how raw products can be processed.
a product is idleuntil it appears in the in tray .intray then it is picked up by the robot arm .getintray subsequently it can be freely placed and picked up from any tool resp.
put.
and get.
until the product processing is finished and the product is placed in the out tray .putouttray .
for simplicity we model that an instance of a product can be reprocessed hence once put on the out tray the product12 .intray .getintray idle .putouttrayput.
get.
figure products.
.getintray .putouttrayput.
get.
figure robot arm.
model is at the initial state again.
note that idrepresents a particular product and tools the available tool set.
we do not include in the models of the products the requirements related to the order in which tools must be applied.
this is because as proposed in we avoid mixing the description of how the environment behaves with the prescription stating how the environment should behave once the controller is in place.
the model describing the robot arm figure shows how the arm can pickup any product from any position in tray out tray and tools and then place that same product in another position.
it can only hold one product at a time.
to simplify we assume that the in and out trays are repositories of unbounded size and that the in tray does not enforce an ordering of products.
the environment model can be built as the parallel composition of a model for each tool a model for the robot arm and a model for each product product a ... product a product b ... product b drill oven press arm .
the lts for this composition is too big to be shown it can be constructed using the modified mtsa tool and data available at .
what remains now is to define the set of actions that the controller to be can control and the specification that it must satisfy when it is composed with the environment.
the controlled actions must be a subset of the actions of the environment model and we define them to be the actions of the robot arm.
in other words we aim to build a controller that restricts the behaviour of the arm so that the way the arm moves the products satisfies the production requirements.
the system specification consists of a safety and a liveness part.
the safety part is twofold.
on one hand the order in which tools will process raw products is encoded with a model describing the expected processing order for each type of products.
in figure we show how to model the processing requirements for products of type a a temporal logic representation of such requirement is also possible and can be constructed automatically from figure but more cumbersome.
we omit it here but assume that captures the requirements for products of type aandb.
on the other hand the drill and press cannot be used simultaneously.
this can be easily encoded with the following temporal logic property bc x y products processing drill x processing press y where bcmeans always in the future and processing t p is a predicatewhich is true when tool tis processing product p. thus the safety goal for the system is i .
the liveness part of the system specification must capture the requirement of not indefinitely postponing the production of any product type.
such requirement can be formalised in temporal logic as follows g v type a b bc bd wmax id 0addedtoouttray type id where addedtoouttray t i is true if the product has just been added to the out tray.
if we attempt to build a controller for the arm such that it guarantees bci bc bdgwhen composed with the model of the environment our approach will indicate that such controller is not possible.
this is true as there is no guarante e of producing an infinite number of products of type aand of typebif the environment does not guarantee that it will provide the raw products to be processed.
consequently we must assume that the environment will produce an infinite number of raw products of type aandb as v type a b id max bc bdaddedtointray type id where given a product with id equal to iand of type t addedtointray t i is true if the product has just been added to the in tray.
if we attempt to build a controller that guarantees i as gour approach successfully builds one.
in other words we will obtain a controller that guarantees when composed with its environment that the products are processed by applying tools in the correct order that the drill and press are not used simultaneously and that if the environment provides infinitely many raw products of both types as both types of products will be produced g .
it is interesting to note that a controller for the robot arm that satisfies the specification above when composed with the model of the environment cannot be produced by simply pruning the environment model as controller synthesis tec hniques for safety properties do .
this is because in order t o fulfill the liveness part of the specification a controller m ust remember if it has been postponing one type of product for too long.
say products of type ahave been postponed for too long the controller must stop processing the other component type b giving way to the production of aproducts.
how much the controller waits before switching type could vary from one controller to another but all controllers mus t have some sort of memory in order to achieve the liveness condition.
this memory is not encoded in the state space of the environment and hence a controller cannot be achieved through its pruning.
in section we describe the procedure of synthesising controllers that satisfy the specification described above an d hence capable of among other things identifying the controller s need for memorising specific aspects of the system behaviour in order to satisfy liveness properties.
.
background we use labelled transition systems as defined below.
.intray .getintray put.oven put.drill put.press put.outtray figure specification for products of type a.definition .
.
labelled transition systems alabelled transition system lts isp s l s0 wheres is a finite set of states l actis itscommunicating alphabet s l s is a transition relation and s0 s is the initial state.
we denote s s s a s andtraces p the set of traces t s l s l ofp.
we say an lts is deterministic if s l s and s l s are in impliess s .
the following definition is based on that of interface automata andlegal environment presented in .
definition .
.
legal environment givenm sm lm m sm0 andp sp lp p sp0 ltss where lm lmc lmu lmc lmu lp lpc lpuandlpc lpu .
we say that mis a legal environment for pif the interface automaton m a bracketle tsm sm0 lmu lmc m a bracketri ht is alegal environment for the interface automaton p a bracketle tsp sp0 lpu lpc p a bracketri ht.
we describe specifications i.e.
goals using fluent linear temporal logic fltl .
linear temporal logics ltl are widely used to describe behaviour requirements .
the motivation for choosing an ltl of fluents is that it provides a uniform framework for specifying state based temporal properties in event based models .
fltl is a linear time temporal logic for reasoning about fluents.
a fluent fl is defined by a set of initiating actions ifl a set of terminating actions tfl and an initial value initially fl.
that is fl a bracketle tifl tfl a bracketri htinitiallyfl whereifl tfl actandifl tfl .
when we omit initially fl we assume the fluent is initially false.
we use fllas short for the fluent defined as fl a bracketle tl act l a bracketri ht.
given the set of fluents an fltl formula is defined inductively using the standard boolean connectives and temporal operators x next u strong until as follows fl x u where fl .
as usual we introduce bd eventually and bc always as syntactic sugar.
let be the set of infinite traces over act.
for we write ifor the suffix of starting at ai.
the suffix i satisfies a fluent fl denoted i fl if and only if one of the following conditions holds initiallyfl j j i aj tfl j j i aj if k n j k i ak tfl from the fltl definition it follows that many results for ltl can be easily extended to fltl.
definition .
.
two player game atwo player game game isg sg sg0 wheresgis a finite set of states sg sgare transition relations sg0 sgis the initial state and s gis a winning condition.
we denote sg s g sg s g and similarly for .
a statesgisuncontrollable if sg e atio slash andcontrollableotherwise.
a playongis a sequence p sg0 sg1 .... a playpending insgnis extended by the controller choosing a subset sgn .
then the environment chooses a statesgn sgn and addssgn 1top.
astrategy with memory for the controller is a pair of functions u where sg 2sgsuch that s g sg andu sg such that is some memory domain with a designated start value 0. intuitively tells controller which states to enable as possible successors and utells controller how to update her memory.if is finite we say that the strategy uses finite memory.
a finite or infinite play p sg0 sg1 ...isconsistent with u if for every nwe havesgn n sgn sgn where i u i sgi for alli .
a strategy u for controller is winning if every maximal play consistent with u is infinite and in .
we say that controller wins the gamegif it has a winning strategy.
we refer to checking whether controller wins a game gas solving the gameg.
the controller synthesis problem is to produce a winning strategy for controller.
it is well known that if controller wins a game gand is regular she can win using a finite memory strategy .
we now define the class of winning conditions that is of our interest.
definition .
.
generalised reactivity given an infinite sequence of states p letinf p denote the states that occur infinitely often in p. let 1 ... nand 1 ... mbe subsets ofs.
letgr 1 ... n 1 ... m denote the set of infinite sequences psuch that either for some iwe haveinf p i or for alljwe haveinf p j e atio slash .
a gr game is a game where the winning condition is gr 1 ... n 1 ... m .
.
event based controlsynthesis .
control problems we now present a high level description of an event based control problem following the world machine model .
we distinguish between software requirements system goals a nd environment assumptions.
we then define the lts control problem which grounds the event based control problem by fixing a specific formal specification framework labelled transition systems and the linear temporal logic of fluents.
finally given the computational complexity of the general lts control problem we define sgr lts control a restricted lts control problem for expressive subse t of temporal properties that includes liveness and allows fo r a polynomial solution.
in the next section we show how such polynomial solution can be achieved.
the problem of control synthesis is to automatically produce a controller that restricts the events it controls.
whe n deployed in a suitable environment such a controller will ensure the satisfaction of a given set of system goals.
satisfaction of these goals depends on the satisfaction of prescriptive assumptions by the environment.
in other words we are given a specification of an environment assumptions system goals and a set of controllable actions.
a solution f or theevent based control problem is to find a machine whose concurrent behaviour with an environment that satisfies the assumptions satisfies the goals.
we adopt labelled transition systems lts and parallel composition in the style of csp as the formal basis for modelling the environment and the controller to be synthesised and fltl with its corresponding satisfiability noti on as a declarative specification language to describe both environment assumptions and system goals.
we ground the problem of control synthesis in event based models as follows given an lts that describes the behaviour of the environment a set of controllable actions a set of fltl formulas as the environment assumptions and a set of fltl formulas as the system goals the lts control problem is to find an lts that only restricts the occurrenceof controllable actions and guarantees that the parallel co mposition between the environment and the lts is deadlock free and that if the environment assumptions are satisfied then the system goals will be satisfied too.
definition .
.
lts control given a specification for an environment in the form of an lts e a set of controllable actions ac and a set hof pairs asi gi where asiandgiare fltl formulas specifying assumptions and goals respectively the solution for the lts control proble m l a bracketle te h a c a bracketri htis to find an lts msuch thatmwith controlled actions acand uncontrolled acis a legal environment for e e mis deadlock free and for every pair asi gi hand for every trace inm ethe following holds if asithen gi.
the problem with using fltl as the specification language for assumptions and goals is that just like in traditional i.e.
state based controller synthesis the synth esis problem is 2exptime complete .
nevertheless restrictions on the form of the goal and assumptions specification have been studied and found to be solvable in polynomial time.
for example goal specifications consisting uniquely of safety requirements can be solved in polynomial time and so can particular styles of liveness properties such as a nd gr .
the latter can be seen as an extension of to a more expressive liveness fragment of ltl.
we now define the sgr control computable in polynomial time.
it builds on the gr and safety control problems but is set in the context of event based modelling.
we require the model of the environment eto be a deterministic lts and hto be i as g whereiis a safety invariant of the form bc the assumptions asare a conjunction of fltl sub formulas of the form bc bd the goal ga conjunction of fltl sub formulas of the form bc bd and and are boolean combinations of fluents.
definition .
.
sgr lts control an lts control problem l a bracketle te h a c a bracketri htis sgr if eis deterministic and h i as g wherei bc as vn i bc bd i g vm j bc bd j and i and jare boolean combinations of fluents.
consider the sgr lts control problem r a bracketle te h a c a bracketri ht whereeis the lts in figure a ac c1 c2 c3 c4 g1 g2 h i as g i bc flw as bc bdflaand g bc bdflg1 bc bdflg2.
recall that fllis a fluent that becomes true when loccurs and becomes fals when any other action occurs.
the ltsc1 c2andc3of figures b to d are some of the possible solutions to r c1 bardblehas no traces satisfying the assumptions as hence it is not obligated to satisfy g all traces in c2 bardblesatisfyasand alsog and traces in c3 bardble either do not satisfy asor satisfy both asandg.
we will discuss in the next subsection the differences between these solutions.
for now it is interesting to note that neither c2 norc3can be obtained only by pruning e. both models introduce new states which allow the controller to remember which is the next goal that must be acheived g1 org2 .
the automated construction of these memory states will be described in detail in section .
.
the sgr control problem restricts the form of the environment assumptions and system goals.
thus a valid concern is the impact of this restriction on expressiveness in2 5c3 c1 a g1 g2 l c3ac4c2 a w a 2c3l b 5c1ag1 ag2 c 6c3lc1ag1 ag2 d figure a environment model e b controller c1 c controller c2 d controller c3 practice.
a closer look at the family of liveness formulas reveals it is not arbitrary they are designed to capture a buchi acceptance condition.
more concretely any liveness property specifiable by a deterministic buchi automaton can be handled by the proposed approach.
the trick is basically to compose the buchi automaton structure with the original plant lts and then use assumptions and goals to express that their acceptance conditions will should respective ly be visited infinitely often.
typical responsiveness assump tions and goals e.g.
bc bd could be treated in this way .
an example of a responsiveness goal that does not fit the syntactic requirements of sgr but could be dealt with by means of this encoding is that if a product is waiting to be processed by the cell i.e.
it has been placed on the in tray and not yet picked up by the arm then it will eventually be put onto the out tray vmax id 0v type a b bc waitingforprocessing type id bdput.outtray type id where waitingforprocessing type id are fluents initiated by events .
.intray and terminated by events .
.getintray .
.
assumptions and anomalouscontrollers a valid concern is if there are semantic restrictions for what is called an assumption in a control problem.
in other words can any assertion be provided as an assumption?
or the fact that it is deemed assumption implies that it should have specific semantic properties?
this question can also be posed for the specific case of sgr lts control are further semantic restrictions needed to ensure that the formul a as vn i bc bd ican be interpreted as an assumption on the environment?
we now answer this question.
consider the lts controller c1discussed in the previous section.c1solves the sgr control problem rby simply ensuring that for all trace traces e bardblc1 e atio slash as.
such a solution from an engineering perspective is unsatisfact ory c1should play fair by trying to achieve gwhenasholds rather than trying to avoid as.
in this sense c2andc3 are more satisfactory.
the best effort controller definitionprovided below formalises this preference by requiring the following if the controller forces asnot to hold after a sequence no other controller that achieves gcould have allowedasafter .
definition .
.
best effort controller given an sgr lts control problem lwith assumptions asand an ltsmsuch thatmis a solution for l we say that m is abest effort controller forlif for all finite traces traces e bardblm if there is no where .
traces e bardblm and .
asthen there is no other solution m tolsuch that traces e bardblm and there exists such that .
traces e bardblm and .
as controllerc1is not a best effor controller as the empty trace ine bardblc1cannot be extended in e bardblc1to satisfyas yet it can be extended by c1 a g1 a g2 ine bardblc2such that .
satisfies bc bdas.
on the other hand given that there are no traces in e bardblc2violatingas c2is abest effort controller for r.c3is also a best effort controller as the only finite trace violating asinc3is c3 and there are no extension of satisfyingasandg.
note that controller c3also could be argued to be anomalous from an engineering perspective although c3does play fair when choosing action c1to state it can also choose actionc3to state taking e bardblc3to a state in which assumptions are no longer possible.
this can motivate a stronger criterion than best effort the controller should never prevent the environment from achieving its assumptions.
definition .
.
assumption preserving controller given an sgr lts control problem lwith assumptions as and an lts msuch thatmis a solution for l we say thatmis an assumption preserving controller forlif for all finite traces traces e bardblm if there is no where .
traces e bardblm and .
asthen there does not exist such that .
traces e and .
i as property .
.given an sgr lts control problem randman lts controller for r ifmis aassumption preserving controller then mis abest effort controller.
property .
and the fact that c1is not best effort it follows that c2is not an assumption preserving controller.
althoughc3is best effort it is not an assumptions preservingcontroller because the trace c3 c3 a c3 ine is a valid extension to c3 inc3 bardblewhich satisfies aswhile violating g. on the other hand given that every infinite trace in c2satisfies both asandg c2is an assumptions preserving controller.
note that the best effort criterion compares two controllers while assumption preserving compares the behavior of the controlled environment against the environment.
now given an sgr problem it is useful to know whether all solutions of an sgr lts control problem are assumption preserving or best effort.
interestingly a sufficie nt condition for this can be achieved by restricting the relati on between the assumptions asand the environment e. the essence of this relation is based on the notion of realisabil ity and the fact that the environment is the agent responsible for achieving the assumptions as introduced in .
the notion of realisability requires that an agent responsible for an assertion be capable of achieving it based on its controlled actions regardless of what happens with theactions is does not control.
in our setting this notion can be used to formalise a sufficient condition for guaranteeing assumption preserving and best effort controllers.
the condition requires the environment be capable of achievingasregardless any choice it may make and the behaviour of any controller that it might be composed with.
this is ensured by checking that for every state1inethere is no strategy for the controller to falsify as.
definition .
.
environment assumption compatibility given an sgr lts control problem l a bracketle te h a c a bracketri ht andh i as g we say that the asis compatible witheif for every state sinethere is no solution for the sgr lts control problem a bracketle tes h ac a bracketri htandh i as false whereesis the result of changing the initial state of etos.
hence when the assumptions of an sgr lts control problem are compatible with the environment it is guaranteed that anomalous controllers such as those that are not best effort and assumption preserving will not be produced.
property .
.given an sgr lts control problem l with assumptions asand environment e ifasis compatible withethen all solutions to lare best effort and assumption preserving.
note that the running example rviolates definition .
and hence has anomalous controllers such as c1 which is notbest effort norassumption preserving orc3which is best effort but not assumption preserving .
also note that the assumptions for the example in section are not compatible with the environment described in the same section.
this is because we modelled the environment so to reuse products once they have been processed.
in other words rather than modelling an infinite number of products to be processed which would lead to an infinite state environment we modelled that a product once it has been fully processed becomes available once again to be put as raw on the in tray.
as the assumptions requireaddedtointray t i infinitely often the environment needs the robot to cooperate by processing the products infinitely often.
hence the environment cannot guarantee the assumptions independently and a solution to the running example could be a robot that does absolutely nothing.
a more appropriate assumption which would guarantee nonanomalous controllers is one that states that the environment reacts to products being placed in the out tray by eventually placing them back on the in tray bc addedtoouttray t i bdaddedtointray t i .
such a formula can as mentioned previously and discussed in be encoded into our framework.
summarising the latter part of this section best effort and assumption preserving controllers explain technicall y the sort of anomalies that might arise if requirement engineering practices such as ensuring realisability of assu mptions by the environment are violated.
in the next section we present how to solve sgr lts problems.
the synthesis algorithm we implemented does not require environment assumption compatibility.
however as explained above such a condition is desirable.
1the adds no computational complexity to the control problem5.
solvingsgr control in this section we explain how a solution for the sgr control problem can be achieved by building on existing state based controller synthesis techniques namely gr .
the construction of the machine for an sgr lts control problem has two steps.
firstly a gr game gis created from the environment model e the assumptions as the goalsgand the set of controllable actions ac section .
.
secondly a solution u to the gr game is used to build a solution m i.e.
an lts controller for l section .
.
we also show that our approach is sound and complete.
that is a solution to the sgr lts control problem l exists if and only if a solution to the gr game gexists.
furthermore the lts controller mbuilt from u is a solution to l. the reader not interested details of the mapping of sgr into gr can skip directly to section .
where we comment on the implementation of the synthesis technique and show a controller for a reduced version of the production cell case study.
.
sgr lts control to gr games we convert the sgr lts control problem into a gr game.
given a sgr lts control problem l a bracketle te as g ac a bracketri htwe construct a gr game g sg sg0 g such that every state in sgencodes a state in eand a valuation of all fluents appearing in asandg.
more precisely consider an sgr lts control probleml a bracketle te as g a c a bracketri ht where e se l e se0 as vn i bc bd iandgis separated in g bc andvm j bc bd j. let fl fl1 ... flk be the set of fluents used inasandgandfli a bracketle tifli tfli a bracketri htinitiallyi.
the game g sg sg0 g is constructed as follows.
we buildsgfromesuch that states encode a state in eand truth values for all fluents in let sg se qk i true false .
consider a state sg se 1 ... k .
given fluent fli we say that sgsatisfies fliif iistrueandsg does not satisfy fliotherwise.
we generalise satisfaction to boolean combination of fluents in the natural way.
we build transition relations and using the following rules.
consider a state sg se 1 ... k .
ifsgdoes not satisfy i.e.
sgis unsafe we do not add successors to sg.
otherwise for every transition se l s e ewe include sg s e ... k in where is ifl ac is ifa acand iis iifl ifli tfli iistrue ifl ifliand iisfalseifl tfli.
the initial state sg0 is se0 initially ... initially k .
we build the winning condition g defined to be a set of infinite traces from asandgas follows we abuse notation and denote by ithe set of states sgsuch thatsgsatisfies the assumptions iand by ithe set of states sgsuch that sgsatisfies the goal i. let g s gbe the set of sequences that satisfy gr 1 ... n 1 ... m .
it follows that g sg sg0 g is a gr game.
it can be shown that if there is a solution to a sgr lts control problem then there is a winning strategy for a controller in the constructed gr game refer to proposition .
.
note that the safety part of the specification is not encoded as part of the wining condition gof the gr game rather it is encoded as a deadlock avoidance problem when constructing and .
consequently the winning condition we realise is bc vn i bc bd i vm j bc bd j flc32 fll fla flc23 fla4 flc1 flg14 flg25 fla flc4 flw flc3 a flc15 fla4 flg1 flg25 fla b figure a transition relations for the game gr b wining strategy for gr figure a shows the transition relations and for gr the game obtained by applying to rthe procedure described above.
transitions in and are marked as and respectively.
states are labelled with a state in the original lts model i.e.
model ein figure a and the set of fluents holding in the state of the lts model.
.
translating strategies to lts controllers we now show how to extract an lts controller from a winning strategy for the gr game that was obtained from the sgr lts control problem as shown in section .
.
intuitively the transformation is as follows given an sgr lts control problem l a bracketle te as g a c a bracketri ht the game g sg sg0 g obtained from land a winning strategy for g we buildm sm l m sm0 a solution tolby encoding in states of sma state ofsgand a state of the memory given by the winning strategy.
more precisely consider an sgr lts control problem l a bracketle te as g a c a bracketri ht.
lete se l e se0 fl fl1 ... flk the set of fluents appearing in andg sg sg0 g be the gr game constructed from eas above and let sg 2sgandu sg be a winning strategy ing.
we construct the machine m sm l m sm0 as follows.
to buildsm sg consider two states sg se 1 ... k ands g s e ... k .
we say that action lispossiblefromsgtos gif sg s g there is some action lsuch that se l s e eand for every fluent flieither l ifli tfliand i i l ifliand i true or l tfliand i false.
to build m sm l sm consider a transition sg s g .
by definition of there is an action l acsuch thatlis possible from sgtos g. ifs g m s g then for every action lsuch thatlis possible from sgtos gwe add m s g l u m s g s g to g. similarly consider a transition sg s g .
by definition of there is an action l acsuch thatlis possible from sgtos g. ifs g s g then for every action lsuch thatlis possible from sgtos g we add s g l u s g s g to g.the initial state of mis defined as sm0 0 sg0 where 0is the initial value for the memory domain .
this completes the definition of m. consider the game grand a strategy u that tries to fulfill the goals at the same time the environment fulfills its assumptions.
that is a strategy that satisfies bc bdfla bc bdflg1and bc bdflg1.
the only possible solution to such requirements is to have in u a cycle visiting fla flg1 and flg2 in some order.
a strategy satisfying this is shown in figure b .
note that some memory is needed to distinguish whether state flg1 or flg2 has to be visited after visiting fla .
finally in figure c we show the lts controller obtained by applying the conversion shown above to the strategy in figure b .
in proposition .
we show that if u is winning strategy for a gr game gconstructed from a to a sgr lts control problem l then the lts mconstructed as explained above is a solution to l. note that to prove this proposition environment e determinism is needed.
proposition .
.
completeness letlbe an sgr lts control problem and gbe a gr game constructed by applying the conversion shown in section .
to l. if mis a solution for the sgr problem lthen there exists a strategy u such that u is winning for gand the lts controller obtained by applying the translation shown i n section .
to u is equivalent to m. proposition .
.
soundness letlbe a sgr lts control problem and gbe a gr game constructed by applying the conversion shown in section .
to l be a transition relation and ube an update function.
if u is winning strategy for g andmis the lts obtained by applying the conversion shown in section .
then it holds that mis a solution for l. .
implementation the original algorithm for solving gr games manipulates sets of states using a symbolic representation in the form of bdds.
we implemented a rank based algorithm that is better suited for explicit state space representati on allowing for integration within the mtsa tool set .
to test our implementation we applied it to the case study presented in section .
the size of the environment model is over states the size of the synthesised controller i s above states and it takes 3s to compute the strategy.
since the size of the models is too big to be depicted in this paper we show the controller for a smaller version which has only one tool a drill and can only process one instance of each product type at a time.
the synthesised controller is shown in figure .
note the states introduced by the algorithm to remember the last product type processed in order to guarantee the system goals.
the controller waits for products of type ato be processed first see states and regardless of whether there are products of type b ready to be processed see state .
it then does the same for products of type b. .
related work our work builds on that of the controller synthesis community and particularly on the generalised reactivity synt hesis algorithm gr proposed in .
the community has largely focused on controllers for embedded systems and dig ital circuits hence adopting a shared memory model the0 a b .idle 2a .intray 9b .intray 1b .putouttrayb .idle 7b .intray 8a .getintray 3a .idle 4a .intray 5get.oven.b get.oven.b b .putouttray a .intraya .idle6 put.oven.b 17a .getintrayb .idle b .intray 19put.oven.a a .intraya .idle 10b .idle 11a .putouttray 12b .intray a b .idle 13b .intray 16a .intray a .putouttray a .idle 14a .intray 15b .getintray b .getintray put.oven.b a .intraya .idleb .intrayb .idle18put.oven.a get.oven.a get.oven.a b .intrayb .idle figure controller for reduced production cell.
controller is aware of changes in the environment by querying the state space shared with the environment.
for instance gr uses kripke structures state machines with propositional valuations on states where the environment and the controller update and read respectively controlled and monitored propositions.
however in many settings such as requirements engineering architectural design and sel fadaptive systems a message passing communication model in the context of a distributed system is typically consider ed.
hence controller synthesis techniques require being adap ted to the notion of event based communicating machines .
this adaptation specifically to labelled transition syste ms lts semantics and csp like parallel composition is a contribution of this paper.
the change from state based to event based introduces the need for determinism of the environment to guarantee that the controller has sufficient information about the state of the environment to guarantee it satisfies its goals see definition .
and property .
.
the change also introduces the need for a sound methodological approach to the definition of assumptions in order to avoid anomalous controllers.
although many behaviour model synthesis techniques have been studied e.g.
these are restricted to userdefined safety requirements.
the exceptions that we are aware of relate to the self adaptive systems and the plannin g communities.
in the self adaptive community many architectural approaches for adaptation have been proposed.
at the heart of many adaptation techniques there is a component capable of designing at run time a strategy for adapting tothe changes in the environment system and requirements e.g.
.
these architectures do not prescribe the mec hanism for constructing adaptation strategies.
the techniq ue we propose could be used in the context of any of these architectures.
in fact we believe that the methodological guidance that our approach offers will help integrating the controller synthesis techniques into these architectures in a sound way.
various approaches to automated construction of adaptation strategies exists.
sykes et al.
in build on the pla nning as model checking framework to construct plans that aim to guarantee reaching a particular goal state henc e a certain liveness requirement must be dealt with.
the execution of the plan is restarted every time the environment behaves unexpectedly hence there is an implicit assumptio n that the environment behaves well enough for the system to eventually reach the goal state.
validating that the environment will behave well enough is not possible as the notion is not defined hence the plans do not provide the expected guarantees.
more generally the planning as model checking framework e.g.
supports ctl goals requires a model in the for m of a kripke structure and does not consider the problem of composing the environment with a machine that is responsible for guaranteeing the system goals.
consequently it does not distinguish between controllable and monitorable actions and the plans that are generated would not be realisable by the software system.
finally our work is heavily influenced by the work on requirements engineering by jackson van lamsweerde and parnas who have argued the importance of distinguishing between descriptive and prescriptive assertions between software requirements system goals and environment assumptions and the key role that the latter play in the validation process.
.
further evaluation in this section we show the results of applying our technique to a case study originally presented in in the context of self adaptive systems.
the case study was performed using an implementation of the control synthesis algorithm described above integrated into the modal transition system analyser.
the modified tool together with the running example and the case study are available at .
consider a situation in which a two bedroom house has collapsed leaving only one small passage between the two rooms refereed to as north andsouth rooms .
the entrance door of the house is in the south room and there is a group of people trapped in the north room.
the task of bringing aid packages to the occupants trapped inside is too dangerous for humans hence a robotic system is required.
a robot that has a wide range of movements and has an arm capable of loading and unloading packages.
the robot has a number of sensors which can be used among other things to check if a loading operation which is of a significant amount of complexity and uncertainty is successful or not.
the situation is complicated by the presence of a door between the two rooms.
the door cannot be opened by the koala robot.
however although the structure is unstable it is assumed that the door can be opened and closed by the trapped occupants.
a model of the environment was constructed by composing a model of the robot with actions such as movenorth its robot arm with actions such as getpackage and sensors e.g.getpackageok getpackagefailed a model of the door e.g.
opendoor and the a topological model of the house which restricts movements according to the position of the robot and the status of the door.
for instance it describes that the robot only can be loaded near the door and it can t move until the loading is accomplished successfull y. the aim is to automatically synthesise a controller for the robot that will achieve the task of retrieving aid packages from the outside to the room where the trapped occupants are trapped.
hence the set of controllable actions is the set of actions that correspond to the actions that can be performed by the robot and its arm e.g.
movenorth getpackage excluding actions events such as opendoor or getpackageok .
the formalisation of the goals is divided into two parts.
the safety part iprescribes the legal places for loading and unloading the robot e.g.
the robot must not unloaded packages in rooms other than the north room the liveness part of the goal states that infinitely often the robot must be at the far end of north room and have just unloaded g bc bdpos4 justunloadeded .
the control problem as defined up to this point is not solvable as the robot has no guarantees that the door will be open for it to move freely to and from the north and south rooms.
introducing the assumption that the door is infinitely often open as bc bddooropen is still insufficient as our implementation reports that the sgr lts control problem cannot be solved.
the problem is that the robot has no control over the success or failure of attempting to load an aid package using the arm.
thus a missing assumption stating that if the robot attempts to load a package it will eventually succeed bc getpackage bdgetpackageok .
when assumptions regarding the door being open and package loading being successful are included in the sgr lts control problem a solution exists and is constructed automatically by the tool.
it is interesting to note that the last assumption is compatible with the environment thanks to the topology of the plant.
consider the case in which the robot is near to the door it s not moving and it s unloaded.
in such case the topological model indicates that the robot can t leave its position if it is not successfully loaded.
th us after a failed loading the robot is forced to retry.
thus no controller would be able to prevent the environment to fulfil its promise.
nevertheless if after a loading fail the robot could not only to retry but also to move then the environment would not be able to fulfil its assumptions on its own and would depend on the controller s decision to retry or not.
therefore this illustrates how compatibility would b e actually violated and although our algorithm yields a best effort controller that could not be taken for granted.
comparing our approach to the original case study note that in i no assumptions are explicitly given as a result i no guarantees can be given as to wether the synthesised controller will satisfy the goal of delivering aid packages and iii although under certain conditions the synthesised plan will work it is not clear what those circumstances are.
.
conclusionsand futurework synthesis for liveness goals of event based systems poses not only algorithmic but also methodological challenges.
i n this paper we proposed a technique that works for an expressive subset of liveness properties that distinguishe s be tween controlled and monitored actions differentiate s between prescriptive and descriptive aspects of the sp ecification of system goals environment behaviour and environment assumptions.
we presented the event based and defined the ltsand sgr control problems which are control problems set in a theoretical framework adequate for event based models.
the first acts as a general definition the second grounds the specification language to ltss and fltl and the third supports safety and gr like properties.
we provide a solution that works in polynomial time and is based on a rank computation which is more suitable for explicit state space representation.
besides we identify a class of anoma lous controllers that even correct and complete algorithms like ours might yield if no further restrictions were requir ed for the assertions acting as liveness assumptions on the environment.
furthermore we identify an effective condition for assumptions that rules out those anomalies.
there are a number of avenues for future work.
we aim at relaxing the requirement on determinism for the environment model that is currently in place for assuring the soundness of our approach.
in fact this is closely related t o non observability of events controlled by the environment .
finally we aim to validate if our definitions of controller anomalies are complete.
in other words if they match our intuitions of what a good controller is.
.