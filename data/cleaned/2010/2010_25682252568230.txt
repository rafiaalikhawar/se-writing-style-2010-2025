integrating adaptive user interface capabilities in enterprise applications pierre a. akiki arosha k. bandara and yijun yu computing and communications department the open university milton keynes united kingdom pierre.akiki arosha.bandara yijun.yu open.ac.uk abstract many existing enterprise applications are at a mature stage in their development and are unable to easily benefit from the usability gains offered by adaptive user interfaces uis .
therefore a method is needed for integrating adaptive ui capabilities into these systems without incurring a high cost or significantly disrupting the way they function.
this paper presents a method for integrating adaptive ui behavior in enterprise applications based on cedar a model driven service oriented and tool supported architecture for devising adaptive enterprise application uis.
the proposed integration method is evaluated with a case study which includes establishing and applying technical metrics to measure several of the method s properties using the open source enterprise application ofbiz as a test case.
the generality and flexibility of the integration method are also evaluated based on an interview and discussions with practitioners about their real life projects .
categories and subject descriptors d. .
software architectures domain specific architectures d. .
design tools and techniques user interfaces h. .
information interfaces and presentation user interfaces user centered design general terms design human factors keywords adaptive user interfaces enterprise systems software architectures model driven engineering integration software metrics .
introduction existing research shows that a daptive user interfaces uis can help enterprise applications to overcome some of their usability problems by tailoring their off the shelf uis to each end user s needs .
yet many enterprise applications incorporate hundreds or even thousands of uis and are already at a mature stage in their development .
a method is needed for integrating adaptive ui capabilities into these systems without incurring a high development cost or significantly changing the way they function.
in his paper on criteria for evaluating ui research olsen gives an example about the objections that were made in the late 1970s towards new ui architectures due to the large amount of legacy code written for command line or text uis.
he notes that legacy code can be a barrier to progress hence if rewriting applications is necessary it could be the price of progress.
yet olsen also states that providing a new advance while maintaining legacy code is desirable .
the latter is what we aim to achieve with our method for integrating adaptive ui capabilities in enterprise applications.
another integration challenge lies in the difference between research work on adaptive user interfaces presented in the literature and traditional ui development techniques.
for example many research works on adaptive uis adopt the model driven approach to ui development either partially e.g.
supple or fully e.g.
masp .
however despite the advantages of the model driven approach the user interfaces of many existing software systems including enterprise applications have been developed using traditional techniques .
therefore an important issue to consider for adaptive ui integration in existing applications is the means of combining new ui development approaches such as the model driven approach with uis that have been built using existing ui design tools such as in terface builders.
this paper contributes a method for integrating adaptive ui capabilities in enterprise applications without the need for a major integration effort.
we evaluated our method by establishing and applying technical metrics to measure severa l of its properties using the open source enterprise application apache open for business ofbiz as a test case.
this evaluation covered different phases including reverse engineering integration and runtime execution.
we also evaluated the method s generality and flexibility based on an interview and discussions with industry practitioners and data from their real life enterprise system projects .
our proposed method in this paper is based on cedar a model driven service oriented and tool supported architecture for devising adaptive enterprise application uis .
using an architecture for adaptive systems is promoted since it provides generality abstraction and a potentia l for scalability.
our proposed method is applicable as a generic solution for adapting the uis of different enterprise applications.
also the abstraction provided by cedar offers a high level understanding of the ui adaptation process for stakeholders in terested in adopting it as a reference for devising adaptive uis.
furthermore ui adaptation mechanism s that are based on cedar are bundled as a separate system and made accessible through web service s thereby creating a loose coupling with potential for scalability and facilitat ing the integration in large scale enterprise applications.
the type of ui adaptation that we applied in the evaluation of our integration method is ui simplification using our role based ui simplification rbuis mechanism .
in a previous work we presented rbuis as a mechanism based on cedar for providing end users with a minimal feature set and an optimal layout based on the context of use and showed that it can improve end user permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india.
copyright acm ... .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
satisfaction and efficiency through a usability study.
we define a feature as a functionality of the software and a minimal feature set as the set with the least featur es required by a user to perform a job.
an optimal layout is the one that maximizes the satisfaction of constraints imposed by a set of factors such as the user s skills and motor abilities hardware device s etc.
an optimal lay out is achieved by adapting concrete widget properties such as the type grouping size location etc .
the example shown in figure was part of the evaluat ion of our integration method .
it demonstrate s feature set minimization and layout optimization operations on the product store ui of ofbiz .
our adaptation and integration mechanisms can be observed in operation through demo nstration videos .
the remainder of this paper is structured as follows section briefly discusses the related work.
section provides an overview of the cedar arc hitecture and presents our technique for integrating adaptive ui capabilities in enterprise applications based on cedar and using ofbiz as a test case.
the metrics we established for evaluating the different phases of our method are presented in section and applied to scenarios from ofbiz.
in section we assess the generality and flexibility of our method .
the threats to validity and limitations are presented in section and the conclusions and future work are given in section .
.
related work in this section we shall briefly cover the prior art for ui adaptation solutions and argue their strength and shortcomings in terms of how they integrate in existing software systems.
.
architectures several architectures were proposed as a reference for applications targeting adaptive uis.
cameleon rt is an architecture for distributed migratable and plastic uis.
however it only serves as a high level reference without providing low level implementation specifications including informa tion on integrating in existing systems.
lehmann et.
al.
proposed an architecture for devising adaptive smart environment uis which was only applied to the development of new prototype systems .
malai was presented as an architectural model for interactive systems .
in malai developers have to define several code based presentations for the same ui at design time.
in addition to being technology dependent a java example is provided ui adaptation in malai is not decoupled from the target software systems thereby requiring significant code modification to the system.
with our method we aim to provide specifications on integrating with existing systems and to decouple the ui adaptation mechanism from the target enterprise application.
.
techniques some works on ui adaptation such as multi layered ui design two ui design and training wheels ui present a theoretical basis for ui adaptation but do not offer an engineering solution for applying their propositions in practice.
other existing works with practical solutions can be classified as follows toolkit based approaches for adaptive uis have been explored extensively in the literature e.g.
caring sharing widgets selector s swing states etc.
.
technology dependence is one of the disadvantages of toolkits in comparison to model driven uis.
this disadvantage could impact the integration of adaptive ui toolkits in existing enterprise applications since the entire toolkit has to be redeveloped for each technology .
providing t echnology independence is a n important part of our cedar based adaptation mechanism as will be explained in section .
.
the comet s attempts to combine the toolkit and model driven approaches for building adaptive uis.
nevertheless e ven if the toolkit was technologically compatible with an existing enterprise system the amount of code modification that is required to switch the ui from the classical toolkit to the adap tive one could be significant .
this is especially true if the enterprise application s ui was not developed by following design patterns such as a bridge to decouple each widget s abstraction from its implementation.
in such a situation a conversion too l is necessary with some manual work for shifting the ui specification from one toolkit to another.
our approach can operate on existing ui s without having to update them to a new toolkit due to the separation of concerns between the adaptation mechanism and the technology dependent ui representation .
aspect oriented programming aop was proposed for improving the separation of concerns in software systems .
one approach that used aop for adapting uis requires several presentations to be figure .
an example o n adapting the product store user interface of the ofbiz enterprise application 713defined for the same ui at design time and a weaver is used to associate these presentations to instrument classes that handle the way the ui functions .
our approach is conceptually similar to aop since we are trying to achieve a separation of concerns between the ui adaptation technique and the enterprise system.
yet our main focus is on adapting the ui s presentation and not its code behind functionality.
from this perspec tive the existing aop based approach requires ui variations to be defined manually by developers at design time whereas o ur approach aims at adapting uis through adaptive behavior using rules that could be applied to different uis at runtime .
for example a rule could be defined to switch the way the ui s widgets are grouped by changing group boxes to tab pages .
adaptation rules defined outside the enterprise system could save integration time and support dynamic changes that narrow the gap between develo pment time and runtime .
design time model driven approaches rely on generating multiple adapted uis based on models that represent the ui at several level s of abstraction.
approaches based on s oftware product lines spl are u sed to tailor software systems in general and some such as mantra particularly target tailoring uis.
spls can be dynamic .
however spl based ui adaptation approaches focus on design time adaptation such as generating uis with different subsets of features based on a feature model whereas runtime adaptive behavior is not addressed.
smart templates are another generative approach and were used with ubiquitous remote control mobile uis .
code generation makes such approaches difficult to adopt for existing mature enterprise applications due to the amount of effort needed to integrate the generated code in the existing systems and the increased number of software artifacts that can require maintenance .
also if the adopted presentation technology required compilation e.g.
windows forms adding ui artifacts would increase the co mpilation time.
our integration method requires a few lines of code to be added to the enterprise application at design time to trigger ui adaptation s at runtime.
therefore our approach can be integrated without major design time effort or the need for a large number of new software artifacts.
runtime model driven approaches keep the models alive at runtime for adapting the running ui dynamically.
some are generative thereby generate an individual ui specification from the models at design time and use the models to adapt this ui at runtime .
masp follows this approach and targets ubiquitous uis in smart environments.
masp does not provide specifications on integrating with existing systems and it was evaluated by re build ing home automation applications such as energy cooking and health assistants .
other approaches such as supple and dynamo aid rely on interpreting the models and dynamically rendering the ui.
supple is a system which primarily targets generating uis that are automatically adapted to each user s motor abilities .
dynamo aid is a design process and runtime architecture for devising context aware uis .
both supple and dynamo aid did not demonstrate and evaluate the ability to integrate their proposed approaches in existing software systems.
supple was evaluated by developing a variety of simple ui dialogs e.g.
email client ribbon print dialog etc.
and dynamo aid was used to develop a tourist guide mobile application.
an additional point that is neglected by existing runtime model driven approaches is the support for user feedback on the adapted ui.
supporting feedback in adaptive systems is promoted for keeping users involved in the adaptation process to insure their trust .
nevertheless it could also play an important role in reducing development and integration efforts .
tuning the adaptation according to each user s needs can take several cycles of development deployment user testing and change reporting.
these cycles can be shortened by empowering users to report changes directly to the system using a feedback mechanism.
most existing wor ks on adaptive uis do not focus on feedback.
one exception is supple which supports user feedback for runtime elicitation of the adaptation rules.
however the sole reliance on runtime elicitation could be time consuming especially in large scale enterprise applicati ons and might not provide sufficient data.
with our cedar based approach we allow an initial definition of the adaptation rules e.g.
based on expert knowledge and rely on user feedback for further tuning.
we think that runtime model driven ui developme nt is the most suitable approach to support a method for integrating adaptive ui capabilities in existing enterprise applications due its dynamic nature .
yet the lack of attention from existing works in the literature towards integration drives us to present an integration method based on our cedar architecture.
section provides an overview of cedar and explains our method for integrating adaptiv e ui capabilities in enterprise applications using ofbiz as a test case.
.
integrating adaptive uis in ofbiz this section provides an overview of cedar and the way of using it for integrating adaptive ui capabilities in enterprise systems.
the open source en terprise application ofbiz is used as a test case.
apache open for business ofbiz is an open source enterprise automation software project that contains several sub systems such as enterprise resource planning erp manufacturing resources planning mrp customer relationship management crm e business and e commerce and supply chain management scm .
it could be considered as a general purpose large scale enterprise system having the characteristics shown in table .
table .
some of ofbiz s characteristics ofbiz release .
number of user interfaces number of lines of code projects based on ofbiz public sites using ofbiz although commercial enterprise systems can be larger for example sap has over lines of code and lawson has over uis ofbiz has complex uis with a large number of widgets that m ay need adaptation making it a good candidate for our study .
for example the main uis from its catalog module have an average of widgets and a maximum of .
also an open source system is necessary to test our integration method .
our method could work with commercial systems but the company that owns the source code should perform the integration.
.
the cedar architecture this section offers an overview of cedar and the way we used it for integrating the rbuis ui adaptation mechanism in ofbiz as shown in figure .
the cedar architecture serves as a reference for stakeholders interested in developing adaptive enterprise application uis based on a model driven approach.
it promotes the use of interprete d runtime models which allow uis to be loaded adapted and rendered dynamically without resorting to code generation.
although cedar has the potential to make the uis of software systems adaptive it had not been integrated with complex enterprise applic ations.
714as illustrated in figure cedar has three server side technology independent layers .
the decision components handle decision making in various adaptive ui scenarios such as evaluating whether a change in the context of use requires the ui to be adapted.
the adaptation components are mainly responsible for adapting the ui models by executing the appropriate adaptive behavior on them.
the adaptive behavior and ui models layer hosts the models that compris e the different levels of abstraction representing the ui.
these levels of abstraction follow the cameleon framework and include task domain abstract ui aui and concrete ui cui models.
the adaptive behavior is also hosted on this layer and could be represented visually as workflows or using scripts that dictate how the ui models are adapted for the different contexts ofuse.
the components of a server side layer can access those of the layer above it as depicted by the vertical arrows in figure right .
cedar s client components integrate in enterprise applications and empower them with adaptive ui capabilities as illustrate d by arrows to in figure using ofbiz as an example .
these components are dependent on the programming and presentation technologies since they have to be integrated in the enterprise application s code .
hence different sets of components are required .
these components offer an application programming interface api that is loaded globally in the enterprise application e.g.
common header in ofbiz .
whenever the end user launches a ui a request is made to the api for adapting this ui the identifiers of the end user and the ui are passed as parameters .
the api uses web services to pass the ui adaptation request to the server side layers which perform the adaptation and return the result to the api as xml .
the api s ui renderer is responsible for applying the adaptation result to the runnin g enterprise application ui which is an html page in the case of ofbiz.
once a ui is adapted the caching engine is responsible for caching the adapted version on the client side in case the end user requests it again.
adaptive ui mechanisms can affect a n end user s ui control end users might feel loss of control if the adaptive ui mechanism makes decisions they cannot understand or change.
reduction mechanisms can affect feature awareness if a ui was adapted by reducing features without providing a means of exploring the features that were removed and possibly bring them back the endusers can become unaware of so me features that they might want to use in certain contexts.
these negative effect s could be overcome if the end users are kept in the adaptation loop by supporting feedback on adaptations .
hence t he feedback monitor allows endusers to report their feedback on the ui adaptations presented by the system.
end users are given the ability to reverse adaptations or choose other possible alternatives.
cedar studio is an integrated development environment ide which helps developers and i.t.
personnel in defining and managing artifacts such as ui models and adaptive behavior which are stored in a server side database.
this id e can access the server side layers through web services in order to request or update artifacts.
cedar studio can be observed in operation through online demonstration videos .
cedar and rbuis were only evaluated in our previous work by constructing new ui prototypes.
in this paper we contribute a method for integrating rbuis in existing enterprise applications following the cedar architecture.
the ofbiz system is used as a test case for evaluating if the proposed integration method works without incurring a high development co st or significantly disrupting the way the enterprise application functions.
.
the rbuis ui adaptation mechanism cedar is a generic architecture that can form the basis for a variety of ui adaptation mechanisms such as rbuis .
rbuis was created in the spirit of rbac and was evaluated in terms of usability enhancement.
in rbuis roles are applied to task models represented as concurtasktrees for adapting the ui s feature set by removing features that are not required by certain end users .
also the layout can be optimized by adapting concrete widget properties such as size location type etc.
layout optimization is done by executing adaptation workflows that can embody visual and code based constructs on the concrete ui cui model s. to adapt a ui using rbuis a call is made to the server figure .
integrating adaptive user interface capabilities in ofbiz based on our cedar architecture 715side layers with the identifiers of the end user and the ui as parameters.
the end user identifier is used to retrieve the roles which are granted to the logged in end user.
then the adaptive behavior associated with these roles is executed on the ui models relevant to the ui identifier .
finally the adapted ui is transmitted to the client side as xml to be rendered on the screen.
in this paper w e used rbuis to give ofbiz adaptive ui capabilities.
.
adaptive ui integration technique ofbiz uses html to represent its uis .
hence in order to integrate rbuis in it we developed a javascript version of cedar s client api that works with html uis.
since rbuis adopts a model driven ui development approach we devised a procedure for reverse engineering html forms into a model driven representation supporting the levels of abstraction suggested by cameleon task aui and cui models .
the reverse engineering is done at design time.
however our technique launches the html page s of ofbiz in the browser then acquires the html through javascript to include the elements that are generated by server side script s. our procedure transforms an html form into an xml document which is used to create a cui model.
then the cui is reverse engineere d into an aui model and the aui into a task model automatically.
the only manual part in this procedure is the definition of mapping rules.
an excerpt of the code for reverse engineering an html table is shown in listing .
listing .
code for reverse engineering html ui to a model driven representation excerpt of html table example function converthtmltabletoxml tableid var xml tableid tr .each function var cells td this parse cells for var cellctr cellctr cells.length cellctr var inputs input cells.eq cellctr parse input fields for var inpctr inpctr inputs.length inpctr var fieldtype inputs.eq inpctr .attr type fieldid getfieldid inputs.eq inpcounter element getelement fieldid genera te xml for element var xmlinput getinputfieldxml element fieldtype fieldid n xml xmlinput return xml after reverse engineering the uis that require adaptation we can apply rbuis on the obtained ui models using cedar studio.
to make the adaptation work at runtime on ofbiz s html pages we need to extend ofbiz with a few lines of code that load the cedar api call its web service and apply the obtained result .
ofbiz uses a master page to wrap its ui forms with a common header footer and panel as shown in figure .
to reduce the integration effort we loaded the api and perform ed the adaptation call in the common header using the code shown in listing .
listing .
code for enabling adaptive ui capabilities load the api scripts script type text javascript src http cedarscripts.js script script type text javascript document .ready function initialize setup the api call the api to adapt the ui and pass the logged in user id as a parameter loadadaptedui getuserid script the getuserid function call on line in listing should be implemented by the developer to obtain the identifier of the logged in user from the ofbiz system .
the loadadaptedui function can internally acquire the ui identifier through a mapping table that contains the ui s url and a number to identify the ui s models in the cedar database.
the ui s url is obtained from the web browser and passed as a parameter to the adaptation function on cedar s web service .
the map ping is done on the server side by querying a mapping table in the cedar database .
after receiving an xml representation of the adapted ui from the server the ui rendere r component will apply the changes to the html page loaded on the client by modifying the widgets propert ies.
an excerpt of the code that applies the adaptations is shown in listing .
this code excerpt demonstrates hiding the widgets that were set to be invisible by an adaptation e.g.
removing features that are not required by a certain user .
listing .
api code for applying the adapted user interface excerpt of widget hiding example function applyadaptedui uixml loop around the ui widgets uixml .find control .each function get the name and visibility attributes var technicalname this .attr technicalname var isvisible this .attr visible hide the invisible elements if isvisible false var element getelement technicalname hide the element if it exists if typeof element !
undefined element.style.visibility collapse .
user feedback mechanism the feedback monitor presented in section .
allows users to change simplification operations by bringing back features in the case of feature set minimizations or choos ing alternatives in the case of layout optimizations as shown in figure a. based on a recommendation we obtained by interviewing an industry expert we extended this mechanism s functionality to allow users to add fields that did not previously exist in the enterprise application as illustrated by figure b. changing simplification operations is enabled for the adapted uis whereas adding new fields is enabled for all the reverse engineered uis.
users can access the feedback mechanism by clicking a chameleon icon that appears in the corner of the ui.
upon changing the simplification operations a request is made to the server passing the changes as a parameter and the ui is readapted accordingly.
as for adding new fields the ui models are extended and the ui is reloaded to show the addition .
a changing simplification operations b adding new fields figure .
user feedback mechanism .
metric based evaluation the process of integrating ui adaptation capabilities in enterprise applications starts by reverse engineering the target application s uis.
afterwards the application is extended to support adaptation henc e becoming able to adapt its uis at runtime.
this section explains the metrics that we used to evaluate our integration method at all the sta ges of the process and demonstrates an application of the se metrics to scenarios from ofbiz .
.
reverse engineering the user interface s as we mentioned in section .
we devised a procedure for reverse engineering html forms into a model driven representation tha t can be adapted by rbuis.
although it is automated this procedure requires mapping rules to be defined manually.
hence t he first question that might come to mind is about the difficulty of deducing these rules from the existing enterprise system since it has a large number of uis .
assuming that there is no prior knowledge of the types of mapping rules required for reverse engineering the enterprise system at hand we defined the following metrics for estimating the number of uis that require manual work before the majority of the mapping rules are detected .
these metrics indirectly show the level of diversity in an application s uis.
more diversity could signify that there are more mapping rules which are more uniformly distributed over the entire system.
the approximate mapping rule detection saturation point sp indicates that the number of new encountered mapping rules stabilize d after rever se engineering a number of uis a. this metric will allow us to test if the pareto principle rule applies for detecting of the mapping rules in the first of the uis.
if this principle applies it indicates that less manual work is required for reverse engineering since the uis have similar characteristics .
to check if the pareto principle holds we define the following equation where r is the set of rules detected in the uis before sp and mr is the set of all the detected mapping rules the saturation point sp is defined as follows where ui is a user interface being reverse engineered c is the number of new mapping rules detected in this ui the subscript b of c indicates the next ui to be reverse engineered and t is the total number of uis to be reverse engineer ed.
the types of mapping rules that are encountered when reverse engineering a ui can differ depending on the characteristics of the software application being reverse engineered .
we hypothesize that the pareto principle holds for enterprise applications due to the use of similar wimp style uis.
ofbiz scenario we selected a sample formed of the main input uis from the catalog and human resources modules .
we were able to ded uce two types of mapping rules necessary for reverse engineering these uis into a model driven representation the most common type of rule is the one that maps individual html elements to cui elements that are in turn mapped to aui elements then tasks in the task model and the second type of rule is related to grouping widget pairs composed of a label and an input widget into logical groups that are reflected in the aui and task model s. defining rules from these two types alongside getting information provided by the html ui e.g.
widget properties such as name size location etc.
was sufficient to obtain a model driven user interface representation that we can adapt using our rbuis mechanism.
figure .
saturation point for mapping rules we encountered different widget types each requiring mapping rule and were able to detect the second mapping rule relating to logical widget grouping in the first ui.
we obtained a saturation point sp .
signifying that after the second ui the mapping rules become minimal as shown in figure .
following our example where sp .
p is .
in best case scenario and .
in the worst case one.
with an average of .
of the rules detected in the first of the uis we can say that the pareto principle holds and the uis of ofbiz are highly similar.
.
integrating the adaptive ui capabilities after reverse engineering the uis we can assess the level of change the integration will incur on the enterprise application.
we defined the lines of code and change impact metrics for this assessment.
the lines of code metric refers to the code required locally in each ui or globally in the enterprise application to apply a type of adaptation .
this metric exclude s the api code since cedar requires each presentation technology e.g.
html to have one api that is reusable with any enterprise application .
the lines ofcode metric is given as follows where lloc represent s a ui s local lines of code whereas gloc represents the global lines of code common across the application a is the required adaptation ui is the user interface to which this adaptation will be applied and ea is the enterprise application .
the values for lloc and gloc represent the number of lines of code that must to be added to make the adaptation operational .
ofbiz scenario as an example test case we considered the context driven ui adaptations listed in table and applied them to ofbiz.
an example of the output was shown earlier in figure .
adaptation a1 is a feature set minimization whereas adaptations a2 a3 and a4 are examples of layout optimizations.
717table .
example user interface adaptations code adaptation a1 reduce features e.g.
hide or disable widgets a2 switch widget type e.g.
combo box es to radio buttons a3 change layout grouping e.g.
group boxes to tab pages a4 change font size e.g.
larger fonts for visually impaired users our method only requires the lines of code shown in listing to be added globally to ofbiz s common header to empower it with adaptive ui capabilities .
consider ae to be the set of adaptations listed in table .
the lines of code needed to make these adaptations work in ofbiz using our method are x x ae gloc x ofbiz and lloc x anyui .
achieving this low number of lines of code is possible because all the adaptation rules are defined on the server side as shown in figure .
some approaches discussed in section operate by changing the ui s representation e.g.
html tags at design time.
therefore we established the change impact ci metric to measure the level of change each approach will incur on th e enterprise application.
a higher change impact could signify that more time and effort could be needed to perform the integration and the compilation time could increase if a compiled presentation technology such as windows forms was used.
since we can think of uis in terms of widgets the change impact metric is given as follows where a is the adaptation being applied ui is the user interface being adapted k is a type of widget e.g.
text box combo box etc.
n is the number of widget types in the ui lk is the number of lines required for representing each widget type e.g.
number of html tags and w k is the number of widgets of a certain type that have been changed by the adaptation.
the variable v represents the number of generated ui versions and is for approaches that cannot adapt the same ui copy e.g.
a single html page but generate multiple copies of the ui each of which is adapted to a certain context of use.
widget toolkits aim at replacing existing widgets from the standard toolkit with adaptive equivalents.
hence the value of v for widget toolkits would be since the change is occurring in the initial ui copy .
we should note that widget toolkits are generally used to adapt the layout and do not have the ability to adapt the feature set due to their lack of a high level ui model such as the task model.
model driven design time generative approaches generate multiple versions of the same ui adapted to different contexts of use.
hence the value for v in this approach would be .
the research work that used aop for adapting the ui s behavior section .
relied on manually creating multiple adapted ui layout s hence we also consider its v value to be .
as for our method ci is always since we use runtime adaptation hence the ui representation e.g.
html pages will remain completely intact at design time.
table .
integration time of different adapta tion approaches approach integration time widget toolkits average high model driven generative d.t.
average aop d.t.
manual adaptation high model driven interpreted r.t. low based on ci we provide d a conceptual comparison between the different ui adaptation approaches as shown in table .
our aim is to give an idea about the differences in the required integration effort between approaches wh ile recognizing that there could be slight differences between adaptation techniques using the same approach.
widget toolkits require an average amount of time if a conversion tool existed to automatically convert the ui otherwise a high amount of time is needed.
model driven generative design time approaches require an average amount of time since the adapted versions could be automatically generated but more time could be still required to integrate them with the software application.
logically manual adaptation requires a high amount of time.
the integration time of our method is low since ci is always hence the developers can continue working on the application without major disruptions.
ofbiz scenario we attempted to apply adaptation a2 to the main input uis of the catalog and human resources modules of ofbiz .
this adaptation switches combo boxes with three other types of widget s including radios buttons list boxes and lookups.
these possibilities indicate that we could obtain three different versions of the ui hence v equation for the model driven generative and manual design time approaches and v for the widget toolkit approach.
the value for n equation is since we are only adapting combo boxes and we consider that each combo box is represented by a single html tag hence l equation .
the results we obtained from calculating ci are listed in table and show that the cedar approach has the lowe st change impact.
table .
ci example based on uis from ofbiz change impact approach mean total widget toolkits .
model driven generative d.t.
.
aop d.t.
manual adaptation .
model driven interpreted r.t. the applied adaptation switches combo boxes with radio buttons list boxes and lookups .
level of decoupling the level of decoupling shows how much intertwining exists between the adaptive behavior and the enterprise application.
it is affected by the percentage of adaptive b ehavior defined in the enterprise application versus that defined separately .
decoupling provides a separation of concerns that could offer potential for scalability and facilitate the integration of an adaptation technique in existing enterprise applicati ons.
as shown earlier in figure cedar provides complete separation between the implementation of the adaptive ui technique e.g.
rbuis which resides on a server and the enterprise application that uses a client side api to communicate with it through a web service.
it is important to maintain the backward compatibility of ui adaptations as enterprise application s evolve.
we consider an adaptation a to be backward compatible if it can be applied to previous ui versions successfully and without reintegration effort .
decoupling helps in improving backward compatibility in terms of eliminating reintegration effort .
a conceptual assessment of the backward compatibility of ui adaptation approaches is presented in table based on the need for reintegration effort .
table .
backward compatibility of ui adaptation approaches approach backward compatible widget toolkits depends on the ability to load a new widget toolkit version at runtime model driven generative d.t.
false aop d.t.
manual adaptation false model driven interpreted r.t. true 718widget toolkits can be backward compatible if it is possible to load a new toolkit version at runtime to update the existing adaptive behavior in older versions of the enterprise system.
this is not possible with model driven approaches that generate uis at design time since the generated artifacts have to be manually integrated in all the previous enterprise application versions.
manual design time adaptation suffers from a similar problem .
if we consider the adaptations listed in table we can say that our approach is backward compatible since it is only necessary to define a global code once to mak e these adaptations work for all the uis.
hence the adaptations would work for all the previous versions that have this code since the adaptive behavior are being defined separately .
an adaptation s success can be partial due to differences in the ui definition between one version and another.
we defined a metric for calculating the backward compatibility success ratio as follows where uivn is a ui from the enterprise application version into which the adaptation a was integrated for the first time and uivn k is one of the previous versions w is the set of widgets in a ui and aw is the set of widgets affected by an adaptation a. as an example of partial ui adaptation success let us consider a ui for managing customer records .
consider that customerui v2 has multiple fields of which are for data selection and are represented as combo boxes e.g.
gender .
assume that the previous ui version customerui v1 has the same data selection fields but only are represented as combo boxes and the other are list boxes.
if we introduce an adaptation to switch data selection widgets with radio buttons in customerui v2 we might ignore list boxes.
in this case bc .
indicating an success rate.
with approaches that are not dynamic and rule based e.g.
design time generative two adapted uis have to be generated and integrated into each respective customerui version to achieve a success rate.
as for our approach we only have to adjust the adaptation rule in our rbuis mechanism to take into consideration list boxes as well a s combo boxes to obtain a backward compatibility .
.
runtime performance considering that our approach is highly dynamic we had to test its runtime efficiency and scalability especially since we are working with uis that are expected to load in real time.
in a previous work we conducted a complexity analysis to show that the algorithms behind our rbuis mechanism are theoretically scalable.
in this paper we tested our technique s runtime efficiency and scalability after integrating it with an existing real life system ofbiz .
to perform this test we defined the following efficiency metric as a function of an adaptation a and a user interface ui where t0a is the time required to perform an adaptation on the server side t0b is the common server side time required for any number of adaptations e.g.
loading common data before applying the adaptations t1 is the time needed to transmit the adapted ui as xml back to the client and t2 is the time it takes the api to apply the adaptation on a running ui such as an html page in ofbiz.
we used this metric to test the efficiency of the four example adaptations listed in table on the three uis with the highest number of widgets in ofbiz s catalog module.
the test was conducted on a single machine with an intel core duo .93ghz cpu and gb of ram running a bit edition of windows .
we used the firefox web browser to run ofbiz.
we determined the t0b variable to be equal to milliseconds ms .
the t1 variable depends on the network connection and is negligible for our test since we were operating on a single machine.
we calculated the average xml document size for the selected uis to be 20kb.
based on this file size t1 will be very small over an internet connection e.g.
15ms 10mbps and negligible over a corporate network e.g.
.15ms 1gbps .
the values of variables t0a and t2 are shown in figure for each ui and adaptation.
figure .
results of the efficiency test on ofbiz uis using example adaptations t0b 30ms and t1 15ms using the data shown in figure and considering t1 to be 15ms we determined the average efficiency for each adaptation to be e a1 75ms e a2 115ms e a3 150ms and e a4 90ms.
the general average is .
ms. if we do not consider the fixed values t0b 30ms and t1 15ms the general average will be .5ms.
based on this number we can say that our technique can perform around different adaptations on the same ui transmit it and display the result all in less than second .
.5ms .
since the cedar architecture supports clie nt side and server side caching performance can be further enhanced.
client side caching is used if a u ser that is stil l operating in the same context e.g.
still logged in with the same roles requests a ui that has already been adapted.
in this case the efficiency metric will be e a ui t2 general average .5ms .
as for the server side caching it is used when a user requests a ui that has already been adapted for another user operating in the same context e.g.
a user that has the same roles .
in this case the efficiency metric will be e a ui t1 t2.
after testing the efficiency of our technique we verified its scalability by load testing cedar s ui adaptation web service.
we selected the largest of the three uis that were used in the scalability test product store ui with widgets and applied to it the four adaptation operations s hown in table .
we submitted increasing requests of that ui to the server over five minute periods and repeated the whole cycle five times.
the web service was hosted on an amazon cloud server with a single intel xeon cpu with cores .
ghz .15ghz .
gb of ram and running a bit edition of windows server standard with the iis web server.
we consider this setup to be an average configuration since enterprises with hundreds of users usually setup servers with multiple cpus and a larger amount of ram.
we simulated the load using an application that we developed and ran simultaneously on three client machines.
the result ing server response times t0a t0b from equation are shown as a box plot in figure .
figure .
box plot of load testing results showing medians the fitting curve of the mean response tim es shown in figure is polynomial of the 4th order with r2 .
.
we should note that the polynomial curves of the 2nd and 3rd orders also produced a high r2 where r2 2nd .
and r2 3rd .
.
based on this test we can say that our ui adaptation service is scalable and will not form a bottle neck if it receives a high number of requests.
figure .
curve of the load testing results showing means .
evaluating the generality and flexibility of our method this section presents an evaluation of the generality and flexibility of our method based on industrial expertise and data .
to evaluate our method from an industrial perspective we drew on the expertise and data from real life projects offered to us by a software company that sells enterprise systems to medium and large enterprises in china.
we selected this company due to its expertise in enterprise systems ui adaptation and our test case ofbiz .
we initially visited the company to get information on their work and the problems that they face with enterprise applica tions.
in this initial visit we discovered that one of the major problems they face is usability related.
the enterpri se applications that they sell suffer from a diminished user experience due to the divers e end user needs that make one ui not fit for all users .
we established through a verbal explanation of our ui adaptation technique that it could be useful with real life enterprise systems such as ofbiz .
at a later stage since we were able to integrate our ui adaptation technique successfully in ofbiz we sought to further evaluate its usefulness by assessing i ts generality and flexibility .
these two criteria were introduced alongside others by olsen for evaluating ui research including architec tures such as cedar .
according to olsen generality evaluates the possibility of using the proposed solutions with different use cases and flexibility evaluates the possibility of making rapid design changes that can be evaluated by the users p. .
we demonstrated our ui adaptation and integration techniques to the manager with videos of running examples on using our ide cedar studio for developing adaptive model driven uis and an example on integrating these capabilities in ofbiz.
afterwards we conducted a semi structured interview over the phone with the manager and followed it with several discussion s. to achieve generality our method only requires an api for the presentation technology adopted by the target enterprise application.
as shown by the cedar architecture in figure all the server side components are technology independent and can be access ed from a technology dependent api through web services.
an api for a particular presentation technology can be used with any application adopting this technology by following the integration procedure described in section .
this is deemed acceptable by the manager especially since we developed an api and demonstrated it in a working example alongside our ide cedar studio.
according to olsen s definition flexibility is regarded as a development metric that assesses how easy it is for developers to make rapid design time changes using a tool .
it is achieved from this perspective by our ide cedar studio which supports visual design tools for both ui models and adaptive behavior in addition to integrated testing of the adapted uis.
thes e features allow changes and testing to be done rapidly.
nevertheless during our interview we deduced a helpful end user perspective of flexibility.
it covers the possibility and eas e through which end users can change the ui themselves without referring to software developers.
based on his company s experience the manager said that uis are initially adapted by the developers based on initial knowledge acquired on the needs of an enterprise s end users.
afterwards the ui adaptation is tuned over several cycles in a process that include s user evaluation change reporting and discussion and readapting the ui based on the newly reported changes.
he noted that the adaptation mechanism available to them in ofbiz supports reducing features layout optimizatio n is not supported through xml configuration files which are defined by the developers.
therefore as he stated the feedback mechanism provided by our approach is an important advantage that empowers end users to provide direct feedback to the system in order to shorten the c ycles of the adaptation process.
this reduces the implementation cost and allow s the users to obtain an adapted ui more quickly.
as a result of this interview we were able to establish the process shown in figure which demonstrates conceptually these advantages .
figure .
ui adaptation process design time versus runtime ui adaptation cycles based on interviewing industry experts a complementary indication on the importance of runtime adaptation approaches is made by an existing research work which states that s oftware systems should attempt to break the boundary between development time a nd runtime to handle the changes that cannot be anticipated or predicted beforehand .
empowering users with control over the ui adaptations narrows this boundary and help s in reducing the round trip in the adaptation process .
in a previous work we conducted a usability study with participants that demonstrated the ease of use of our feedback mechanism since of the participants were able to use it by only referring to a few written words of instruction on its purpose.
720in this paper we estimated the time that the feedback mechanism could save in the ui adaptation cycle based on real life data .
we asked the manager who we interviewed to provide us with timestamps of requests on the different steps of the ui adaptation process from past projects.
we were provided with a sample of timestamps of requests from past projects that were running in parallel.
the timestamps were obtained by referring to historic emails of requests on development deployment and change reporting and discussion .
based on these timestamps we calculated the mean number of days for developing and deploying the adapted uis and reporting and discussing change requests between the enterprise employees and the software company.
the results are shown in figure but the project names are hidden for confidentially purposes.
the results indicate that the highe st mean days in the ui adaptation process are allocated to user evaluation and change reporting and discussion project a .
project b .
project c and a smaller mean number of days is allocated to the development and deployment of ui adaptations project a project b .
project c .
.
figure .
mean number of days for ui adaptation cycle from real life enterprise projects running in parallel the results in figure show that if the ui adaptation process was repeated from the start with every cycle a period of over month could pass before the users get their reque sted ui adaptations.
on the other hand if the users were given the ability to report the changes directly to the system through a feedback mechanism this process could become much shorter by eliminating the time required for development deployment and change discussion.
.
threats to validity the data presented in this paper is based on applying our ui adaptation approach to scenarios from ofbiz.
the figures we obtained by applying the saturation point sp metric give us an indication abou t the nature of enterprise application uis without claiming generalizability to all enterprise applications .
when we compared our approach to others from the literature using the change impact ci and backward compatibility bc metrics we aimed at givin g a general conceptual idea about the differences while a cknowledg ing that there could be some variations between the low level adaptation techniques using the same approach .
the load testing curve presented in figure is intended to show that our ui adaptation mechanism is scalable.
determin ing an accurate regression equation which is not the purpose of this test requires a larger sample of mean execution times .
interviewing more industry experts could support our generality claim further.
concerning the ui adaptation cycle data figure as we mentioned earlier it is based on a sample of request timestamps from projects.
therefore our intention is not to generalize it but to give an indication about the time each ada ption cycle could take to show the usefulness of our runtime feedback mechani sm in shortening these cycles.
task models represented as concurtasktrees support temporal operators which can help in determining inter task dependency.
determining this depende ncy is helpful for feature reduction adaptation operations.
currently we are unable to automatically detect these operators when reverse engineering a ui specified in a presentation technology such as html to a model driven representation.
it is possible to specify t hese operators manually using the task model design tool in our ide cedar studio.
another limitation lies in the addition of new fields using the feedback mechanism.
this functionality allows the new fields to be rendered on the screen by updat ing the ui models.
however for the fields values to be stored in the enterprise s database the enterprise application should support domain model extension.
ofbiz allows its domain model to be extended by the developers but the feedback mechanism makes it extensible by the end users.
in case other enterprise applications did not support domain model extension this functionality has to be programmed before the endusers can use the field addition part of our feedback mechanism.
.
conclusions and future work adaptive uis can help enterprise applications to overcome some of their usability problems .
many of these systems have a large number of ui s and are at a mature stage in their development life cycle.
however existing works on adaptive uis mostly test their approaches by bui lding new prototype systems but do not present and evaluate methods that can integrate such capabilities in existing sys tems without causing major changes to the way they function or incurring a high integration cost.
in this paper we presented a method for integrating adaptive uis in enterprise applications based on our cedar architecture.
this method uses interpreted run time models to empower enterprise applications with adaptive ui capabilities without the need for a major integration effort.
we established several technical metrics and applied them to evaluate our method based on scenarios from the open source enterpris e application ofbiz.
this assessment covered the different phases of our method including reverse engineering integration and runtime execution.
we showed that due to the similarity between enterprise application uis around of the mapping rules required for the reverse engineering phase could be determined by examining the first of the uis to be reverse engineered.
after determining the mapping rules the reverse engineering process becomes fully automated.
without changi ng the underlying functionality our integration method only requires a few lines of code to work and does not have a high change impact on existing ui definitions in comparison to other approaches.
furthermore we demonstrated that our runtime ui adaptat ion mechanism is both efficient and scalable by applying it to real life scenarios from ofbiz.
finally we showed the generality and flexibility of our method based on an interview and discussions with practitioners and data from their real life projects .
in the future we aim to devise a technique that can automatically detect the temporal operators for the task models when reverse engineering a final user interface e.g.
html into a model driven representation.
an interesting starting point could be an existing work that has explored a way to transform html pages into state machine diagrams by relying on the function calls in the code behind the ui .
additionally we are aiming to ask software developer s to evaluate our ui adaptation and integration approach and our supporting tool cedar studio in a focus group setting.
.