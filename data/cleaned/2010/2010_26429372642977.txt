droidmarking resilient software watermarking for impeding android application repackaging chuangang ren department of cse the pennsylvania state university university park pa cyr5126 cse.psu.edukai chen state key laboratory of information security institute of information engineering chinese academy of sciences beijing china chenkai010 gmail.compeng liu college of ist the pennsylvania state university university park pa pliu ist.psu.edu abstract software plagiarism in android markets app repackaging is raising serious concerns about the health of the android ecosystem.
existing app repackaging detection techniques fall short in detection e ciency and in resilience to circumventing attacks this allows repackaged apps to be widely propagated and causes extensive damages before being detected.
to overcome these di culties and instantly thwart app repackaging threats we devise a new dynamic software watermarking technique droidmarking for android apps that combines the e orts of all stakeholders and achieves the following three goals copyright ownership assertion for developers real time app repackaging detection on user devices and resilience to evading attacks.
distinct from existing watermarking techniques the watermarks in droidmarking are non stealthy which means that watermark locations are not intentionally concealed yet still are impervious to evading attacks.
this property e ectively enables normal users to recover and verify watermark copyright information without requiring a con dential watermark recognizer.
droidmarking is based on a primitive called self decrypting code sdc .
our evaluations show that droidmarking is a feasible and robust technique to e ectively impede app repackaging with relatively small performance overhead.
categories and subject descriptors k. .
management of computing and information systems security and protection invasive software keywords software watermarking android app repackaging chuangang ren and kai chen are co rst authors and contact authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
introduction the past years have witnessed the unprecedented popularity of android devices and the booming of android application markets.
software plagiarism in android markets however which is also known as app repackaging is posing prevalent and severe threats to the health of the android ecosystem.
for instance app repackaging has caused intellectual property infringement and enormous advertising revenue losses for original app developers .
a signi cant portion of android malwares use repackaged apps as a free vehicle to carry malicious payloads which have posed serious risks to user privacy and nancial security .
while there have been considerable recent e orts from both academia and industry to impede the app repackaging acts the existing methods have limitations that largely undermine their e ectiveness in practice.
most existing app repackaging detection approaches are o ine solutions performing centralized repackaging detection regularly or on purpose by authorities like android markets e.g.
similarity mining from a large basis of app samples .
the primary drawback of these o ine solutions is that they allow for repackaged apps to be widely distributed depending on how often repackaging detection is performed and to cause extensive harm to users and original app developers before they are detected.
moreover most existing repackaging detection approaches can be easily evaded by various obfuscation techniques as illustrated by which further encourages repackaged app developers attackers to submit more repackaged apps to the markets hoping to make as much illegal pro ts as possible before they are detected and removed from the markets.
to this end we have a pressing need for a new robust antirepackaging scheme that can combine the e orts of other major stakeholders users and app developers and can instantly thwart the distribution of repackaged apps before massive damages are caused.
we thus have the following design goals for the new anti repackaging scheme .
accurately and quickly detect app repackaging threats with help from users and original developers .
provide undeniable and solid proof of copyright ownership to protect app developers .
o er strong resilience to various evading attacks toward all these goals we are intrigued by traditional watermarking techniques which are widely employed by printing industries to ght against piracy acts.
they provide three noteworthy properties copyright assertion real time copyright veri cation by users and resilience to evading attacks.
these properties are highly desirable for those who want to overcome the di culties in impeding app repackaging in today s android market.
software watermarking is not new.
by using a custom tool namely watermark embedder a software developer can insert a copyright notice into a program.
an concerned authorized party can later recover and verify the software s copyright ownership using a tool called watermark recognizer which keeps some form of secrets e.g.
password special input to reverse the watermarking embedding process and recover the copyright notice from the program.
to prevent attackers removing the watermarks existing software watermarking approaches rely heavily on the stealth of watermark i.e.
embed watermarks in a way to make them locally indistinguishable from the carrier code .
however this stealthy design principle causes two consequences that prevent existing software watermarking techniques from achieving the properties we desire in traditional watermarking.
first the watermark recognizer has to be kept condential from the public and be held by a small number of authorized parties e.g.
developer or trusted authority as it contains the secret to disclose the locations of watermarks in a program.
as a result there is no way for normal users to verify watermarks in real time like they can on for example a book page.
second it is di cult to ensure absolute stealth as we will see in section .
therefore simply deploying existing software watermarking techniques on android apps would fail to achieve our goals.
it is exactly these challenges that this paper seeks to address by presenting a new non stealthy software watermarking scheme.
contrary to the design criteria of existing software watermarking approaches our design is based on the insight that non stealthy i.e.
do not conceal the locations of watermarks on purpose is an appealing property for software watermarking due to two advantages when the locations of watermarks in a program is open to the public normal users and also attackers are free to recover watermarks without con dential tools needed.
of course users still need assistance from certain tools to recover watermarks but these tools contain no secret for watermark recovery and thus are no longer exclusive to authorized parties.
it circumvents the design challenge of how to make watermarks stealthy which is di cult based on the experience of previous work .
on the other hand non stealthy makes watermarks vulnerable to evading attacks.
our solution is to make the resilience of our watermarking rely on inter dependency between the embedded watermarks and the carrier program.
it means that not only do watermarks depend upon a carrier program to reside but watermarks also are embedded in a way that the correct and complete functionality of the original program also relies on the integrity of original watermarks.
simply de coupling the two would result in miss or non functional code.
based on these new criteria our watermarking scheme droidmarking lets a developer embed watermarks into an app and later allows a normal user who installs this app on his her device to quickly recover and verify the developer s watermark from the app by simply playing the app for ashort period of time without any con dential watermark recognizer needed.
based on the recovered watermark information a droidmarking facility on a user device can automatically detect potential repackaging threat and immediately report it to user and or the android market.
droidmarking is based on a primitive called self decrypting code sdc segment which is rst introduced by sharif et al.
and referred to as conditional code obfuscation in their work .
a sdc segment is an encrypted code block containing both the original functional code and embedded watermark code snippet in a special type of branch in the program.
the encryption key comes from the constant value in the special branch condition.
the branch condition is re written in a semantic equivalent way that this particular constant key is removed from the static code and can only be dynamically recovered upon branch condition satisfaction at runtime.
by this means sdc helps build the inter dependency between watermark and original carrier code by combining and encrypting the two into a single sdc segment.
furthermore by creating a large number of watermark carrying sdc segments it is di cult for attackers to de couple all embedded watermarks from the original functional code without signi cant e orts.
we summarize our contributions below we propose a new non stealthy software watermarking approach that allows users to freely recover and verify watermarks without requiring a con dential watermark recognizer yet is still resilient to de watermarking attacks.
our non stealthy watermarking is based on a primitive called self decrypting code sdc .
we implement our watermarking approach to a prototype droidmarking for android applications.
we systematically evaluate the e cacy of droidmarking on its feasibility resilience and performance.
.
watermarking background .
traditional watermarking traditional watermarking embeds a watermark message into the carrier media to declare copyright ownership.
take watermarking in printing industry for instance a valid watermark usually an image or a pattern in paper in a printed book carries unique authorship and publisher information that discloses precise copyright ownership of the book.
a concerned reader can readily verify these information immediately when getting a hard copy.
an e ective watermarking technique is designed to make sure that watermark is readily veri able by people who possess the object and it is infeasible to copy or counterfeit a watermark.
the rst objective allows users be able to easily verify the authenticity and originality of the object by themselves immediately.
the second objective protects the integrity of watermarks against forgery attempts.
as a result there is no easy way for an attacker to forge a watermarked object without being noticed by concerned users who always verify the watermark rst.
.
software watermarking software watermarking does not prevent software copying but instead discourages software piracy by embedding copyright information into software code and allows one to prove copyright ownership when plagiarism has occurred.
636software watermarking embeds a watermark winto a programp such that wcan later be reliably located and recognized from p even after pis subject to code transformations.
software watermarking comes with two avors static and dynamic.
static watermarks are stored in the code or data of the executable whereas dynamic watermarks are usually built at runtime and contained in the dynamic state of the program e.g.
data structure execution trace etc.
software watermarking must be able to defend against two types of attacks in general steal attack and change attack.
in a steal attack attackers wish to disguise plagiarized software as original by copying forging the original watermark making users believe that their copy comes from a trusted original software vendor.
in a change attack attackers attempt to disable the original watermark by changing the program.
more speci cally change attacks fall into the following three categories a subtractive attack tries to completely or partially remove the watermarks from the program.
a distortive attack applies a sequence of code transformations attempting to obstruct the recovery of original watermarks.
an additive attack add attacker s own watermarks to the software and claim attackers ownership of the software.
in practice attackers can opt for a combination of the above attacks.
on the defense side one natural step towards defeating subtractive and distortive attacks in existing work is to conceal the watermark in a stealthy way such that it is di cult to locate remove distort all watermarks in the program or the quality of the distorted program is signi cantly degraded such that it is no longer of any value to the attacker.
however the principle of stealth is inherently awed and in turn causes two consequences.
first the watermark recovery tool watermark recognizer that contains some forms of secret information e.g.
password special inputs used for watermark recovery is kept con dential from the public.
it means that unlike traditional watermarking existing software watermarking approaches cannot enable normal users to perform watermark veri cation instead it solely relies on a small number of authorities who have access to the con dential watermark recognizer.
although software watermarking techniques have been developed for many years in practice no such authorities actually exist.
we believe that android markets do not have strong enough incentives to become such a liable authority.
nevertheless the originality of android apps is a serious concern for developers and users.
second previous experience in watermarking design has shown us that it is non trivial to ensure absolute stealth .
once a program resides in an attackers machine attackers can use any conceivable techniques to approximately locate the watermarks.
for example it is well known that static watermarking is highly susceptible to semantics preserving transformation attacks.
dynamic watermarking while yielding a certain degree of resilience to semantics preserving transformation attacks relies on the stealth of runtime states e.g.
bogus graph data structure .
once a subset of these runtime states are detected and scrambled by the attacker the watermark is ruined and rendered useless.
.
overview to overcome the limitations of existing watermarking methods droidmarking is designed to be a non stealthy watermarking technique in other words the purpose is not tohide watermarks.
in fact it is fairly easy to locate the watermarks in an android app program.
to defend against watermarking evading attacks droidmarking is based on a primitive called self decrypting code sdc which makes it di cult to de couple the two without signi cant e orts and costs for attackers.
.
problem statement and assumptions in watermark embedding our scheme takes as input an app program aand the original developer s watermark instancew and outputs a watermarked app program a0such thata0is semantically equivalent to a i.e.a0 e a w wheree is the watermark embedding function.
in the watermark recognition phase a set of watermark instances may consists of multiple ws denoted by is recovered from program a0and collected by a watermark recognizer i.e.
d a0 .
represents a series of user inputs and interactions to app a0.d is watermark extraction function called by a0in response to user inputs .
lett a0 denotes the app program after code transformations performed by an attacker and 0denote the set of watermark instances recovered from t a0 i.e.
d t a0 .
we say the original watermark instance wis successfully recovered even subject to code transformations i andw2 denotes an empty set.
in other words successful watermark recovery ensures that at least one watermark instance wfrom original developer be recovered and collected by the watermark recognizer.
in addition our goal also requires wto be successfully recovered within an anticipated short period of time t. otherwise we call it failure to recover original watermark w. now we consider a set of watermarks recovered from an unknown app a i.e.
d a awatermark con ict occurs if 9w1 w22 andw16 w2.
a watermark con ict unquestionably indicates that aincludes di erent copyright information and hence is a repackaged app.
we assume that an original app developer has the app source code.
developers are concerned about their intellectual property and nancial interests and thus are motivated to apply protection schemes against potential piracy acts.
android users however are divided into two classes with respect to their care and caution to the originality of the apps concerned users andcausal users .
concerned users are prudent about their privacy and cyber security and are willing to build trust with newly installed apps rst whereas casual users do not bother to care.
droidmarking draws the joint e orts from original developers concerned users and android markets to defend against app repackaging threats.
we assume that attackers can use any conceivable static or dynamic analysis tools to examine the compiled app program bytecode and native binary line by line and make any code transformations necessary aiming to remove original watermarks render watermarks infeasible to be recovered or even add attackers own watermarks to the app.
a determined attacker may also carefully infer the program semantics and re write part of the app program or in the extreme cases the whole app program.
however the cost of re writing the app may outweigh the value of the repackaged app itself.
we assume cash interests driven attackers are interested in repackaging an app only if the cost of repackaging is less than the value it adds.
in that case an attacker may w w d d z d d z nj h z h y k z figure deployment model of droidmarking system li xul vwduwvzlwk 3vpws rgh d li zhljkw khljkw !
rgh e figure examples of candidate branches.
even be willing to sacri ce certain functionality and value of the original app as long as the cost e cacy still holds.
the plagiarized app can be distributed by the attacker either in the same market as the original app or across di erent markets.
.
architecture figure shows the overall deployment model and architecture of the droidmarking system.
droidmarking is comprised of three major components as highlighted in figure for the three stakeholders respectively droidmark embedder dm embedder used by developers droidmark recognizer dm recognizer installed on user devices and droidmark scanner dm scanner employed by android market.
an app developer feeds app source code aas input to dm embedder.
dm embedder embeds watermarks into the code and nally outputs a dex le executable for dalvik virtual machine on android system .
the dex le is then packaged with libsdc a native library used in our watermarking scheme and other app resources to an apk le for publication application package .
before publishing the app packages to the app store android market conducts a quick static scan to the dex le to insure the valid and correct use of the dm embedder.
those who fail dm scanning are subject to misuse or evading attacks see section and are rejected by the market.
when users install the app on their devices and use the app the embedded watermarks are automatically recovered.
dm recognizer residing on user devices is responsible for harvesting the recovered watermark instances from the app and alerting the user and or android market immediately when an repackaging threat is detected.
in the next section we will discuss in detail the design and implementation of these three components respectively.
.
design and implementation .
self decrypting code droidmarking is based on a primitive called self decrypting code sdc which was rst proposed by sharif et al.
for malware obfuscation and has nothing to do with watermarking.
a sdc segment is created from a special type of branch from the app code.
figure shows two examples of these types of branches in android apps.
the two common proper 35dqgb6wulqj hqfu sw 9du li ghfu sw 9du li 9du rqvw d dqglgdwh udqfk e 6hjphqw khuh hqfu sw rqvw hqfu sw rqvw figure example of self decrypting code sdc segment.
ties in the examples are that both examples use equality test such as operator startswith endswith or equals routines as one of the conditions to enter the branch one of the equality test operands is a constant numerical string value.
we call the branches that have these branch conditions candidate branches.
an sdc segment is created from a candidate branch as illustrated in figure .
in this example the original branch condition var const in figure a is transformed to an equivalent condition v m in figure b .
the operands v andmof the equality test are created by performing encryption on the same randomly generated string s. one encryption is performed at runtime at line i.e.
v encrypt s var where var is used as the key for this encryption operation.
another encryption is pre computed o ine i.e.
m encrypt s const where const is the key.
as a result v m holds only when var const.
const is also used as the key to encrypt the original candidate branch code block cto a cipher code block ec.
note that by using the equivalent condition v m the constant const also the key to encrypt c has been removed from the code.
as shown in figure b we de ne the new branch condition as well as the cipher code inside the branch as a sdc segment.
during runtime ecis only reached when the equivalent condition is satis ed upon var const.
when this happens var is immediately used as the key to decrypt ec line .
ecis then replaced by the resulting decrypted branch code csuch that the execution of code cproceeds normally.
in droidmarking we embed watermark code snippets in branch code cof all candidate branches and create sdc segments accordingly.
by this means we build the interdependency between watermarks and original branch code such that it is infeasible to de couple the two within a cipher code block unless one rst decrypts it.
knowledge asymmetry property of sdc this property provided by sdc says that the original developer knows both the constant value const of the original branch condition and the enclosed branch code c that this constant value could lead to.
in contrast an attacker does not know this at all until the dynamic execution of the app program d td d d d figure work ow of droidmarking embedder.
happens to go into the sdc branch.
this property is the fundamental reason why our software watermarks can be inter dependent with original branch code and become non stealthy yet still resilient to evading attacks.
.
dm embedder in the watermark embedding phase the dm embedder helps embed watermarks into an app program for developers.
the dm embedder takes app source code as input and takes three steps to output a watermarked dex le watermark code snippet generation nding sdc candidate branches and embedding watermark code snippet into sdc segments.
figure shows the work ow and modules of the dm embedder.
module wm initiator handles step and and outputs intermediate im source code.
the following compiling process of im source code is intervened and a modi ed dx compiler a tool used for compiling java bytecode to dalvik bytecode takes care of step .
we now present the design and implementation of these three steps respectively.
.
.
watermark code snippet generation the most important piece of information in a watermark instance is a unique developer identi er.
on the android platform every installed app must be self signed by the developer with a certi cate whose private key is held by the app developer.
the whole purpose of app signing is to allow the android system to uniquely identify the developer of an app which is used for authenticating app updates and building trust among apps from the same developer.
the public key certi cate is distributed with apk le contained in selfsigned x. certi cate meta inf cert.rsa for signature veri cation signature le meta inf cert.sf by the android system upon app installation.
to this end we use public key certi cates as the key information for a watermark as it is uniquely distinguishable for developer identity either personal or organizational and easily attainable from the app package.
wm initiator o ine generates a watermark code snippet as shown in figure that can dynamically create a watermark instance at runtime.
as shown in the code snippet a watermark instance is an intent object line an java object developer uses to send messages between app components on the android system.
multiple pieces of watermark information are stored in the intent object as key value pairs line to cer developer s pubic key certi cate pid pid of running app pck app package name iss certi cate issuer developer and tim time of watermark assertion.
it is important that the public key certi cate be the same one whose private key will be used next for signing the app.
the watermark code snippet then explicitly sets an service com.dmrecognizer.dmservice service in dm recognizer to receive and handle the intent line .
this intent watermark instance is then sent to dqgurlg frqwhqw qwhqw zp qhz dqgurlg frqwhqw qwhqw zp sxw wud 3fhu sxeolf nh fhuwlilfdwh!
lqw slg dqgurlg rv 3urfhvv p 3lg zp sxw wud 3slg slg zp sxw wud 3sfn 3frp sdfndjh dssqdph zp sxw wud 3lvv qgurlg hexj qgurlg zp sxw wud 3wlp zp vhw rpsrqhqw qhz dqgurlg frqwhqw rpsrqhqw1dph 3frp gpuhfrjql hu 3frp gpuhfrjql hu gp6huylfh frqwh w vwduw6huylfh zp figure watermark code snippet.
the dm recognizer by calling startservice function line .
we will discuss dm recognizer in more detail in section .
.
this watermark code snippet will be embedded into every candidate branch found in section .
.
.
.
.
finding candidate branches in this step wm initiator aims to nd all candidate branches in the app source code that can be used to carry watermark code snippet.
wm initiator statically analyzes the source code and determines the following types of ifcandidate branch conditions equal to operator string comparison routines such as startswith endswith and equals not equal operator !
and multiple simple conditions combined by andjjoperators.
type and conditions we called simple conditions can be directly transformed to sdc segments as described in section .
.
.
type and conditions must rst be transformed to simple conditions.
.
.
watermark embedding in this step the watermark code snippet generated in section .
.
is embedded into all candidate branches found in section .
.
.
these watermark carrying candidate branches are then transformed to sdc segments.
watermark code snippet embedding.
figure shows how wm initiator embeds the watermark code snippet into a candidate branch and generates the intermediate im code a .
wm initiator appends watermark code snippet wm right before the branch code c and inserts special bogus expressions at line and respectively in figure b as the begin and end marker of this combined code block.
as we will see these markers will be used for sdc segment generation and kept in the nal executable.
as we have already seen in section .
we replace condition var const with semantic equivalent condition v m where m encrypt s const such that the branch code encryption key const in figure a is removed from the nal executable.
for now the encryption key const is temporarily retained in im code right before the begin marker and will be removed after being used for code encryption.
we also insert sdc decrypt function call at the beginning of branch code in line .
sdc decrypt is a java function call to our native library libsdc via java native interface jni .
this library is responsible for decrypting the cipher code block once the branch condition is satis ed.
so far wm initiator has nished all its jobs and has generated watermarked im source code which will be compiled by javac and then passed to our modi ed dx compiler for sdc segments generation.
sdc segment generation.
this is the nal stage of dm embedding process where the transformed candidate branches in im code are encrypted and transformed by dx 35dqgb6wulqj hqfu sw 9du li vgfbghfu sw rii ohq 9du nh rqvw li 9du rqvw d 6rxufh rgh e 6rxufh rgh hqg !
ehjlq !
hqfu sw rqvw figure embedding watermark code snippet into a candidate branch.
compiler to sdc segments in the output dex executable.
dx compiler is a tool used to convert java class les to a dex le which contains the code data and