tracing software build processes to uncover license compliance inconsistencies sander van der burg delft university of technology netherlands s.vanderburg tudelft.nleelco dolstra logicblox inc. usa eelco.dolstra logicblox.comshane mcintosh queen s university canada mcintosh cs.queensu.ca julius davies university of british columbia canada juliusd cs.ubc.cadaniel m. german university of victoria canada dmg uvic.caarmijn hemel tjaldur software governance solutions netherlands info tjaldur.nl abstract open source software oss components form the basis for many software systems.
while the use of oss components accelerates development client systems must comply with the license terms of the oss components that they use.
failure to do so exposes client system distributors to possible litigation from copyright holders.
yet despite the importance of license compliance tool support for license compliance assessment is lacking.
in this paper we propose an approach to construct and analyze the concrete build dependency graph cbdg of a software system by tracing system calls that occur at build time.
through a case study of seven open source systems we show that the constructed cbdgs accurately classify sources as included in or excluded from deliverables with precision and recall and can uncover license compliance inconsistencies in real software systems two of which prompted code xes in the cups and ffmpeg systems.
categories and subject descriptors k. .
hardware software protection copyrights licensing keywords license compliance build systems .
introduction nowadays software developers improve development efciency by reusing oss components libraries and frameworks.
these reusable components are released under a variety of di erent licenses ranging from the simple and permissive bsd and mit style licenses that allow client systems to include components without publishing any source code permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
the more restrictive gpl and mpl style licenses that impose license requirements on client systems i.e.
derived works .
due to the intricacies of oss licenses it may not be legally permissible to combine certain oss components with client system code.
client systems that are released under licenses that are incompatible with the licenses of the oss components that are used to build them are said to have a license mismatch problem .
failure to comply with the license terms of reused external components makes the distribution of client system deliverables a potential copyright violation opening client system distributors up to litigation by copyright holders .
to ensure that a client system is compliant with the license terms of reused external components one must not only understand which licenses govern the reuse these components but also how they are combined with the source code of the client system.
for example statically linking to external components released under a gpl style license stipulates that the source code of the client system deliverable be released under a gpl style license as well.
in order to perform a license compliance assessment on a client system one must know for each deliverable being created which source les of the client system are being used which external components are being used and how the client source code and external components are being combined.
we therefore trace and record each step taken during the build process in order to construct a concrete build dependency graph cbdg i.e.
a graph that represents the actual dependencies of the client system deliverables.
since build speci cations may not explicitly denote all of the client system dependencies we construct cbdgs by tracing the operating system calls made by build tools during their execution.
we annotate the source le nodes in the cbdg with their respective licenses and analyze the cbdg to detect license compliance inconsistencies.
in order to evaluate our license compliance assessment approach we perform a case study of seven open source systems and address the following two research questions rq1 does our approach accurately identify the sources that are included in constructed deliverables?
removing the source les that appear in the cbdg truly causes changes in build behaviour in of cases precision .
conversely removing the source les that do not appear in the cbdg does not cause changes in build behaviour in of cases recall .
rq2 does our approach reveal license mismatch issues?
analysis of the constructed cbdgs reveals license mismatch issues that prompted rapid bug xes in theffmpeg and cups systems.
the main technical contributions of this paper are the de nition of the cbdg which explicitly describes the steps performed when creating deliverables.
both internal which client system source les are being used and external dependencies e.g.
libraries can be extracted from the cbdg.
an approach for constructing a cbdg from traces of operating system calls made during a build execution.
an approach to analyze a cbdg to identify license compliance inconsistencies in client systems.
paper organization.
the remainder of this paper is organized as follows.
section outlines the challenges associated with license compliance assessment.
section describes our cbdg based approach to license compliance assessment.
section presents the design of the empirical study that we performed to evaluate the accuracy and usefulness of our license compliance assessment approach while section presents the results.
we discuss the limitations of our approach and its empirical evaluation in section .
section surveys related work.
finally section draws conclusions and discusses potential avenues for future work.
.
challenges of license compliance assessment license compliance assessment i.e.
the process of detecting inconsistencies in the license terms of an external component and its reuse by a client system is nontrivial .
figure provides an overview of the challenges of the assessment process.
we brie y describe each challenge below.
challenge identifying included source les.
oss packages i.e.
collections of related oss components are composed of several source code les that often have different potentially incompatible licenses.
in recent work we found that of the packages in the fedora distribution are heterogeneously licensed with more than one license appearing in their source les .
determining the license that takes precedence over the others in heterogeneously licensed components is often dependent on the con guration of the build system.
for example the freebsd kernel is normally released under the permissive bsd license.
however the source code for the freebsd kernel includes restrictively licensed gplv2 source les which are con gured to be excluded from the freebsd kernel by default.
if the gplv2 code is con gured to be included in the freebsd kernel its license changes from bsd2 to gplv2.
hence knowing which source les are included in and excluded from the build process is an important challenge to overcome for license compliance assessment.
challenge identifying used external components.
while external components that are required by the client source filescompilationinclude files compilation linking linkinglibraries object filesexternal components library executable deliverables unused challenge identify how source f iles and external components are combined using compilers linkers scripts etc.
challenge identify used external components challenge identify used f ilesbuild processfigure challenges of license compliance assessment.
system are typically listed in product documentation this documentation is often incomplete i.e.
missing dependencies such as those recursively used to create the external components that are used by the client system or out of date i.e.
incorrect dependencies such as those that are no longer used.
for example in recent work we identi ed an error in the build system of the php package in fedora where a deliverable was mistakenly being linked to a gplv2 licensed component .
linking to this gplv2 component caused the gplv2 license to take precedence over the php license for several php deliverables.
the build system was later corrected to link the php deliverables with an external component that is compatible with the php license.
indeed the external components used to assemble client system deliverables impose restrictions on the license that the client system can be released under.
challenge identify how source les and external components are combined.
the method by which client source code is combined with external components also has an impact on the license constraints that apply to the client system .
for example external components that are released under the gpl license transitively apply the gpl license to client system deliverables that statically link with them i.e.
client system deliverable must also be distributed under the gpl license if a gpl component is statically linked with it however if instead of using static linking components are connected using rpc or a web api then the resulting client system might not be required to be licensed under the gpl .
.
addressing the challenges of license compliance assessment the challenges of license compliance assessment listed above highlight that the legal constraints that are imposed on the distribution of client systems depend not only upon which internal source les and external components are used challenges and but also upon how these sources are combined to produce client system deliverables challenge .
732patchelf patchelf.o g patchelf.o o patchelf patchelf.o patchelf.cc g c patchelf.cc o patchelf.o denable foo install patchelf install patchelf usr bin a the simpli ed make le.
usr bin patchelf patchelf.cc g patchelf.o g patchelf install b the build dependency graph extracted from the make le.
figure the patchelf make le and corresponding dependency graph.
the build system of a software project speci es this process of translating sources into deliverables.
when executed build tools orchestrate the order dependent execution of compilers and other tools in order to correctly produce deliverables according to build speci cations.
while it may seem natural that one could apply static analysis to the build system to address these challenges this approach is fraught with peril.
first there are several build technologies abound such as the countless variants of make ant maven and gradle for java systems language speci c scriptable formalisms such as python s setuptools or ruby s rake and abstraction based build technologies like gnu autotools or perl s makemaker that allow developers to express build dependencies using abstractions and use platform and con guration speci cs to generate appropriate low level build speci cations.
furthermore a static analysis of the build system will likely produce an incomplete picture of the concrete client system dependencies.
consider for instance the patchelf utility for manipulating unix executables.1patchelf consists of a single c source le patchelf.cc.
figure shows a simpli ed version of the build system of patchelf speci ed using make .
figure 2a shows the build speci cation that describes how patchelf.cc is compiled into patchelf.o linked into patchelf and installed into usr bin patchelf.
static analysis of figure 2a will produce a build dependency graph figure 2b i.e.
a directed acyclic graph describing the sources deliverables and intermediate les as circular nodes the commands that update deliverables or intermediate les as square nodes and the ordering requirements for these commands as edges .
while figure 2b provides useful information it does not address the license compliance assessment challenges header le nodes are missing challenge the patchelf.cc source le includes elf.h yet since the build system does not express this relationship it is missing from figure 2b.
this relationship is especially important for license compliance assessment in this case since the elf.hheader le that was actually copied from the gnu c library.
external component nodes are missing challenges and the link command that produces deliverable does not list automatically linked system libraries which also have licensing implications.
phony targets may mask the build step that was performed challenge the install target does not denote that it generates usr bin patchelf deliverable.
hence the link between the usr bin patchelf deliverable and the patchelf intermediate le would need to be inferred.
a static analysis of build systems for license compliance assessment would therefore not only need to process the various types of build speci cations but would also need a context speci c understanding of the source code to uncover header le dependencies and the executed commands to uncover implicitly linked libraries and build rule side e ects .
to avoid the pitfalls of static analysis we use dynamic analysis of build behaviour to perform license compliance assessment.
rather than constructing a build dependency graph from the build speci cations our approach constructs a concrete build dependency graph cbdg that contains all of the information that is missing in figure 2b.
moreover our cbdg based approach is technologyagnostic and can be applied to build systems speci ed using any technology.
.
license compliance assessment approach in order to detect the license compliance inconsistencies we construct and analyze the cbdg of a software system.
as shown in figure the process is divided into four steps.
we describe each step below.
.
license identification we rst identify the licenses that govern each of the source les of a client system.
to do so we use ninka an open source license identi cation tool that analyses sentences in source code comments.2ninka is capable of identifying more than di erent licenses.
performing this step produces a mapping of source les to licenses.
.
build trace collection in order to address the challenges of license compliance assessment outlined in section the cbdg must describe which client sources and external components are used and how they are combined to create the client system deliverables.
to achieve this we record which les are read and written by each step in the build process.
speci cally we trace the operating system calls i.e.
calls made by user processes to the operating system kernel that are made while the build is executing.
these system calls provide userspace processes with access to system resources like lesystems.
the necessary tools for collecting system call traces are already available for most conventional operating systems such as linux freebsd mac os x and windows.
to illustrate why system call traces will be useful for license compliance assessment we use the example of tracing the system calls made when executing make install using the patchelf make le shown in figure 2a.
on linux this can be done using the strace command3as follows strace f make 733license compliance assessment license compliance reportdatabase of dependency and license informationbuild trace collectionlibavfilter vf pixdesctest.o arccobjkkj.s libavfilter graphparser .occqecdzd.s ccnvs3fe.s as libavfilter vf crop.occnogffg.s asccdfme6l.s as ccukjxbk.sccfzvj3t.s as libavfilter vf transpose.o as libavfilter vf pad.olibavfilter allfilters.olibavfilter vf aspect.o ccaokvoq.s as ccjlby8h.sccrthbem.s as as libavfilter vsrc movie.occfnq88b.s ccuxevsb.s aslibavfilter vf fifo.o libavfilter libavfilter .a installcctu862u.s as cc37sui5.s aslibavfilter vf drawbox.oas as libavfilter vf scale.olibavfilter formats.o libavfilter avfilter .oas libavfilter vf gradfun.occkrg5ty .s ccnemnqz.scc1ahjc5.s cchyxd8k.s asccofgub7.s asranlibas libavfilter af anull.o libavfilter vsrc nullsrc.oas libavfilter vf setpts.o libavfilter libavfilter .acccsex5u.s ccy8vbmp.s as ccd9lx4r.s asccesa7p0.sasas as ccxg6mno.s aslibavfilter vf fieldorder .oas libavfilter vf overlay .olibavfilter defaults.occh5ctfw.s cc8wjsdk.s asasas ccvrboni.sas libavfilter x86 gradfun.o libavfilter vsrc color .olibavfilter vf slicify .o ccmkusu4.s ccwyakn2.sccq3hzpi.s asas libavfilter asink anullsink.o libavfilter vf vflip.o libavfilter vf settb.olibavfilter vsink nullsink.o cc8e2ndb.s aslibavfilter vf null.o lib libavfilter .a as libavfilter vf hflip.olib libavfilter .a ranliblibavfilter vf format.o as ccasncaq.sas libavfilter vf unsharp.o libavfilter avfilter graph.o ccjntubq.slibavfilter vf copy .o as libavfilter vf fade.olibavfilter asrc anullsrc.o libavfilter drawutils.o libavfilter vsrc buf fer.occtsau9j.sccdsvcil.sccbkzhtx.s cc70bpn3.s as graph construction source package ntrace outputlicense identi f ication license info of fileslibavfilter vf pixdesctest.o arccobjkkj.s libavfilter graphparser .occqecdzd.s ccnvs3fe.s as libavfilter vf crop.occnogffg.s asccdfme6l.s as ccukjxbk.sccfzvj3t.s as libavfilter vf transpose.o as libavfilter vf pad.olibavfilter allfilters.olibavfilter vf aspect.o ccaokvoq.s as ccjlby8h.sccrthbem.s as as libavfilter vsrc movie.occfnq88b.s ccuxevsb.s aslibavfilter vf fifo.o libavfilter libavfilter .a installcctu862u.s as cc37sui5.s aslibavfilter vf drawbox.oas as libavfilter vf scale.olibavfilter formats.o libavfilter avfilter .oas libavfilter vf gradfun.occkrg5ty .s ccnemnqz.scc1ahjc5.s cchyxd8k.s asccofgub7.s asranlibas libavfilter af anull.o libavfilter vsrc nullsrc.oas libavfilter vf setpts.o libavfilter libavfilter .acccsex5u.s ccy8vbmp.s as ccd9lx4r.s asccesa7p0.sasas as ccxg6mno.s aslibavfilter vf fieldorder .oas libavfilter vf overlay .olibavfilter defaults.occh5ctfw.s cc8wjsdk.s asasas ccvrboni.sas libavfilter x86 gradfun.o libavfilter vsrc color .olibavfilter vf slicify .o ccmkusu4.s ccwyakn2.sccq3hzpi.s asas libavfilter asink anullsink.o libavfilter vf vflip.o libavfilter vf settb.olibavfilter vsink nullsink.o cc8e2ndb.s aslibavfilter vf null.o lib libavfilter .a as libavfilter vf hflip.olib libavfilter .a ranliblibavfilter vf format.o as ccasncaq.sas libavfilter vf unsharp.o libavfilter avfilter graph.o ccjntubq.slibavfilter vf copy .o as libavfilter vf fade.olibavfilter asrc anullsrc.o libavfilter drawutils.o libavfilter vsrc buf fer.occtsau9j.sccdsvcil.sccbkzhtx.s cc70bpn3.s as graph construction sourcepackage traceoutputconcrete build dependency graphlicense identi f icationlicense info of files concrete build dependency graphbuild trace collectionfigure an overview of our license compliance assessment approach.
install.
the f ag instructs the strace command to record system calls made by child processes of the make install command as well.
the make install command will rst spawn a process to run g in order to compile patchelf.o.
since this process will write to the patchelf.o le it will at some point issue the system call open patchelf.o o rdwr o creat o trunc furthermore because g must read the patchelf.cc source le and all of the headers that it includes the trace will include system calls such as open patchelf.cc o rdonly open usr include c .
.
string o rdonly o noctty open elf.h o rdonly after compiling the linker needs to read patchelf.o as well as the libraries and object les such as usr lib libc.so usr lib libc non shared.a and usr lib crtn.o in order to write patchelf.
finally the install command will read .
patchelf and write usr bin patchelf.
thus the system call trace contains all of the necessary information to derive the cbdg for the usr bin patchelf deliverable.
narrowing the scope of traced system calls.
since large projects have complex build systems that can take hours to build the output of strace can be extremely large.
for performance reasons we select only the following types of system calls for cbdg construction system calls that take le name arguments e.g.
open rename and execve .
system calls related to process management e.g.
vfork execve and vfork .
.
graph construction we parse the collected system call traces of build processes in order to construct the cbdg.
formally the cbdg isde ned as cbdg v e where v vt vf the union oftask nodes vt i.e.
steps in the build process and le nodes vf i.e.
the les that are read by or created during the build process .
the granularity of a task node can vary depending on the level of detail required e.g.
vtcould be the set of build commands or operating system processes.
each taskt2vtis de ned as an ordered tuple htid i where tid2tids is a symbol that uniquely identi es t. additional information can also be included in the task tuple e.g.
the name of the program s invoked by the task .
a le node f2vfis also represented using a tuple h d path licensei where d2fids is a symbol that uniquely identi es f path is the le s path and license is the license that we identi ed forfusing ninka cf.
section .
.
each task t2vtrepresents a process that was executed during a build.
information about each tis stored in a htid program argsituple where program is the path of the last program executed by the task i.e.
the last program loaded into the process s address space by execve or the program inherited from the parent and argsis the sequence of command line arguments.
our cbdg constructor assembles the cbdg by reading each build trace line by line.
when a new process is created in the trace a corresponding task node tis added to vt. when a task treads a le fin the trace we add ftovf if it did not already exist and an edge from ftot.
similarly when a process opens a le for writing in the trace we add a le node ftovf and an edge from the task node to f. implementation details.
there are several intricacies of system call traces that must be carefully handled when constructing cbdgs relative paths must be normalized with respect to the current working directory cwd of the calling process.
thus we must keep track of the current working directory by processing chdir calls.
since thecwdis inherited by child processes our cbdg constructor must also keep track of parent child process 734patchelf .
bin patchelfpatchelf .
.tar.bz2 tar strip install patchelf .
bin patchelf ld patchelfas patchelf.o cc1plus ccopovgb.self.h patchelf.cc gcc crtbegin.o gcc crtend.o gcc ...elided... linux headers errno base.h linux headers errno.h linux headers ...elided... glibc include g config.h glibc include alloca.h glibc ...elided... figure the patchelf dependency graph.
external dependencies are depicted in white.
relations and propagate the cwd of the parent to the child when it encounters a fork operation.
process ids pids may be reused while performing a build.
in fact this occurs frequently in the build traces of large packages because pids are by default limited to in linux.
since cbdg analysis needs to distinguish between di erent processes that had the same pid pids are not used as unique tids in the cbdg.
instead a unique tid is generated every time a process creation operation is encountered.
while we do need to track system libraries that are dynamically linked to client system deliverables cbdgs do not need to contain dynamic libraries that are loaded by the tools used during the build execution.
this is because the loading of a dynamic library by a build tool rarely has license compliance implications.
we observed that after the dynamic loader has opened all shared libraries it issues an arch prctl system call on x86 64 linux systems to set the bit base for the fs segment register that is internally used by glibc.
thus to lter away system calls made due to the loading of a dynamic library we ignore any open system calls performed between a call to execve and arch prctl .
files may be written more than once during a single build.
hence a le s path may not uniquely identify an instance of a le in the cbdg.
for example a deliverable can be written by rst linking client code with external components and then later postprocessed by a command like strip which removes debugging symbols.
represented naively this scenario would yield the following subgraph install usr bin patchelf strip cycles in the cbdg muddle the data ow especially if there are multiple processes that update a le the order that these processes occur in is impossible to discern.
therefore we create a new node for each modi cation that a le undergoes.
file nodes are disambiguated by tagging them with the id of the task that created them as shown below install usr bin patchelf strip usr bin patchelf handling coarse grained processes.
system call tracing identi es inputs and outputs at the granularity of unix processes.
an underlying assumption is that every process is part of at most one conceptual build step.
however this is not always the case.
for example consider the command cp foo bar usr bin .
this command installs two les in the usr bin directory.
although conceptually these are two build steps since they are executed by a single process the following subgraph is generated foo cp usr bin foo usr bin bar bar this is undesirable because fooand its sources now appear as dependencies of usr bin bar even if the two programs are otherwise unrelated.
we handle such coarse grained processes that may perform multiple build steps at once e.g.
cpand install on a case bycase basis by adjusting the cbdg as follows.
first we scan the cbdg for the set of known coarse grained processes that have more than one output le and each output le has the same base name as an input le.
we then replace this task node with a set of task nodes one for each pair of corresponding input and output les e.g.
bar cp usr bin barfoo cp usr bin foo note that both cptasks in this graph correspond to the same process in the trace.
example the patchelf cbdg.
as with most unix packages building the patchelf package starts with unpacking the source code distribution i.e.
patchelf .
.tar.bz2 running its configure script running make and nally running make install.
figure shows the cbdg resulting from analyzing the trace of a build of this package.
comparing figure with figure 2b i.e.
the graph constructed using static analysis shows that the cbdg exposes dependencies that patchelf.cc not only has on elf.h but also on numerous header les from glibc and the linux kernel.
similarly the linker loads several object les and libraries from glibc and gcc that were invisible to the static analysis.
the cbdg also reveals that the installed version of usr bin patchelf is rewritten by strip.
735table an overview of the studied systems.
package version domain size sloc yfiles aterm .
program transformation .5k opkg .
.
software package management .2k bash .
command shell .7k cups .
.
printer management .8k xalan .
.
xml processing .0k openssl .
.0d digital communication security .0k ffmpeg .
rc1 multimedia processing .2k ynon comment non whitespace lines of code calculated using sloccount .
license compliance assessment we then use the constructed cbdg to perform license compliance assessment for a given deliverable.
the process is divided into three steps step identify the les f vfthat are included in a deliverable d.we do so using the following logic f2vfjdeg f 9a path in gfrom ftod note that if this logic is applied to a raw cbdg the list of source les will include source distribution les e.g.
patchelf .
.tar.bz2 and omit the source les that were contained within it e.g.
patchelf.cc .
while this set of source les is technically correct i.e.
patchelf .
.tar.bz2 is the sole source of the patchelf package it is not useful for license compliance assessment.
to address this we further lter task nodes such as tar and its edges out of the cbdg.
applying the search logic to the ltered patchelf cbdg this yields the following set of source les fpatchelf cc elf h errno base.h errno h g step identify the licenses of the les f vfthat are included in deliverable d.we used ninka to determine the licenses of each source le identi ed by step .
we identify the licenses that govern the external components which we did not have source code for by examining product documentation.
this license information is denoted in the le node tuples in the cbdg.
hence the cbdg nodes selected by step also contain their license details.
step identify how external components are combined with client deliverables.
finally we detect how each external component is combined with client deliverables by scanning the process nodes on the path connecting an external source with a client deliverable.
for instance some lawyers consider that statically linking external components imposes more restrictive legal constraints than dynamic linking does.4hence we can ag the source les of external components that are statically or dynamically linked into client deliverables for further analysis.
.
empirical study design we performed an empirical study to evaluate the accuracy and usefulness of our license compliance assessment approach.
to structure the study we formulate the following two research questions 4for example larry rosen shares this view however the free software foundation considers static and dynamic linking to be equivalent .
rq1 does our approach accurately identify the sources that are included in constructed deliverables?
before the results of our license compliance assessment approach can be validated we must rst ensure that the generated cbdg accurately re ects the build processes of the studied systems.
rq2 does our approach reveal license mismatch issues?
while license compliance assessment using the cbdg may work in theory it is not clear whether license compliance inconsistencies can actually be uncovered using it.
hence we set out to detect real world licensing issues using our approach.
.
studied systems we study seven open source systems in order to address our research questions.
we study systems of various sizes and domains to combat potential bias in our results.
table provides an overview of the studied systems.
aterm enables creation and manipulation of annotated terms in c source code.
opkg is a lightweight package manager used to download and install openwrt packages.
bash is the gnu implementation of the bourne again shell bash a unix command shell.
cups is a common system for interfacing with printers developed by apple inc. for unix.
xalan is an xslt processor for transforming xml documents into html text or other xml document types.
openssl is a toolkit implementing the secure sockets layer ssl v2 v3 and transport layer security tls v1 protocols.
ffmpeg is a package used to record convert and stream audio and video.
.
empirical study results in this section we present the results of our empirical study with respect to our two research questions.
for each research question we rst present our approach to addressing the question then present the results that we observe in the studied systems and nally discuss the broader implications of our ndings.
rq1 does our approach accurately identify the sources that are included in constructed deliverables?
approach.
we evaluate how accurately the constructed cbdgs classify les as being included in or excluded from the build process.
a le is classi ed as included if it appears in the cbdg otherwise it is classi ed as excluded.
736table results of rq1 cbdgs provide very high recall and precision.
package files false false recall precision all source les excluded included included negatives positives aterm opkg bash cups xalan openssl ffmpeg we use the build output and status to establish the ground truth for our evaluation by executing a clean build after removing each source le in the studied systems.
we refer to these builds as the removed builds .
if the removed build for a source le xexecutes without error then the removal ofxhad no impact on the build output and xis recorded as excluded from the build process.
on the other hand if the removed build for le xhas an error then xhad an impact on the build output and we mark xas being included in the build process.
we measure the accuracy of a cbdg by comparing the ground truth for each le to the les that appear in the cbdg for each studied system.
we use four metrics to measure the accuracy of a cbdg false negatives files that are excluded from the cbdg but actually have an impact on the build process.
false positives files that are included in the cbdg but do not have an impact on the build process.
recall the proportion of the les that have an impact on the build process that are included in the cbdg.
precision the proportion of false positives in the cbdg.
results.
cbdgs contain very few false negatives and hence have very high recall.
table shows that we only observe a total of false negative in the seven studied systems.
we manually investigate the root cause of these false negatives by inspecting the build speci cations.
we nd that les often appear as false negatives in the cbdg due to errors in the build speci cations.
for example the build speci cations of aterm opkg and cups check for the existence of these les yet they were never read or written by any of the processes spawned during the build.
on the other hand the number of false positives was slightly larger.
we again perform an inspection of the build speci cations in order to determine the root cause for these false positives.
the inspection revealed that these false positive les are used only if they were present.
if the false positive les were not present no error was issued but the output of the build is changed.
for example in bash the number of false positives was higher than the other packages because bash contains various localization les i.e.
.po les that translate the bash deliverables into many di erent languages.
the build system of bash processes any .po les that are present.
cbdgs can accurately determine whether a source le is included in or excluded from the build process with a recall of and precision of .discussion.
although beyond the scope of this paper the results of our false negative analysis suggest that cbdgs may also be useful for detecting errors in build speci cations.
if we use the cbdg as the ground truth to evaluate the removed build results the inverse of the experiment performed above we could detect errors in the build specications of studied systems.
we expand upon this and other uses of the cbdg in section .
rq2 does our approach reveal license mismatch issues?
approach.
we aim to detect inconsistencies between the license of the client deliverables and the external components that are used to create it.
a license of a deliverable is said to be inconsistent with an external component that is used to create it if the license of any le in an external component contains terms that cannot be satis ed by the terms of the license of the deliverable.
in recent work we analyzed the fedora distribution to understand how license auditing is performed .
one of the challenges we faced was determining which les are used to create a deliverable.
this is particularly important in systems that include les under di erent licenses that do not allow for their composition.
for example one deliverable that contains a le released under the bsd license and another le released under the gplv2 license.
this type of inconsistency can be detected using the cbdg.
any le that is a predecessor to a deliverable in the cbdg must have a license that is compatible with the license of the deliverable.
speci cally our license compliance assessment is performed using the following ve steps .
extract the licenses of each le in each of the studied systems using ninka.
.
identify the declared license of the client deliverables by examining product documentation i.e.
the license of the deliverables as stated by the authors of the software .
.
trace the build of each system and generate its cbdg.
.
annotate the cbdg le nodes with license information.
.
traverse the cbdg to identify the sources that are used to create the client deliverables.
.
mark client deliverables that contain sources that are released under incompatible licenses as inconsistencies.
in our prior study we identi ed three systems that appear to contain license incompatibilities.
737ffmpeg the license of the ffmpeg deliverables varies depending on the con guration ags that are speci ed prior to executing the build.
by default its deliverables are released under the lgplv2 license.
however when con gured using the appropriate ags the deliverables are released under the gplv2 license.
cups the cups deliverables are licensed under the permissive cups license.
the studied version .
.
contains three les backend scsi that are released under the bsd license which is not compatible with the cups license.
it is important to know whether any of these three les are being combined with cups licensed les during the build process.
bash the bash deliverables are licensed under the gplv3 .
however there is a source le examples loadables getconf.c that is released under the bsd license which is incompatible with the gplv3 .
again we would like to know if this le is combined with the gplv3 licensed les during the build process.
we perform a deeper analysis of these three systems using our approach to detect if there are truly inconsistencies that appear in the constructed deliverables.
we identify inconsistencies using our license compliance assessment approach cf.
section .
results.
we uncovered two lgplv2 vs gplv2 license compliance inconsistencies in ffmpeg.
by default ffmpeg is expected to create libraries and binary programs to be released under the lgplv2 license.
through cbdg analysis we found two inconsistencies i.e.
two les that are released under the gplv2 license that were being used during the default build process.
first libpostproc postprocess.h is a header le that is include throughout theffmpeg codebase.
however this header only contains de nitions of constants.
since constants are likely not copyrightable they are likely considered facts and not creative expression we believe this is a low risk violation.
however the second inconsistency in libavfilter x86 gradfun.c contains source code inlined assembly that was being compiled into the libavfilter library and redistributed with the ffmpeg deliverables.
by combining libavfilter x86 gradfun.c licensed under the gplv2 with the lgplv2 code requires libavfilter to also be released under the gplv2 license.
the cbdg of libavfilter is shown in figure and is a high risk violation.
to con rm that the libavfilter x86 gradfun.c inconsistency was of serious concern we contacted the ffmpeg development team.
they responded within hours.
the code in question was an optimized version of another function.
a developer quickly prepared a patch to disable its use and the original authors of libavfilter x86 gradfun.c were contacted to arrange relicensing of this le under the lgplv2.
.5three days later this le s license was changed to lgplv2 which is compatible with the lgplv2.
.
we identi ed three les that caused license compliance inconsistencies in cups.
speci cally backend scsij scsiirisjscsi linux .c were released under the bsd license and 4q4bhmcvojgxyfn3wyhb html libavfilter vf pixdesctest.o arcc1ccobjkkj.s libavfilter graphparser.occ1ccqecdzd.s ccnvs3fe.s as libavutil avassert.hcc1cc1glibc include bits wchar.h cc1cc1cc1 cc1 cc1 cc1cc1 cc1cc1 cc1 cc1cc1cc1 cc1cc1 cc1 cc1 cc1cc1 cc1cc1cc1 cc1cc1 cc1cc1 cc1cc1 cc1 cc1cc1 cc1cc1glibc include bits errno.h libavutil colorspace.hlibavutil rational.h nix store 3r8kfi33y3lbrsvlx8vzwm74h8178y35 gcc .
.
lib gcc x86 64 unknown linux gnu .
.
include stdint.h libavfilter vsrc nullsrc.clibavfilter vf crop.oconfigure configureglibc include gnu stubs .h ccnogffg.s asccdfme6l.s as ccukjxbk.s libavutil x86 intreadwrite.hlibavutil intmath.h libavutil intfloat readwrite.h ccfzvj3t.s as libavfilter vf transpose.o nix store 3r8kfi33y3lbrsvlx8vzwm74h8178y35 gcc .
.
lib gcc x86 64 unknown linux gnu .
.
include stddef.h as libavfilter vf pad.o glibc include time.hcplibavutil avconfig.h libavfilter allfilters.olibavfilter vf aspect.o ccaokvoq.s as ccjlby8h.sccrthbem.s as as libavfilter vsrc movie.occfnq88b.s glibc include bits stdio.h glibc include stdint.h glibc include sys cdefs.h glibc include wchar.hccuxevsb.s as config.maklibavfilter vf fifo.o libavutil audioconvert.hlibavfilter libavfilter.a libavfilter avfilter.ccctu862u.s as cc37sui5.s aslibavfilter vf drawbox.olibavfilter vf vflip.c libavfilter formats.c libavfilter graphparser.c libavfilter vsrc buffer.cas glibc include g config.h as libavfilter vf scale.o libavfilter internal.h libavcodec avcodec.hlibavutil error.hlibavfilter formats.o linuxheaders include asm errno.h libavfilter avfilter.oglibc include bits local lim.h glibc include bits endian.h libavfilter drawutils.cas libavfilter vf gradfun.occkrg5ty .s libavutil attributes.h libavutil eval.hccnemnqz.s libavutil imgutils.hcc1ahjc5.s glibc include bits huge valf.hcchyxd8k.s asffconf.umppvqpt.hccofgub7.s libavutil opt.has glibc include bits mathdef.hranlibas libavfilter af anull.o libavfilter vf scale.c libavfilter vf pad.ccat glibc include features.h linuxheaders include linux limits.hlibavfilter allfilters.c libavfilter vsrc movie.clibavfilter vsrc nullsrc.oas libavfilter vf settb.c libswscale swscale.h libavformat avformat.hlibavfilter vf setpts.o libavfilter libavfilter.a glibc include inttypes.h libavformat avio.hcccsex5u.s ccy8vbmp.s as ccd9lx4r.s aslibavfilter avfilter.h ccesa7p0.s nix store 3r8kfi33y3lbrsvlx8vzwm74h8178y35 gcc .
.
lib gcc x86 64 unknown linux gnu .
.
include fixed limits.h linuxheaders include linux errno.h libavutil libm.h glibc include string.hasas as ccxg6mno.s aslibavfilter vf fieldorder.o libavfilter x86 gradfun.oas glibc include limits.h libavfilter vf crop.clibavfilter vf overlay .olibavfilter vf format.c libavfilter defaults.occh5ctfw.s cc8wjsdk.s as glibc include bits string.h glibc include bits posix2 lim.hasaslibavfilter vf pixdesctest.c ccvrboni.s libavutil x86 intmath.h libavutil avstring.has libavfilter vsrc color.olibavfilter vf slicify .o ccmkusu4.s glibc include bits inf.h libavutil mem.h nix store 3r8kfi33y3lbrsvlx8vzwm74h8178y35 gcc .
.
lib gcc x86 64 unknown linux gnu .
.
include fixed syslimits.hccwyakn2.sccq3hzpi.s asas libavfilter asink anullsink.o glibc include bits string2.h libavfilter vf hflip.clibavfilter vf vflip.o libavfilter vf settb.olibavfilter asink anullsink.c libavutil avutil.h glibc include stdio.h glibc include math.h glibc include bits wordsize.h libavfilter defaults.clibavfilter vf null.c libavfilter vsink nullsink.olibavfilter avfiltergraph.cglibc include bits typesizes.h libavutil parseutils.hcp cc8e2ndb.s aslibavfilter vf null.o libavfilter vf transpose.clinuxheaders include asm generic errno base.hlibavfilter asrc anullsrc.c glibc include bits huge val.h lib libavfilter.a as libavfilter vf hflip.olib libavfilter.a ranlib glibc include bits time.hconfig.hlibavfilter vf copy .c glibc include gnu stubs.h libavfilter gradfun.hglibc include bits sys errlist.h libavfilter vf format.o as ccasncaq.slinuxheaders include asm generic errno.h aslibavutil log.h libavfilter vf unsharp.oglibc include libio.h libavfilter avfiltergraph.olibavfilter vf setpts.c ccjntubq.sglibc include bits posix1 lim.h libavfilter vf copy .o libavfilter x86 gradfun.caslibavfilter vf slicify .c glibc include stdlib.h libavfilter vf fade.o nix store 3r8kfi33y3lbrsvlx8vzwm74h8178y35 gcc .
.
lib gcc x86 64 unknown linux gnu .
.
include float.hcat ffconf.umppvqpt.hlibavfilter af anull.c libavfilter asrc anullsrc.o libavfilter drawutils.o libavfilter vsrc buffer.o libavutil x86 bswap.hlibavutil cpu.hlibavfilter vf unsharp.c libavutil pixdesc.hlibavutil samplefmt.h libavutil x86 timer.h cctsau9j.slibavfilter vsink nullsink.c ccdsvcil.s libavfilter drawutils.hlibavfilter vf fieldorder.cccbkzhtx.sglibc include ctype.h libavutil internal.h libavutil common.hlibavfilter vf fade.c libavfilter avfiltergraph.hglibc include bits stdio lim.h libavfilter vf gradfun.c libavfilter vf overlay .c nix store 3r8kfi33y3lbrsvlx8vzwm74h8178y35 gcc .
.
lib gcc x86 64 unknown linux gnu .
.
include stdarg.h cc70bpn3.s asglibc include bits mathcalls.h libavformat version.hlibavutil x86 cpu.hlibavutil timer.h libavutil pixfmt.h glibc include bits mathinline.h glibc include assert.h libavutil bswap.h libavfilter vsrc buffer.hglibc include endian.h glibc include bits huge vall.h libavcodec version.hlibavfilter vsrc color.clibavfilter vf fifo.c glibc include bits nan.h libavfilter vf drawbox.c libavutil intreadwrite.hlibavfilter vf aspect.c glibc include errno.h glibc include bits types.h libavutil mathematics.hfigure excerpt of the cbdg of libavfilter.
the library libavfilter is licensed under the lgplv2.
but required libavfilter x86 gradfun.c depicted in red licensed under the gplv2 .
we noti ed the ffmpeg team and they quickly corrected this inconsistency.
were incompatible with the permissive cups license.
according to the cbdg these les were used to create the backend scsi deliverable which is distributed with the cups deliverables.
to con rm this inconsistency we led a bug in the cups issue tracker.7one day later the bug was resolved by removing the o ending les since scsi devices were no longer supported.
one license compliance inconsistency was detected in the bash system.
the examples loadables getconf.c le is released under the bsd license which is incompatible with the other les that are released under the gplv3 license.
according to the cbdg this le is compiled into a program called examples loadables getconf.
since this le is only an sample program that is not part of a distributed during product installation this does not raise license compliance concerns.
our cbdg based approach identi es several license compliance inconsistencies in the studied systems.
two of these inconsistencies generated prompt responses in the form of code xes from the ffmpeg and cups development teams.
discussion.
the fact that a le with a non compatible license is used during the creation of a deliverable does not necessarily imply a license violation.
one needs to understand how such a le is combined with the other source code.
this information is explicitly stated in the cbdg.
we expect that cbdgs can assist in the process of license compliance assessment by removing les that are not included in the build process and by showing the processes that read each of the les and which deliverables that they are contained in.
.
threats to v alidity we now discuss the threats to the validity of our analysis.
.
construct validity coarse grained processes i.e.
those processes that perform several build steps yield dependency subgraphs that do not accurately portray concrete dependencies.
thus les may be falsely reported as dependencies which can in turn lead to false positives in our license compliance assessment report.
while we decompose many known to be coarse grained processes those that are unknown may introduce noise in our assessment report.
however our approach for handling coarse grained processes is conservative i.e.
coarse grained processes trigger an overestimation of the set of source les used to produce deliverables but it will not underestimate it.
processes may access les that do not have an impact on the deliverables.
consider for instance if a c compiler opened all header les in its search path regardless of whether they were included in the source le s being compiled.
although we have not encountered such cases we cannot rule out the possibility.
nonetheless we conservatively mark such les as being part of the build process since they may have an impact on the deliverables and hence the role that they play in the build process should be assessed for potential license compliance implications.
we assume that the external components that are used by the studied systems have correctly document the licenses that they are released under.
however due to the heterogeneity of licenses used by source les that make up these components the reported licenses may not be correct.
we are actively expanding the scope of our cbdg to include source le nodes for external components by collecting additional system call traces from their build processes.
using the expanded cbdg our license compliance assessment would apply directly to the licenses listed in the internal and external source code les that compose client system deliverables.
the cbdg constructor does not trace le descriptors and inter process communication e.g.
through pipes .
for instance the cbdg constructor fails to detect that the patch task in the command cat foo.patchjpatch bar.c depends on foo.patch.
the cbdg constructor only detects that the patch task reads and re creates bar.c.
.
internal validity we assume that the build systems of the studied systems are correct whereas defective build systems may fail nondeterministically.
such build system defects could introduce noise in the results of rq1 i.e.
a build execution may fail due to a defect in the build system rather than because of the le that we have temporarily removed.
however a manual analysis of a sample of injected build failures suggests that they are indeed caused by the removed les.
.
external validity we focus our evaluation on seven open source systems which threatens the generalizability of our case study results.
however we studied a variety of systems from di erent domains to combat potential bias.
nonetheless additional replication studies are needed.
the build systems of the studied systems generate or maintain make speci cations which may bias our case studyresults towards such technologies.
nonetheless our approach is agnostic of the underlying build system operating on system call traces which can theoretically be extracted from any build system.
our approach requires access to the source code of a system and all of its dependencies in order to completely assess potential license implications.
such a constraint may limit the usefulness of our approach to identifying license compliance inconsistencies in the reuse of open source packages.
on the other hand software distributions that can be completely deployed from source code are not uncommon nowadays e.g.
gentoo linux8or nixos .
.
related work we now discuss the related work with respect to build system analysis and licence compliance assessment.
.
build system analysis prior work has shown that the build system contains plenty of information that can be leveraged for other purposes.
for example tu and godfrey show that information from the build system can be used to compose a build time architectural view which they create by hand by inspecting the build documentation of a system.
we consider our work an extension or theirs since the cbdg is a build time architectural view.
moreover we provide a method to create and analyze cbdgs automatically.
other work has constructed build dependency graphs to assist in build system maintenance.
through dynamic analysis of make debugging output adams et al.
develop the makao tool to visualize and reason about build dependencies speci ed in make les .
tamrawi et al.
propose a technique for verifying make le behaviour by constructing symbolic dependency graphs using static analysis .
although our approach is also based on a build dependency graph i.e.
cbdgs our goal is to detect license compliance inconsistencies rather than support build maintenance.
hence our approach is based on a more concrete instance of a build dependency graph that contains dependencies that are often omitted from the build speci cations.
others have also used operating system call traces to examine concrete build system interactions.
perhaps the most related instance is that of build audit a tool that produces a report of the processes invoked by and les involved in the build process.
coetzee et al.
also use operating system call tracing to reliably derive dependencies for accelerating slow builds by optimally parallelizing them .
however these tracing tools and techniques do not retain the information in a graph a necessary precondition for license compliance assessment.
although these tracing techniques will reveal which les were read and written during the build this only addresses two of the three challenges of license compliance analysis cf.
section .
these traces alone do not describe how client code and external components are combined which is critical for determining the licensing constraints that are imposed by the external components.
.
license compliance assessment the reuse of open source in both commercial and other open source systems has created a need for license compliance assessment support.
von willebrand and partanen 739describe the di culties of licensing compliance assessment stating that it is not uncommon for foss packages to contain code that causes them to pose potential or clear risks when redistributing them .
combining components and les governed by di erent licenses makes this process di cult.
bain leads a group of lawyers in the creation of a document that explains the di erent ways of combining components governed by di erent licenses and the legal implications .
german and hassan documented the ways in which open source systems address the combination of components with di erent potentially incompatible licenses .
german and di penta have also proposed a method to perform license compliance assessment of java applications .
they discuss three main challenges provenance discovery license identi cation and architectural analysis.
only the rst two challenges have been addressed.
tuunanen et al.
used a tracing approach to discover the dependency graph for c based projects as part of asla automated software license analyzer .
they modi ed the c compiler gcc the linker ld and the archive builder arto log information about the actual inputs and outputs used during the build.
the resulting dependency graph is used by asla to compute license information for binaries and detect potential licensing con icts.
however instrumenting speci c tools has several limitations.
first adding the required instrumentation code to programs could be time consuming nding the right places to instrument the code .
second many tools would need to be instrumented compilers linkers assemblers and so on.
finally a package might contain or build a code generator and use it to generate part of itself.
on the other hand the system call tracing approach we propose does not require instrumentation of the build tools and can be applied to any build environment.
the main use case for this speci c information is license compliance analysis of software systems.
understanding the myriad of ways that xed works of original authorship are embedded compiled transformed and blended into other xed works is crucial for understanding licenses and copyrights .
a study by german et al.
showed this information is important to owners and distributors who need to understand the copyrights of their systems .
they studied package metadata in fedora to nd license problems.
in their study they showed that fedora s current packagedepends on package level of granularity while helpful is ultimately insu cient for understanding license interactions in a large open source compilation such as fedora.
only a le depends on le level of granularity can work and this study directly addresses that problem.
.
conclusions modern software development relies heavily on the reuse of open source software components libraries and frameworks.
however the plethora of potentially incompatible licenses that these components are distributed under impose legal constraints on client systems.
indeed license compliance is a critical nonfunctional requirement for software systems that rely on such external components.
to assist in license compliance assessment we propose an approach that constructs and analyzes concrete build dependency graphs cbdgs for license compliance inconsistencies.
these cbdgs not only identify the source les and external components that are included in client deliver ables but also describes how they are combined to produce deliverables a detail that has critical legal implications.
to evaluate our cbdg based license compliance assessment approach we perform an empirical study on seven open source systems.
we make the following observations the cbdgs that were constructed from the studied systems can accurately classify les that have an impact on the client deliverables with a recall of and a precision of .
our analysis uncovers several license compliance inconsistencies two of which prompted rapidly xed bugs in the ffmpeg and cups systems.
future work.
although this paper focuses on license compliance assessment the cbdg is a generic data source that can be used for a variety of other tasks.
we have shown that the cbdg is an accurate source of concrete build execution data.
in future work we plan to use this data to verify the correctness of build speci cations.
dependencies that appear in the cbdg but are not expressed in the build speci cations may lead to incorrect build system behaviour.
adams et al.
have shown that incorrect build behaviour can lead to defects that are frustrating and di cult to diagnose .
in prior work we have shown that incorrect build behaviour can even impact end users if it permeates through to software releases .
hence we believe that veri cation of build systems is a natural next step for cbdg analysis.
an automatic license analysis of a cbdg would not only ag potential inconsistencies violations but would also list the legal requirements that the licenses being used impose on the licensor.
in order to automatically analyze cbdgs for license compliance it is necessary to have a calculus that is aware of the requirements that each license has and given a task node in a graph it can make an assessment of the legal requirements that such input les create on the resulting le.
this calculus cannot be universal di erent jurisdictions have di erent views on what a license requirement might mean and some organizations might be more sensitive to legal risks that others.
thus such a calculus would need to be con gurable by its user.
due to the dynamic nature of the cbdg it can only detect licensing inconsistencies in a single build con guration.
many modern software systems support several con gurations which may vary in terms of licensing implications.
more powerful static analysis techniques for build systems could lead to more powerful license compliance assessment tools capable of examining several con gurations at once.
.