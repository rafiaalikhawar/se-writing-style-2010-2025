path based fault correlations wei le and mary lou soffa department of computer science university of virginia charlottesville va usa weile soffa virginia.edu abstract although a number of automatic tools have been developed to detect faults much of the diagnosis is still being done manually.
to helpwiththediagnostictasks weformallyintroduce faultcorrelation a causal relationship between faults.
we statically determine correlations based on the expected dynamic behavior of a fault.
if the occurrence of one fault causes another fault to occur we say they are correlated.
with the identification of the correlated faults we can better understand fault behaviors and the risks of faults.
if one fault is uniquely correlated with another we know fixing the first fault will fix the other.
correlated faults can be grouped enabling prioritization of diagnoses of the fault groups.
in this paper we develop an interprocedural path sensitive and scalable algorithm to automatically compute correlated faults in a program.
in our approach we first statically detect faults and determine their error states.
by propagating the effects of the error state along a path we detect the correlation of pairs of faults.
we automatically construct a correlation graph which shows how correlations occur among multiple faults and along different paths.
guided by a correlation graph we can reduce the number of faults required for diagnosis to find root causes.
we implemented our correlation algorithm and found through experimentation that faults involved inthecorrelationscanbeofdifferenttypesandlocatedindifferent procedures.
usingcorrelationinformation weareabletoautomate diagnostic tasksthat previously hadto be done manually.
categoriesandsubjectdescriptors d. .
software program verification reliability d. .
testing and debugging diagnostics symbolic execution generalterms algorithms experimentation reliability security keywords fault correlation errorstate demand driven path sensitive permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bearthisnoticeandthefullcitationonthefirstpage.
tocopyotherwise to republish topostonserversortoredistributetolists requirespriorspecific permission and or afee.
fse november7 santa fe new mexico usa.
copyright2010acm978 ... .
.
.
introduction today the software industry relies more and more on automatic tools to detect faults however many of the diagnostic tasks are still done manually which is time consuming.
for largenewlydevelopedsoftware thousandsorevenmillionsoffault reportsaregeneratedbytools howeverthegeneratedreportsareprocessedataverylowspeed estimatedas15 20reports per person day or lines of code per person hour on average .
fault diagnosis done statically on the program source code aims to identify and fix the causes of detected faults.
diagnosing faults is challenging for a number of reasons.
one reason is that the root cause can be located far from where the fault is detected while the code around the fault can be complex.
unlike debugging infaultdiagnosis thereisnoruntimeinformationavailabletoassistinexplainingfaults.
also instaticanalysis realfaults are often mixed with an overwhelming number of false alarms and benign errors.
in this paper we explore relationships among faults for fault diagnosis.
we show that a causal relationship can exist between faults that is the occurrence of one fault can cause another fault to occur which we call correlation .
as an example in figure we show a fault correlation discovered in ffmpeg .
.
.
the correlation exists between an integer signedness error at node and a null pointer dereference at node as any input that leads to the integer violation at node triggers the null pointer dereference at node along path angbracketleft1 angbracketright.
the trigger can occur because the variablecurrent track at node is not guaranteed to get the unsignedvalueof av rl32 head seethemacrodefinition at the bottom of the figure .
if a large value is assigned the signed integer current track would get a negative value atruntime.
when current track isnegative thebranch angbracketleft2 angbracketright is taken and the memory allocation at node is skipped causing the dereference of fourxm tracks at node to encounter a null pointer.
fault correlation is a relationship defined on the dynamic behavior of faults.
when a program runs an initial root cause can propagate and cause a sequence of property violations along the execution before an observed symptom e.g.
crash is detected.
in traditional static tools the dependencies of those property violations are not identified either only the first violation is reported or all the violations are reported but as separate faults .
for the above example static detection only reports that node containsanintegerviolation butitcannotexplainwhetheritisbenign or malignant and if harmful how severe is the consequence.
a static detector for null pointer dereference also cannot discover the vulnerability because the detector may not be aware of any integer violations.
when the impact of integer fault is not considered the static analysis would report the path angbracketleft1 angbracketrightinfeasible 307figure1 fault correlation inffmpeg .
.
asav rl32 x always returns a non negative integer and thus the result of the addition at node should be always larger than fourxm track count s initial value .
however given the fault correlation we know that there exists a null pointer dereference at node its root cause is the integer fault at node and by fixing the integer fault the null pointer dereference can also be fixed.
fault correlation helps fault management in the following ways we can detect new faults with introduced fault impact e.g.
the null pointer dereference shown in figure .
these faults are impossibletobeidentifiedusingtraditionalstaticdetectors wecan confirmandprioritizerealfaultsbyrevealingtheirpotentialconsequences and3 we can groupfaultsbasedon their causes.
determining fault correlations in current static tools is challenging for three reasons.
first identification of correlations of faults requires knowledge of fault propagation which only can be obtained when program paths are considered however exhaustive static analysis based on full path exploration is not scalable.
another reason is that most static tools only detect one type of fault while correlations often occur among faults of different types as shown in the above example.
also in order to statically compute the propagation of a fault the potential dynamic impact of a fault needstobemodeled whichistypicallynotdoneinthestatictools.
in this paper we formally define fault correlation and develop algorithmstodeterminecorrelationsinaprogram.
ourapproachis tofirststaticallydetectfaultsandidentifytheerrorstatethatafault potentiallyproduces.
wethenstaticallypropagatethepotentialdynamic impact of a fault along program paths.
during propagation either a previously detected fault can be identified as being correlated or with the introduced error state another fault missed in thestatic detection can be discovered as part of correlation.
we applyademand driven analysistoaddressthescalability ofthepathsensitive analysis.
the identified fault correlations are represented in acorrelation graph .
we implemented our algorithm using an interprocedural pathsensitive demand driven static analysis framework.
we selected three types of faults buffer overflow integer error and null pointer dereference ascasestudies.
inourexperiments weshowthatcorrelations commonly exist in real world applications and our algorithm can automatically compute them.
using the correlation informationrepresentedinthecorrelationgraph weareabletounderstandtheimpactoffaults prioritizediagnostictasks andgroup faultsto speed updiagnosis.
to the best of our knowledge our work is the first that formally defines and automatically computes fault correlations.
the contributionsofthe paper include the definition and classification offault correlations theidentificationoftheusefulnessofcorrelationsinfaultdiagnosis algorithms forautomatically computing correlations correlation graphs that integrate fault correlations on different paths andamong multiple faults and experiments that demonstrate the common existence of fault correlationsand the value ofidentifying them.
insection2 wedefinefaultcorrelation.
insection3 weexplain how to compute correlations.
section presents the correlation graph.
section gives experimental results.
the related work is compared in section followed bythe conclusionsin section .
.
fault correlation we first define program faults and fault correlation.
we also provide examples to demonstrate correlations.
.
program faults definition aprogram fault is an abnormal condition caused by the violation ofarequired property at aprogram point.
the property can be specified as a set of constraints to which a programhastoconform.
wefocusonthefaultscausedbyproperty violations where the violation can be observed at certain program points.
those program points can be identified using code signatures.
todetermineafault werequirefindingatleastoneexecution path that leads to the violation of constraints at the program point ofinterest.
for example buffer overflow can occur at any buffer access if the length of the string is larger than the buffer size.
an integer overflowoccursatintegerarithmeticwhentheoutcomeofthearithmetic is larger than the maximum value the destination integer can store.
for a data race to occur the value of a shared variable at its use must be inconsistent under different interleaving of threads.
similarly memory leaks occur if the allocated memory is never released when the pointers are no longer alive or reassigned to another part of memory.
on the other hand we do not consider a missing statement or a misused variable as a fault in this paper as no property constraintsare violated at acertain program point.
definition2 theerrorstate ofafaultisthesetofdataproduced at runtime asaresult ofproperty violations.
intuitively an error state is the manifestation of a fault.
that is after executing a program statement there exists a set of values 308fromwhichwecandeterminethatpropertyconstraintsareviolated and a fault occurs.
the set of values constitute an error state.
if a crash would occur we consider the values that cause the crash as the error state.
we model the error state of a fault based on the fault type using constraints.
the modeling is empirical and based on the common symptoms of faults a code inspector might use to manually determine fault propagation.
table errorstateof commonfaults faulttype code signature errorstate bufferoverflow strcpy a b len a size a integer overflow unsigned i a bvalue i value a value b c integer int j...unsigned i j value i signedness unsigned i...int j i value j integer truncation unsigned i...uchar j i value j value i resourceleaksocket s accept avail socket s accept avail socket table lists the error state for several common faults.
under code signature we give example statements where a certain type offault potentially occurs.
under errorstate weshowconstraints about corrupted data at the fault.
the type of corrupted data is listedinbold.
thefirstrowofthetableindicatesthatwhenabuffer overflow occurs the length of the string in the buffer len a is always larger than the buffer size size a .
from the second to fourth rows we simulate the effect of integer faults.
when an integer overflow occurs the value stored in the destination integer value i should equal the result of integer arithmetic value a value b minusatype dependentconstant c e.g.
.
similarly when an integer signedness error occurs we would get an unexpected integer value.
for example when a signed integercaststounsigned anyresultslargerthan themaximum valueasigned32bitintegerpossiblystores indicatestheviolation of integer safety constraints .
when an integer truncation occurs for instance between ucharandunsigned as shown in thetable thedestinationintegerwouldgetasmallervaluethanthe source integer.
in the last row we use a socket as an example to show that when resource leaks occur the amount of available resources in the system is reduced and we model the error state as .
.
correlation definition suppose f1andf2are two program faults.
definition f1andf2arecorrelated if the occurrence of f2 along path pis dependent on the error state of f1.
we denote the correlation as f1 f2.
iff2only occurs with f1along path p we sayf1uniquely correlates withf2 denoted as f1u f2.
theoccurrenceof f2alongpisdeterminedbythepropertyconstraints on a set of variables collected along p. if such variables arecontrolordatadependent onthecorrupteddataattheerror state of f1 f1andf2are correlated.
intuitively given f1 f2 f1occurs first on the path and the error state produced at f1propagates along pand leads to the property violation at f2.
therefore f1andf2have a causal relationship.
given f1u f2 f1is a necessary cause of f2 which means if f1does not occur f2cannot occur.
if the correlation is not unique there is other cause s that can lead to f2.
considerfigure2 a inwhichthevariable inputstoresastring from the untrusted user.
a correlation exists between the buffer overflow at line and the one at line as there exists a valueflow on variable a shown in the figure that propagates the error state of the overflow at line to line .
when the first buffer overflow occurs the second alsooccurs.
thefaultsare uniquely correlated.
a uniquely correlate via data b uniquely correlate via control c correlate but not unique d not correlate figure defining fault correlation correlated faults are marked with error state is included in and corrupted dataare underlined in figure b we show a correlation based on control dependency between faults.
the integer overflow at line leads to the buffer overflow at line as the corrupted data value i produced at the integer fault impacts the conditional branch at line on which line is control dependent .
in figure c buffer overflow at line correlates with the one at line .
however the first overflow is not the only cause for the second because when the overflow at line does not occur the overflow at line still can occur.
as a comparison the two buffer overflows presented in figure d are not correlated.
at line both the size of the buffer and the length of the string used to determine the overflow are not dependentonthecorrupteddata len a intheerrorstateatline2.
by identifying fault correlation we can better understand the propagation of the faults and thus fault behavior.
we demonstrate the value of fault correlations in two real world programs.
in the first example we show given f1 f2 we can predict the consequence of f1through f2 and prioritize the faults.
the correlation alsohelpsgroupandorderfaults asinthecaseof f1u f2 fixing f1willfix f2.
see example .
example1 figure3presentsacorrelationfoundintheprogram acpid .
.
.
inthisexample weshowhowafaultofresource leakcancauseaninfiniteloopandleadtothedenialofservice.
the code implements a daemon that waits for connection from clients and then processes events sent via connected sockets.
in figure thewhileloop at node can only exit at node when an event is detected by the poll function at node and processed by the server.
correspondingly along the paths angbracketleft angbracketright the socketfdis created by the function ud accept at node and released by clean exit at node .
however if a user does not send legitimate requests the branch angbracketleft2 angbracketrightis always taken and the created sockets at node cannot be released.
eventually the listofsocketsin the systemiscompletely consumedandnosocket is able to be returned from ud accept at node .
as a result the condition fd 0always returns true.
the execution enters an infiniteloop angbracketleft angbracketright.
inthisexample theimpactoftheresource leak makes the execution always follow the false branch of node and the true branch of node causing the program to hang.
with faultcorrelationinformation wecanautomaticallyidentifythatthe root cause of the infinite loop is the resource leak.
to correct this infiniteloop wecanaddresourcereleasecodeintheloop asshown in the figure.
example static tools potentially report many warnings for 309figure3 correlation of resource leakand infinite loopinacpid a program especially when they analyze newly written code or legacy but low quality code.
consider the example in figure frompolymorph .
.
.
there exist buffer overflows in the code located at lines and .
although these overflows are not all located in the same procedure and even the buffers involved in the overflow are not all the same we find that correlations exist among them.
for example the overflow at line correlateswiththeoneatline16alongpath angbracketleft1 angbracketright andline16 correlateswith line 21along angbracketleft16 angbracketright.
we can groupthese correlatedfaultsand diagnose themtogether.
1charfilename 2strcpy filename filedata .
cfilename 3convert filename filename 5voidconvert filename char original 6charnewname char bslash null .
.
.
7if does namehaveuppers original for i i strlen original i if isupper original newname tolower original continue newname original newname 16elsestrcpy newname original 17if clean bslash strrchr newname if bslash !
null strcpy newname bslash .
.
.
21strcpy original newname figure correlations of multiple bufferoverflows inpolymorph to further understand the correlations in real world programs we conducted a study on vulnerabilities in the common vulnerabilitiesandexposure cve database datedbetween20062009.
we manually identified fault correlations on types ofcommon faults including integer faults buffer bounds errors dereference of null pointers incorrect free of heap pointers any types of resource leak infinite loops race conditions and privilege elevations.
our study shows that correlations commonly exist in realworld programs.
in fact the reports suggest that security expertsmanually correlate faults in order to understand the vulnerabilities orexploits.
table classifies the correlations we found.
we mark if the fault listed in the row uniquely correlates with the fault in the column and for correlations that are not unique.
comparing the rows ofintandracein the table we found that integer faults and data race behave alike in correlations.
intuitively both integer violation and data race can produce unexpected values for certain variables and thereby trigger other faults.
from the study we also found that a fault can trigger different types of faults along different execution paths and produce different symptoms.
we mark check in the table if the faults from the column and row can be triggered by the same fault along different paths.
table typesof correlated faults discovered incve intbufnullptr freeleakloopraceprivilege int check buf check check nullptr check check check free check leak loop check check check race privilege .
computingfault correlation in this section we present an algorithm to statically compute faultcorrelation.
theapproachhastwophases faultdetectionand faultcorrelation.
infaultdetection wereportpathsegmentswhere faults occur.
in fault correlation we model the error state of detectedfaultsandsymbolicallysimulatethepropagationoftheerror statealongprogrampathstodetermineitsimpactontheoccurrence of the other faults.
the goals of the second phase are to identify whetherafaultisacauseofanotherfaultdetectedinthefirstphase and2 whetherafaultcanactivatefaultsthathadnotbeenidentified inthefirstphase.
asthedeterminationoffaultcorrelationrequires pathinformation weuseademand drivenanalysis whichhasbeen shown to be scalable foravariety ofapplications .
.
anoverview the steps for fault detection are shown on the left side of figure .
the demand driven analysis first identifies program statements where the violation of property constraints can be observed namely potentiallyfaultystatements .
atthosestatements theanalysis constructs queries as to whether property constraints can be satisfied.
each query is propagated backwards along all reachable paths from where it is raised.
information is collected along the propagation to resolve the query.
if the constraints in the query are resolved as false implying a violation can occur a fault is detected.
the path segments that produce the fault are identified as faulty.
to improve the precision of the fault detection we run an infeasible path detection using a similar query based algorithm where the query is constructed at a conditional branch as to whether the outcome of the branch can always be true or false .
after the infeasible paths are identified and marked on the interprocedural controlflowgraph icfg oftheprogram werunvariousfaultdetectors.
in the fault detection when the query that is being used to determine faults encounters an infeasible path the propagation terminates.
challengesofdesigningsuchastaticfaultdetectorincludestrategies for propagating queries and solutions for handling imprecise 310figure5 fault detection and faultcorrelation sources to construct and resolve symbolic integer constraints.
our querypropagationispath sensitiveinthatqueriespropagatingfrom branchesarenotmergedandconditional branchesthat are relevant to the queries are collected.
the analysis is also interprocedural and context sensitive.
when a query arrives at a procedural call we perform a linear scan of the called procedure to determine if the query can be updated.
we only propagate the query into the procedureifanupdateispossible.
wepropagatethequerythrough the loop via two iterations to determine the potential update of the queryintheloop.
iftheloophasnoimpactonthequery thequery advances out of the loop.
if the iteration count of the loop and the update of the query in the loop can be symbolically identified we update the query by adding the loop s effect on the original query.
otherwise we introduce a don t know tag to record the imprecision.
to handle the c structure and heap we apply an external pointer analysis which is intraprocedural flow sensitive and fieldsensitive.
wealsointroduceanexternalconstraintsolvertoresolve integerconstraintsstoredinthequery.
moredetailsofouranalysis can be foundin our technical report .
in the analysis we cache queries and the resolutions at statements where the queries have been propagated.
both the cached query and the identified path segments will be reused to compute fault correlations.
all the detected faults are checked for correlationin the next phase.
wedevelopedfourstepstodeterminethefaultcorrelation shown on the right in figure .
in the first step we model the error state off1based on its fault type see table .
the error state is instrumented on icfg as a constraint.
for example for the integer fault in figure we insert at node and for the resource leak in figure we add at node .
next we examine whether the error state of f1can change the results of branch correlationanalysis asanupdateoftheconditionalbranchcanleadto the change of feasibility which then impacts the occurrence of f2.
inthefollowingstep wedeterminetheimpactof f1directlyon f2 andfinally wecheck ifthe identified correlation isunique.
.
examplesto findcorrelations basedonthedefinitionoffaultcorrelation for f1 f2tooccur werequiretwoconditions thereexistsaprogrampath pthattraversesboth f1andf2 and2 along p constraintsforevaluating f2 figure correlation viadirect impact aredependentontheerrorstateof f1.
inthissection weuseexamples to show how the steps of fault detection and fault correlation presented in figure5 proceed to determine the two conditions.
.
.
correlation via direct impact on faults in figure we show an example on the left and the actions takenintheanalysisontheright.
under faultdetection wepresent the transitions of the query in fault detection phase.
each table describesthepropagationofaqueryalongonepath.
thefirstcolumn ofthetablegivesthenodeswhereaquerypropagatedandupdated.
the second column lists the query after being updated and cached at the node.
in table q5 we show that to detect integer overflow we identify node as a potentially faulty statement and raise the query cis the type dependent constant inquiring whether the integer safety constraints hold.
the query is propagated backwards and resolved as falseat node due to a user determined input i shown in the second row of tableq5.
path angbracketleft4 angbracketrightis thus determined as faulty and marked on icfg.
the query is also propagated to node and resolved astrue this path is not listed in the figure due to space limitations .
similarly to detect buffer overflows we identify nodes and as potentially faulty and raise queries to determine their safety.
table q8 q10andq11present the propagation of the three queries.
take q8as an example.
at node we raise an initial query inquiring whether the buffer constraints are satisfied.
at node the query is first changed to .
a symbolic substitution at node further updates the query to .
we thus resolve the query as trueand report the buffer at node safe.
in the fault detection phase we identify three faults an integeroverflowatnode5 andbufferoverflowsatnodes10and11.
we determine in the next step whether the correlation exists for these faults.
underfaultcorrelation infigure6 welistthestepsforcomputingcorrelations.
wefirstmodeltheerrorstate.
fortheintegeroverflow at node we introduce as an error state shown in the first box under fault correlation .
we italicizedvalue x to indicate it is the corrupted data at this 311figure correlation viafeasibilitychange fault.
conceptually we need to propagate the error state along all program paths in a forward direction to examine if the corrupted data value x can impact the occurrence of the faults at nodes and .
since our analysis is demand driven to determine such impact we actually propagate the queries raised at nodes and in a backward direction toward the fault located at node and determine if the error state can update the queries.
as such backward propagation has been done in fault detection we can take advantage of cached queries to compute correlation.
in the figure all queries listed in tables are cached in the correspondent nodes after fault detection.
from table q8 we discoverthatattheimmediatesuccessor s oftheintegerfault i.e.
node6 query hasbeenpropagated to and is cached.
the query is dependent on the corrupted data value x at the error state.
we use a bold arrow in the figure to show the dependency.
the query is thus updated with the error state and reaches a new resolution false.
in this case we discover a fault that was not reported in fault detection.
using a similar approach we introduce the error state after node for a buffer overflow.
with this information the query for checking buffer overflow at node is resolved to false.
in this case two previously identified faultsare determined ascorrelated.
to determine f1u f2 we examine when f1is fixed whether f2stillcanoccur.
asfor f1u f2 f1isthenecessarycauseof f2 and fixing f1ensures the correctness of f2.
our approach is to replacetheinsertederrorstatewiththeconstraintsthatimplythecorrectnessofthenode.
forexample infigure6 wereplacetheerror stateatnode5with andatnode10 with .
with the new information node is determined as safe indicating the correlation of node and node is unique while node still reports unsafe showing the correlation between nodes 10and11 isnot unique.
in our approach the two conditions for determining fault correlation are ensured by two strategies.
first in fault correlation if queriesareupdatedwiththeerrorstateof f1andstillnotresolved wecontinuepropagatingtheupdatedqueryalongthefaultypathof f1 which assure f2andf1are located along the same path.
for instance in the above example if the buffer overflow query raised atnode8isnotresolvedatnode5withtheerrorstate itwouldcontinuetopropagatealongpath angbracketleft5 angbracketrightforresolution astheerrorstate is only produced along the faulty path angbracketleft5 angbracketright.
second we establishthe dependency between f2andf1by assuring the error state of f1can update the queries of f2and the variables in the queries are dependent onthe corrupted data in the error state.
.
.
correlation via feasibility change the error state of f1also can impact f2indirectly by changing the conditional branches f2depends upon shown in figure .
the programisasimplifiedversionoffigure1.
under faultdetection we list the query transitions to detect infeasible paths and faults.
underfault correlation we show the query update in fault correlation.
in this example our focus is to present how an integer error found at node changes the branch correlation at node and then impacts other faults.
an error state is modeled after node .
examining cached query at node we find that the error state can update the branch query and resolve it to false.
the change of the resolution implies that the path this query propagated along is no longer infeasible as identified before.
therefore all the queries that are control dependent on this branch are potentially impacted and we need to evaluate all the queries cached at node for new resolutions.
for example we restart the query from node and resolve it at node as false and a null pointer dereference is discovered.
similarly we restart the buffer overflow query at node where we find the query is resolved as falsewith the information from the error state.
in this case the error state of the integer fault first impacts the branch and activates the propagation of the query at node then the error state also has a direct impact on the query andchanges its resolutionto false.
.
thealgorithm of faultcorrelation for identifying fault correlations algorithm takes the inputs icfgandn where icfgrepresents the icfg with fault detection results includingthecachedqueriesandmarkedfaultypaths and nis the node where the fault is detected.
our goal is to identify all the correlationsforthe fault atnode n. at line we model the error state.
for each query cached at the immediate successor s of the fault we identify queries that are dependent on the error state.
see lines .
if the query is resolved after updating with the error state we add it to the set of resolved queries aat line .
otherwise if the updated query was used to compute faults we add it to the list fqat line .
if the query was used to compute branch correlation we add it to the listiqat line .
lines collect queries stored at the branch q .raise.
the faults associated with these queries are potentially impactedbythefeasibilitychange andthusneedtobereevaluated.
after queries are classified to the lists fqandiq we compute the feasibility change at line using iqand then determine the impact ofthe errorstate directly on the faultsatline 17using fq.
thedeterminationoftheresolutionsofupdatedqueriesisshown inresolve at line .
the analysis is backwards.
at line we first propagate the queries to the predecessors of the faulty node.
we then use a worklist to resolve those queries at lines .
propagate atline29indicatesthatweneedtoonlypropagatethe queriesalongfeasibleandfaultypaths.
afteraqueryisresolvedat line we identify paths and mark them on icfg at line .
for branch query they are adjusted infeasible paths while for queries to determine faults the paths showwhere the correlationoccurs.
.
correlation graphs our algorithm computes the correlation between pairs of faults.
we integrate individual fault correlations in a graph representation to present correlations among multiple faults and along different paths forthe whole program.
312input icfgwith fault detection results icfg faulty node n output correlationsfor n 1er modelerrstate n 2foreach m succ n do 3foreach q q do q updatewitherrstate er q ifq negationslash qthen ifq .an resolved thenaddq toa else ifisfaultq q thenaddq tofq else addq toiq foreach x q do if isfaultq x thenaddxtofq end end 14end 15end 16resolve iq 17resolve fq 18procedure resolve querylist q 19foreach q qdo 20foreach p pred n do propagate n p q 21end 22while worklist negationslash do 23remove i q from worklist 24updateq i q 25ifq.an resolved thenaddqtoa 26else foreach p pred i do propagate i p q 27end 28identifypath a 29procedure propagate node i node p query q 30if onfeasiblepath i p q.ipp 31onfaultypath i p q.fpp then 32add p q toworklist algorithm computefault correlations definition acorrelation graph is a directed and annotated graph g n e where nisasetofnodesthatrepresenttheset of faults in the program and eis a set of directed edges each of which specifies a correlation between two faults.
the entry nodes in the graph are nodes that do not have incoming edges and they are the faults that occur first in the propagation.
the exit nodes are nodeswithoutoutgoingedges andtheyarethefaultsthatnolonger further propagate.
annotations for a node introduce information about a fault including its location in the program the type and the corrupted program objects at the fault if any.
annotations for theedgespecifywhetherthecorrelationisuniqueandalsothepaths where the correlation occurs.
the correlation graph groups faults of the related causes for the program.
the entry nodesofthe graph and the nodes whose correlation are not unique should be focused to find root causes.
using thecorrelationgraph wecanreducethenumberoffaultsthatneed tobeinspectedinordertofixallthefaults.
infigure8 weshowthe correlation graphs for examples we presented before figure a forfigure b forfigure and c forfigure .
infigure1 wehaveshownacorrelationofintegerfaultandnullpointer dereference along path angbracketleft1 angbracketright.
actually the integer fault atnode2alsocorrelateswithabufferboundserroratnode5along path .
seefigure8 a .
ifthebufferboundserror continues to cause privilege elevation the correlation graph would showachainofcorrelatedfaultstohelpunderstandtheexploitability of the code.
on the other hand if both the null pointer dereference and buffer underflow at node are reported via a dynamic a graphforfigure1 b graph forfigure c graphfor figure4 figure correlation graphs for examples marks a correlationthatisnot unique detector using the correlation graph we are able to know the two failures are attributable to the same root cause and can be fixed by diagnosingtheintegerfaultatnode2.
similarly therelationshipof the resource leak and infinite loop shown in figure is depicted in figure b .
the correlation graph in figure c integrates all correlations for buffer overflows in figure .
to use this graph for diagnosis we start from the entry node of the graph as it indicates the root cause of all correlated faults.
diagnosing the entry node we discover that when the input filedata.cfilename is copied to thefilename bufferatline2 noboundscheckingisapplied.
we thus introduce a fix for line .
the correlation graph indicates that allothercorrelatedfaultscanbefixedexceptthefaultatline14 as in the graph the edge from the fault at line to the fault at line indicates the existence of an additional root cause.
we thus diagnose line 14and introduce the second fix.
.
experimentalresults to demonstrate that we are able to automatically compute fault correlationsandshowthatfaultcorrelationsarehelpfulforfaultdiagnosis weimplementedourtechniquesusingmicrosoft sphoenix framework and disolver constraint solver .
we choose three types of common faults as case studies buffer bounds error integer truncation and signedness errors and null pointer dereference.
intheexperiments wefirstrunfaultdetectionandupdatethe icfg with faults detected.
we model the error state of integer and bufferfaultsusingtheapproachesshownintable1andthendetermine the fault correlation.
it should be noted that although in our experiments we use our fault detector to identify faults and then compute fault correlations our technique is applicable when faults areprovidedbyothertools.
weusedasetof9programsforexperimental evaluation the first five are selected from benchmarks that are known to contain buffer overflows in each program the rest are deployed mature applications with a limited number of faults reported by our fault detector.
the experimental data aboutfaultcorrelationarepresentedinthefollowingfoursections.
the resultshave been confirmed bymanual inspection.
313table automaticidentification of fault correlations benchmarks sizefaultsfromdetection fault correlations faults during buf corr int corr ptr corr int int int buf int ptr buf buf buf int total correlation wuftp .4k sendmail .4k buf sendmail .7k polymorph .
.
.7k gzip .
.
.2k buf ffmpeg .
.
.
k 1ptr 10buf putty .
.
k 3int buf tightvnc .
.
.
k 2int buf apache .
.
.8k .
identificationof faultcorrelations inthefirstexperiment weshowthatfaultcorrelationscanbeautomatically identified.
table displays identified correlations.
in thefirsttwocolumnsofthetable welistthe9benchmarkprograms and their sizes in terms of lines of code.
under faults from detection we display the number of faults identified for each program in our fault detection.
buffer bounds errors are reported in columnbuf corr.
integer faults are listed in column int corrand the null pointer dereferences are shown in column ptr corr.
in each column the first number gives the identified faults and the second lists the number of detected faults that are involved in fault correlation.
our fault detector reports a total of faults of three types 51ofwhich are involved in fault correlation.
underfault correlations we list the number of pairs of faults in the program that are found to be correlated.
for example under int buf we count the pairs of correlated faults where the cause is an integer fault which leads to a buffer overflow.
comparing the integer faults involved in the correlations under int bufandint ptr with the ones found in fault detection we can prioritize the integer faults with severe symptoms.
in the last column of fault correlations we give a total number of identified correlations.
in our experiments we found fault correlations for out of programs.
correlations occur between two integer faults an integer fault and a buffer overflow an integer fault and a null pointer dereference two buffer overflows as well as a buffer overflow and an integer fault.
the experiments also validate the idea that the introduction of error states can enable more faults to be discovered.
we identify a total of faults during fault correlation from benchmarks including buffer overflows integer faults and null pointer dereferences shown under faults during correlation .
consider the benchmark gzip .
.
as an example.
we discover a total of faults and pairs of them are correlated.
a new buffer overflow is found after introducing the impact of an integer violation.
buffer overflow correlates with integer fault when strlen is called on an overflowed buffer which later is assigned to a signed integer without proper checking.
we also found that the new faults generated during fault correlation can further correlate with other faults.
in putty .
two integer faults found duringfaultcorrelationresultedfromanotherintegerfaultareconfirmed to enable a buffer overflow.
the propagation of these faults explainshow the buffer overflow occurs.
.
characteristicsof faultcorrelations wealsocollectedthedataaboutthecharacteristicsoffaultcorrelations shownintable4.
incolumn unique not wecount forall the correlations identified how many are uniquely correlated see thefirstnumberinthecolumn andhowmanyarenot seethesecond number .
the data demonstrate that both types of correlations existinthebenchmarks.
column dir indir showswhetheracorre lationoccursdirectlybetweentwofaultsorindirectlyasaresultof feasibilitychange.
thefirstnumbersummarizesthedirectcorrelations and the second number counts the indirect ones.
the results showthatmostcorrelationsarediscoveredviadirectqueryinteractions andonlytwoprogramsreportthecorrelationsidentifiedfrom feasibility change.
we also investigated the distances between the correlatedfaults.
theexperimentaldataunder inter intra showthat along the correlated paths the two faults can be located either intraprocedurally or interprocedurally.
therefore an interprocedural analysis is required for finding all correlations.
a related metric is thedistanceofcorrelatedfaultsalongthecorrelationpathsinterms of number of procedures.
column corr proc gives both the minimumandmaximumnumbersofproceduresbetweentwocorrelated faults in the benchmark.
we are able to find the correlation where two faultsare 19procedures apart.
table characteristics of fault correlations benchmarks unique not dir indir inter intra corr proc wuftp sendmail sendmail polymorph .
.
gzip .
.
ffmpeg .
.
putty .
tightvnc .
.
.
computingcorrelation graphs a correlation graph is built for each benchmark in the experiments.
in table we report the total number of nodes in the correlationgraphincolumn node.
thenodesincludefaultsidentified from fault detection and fault correlation.
the types of identified faults are listed in column type.
for example for the program ffmpeg .
.
we find faults of all three types.
in column group we provide the number of groups of correlated faults for each program.
we obtained the number by counting the connected components in each correlation graph.
the results show that although the number of faults can be high in a program many of the faults can be grouped and diagnosed together.
for out of programs the faults are clustered to less than a half of fault groups which willassistdiagnosis.
underanalysiscost we report the analysis costsforcomputing correlationgraphs includingthetimeusedfordetectingfaults see the first number in the column and the time used for computing fault correlations see the second number .
the machine we used to run experiments is the dell precision one intel xeon core processor .
ghz and gb memory.
the experimental data show that the analysis cost for fault detection is not always proportional to the size of the benchmarks the complexity of the 314code also matters.
for example the analysis for sendmail takes a long time to finish because all the faults are related to several nested loops.
the additional costs of computing fault correlations for most of the benchmarks are under seconds or minutes except forgzip .
.
which contains the most faults among the benchmarks and many faults are found to impact a large chunk of the code in the program.
the data suggest that the important factors that determine the analysis cost of fault correlation are the number offaultsand the complexity oftheir interactions.
table correlation graphs and theiranalysis costs benchmarks sizenodetypegroup analysis cost wuftp .
k .
m .
s sendmail .
k .
m .
s sendmail .
k .8s .
s polymorph .
.
.
k .4s .
s gzip .
.
.
k .3m .
m ffmpeg .
.
.8k .
m .
m putty .
.5k .8m .
m tightvnc .
.
.9k .3m .
m apache .
.
.
k .
m .
s .
false positives andfalse negatives inourexperiments bothfalsepositivesandfalsenegativeshave been found.
because we isolate don t know warnings for unresolved library calls loops and pointers our analysis does not generate a large number of false positives.
in fault correlation we consider the following two cases as false positives at least one of the faults involved in correlation is false positive and both faults in the correlation are real faults but they are not correlated.
in our buffer overflow detection we report a total of false positives for all programs from sendmail fromgzipand fromputty.
for integer fault detection we report a total of false positives from sendmail frompolymorph fromffmpeg fromputtyand from apache.
we find correlations reported are actually false positives of which are related to case and to case where the correlation paths computed are confirmed as infeasible.
however we did not find that any new faults reported during fault correlation see the last columnintable3 arefalsepositives.
interestingly wefoundfalse positivefaultscancorrelatewitheachotherandthusbegrouped.
in our implementation we have applied such correlations to quickly remove false positives and improve the precision of our analysis.
we exclude the false positives when reporting the faults and fault correlationsin tables and .
wemissfaultcorrelationsmainlyintwocases wereportcorrelatedpathsbetweentwofaultsasdon t know and2 thecorrelationoccursamongthetypesoffaultsnotinvestigatedinourexperiments.
forexample inthebenchmark tightvnc .
.
three integer faults are reported as not correlated shown under faults from detection in table however our manual inspection discovers that these faults can cause buffer read overflow which was not consideredin our fault detection.
.
related work fault correlations identify a causal relationship between faults.
the key idea for computing correlations is to statically simulate the propagation of a potential error state of a fault along program paths.
researchinfaultpropagationhasbeendoneforsoftwaresecurity .
to understand the severity of certain types of static faults ghosh et al.injected faults in programs and dynamically triggeredfaultstoobservetheirpropagationandimpact .
chenet al.discovered that a successful attack performs a set of stages.
thefinitestatemachinescanbeusedtomodeltheactivitiesateach stage .
similar to our research both of the above works emphasize the importance of fault propagation.
however ghosh et al.
obtained fault propagation by running the program and thus the numberofpathsthatcouldbeexploredwaslimitedbytheprogram inputs while chen et al.manually identified fault propagation.
fault propagation is also useful for software debugging.
using dynamic tainting clause et al.isolated the input that potentially causes failure .
their interest was to find the part of program input that has dependencies with the error state.
faultrankingaimstoprioritizerealandimportantfaultsforstatic warnings.
often many factors can indicate the importance of a warning such as the complexity of the code where the warning is reported or the feedback from code inspectors.
ruthruff et al.developedlogisticregressionmodelstocoordinatethosefactors .
kremenek etal.observedthatwarningscanbeclusteredinthateither they were all false positives or were real faults.
thus diagnosingonecanpredicttheimportanceofotherfaultsinthecluster .
heckman etal.identifiedalertcharacteristicsandappliedmachinelearningtechniquestoclassifyactionableandnon actionable static warnings .
compared to the above works which are all basedonempiricalobservations ourapproachstaticallygroupsand orders faults based on the inherent causality between faults and thus is generally applicable.
research in fault localization aims to automatically identify the root cause of faults.
ball et al.developed a localization technique for error traces generated from the model checker.
the key was to identify the transitions that only appear in error traces but not correct traces .
there are also the approaches of delta debugging dynamic value replacement and coverage based faultlocalization however thoseapproachesareonlyapplicable when the inputsthat trigger the faultsare available.
research efforts have been reported on a different type of correlation in the testing area.
the focus of one effort was to discover how an error can potentially mask another and impact testing coverage .
another study investigated how to propagate an error to the output of the program so that its consequence can be observed .
althoughbothourresearchandtheirresearchexplored the relationships of software defects the faults we focused on are different from the errors studied in their work.
our work is set in thedomainofstaticallyidentifiablefaults whiletheirworkfocused on errorsin testing.
in prior work other types of correlations have been proposed.
muelleret al.developed compiler optimizations based on branch correlation while bodik et al.identified infeasible paths using branch correlation .
esp made the assumption that there exist correlations between the outcome of branches and property states basedonwhich apath sensitiveprogramverificationcanbe optimized to linearcomplexity .
.
conclusions as faults become more complex manually inspecting individual faults becomes ineffective.
to help with diagnosis this paper shows that identifying a causal relationship among faults helps understand fault propagation and group faults of related causes.
with thedomainbeingstaticallyidentifiablefaults thispaperintroduces definitions of fault correlation and correlation graphs and presents algorithms for their computation.
our experiments demonstrate thatfaultcorrelationsexistinreal worldsoftware andwecanautomatically identify them.
the benchmarks used in our experiments arematureapplicationswithfewfaults.
however determiningcorrelation is especially important for newly developed or developing 315software which would have many more faults.
although the fault correlation algorithm is tied to our fault detection for efficiency a slightlymodifiedcorrelationalgorithmwouldworkiffaultsarediscovered byother toolsand presented to the correlation algorithm.
.