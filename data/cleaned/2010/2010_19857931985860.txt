ownership experience and defects a fine grained study of authorship foyzur rahman and premkumar devanbu department of computer science university of california davis usa mfrahman ptdevanbu ucdavis.edu abstract recent research indicates that people factors such as ownership experience organizational structure and geographic distribution have a big impact on software quality.
understanding these factors and properly deploying people resources can help managers improve quality outcomes.
this paper considers the impact of code ownership and developer experience on software quality.
in a large project a file might be entirely owned by a single developer or worked on by many.
some previous research indicates that more developers working on a file might lead to more defects.
prior research considered this phenomenon at the level of modules or files and thus does not tease apart and study the effect of contributions of different developers to each module or file.
we exploit a modern version control system toexamine this issue at a fine grained level .
using version history we examine contributions to code fragments that are actually repaired to fix bugs.
are these code fragments implicated in bugs the result of contributions from many?
or from one?
does experience matter?
what type of experience?
we find that implicated code is more strongly associated with a single developer s contribution our findings also indicate that an author s specialized experience in the target file is more important than general experience.
our findings suggest that quality control efforts could be profitably targeted at changes made by single developers with limited prior experience on that file.
categories and subject descriptors d. .
metrics process metrics general terms experimentation measurement verification keywords ownership experience collaboration software quality permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.
.
introduction software defects cost the us economy billions each year .
for several decades now studies of the causes of defects have led to both prediction models and actionable approaches to change processes to improve quality.
of late there has been increasing attention to human factors such as organizational structures code ownership and developer experience as an influence on software quality.
code ownership can be a good thing.
strong code ownership might give rise to pride of workmanship and thus yield higher quality results.
in industry code ownership makes it easier for managers to hold the right people accountable and also can help find experts to whom tasks may be delegated and questions addressed.
on the other hand excessive levels of ownership might lead to in bred code whose quality suffers from a lack of wider scrutiny.
experience is a related but distinct phenomenon.
as a developer contributes more to a project her experience increases thereby it is likely that the code she writes would be of higher quality and thereby less defect prone.
on the other hand an experienced developer might be overconfident in her approach to unfamiliar code and thus inadvertently lower its quality.
researchers have previously studied the effects of ownership and experience but this research largely considers ownership and experience at the level of files and modules.
however several developers may contribute to each file or module thus the effects of many developers varying ownership and experience on quality can be conflated together and give anomalous noisy and or confusing results arising from the ecological fallacy .
we adopt a much more precise fine grained approach.
our approach is to zero in on the lines of code that were actually changed or deleted to fix bugs.
we refer to these lines as implicated code1 .
using the provenance facilities based on modern more precise differencing algorithms afforded by thegitversion control system we can track down the origin and authorship of individual lines of code and thus more precisely identify the authors of implicated code.
we can then contrast the experience and ownership characteristics of implicated code with normal randomly chosen background code as we describe in detail below.
in this paper we study the relationship of ownership and experience at a fine grained level on the quality of code.
we make the following contributions.
.we find that stronger ownership by a single author is associated with implicated code.
1we use implicated in the sense described in wordnet http wordnetweb.princeton.edu perl webwn?s implicatedpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.we find lack of specialized experience on a particular file is associated with implicated code in that file.
.we find that lack of general non specialized experience is not consistently associated with implicated code.
.methodology for our study we use a novel fine grained sampling method.
we use the blame feature of gitto track the provenance of code fragments implicated in bugs and compare the provenance of this implicated code with randomly chosen unimplicated fragments of the same size drawn from the same file and same point in the system s history.
we argue that this approach is general and can be used to study a range of questions as to why certain code fragments are involved in bugs and others are not the resulting knowledge can drive new approaches to quality control and defect detection.
these results are actionable at the simplest level our results indicate that specialized experience matters more than general experience rather than throwing a random developer at crunch time to fix problems in an unfamiliar part of a system we should use someone with experience on that part of the system.
we discuss further implications in section .
.
background theory ownership large software projects must divide the work between members of the development team.
the question ofownership arises here should each member of the team own their piece of the system?
or should everyone collectively own everything?
this is controversial.
the agile movement argues for collective ownership as does raymond who claims that increasing the number of collaborators will accelerate defect diagnosis.
others counter with evidence suggesting that too many cooks working on the software leads to unfocused defect prone contributions .
also communication and coordination overheads worsen as the team size increases .
researchers have also found that these overheads can slow down development and increase defects .
seifert et al.
found that an increasing number of distinct authors making change to a file may lead to more defects.
meneely et al.
used social network based measures to analyze the effect of focus and ownership on security related errors.
they found that contributions by less focused developers were associated with more security related errors.
they also found that when more than nine developers contribute to a source file it is sixteen times more likely to include a security vulnerability.
bird et al.
find evidence that small contributions by minor developers are associated with defects specially in more commercially oriented development processes.
there are however some contradicting results weyuker et al.
and graves et al.
both found that the number of contributors didn t necessarily relate to fault proneness.
the findings reported above are generally at the file or module level.
however code authorship happens at a much more fine grained level.
indeed different bits of code in the same file may have been contributed by different authors version control systems can track authorship at the line level.
studies of ownership effects at a file or module level aggregate the effects of individual contributors together thus risking the ecological fallacy of transferring findings from theaggregate to the constituent element there are both internal and construct validity issues with this type of ecological in ference.
with the fine grained provenance information available from git blame we address the question is ownership at a fine grained level indicative of defect proneness?
if one believes the many eyeballs theory of raymond shouldn t fragments of code with multiple authors be less likely to have defects?
rq1 is implicated code less likely to involve contributions from multiple authors?
experience a related but distinct issue is experience .
employee experience and its impact on productivity and quality of output has been the subject of extensive study in many fields and several industries .
in manufacturing when a worker performs a task repetitively her efficiency improves and quality of output increases .
similar findings were reported for service industries .
unlike manufacturing or service industries software development is not particularly repetitive and requires significant creativity however studies indicate that a developer s knowledge of the system increases as she works more on various components of the system .
knowledge gained from experience matters it can lead to better ability to answer questions about previous work and better quality work .
these findings are also supported by robillard who suggests that lack of such knowledge could hurt software quality.
we contribute to this literature in two ways.
first we pursue a fine grained approach considering the contributions of each developer within a file and studying the relationship of deve loper experience to quality at the level of these fragmentary contributions.
second we conceptualize two distinct types of experience that can affect the quality of a developer s work specialized experience in a file under consideration and general experience in the entire project.
we define precise measures later but intuitively we view general experience of an individual as a measure of the total contributions of that individual to a project and specialized experience of an individual with respect to a file as a measure of the number of contributions of that individual to that file.
the distinction between specialized and general experience matters.
given an urgent task a manager might have difficulty finding a person with specialized experience relevant to a given task and so might be tempted to deputize a developer with a lot of general not necessarily relevant experience.
is this a temptation to which one should yield?
boh et al.
studied the impact of such specialized and general experience on developer productivity.
their findings indicate that specialized experience has much larger impact on developer productivity than diverse experience in unrelated systems.
we consider the impact of general and specialized experience on quality .
while mockus and weiss considered the quality effect of both types of experience they study the quality effect of experience at the relatively coarser granularity of a maintenance request mr a single mr may involve changes to multiple files by multiple authors and conflates the specialized general experience of all contributing authors together using a geometric mean.
we study the quality effect of experience at a finer granularity considering the authorship of lines of code within each file and comparing the experience of authors of lines implicated for bugs with that of background code randomly selected code with similar properties authors.
we consider specialized experience rq2 and general experience rq3 separately.492in particular when a developer authors some lines in a file one can reasonably assume that her prior experience on that selfsame file is the most relevant experience.
we hypothesize that the more a developer contributes to a file the less likely it is that a change authored in that file by him her would be implicated later.
rq2 is a developer with higher file level authorship less likely to be associated with implicated code?
next we consider general experience.
the more work a developer has done on every file of the system perhaps the less likely they are to make mistakes.
paradoxically prior work suggests that experienced developers are more defect prone e.g.
erich gamma was identified as second most defect prone programmer in eclipse .
zeller makes the argument that this is because the most experienced developers work on the most often exercised most complex part of the system .
we examine this issue at a finegrained level by measuring the level of experience of the authors associated with implicated code rq3 is general experience more likely to be associated with implicated code?
the above questions consider defect proneness without addressing the type of defects.
however in most projects faults are associated with a criticality factor e.g.
apache etc.
uses a notion of severity .
unfortunately fault proneness generally considered in the research with few exceptions without attention to severity.
however when considering the effect of experience on fault proneness one can naturally believe that experienced developers are more likely to be working on critical code and thus more likely to be associated with critical faults.
thus when we inspect the authorship of implicated code we might expect that implicated code associated with severe defects is more likely to be associated with senior developers viz.developers with more general experience.
we therefore examine whether experienced developers are writing more severe bugs.
rq4 is general experience associated with implicated code for more severe defects?
overview of methodology existing research addresses ownership and experience questions mostly at file or module level.
we instead try to study the ownership and experience in the context of implicated code.
we identify lines of code that are associated with changes that are identified as defect repairs.
this code was originally called fix inducing code by sliwerski et al.
also see as it is the code that needed repair for example if the code line strcpy str2 str1 was changed to strncpy str2 str1 n then the original line is considered fix inducing code.
we have found that the term fix inducing code causes confusion we prefer the term implicated code implicated code is code that is modified to fix a defect.
figure adapted from shows how we find implicated code.
we start with data linking a given bug to the revision where that bug was fixed.
if a bug fix is linked to revision n then the immediately preceding revision viz.
n should contain the relevant unfixed code.
a diff between revision nand n for each of the files that was changed in revision n gives us the potential buggy code.
we call these lines the implicated code .
we then use the git i j k ndiffbug b fi xed at revision n 1link database bug b was reportedimplicated implicated innocent figure finding implicated code blame command on all such implicated code this produces provenance annotations author date revision number where they were last changed on each line we note here that git uses a sophisticated differencing algorithm that is sensitive to whitespace changes line breaking and even to some extent code movement .
in the figure versions i jand k contributed lines that were changed from version nton .
versions iand joccurred before bug bwas reported version koccurred after.
following we consider code attributed to version kas innocent and not part of the implicated code associated with bug b. foo.c n foo.c j foo.c i bob on at 15pmgopal on at 29pm figure implicated code author information figure shows how we find the author and modification time.
in the figure three of the seven implicated code lines were attributed to revision iand jwhich were originally committed by bob on and gopal at .
these details can be used to study the ownership and experience in implicated code when compared to the rest of the code.
does the implicated code itself involve more authors?
are there any significant differences in experience level associated with implicated code?
to answer these questions we draw upon the existing literature on ownership and experience.
girba et al.
visualize a project s evolution based on ownership changes.
they define a developer s ownership of a file as the percentage of lines attributed to him her in a file.
the overall owner is the author with the highest ownership.
mockus et al.
report that developer experience is negatively correlated with failure proneness.
they measure experience as the number of changes that a developer made to a system upto a given time.
we define general experience as the cumulative developer contribution to the entire system at a given time.
our study of implicated code goes further to consider the influence of specialized experience as discussed below.
.
experimental framework in this section we will define all the terminologies and background of our experiment.
.
revision source code management systems scm provide a rich version history of software projects.
this information includes the full history of commits to each file timestamps authorship change content and the commit log.
in our study we identify each of these commits as a revision where a revision consists of an author a timestamp and a set of files changed in that revision.
we chose gitas our version control system thanks to its excellent provenance facilities .
.
bug fixing revision typically bugs are discovered and reported to an issue tracking system such as bugzilla and later on fixed by the developers.
each bug report records the opening date the fixing date a free text bug decription and the final triaged bugzilla severity.
a typical bug severity in bugzilla may have one of the following values blocker critical major normal minor trivial enhancement .
we consider any change associated with a report in the bugzilla database that is not labeled as an enhancement to be a bug.
our study begins with links between bugzilla bugs and the specific revision that fixes the bug we call this a bug fixing revision .
our data is derived using several different heuristics.
various key words such as bug fixed etc.
in the scm commit log are used to flag bug fixing revisions .
also numerical bug ids mentioned in the commit log are linked back to the issue tracking system s identifiers .
then the data is crosschecked with the issue tracking system to see whether such issue identifier exists and whether its stat us changes after the bug fixing commit.
finally manual inspection is used to remove spurious linking as much as possible.
each of the remaining linked bugs can be associated with a particular bug fixing revision.
we gratefully acknowledge the direct use of linked bugs data derived by bachmann .
these bug fixing revisions change or delete certain lines in the source base in order to fix bugs.
these changed or deleted lines are the implicated code lines which are the central focus of our research.
new lines may also be added in the bug fixing revision but we do not consider these implicated since they are part of the treatment not the symptom.
implicated code for a single bug may not be contiguous in fact it may occur as several spatially separated groups of contiguous lines.
each group of contiguous lines in the implicated code is referred to as a hunk.
.
implicated author for each line of implicated code we seek to identify the author of that line of code.
we use the blame functionality ofgitto identify the revision time author that introduced the line.
githas a very accurate blame facility which properly handles whitespace changes and tracks code copying and movement within and even between files2.
we then identify at the resolution of individual lines all the revisi ons and revision authors contributing to the implicated code.
.
authorship ownership based on our partitions for implicated code we compute the proportion of contribution for each author.
so if nblines are changed to fix a bug b and there are a total of mdistinct authors and the number of lines contributed by author ato the implicated code of bug bisnb a then contribution ratio 2see docs git blame.html last checked july 2010for author aisra nb a nb.
we call this authorship for author a. we also determine the author with the highest authorship i.e.
highest contribution ratio and flag this author as the primary implicated code contributor for this bug.
in this paper we use the term ownership of a code fragment to refer to the authorship of the highest contributor.
thus implicated code ownership would give us the authorship of the highest contributor to that implicated code.
in a similar fashion we determine ownership of a file by considering highest contributor of a file instead of a bug.
.
background code when making claims about properties of implicated code such as number of contributors experience of owner etc it is important to have a reference point.
for example if we claim that implicated code has more authors the question arises when compared to what ?
clearly one needs to compare implicated code with some non implicated code to see if there is something different about the implicated code.
our approach is to compare each hunk of implicated code to a randomly chosen hunk of non implicated code.
we call these hunks chosen for comparison background code .
obviously the background code chosen for comparison to a given hunk of implicated code should be selected both carefully and fairly.
for example we should choose hunks of the same size.
a background code hunk smaller than a corresponding implicated hunk will tend to have fewer contributors than a larger hunk.
furthermore newer code might have fewer authors than older code.
therefore we compare each hunk of implicated code to a randomly chosen hunk of the same length from the same file from the same revision as the implicated code was considered.
furthermore comments and blank lines can be expected to have different patterns of authorship and evolution than non commentary code.
for this reason we disregard comments and blank lines in both implicated code and background code.
we use the following procedure to choose background hunks.
first we pick locationally similar background code from the same file of its corresponding implicated code.
next we choose temporally similar background hunks by choosing a hunk from the same revision that the corresponding implicated code was changed to fix the bug.
next we ensure length similarity by picking random contiguous hunks of the same length as each such hunk in the implicated code.
during the selection process we ensure structural integrity by picking code hunks that do not cross function boundaries3.
that is we do not pick code hunks which may span multiple functions.
our algorithm tries to find background code that doesn t overlap with the corresponding implicated code.
however it may occasionally return overlapping background code when it couldn t find a non overlapping one.
following also explained in section we discard any implicated code lines that were introduced after the bug was reported.
to ensure spatial and structural similarity of background code in such cases we run a post processing on the selected background code hunks.
the post processing discards i th line of h th hunk of background code if the corresponding line is discarded from the implicated code i.e.
i th line of h th hunk of implicated code was changed after the bug was reported and was identified as innocent for that reason .
3we use understand from scitoolstmto find function boundaries494thus we choose background code hunks matched as closely as possible to the implicated code .
since the background code hunks come from the same time from the same file and are of the same length as the implicated hunks we have a greater chance of discerning any significant dissimilarities arising in the ownership level of the implicated hunks and the experience of the authors contributing to them.
this methodology of comparing implicated code with carefully chosen background code is an important contribution of this paper and we argue that this is a novel experimental technique that has applications beyond this work .
it can allow study of a range of questions concerning fine grained phenomena that can give rise to defects such as language features apis programming styles static properties and so on.
.
experience to measure the general experience of an author we use the total number of deltas committed to the source code repository by an author up to a particular point in time.
e.g.
if she committed a total of lines of deltas until january 1st her general experience would be at that point but if we look at january 1st she might have contributed lines by that time thereby changing her general experience to .
we derive general experience for implicated and background hunks using the weighted geometric mean of the experience of all contributing authors as described by mockus .
in our case weight is the proportion of either the implicated code or the background code written by a person and experience is her general experience at that point in time.
we also use a developer s authorship of a file at a point in time to measure her specialized experience .
.
the data sets we chose different medium to large sized open source projects for our study.
all have long development history but hail from different domains.
apache httpd is a widely used open source web server.
nautilus is the default file manager for the gnome desktop.
evolution is the default email client for the gnome desktop with support for integrated mail address book and calender functionality.
gimp is a popular open source image manipulation program.
all of our projects are written in c. we converted the apache subversion repository to gitand used the other projects git repositories directly.
max.
linked implicated name size bug hunk author loc count count count apache evolution gimp nautilus table summary of study subjects these projects represent a diverse set of application domains a server a client a file browser and a gui application.
all are non trivial.
a summary of descriptive statistics of the projects studied is presented in table .
they range in size from 200k lines to about a million lines.
the table presents details about the number of loc the total number of linked bugs over the entire period total number of implicated code fragments and number of distinct authors.we determine all linked bugs and their associated bugfixing revision for all the subject projects.
the corresponding implicated code is found by using diff between a bug fixing revision and its immediate preceding revision.
such implicated code may consist of multiple hunks and for each hunk we used our careful background code finding procedures to select similar random non implicated code.
we also experimented with several alternative less stringent methods to select background code.
our alternative background code selection procedure includes relaxing function boundary requirement keeping comments picking one contiguous code section for all the composing hunks of a bug etc.
in all those cases we found results similar to our stringent background selection procedure.
after collecting all implicated code and the corresponding background code we use git blame on each line of the implicated code and background code to identify its lastmodifying author and the modification time.
we then proceed to compare their properties to answer various research questions concerning the impact of code ownership and developer experience on software defect proneness.
.
results we now present our results broken down by the research questions presented earlier in section .
in some cases a single research question was subject to detailed investigatio n using a few different measures and we present them as rq1a rq1b etc.
for illustrative purposes we present the boxplot charts only for apache and evolution.
data from other projects is discussed in the text.
gg gg g gg g g gg gg gg g g gg g gg gg g g gg g g g gg gg gg g g gg g gg g g g gg g gg g g gg g gg g g gg ggg gggg gg g gg ggg g gg gg gg ggg g gg implicated code background2 14apache number of authorsnumber of authorsg g gg g g g g gggg g gg g gg g g gg g ggg g gg g gg g g g ggg g ggg g gg ggg gg g gg g g ggg gg gg gg g gg gg gg gggg gg g g g g gg gg g gg g g gg g g g gg g gg g gg g g gg gg g g gg g gg g g gg gg g gg ggg g gg g gg g gg g gg g gg g g gg ggg g gg gg g ggg g gg g g gg g gg ggg g gg g g g ggg gg gg g g gg gg ggg g implicated code background2 14evolution number of authorsnumber of authors figure number of distinct authors in implicated code and background for a apache b evolution.
rq1a is implicated code less likely to involve contributions from multiple authors?
to evaluate this more eyeballs better code theory we compare the number of authors in the implicated code against the number of authors in comparable background code.
figure shows the boxplot of number of authors in implicated code and background code.
the boxplot suggests that the number of author is actually higher in background than implicated code.
a wilcoxon paired test alternative hypothesis set to number of author is greater in background code are shown in table .
all the p values for rq1a in table are very low rejecting the null hypothesis conclusively .
despite the evidence to reject the null hypothesis in this case if we look at the boxplots we can notice both small range and strong positive skew due to the limited range of number of authors mostly or in implicated code and comparable background code most implicated code hunks are small they are largely single authored.
as a more sensitive test we consider the primary ownership of495name rq1a rq1b rq1c rq2a rq2b rq3 rq4 apache p .
p .
.
.
.
.
.
evolution p .
p .
.
p .
p .
.
.
gimp p .
p .
.
p .
p .
p .
.
nautilus p .
p .
.
.
p .
.
.
table the alternative hypothesis is that the answers to the research question is yes in all cases.
wilcoxon test p values for rq1 rq2 rq3 and rq4.
all p values h ave been adjusted using benjamini hochberg procedure.
p values are the probability of the sample if the null hypothesis were true.
except rq4 all arepaired wilcoxon test.
implicated code and background code viz.
the proportion of the hunks contributed by the largest contributor thus giving us range of values upto .
.
g gg g g g g implicated code background0.
.
.
.
.0apache ownershipownership g implicated code background0.
.
.
.
.0evolution ownershipownership figure ownership in implicated code and background for a apache b evolution.
rq1b does implicated code have higher primary ownership?
figure shows the boxplot of primary ownership in implicated code and background code.
the boxplots are consistent with rq1a boxplots and the p values are shown in table .
all the p values are again very low thereby we reject the null hypothesis.
this result provides additional evidence indicating that the implicated code tends to more frequently originate from fewer authors when compared to similarly chosen background code.
noticing that many of the implicated code fragments had only one single author and the resulting negative skew in the data we decided to perform one bit of sensitivity analysis on the data.
we discarded all singly authored implicated code fragments and considered just the ownership of the remaining implicated code.
it s important to notice that this is a particularly stringent test by omitting this data from implicated code we are reducing the likelihood of detecting a difference between implicated code and background.
implicated code background0.
.
.
.
.0apache ownership excluding .
ownership implicated code background0.
.
.
.
.0evolution ownership excluding .
ownership figure ownership after discarding single author implicated code and their corresponding background code for a apache b evolution.rq1c does implicated code with more than one author demonstrate higher ownership?
we discard all the implicated code that has a single author for fairness we also discard the background code chosen to match this implicated code.
it s important to note that it is only the background code chosen to match this buggy code that is discarded.
we then compare the ownership of the remaining implicated code and background code.
the boxplot of our comparison is shown in figure .
three out of four projects except apache still give us consistent findings with rq1a and rq1b.
the p values are shown in table .
this is a conservative analysis as we selectively discarded only the singly authored implicated code and its corresponding background code without selectively discarding the singly authored background code we of course discarded the singly authored background code if that corresponds to a discarded implicated code .
the apache contains relatively more singly authored implicated code of linked bugs have singly authored implicated code while evolution gimp and nautilus have respectively and so a relatively large number of multi authored background code got discarded in the process.
our results from rq1a rq1b and rq1c all shows evidence of fewer authors and corresponding higher ownership in implicated code.
implicated code is less likely to involve contributions from multiple developers.
implicated code background0.
.
.
.
.
.0apache file owner s contributioncontribution implicated code background0.
.
.
.
.
.0evolution file owner s contributioncontribution figure file owner s contribution in implicated code and background code for a apache b evolution.
rq2a is higher authorship by the file owner less likely to be associated with implicated code?
one would expect that a developer s expertise on a file s code would increase significantly as she writes more of the code in the file.
does this expertise translate into better quality code?
if so we would expect to see a file s owner writing less implicated code.496implicated code background0.
.
.
.
.
.0apache implicated owner s file level contributioncontribution implicated code background0.
.
.
.
.
.0evolution implicated owner s file level contributioncontribution figure implicated and background code owner s contribution at file level for a apache b evolution.
we define the file s owner at the time the bug fix was performed to be the developer with the most contributions to the file.
we then compare a file s owner s contribution to the implicated code against background code.
figure compares file owners contribution in implicated code and background code.
if the file owner writes less implicated code in that file then her contribution in implicated code of that file would be less than her contribution in background code of that file alternative hypothesis .
in of cases see table rq2a column we can reject the null hypothesis and find support for the alternative hypothesis that file owners indeed write significantly less implicated code in that file.
figure shows how rq2a is supported by the evolution dataset but not the apache dataset.
however left and right side boxplots in each dataset in the figure are skewed and do look rather similar.
this is because file owners ipso facto write most of the code in the files they own including both implicated code and background code.
we therefore consider a more sensitive measure by reversing the sense of ownership and asking how much the primary contributor of the implicated code or corresponding random fragment contributes to the file.
rq2b do implicated code owners have lower contribution at file level?
in rq2a we found in of cases that file owners are less likely to introduce implicated code.
we intend to investigat e this trend further by asking the converse question.
if the rq2a trend holds i.e.
specialized experience in a file is associated with writing less implicated code in the same file then we would see that the implicated code owners would have lower contribution to the file.
to investigate this we compare the contributions of implicated code owners and background code owners to the containing file.
if prior experience on the file matters then implicated code owners should tend to have less ownership at the file level.
figure presents the boxplots comparing these two samples.
the figure indicates that implicated code owners have lower file level contribution than background code owners.
the p values are shown in table with alternative hypothesis set to implicated code owners have lower file level contribution than background code owners .
all the p values are highly significant thereby rejecting the null hypothesis conclusively.
the findings from rq2a and rq2b are largely consistent and suggest that specialized experienc e plays an important role to write less defective code.implicated code owner has lower contribution at file level.
gg gg ggg gg g g gggg gg g gg gggg g gg gg gg g gggg g implicated code background code1 5apache weighted experience overall log10 weighted experience g ggg g ggg gg g ggg gg g gg g implicated code background code1 6evolution weighted experience overall log10 weighted experience figure weighted author experience in implicated code and background code for a apache b evolution.
rq3 is general experience more likely to be associated with implicated code?
next we examine whether general experience is associated with implicated code.
we compare general experience of implicated code against the general experience of background code.
we measure general experience of a developer as the number of deltas she has contributed until a point in time.
the weighted experience of all the hunks of the implicated code of a bug is computed by multiplying each contributing developer s experience by the number of lines she contributes to those hunks.
following mockus we use the geometric mean of these weighted values geometric means are used because the distribution of experience is very right skewed.
in figure we compare general experience of implicated code and background code.
from boxplots we observe a lower weighted experience of implicated code only for evolution.
also for apache the difference is almost indistinguishable .
for other two projects gimp and nautilus we observe a higher weighted experience for implicated code.
table presents p values for wilcoxon rank sum test with alternative hypothesis set to implicated code associated with more general experience than background code .
we reject the null hypothesis for the gimp and nautilus while fail to do so for apache and evolution.
further study is clearly needed to shed light on this question.
general experience of author has no clear association with implicated code rq4 is general experience associated with implicated code for more severe defects?
if experienced authors always take the brunt of programming the most risky parts of the system it can happen oddly enough that they are responsible for more implicated code .
we come at this question somewhat indirectly asking if experienced developers are more responsible for implicated code corresponding to severe bugs.
we therefore compare weighted experience as is calculated in rq3 but for different bug severities.
thus we compare weighted experience of implicated code after breaking the data down by severity.
we use two partitions.
the severe partition contains blocker and critical and rest of the categories are partitioned as not severe .
we then compare these two497g gg gg ggg g severe bugs non severe bugs1 5apache weighted experience severity log10 weighted experience g gggg g g severe bugs non severe bugs1 6evolution weighted experience severity log10 weighted experience figure weighted author experience for severe bugs and other bugs in a apache b evolution.
distributions weighted experience using boxplots to see if the general experience is more associated with implicated code for more severe bugs alternative hypothesis .
figure depicts the boxplot of weighted experience of corresponding implicated code for severe and non severe bugs.
as is apparent from the figure and supported by the wilcoxon rank test p values are presented in table experienced authors may not be introducing significantly more severe defects than non experienced developers.
this suggests a lack of association of experience and the authorshi p of code involving severe defects.
experienced developers are not clearly associated with code implicated in severe defects.
.
discussion our findings have several important implications on existing software development practice.
we found that implicated code is mostly contributed by a single author.
this finding provides empirical support for linus law as asserted by raymond .
perhaps at this fine grained level programmers could efficiently review any contributions by their peers and perhaps serendipitously find and fix errors before they are exposed and reported into the issue tracking system.
interestingly this appears to conflict with the findings by which suggest that more contributors lead to more defects however it should be noted these results were both based on aggregated studies at the module and file levels whereas ours is a fine grained study at the line level of the implicated code.
perhaps at a coarse grained level it s more likely that contributors aren t as aware of each other s work this mutual long distance ignorance could lead to cross purposes and thus errors.
however weyuker et al.
and graves et al.
in another coarse grained study found that number of contributors were not a factor in defect proneness.
clearly the number of authors plays a complex role in defect proneness and further study is needed.
we speculate e.g.
that a code fragment with multiple authors in its backward slice is more likely to show defects if authors contributions are pairwise distant in the same slice.
we also found that specialized experience consistently helps in writing less defective code.
this suggests a very targeted inspection approach based on prior history of the contributions to a given file rather than directed inspection efforts at a coarse level to an entire file this approach would direct inspectors to a specific set of changed or new lines viz.
those written by developers into a file when those developershad less prior experience in that file.
given the isolated nature of implicated code written by mostly one developer even a review of only newly introduced code may yield fewer defects.
moreover instead of making changes themselves less familiar developers might be required to collaborate with more familiar developers subject to resource availability.
on the other hand the importance of general experience on implicated code is not clearly evident.
more research is needed to assess the precise impact.
but the findings of rq3 and rq4 suggest that general experience may not be very effective to ensure code quality.
however it is not our intention to downplay the value of general experience.
earlier findings suggest that general experience could cut down integration time and foster productivity .
also experience of one domain may provide an analogous solution for another domain .
moreover repetitive use of particular apis or working on a particular system could create episodic knowledge .
such episodic knowledge could help in writing succinct code or designing a better software .
.
threats to validity .
construct validity there are questions concerning whether we are truly measuring just and all of the implicated code.
bugs were collected from the bugzilla databases for each project and thus may not represent the complete set of all bugs.
however in all cases bugzilla is the designated repository of bug reports we also focus on the fixed bugs and thus the ones the community deemed worthy of repair.
we used an automated bug linking process which may be inaccurate.
there may be both false positives and false negatives in the linked set.
in a prior study we evaluated the false positive and false negative rates and found them to be quite low.
bias in fix reporting could have resulted in some fixes being unreport and might have affected our results.
in addition our implicated code identification algorithm us es thediff tool.
it is entirely possible that some of the changes in a revision marked as a bug fix are not in fact fixing lines which caused the bug.
in lieu of this problem we use an approach used by well known prior studies .
accuracy in identifying bug introducing changes may be increased by using advanced algorithms .
we use git blame which we have found produces highly accurate results even in the presence of white space changes and code movement .
we also ignore comments and blank lines in implicated code.
labeling of bug severity may not be entirely accurate and depends on many factors including external factors such as bug reporter and internal factors such as the criticality of impact.
however we only focus on the fixed bugs which the community deemed worthy of repair and thereby we believe they are more accurate in their severity labeling.
availability of large number of bugs also provides better resilience against possible bias.
we compared properties of implicated code against randomly chosen background code.
our chosen random code distribution may not be representative of the implicated code distribution.
we did take several measures as described in section .
to mitigate this threat.
sometimes implicated code may not really be buggy code but rather a kind of innocent bystander that gets changed to remedy a flaw elsewhere or even an unrelated change that just happened in a bug fixing commit.
however one can reasonably expect that usually implicated code is indeed buggy code and given the large number of fix inducing498hunks ranging from for apache to for gimp one can reasonably expect that the signals we see in the data are robust.
another issue is that bugs may have arisen due tomissing code such as an omitted case in a switch .
we haven t addressed this issue.
for measuring general experience we consider only the contribution in that particular project.
however developers may contribute in several other projects thereby garnering experience from those too.
measuring external experience would be difficult.
however given the long history of our studied projects and the participation of a large number of developers it is reasonable to assume that our method reasonably estimates general experience of the developers.
.
internal validity one issue raised by one of the reviewers is that implicated code is more likely to be logically cohesive and thus edite d by a single author.
this requires further study beginning with a clear definition of logically cohesive code.
meanwh ile as seen with rq1c above even multiply authored implicated code generally shows higher ownership than background code.
we present evidence that implicated code tends to be associated with fewer authors.
we also find that authors with prior experience of a file tend to be associated with less implicated code in that file.
while strong correlation exists the stringent requirements for causality have not been shown .
despite this our results do indeed show strong evidence that buggy code is different than other background code and provide support for further research examining why it is different and whether these properties can be utilized to develop better process model or to predict software failures.
.
external validity in an attempt to address the generalizability of our findings we have studied four real software projects that represent varying software processes and governance styles .
however while it is reasonable to believe that our results are representative of open source software it is unclear how well they generalize to commercial software which may have different ownership policies and behavior.
again we have provided evidence that bugs are different than background code they have fewer number of authors and they are less likely to be introduced by the primary contributor of the target file.
all of our study subjects were written in c. while c is a very popular language it is remarkably different from object oriented languages like java.
given the rich encapsulation support of oop it is entirely possible that topic knowledge would play a larger role and episodic knowledge would be more reusable.
it would be an interesting future work to study such possibilities.
.
conclusion we have studied open source projects to understand impact of ownership and developer experience on software defects.
using version control history we examine contributions to code fragments that are actually repaired to fix bugs.
are these troubled code fragments the result of contributions from many?
or from one?
does experience matter?
what type of experience?
we find that implicated code is more strongly associated with a single developer s contribution our findings also indicate that author s specialized experience in the target file is more important than general experience.
our findings suggest that quality controlefforts could be profitably targeted at changes made by single developers with limited prior experience on that file.