test input generation using dynamic programming razieh nokhbeh zaeem and sarfraz khurshid the university of texas at austin austin tx usa nokhbeh utexas.edu khurshid ece.utexas.edu abstract constraint based input generation is an effective technique for testing programs such as compilers and web browsers which have complex inputs.
however efficient generation of such inputs remains a challenging problem.
we present a novel input generation technique that takes constraints written as recursive predicates in the underlying programming language and uses dynamic programming to solve the constraints efficiently.
our key insight is to leverage the recursive structure of desired inputs and partition the problem of generating an input into several sub problems of generating smaller inputs that exhibit the same structure and then to use dynamic programming a well known problem solving methodology designed to exploit common sub problems to combine them.
a lazy initialization strategy and symbolic execution optimize our basic technique.
our technique provides not only bounded exhaustive input generation but also enables random input generation.
we show the correctness of our technique.
furthermore we present an experimental evaluation which shows that our technique can provide over an order of magnitude performance improvement for input generation compared to korat an efficient solver for structural constraints and pex a state of the art tool for symbolic execution .
finally we use our technique to effectively find bugs in production versions of google chrome and apple safari web browsers.
categories and subject descriptors d. .
testing and debugging testing tools keywords recursive test generation dynamic programming lazy initialization symbolic execution .
introduction test input generation is one of the most challenging tasks in automated testing.
generation is especially hard for programs such as browsers or compilers which take complex structures e.g.
html or java programs as inputs because such inputs are hard to generate automatically or sample at random.
constraint based testing provides the basis for effective techniques permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
sigsoft fse november cary north carolina usa.
copyright acm ... .
.
for generation of such structurally complex inputs an input constraint defines the structural properties of a class of desired inputs a constraint solver enumerates solutions to the constraint and the solutions are refined as test inputs.
advances in constraint solving technology have enabled solvers to handle more complex constraints.
however scaling constraintbased testing remains a challenging problem particularly when used for systematic testing i.e.
bounded exhaustive testing which tests against all inputs within a bound on the input size.
this paper introduces a novel constraint based technique for efficient and scalable generation of structurally complex inputs.
to write constraints our technique supports recursive predicates that are written in the same language as the program under test.
imperative predicates that check constraints especially class invariants are traditionally called repok methods .
our key insight is that not only are recursive predicates more natural to write for recursive structures which may also have some non recursive elements e.g.
a binary tree is either null or a node whose left and right children are each a binary tree but also recursive predicates naturally lend themselves to recursive input generation.
intuitively since the predicate definition is recursive it suffices to build the non recursive elements of a new input and use the same method to recursively build the recursive elements.
for example to build a binary tree which is not null it suffices to assign one node as the root and recursively call the same procedure to build binary trees for the right and left children.
our technique utilizes the recursive structure of desired inputs to divide the problem of generating an input into several sub problems of generating smaller inputs that exhibit the same structure and employs dynamic programming a well known problem solving methodology designed to exploit common sub problems to combine them and generate inputs in a bottom up manner.
to illustrate when exhaustively generating binary trees as inputs we build all binary trees of sizes and and use them to construct binary trees of size .
for random test generation we randomly generate some binary trees of sizes and and then combine them to sample binary trees of size .
since many recursive test inputs exhibit the property of overlapping sub problems dynamic programming saves us a lot of computation.
we present three algorithms for input generation a basic algorithm that uses dynamic programming directly a lazy initialization strategy that optimizes dynamic programming and a further optimization using symbolic execution .
our first algorithm dp utilizes dynamic programming to generate test inputs up to a given size.
to build a new test input we take formerly generated test inputs and combine them to build the recursive parts explore the state space to assign values to the non recursive parts and pass the resulting candidate object to the repok predicate for evaluation.
if repok returns true this object is saved as a valid input and is then used to create larger inputs.
our second algorithm lazydp uses lazy initialization to optimize performance.
to cope with the limitation of other resources beyond computational time such as memory we store a recursive test input concisely as an array of numbers where each number recursively represents a formerly generated test.
when combining inputs to build a candidate we do not expand all the smaller test inputs in the hierarchy from their concise form to actual objects.
instead we expand them lazily whenever repok accesses them.
our third algorithm symbolazydp further enhances the performance by skipping a systematic search for non recursive fields when possible.
for recursive fields this search is improved by using the first two algorithms where we restrict the choice of smaller sub problems to formerly generated solutions.
to avoid the search for non recursive fields the third algorithm adds symbolic execution which uses symbolic values for non recursive fields builds a path condition while executing repok and uses an in house constraint solver to solve for the symbolic values.
our technique not only enables efficient generation of inputs based on textbook data structures but also a wide range of stringbased inputs that represent structured data e.g.
strings that belong to a context free grammar sql queries data in a database management system java programs and html css pages.
we developed a prototype implementation of our three algorithms and evaluated it using microbenchmarks and real world applications including google chrome and apple safari web browsers.
this paper makes the following contributions.
we introduce the use of recursive predicates in constraint based generation of complex structures that have recursive and non recursive elements to both facilitate predicate formulation and enable faster input generation.
we present a novel technique for input generation using dynamic programming.
to our knowledge dynamic programming has not previously been used to generate structurally complex inputs.
we prove the correctness of our technique.
we utilize lazy initialization and symbolic execution to optimize the performance of dynamic programming for input generation.
we apply our technique based on dynamic programming for both exhaustive and random generation of test inputs.
we use our prototype implementation to evaluate our technique.
experimental results show our technique improves input generation performance and scalability for microbenchmarks over state of the art testing tools pex and korat and effectively finds real bugs in production versions of two widely used applications.
.
example in this section we describe two examples a binary tree which we use as a running example and an html input that we use alongside with a css input to test a web browser.
the recursive definition of a binary tree is as follows a binary tree is either null or a node whose left and right children each point to a binary tree.
the tree should not have any loops.
furthermore in our binary tree btsize is equal to the number of nodes in the tree.
listing shows the recursive implementation of a binary tree.
one can easily see that a recursive repok is a natural way of describing the properties of a recursive data structure.
listing shows the repok method of an html input.
the backbone of such an input is a generic tree a recursive data structure.
in addition other constraints are enforced on html tags.
in section .
we demonstrate how to leverage this modeling of html files and list modeling of css files to automatically generate bug revealing test inputs for the chrome and safari web browsers.
figure models the nested structure of tags in listing section .
.1c l a s s b i n a r y t r e e b i n a r y t r e e r i g h t l e f t i n t b t s i z e boolean repok i f !
a c y c l i c return f a l s e return r e c u r s i v e r e p o k boolean r e c u r s i v e r e p o k i n t r i g h t b t s i z e l e f t b t s i z e i f r i g h t n u l l r i g h t b t s i z e e l s e i f !
r i g h t .
r e c u r s i v e r e p o k return f a l s e r i g h t b t s i z e r i g h t .
b t s i z e i f l e f t n u l l l e f t b t s i z e e l s e i f !
l e f t .
r e c u r s i v e r e p o k return f a l s e l e f t b t s i z e l e f t .
b t s i z e i f b t s i z e r i g h t b t s i z e l e f t b t s i z e return t ru e e l s e return f a l s e listing a recursive binary tree in java.
1c l a s s html i n t t a g i n d e x html c h i l d a t t r i b u t e a t t r s t r i n g htmltags html head l i n k body .
.
.
boolean repok i f !
a c y c l i c return f a l s e i f t a g i n d e x !
h tml return f a l s e i f !
c h i l d .
repokhead return f a l s e i f !
c h i l d .
repokbody return f a l s e .
.
.
return t ru e boolean repokbody i f t a g i n d e x !
body return f a l s e i f !
c h i l d .
r e c u r s i v e r e p o k return f a l s e .
.
.
return t r ue listing html repok method.
c63 c62 c61 c60 c56 c57 c58 c59html d1 d1 d29 d29 c63 c62 c61 c60 c56 c57 c58 c59head d15 d15 c63 c62 c61 c60 c56 c57 c58 c59body d15 d15 c63 c62 c61 c60 c56 c57 c58 c59link c63 c62 c61 c60 c56 c57 c58 c59div d15 d15 c63 c62 c61 c60 c56 c57 c58 c59h1 d15 d15 c63 c62 c61 c60 c56 c57 c58 c59div d15 d15 c63 c62 c61 c60 c56 c57 c58 c59h1 figur e a tree representation of an html input.
note that we support repok methods with both recursive and non recursive parts.
the btsize of each subtree in listing and therepokhead andrepokbody checks in listing are examples of non recursive parts of a repok.
.
framework in this section we describe how we use recursive definitions of data structures for exhaustive and random test generation.
we explain our three algorithms and prove a theorem on their correctness.
.
recursive repok methods many test inputs such as data structures have an embedded recursive structure.
sets trees stacks queues arrays heaps and many other data structures have recursive definitions.
using recursion in repok to identify correct instances of recursive loop free data structures makes repok easier to write read and debug.
besides identifying correct instances of a data structure a repok method should be able to identify incorrect structures as well but incorrect structures are not necessarily loop free.
to comply with this standard definition of repok we require the template shown in the repok method of listing .
this repok first checks for cycles and then enters the recursion phase to avoid an infinite loop.
throughout this paper we use recursive repok methods that assume acyclicity.
2we process the source of a recursive repok through a simple pattern matching to find all recursive calls.
a field on which repok is recursively called is identified as a recursive field .
we could also identify recursive calls by processing the abstract syntax tree of method calls.
.
algorithms here we describe dp lazydp and symbolazydp.
the use of these algorithms is orthogonal to exhaustive or random test generation.
in section .
.
we describe a variation of the algorithms that generates random tests.
.
.
dp generation of test inputs can benefit from the recursive structure of repok.
given a recursive repok the goal of exhaustive test generation is to generate all test inputs in a given scope for which repok returns true.
for example the recursive repok of a binary tree listing checks whether its right and left children are correct binary trees and whether btsize is correctly set to the sum of thebtsize fields of the children plus one.
by observing the execution of repok we present our recursive method of generation a new candidate test is generated by setting its recursive fields to formerly generated correct tests and finding correct values for the non recursive fields.
then repok is invoked on the candidates to filter out the incorrect ones.
the repok method directly rejects the candidates with loops and recursively calls itself to evaluate different parts of the loop free candidates.
this check includes assuring the correctness of recursive substructures.
because we provide previously generated valid test inputs as substructures we can bypass these internal recursive calls and directly return true for them.
besides breaking the problem into subproblems our generation method demonstrates the other property necessary to a dynamic programming solution overlapping subproblems.
the same substructure is used multiple times to build new candidate test inputs.
for more efficient test generation the dp algorithm avoids generating repetitive candidates.
to this end we generate test inputs in iterations and keep three sets of previously generated inputs thisroundtests contains correct tests generated in the current iteration lastroundtests includes correct tests generated in the last iteration which have not yet been used to build other candidates and pool contains all other correct tests generated so far.
at the beginning of test generation pool andthisroundtests are empty and lastroundtests contains only null line of listing .
we assume that null is always a valid test input because we cannot call repok on null e.g.
it throws a nullpointerexception in a java program and for all common data structures null is a valid instance.
the dp algorithm proceeds as follows listing .
if repok makesrrecursive calls we need r not necessarily different but ordered tests to build a new test.
the outer while loop lines to executes as long as it makes progress in generating new test inputs.
at each iteration the test inputs generated in the previous iterations are combined to form new candidates then repok is invoked to identify correct test inputs.
more specifically the recursives array selects a permutation of rrecursive substructures by calling the nextpermutation method.
this method iterates over pool andlastroundtests and upon each invocation provides the next permutation of rsubstructures from the set lastroundtests pool such that at least one of the rsubstructures is selected from lastroundtests.
section .
shows how this constraint assures that we would avoid repetitive candidates.
when all permutations are exhausted this method returns null .
a challenge for dp is the exponential growth of the number of candidates at the outer boundaries of the scope.
in fact even cre 1v oid t e s t g e n e r a t i o n i n t r g e t n u m r e c u r s i v e c h i l d r e n i n t s getnumnonrecursivefields po ol i n i t i a l i z e l a s t r o u n d t e s t s i n i t i a l i z e addto l a s t r o u n d t e s t s null i s t h e s i z e o f n u l l t o t a l e x p l o r e d v a l i d c a s e s g e n e r a t e d boolean p r o g r e s s tru e while p r o g r e s s t e s t g e n e r a t i o n round lo op p r o g r e s s f a l s e t h i s r o u n d t e s t s i n i t i a l i z e i n t r e c u r s i v e s n e x t p e r m u t a t i o n r while r e c u r s i v e s !
n u l l i f s i z e r e c u r s i v e s maxnumrecursives r e c u r s i v e s n e x t p e r m u t a t i o n p r u n i n g r s i z e r e c u r s i v e s c o n t i n u e i n t f i e l d s n e x t v a l u a t i o n s while f i e l d s !
n u l l t o t a l e x p l o r e d o b j e c t t e s t c a s e o b j b u i l d c a n d i d a t e r e c u r s i v e s f i e l d s i f t e s t c a s e o b j .
repok !
randomison c o i n t o s s s i z e r e c u r s i v e s p r o g r e s s t ru e v a l i d c a s e s g e n e r a t e d addto t h i s r o u n d t e s t s combine r e c u r s i v e s f i e l d s s i z e r e c u r s i v e s f i e l d s n e x t v a l u a t i o n s r e c u r s i v e s n e x t p e r m u t a t i o n r f o r i n t t e s t l a s t r o u n d t e s t s addto pool t e s t s i z e t e s t l a s t r o u n d t e s t s t h i s r o u n d t e s t s end t e s t g e n e r a t i o n round loo p listing test generation algorithm in java.
ating those candidates can considerably affect the performance.
to address this challenge we keep the tests in each of the three sets sorted according to their sizes.
we use bucket sort since the maximum size of a valid test is known from the scope as we add new tests.
in listing once recursives is selected we first examine its size in line .
if a candidate built with this permutation would be outside the scope we throw this permutation away and also prune all other permutations with the same or bigger sizes via calling the nextpermutationpruning method.
this method gives the next permutation that is inside the scope.
once we have such a permutation we use the rsubstructures to build the recursive fields of a new candidate.
in order to find the proper values for the non recursive fields we perform a systematic search by calling the nextvaluation method which upon each invocation returns one valuation for the non recursive fields.
a permutation for recursives together with a valuation of fields gives us a candidate testcaseobj which we send to repok.
if repok returns true ignoring randomison andcointoss for now the new test gets added to thisroundtests with its appropriate size otherwise it is discarded.
at the end of the outer while loop when all permutations are exhausted the tests in lastroundtests joinpool lines and the tests in thisroundtests replace lastroundtests line and we move on to the next round.
in the dp algorithm size is defined recursively as follows.
if a candidate is null its size is .
otherwise the size of a candidate is the sum of the sizes of its recursive substructures plus one.
note that in the example of a binary tree btsize has the same meaning of size.
the size concept built into the dp algorithm however does not necessarily correspond to a field of the data structure.
the dp algorithm memoizes and uses the size of a test whereas it treats btsize as a non recursive field and performs a systematic search to find its correct value for any candidate.
consider the example of finding binary trees up to size figure .
in the first iteration the invocation of nextpermutation 3iteration size size size size pool lastroundtestsnull btsize thisroundtests c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d29 d29 iteration size size size size poolbtsize lastroundtests c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d29 d29 thisroundtests c31 c30 c29 c28 c24 c25 c26 c27btsize d2 d2 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d28 d28 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d121 d121sss d37 d37 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 iteration size size size size poolbtsize c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d29 d29 lastroundtests c31 c30 c29 c28 c24 c25 c26 c27btsize d2 d2 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d28 d28 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d121 d121sss d37 d37 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 thisroundtests c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d28 d28 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d2 d2 d28 d28 c31 c30 c29 c28 c24 c25 c26 c27 d2 d2 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d2 d2 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 c31 c30 c29 c28 c24 c25 c26 c27btsize d2 d2 d28 d28 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d28 d28 c31 c30 c29 c28 c24 c25 c26 c27 d1 d1 d29 d29 figure finding binary trees up to size .
trees are numbered using in the order they are generated.
returns different permutations of r i.e.
two formerly generated binary trees such that at least one of them is from lastroundtests.
here there is only one option null for both right and left children.
the total size of the binary trees in recursives is0 which is still less than so no pruning happens at this point.
furthermore s implies that there is one field btsize for which we should systematically search all values in the scope.
we build candidates by assigning null as both children and exploring different values for btsize ranging from to these numbers come from the scope .
each of these candidates is sent to repok and the one with btsize correctly set to returns true.
upon receiving true from repok the new test is saved in thisroundtests and the algorithm continues until all permutations and valuations are exhausted.
at the end of this round null moves topool and tree moves tolastroundtests.
the algorithm continues in the same manner.
in the third iteration first binary trees and are combined with binary tree null to generate four binary trees of size .
then an example of pruning occurs.
once the algorithm selects tree from lastroundtests and tree from pool the check on the size of recursives indicates that the resulting candidate would be outside the scope.
therefore nextpermutationpruning is called to find the next permutation of recursives that is inside the scope.
because all other permutations are bigger in size they are pruned.
for brevity we do not show iteration wherein no new test is generated.
the algorithm terminates at the beginning of iteration when all valid inputs are in pool.
.
.
random generation our use of dynamic programming is orthogonal to random or exhaustive test generation and can be applied to both.
in order to generate random tests we introduce randomization into the process of saving valid inputs.
for random test generation randomison returns true on line of listing .
therefore saving or discarding a correct test input depends on the value returned from cointoss size recursives .
this method heuristically returns true for all small inputs inputs with a size less than a thresh old parameter in order to save them all and uses a random number generator a coin toss with a fixed probability of success to randomly save or discard other correct test inputs.
as the algorithm continues to execute discarded tests do not take part in test generation.
at the end the algorithm generates one or several random tests of a given size.
keeping all small inputs for example the single node binary tree helps in reducing the chance of having repetitive patterns in one random test.
in the case of generating multiple tests if sharing structures between tests is undesirable one could run the algorithm from scratch multiple times.
as section shows our algorithms are efficient enough to generate big inputs in a matter of seconds and one can run them several times.
.
.
lazydp one problem that arises during the test generation is the limitation of other resources beyond computational time such as memory.
if we keep tests as objects we run out of the heap memory space for bigger scopes.
as listing shows to optimize memory usage tests are saved in the compact form of an array of integers.
these integers are either indexes of smaller substructures which in turn point to other arrays of integers or values of non recursive fields.
for example tree is saved as right child left child btsize where tree is in turn kept as right child left child btsize .
the value of a non recursive field is saved as an index with respect to the scope.
for example if there is a field with primitive type boolean whose values are false and true in the scope represents false and represents true.
whenever we create a bigger candidate test input using smaller previously generated tests we need to call repok to examine the correctness of the candidate.
consequently we need to retrieve the smaller tests build their corresponding objects and then utilize them to build the candidate.
we build the smaller tests with the lazy initialization technique which means that the substructures get initialized i.e.
expanded from arrays of integers to objects only when repok accesses a field from them.
for binary trees since repok of listing only accesses btsize 4of the direct children of a node we only expand the direct children to objects and keep their children as arrays.
for example the expansion of binary tree is limited to expanding binary trees and and not binary tree which is a child of binary tree .
.
.
symbolazydp while both dynamic programming and lazy initialization improve finding the recursive values of a candidate in order to find the correct values for its non recursive fields e.g.
btsize we still need to search all valuations which diminishes the efficiency and scalability of test generation.
to avoid such a search we observe that the values of many non recursive fields of a test can be symbolically computed rather than searched for.
following previous work we use symbolic execution for non recursive fields.
using symbols instead of concrete values for fields we build a path condition a boolean formula over the symbols which represents the constraints that should be satisfied to follow a path while executing repok.
at the end of the repok execution we use a constraint solver to solve the path condition and calculate concrete values for non recursive fields.
in order to enable symbolic execution we use a source to source instrumentation on the repok method .
we replace each branch condition with a boolean variable which takes both true and false values.
when it takes the true value we add the original branch condition to the path condition.
when it takes the false value we add the negation of the original condition.
all valuations of such boolean variables provide all execution paths.
listing shows the corresponding instrumentation for btsize replacing the last two lines of listing .
upon reaching a return statement we invoke a constraint solver to solve the path condition and consider each solution as an acceptable valuation for the non recursive fields.
for example btsize of a candidate binary tree is assigned through solving the condition added on line of listing .
we save the path condition with each valid substructure but do not save the solution i.e.
substructures are saved with symbolic non recursive fields and constraints on them.
after combining the substructures we perform symbolic execution on the entire candidate including the recursive calls because solving the substructures separately does not necessarily give compatible results e.g.
consider solving the search constraint on integer elements of a binary search tree it is possible to save valid integer elements in the right and left children that violate the search constraint at the root making the constraint infeasible .
19i f g e t b o o l e a n addcond b t s i z e eq r i g h t b t s i z e l e f t b t s i z e return tr u e e l s e addcond b t s i z e noteq r i g h t b t s i z e l e f t b t s i z e return f a l s e listing instrumenting binarytree for symbolic execution.
.
theorem in this section we prove that the dp algorithm generates all valid tests in the scope and it does not generated any valid or invalid candidate more than once.
definesras the value of set s e.g.
pool at the end of round r. furthermore define discarded ras the set of candidates discarded during roundr including those outside the scope.
definition .visited candidates visitedcands r poolr lastroundtests r uniontextr i 1discarded i. defi nition .t c for a candidate c lett c be the set of all test inputs that cuses as its recursive substructures.lemma .at the end of each round r r and for any candidate c the following loop invariant holds t c poolr c visitedcands r proof by induction .
the base case is the beginning of round one were pool0 .
the only candidate that does not use any recursi ve substructures is null.
yet null lastroundtests and hence null vi sitedcands so the invariant holds.
for the induction step assume that t c poolr c visitedcands r at the end of round r the tests in lastroundtests joinpool and then the tests in thisroundtests replacelastroundtests.
poolr poolr lastroundtests r lastroundtests r thisroundtests r suppose that the invariant does not hold at the end of round r .
c t c poolr c visitedcands r now t c lastroundtests ris either a or b negationslash .
for case a a t c poolr c visitedcands r de finition c visitedcands r which contradicts with .
for case b t t c t lastroundtests r note that the algorithm generates all permutations of the tests belonging to lastroundtests orpool that have at least one test fromlastroundtests i.e.
t c poolr lastroundtests r t t c t lastroundtests r c thisroundtests r discarded r c thisroundtests r discarded r de finition1 c visitedcands r which ag ain contradicts with .
th eorem .part for a given scope the algorithm generates all valid tests.
part the algorithm does not generate any valid or invalid candidate more than once.
proof of part .
letc be the smallest correct test that the algorithm f ails to generate.
if the algorithm terminates right after roundfin repok c true c visitedcands f in c re pok c true c visitedcands fin size c size c t t c size t size c t t c repok t true t t c t visitedcands f in further the termination of the algorithm at the end of round fin means that no progress was made in this round.
accordingly no test was added to thisroundtests fin.
by using lastroundtests fin thisroundtests fin vi sitedcands fin poolfin fin uniondisplay i 1discarded i 1fin 0since the test generation loop executes at least once.
5now let us assume that c is inside the scope.
si ze c scope.size t t c size t s cope.size from the definition of discarded we have c discarded r repok c negationslash true size c scope.size t t c t f in uniondisplay i 1discarded i t t c t poolfin lemma1 c visitedcands f in but contradicts with which proves part .
pr oof of part 2by induction .
consider r 0for the induction base.
because only one instance of null is generated before the first round no repetition happens at r .
for the induction step assume that all candidates visited up to the end of round rare distinct.
we use negationslash to show that two candidates are different instances although they might be equal .
t t visitedcands r t negationslash t t t suppose that the first repetitious candidate named c is generated during round r .
c thisroundtests r discarded r cis repetitious so another instance of it named c is already generated at roundr .
c thisroundtests r discarded r t c poolr lastroundtests r t c poolr lastroundtests r either a r r 1or b r r .
for case a note that during one round of test generation methods nextpermutation andnextpermutationpruning provide distinct permutations.
so in order to have repetitive candidates at least one of the substructures should have more than one instance.
t t c t t c t negationslash t t t a t t visitedcands r t negationslash t t t which contradicts with .
for case b notice that at least one substructure is selected from lastroundtests.
c c t t c t lastroundtests r t lastroundtests r visitedcands r r r which contradicts with b .
.
ev aluation in order to evaluate our test generation methods we implemented a prototype of the algorithms and designed some experiments wherein we address two research questions rq1 how efficient and scalable are our algorithms compared to state of the art test generation tools pex and korat ?
2thealgorithm never generates null again sor negationslash .
rq2 how effective are the generated tests in finding bugs in real world applications chrome and safari web browsers ?
in the first set of experiments we used six microbenchmarks which are complex data structures widely used in programs and as test inputs.
previous work has extensively used these benchmarks for evaluation .
in order to answer the first question we need an alternative exploration method of the state space of possible test inputs.
a naive exploration of the state space will give rather unacceptable results.
therefore we compare our methods to microsoft pex a state of the art test generation tool for .net and korat a well known test generation method and an open source tool for java programs.
pex is a white box test generation tool that performs symbolic execution.
in addition it uses path bounded model checking to cover different paths in the program.
pex is an appropriate subject tool it particularly addresses the effect of symbolic execution.
generation of test inputs considered in this paper is black box with respect to the code under test yet we allow pex to explore different paths in repok.
we used the same repok methods for pex and korat except for minor changes to accommodate syntactic differences between c and java respectively.
the korat algorithm monitors repok executions to prune large portions of the bounded space of candidate structures.
korat is an appropriate subject tool too previous work shows that korat is among the most efficient solvers for complex structural constraints.
in addition to exhaustively generating test inputs we compare the efficiency and scalability of our algorithms with pex and korat when sampling a few large test inputs.
in the second set of experiments we show how to naturally model html and css3 files as acyclic data structures.
such files which are test inputs to any web browser are examples of practical and common yet user defined test inputs.
by systematically generating html and css3 test inputs our generation methods found real bugs in the latest versions of two well known web browsers google chrome and apple safari.
.
experimental settings throughout the evaluation we ran each experiment five times and reported the averages.
all experiments used a .50ghz core duo processor with .00gb ram running windows .
we used sun s java sdk .
.
jvm with our methods and korat and microsoft visual c version .
.
rtmrel with pex version .
.
.
.
pex used z3 theorem prover version .
.
in section .
we used google chrome version .
.
.
m for windows and apple safari .
.
the latest versions as of the date of this paper.
for symbolic execution we used our in house constraint solver developed in java.
the source to source instrumentation for symbolic execution is currently manual but is mechanical and can be automated .
for exhaustive test generation with pex we used the following setting to force pex to generate all test inputs testemissionfilter pextestemissionfilter.all .
microbenchmarks to address rq1 for exhaustive test generation we considered six microbenchmarks.
table shows the results for the biggest sizes considered.
for all six microbenchmarks and all sizes considered including those not shown dp and lazydp generate the same number of tests as korat.
symbolazydp and pex generate the same number of tests since they both use symbolic execution and report one solution for each path condition instead of exploring all valuations from the state space.
in addition to improving test generation performance and scalability symbolic execution im6table exhaustive test generation for the biggest sizes.
to represents a time out of 1000s.
best performance highlighted.
benchmark biggest valid tests candidates generation time s state size korat dp symbo pex korat dp symbo pex korat dp lazydp symbo pex space lazydp lazydp lazydp lazydp lazydp linkedlist .
.
.
.
.
binarytree to to .
.
.
.
to1026 redblacktree to to .
.
to .
to1026 fibonacciheap to to .
.
.
.
to1014 binaryheap .
.
.
.
.
hashtable to to .
.
.
.
to1038 .
.
.
.
.
.
size of generated tests sortedsinlylinkedlist korat dp lazydp symbolazydp pex1.
.
.
.
.
.
size of generated tests binarytree korat dp lazydp symbolazydp pex .
.
.
.
.
.
size of generated tests redblacktree korat dp lazydp symbolazydp pex1.
.
.
.
.
.
size of generated tests fibonacciheap korat dp lazydp symbolazydp pex .
.
.
.
.
.
size of generated tests binaryheap korat dp lazydp symbolazydp pex1.
.
.
.
.
.
size of generated tests hashtable korat dp lazydp symbolazydp pex figure performance comparison on microbenchmarks.
pro vestest execution by reporting less yet representative test inputs.
symbolazydp is the most efficient generation method for all the microbenchmarks on the biggest size.
figure shows the performance evaluation results.
the first data structure is a sorted singly linked list of integer elements.
here dp and lazydp constantly outperform korat.
lazy initialization is effective here especially because properties like being sorted are verified locally it suffices to compare each node s element with its neighbor s. pex outperforms dp and lazydp on bigger sizes for two data structures singly linked list and binary heap.
the reason is that pex generates far fewer tests by symbolically executing repok and representing all sorted lists of a given size with only one test while korat dp and lazydp exhaust different valuations.
symbolazydp however shows the best performance among all the methods.
it generates the same number of tests and growswith the same pace as pex but it is multiple times faster.
notice that the vertical axis is logarithmic.
the next benchmark is a binary tree as described in section .
as figure displays symbolazydp performs the best.
pex can only enumerate all binary trees up to size before timing out.
we also experimented with red black trees with size key and color.
while dp and lazydp are faster than korat at first korat takes over them at some point because dp and lazydp have to explore all valuations of key and color but korat prunes many of them.
notice that lazydp takes slightly more time than dp on this benchmark.
this is because repok needs to explore down the tree to find minimum and maximum keys to evaluate the search tree property and eventually expands many substructures which undermines the usage of lazy initialization.
pex uses symbolic execution for key and color but cannot generate all red black trees with four nodes or 7table random generation of ten tests with size .
to represents a time out of 1000s.
best performance highlighted.
benchmark valid tests candidates generation time s state korat symbolazydp pex korat symbolazydp pex korat symbolazydp pex space linkedlist .
.
binarytree .
.
redblacktree to to to to to .
to10529 fibonacciheap to to .
.
to binaryheap .
.
hashtable to to to to to .
to10527 korat dp lazydp size of generated tests figure memory usage for redblacktree .
more.
symbolazydp using dynamic programming and symbolic execution closely competes with korat and eventually takes over.
figure compares the memory usage of our methods and korat for red black trees.
dp and lazydp generate the same number of tests so they always use equal amounts of memory.
symbolazydp generates less tests and hence uses less memory.
korat keeps only one candidate vector while we have to keep all correct tests albeit in a compact format .
hence the memory usage of our methods grows faster than korat.
however since the java heap space is usually in the order of a few gb s 10mb of memory usage should not be a problem.
the memory usage of the other benchmarks follows a very similar pattern.
the next benchmark is a fibonacci heap.
this is the only case where the memory usage is a concern for dp and lazydp.
in fact for fibonacci heaps with more than six nodes dp and lazydp run out of the heap space and korat and pex run out of time.
yet symbolazydp does not time out and is the most efficient.
the next benchmark a binary heap gives results similar to the sorted singly linked list.
symbolazydp is the most efficient.
in the last benchmark a hash table implemented using nested lists lazydp and dp are slightly better than korat.
the difference increases when a time consuming hash function is used.
since we use previously generated tests we avoid many calls to the hash function.
the generation time for pex starts off at a bigger value and increases at the same pace as symbolazydp.
symbolazydp outperforms all the other methods.
finally it is worth mentioning that pex and symbolazydp both require path bounds e.g.
for loop unrolling .
throughout the experiments we used trial and error to find and set the smallest bounds that provide all tests.
similarly korat dp and lazydp need a bound on primitive e.g.
integer values.
the number of primitives used usually has a relationship with the test size.
.
random test generation to address rq1 for random test generation we considered generating ten random tests of ninety to a hundred nodes .
for korat and pex we took the first ten tests generated in the desired size range.
for symbolazydp all small tests up to size were saved and bigger tests were saved or discarded at random section .
.
.
except for the fibonacci heap benchmark symbolazydp is the most efficient and scalable.
.
google chrome and apple safari to address rq2 and showcase the ability of our methods in finding bugs in real world well tested3 commercial applications we tested the support for rendering css3 3d effects by chrome and safari web browsers.
css cascading style sheets is a style sheet language that separates the presentation of a markup language document from its content and is commonly used to style web pages written in html and xhtml.
css3 the latest variation of css enables web developers to add 3d effects to web pages i.e.
position and move elements in the three dimensional space.
apple safari and google chrome web browsers support css3 3d effects.
as of the date of this paper chrome and safari are the third and fourth most widely used desktop web browsers with .
and .
worldwide usage share respectively .
safari is developed in c and objective c and precedes chrome in supporting 3d transforms.
chrome is developed in c assembly python and javascript.
both of these browsers use webkit layout engine which introduced 3d transforms in css.
we directly tested kloc of c code .cc .h files from chrome.
safari is mb compiled.
our test for safari included .
kloc .cpp .h files of its open source code plus its closed source implementation.
.
.
modeling html and css test inputs an html file is composed of a set of nested html elements.
an html element includes a start tag e.g.
h1 and an end tag e.g.
h1 .
the start tag might also have some attributes e.g.
class classname .
we modeled an instance of an html file as a tree.
the whole document is contained between html start and end tags which we consider as the root of the tree.
further each tag is represented as a node that has some attributes and an ordered set of children which are the tags immediately inside it.
listing shows some parts of the html model.
figure shows the tree representation of listing .
1s e l e c t o r p r o p e r t y v a l u e p r o p e r t y v a l u e .
.
.
listing abstraction of a css rule.
a css file consists of a list of rules.
a rule has a selector and a declaration block.
inside a block each declaration has a property followed by a list of values.
listing shows an abstraction of a css rule.
we modeled each css rule as a linked list of alphabetically sorted4properties where each property has a linked list of values.
asone could see our html and css models are intuitive and easy to implement as recursive loop free data structures.
indeed we have already implemented both of them as microbenchmarks.
3for example chrome is extensively tested before release and claims to pass of webkit s layout tests .
the css3 3d effects are among the webkit s layouts.
4because the order of properties is irrelevant we keep them sorted toa void duplicates.
.
classname4 webkit t r a n s f o r m r o t a t e y deg .
classname12 webkit p e r s p e c t i v e webkit bac k fa c e v i s i b i l i t y h i d d e n listing an automatically generated css test input file.css .
h tml head l i n k r e l s t y l e s h e e t type t e x t c s s h re f f i l e .
c s s l i n k head body div c l a s s classname4 h1 thi s i s some t e x t div c l a s s classname12 h1 t hi s i s some t e x t h1 div h1 div body html listing an automatically generated html test input.
listings and show bug revealing examples of html and css inputs automatically generated by our methods.
.
.
experimental results using the above models we systematically generated all test inputs with up to eight tags two div tags inside an html file and two declarations inside a css declaration block.
five css properties were used perspective backface visibility transform transform origin and transform style.
also various values for these properties were used including perspective rotate scale skew and translate for the transform property.
each html tag could have a css selector as its class attribute see listings and as an example .
consistency constraints between css and html files are maintained by first running the css input generator and then feeding the number of classes it generates to the html input generator to exhaustively cover all classes.
table shows a summary of the results.
in total test inputs each including an html file with the corresponding css file were generated.
the size of the input space for the chosen bounds is .
the size bound in this experiment is too small to get lazydp benefits.
ho wever symbolazydp gives a clear advantage.
in our model symbolazydp is not applicable on css inputs for the lack of non recursive fields that can be executed symbolically.
.
.
differential testing so far we have automatically generated the test inputs.
but in order to test chrome and safari with these tests we need an oracle that defines the correct rendered output for any given test input.
since no such oracle was available we use differential testing where the outputs of two implementations are checked against each other.
whenever the outputs are not the same there likely is a bug in at least one of the implementations.
we wrote a test harness in java that automatically launches chrome and safari with each test input and performs a basic image differencing algorithm to compare the screen shots taken from them.
all test inputs were checked in less than hours.
such time consuming checks are specific to this application.
furthermore improving the performance of launching the browsers and image differencing is possible yet beyond the scope of this paper.
.
.
bugs found among the tests generated tests were rendered differently by chrome and safari.
we semi automatically investigated these tests.
out of these failures cases were false positive due to the inaccuracy of our image differencing algorithm.
we manually classified the rest of the failing tests tests based on the css properties used and found at least three distinct bugs intable chrome and safari test input generation results.
candidates gen. time s tests css html css html dp .
.
lazydp .
.
symbolazydp n a n a .
the production code stable releases of chrome and safari.
the actual number of faults in the code which produce these failures in fact may be greater.
however localizing the faults was not possible due to the proprietary code of safari.
we reported three bugs in chrome.
one of these bugs was regarding the hidden backfacevisibility of an element.
listings and reveal this bug.
another bug involved the webkit perspective property.
both of these bugs in chrome were already reported and confirmed issue in the chromium project and are fixed in the next canary release.
the last bug was due to a rotation direction inconsistency with the w3c editor s draft march as the standardization in progress of css 3d transforms.
this bug is not confirmed by google inc. as of the date of this paper.
consider listings and .
to reveal this bug we need two nested classes where the outer one has a degree rotation and the inner one has a hidden visibility as well as the webkit perspective property.
invoking the hidden visibility by itself or in any other setting is not enough to show the problem.
.
.
applying symbolic execution and korat we strove to use symbolic execution on the source code available from chrome.
the corresponding code however includes .cc .h files kloc of code that collectively render a css 3d effect.
we were unable to apply white box symbolic execution due to the code size and complexity.
symbolic execution is not feasible for testing closed source systems safari .
korat can in principle find the bugs if given enough time.
yet as we showed our technique outperforms korat in all the cases of exhaustive test generation.
.
threats to validity internal validity.
to implement our algorithms for test generation using dynamic programming we strictly followed the original algorithms used well known libraries and validated the number of inputs generated to match the numbers generated by other independently developed tools namely korat and pex.
to compare with korat we used its open source implementation that has been in the public domain for over five years and used the repok s that are distributed with it.
to compare with pex we used its public distribution version .
.
.
while setting the search depth bound to the smallest number required to complete the generation of all inputs within the chosen size in order to minimize the exploration time for pex.
we carefully performed a faithful translation of java repok s used for korat into c to run pex.
we used our own in house constraint solver developed in java for symbolic execution with dynamic programming which might give different performance results compared to z3 used by pex.
although it is unlikely that our solver in java is faster than the state of the art z3 to address this threat we plan to use z3 as a part of future work.
external validity.
the main threat here involves using only two industrial programs chrome and safari .
to address this threat we experimented with microbenchmarks that have previously been used by a number of other authors .
construct validity.
we used metrics commonly used in software testing research to compare test generation tools and automated our entire test generation and execution process.
furthermore we manually investigated the failures reported for the browser testing.
.
applicability our work directly enables systematic i.e.
bounded exhaustive testing to scale better for certain applications e.g.
refactoring engines compilers model checkers and browsers which clearly must be tested against larger inputs.
the inputs to these applications are programs themselves which can be modeled and generated at the abstract syntax tree level an acyclic structure using structural constraints.
e.g.
alloy programs were modeled and generated to find bugs in alloy alpha more recently systematic testing found bugs in eclipse netbeans sun javac and jpf .
more generally our work can help systematic grammar based testing techniques .
such techniques enumerate all strings up to a given bound that belong to a context free grammar.
contextfree grammars can describe various input types such as xml schemas and programs.
to illustrate consider the work of khalek et al.
which uses constraint based testing to reveal bugs in oracle 11g.
it enumerates solutions for a subset of sql grammar and a schema to provide queries and populate the database.
our technique has a direct application in generating strings that belong to the sql grammar and can also improve the generation of tabular test data.
our use of dynamic programming is not limited to bounded exhaustive generation rather our technique also facilitates random test generation which complements systematic testing and has also been used successfully to find bugs .
most recently yang et al.
used random test generation to find numerous bugs in mainstream c compilers .
as our work shows dynamic programming can be used in synergy with random test generation.
while we describe algorithms for generating recursive structures without cycles our approach can be used to generate cyclic structures as a part of a multi step generation technique.
for example we can generate an acyclic backbone in the first step using dynamic programming and populate the remaining fields using constraintbased data structure repair in the second step.
.
related work the importance of using specifications in testing has long been recognized .
several projects automate test generation from specifications in various languages .
the specific use of logical constraints to represent inputs dates back at least three decades .
but a focus of prior work has been to solve constraints on primitives and not on complex structures which require very different constraint solving techniques.
korat and testera are among the first frameworks to provide systematic generation of structurally complex tests from constraints.
following this spirit of systematic black box testing astgen and udita are two more recent frameworks which have been used successfully to find bugs in real applications including refactoring engines.
astgen requires the user to write imperative test input generators whose executions produce input programs for refactoring engines.
astgen bears some similarities to our framework in composing test generators to build bigger inputs.
however it is limited to testing refactoring engines and requires the user to explicitly specify how to generate test inputs.
udita provides a programming language to describe test inputs using a combination of declarative and imperative styles where constraint solving is used in conjunction with partial generators.
lava and quickcheck can also provide generation of complex structures.
lava requires the user to describe inputs using a production grammar and generates strings in the grammar but cannot handle complex constraints such as those of a red black tree.
quickcheck requires the user to write a generator for complex inputs and generates random inputs for testing functional programsin haskell using a technique similar to recursion with lazy initialization.
similarly gast generates tests for programs written in functional languages.
however quickcheck and gast use pure top down recursion and not dynamic programming.
while dynamic programming has been used for monitor generation from formal specifications to our knowledge there is no previous work on using dynamic programming for test input generation.
several tools use method sequences for testing object oriented programs and can generate complex structures using systematic or randomized exploration .
while these tools allow unit testing they cannot feasibly generate inputs that are parsed from strings with semantic and syntactic constraints e.g.
xml files which constraint based test generation handles readily.
the recent advances in constraint solving technology have led to a rebirth of symbolic execution a powerful program analysis technique that was traditionally used for checking small programs with primitive types.
generalized symbolic execution implements korat using the java pathfinder model checker and supports structural constraints using symbolic execution.
guiding symbolic execution using concrete executions is rapidly gaining popularity as a means of scaling it up in several recent frameworks most notably dart cute exe and pex .
while dart and exe focus on properties of primitives and arrays to check for security bugs such as buffer overflows cute and pex support the use of preconditions in white box testing.
compositional techniques for symbolic execution introduced by prefix and prefast can handle larger code bases but they do not currently handle complex structural properties .
our work provides a novel way to scale symbolic execution by applying it with dynamic programming in synergy.
.
conclusions we presented a novel technique for exhaustive and random generation of test inputs for programs that operate on structurally complex tests e.g.
recursive data structures.
our key insight is to leverage the recursive structure of desired inputs and partition the problem of generating an input into several sub problems of generating smaller inputs that exhibit the same structure and to use dynamic programming to combine them.
we used a lazy initialization strategy as well as symbolic execution to optimize the technique.
we formally proved the correctness of our algorithm.
experimental results show that our technique provides more efficient and scalable generation of structurally complex tests for a variety of subject programs compared to state of the art test generation tools pex and korat.
furthermore our technique found real bugs in well tested commercial applications google chrome and apple safari.
while in this paper we focus on generation of recursive data structures our work paves the way for development of novel techniques for generating more general classes of inputs.
to illustrate our technique can be used as a sub routine to populate a recursive component of a larger input and the other components could be populated using complementary techniques.
given the increasing use of constraint solving technology in software verification we believe the time is ripe for dynamic programming to make a significant impact on our ability to find more bugs faster and to deploy more reliable software.
.