partialmodels towardsmodelingandreasoningwithuncertainty michalis famelis rick salay and marsha chechik university of toronto canada abstract models are good at expressing information about software but not as good at expressing modelers uncertainty aboutit.thehighlyincrementalanditerativenatureofsoftware development nonetheless requires the ability to express uncertainty and reason with models containing it.
in this paper we buildonourearlierworkonexpressinguncertaintyusingpartial models by elaborating an approach toreasoningwith such models.weevaluateourapproachbyexperimentallycomparing it to traditional strategies for dealing with uncertainty as well as by conducting a case study using open source software.
we conclude that we are able to reap the benefits of well managed uncertaintywhileincurringminimaladditionalcost.
i. introduction software engineering is a highly incremental and iterative endeavorwhereuncertaintycanexistatmultiplestagesofthe development process.
consequently systematic approaches to handling uncertainty are essential throughout the software life cycle.
models are used pervasively in software engineering and their ability to express information about different aspects of software has been studied by many researchers .
however models seldom provide the means for expressing the uncertainty that the modeler hasabout this information.
in thispaper by uncertainty wemean multiplepossibilities .
this notion of uncertainty is often used in behavioral modeling but we expand it to arbitrary modeling languages.
for example a modeler of a class diagram may be uncertain about which of two attributes to include in a particular class becausetheyrepresentdifferentdesignstrategies anditistoo early to know which is correct.
uncertainty can be introduced into the modeling process in many ways alternative ways to fix model inconsistencies different design alternatives e.g.
the above example problem domain uncertainties multiplestakeholderopinions etc.ineachcase thepresence of uncertainty means that rather than having a single model we actually have aset of possiblemodels and we are not sure which is the correct one.
living with uncertainty requires us to keep track of this set and use it within modeling activities wherever we would use an individual model however thiscanbechallengingsincemodelingactivitiesare typically intended for individual models not sets of them.
also managing a set of models explicitly is impractical as its size might be quite large.
e.g.
in sec.
vi we give a case study in which two inconsistencies lead to several hundred possible models.
on the other hand if uncertainty is ignored and one particular possible model is chosen prematurely we risk having incorrect information in the model.
figure1.
a f sixalternativedesignsforapeer to peerfilesharingsystem g a partial modelm efor the six alternatives.
our approach to handling uncertainty is to use annotations with well defined semantics that change a model into apartialmodel i.e.
one that compactlyyet preciselyencodes the entire set of possible models.
this representation allows us to work with a set of models as if it were a single model and do reasoning efficiently with all the possible models simultaneously.
motivating example.to help motivate and explain our approach we use the example of a team engaged in the developmentofasimplepeer to peerfilesharingapplication.
the team uses uml state machine diagrams to model the behavior of this application.
its states areidle leeching downloading a file andseeding sharing a complete local copy .
downloading always starts from theidlestate and seedingandleechingcan always be canceled.
we assume that at this stage of development the team has not finalized978 .
c ieee icse zurich switzerland theexactbehavioroftheprogram duetovaguerequirements given to them by their client.
the team has drafted three alternative behavioral designs benevolent oncethefileisdownloaded theprogram automatically startsseeding as shown in fig.
a .
selfish once the file is downloaded the program becomesidle and the user can choose whether to start seedingor not see fig.
c .
compromise once the file is downloaded the program stops accepting new peers.
it doesn t disconnect from peers that were already connected during theleechingstage but rather waits while they are finishingbefore it becomesidle see fig.
e .
theteamisalsounsurewhethertheprogramshouldallowthe user torestarta finished download i.e.
download the file again .
the three alternatives with this feature are shown in fig.
b d e respectively.
untiltheclientclarifiestherequirements theteamisfaced with uncertainty over which design decision to choose.
at this point it is probably useful to be able toreason about the available choices bothtoensurethatthemodelsconform to the desired constraints and to explore their properties.
for example assume thatthe teamis usinga codegenerator that inordertoensuredeterminism requirestwohardconstraints hc1 no two transitions have the same source and target.
hc2 no state is a sink.
additionally the team is interested in two nice to have properties i.e.
soft constraints that are not strictly required but are desirable sc1 users can share files they already have i.e.
seeding is directly reachable fromidle .
sc2 userscanalwayscancelanyoperation i.e.
everynonidle state has a transition toidleoncancel .
in order to reason effectively about any of these properties over the entire set of alternatives the team may want to ask the following questions does the property hold for all some or none of the alternatives?this can help determine how critical some property is in selecting alternatives when uncertainty is lifted.
for example hc2 holds for all alternatives and therefore is not going to be a main reason in selecting one once uncertainty is resolved.
moreover if some property does not hold for any alternative it may be an indication that the team needs to revisit the designs sooner rather than later.
for example knowing early on that hc1 does not hold for the alternatives in fig.
c d may be an indication that the team needs to reconsider the design of the selfish scenario.
if the property does not hold for all alternatives why is it so?this form of diagnosis can help guide development decisions even before uncertainty is lifted.
developers may beinterestedinfindingonecounter exampleofanalternative where the property gets violated or if they expected that the property would be violated an example where it holds to helpthemdebugthesetofalternatives.forexample locating the alternative in fig.
e might be sufficient for the team to understand why sc2 does not hold for all alternatives.
figure .
simplified metamodel used for defining state machines.
in other cases we may prefer to calculate the entire subset of alternatives that violate the property to explore whether there is a common underlying cause as with the alternatives in fig.
c d that violate the hard constraint hc1.
if the property is a necessary constraint how to filter out the alternatives for which it gets violated?developersmaybe interested in this sort of property driven refinement of the set ofalternatives.e.g.
iftheteamdecidesthatsc2isnecessary theyshouldbeabletorestricttheirworkingsetofalternatives to those that satisfy it i.e.
those in fig.
a d .
contributions.inthispaper weelaborateandevaluateakey component of our broad research agenda for managing uncertainty within models reasoning with models containing uncertainty.
specifically we define partial models show how to construct them and then describe the three reasoning operators aimed to answer the questions posed by the motivating example.
we then extensively evaluate our approach by experimentally comparing it to conventional strategies for dealingwithuncertaintyaswellasbyconductingacasestudy of an open source software project.
organizationoftherestofthepaper.insec.ii weprovide the necessary background.
in sec.
iii we formally define partial models.
sec.
iv develops the core methods of reasoning with partial models.
these are experimentally evaluated in sec.
v and then applied to a case study in sec.
vi.
we discuss related work in sec.
vii and conclude the paper with asummaryandsuggestionsforfurtherresearchinsec.viii.
ii.
background in this section we establish the notation and introduce concepts used in the remainder of the paper.
specifically we groundourapproachtograph basedmodelinglanguagesand propositional logic.
modeling formalisms.in this paper a model is atyped graphthatconformstosomemetamodelrepresentedbyadistinguishedtype graph.
our approach is domain independent inthesensethatitcanhandlearbitrarygraph basedmodeling languages.
the definitions that follow are based on .
definition agraphisatupleg v e s t wherev is a set of nodes eis a set of edges ands t e vare the source and target functions respectively that assign each edge a source and target node.
definition atyped graph model of typetis a triple g type t consisting of a graphg a metamodeltand a typing functiontype g tthat assigns types to the elements ofg.
forexample themodelsshowninfig.1aretypedwiththe metamodel shown in fig.
.574definition thescope orvocabulary of a model g v e s t type t is the sets v eof its typed nodes and edges.
for example the scope of the model in fig.
a consists of the statesidle leechingandseedingand the edges start completed etc.
inthefollowing weoftenrefertonodesandedgesthatare in the scope of a model aselementsoratomsof the model.
from models to formulas and back.to encode a model in propositional logic we first map elements in its scope intopropositionalvariablesandthenconjointhem.toensure that this operation is reversible we define specific naming conventions for the propositional variables a node elementnof typetis mapped to a propositional variable n t .
an edge elementeof typetwith source noden 1and target noden 2is mapped to a propositional variable en1n2t .
e.g.
the propositional encoding of the model in fig.
b is idle state leeching state seeding state start idle leeching transition cancel leeching idle transition completed leeching seeding transition cancel seeding idle transition restart seeding leeching transition given a propositional encodingp m of a modelm we can uniquely reconstruct the modelmusing the naming conventions.
first for every propositional whose name fits the patternn t we create a node of typet namedn.
then for every propositional variable whose name follows the patterne n1n2t we create an edge of typetbetween the nodesn 1andn with the labele.
this propositional encoding also allows us to embed models into larger scopes by negating all the variables not in the original scope.
for example the model in fig.
a can be expressed in the scope of the model in fig.
b as idle state ... cancel seeding idle transition restart seeding leeching transition using the propositional representation we also define a simpleformofmodel union.assumingtwoelementswiththe samenameareconsideredidentical theunionoftwomodels is a model that corresponds to a formula that is a conjunction of all the variables in the union of their scopes.
for example the union of the models in fig.
b d is idle state ... restart seeding leeching transition completed leeching idle transition share idle seeding transition ausefulextendedscopeistheembeddingofasparsegraph into the scope of its corresponding complete graph.
in the union of models with extended scopes variables only appear negated if they are negated in both input models.
properties.we consider properties expressed in first order logic fol or in a similar language such as the object constraint language ocl .
for example the property hc1 is expressed in fol as t1 t2 transition source t source t target t target t t t2 anfolformulacanbegroundedoverthevocabularyofa particular model that is encoded in a propositional formula.
e.g.
grounding hc1 over the vocabulary of the model in fig.
a given that it contains transition elements and that hc1 is a universal property results in hc1 a conjunction of unique terms of the form s i s j t i t j ei e j wheree i jarepropositionalvariablesrepresenting transitions s i j ti jare variables representing their respective source and target states and signifies identity.
iii.
partialmodelpreliminaries in this section we formally define partial models and their associated operations.
semantically a partial model represents a set ofclassical i.e.
non partial models.
partialmodels.the particular type of partiality we consider in this paper is the one that allows a modeler to express uncertainty as to whether particular model atoms should be present the model.
the model is accompanied by a propositional formula calledmay formula which explicates allowable combinations of such atoms.
definition apartial modelis a tuple g vm em whereg v e s t type is acompletetyped graph vm v bandem e b wherebis the set true false maybe are functions for annotating atoms ing and is a propositionalmayformula over the scope s v e built as described in sec.
ii.
in the above definition an annotationtrue false means that the atom must must not be present in the model whereasmaybeindicatesuncertaintyaboutwhethertheatom should be present in the model.
in other words a partial modelconsistsofacompletetypedgraphwhoseelementsare annotated withtrue falseormaybe and a may formula thatdescribestheallowedconfigurationsofitselements.the annotation functions are often omitted for brevity.
modelm ein fig.
g is an example of a partial model.
the elements annotated withtrue e.g.
the stateidleand thetransitionstart appearwithsolidlines anditsmaybe elements e.g.
the statefinishing with dashed lines.
the edges that are not shown e.g.
any edge between the states finishingandleeching are annotated withfalse.m eis accompanied by the may formula e shown next to it in the figure.
we used capital letters as shortcuts for the full names of the propositional variables that correspond tomaybeelements.
e.g.
fstands for the variablefinishing state.
given a partial modelm letc m be the set of classical orconcrete models that it represents calledconcretizations.
for example c m e consists of the models shown in fig.
a f .apartialmodelwithanemptysetofconcretizations is calledinconsistent.
in what follows we only assume consistent partial models.
thesizeofthesetofconcretizationsreflectsthemodeler s degreeofuncertainty.uncertaintycanbereducedbyreducing the set of concretizations viarefinement.
a partial model is refinedbychangingtheannotationsofitselementstoincrease the level of certainty maybeelements can be assigned to true falseormaybe trueandfalseannotations must remain unchanged since information about them is already575figure .
normal forms of the modelm hc1 e shown in fig.
a a graphical normal form gnf b propositional normal form pnf .
certain.
changes tomaybeelements must not violate the formula of the original partial model and thus produce a nonempty subset of concretizations allowed by it.
definition giventwopartialmodelsm 1andm where mi g i vm i em i i withg g we say thatm refinesm or thatm 1ismore abstractthanm denoted m2 m 1iffc m c m over the same scopes.
e.g.
the modelmhc1 ein fig.
b is more refined thanm e in fig.
g .
in particular c m e consists of the models in fig.
a f whereasc mhc1 e consists of the models in fig.
a b e f .
thus the modelmhc1 ehas less uncertainty.
a partial model withoutmaybeelements has exactly one concretization.thenamingconventionsinsec.iiallowusto define a unique conversion between a classical model and a corresponding partial model with a unique concretization.
normal forms.given a set of classical models there is no uniquewaytorepresentthemasapartialmodel.forexample m hc1 e in fig.
a represents the models in fig.
c d .
however the same set of concretizations could be expressed by a removingfromthescopeofm hc1 e extraneousfalse elements such as the statefinishing and b rewriting its propositional formula only in terms of itsmaybeelements.
in the case ofm hc1 e the partial model has only one maybeelement the transition onrestart which can be eithertrueorfalse andtherefore theattachedpropositional formula hc1 e is a tautology.
definition two partial modelsm m2areequivalent denotedm m iffc m c m .
obviously m m2iffm m 2andm m .
to help represent models we define two normal forms graphical normal form gnf andpropositional normal form pnf .
intuitively a model in gnf represents most information in the graph whereas in pnf it represents all the information in the formula.
for example the gnf and pnf form hc1 e are shown in fig.
a b respectively.
in the latter we did not representfalseedges which would otherwise be represented by negated variables.
as partial models are complete graphs the normal form ofmshould be restricted to its largest complete subgraph that only containstrueandmaybenodes.
we call the scopeof this subgraphminimal.
in the following the symbol signifies logical entailment.
definition given a partial modelm g its gnf is a partial modelmgnf ggnf gnf constructed as follows ggnf gand the scopesofmgnfis minimal.
foreveryatomaing if a thenaisannotatedwith trueinggnf.
for every atomaing if a thenais annotated withfalseinggnf.
gnfis specified only in terms of elements annotated withmaybeinggnf.
gnf.
proposition letmbe a partial model andmgnfbe a result of applying definition .
then m mgnf.
definition given a partial modelm g its pnf is a partial modelmpnf gpnf pnf constructed as follows gpnf gand the scopesofmpnfis minimal.
all elements ingpnfare annotated withmaybe.
pnf .
proposition letmbe a partial model andmpnfbe a result of applying definition .
then m mpnf.
properties of partial models.the result of checking a property on a partial model can betrue falseormaybe.
truemeans that the property holds for all concretizations falsethat it does not hold for any of them andmaybe that it holds for some but not all concretizations.
this is calledthoroughchecking .
moreover by definition refinement preservestrueandfalseproperties.
that is as uncertaintygetsreduced valuesofpropertiesaboutwhichwe were certain remain unaffected.
iv.
reasoning with partialmodels in this section we describe how to facilitate decision deferralinthepresenceofuncertaintybyusingpartialmodels toreasonwithsetsofalternatives.inparticular wedefinefour reasoning operations op1 construction how to create a partial model to precisely represent a set of alternatives.
op2 verification how to check whether a partial model satisfies a property.
op3 diagnosis how to find out which alternatives violate the property.
op4 refinement how to filter out the alternatives that violate the property.
op1 construction.construction of partial models is achieved by merging the alternatives and annotating the elementsthatvarybetweenthembymaybe.additionally may formulaisconstructedtocapturetheallowableconfigurations of themaybeelements.
algorithm shows how to create a partial modelmfrom a setaof alternatives.
by construction c m a which establishes the algorithm s correctness.
in our motivating example the six alternative behavioral designs can be represented using the partial model shown576algorithm1construction of partial models.
input setaofnconcrete modelsm i i .
output a partial modelm g m m constructg mas the union of allm i a. annotate non common elements ing mbymaybe.
create m false forallm i a e x g me annotated withmaybedo create i e0 e .
.
.
e k where ife x m i it appears negated.
m m i endfor returnm g m m in fig.
g .
in the figure elements annotated asmaybe appear dashed.
for example the statefinishingexists in only two alternatives and the transition onrestart in three therefore both are represented asmaybe.
the rest of theelementsarepresentinallofthealternatives andthusare representedastrueandappearsolid.thecorrespondingmay formula is shown in fig.
g .
op2 verification.the purpose of the verification task is to answer the question does the desired property hold?
.
in order to facilitate reasoning we put the partial model in pnf and appropriately combine its pnf may formula with the formula representing the property we want to check.
a satsolveristhenusedtocheckwhethertheencodingofthe model entails that of the property.
specifically theverificationenginereceivesapartialmodel mthat is represented in pnf by the propositional formula mand a property expressed as a propositional formula p. we then check satisfiability of the expressions m p and m p using two queries to a sat solver combining the results to determine the outcome of the property on the partialmodelasdescribedintablei.forexample ifboththe property and its negation are satisfiable then there is at least one concretization of the partial model where the property holds and another where it does not.
thus in the partial model the property has valuemaybe.
returning to our running example in order to check whether the property hc1 holds for the partial modelm ein fig.
g we first putm ein pnf to get the propositional formula e. then we express hc1 as a propositional formula hc1 by grounding it over the vocabulary ofm e as described in sec.
ii.
checking the property means checking satisfiability e hc1and e hc1.
the sat solver returns one of the two models from fig.
c d as the satisfying assignment for hc1 and one of those in fig.
a b e f for hc1.
thus the value of hc1 is uncertain maybe on the model.
op3 diagnosis.iftheresultoftheverificationtaskisfalse ormaybe the next step is to do diagnosis i.e.
to answer the question why does the property of interest not hold?
.
or conversely iftheoutcomewasmaybewhereitwasexpected to befalse to answer the question why is the property not violated?
.
three forms of feedback can be returned table i checking property pon the partial model m. m p m p propertyp sat sat maybe sat unsat true unsat sat false unsat unsat inconsistentm return one counter example a particular concretization for which the property does not hold op3a such a counter example is provided for free as a by product of sat based verification.
in particular if the property is false the sat solver produces a satisfying assignment for m p. this assignment is a valuation for all propositional variables that correspond to elements in the scope ofmand can thus be visualized as a classical model for presentation to the user.
to create the visualization we conjoin all variables negating those that had valuefalsein the satisfying assignment.
provided the naming conventions in sec.
ii are followed thisconjunctionuniquelycorrespondstoaclassical model which is then presented as the feedback.
in our running example verifying sc2 on the modelm e involves checking the satisfiability of e sc2.
this formula is satisfiable and the sat solver returns one of the concretizations in fig.
e f as a satisfying assignment.
return a concretization where the property does hold op3b thisis alsoa by productofthe verificationstage if the result of checking the property ismaybe the sat solver produces a satisfying assignment for the formula m p. this valuation is expressed as a model as discussed above and provided to the user.
in the case of verifying sc2 the sat solver returns a valuation that corresponds to one of the concretizations in fig.
a b c d as a satisfying assignment to the formula e sc2.
return a partial model representing the set ofallconcretizations for which the property does not hold op3c theseconcretizationsarecharacterizedbytheformula m p. in our example the concretizations ofm ethat violate hc1arethosethatsatisfytheformula e hc1 i.e.
those in fig.
c d .
inordertocreateusefulfeedbacktotheuser weconsidera new partial modelm pwith the same vocabulary asm that isrepresentedinpnfbytheformula m p.wevisualize m pbyputtingitintognf.inourexample thepartialmodel m hc1 e that represents the set of concretizations ofm ethat violate hc1 is shown in fig.
a .m hc1 e is expressed in termsofthelargerscopeofm eandthereforecertainelements are tagged asfalseand omitted from the diagram.
the overall process is described in algorithm .
as the resulting model is constructed by the formula m p its set of concretizations is exactly the subset of concretizations of the originalpartialmodelforwhichthepropertywasviolated.in other words m p m. op4 property driven refinement.if the result of verification of an important property ismaybe the developer may577figure4.
a partialmodelm hc1 e representingallconcretizationsofm e that violate hc1.
b partial modelmhc1 erepresenting all concretizations ofm ethat satisfy hc1.
want to refine the partial model to a constrained version such that all of its concretizations satisfy the property.
this subsetofconcretizationsexactlycharacterizedbytheformula m p. we use it to construct the partial modelmpin the same manner as we did for constructingm p. inourexample thesetofconcretizationsofm ethatsatisfy hc1 consists of those in fig.
a b e f .
constructing the partial modelmhc1 ethat represents these is done using the same method shown in algorithm as for constructing its complement m hc1 e .
namely the formula e hc1 is constructed and then put into gnf.
the result is shown in fig.
b .
asmpis constructed using the formula m p its set of concretizations is exactly the subset of concretizations of theoriginalmforwhichthepropertyholds thus mp m. v. experiments we conducted a preliminary empirical study to assess the feasibility and scalability of our approach to reasoning using partialmodels.morespecifically weattemptedtoanswerthe following research questions rq1 howfeasibleis reasoning with sets of models with the partial model representation in comparison to the classical approach?
rq2 howsensitiveare the partial modeling representation and reasoning techniques to the varying degree of uncertainty?
to get answers to rq1 and rq2 we set up experiments with parameterized random inputs to simulate various categories of realistic reasoning settings.
experimental setup.the reasoning tasks described in sec.
iv are operationalized using two fundamental tasks t1 check the satisfiability of the formulas m pand m p for op2 op3a and op3b .
t2 construct a new partial model in gnf that has a pnf formula m p for op3c with pand op4 .algorithm 2get all concretizations that violate satisfy a property.
input a partial modelm inand a propertyc output a partial modelm outabstracting exactly the concretizations ofm inthat violate satisfy c. putm inin pnf to get in.
groundc to get c construct out in c out in c createm outwith the same vocabulary asm inand pnf formula out putm outin gnf andreturnit we focus our experimental evaluation on t1 and t2 because they require the use of sat solving technology as opposedtoconstruction op1 whichislineartothenumberof input classical models and their elements see algorithm .
specifically to answer rq1 we conducted two experiments e1 compare the relative performance of reasoning by running the task t1 to the performance of classical reasoningbyconsideringthesetofconcretizationsrepresented bym.
e2 compare the relative performance of running t2 to get a partial model representing the subset of concretizations that satisfy a property to the performance of incrementally collecting all the classical models as satisfying assignments of the formula m p. toanswerrq2 weexecutedtheexperimentse1ande2with randomlygeneratedexperimentalinputsthatwereparameterized to allow for different sizes both with respect to model size and the size of the set of concretizations.
experimental inputs.the metamodel of typed models corresponds to additional constraints in their propositional encoding.
this makes the problem easier for the sat solver as it constrains the search space.
we chose to use untyped modelsforinputstoourexperiments astheleastconstrained and thus the most difficult for the sat solver.
we considered the following experimental parameters size of the partial model size of its set of concretizations quantification e.g.
existential universal mixed of theproperty and4 resultofpropertychecking true false maybe .
to manage the multitude of possible combinations of these we discretized the domain of each parameter into categories.
we defined four size categories based on the total number of elements nodes and edges in the partial model small s medium m large l and extra large xl .
based on pilot experiments we defined ranges of reasonable values foreachsizecategoryandselectedarepresentativeexemplar.
the ranges of the categories and the selected exemplars for each category are shown in table ii.
in a similar manner we defined four categories s m l xl for the size of the set of concretizations of the generated model.
the size of this set reflects the degree of uncertainty encoded in the partial model so that the category s corresponds to little uncertainty over which alternative to chose 578table ii categories of the size of models .
size of model s m l xl nodes elements exemplar table iii categories of the size of the concretization set .
size of set s m l xl concretizations exemplar and the category xl corresponds to extreme uncertainty.
based on pilot experiments we defined reasonable ranges and selected a representative exemplar for each category as shown in table iii.
we also defined four property types based on the quantification of fol formulas fully existential e fully universal a and two mixed categories exists forall ea and forall exists ae .
additionally we considered the three possible results that can be yielded by property checking true maybeandfalse.
implementation.we implemented tooling support to randomly generate inputs based on the experimental properties outlined in sec.
v. specifically we generate propositional formulas expressed in the input format of the mathsat smt solver .
each such propositional formula ris a conjunction of the form r a c p where arepresents the annotations of the elements of the partial model c its set of concretizations and p the property being checked.
we describe these below.
for each random partial model we considered a complete graph whose elements are in the model s finite vocabulary of n1nodesandn2 1edges.eachelementisrandomlyannotated astrueorfalse andn 2elements are annotated asmaybe.
each element in the model is represented by a boolean variable.
the formula acaptures the set of variables that make upthemodelaswellastheirannotations.inparticular aisa conjunctionofn n1 terms oneforeachelement.ifan element is annotated astrue its corresponding term is the non negated variablev .
if it is annotated asfalse its term is v and if it is annotated asmaybe v v .
this tautological disjunction is necessary forv to be considered by the sat solver even if it doesn t appear elsewhere in r. each model is accompanied by the formula cthat captures its set of concretizations.
cis a disjunction ofn unique sub formulas representing individual concretizations.
each one is a conjunction of then 2maybevariables a randomnumberofwhichisnegated.thisway eachsub formula defines an allowable configuration ofmaybeelements.
defining specific values forn 1andn we were able to generate models for each of the combinations of the parameters in tables ii and iii.
to generate formulas pthat simulate grounded fol properties we used property templates .
for example to capture the fol formula ex x y x y we createdvar v0 v1 v2 v0 v0 v0 v1 v0 v2 v1 v0 v1 v1 v1 v2 v2 v0 v2 v1 v2 v2 boolean formula start of a v0 and v1 or not v1 and v2 or not v2 and not v0 v0 and not v0 v1 and v0 v2 or not v0 v2 and not v1 v0 and not v1 v1 and not v1 v2 and not v2 v0 and not v2 v1 and not v2 v2 and start of c v1 and v2 and not v0 v2 or v1 and not v2 and not v0 v2 or not v1 and v2 and v0 v2 start of p and not not v0 implies not v1 v0 and not v1 v0 implies not v2 and not v1 implies not v0 v2 figure .
a randomly generated input in mathsat s encoding language.
the template x implies y .
given a partial model with elements represented by the set of variables v v2 v3 v4 the propositional formula that corresponds to grounding ex over the vocabulary of the model is created as a randomly instantiated disjunction of copies of the template e.g.
v3 implies v2 or v1 implies v4 .
to run experiments our goal was creating templates for realistic properties such as the ownership relationship.
e.g.
the template not x implies not y indicates thatycannot exist without its owner element x. each template was repeatedn 6times withn 6large enough so that pcontainsn 4variables out of which n5correspond tomaybeelements.
preliminary results by pilot experiments indicated that these parameters did not significantly affect the observed times and therefore in the generated inputs we fixed them ton .
n 1and n5 min n .
n .
tocreatepropertiesinthefe fullyexistential category the template is repeated as a series ofn 6disjunctions and for fa properties as a series ofn 6conjunctions.
ea propertiesweregeneratedasn 7disjunctionsofconjunctions ofn 8instantiations of the template wheren 7andn 8were randomnumberss.t.n n n .similarly aeproperties were comprised ofn 7conjunctions of disjunctions ofn instantiations of the template.
fig.
shows an example of an input formula generated randomly using a fa ownership property .
methodology.we conducted a series of experiments generating inputs along the dimensions specified by three parameters model size size of set of concretizations and type of property.
for each combination of the parameters we produced inputs using the selected exemplar values shown in tables ii and iii.we did multiple runs for each combination and then picked at least runs for each data point that produced results in each of the three possible return values true maybe false .
for each run we used the generated input to execute the two experiments e1 and e2.
for each we recorded the speedups p tc tpm wheret candt pmwere the times to do a task with sets of classical models and with partial models.579figure .
speedup versus model size for different degrees of uncertainty a experiment e1 b experiment e2.
results.theexperiments1didnotshowdramaticdifferences in speedup between the different property and return types.
the biggest difference in speedup for e1 was recorded in the ae category between properties that returnmaybe .
and those that returnfalse .
for m sized models with l sets of concretizations.
for e2 the biggest difference in speedup was recored for s sized models with xl sets of concretizations for properties that returnmaybe between the ea .
and ae categories .
.
this indicates that property and return types are not the prime determinants for the performance of our approach.
the size of the partial model and the size of the set of concretizations had a much larger effect on the recorded variance of speedup.
the ranges of speedups for e1 and e2 are shown in fig.
a b respectively.
the plotted values are averages for type of property and return value for each combinationofmodelsizeandsizeofsetofconcretizations.this indicatesthattheseparametersarethemostimportantfactors for studying the effectiveness of partial model reasoning.
fig.
a shows that for verification and simple diagnostic tasks such as producing a counter example there is a significant speedup from using partial models.
the smallest speedups were observed in the inputs with s sets of concretizations between2.45fors sizedmodelsand2.59forlsized models .
the increase from these values was dramatic form landxlsetsofconcretizations.forthesecategories the smallest speedup was .
for xl sized models with m setsofconcretizationsandthebiggestspeedupwas30.49for m sized models with xl sets of concretizations.
for more complex tasks such as property driven refinement the effect of the size of concretizations as shown in fig.
b seems to be the determinant parameter as the technique offers a speedup greater than for larger sets of concretizations.
our approach was significantly slow for s setsofconcretizations thelargestspeedupbeing0.05formsizedmodels .moderatespeedupswereonlyrecordedforxl sets of concretizations and smaller models .
for s .
for m and .
for l .
this points to the conclusion that for more complex tasks speedup is best for smaller models with larger sets of concretizations.
1all results available at observations lead us to the conclusion that regarding rq1 feasibility there is a significant net gain from using our approach for tasks like verification and counterexample guided diagnosis whereas for tasks like propertydrivenrefinementtherearecertaincaseswhereitispreferable to use the classical approach.
regarding rq2 sensitivity to degree of uncertainty the observations point to the conclusion that the speedup offered by our approach is positively correlated to the degree of uncertainty.
in fact the greatest speedups were observed for inputs that had bigger sizes of sets of concretizations.
for smaller levels of uncertainty explicitly handling the set is more efficient.
threats to validity.the most important threat to validity stemsfromtheuseofexperimentalinputsthatwererandomly generated.
the formulas that we created for properties were randomlygroundedandweregeneratedfromafewarbitrarily defined templates.
another threat to validity is induced by our choice to use a few exemplar values of the experimental parameters in order to manage the combinatorial explosion of options.
it is evident that more experimentation is required to generalize our results and further investigate effects of the experimental parameters that may not have been made obvious by our set of experiments.
tocompensateforthesethreatstovalidity weadditionally conducted a case study to triangulate our experimental results with experience from applying our technique to a real world application.
the size of the models that we extracted from the case study fell in the xl category with m and l sets of concretizations whereas the properties were in the fe category and returnedtrueandmaybe.
the observed speedups detailed in the next section were consistent with our experimental results.
vi.
casestudy problemdescription.in this case study we aim to illustrate thefollowingmdesoftwaremaintenancescenario anengineerisgiventhetaskoffixingasoftwaredefectbymodifying its uml model which will subsequently be used to construct the modified software e.g.
via a transformation .
however 580after creating the modifications to the model the engineer finds that some model constraints are violated and thus the software cannot be constructed.
for example she may have modifiedasequencediagramwithoutproperlysynchronizing it with the structural aspects e.g.
classes of the model.
to help her resolve these constraint violations she uses a tool that can automatically propose different model repair alternatives e.g.
.
suppose the engineer is uncertain aboutwhichalternativetochoosebecausetheirrelativemerits are unclear and thus she would like to reason with the set of alternatives to help her make the choice and possibly even defer the decision until more information is available.
in this case study we apply the partiality techniques developed in this paper to show how they could help her in this scenario and to illustrate the feasibility of the approach.
we use an open source project umlet which is a simple java based uml editor as the software on which our user is requested to perform a maintenance task.
this project has also been used by van der straeten et al.
for finding model inconsistencies with a model finder .
the goal of the maintenance task is to fix the following bug referred to asissue10ontheonlineissuelog copieditemsshould haveahigherz order priority .thatis iftheusercopiesand then pastes an item within the editor it is not the topmost item if it overlaps with other existing items.
thus any fix to the bug must satisfy the following property p1 each item that is pasted from the clipboard must have z order .
the pastefunctionalityisimplementedinumletbyinstantiating the classpasteand invoking itsexecuteoperation.
fig.
shows a fragment of the sequence diagram generated from the code using the borland togetherj tool forexecute with the circled portion representing a bug fix we propose.
the full sequence diagram has objects messages and statement blocks.
although umlet has classes in total we restrict ourselves to a slice that covers the sequence diagramforexecuteconsistingof6classes plus5javalibrary classes with44operations.ofthe12objectsinthesequence diagram are instances of java library classes and of umletclasses.inthefragmentshown theforloopstatement block iterates through every item in the clipboard indexed by variablee and adds it to the editor window represented by the objectpnl drawpanel .
when an entity is added to a drawpanel the z order is not set to by default causing the bug.inourproposedfix showninthedashedcircle wecreate a transient objectpositionerand tell it tomovetotop e using the swing operationsetcomponentzorder.
inconsistenciesandthepartialmodel.ourfixisconceptually correct but it violates two consistency rules required for code generation classlessinstance everyobjectmusthaveaclass.possible repairs rc1 remove the object.
rc2 obj replace the object with an existing object objthat has a class.
rc3 cls assign the object to the existing classcls.
rc4 assign the object to a new class.
self e gridelement elem addelement pnl drawpanel positioner execute handler .
getx .
gety .
.
.
addelement e x y zoom .
execute handler .
new .
movetotop self e .
setcomponentzorder e handler diagramhandler for sd paste.executefigure .
our fix for theexecuteoperation of the umlet paste function.
danglingoperation the operation used by a message in a sequence diagram must be an operation of the class of the receiving object.
possible repairs rd1 put the operation into the receiving object s class.
rd2 op change the operation to the operationop that is already in the receiving object s class.
rd3 remove the message.
classlessinstance and danglingoperation are both based on .
in our case thepositionerobject violates classlessinstance and the message with operationmovetotopviolatesdanglingoperationbecauseitisnotinpositioner sclass sincepositionerhas no class .
if we apply all possible repairs we get a set of alternative ways to fix the inconsistency summarized as follows positionercan be removed rc1 can be replaced by one of the existing objects rc2 can be assigned to oneoftheexisting6classes rc3 orcanbeaninstance of a new class rc4 .
the operationmovetotopcan be added to thepositioner sclass rd1 can be changed to one of the other operations depending onpositioner sclass rd2 or can be removed rd3 .
only certain repairs are mutually compatible for example rc1cannot be used withrd2since the latter depends on positioner s class but the former removespositionerentirely.
there are alternatives in total for all valid combinations.
if we construct a partial model to represent this set of alternatives all the model elements in the proposed fix in fig.
becomemaybesince they are present in some alternatives and absent in others.
furthermore based on the compatible combinations of repairs themayformula portion of the partial model is expressed as m choose rc1 rd3 rc2 e rd1 rc2 e rd2 getx .
.
.
wherechoose .
.
.
n is a logical function that holds when exactly one of i i n hold.
each of the formulas581for the individual repairs can be further expanded and expressedintermsoftheuml2metamodel .forexample rc2 e represents the condition that objectpositioneris replaced by objectein fig.
expressed as rc2 e covered receiveevent message .
lifeline e which says that the lifeline covered by the receiving event of message .
is the one for objecte gridelement.
analysis.having defined a partial model whose set of concretizations are the possible alternative ways of making our bug fix consistent with the required rules we can use the techniques discussed in sec.
iv to reason about the alternatives using properties.
the first question is whether any of the alternatives break the paste functionality.
for example considerthepropertyp2 wheneveranitemispasted anew itemiscreatedintheeditorwindow whichshouldholdifthe paste functionality is implemented correctly.
to check this against the partial model we encode it into a propositional formula p2over the uml metamodel in the same way as the repair formulas.
due to lack of space we limit ourselves to a high level description of the encoding p2holds iff in the sequence diagram forexecutethere exists an iteration over the items in the clipboard e.g.
aforblock that creates a copy of each item using the operationclonefromme and later adds the item to the editor window using the command addelement .
only theaddelementportion is visible in the fragment in fig.
.
weusedthemathsatimplementationdescribedinsec.v toverifythisproperty op2 checkingthequeries m p2 and m p2.
the result wastrue indicating that all concretizations satisfy the property.
we also did the comparison with this task using classical models as in sec.
v and found a speedup of .
.
next we considered the critical property p1 that is required for any fix to our bug.
in this case op2 yieldedmaybeindicating that some but not all concretizations are acceptable bug fixes.
in this case we found a speedup of .
.
to investigate why some concretizations did not fix the bug we used our diagnosis technique op3c to produce the partial model representing the counterexamples to p1 by setting themayformula to m p1and computing the gnf.
in the resulting may model themovetotopoperation is absent and thusmovetotopis necessary for p1 to hold.
this is reasonable since if this operation is not invoked then the z order is never set to .
in a similar way we used property guided refinement op4 to refine our partial model to represent only the satisfying concretizations by setting the mayformula m p2andcomputingthegnf.thespeedup for these two tests were .
and .
respectively.
vii.
r elatedwork anumberofpartialbehavioralmodelingformalisms have been studied in the context of abstraction for verification or for capturing early design models .
for example modal transition systems mtss allow introduction of uncertaintyabouttransitionsonagivenevent whereasdisjunctive modal transition systems dmtss add an additionalconstraint that at least one of the possible transitions must be taken in the refinement.
these approaches compactly encode an over approximation of the set of possible ltss and thus reasoningoverthemsuffersfrominformationloss.moreover the mts and dmts refinement mechanism allows resulting lts models to have an arbitrary number of states which is different from the treatment provided in this paper where we concentrated only on structural partiality and thus state duplication was not applicable.
another relevant area is product line software development which captures the set of potential models by identifying their commonalities and variabilities.
most approaches keep the expressions of variability in a separate feature model but some incorporate these directly into the model using notational extensions in the metamodel .
featured transition systems ftss are most closely relatedtothenotionofpartialmodelspresentedinthispaper.
ftss encode a set of products by annotating transitions with specific features from a feature diagram much like ourmay formula and differ from mtss and dmtss in that they supportpreciserepresentation and reasoning with a set of models.
our approach is distinct from related work in a number of important ways.
first it applies toanykind of modeling language notjustbehavioralmodels thatcanbedefinedusinga metamodel.second ourviewpointisthecomprehensivehandlingofuncertaintyratherthanjustreasoningovervariability.
in this context partial models support changes in the level of uncertainty with tasks such as property driven op4 and more generallyuncertainty removingrefinement .
third partialmodelsarefirst classdevelopmentartifactsthatcanbe manipulated throughout the software engineering life cycle withdetail addingtransformationsthatdonotaffectthelevel ofuncertainty .finally thenotionofpartialitystudiedhere wheremodelelementscanbeoptionalormandatory isonly one of several kinds of partiality developed in .
viii.
c onclusion and futurework this paper presented an approach for reasoning in the presence of uncertainty.
we showed how to construct partial models to represent sets of alternatives and how to use them for reasoning.
we evaluated the approach by running experiments using randomly generated inputs and triangulated our results with a case study dealing with alternative repairs to inconsistency for a real world software project.
our evaluation while preliminary showed that in the presence of high degrees of uncertainty using partial models offers significant improvements for reasoning tasks.
our work is part of a broader research agenda outlined in .
our next steps include studying how partial models canbeusedasfirst classdevelopmentitems.inparticular we wanttoinvestigatemodeltransformationofpartialmodels as well as the effects of transformation on the properties of the concretizations.582references borland togetherj.website accessed .
g. bruns and p. godefroid.
model checking partial state spaces with valued temporal logics .
inproc.
of cav pages .
r. bruttomesso a. cimatti a. franzen a. griggio and r. sebastiani.
the mathsat smt solver .
inproc.
of cav pages .
p. classen a.and heymans p. schobbens a. legay and j. raskin.
model checking lots of systems efficient verification of temporal properties in software product lines .
inproc.
of icse pages .
a. egyed e. letier and a. finkelstein.
generating and evaluatingchoicesforfixinginconsistenciesinumldesign models .
inproc.
of ase pages .
h.ehrig k.ehrig u.prange andg.taentzer.fundamentals of algebraic graph transformation.
eatcs.
springer .
m. famelis s. ben david m. chechik and r. salay.
partial models a position paper .
inproc.
of modevva pages .
m. famelis r. salay and m. chechik.
the semantics of partial model transformations .
inproc.
of mise .
to appear.
d. fischbein g. brunet n. d ippolito m. chechik and s. uchitel.
weak alphabet merging of partial behaviour models .acm tosem .
k. g. larsen and b. thomsen.
a modal process logic .
in proc.
of lics pages .
p. larsen.
the expressive power of implicit specifications .
inproc.
of icalp volume oflncs pages .
t. mens and r. v. d. straeten.
incremental resolution of model inconsistencies .
inproc.
of wadt .
b.morin g.perrouin p.lahire o.barais g.vanwormhoudt and j. m. j ez equel.
weaving variability into domain metamodels .j.
model driven engineering languages and systems pages .
c. nentwich w. emmerich and a. finkelstein.
consistency managementwithrepairactions .
inproc.
of icse pages .
object management group.object constraint language omg available specification version .
.
omg.uml superstructure specification version .
.
k. pohl g. b ockle and f. van der linden.software product line engineering foundations principles and techniques.
springer verlag new york inc .
m. sabetzadeh s. nejati m. chechik and s. easterbrook.
reasoning about consistency in model merging .
inproc.
of lwi .
r. salay m. chechik and j. gorzny.
towards a methodology for verifying partial model refinements .
inproc.
of volt .
to appear.
r. salay m. famelis and m. chechik.
language independentrefinementusingpartialmodeling .
inproc.
of fase .
r. v. d. straeten t. mens j. simmonds and v. jonckers.
using description logic to maintain consistency between uml models .
inproc.
of uml pages .
umlet.umlet issue list accessed .
umlet.umlet website r. van der straeten j. pinna puissant and t. mens.
assessing the kodkod model finder for resolving model inconsistencies .modelling foundations and applications .
a.vandeursen p.klint andj.visser.
domain specificlanguages an annotated