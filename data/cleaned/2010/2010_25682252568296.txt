reuse oriented reverse engineering of functional components from x86 binaries dohyeong kim1william n. sumner2xiangyu zhang1dongyan xu1hira agrawal3 1department of computer science purdue university usa 2school of computing science simon fraser university canada 3applied communication sciences usa kim1051 xyzhang dxu cs.purdue.edu2wsumner sfu.ca 3hagrawal appcommsci.com abstract locating extracting and reusing the implementation of a feature within an existing binary program is challenging.
this paper proposes a novel algorithm to identify modular functions corresponding to such features and to provide usable interfaces for the extracted functions.
we provide a way to represent a desired feature with two executions that both execute the feature but with di erent inputs.
instead of reverse engineering the interface of a function we wrap the existing interface and provide a simpler and more intuitive interface for the function through concretization and redirection.
experiments show that our technique can be applied to extract varied features from several real world applications including a malicious application.
categories and subject descriptors d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering d. .
reusable software general terms algorithms keywords feature extraction reverse engineering dynamic analysis .
introduction developers have long struggled with the desire to reuse previously implemented features within new code.
by reusing an old implementation developers can avoid creating new bugs and can create easier to maintain programs .
implementation reuse can also be crucial when a new program must replicate features within a legacy system but the speci cation for the legacy system no longer permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.exists.
driven by this desire to reuse existing implementations previous research has delved into techniques for both locating the implementation of a feature within a body of source code and extracting that source implementation into a conveniently reusable function .
these techniques generally assume the availability of the original source code but in practice the source code itself may no longer be available or may no longer even exist.
indeed facing the maintenance of legacy programs without source code darpa recently called for a solution to this exact problem .
for example some components are provided to developers only in the binary form and the source of these programs or libraries may not be available due to intellectual property restrictions .
in other cases companies may have existing programs that implement de facto speci cations but both the original source code and any documentation of the speci cations have been lost over time .
finally when reverse engineering the behavior of a foreign program a program from a third party security researchers sometimes wish to extract certain features such as encoding decoding routines or anti debugger techniques from a foreign program in binary form.
reusing these features from foreign binaries allows the security analysts to gain insight into the behavior of malicious code and potentially develop defensive techniques .
in each of these scenarios a developer needs to locate and extract the existing implementation of a feature that exists only in binary form within an existing program.
although source code provides rich information about the behavior and structure of a program much of this information is stripped away when the program is compiled to a binary form.thus techniques for locating and extracting features that rely on source code analysis and manipulation no longer apply.
new solutions must be found for both locating and extracting features.
prior work on locating a desired feature includes techniques built on statement coverage information and dynamic slicing techniques .
while both of these techniques apply to both source code and binaries they may both locate features too coarsely including more of the original implementation than is necessary or desirable.
dynamic slicing techniques compute transitive closures over the dynamic dependence graph of an execution .
these closures are known to be large in practice .
statement coverage techniques contrast the statements performed within an execution that exhibits a desired feature against those performed in an execution that does not exhibit thepermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
feature.
the intuition is that statements executed only or more frequently within the execution exhibiting the feature should implement the feature itself.
we observe and later show that such approaches can be too coarse grained and identify portions of the original implementation that are unnecessary for implementing the feature.
once the functions implementing a feature have been identi ed they may be extracted from the original binary but extraction alone is insu cient.
to reuse the extracted component we must provide an interface through which it may be invoked but even state of the art binary analysis tools have di culty reverse engineering such interfaces.
we show that the original interface for a component can also involve complex heap structures and the parameters that correspond to a feature of interest may be deeply embedded within these heap structures and subject to subtle constraints.
developers should not need to deal with such complexities when reusing an extracted component.
in this paper we propose a novel approach to locating modular functions that correspond to a desired feature and providing a usable interface for the extracted component.
we describe the desired feature through multiple executions that use the feature.
the user executes the feature twice with di erent inputs and our technique semantically contrasts the executions to discover where the di erent input values are used and which part of the code produces the desired output from the input.
our technique then isolates the feature using concretization to replace the original parameters of the function with values from a real run.
finally it wraps the original interface of the binary with a new and simpler interface for the developer to invoke and then uses redirection to ensure that the parameters of the new interface are used consistently throughout the extracted function.
our main contributions are highlighted as follows.
we provide a way to precisely represent a desired feature using multiple executions that exhibit the feature.
providing these executions is intuitive to a user who knows how to use the existing binary.
we perform a semantic comparison of the provided executions using dual slicing .
this allows us to precisely locate the desired feature within the code.
we propose a technique called interface casting that uses concretization to isolate desired parameters for a function.
it then wraps an extracted binary feature with an adapter and exploits redirection to use the parameters of the adapter.
this provides the developer a convenient means of invoking the extracted feature.
we implement and evaluate a prototype of the approach.
we apply our technique to applications and extract reusable components from the binaries.
we show that even when there are originally no parameters to the extracted functions our technique still applies.
.
motivating example suppose a developer desires to extract and reuse the email sending feature of pine an email client.
because pine has many diverse email features this reuser must rst locate the function that contains the desired feature.
to reuse the function they must also uncover the function s interface or prototype.
knowing the interface they can provide parameters such as the sender address recipient subject and body for a sent email.
in this section we show how to locate thedesired function by using dual slicing.
we then show how to extract the function into an isolated component with a reusable interface by using concretization and redirection.
.
function location before extraction we must locate the function responsible for sending an email.
to nd the function we contrast two di erent executions of pine each of which sends a di erent email.
we follow the same steps both times except that the sender addresses recipients subjects and bodies of the sent emails di er.
thus we choose the same menu items in the same order and we provide the same sequence of key strokes except for the four parameters of interest.
as a result the two executions follow the same paths through the program except for di erences related to the di ering user input.
dual slicing is a technique that contrasts two executions and identi es only those instructions that both behave differently across the two executions and contribute to their di erent outputs.
intuitively the user inputs for the two executions of pine di er only with respect to the emails sent so the two executions should mainly di er in the portion of code that is responsible for processing and sending the di erent emails.
thus the di erences identi ed by the dual slice should be the behaviors of pine that we wish to extract.
next our technique nd the function that encloses all of the relevant di erences between the two executions.
fig.
shows the part of the dynamic call tree containing the dual slice.
each node represents a function and each arrow represents a caller callee relationship between functions.
shaded nodes represent those functions containing the relevant instructions within the dual slice.
the topmost shaded function iscall mailer and it transitively calls all other shaded functions.
since the shaded functions are necessary for the mail sending component we identify call mailer and its callees as the components of pine to extract.
pine rfc822 headerpost rfc822 outputcallmailer sstrncpycompose mail smtp mail pine rfc822 output body pine header linepine send rfc822 output full foldpine rfc822 outputmain figure dual slice of the mail sending feature in pine.
shaded nodes show the dual slice within the call tree.
.
interface casting we must next extract call mailer and provide it with a usable interface.
the new interface is particularly important because the original interface is complex and does not match the expectations of reuser.
suppose that we tried to invoke the extracted function directly.
fig.
presents the original interface of call mailer .1129struct body parttext contents body part contents union different ways of accessing contents part part body part list message msg body encapsulated message nested ... struct part body body body information for this part part next next body part struct message body body message body parttext text body text ... struct parttext unsigned long offset offset from body origin struct unsigned char data text unsigned long size size of text in octets text int call mailer metaenv header body body char alt smtp servers intflags void bigresult f char int void pipecb f pipe s int void figure interface of call mailer the function has parameters.
the rst and the second arguments are pointers to internal data structures and we would need to reverse engineer those data structures to reuse the original interface.
in particular the body of an email is stored in body contents.text.data and the size of the body is stored in body contents.text.size .
to specify the body we would rst need to allocate memory regions for the body structure and its child data structures e.g.
partandmessage and specify correct values for both dataandsize.
this also requires understanding the semantic relationship between dataandsize.
to reuse call mailer we would further need to correctly initialize the entire data structure and identify the semantics of each eld even if the eld is unrelated to the four parameters we want to provide .
in fact there is even more complexity as email contents may be speci ed in two di erent ways one through the contents eld of bodyand the other through a further nested eld of body.
expecting the reuser to manage this complexity on their own is unrealistic.
to provide a usable interface for the function we must simplify away the unnecessary parameters and introduce new parameters matching the reuser s intentions.
we call this process interface casting .
to simplify existing parameters our technique rst statically concretizes those values generated outside call mailer and used inside call mailer .
thus if call mailer is invoked by the reuser the parameter bigresult f does not actually take a variable argument.
instead we provide it a concrete value observed in one of the original executions.
we concretize not only the values of all function parameters but any memory values de ned outside call mailer .
by concretizing all of the direct and indirect inputs we hermetically seal the function of interest.
that is by providing concrete values for all inputs of a function we ensure that it behaves the same way every time.
to provide the parameters desired by the reuser our technique then relaxes this seal to allow only the chosen parameters to again a ect the function s behavior.
we redirect accesses of the original inputs to use memory locations for the new parameters provided by an interface that we construct.
since we already concretize the parameters and memoryvalues the location for a parameter is statically xed.
for example the value of the parameter bodymay be concretized to0x0408cc00 and the subject of an email may be concretized to 0x0409db00 .
thus the program will always read the email subject from the same location in memory and we can redirect accesses of that memory location to use a new memory location that contains a new subject string.
before we can relax and redirect accesses of inputs we must rst allow the reuser to determine just which data should be parameters for the extracted function.
once again the reuser can use dual slicing to provide this information.
recall that in the function identi cation phase we contrasted two executions with all desired parameters changed to identify the code to extract.
in contrast to identify the instructions that read each input we need only change one input at a time.
this way the dual slice between the original execution and the execution with one di ering input will capture only those instructions processing the changed input.
once we identify all desired parameters of call mailer and create a new interface using concretization and redirection we can simply extract the function from its original binary by using binary rewriting tools .
the new interface we provide acts as a wrapper that invokes this binary function allowing the reuser to call it like any other library function.
.
the reuse process in this section we discuss the details of reusing functions from binary code.
we present algorithms for both locating the function that contains a feature through dual slicing and for providing a reusable interface through concretization and redirection.
.
component location we rst present background information on dual slicing to clarify details of our approach for locating components within a binary.
we then explore our algorithms for locating components and why they can localize a component to a more concise portion of code than existing techniques.
dual slicing.
dual slicing is a slicing technique that contrasts two executions and produces a slice containing only those di erences between the two executions that are responsible for some observably di erent behavior .
alg.
presents the core algorithm.
given a slice criterion e1 e2 that identi es some output di erences across the two executions the algorithm computes a set of dynamic dependences from both executions.
e1 e2 denotes that two execution points e1and e2 in the rst and the second executions respectively align or correspond across the executions .
e1 ?
denotes that there is no execution point in the second execution that aligns with e1in the rst execution.
the algorithm rst ensures that the slice criterion exists in the rst execution.
lines process data dependences at the slice criterion.
here f e1 e2 !
e0 e0 gdenotes that e1has a data dependence upon e0 1in the rst execution e2has a data dependence upon e0 2in the second execution and e0 1aligns with e0 .e0 2can be?when e0 1does not align with any point in the second execution or e2is not data dependent on the alignment of e0 .
on line if the data dependence exists only in the rst execution or if the values of two data dependences di er the data dependence is added to the dual slice.
the algorithm proceeds to include the dual slice from e0 e0 recursively similar to traditional dynamic slicing.
lines process the control dependence of the slice1130criterion denoted as .
similar to the data dependence if the control dependence exists only in the rst execution or the branch outcomes di er the control dependence and the recursive dual slice of the control dependence are added to the dual slice.
so far the algorithm considers only data dependences and control dependences when e1is not null.
lines compute the dual slice when e2is not null.
algorithm dual slicing input e1 e2 slice criteria output d the dual slice a set of deps in either execution dualslice e1 e2 ife16 ?then for all data dep dd f e1 e2 !
e0 e0 gdo ife0 ?
or values at e0 1and e0 2di er then d d dd dualslice e0 e0 end if end for control dep cd f e1 e2 e0 e0 g ife0 ?
or branch outcomes at e0 1and e0 2di er then d d cd dualslice e0 e0 end if end if ife26 ?then operations symmetric to when e16 ?
end if returnd component location using dual slicing.
to use dual slicing to identify the component that corresponds to the desired feature we use two executions that each exercise the desired feature but that use di erent inputs.
for example in thepine case study we send an email in both executions but the emails have di erent recipients subjects and bodies.
the resulting dual slice contains only those instructions that process the input because all the execution di erences originate from the di ering inputs.
the slice also includes only instructions that help produce the desired output because slicing excludes instructions unrelated to the output.
alg.
presents the component identi cation algorithm.
the algorithm requires two executions e1ande2 which exercise the same feature but with di erent inputs.
lines and choose the output corresponding to the desired feature as the slice criterion.
in the pine example we use the network packet containing the composed email as the slice criterion.
line computes the dual slice and line trims o a pre x of the slice that only moves the arguments around without using them for any computation.
line locates the function that contains this trimmed dual slice.
it chooses the closest common ancestor function in the dynamic call tree of those functions whose instructions reside in this dual slice.
line further selects this common ancestor as well as all functions that it transitively called in e1ande2as targets of extraction.
in other words the identi ed components comprise nodes of the dynamic call tree with the identi ed common ancestor function as their root.
suppose that we wish to identify the function containing the email sending functionality of the sample program in fig.
that models pine.load config rst initializes global variables that will be used in pine send .menu waits for an input from a user with timer of second.
if the timer expires algorithm component location input a pair of executions e1ande2with both exercising the target functionality but with di erent inputs.
identification e1 e2 o1 o2 outputs corresponding to the desired feature ine1ande2 resp.
e1 e2 execution points that emit o1ando2 resp.
dse dualslice e1 e2 tse trim dse func the modular function that encloses tse extract func and all user functions directly indirectly called by func return extract menu performs background tasks.
if the user instead selects the send menu option pine send callseditor to edit the recipient subject and body of an email.
later call mailer composes an email with the information from editor and sends it to an smtp server.
in this example call mailer has the email sending functionality since editor only stores the user input into a bu er and does not apply any calculation or transformation to the given inputs.
to get two execution traces for dual slicing we run the program twice with di erent recipients subjects and body texts.
we run the program in exactly the same way the second time except for those inputs.
those three parameters are all that we want our extracted component to require and we want to use the same values for other con gurations such as the smtp server address and sender address.
fig.
4a and fig.
4b present the resulting traces.
line is the slice criterion because it sends the packet containing the email to the smtp server.
the dual slice includes that line because the sent packets di er in the two executions.
line further depends on lines and .
line uses the same value of smtp server in both executions so the dual slice excludes it.
because lines and produce value di erences the dual slice includes them.
also line is directly or transitively control dependent upon lines and but those lines do not re ect di erences across the two executions so the dual slice excludes them.
the dual slice shows that lines and are important for the mail sending functionality.
note however that lines and simply copy the input to a bu er.
because they only move the input around and do not make decisions or perform computations with it these lines form anirrelevant pre x of the desired behavior.
they re ect preparatory bookkeeping work rather than behavior of the desired component itself.
we can thus omit them entirely and still locate the functions containing the behavior we wish to extract.
the trim function removes such instructions from the front of the dual slice up until the rst decisions or computations with inputs that di er across the executions.
in practice this localizes the component to a smaller portion of code.
in our example the only remaining instruction is line so the technique identi es that the email sending feature is located within call mailer .
coverage based approaches.
prior work on feature location computed the di erence in statement coverage between two executions one sending an email and the other not sending the email .
this coverage based comparison can identify more functions than we desire because the reuser113112 while true c select stdin t if c t else if c stdin command read stdin if command send pine send pine send editor env body editor envelope env body body env recipient read stdin env subject read stdin body text read stdin call mailer smtp server env body call mailer ... s connect smtp server send to s ... log send mail stdin send recipient1 subject1 body1 a execution 1stdin send recipient2 subject2 body2 while true c select stdin t if c t else if c stdin command read stdin if command send pine send pine send editor env body editor envelope env body body env recipient read stdin env subject read stdin body text read stdin call mailer smtp server env body call mailer ... s connect smtp server send to s ... log send mail b execution figure dual slice of the simpli ed pine example from fig.
.
cannot control the program s behavior at a ne grained level.
that is a small behavioral di erence to the user may correspond to many di erences in terms of which functions a program executes only a few of which may be interesting.
consider xv an image viewer that can convert one image format to another.
suppose our target functionality is converting a bmp format image to jpeg format.
to compute the coverage di erence we load the same le in both executions.
we convert the le into jpeg format in one execution but cancel the conversion in the other.
fig.
5a presents the coverage comparison results.
the results show a large call graph with many functions related to processing the user interface and handling user input such as mouse clicks in addition to the important function writejpeg .
furthermore the approach misses the function loadbmp which is responsible for loading a bmp image.
in contrast dual slicing computes a concise set of functions for the conversion and identi es loadbmp as well.
fig.
5b shows the dual slice which highlights only the important functions writejpeg andloadbmp .
we later discuss pruning the extracted component to contain only these two functions and their callees.
the simple coverage di erence includes many non essential functions because the reuser cannot control every detail of program behavior by enabling and disabling the target feature.
hence in this paper we use dual slicing to focus more concisely on the interesting di erences.
.
interface casting once we have located the function the reuser wishes to extract we must take the potentially complicated interface of that original function and compose a simpler alternative interface with only the reuser s desired parameters.
our approach to this problem is to rst concretizing all of the values that feed into the selected function to hermetically seal and isolate the function s behavior.
this makes the function behave the same way every time it executes.
our technique then relaxes this seal for only the reuser s desired inputs by redirecting accesses of the original inputs so that they instead access inputs of a freshly constructed interface.
alg.
presents an overview of the interface casting process.
the algorithm takes three parameters the code to extract a result of the component identi cation algorithm an execution ethat exercises the desired feature and one additional execution for each parameter we wish to specify.
in the pine case study if we wished to specify the recipient subject and body of an email we would need three additional executions.
one would send an email with the same subject and body as execution ebut with a di erent recipient.
another would send the email with a di erent subject.
the last would send the email with a di erent body.
these additional executions identify those instructions that access each of the di erent speci ed parameters.
algorithm interface casting input extract denotes the code to extract which is identi ed in the previous section an execution eexercising the target functionality a list sof pairs ei ti with eithe same as e except that eihas a di erent value for the ith input with typeti intended by the user.
interfacecasting extract e s extdep instruction instances in ethat are part of extract and have external dependences seal off all external dependences concretize extract extdep patch to allow reuser specified inputs for each ei ti 2sdo e ei instruction instances emitting the feature related output in eandei resp.
di e s instruction instances in dualslice e ei if instruction instances in di extdep redirect extract if ti end for line computes the set of instruction instances with external dependences.
if an instruction reads a value from memory that was written outside the modular component it is an external dependence.
since the selected component does not create values for external dependences they must be provided for the component to execute correctly.
line concretizes all external memory dependences to seal the behavior of the function.
this replaces values of accesses with those observed in e. extracting the function at this point would create a new function with no arguments that behaves as in eevery time it is called.
the loop in lines considers each parameter speci ed by the reuser and identi es all11321main 2load config 3menu 6load config 7smtp server x.x.x.x 10menu 11t timer while true c select stdin t if c t timer expired do something else if c stdin command read stdin if command send pine send log send mail else if command cancel continue 28pine send 29envelope env 30body body 31editor env body 32call mailer smtp server env body 35editor envelope env body body 36env recipient read 37env subject read 38body text read 41call mailer char server envelope e body b 42s connect server 43send to s compose mail e recipient e subject b text figure a program modeling email sending in pine.
instructions with external dependences upon each parameter.
the loop redirects those accesses to instead use new memory locations that hold the values of the parameters within a wrapper function that matches the reuser s demands.
concretization.
to seal the function and remove undesired inputs from the interface we concretize the values of those inputs by monitoring memory accesses.
for example in fig.
call mailer has a variable alt smtp servers that holds alternative smtp server addresses.
we do not want the function we extract to expose this complex behavior to the reuser.
to provide an interface without this parameter we concretize the value of the parameter so alt smtp servers always holds the same value in the extracted version of the function.
note that if the reuser intends the smtp server to be an input of the extracted component he she could simply provide an additional execution that di ers from the original execution only at the smtp server address.
alg.
explains the concretization process.
lines process the instructions with external dependences.
by the de nition of an external dependence we can assume that the instruction iwill have the form movr2 because it reads external memory.
lines replace the original instruction with a guard to see if the dynamic instance of the instruction uses external memory and new mov instructions to redirect the memory access to a saved value if so.
lines process the instructions that write to externalloadbmp computescrlvals draw3drectsetdirsavemode drawselredrawdirwopenfirstpic createpsd scchangehandleevent dredrawxvbcopy btsetactivehandledispmodemain eventloop haveselection changedctrllistctrlboxlscreate mbredrawsetfname mbtrackchangecmapmode lschangedata cbsetactive settextcursorcreatetextwins loadcurrentdirectoryset824menus btredrawmbclick dsetvalcreatedirwmainloop setbrowsecursorcreatectrl createbrowse drawctrlnumfiles cbredrawcentermapwindow scrolltocurrentgenerateepic scsetvalmbselect ls3dnewcmap setcursorsscrolltofilename dsetrangeresizetext dimrectdimdialchangecommenttext resizebrowse setcursorsbttrackclickctrl sccreate dsetactive hdredraw redrawnlist drawctrlstrdcreatejpegdialog showfname ulinestringreadpicfile redrawdnamwjpegcheckevent clickjdscsetrange lsredrawalloccolorsnewpicgetcolors activeprevnext writejpeghmap2dialswaitcursorhandlebuttonevent drawtextwcreategam drawjdsethsvmode redrawctrl drawthumblsnewdata redrawcmapcreatejpegw drawstringgetistrchangesu x docmdkilloldpics drawarrowclickdirw setdirfnameopenpic redrawdlist drawbuttdirbox centerstringdosave scredraw drawvalstr a coverage di erence between converting bmp to jpeg and not converting bmp to jpeg.
shaded nodes are the functions executed only when converting bmp to jpeg and the lone black node is writejpeg which is important for the conversion.
encode oneblock jpeg fdct isloweventloop ush bits jcopy sample rowswrite letrailer nish pass master grayscale convertjpeg nish compressmainloop handleevent compress data emit bitsfullsize downsampleencode mcu hu docmdmain expand bottom edgejpegcheckevent process data simple mainclickjd sepdownsample emit bytewritejfif jpeg write scanlines nish pass hu handlebuttonevent preprocess data expand right edgeforward dctemit markeropenfirstpic openpic readpicfile loadbmp24 getintloadbmp writejpeg b the result of dual slicing.
the call graph is concise and highlights only two functions loadbmp andwritejpeg .
figure call graph from xvcase study memory.
in other words such an instruction writes a value to some location in memory allocated outside the identi ed function in the original execution e implying that the address is invalid in the extracted binary.
thus we rst map the observed memory address of the access into the address of a new variable that we create within the data section of the extracted binary on lines .
line similar to the read case replaces the instruction to use this new mapped address instead of the original one.
redirection.
in order to redirect parameters we rst identify the parameters using dual slicing.
the approach is similar to the one used for locating the desired function.
for each parameter we use two inputs that di er only with respect to that parameter.
for example we may use two inputs that have di erent recipients to identify the instructions responsible for the recipient parameter.
after our technique identi es these parameter providing instructions it redirects the memory accesses in the instructions to new locations.
when an instruction reads a parameter from memory it instead redirects the memory access to a new variable or bu er prepared to hold the parameter.
alg.
presents the redirection algorithm.
line adds a new variable to the data section of the binary.
this new variable will hold the input for the extracted version of the function so accesses of the original data must be redirected to this new variable.
we break the inputs down into two di erent categories during the process scalar variables which are always accessed through their starting address and bu er variables which have many internal addresses that may be accessed independently.
lines process scalar variables.
on line the algorithm iterates over the instructions ifi discovered by dual slicing with two inputs that identify one1133algorithm patch the extracted code for external dependences through concretization input extract denotes the code to extract extdepdenoting instruction instances in ethat are part of extract and have external dependence concretize extract extdep concretize reads of external dependences for each unique instruction iinextdepdo letibe movr2 lett faddr7!valgbe a map from addresses to the values of i s external dependences replace iwith the following ifr12t mov r t else mov r end for patch instructions writing through addresses derived from external dependences for each instruction iinextract that may write to an address that is directly indirectly computed from an external dependence in edo letibe mov r1 for each external address athatihas written to do add an entry xato the data section map xa end for replace iwith the following ifr22map mov r else mov r1 end for parameter.
on line it replaces the instruction.
if the instruction reads from the location that we identi ed as theith parameter it is redirected to instead read the new variable prepared for the ith parameter on line .
external dependences through registers are handled similarly and thus elided.
lines process a variable holding a bu er that may be read from at any consecutive memory locations within the bu er.
many strings provided by the user fall into this category including the body dataparameter in the pine case study.
similar to scalar variables the algorithm iterates over and replaces the discovered instructions.
if the instruction reads from a memory address corresponding to the ith parameter it is redirected to read from the new location.
because the instruction reads from a bu er we must guard the redirection by checking whether the address lies between the lowest address observed for the ith parameter and the size of the new parameter.
next we use the pine example to illustrate concretization and redirection.
fig.
presents a portion of code from pine that reads the email subject along with the corresponding binary code and the rewritten binary after concretization and redirection.
on line call mailer readsheader env on line smtp mail readsenv subject and on line rfc822 output ... reads a subject from a bu er where subject is pointing.
to nd the instructions that read the email subject in this example we slice two executions with di erent subjects.
the resulting dual slice includes only line because that instruction reads the subject and the value changes when thealgorithm redirect instructions related to the ith input.
input extract denotes the code to extract ifithe instructions load the ith input tithe type of the ith input redirect extract ifi ti add a global variable viof type tito the data section iftiis a scalar type then for each unique instruction xinifido letxbe movr2 letaddr be the address accessed by xinifi replace xwith the following ifr1 addr r1 x i mov r r1 addr else mov r end for else if tiis a bu er type then for each unique bu er access instruction xinifi do xmust be an instruction repetitively executed to access a buffer letxbe movr2 letaddr be the lowest address accessed by xin ifi replace xwith the following ifaddr r1 addr t i.size t r r1 x i r addr mov r r1 t else mov r end for end if user input changes.
although lines and are not in the dual slice the values they use come from outside call mailer causing external dependences.
hence our technique automatically concretizes accesses in lines and and redirects the one in line as shown in lines for header for header env env subject and subject .
the key idea of concretization and redirection is that the concretized values are used only as keys for redirection and never actually dereferenced.
concretized pointer values ensure the same original bu er address is accessed and the accesses can simply be redirected.
for example we concretize the instruction on line that reads the header parameter.
on line pine readsheader env through header .
since the ebx register is already concretized on line ecxis also concretized on line .
note however that one instruction may execute many times and some instances of the instruction should be concretized while other instances should not we ensure that the instruction performs the original behavior as necessary through the else branch of the instrumentation.
.
practical challenges nondeterminism.
in the previous section we claimed that the dual slice presents only di erences originating from input di erences.
however when a program is nondeterministic there can also be di erences caused by that nondeterminism.
for example fig.
shows that two executions of pine that send an email can have di erences as a result of nondeterminism within an event handling loop controlled by a timer.
in the rst execution we select the send command of the menu11341call mailer metaenv header ... ... 3smtp mail ... header env ... 633b98 mov ebx !mov ebx 0x7ffee00 6633ba0 mov ecx !ifebx 0x7ffee00 mov ecx 0x7ffef40 else mov ecx ... 12smtp mail ... envelope env ... ... 14rfc822 output header line ... env subject mov eax !ifecx 0x7ffab40 mov eax 0x7fff080 else mov eax ... 21rfc822 output header line ... char subject ... while n d subject !
664fc9 mov eax !if0x7fff080 edx 0x7fff080 mov eax nsubject else mov eax ... figure source code of pine reading subject from data structure before the timer expires in iteration a but in the second execution we select the send command after the rst timeout in iteration b and before a second timeout in iteration c. thus lines in the rst execution do not align with any lines in the second execution.
the resulting dual slice includes lines because line control depends upon lines and and line data depends upon line .
this is not a desired result because lines also execute in iteration c of the second execution and these lines show no value di erences.
to address this issue our technique identi es possible nondeterminism through a calibration phase.
we execute the program twice with the same input.
di erences between the two executions show that the program has nondeterministic behavior and speci c di erences indicate where nondeterminism occurs.
when an instruction has a value di erence across the executions i.e.
their occurrences in the two executions align but have di erent values the value di erence originates from nondeterminism and the instruction can be ignored during the component location process.
in contrast control ow di erences i.e.
unaligned instruction instances usually arise from nondeterminism in event handling loops.
in our pine example the send menu item may be selected in either the rst or second iteration of a loop depending on the timer.
thus our technique rst nds the loop containing the nondeterministic behavior through calibration.
in our example the while loop starting on line is identi ed as the nondeterministic event handling loop.
during component identi cation when aligning executions with di erent inputs our technique does not simply align each iteration of a nondeterministic loop in order but rather based on edit distance .
the technique nds which alignment of iterations in both executions yields the fewest misaligned instructions.
if multiple iterations align equally well the earliest is selected.
in fig.
our technique aligns iterations a of the rst execution and c of the second.
locating multiple components.
in some cases the component containing the dual slice includes most of the binary.... 12while true f c s e l e c t stdin t i f c t else i f c stdin command read stdin i f command send f pine send log send mail ...... 12while true f c s e l e c t stdin t i f c t do something 12while true f c s e l e c t stdin t i f c t else i f c stdin command read stdin i f command send f pine send log send mail ...12while true f c s e l e c t stdin t i f c t else i f c stdin command read stdin i f command send f pine send log send mail 12while true f c s e l e c t stdin t i f c t else i f c stdin command read stdin i f command send f pine send log send mail 12while true f c s e l e c t stdin t i f c t do something a b c figure two executions with nondeterminism.
iteration a should align with iteration c. for these cases our technique supports identifying multiple modular functions to extract instead of just one function in order to reduce the size of the component.
recall for example the xvcase in fig.
5b.
locating a single component will extract everything called by the function mainloop which is undesirable.
instead our technique can extract only writejpeg andloadbmp which precisely capture exactly the behavior of interest.
when extracting multiple functions the data ow between the functions must be property connected.
for example writejpeg must use image data generated by loadbmp .
the concretization and redirection process handles this.
to simplify our discussion assume two functions aandbare extracted with awriting to a chunk of memory m which is later read by b. the memory is allocated outside both a andb.
during concretization instructions writing values to m ina are replaced with writes to a new and valid memory location.
instructions reading m inb are redirected to the new memory.
if data ow between aandbgoes through another function c e.g.
cmodi es the values between a andb cwill be included in the dual slice as well and thus the aforementioned process still applies.
concretizing other resources.
during concretization accesses to external memory get replaced with valid accesses to freshly created variables.
however not all external dependences may be on memory.
for example the extracted component may depend upon a le handle that is not affected by the reuser s chosen parameters.
in such cases we must identify the external dependences on other necessary resources and safely acquire them as well.
pragmatically our present implementation handles dependences on external les and sockets but it can be extended to other resources once they have been identi ed.
.
experiments and results we have implemented a prototype of our system using pin for tracing while the dual slicing is written in c. we use bistro for extracting the desired components as well as for binary rewriting to perform concretization and redirection.
note that bistro is a robust binary transformation tool.
it can safely extract portions from or patch arbitrary binaries by correcting internal