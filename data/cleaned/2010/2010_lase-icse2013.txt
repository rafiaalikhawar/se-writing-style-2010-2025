lase locating and applying systematic edits by learning from examples na meng miryung kim kathryn s. mckinley y the university of texas at austin microsoft researchy mengna09 cs.utexas.edu miryung ece.utexas.edu mckinley microsoft.com abstract adding features and fixing bugs in software often require systematic edits which are similar but not identical changes to many code locations.
finding all relevant locations and making the correct edits is a tedious and error prone process.
this paper addresses both problems by using edit scripts learned from multiple examples.
we design and implement a tool called lase that creates context aware edit scripts from two or more examples and uses these scripts to automatically identify edit locations and to transform the code.
we evaluate l ase on an oracle test suite of systematic edits from eclipse jdt and swt.
l ase finds edit locations with precision and recall and transforms them with accuracy.
we also evaluate l ase on example systematic edits from other open source programs and find l ase is accurate and effective.
a key contribution of this paper is an algorithm that combines two or more edits to make a script.
this feature of learning from multiple examples is critical to accuracy edit scripts created from only one example produce too many false positives false negatives or both.
these results illustrate that lase should help developers in automating systematic editing.
whereas most prior work either suggests edit locations or performs simple edits l ase is the first to do both for nontrivial program edits.
i. i ntroduction to add features fix bugs refactor and adapt to new apis developers often perform systematic edits similar but not identical changes to many locations.
kim et al.
observe that of structural changes involve systematic change patterns .
nguyen et al.
find that to of bug fixes are systematic to occur in methods that perform similar functions and or object interactions .
when an api evolves client applications must systematically adapt by constructing new objects passing new arguments or replacing api calls .
in the context of product line software development programmers often make similar changes to related products.
in all these examples programmers manually locate many code locations and then apply similar but not identical edits to them one by one.
this work is tedious and error prone.
existing tools either suggest code locations or transform the code but not both except for specialized or trivial edits.
for example much prior work infers code patterns or takes them as input to find buggy code violating the patterns or they identify code clones that may require similar edits .
however these tools do not fix programs by applying source transformations.
other tools apply code transformations but the the user must specify the target locations .
the closest work locates and fixes violations of simple local invariants by applying simple edits performing very stylizedapi usage corrections or applying identical lexical edits to similar text .
however these tools do not perform nontrivial program transformations.
for example andersen and lawall s approach focuses on api changes and cannot always correctly position edits because they compute positions without considering data and control dependence constraints that edits have on their surrounding context.
this paper introduces l ase locating and applying systematic edits to help developers evolve programs by performing systematic general edits that add features and fix bugs.
developers specify two or more example methods that they edited by hand to l ase.
lase learns a context aware edit script and uses it to find other edit locations and to apply a customized edit to each target location.
from the exemplar changed methods l ase infers the most specific generalization resulting in a partially abstract context aware edit script.
intuitively l ase infers edit operations insert delete update and move common to all examples and abstracts or omits edit operations that differ between the examples.
for instance if two examples delete the same ifstatement but disagree on specific identifiers variable type or method names l ase creates a partially abstract delete statement in the edit script that abstracts the uncommon ones.
it uses concrete identifiers if they are common among all examples.
lasenext computes the context of the inferred edit operations which determines the relative position of edits in the method.
for instance if the edit operation inserts a statement sands is the first statement in a while loop in both edits the context is the while loop and the relative position is while s first child.
l ase determines the largest common context with a novel algorithm that combines clone detection maximum common embedded subtree extraction and dependence analysis.
the result is an edit script that consists of partiallyabstract edit operations and context.
lase uses the script to find edit locations and transform the code.
l ase relies on the assumption that similar contexts require similar code changes.
l ase thus searches for code locations that match the context of the script.
if it finds a new code location that matches the context it customizes the script for the method.
l ase replaces the abstract identifiers in the script with concrete identifiers used by the target method.
it then applies this customized edit script and suggests the changed method for developers review.
we perform a thorough evaluation of l ase and its featureson programmer applied systematic edits drawn from opensource programs.
we use real world repetitive bug fixes that required multiple check ins in eclipse jdt and swt as an oracle.
for these bugs developers applied supplementary bug fixes because the initial patches were either incomplete or incorrect .
we evaluate l ase by learning edit scripts from the initial patches and by determining if l ase correctly derives the subsequent supplementary patches.
on average lase identifies edit locations with precision and recall.
the accuracy of applied edits is the toolgenerated version is similar to the developers version.
in several confirmed cases l ase identifies and performs edits on locations that the developers missed.
we also evaluate l ase on a test suite of systematic edits drawn from five java open source projects.
in these experiments we find that l ase s approach to finding locations has significantly fewer false positives and negatives when compared to other approaches such as learning edit scripts from a single example with fully abstract or fully concrete identifier names.
the partially abstract context and edits that l ase infers from multiple examples are critical to achieving high recall precision and accuracy.
to our knowledge l ase is the first tool to learn nontrivial program edits from multiple changed methods to use them to find other edit locations and to perform customized program transformations at each location.
l ase reduces the time and effort of specifying code changes manually searching for methods that need a systematic edit applying the edit and thus eases the pain of tedious and error prone hand editing.
ii.
m otivating example this section uses a motivating example drawn from revisions to org.eclipse.compare to show l ase s work flow and compare it to our prior work.
figure shows two methods with similar changes maandmb.
the unchanged code is in black added code is in blue with and deleted code is in redwith .
the changes to method madelete two print statements lines to insert a local variable declaration next for each enumerated element line of ma perform a type cast to mvaction on the variable line and then process it.
in our prior work s ydit relied on the developer to specify this one exemplar change and also to specify where to apply the inferred edit transformation.
an edit script consists of edit operations add delete move and update and context other statements in the method on which the edit statements are control and or data dependent that serve to position the edit.
figures and show example edit scripts.
gray bars represent edit context red bars represent deleted code and blue bars represent inserted code.
figure shows the edit script inferred by s ydit .
unfortunately in this example s ydit cannot apply it to either mbormcbecause the script is too specific to ma.
in general learning a systematic edit from a single example has the following limitations it may over specify the learnt edit to the example.
in this case learning only from method maincludes deleting two statements lines and but these operations arespecific to maand prevent the script from being applied to other methods such as mbandmc.
it may over generalize the edit.
given only one example it is unclear which concrete identifiers will be the same in other methods and thus abstracting all identifiers produces a more flexible script.
for instance abstracting eof type iterator tov 0of type t 0enables v 0to match variables einmaand iter inmb both of which have type iterator .
however full abstraction is so flexible that v matches task inmd we omit md s code for brevity which is not an instance of type iterator and mdis not a location where the programmer wants to apply the learnt edit.
searching with this edit script produces many spurious false positive matches.
this paper seeks an edit script that serves double duty both finding edit locations and accurately transforming the code.
we take the approach to learn from two or more example edits given by the developer to solve the problems of over generalization and over specification.
although developers may also want to directly create or modify a script since they already make similar edits to more than one place we think providing multiple examples is a natural interface.
developers may also use a tool like repertoire to identify multiple code examples that changed similarly.
figure shows the workflow for l ase where the developer specifies two exemplar changed methods maandmb.
lase then infers the edit script shown in figure .
l ase uses the edit script to find locations for which it is appropriate specializes the script for each location applies the script and suggests the resulting code to the developer.
to create edit scripts from multiple examples requires new algorithms that identify common changes and context which abstract or omit differences.
none of these algorithms are necessary when learning from a single exemplar edit.
lase first finds the longest common edit operation subsequence among exemplar edits to filter out operations specific to only a single example.
notice that l ase omits the deleted print statements from ma lines and in figure because the edits are not common to maandmb.
lase next extracts the context for each common edit and then it determines the largest common edit relevant context by combining clone detection maximum common embedded subtree extraction on the abstract syntax tree ast and program dependence analysis.
finally l ase abstracts operations and context in the script.
for example the script in figure uses type name iterator because it is common to maandmb.
however since field access factions inmaand method invocation getactions inmbmatch but differ it generalizes them to an abstract identifier u fieldaccessormethodinvocation .
the next few sections describe how l ase creates edit scripts uses the edit context to search for additional locations and applies the edit.
iii.
a pproach this section summarizes l ase s three phases and formalizes our terminology.
the following sections then describemaoldtomanew mboldtombnew .
public void textchanged tevent event f .
iterator e factions.values .iterator .
print event.getreplacedtext .
print event.gettext .
while e.hasnext f .
mvaction action mvaction e.next .
if action.iscontentdependent .
action.update .
object next e.next .
if next instanceof mvaction f .
mvaction action mvaction next .
if action.iscontentdependent .
action.update .
g .g .
system.out.println event is processed .g1.
public void updateactions f .
iterator iter getactions .values .iterator .
while iter.hasnext f .
print this.getreplacedtext .
mvaction action mvaction iter.next .
if action.isdependent .
action.update .
object next iter.next .
if next instanceof mvaction f .
mvaction action mvaction next .
if action.isdependent .
action.update .
g .
if next instanceof fraction f .
fraction action fraction next .
if action.isdependent .
action.update .
g .g .
print this.tostring .g fig.
.
a systematic edit to two methods based on revisions from and to org.eclipse.compare !
!
!
!
.
.
.
!
!
.. .
.
fig.
.
s ydit learns an edit from one example.
a developer must locate and specify the other methods to change.
!
!
!
.
.
.
.
!
fig.
.
l ase learns an edit from two or more examples.
l ase locates other methods to change.
.
... ... method declaration ... ... .
t v v .m .m .
delete m v .m .
delete m v .m !
.
while v .m .
update t v t v .m .
to t v v .m .
if v .m .
... ... .
.
insert if v instanceof t .
insert t v t v .
... ... .
!
move fig.
.
edit script from s ydit abstracts all identifiers.
gray marks edit context red marks deletions and blue marks additions.
.
... ... method declaration ... ... .
iterator v u fieldaccessormethodinvocation .values .iterator .
while v .hasnext .
update mvaction action mvaction v .next .
to object next v .next .
if action.m .
... ... .
.
insert if next instanceof mvaction .
insert mvaction action mvaction next .
... ... .
!
move fig.
.
edit script from l ase abstracts identifiers that differ in the examples and uses concrete identifiers for common ones.
gray marks edit context red marks deletions and blue marks additions.
each phase in detail.
we analyze and transform an abstract syntax tree ast representation of the program.
we also represent edit operations and context using ast.
phase i takes as input multiple changed methods mand generates ast edits for each of them.
it identifies the common edit operations e among all examples and extracts the largest common context crelevant to eto create an edit script p. phase ii identifies other edit locations mfthat match the context celsewhere in the program.
phase iii customizes the edit to each new location mf2mfand applies it.
phase i generating an edit script.
generating an edit script from multiple examples has four steps.
generating syntactic edits.
for each changed methodmi2m fm1 m2 mng lase compares the old and new versions of miand creates an edit script ei fe1 e2 e kgwhere eiis a delete insert move or update of ast statements.
identifying common edit operations.
lase identifies the longest common edit operation subsequence ecsuch that81 i n ec ei and ecpreserves the sequential order of operations in each ei.
abstracting identifier names.
when common edit operations e2ecin the examples use distinct identifier variable type and method names l ase replaces the concrete identifier names with abstract names resulting e. otherwise it uses the original concrete identifiers.lceos s ei p s ej q ifp orq lceos s ei p s ej q ifequivalent ep eq max lceos s ei p s ej q lceos s ei p s ej q if!equivalent ep eq s e i represents the edit operation subsequence e1 e iine .
extracting common edit context.
lase finds the largest common context crelevant to eusing code clone detection maximum common embedded subtree extraction and dependence analysis.
l ase then abstracts identifiers in context c. the result of this process is a a partially abstract contextaware edit script p. phase ii finding edit locations.
lase uses the edit script s context cto search for methods mfthat match c. phase iii applying an edit.
for each method mf2mf lase concretizes identifiers and code positions in pto mf producing f applies it and suggests a modified versionmf .
iv.
p hase i l earning edits from multiple examples a. generating syntactic edits for each exemplar changed method mi2m lase compares the ast of mi s old and new versions and creates a sequence of node edit operations eiconsisting of insert node u node v intk insert uand position it as the k thchild of v. delete node u delete u. update node u node v replace u s label and ast type with v s while maintaining u s position in the tree.
move node u node v intk delete ufrom its current position and insert it as the k thchild of v. this process uses fluri et al.
s ast differencing algorithm and results in a set of concrete edits fe1 e2 e ng where n 2is the number of exemplar methods b. identifying common edit operations laseidentifies common edit operations in fe1 e2 e ng by iteratively comparing the edits pairwise using a longest common edit operation subsequence lceos algorithm which is a modified version of the longest common subsequence lcs algorithm as shown in equation .
for instance given fe1 e2 e3g lase first computes ec1 lceos e1 e2 ec2 lceos e1 e3 and finally computes ec lceos ec1 ec2 .
we do not require exact equivalence between edit operations because systematic edits are often similar but not exactly the same.
we define the comparison function equivalent ep eq for two edit operations to return equivalence for inexact matches as follows.
lase first applies concretematch ei ej ts which takes as input two concrete edit operations eiandej and a threshold ts.
it compares eiandejbased on edit type and edited node u s ast label i.e.
a string representation of the ast node.
if twooperations are of the same type and the labels bi gram string similarity is above the threshold ts the function returns true.
by default we set tsto .
to increase the number of matches between different but similar edits.
if two edit operations fail the concretematch test l ase applies abstractmatch ei ej which first converts all identifiers of types methods and variables in the edited node u s label to abstract identifiers t m and v .
if the edit type and their labels abstract representation match abstractmatch returns true.
the result is the set of concrete edits that are equivalent and common to all exemplar methods but their identifiers and ast types may not match.
c. generalizing identifiers in edit operations lase next generalizes identifier names as needed.
when all the edits agree on an identifier l ase uses the concrete name.
if one or more edits use a different identifier name l ase generalizes the name.
for example figure shows ea delete mvaction action mvaction e.next matches with eb delete mvaction action mvaction iter.next .
when lase detects the divergent identifiers evs.iter it generalizes them by creating a fresh abstract variable name v substituting it for the original names and creating e delete mvaction action mvaction v .next .
lase records the pairs e v iter v in a map.
l ase then substitutes v 0for all instances of einmaandeaand all instances of iter inmb andebto enforce a consistent naming for all edit operations and edit context.
the result is a list of partially abstract edit operations e. d. extracting common edit context this section explains how l ase extracts the common edit context cforefrom the exemplar methods with clone detection and then refines this context based on consistent identifiers usage ast subtree extraction and control and data dependences.
finding common text with clone detection for each fe1 e2 e ng2e lase extracts unchanged context.
it aligns each two changed methods unchanged context based on the common edit operations they share and uses text based clone detection to find clones in each aligned code segment pair.
when two exemplar edits e1ande2 share a single edit operation we use the edited node n1inm1and the edited node n2inm2to divide the unchanged code in each method into two parts code before the edited node s1inm1 s2inm2 and after the edited node t1inm1 t2inm2 .
l ase compares each segment pair s1vs.s2 t1vs.t2 using ccfinder to detect any clones.
this step reveals all possible common textshared between each two methods in sequence ctext.!
!
.
!
!
!
!
!
!
?
?
!
!
!
!
!
!a b8 !
c3d6 3e f g h i j k l m n fofp !
eq6!
c70b!
!
!rs fp b8 !
.
!
!
!
!
!
?
?
!
96a !
b8 !
ctd6 3e f g h i j l m !
!
!0e!
n !
!
!
k !
!
!
fig.
.
ma s and mb s ast generalizing identifiers because clone detection uses text similarity it does not guarantee that an identifier in one method is mapped consistently to identifiers in other methods.
l ase collects all identifier mappings between each two methods clone pairs.
if there are conflicting identifier mappings l ase only keeps the most frequent one removing the rest and their corresponding clone pairs from the context.
if two different concrete identifiers map consistently with each other l ase generalizes them to a fresh abstract identifier and substitutes it for both identifiers in all statements in the respective methods and the context to create an abstract common context cabs.
extracting common subtree s with mcese because the clone detection algorithm only uses text matching the ast structure of two nodes may mismatch e.g.
two matching nodes may have different unmatched parent nodes.
to solve this problem l ase uses an off the shelf maximum common embedded subtree extraction mcese algorithm to find the largest common forest structure between each two methods asts as shown in equation .
this algorithm traverses each tree in pre order indexes nodes and encodes the tree structure into a node sequence.
by computing the longest common subsequence between each two sequences and reconstructing trees from the subsequence l ase finds the largest common embedded subtree s csub.
mcese s t ifsortis empty max8 mcese head s head t ifequivalent s t mcese tail s tail t mcese head s tail s t mcese s head t tail t otherwise consider ma s and mb s ast in figure .
l ase traverses ma s ast in pre order indexes nodes and encodes the tree into node sequence s where notation marks finishing thetraversal of current node.
indexes xand xmark the boundaries of the subtree rooted at x s node.
similarly l asecreates sequence t for mb.
we then use equation to find the longest common subsequence between them which corresponds to subsequence ofs and oft.
the reconstructed trees out of these sequences are colored with orange and circled with dash lines.
in the equation head s returns the sequence of nodes sub rooting at s excluding s while tail s returns the subsequence following s .
for instance given a sequence s head s tail s .
the function equivalent i j checks string equality between the two nodes labels.
refining edit context with dependence analysis the common text extracted between any two methods may include irrelevant code i.e.
code that does not have any control or data dependence relations with edited code.
blindly including them as edit context may put unnecessary constraints on potential edit locations in need of similar edits causing false negatives in edit location search.
l ase thus refines the extracted text using control and data dependence analysis to produce the edit context.
lase performs control and data dependence analysis on each changed method to find context nodes relevant to any edited node involved in e. for both control and data dependence analysis we include all nodes transitively depended on by an edited node as edit relevant context cdep.c csubtcdepis the final edit context extracted for e. ifcdep is empty instead of an empty context l ase simply uses csub ascin order to find edit locations.
l ase combines eandc to create a partially abstract context aware edit script p where each edit operation in eis described with respect to context c.v. p hase ii f inding editlocations given an edit script p lase searches for methods containing p s context c. based on our assumption that methods containing similar edit contexts are more likely to experience similar changes l ase suggests them as edit locations.
because cis partially abstract it contains both concrete and abstract identifiers.
when l ase matches cwith a method m it matches concrete identifiers by name and matches abstract identifiers by identifier type or ast node type.
for instance iterator inconly matches iterator inm.
an abstract name such as v matches any variable while u 0 fieldaccessormethodinvocation only matches fieldaccess ormethodinvocation ast nodes.
l ase reuses the mcese algorithm described in section iv d to find the maximum common context between candm but redefines theequivalent i j function to compare concrete identifiers based on string equality and abstract identifiers based on identifier type and ast node type equality.
if all the common context between candmmatches each node in c lase suggests mas an edit location mf.
vi.
p hase iii a pplying the edit to apply the edit to a suggested location mf lase first customizes pformfand then applies the edit.
for this process we slightly modify the edit customization and edit application algorithms that we introduced previously .
the customization algorithm replaces all abstract identifiers in pwith corresponding concrete identifiers from mfusing theequivalent i j function defined above.
in addition it positions each edit operation concretely in the target method in terms of ast node positions.
it uses data and control dependences in the edit script and target method to maintain correct and consistent relationships between identifiers and statements.
the result is f which fully specifies each edit operation as a modification of the ast with concrete identifiers and concrete node positions within each target ast.
l ase then applies this customized concrete edit script and suggests a new version for developers to review.
vii.
e valuation this section evaluates the precision and recall of l ase for finding the correct edit locations and the accuracy when l ase applies edits.
we first use an oracle test suite with multiple systematic edits that fix the same bug in multiple commits which are drawn from two open source programs.
we then explore the differences between using multiple examples and one example between l ase s and other variants of edit scripts on a test suite of systematic edits from other five java open source programs.
a. precision recall and accuracy with an oracle data set to measure l ase s precision recall and accuracy we use data from park et al.
s study on supplementary bug fixes .
they find a group of bugs that were fixed in multiple commits to understand the characteristics of incomplete or incorrect bug fixes.
they perform clone detection among bug patches labelededit location operations index bug patches methods xp r a e c a e average average total average table i lase s effectiveness on repetitive bug patches to eclipse with the same bug id to find repetitive similar bug fixes .
if a bug is fixed more than once and there are clones of at least two lines between its bug patches checked in at different times we manually examine these methods for systematic changes.
we find systematic edits in eclipse jdt and systematic edits in eclipse swt.
in table i the first two rows are from jdt while the rest are from swt.
we view the patches as an oracle of a correct systematic edit and test if l asecan produce the same results as the developers from the first two fixes in this set of systematic fixes.
since the developers may not be perfect there may be incorrect edits or some missing edits indeed we found a couple and we cannot control for this potential problem.
if l ase however produces the same results as developers did in multiple patches this indicates that l asecan help programmers detect edit locations earlier reduce errors of omissions and make systematic edits.
we give l ase as input two random changed methods in the first patch.
if there is only one changed method checked in the first patch we randomly select the second one from the next patch.
l ase generates an edit script from these two examples finds edit locations customizes the edit for each location and applies it to suggest a new version.
table i shows the results on this data set.
the table numbers each edit lists the bug identifier the number of patches and methods that developers changed.
for each edit location we present the number of methods that l ase identifies as change locations x the number of methods correctly identified precision p the percent of identified edit locations compared to the correct locations out of all found locations recall r the percentage of correct locations out of all expected locations accuracy a the similarity between the tool suggested version and the expected version only foredited methods.
for each edit operation we present e the number of edit operations shared among repetitive fixes for the same bug i.e.
operations we expect l ase to infer c the number of lines of context inferred by l ase and ae the percentage of operations actually inferred over expected operations.
l ase locates edit positions with respect to the oracle data set with precision recall and performs edits with accuracy.
we determine precision recall and accuracy by visual inspection compilation and testing.
in the table examples are grouped into two sets based on whether l ase refined the context with program dependence analysis or not see section iv d4 .
the first edits have non empty cdep and thus c csubtcdep.
the last edits have empty cdepand thus c csub.
most of the inferred edits are nontrivial and l asehandles these cases well.
for instance edit requires operations.
l ase correctly infers all of them correctly suggests edit locations and correctly applies customized edits with accuracy.
finally although not listed in this table l ase also suggested some omitted edits which developers missed .
these missing edits include one customized edit for edit two customized edits for edit and six customized edits for edit .
we confirmed these omissions with the developers and they validated our suggestions which means that l ase will help developers make systematic edits consistently and reduce errors of omission.
lase cannot guarantee edit application accuracy for four reasons.
first the inferred edit is sometimes a subset of the exemplar edited methods so l ase cannot suggest extra edits specific to a single location.
second when abstract identifiers do not have corresponding concrete identifiers in an edit location e.g.
identifiers only used in inserted statements lase cannot decide how to concretize them.
third based on string similarity l ase s ast differencing algorithm cannot always infer edits correctly when two strings are quite different.
fourth l ase s lceos algorithm cannot always find the best longest common edit operation subsequence between two sequences because it does not enumerate or compare all possible longest common subsequences between the two to decide the best one.
although each of these problems occurred none occurs frequently.
the number of exemplar edits from which l ase learns a systematic edit affects its precision recall and accuracy.
to determine how sensitive l ase is to different numbers of exemplar edits we randomly pick cases in the oracle data set.
for each case l ase enumerates all possible ways to construct an exemplar edit set evaluates the precision recall and accuracy for each set separately and calculates an average for exemplar edit sets with the same cardinality to determine how sensitive l ase is to choice of exemplar edits and the number of input examples.
table ii shows the results.
the table shows that precision pdoes not change as a function of the number of exemplar edits.
however recall r does increase with the number of exemplar edits.
the more exemplar edits provided the less common context is likely to be shared among them the more methods may match the of p r a exemplar edits case case case case case table ii lase s effectiveness when learning from multiple examples context and are suggested as edit locations.
in theory pcan go down when more diverse examples are given but this case did not occur in our tests.
the table shows that accuracy avaries inconsistently with the number of exemplar edits because it strictly depends on the similarity between methods.
for instance when exemplar methods are diverse the fewer common edit operations extracted and the lower accuracy of l ase.
on the other hand when exemplar methods are similar adding exemplar methods may not decrease the number of common edit operations but it may induce more identifier abstraction and result in a more flexible edit script which will help l ase increase accuracy.
b. comparing settings for edit script learning this section compares edits learned from single examples to edits learned from multiple examples.
we use l ase to generate edit scripts from example pairs and our prior tool sydit to generate edit scripts from single examples.
we use l ase to find matching locations and apply the resulting edits.
s ydit does not find edit locations but instead relies on developers to choose locations.
these experiments show that edits learned from single examples are not as useful for finding other locations and motivate using two or more examples.
we measure precision and recall of edit location suggestion and accuracy of edit application on a test suite we developed for s ydit from five open source programs jedit eclipse jdt.core eclipse compare eclipse core.runtime and eclipse debug.
this suite contains pairs of exemplar changed methods.
each pair of methods demonstrates at least one similar edit operation and the two methods are at least similar according to the syntactic program differencing results see section iv a .
we remove the simplest cases e.g.
edits on initially empty methods or only one statement resulting in pairs of exemplar edits.
for each pair we extend the oracle set of exemplar edits as follows.
we first apply l ase to infer the systematic edit demonstrated by both methods and search for edit locations in the program s original version.
then we manually examine these locations.
if a suggested location isid methodstwo examples one example xp r a xp r a average average average table iii learning from one example versus multiple examples indeed edited similarly in the next version but not included in the known method pair we extend the oracle set to include it.
table iii shows the results.
on average learning from one example has lower precision and recall when looking for edit locations as compared to learning from two examples but has higher accuracy when suggesting edits for correctly identified locations.
several reasons explain these results.
inferring a common edit context from two examples results in a mix of concrete and abstract identifiers that generalizes identifiers only when necessary.
using the partially abstract context to search is more precise than using a fully abstract context which matches more contexts.
using two examples reduces the edit to a common subset so the derived edit is more likely not to be accurate for any target location where some extra specific edits are needed.
lase includes all nodes transitively depended on by any edited node in the inferred context so it derives a more precise context as compared to s ydit s context which is based on direct dependence relations.
lase matches context differently than s ydit .p r a lase laseabsall lasesigcon lasesigabs lasedirdep lasesydit table iv comparison between lase and its variants in order to explore how each factor affects l ase s effectiveness we explored variations of l ase and evaluated their average precision recall and accuracy on all edits as summarized in table iv.
lase absall differs from l ase by abstracting all identifiers instead of only abstracting identifiers when necessary.
therefore l ase absall s inferred context is more general than l ase s and it matches more methods causing more false positives and lower precision.
lase sigcon differs from l ase by learning from a single example and using all concrete identifiers.
therefore l ase sigcon s inferred edit is very specific to the example and thus has higher precision and accuracy.
however l ase sigcon s derived context is too specific to reveal more unknown edit locations.
its average recall is just with many false negatives.
in many cases l ase sigcon s context can only find the method from which it is inferred but cannot detect any other possible edit location.
in contrast l ase has recall on these examples.
lase sigabs differs from l ase sigcon by abstracting all identifiers.
unsurprisingly it derives a more general context which matches more methods suggesting edit locations with lower precision and higher recall and applying edits with lower accuracy.
lase dirdep differs from l ase by only using direct dependence relations to include unchanged nodes for edit context instead of using transitive closure of dependence relations.
the comparison shows that excluding the extra dependences in edit context does not affect precision recall or accuracy.
lase sydit differs from l ase sigabs by using s ydit s context matching algorithm to search for locations instead of mcese.
the comparison shows that l ase sigabs has a higher precision higher recall and lower accuracy indicating that mcese is more flexible when matching contexts.
to sum up compared with learning from one example lase s new algorithms for deriving a common edit and context from multiple examples and generalizing identifiers only when necessary are critical to accurately suggesting correct edit locations with high precision and recall.
although lase sometimes sacrifices edit application accuracy for that improvement detecting missed edit locations will improve code quality and save developers time and effort.
viii.
r elated work this section describes related work on programming by demonstration code search edit location suggestion and automated code repair.example based program migration and correction.
the most closely related work automates api migration .
this work detects client differences in api usage from multiple instances creates an edit script called a semantic patch in their work for the correct usage and transforms programs to use updated apis.
this approach focuses on performing stylized api usage correction and cannot always correctly position edits in target contexts because they compute edit positions without considering control or data dependence constraints that the edits have on their surrounding contexts .
in comparison l ase supports much more expressive customizable transformations and uses program dependence analysis to correctly position the edits.
their evaluation is limited to understanding a handful of api usage changes and inferring the reasons for certain bug fixes whereas our evaluation actually uses the inferred systematic edits to search for edit locations applies a customized edit to each location and measures l ase s effectiveness systematically in terms of precision recall and accuracy.
our prior work s ydit produces code transformation from a single example only.
it does not search for edit locations and requires developers to supply target edit locations.
furthermore we find one example is not sufficient for creating an edit script that can find other edit locations multiple examples significantly reduce false positives and negatives.
simultaneous text editing automates repetitive editing .
users interactively demonstrate edits in one context and the tool replicates identical lexical edits on pre selected code fragments.
in contrast l ase performs similar yet different edits using a syntactic context aware abstract transformation.
edit location suggestion.
sophisticated code search takes as input queries like def use and method call sequences and may identify locations missing similar edits.
wang et al.
propose a dependence query language to find code snippets that require similar edits .
using pql developers write declarative rule based queries to look for matching code fragments at runtime and to correct an erroneous execution on the fly .
libsync helps client applications migrate library api usages by learning migration patterns with respect to a partial ast with containment and data dependences.
although it suggests example api updates it is unable to transform code.
all these tools suggest edit locations but developers must manually apply edits whereas l ase automatically finds locations and applies edits.
program synthesis.
recent work on synthesis learns from examples or specifications and then automatically synthesizes a program in a domain specific language .
researchers have applied this approach to string manipulation macros table transformation in excel spreadsheets geometry construction and programs.
however none of the synthesis approaches apply to editing general purpose programs such as java.
automated code repair.
automatic program repair generates candidate patches and checks correctness using compilation and testing .
for example weimer et al.
generate candidate patches by replicating mutating or deleting code randomly from the existing program.
they do not infer edits from mul tiple edit examples nor do they systematically apply an edit to multiple places.
specification based program repair such as autofix e generates simple bug fixes from manually prescribed contracts.
since l ase automatically infers program transformations from multiple edit examples it handles a much larger space of systematic edits than these tools.
ix.
d iscussion and conclusions lase is the first tool to learn nontrivial partially abstract data and control context aware edits from multiple edit examples to automatically search for edit locations and to apply customized edits to the locations.
other tools either are limited to much simpler changes or only suggest locations or only perform edits.
to learn and apply a systematic edit users must provide a set of examples whose common edit operations capture the skeleton of portable edits.
for example a library component developer could use l ase to automate api usage updates in client applications by shipping an edit script learned from examples that already migrated to the new api and tested by the developer.
lase matches the context of a learned edit script against all methods in the entire program reasonably fast in our study matching a learned context against allmethods in each subject program took only seconds on average.
our subject programs jedit eclipse jdt.core eclipse compare eclipse core.runtime and eclipse debug are representative of medium and large size java projects.
currently l ase focuses on single method updates but it may be possible to generalize this approach for higher level changes such as class hierarchy changes.
these activities make coordinated edits to multiple classes and methods.
for example an extract super class refactoring moves a set of related fields and methods from subclasses to a super class.
this type of functionality will require more sophisticated context representations and matching algorithms.
lase customizes edits by establishing a mapping between symbolic identifiers and concrete identifiers from the target context.
however it cannot always find such mapping for code that only exists in the new version.
to overcome this limitation we plan to investigate algorithms to synthesize identifier names based on existing concrete identifiers in the target context.
we believe that users may want to correct inferred edit scripts or write their own from scratch although we did not evaluate it here.
users would then choose which names to abstract or which parts of the edit are more widely applicable.
given this modified script l ase can verify it against the examples.
it can also compare the suggested edits from the original script with those from the modified version to show users effects of a particular modification.
lase aims to relieve some of programmers burden in manual and tedious application of similar changes to eliminate errors due to copy and paste practices to find and transform locations that developers may have otherwise missed.
in summary l ase provides needed functionality that helps developers locate code requiring similar edits and apply these edits automatically.
by learning the common edit operationsand context from multiple examples and matching context against all method locations in the entire program l ase achieves high precision recall and edit application accuracy.
in our extensive study of repetitive bug fixes it achieves precision recall and accuracy.
furthermore lase found and transformed several locations that developers missed.
this approach for program evolution opens a new approach that gives developers tools they need when adding features and fixing bugs.
acknowledgment this work was supported in part by the national science foundation under grants ccf ccf ccf shf0910818 and ccf and by a microsoft seif award.
we thank jihun park for sharing supplementary patch data.