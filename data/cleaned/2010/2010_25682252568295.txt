mining billions of ast nodes to study actual and potential usage of java language features robert dyer hridesh rajan hoan anh nguyen and tien n. nguyen iowa state university usa rdyer hridesh hoan tien iastate.edu abstract programming languages evolve over time adding additional language features to simplify common tasks and make the language easier to use.
for example the java language specification has four editions and is currently drafting a fifth.
while the addition of language features is driven by an assumed need by the community often with direct requests for such features there is little empirical evidence demonstrating how these new features are adopted by developers once released.
in this paper we analyze over 31k opensource java projects representing over million java files which when parsed contain over billion ast nodes.
we analyze this corpus to find uses of new java language features over time.
our study gives interesting insights such as there are millions of places features could potentially be used but weren t developers convert existing code to use new features and we found thousands of instances of potential resource handling bugs.
categories and subject descriptors d. .
language constructs and features general terms languages human factors keywords java empirical study language feature use software mining .
introduction the java language specification jls is the official specification for java.
new editions of the specification jls2 jls4 are released as the language evolves to add new features.
the official java platforms java runtime environment jre and java development kit jdk standard se mobile me and enterprise editions ee all implement the language based on this official specification.
changes to the specification are driven by needs from the community.
this need often comes in the form of an official request a java specification request jsr using the java community process jcp .
the jsr formally defines what the need is why the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.current specification is lacking and proposes a solution.
each new language feature has an accompanying jsr and each new edition of the language has an umbrella jsr to identify the new features.
currently however there is little quantitative evidence demonstrating how most of these new language features are used in practice.
previous studies have investigated the use of certain java language features e.g.
investigated the use of several objectoriented features in java such as class interface and method usage and investigated the use of generics in java.
similarly and investigated the use of non language features such as reflection which in java is supported by the runtime and not the language .
however these studies looked at a relatively small number of java projects around investigated a very small subset of features or did not investigate their adoption over time.
in this paper we utilize the boa language and infrastructure to study java feature adoption over time for language features and on a large corpus of projects1.
the dataset we query is over 31k projects from sourceforge representing over million unique java source files with over million snapshots of those files which when parsed contain over billion ast nodes.
from this dataset we investigate if features were indeed anticipated by the community by looking for their uses before their release dates.
our results show this is true every feature is used prior to release.
we then investigate how those features are adopted over time along three dimensions projects source code files and committers using the features .
our results show that while some features are widely used many see only limited use.
we then investigate if these features aren t being used due to lack of opportunity by defining a set of mining tasks to locate source code that could potentially use these new features.
we find millions of such cases both in files existing before the feature s release date and in new files created after the feature s release.
this suggests there is room for better tool support to recommend the use of these new language features or to convert code to use these features.
it also suggests there may be a need for better training and advertisement of new features.
some of our interesting results include all language features were used prior to their official release indicating anticipation of such features.
all studied features are used however a few features are clearly the most popular including annotation use enhanced for loops and variables with generic types.
several features saw minimal use.
developers do convert existing code to utilize new language features after their release.
thus tool support for such con1our queries and raw results are available online to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
version operations and recommendation of code locations to convert is important for the community.
we found many instances where features could have been used but were not indicating a need for better training or ide support.
in fact some missed opportunities could actually lead to erroneous behavior.
committers tend to adopt new features on an individual basis rather than in a team.
this result is consistent with a previous study but with times more committers.
most committers use only a small number of new features.
a small number of committers account for the majority of new language feature uses.
next we give background on each edition of the jls and the new language features.
then in section we pose the research questions our study aims to answer.
we describe the approach used in our study in section and give the study itself in section .
we give some discussion in section .
in section we describe some previous studies regarding language feature use.
finally we conclude with future work in section .
.
ja v a language specifications jls this section provides background on the java language specification jls .
since the original edition of the java language specification there have been three updates.
in this section we outline some of the changes to the language for each edition.
the full list of features is shown in figure .
note that new language features are purely additive each edition is fully backwards compatible with previous editions.
.
jls2 new language features the java language specification edition jls2 was a relatively minor update in terms of new language features.
this edition added one new language feature assert statements .
.
jls3 new language features the java language specification edition jls3 added several significant language features including annotation types enhanced for loops type safe enumerations enums generic types and variable argument methods varargs .
.
jls4 new language features the java language specification java se edition jls4 made several changes including binary literals adiamond operatorfor generic type inference allowing catching multiple exception types suppression of varargs warnings automatic resource management and underscores in literals .
as these features are not as widely known we detail some of them in this section.
.
.
type inference for generic instance creation diamond as previously mentioned the language allows generic types.
when declaring a variable of a generic type however the generic type arguments must be repeated.
for example map k v m new hashmap k v declares a hashmap with keys of type kand values of type v. note that the generic type arguments were repeated in the variable declaration left and the object instantiation right .
jls4 allows omitting the repeated generic type arguments in the instantiation the so called diamond operator thus changing the previous example to jls2 assert assert i jls3 annotation declaration interface test annotation use test void m .. enhanced for loop for t val items .. enums enum e n1 .. generic variable list t l generic method t void m t a .. generic type interface list t .. extends wildcard class ?
extends e c super wildcard class ?
super s c other wildcard class ?
c varargs void m t... arg .. jls4 binary literals int five 0b101 diamond map k v m new hashmap multicatch catch e1 e2 e .. safe varargs safevarargs try with resources try file f new .. .. underscore literals int million 1 000 000 figure studied java language features with examples.
map k v m new hashmap this new diamond operator can be used anywhere the compiler is able to infer the generic type arguments.
.
.
catching multiple exception types multicatch this edition allows specifying more than one exception type inside a catch clause.
the catch clause s body is then executed when either exception type is caught.
for example the statement try .. catch e1 e2 e .. executes the catch statement s body if the try statement throws an exception of type e1or type e2.
this helps avoid code duplication.
.
.
safe varargs warning suppression the variable number of arguments in methods feature added in jls2 can lead to a large number of compile time warnings when combined with generics.
often however the programmer knows that these warnings can safely be ignored so the ability to disable those warnings was added safevarargs suppresswarnings unchecked varargs static t list t aslist t... elems .. the use of either of these annotations will suppress compiler warnings at this location.
.
.
try with resources certain resources such as files require manually releasing them when finished.
this by itself is easy to forget however even when programmers remember to close the resource errors can still creep in .
to ease the management of these resources a new statement was introduced try file f new .. .. this try statement declares a resource fwhich is available within the try statement s body.
upon exiting the try statement either through normal or exceptional program flow the resource is automatically released.
.
research questions regarding language feature use the focus of our study is the usage of java language features by open source developers.
in this section we outline the specific research questions rq we wish to answer.
rq1 do projects use new language features before their release?
often especially with java an implementation of a requested feature is available before its release.
this can take the form of an official beta pre release or an unofficial compiler.
we are interested in how often new language features are used prior to their official release.
such data can give an indication if a particular feature was anticipated and if providing implementations prior to release may be useful to the community.
rq2 how frequently is each language feature used?
the next question deals with feature usage.
the addition of language features is driven by needs from the community yet to date there has been no study to see how most of java s language features are being adopted by developers.
this question examines language features introduced in jls2 jls4.
for each language feature its use across our entire dataset is tracked.
this data gives insight into how each feature was and is being used.
rq3 how did committers adopt and use language features?
once a new set of language features is available it takes time for developers to learn how and where to use them.
some developers may be excited and try using them as often as possible.
other developers may be content with solving problems with the old set of features as that is what they are accustomed to.
we wish to investigate to see how language feature adoption occurs for individual developers.
rq4 were there missed opportunities to use language features?
although a new language feature may be available developers might chose to not use it.
we are interested in knowing how often such missed opportunities exist.
rq5 was old code converted to use new language features?
we also wish to investigate to see if code using older language features is ever updated to use the newer language features.
.
approach tools and dataset in this section we describe our approach for answering the previously identified research questions.
our approach relies on boa and its dataset from sourceforge .
.
background on boa language and infrastructure the boa language and infrastructure was designed to abstract away the details of software mining and provide a platform for easily writing queries that execute efficiently against a very large set of software repository data.
boa contains data from sourceforge projects and supports a wide range of queries on that data.
the boa language abstracts away most of the details of software mining.
the boa framework mines the software repositories in this case sourceforge and transforms the data into a custom set of types.
the language provides these domain specific types such as project coderepository andrevision that allow users to perform queries against software repositories.
boa currently processes cvs and subversion repositories of java projects.
when it finds a change to a java source file it checks out the snapshot of that file at that revision andparses it using the eclipse jdt parser .
the parsed data is then translated into a custom representation including types such as namespace declaration method variable statement and expression .
the statement and expression types are union types allowing each to represent multiple cases.
the boa infrastructure generates a hadoop mapreduce program to efficiently execute queries.
this is also abstracted away and developers do not have to explicitly write any code to parallelize their queries.
.
dataset used in our study the dataset used for our study is the september dataset from boa.
this dataset includes all java projects on sourceforge with at least one cvs or subversion repository.
the dataset does not include java projects with only mercurial git or bazaar repositories.
the total number of java projects is over 35k see figure .
metric count all projects java projects studied projects repositories revisions files file snapshots java files java file snapshots ast nodes figure metrics for the sourceforge based dataset in boa.
however not all of these projects are useful.
we identified almost 4k projects where all java source files contained a parse error.
we filtered those projects out leaving over 31k projects in the dataset for use in our study.
the dataset contains widely used java projects including azureus vuze weka hibernate jhotdraw jabref junit itext findbugs jml tightvnc etc.
this dataset represents over million revisions by more than 50k developers.
it contains over million unique java files and over million snapshots of those files.
this represents to the best of our knowledge the largest empirical dataset to date for java projects that contains both full history information of the source repositories with over a decade of history and the full ast information from the java source files.
for our research questions the size of the java projects whether or 1k files is irrelevant as we are interested in investigating java language features used by developers without constraining the study to any specific kind of developer.
thus we include small projects perhaps written by novice developers as well as large projects perhaps written by experts .
however for rq3 smaller projects could affect our results and thus as we mention later for this research question we filtered projects with few developers.
.
empirical study on ja v a language feature adoption this section presents our study on java language feature usage.
.
rq1 do projects use new language features before their release?
if a feature is requested by the community then most likely people will be excited to use it prior to its release.
to see if this is true 781first we needed to know the release dates of official implementations for each language specification.
we show these release dates based on each specification s jsr in figure .
jls2 jsr released may feature earliest use projects files assert feb jls3 jsr released sep feature earliest use projects files annotation declaration nov annotation use jan enhanced for jan enums jan generic variable jul generic method may generic type jul extends wildcard jan super wildcard jul other wildcard feb varargs jul jls4 jsr released jul feature earliest use projects files binary literals nov diamond aug multicatch aug safevarargs apr try with resources nov underscore literal nov figure language features are used before their release.
note cutoff times were midnight utc on release date using the release dates in this table we then analyzed each valid java file to see if it used a particular feature.
we filtered out any java file containing a parse error.
then we collected the timestamps of each file using each language feature and then filtered based on the particular language feature s release date.
the results are shown in figure and include the list of features the date of the first mined use of the feature the number of projects that used the feature prior to its release and the total number of files that used the feature prior to its release.
for the earliest uses we manually investigated to verify the identified files actually used the particular feature and that the commit date matched our results.
based on this analysis we identified one project with clearly erroneous commit dates2and we removed that project from this analysis.
interestingly for one project that made heavy use of generics in the commit log referenced switch to gj which is the language extension proposed by bracha et al.
that eventually became the basis of java s generics.
the results in the table clearly show that every language feature was used prior to its official release date and adoption is most likely driven by compiler support.
next we investigate how each language feature was adopted over time.
.
rq2 how frequently is each language feature used?
the addition of language features is driven by needs from the community.
in this section we quantitatively investigate how developers use these new features by looking at each unique java source file path in the system and taking the last existing snapshot of each.
we then analyze that set of snapshots and count feature for each file we generate a mapping between features and the total uses in the file.
we show the results in figure first by total number of uses across the entire dataset then by percentage of java files using the feature and finally by percentage of projects using the feature.
the table clearly shows every feature is being used at least once.
one trend that becomes readily apparent is that jls4 features are not used very often compared to jls3 features.
this is despite the fact there were over a million revisions and 3k java projects active since the release of jls4.
jls2 assert uses file .
project .
jls3annotation declarationannotation use uses file .
.
project .
.
jls3enhanced for loopenumsgeneric variablegeneric method uses file .
.
.
.
project .
.
.
.
jls3generic typeextends wildcardsuper wildcardother wildcardvarargs uses file .
.
.
.
.
project .
.
.
.
.
jls4binary literalsdiamond multicatchsafe varargstry with resourcesunderscore literals uses file .
.
.
project .
.
.
.
.
.
figure java language feature usage by total number of uses by percent of all files and by percent of all projects.
also observe the trends for the ratios of uses to files.
for example the annotation declaration feature has a ratio close to one3 there is roughly one annotation declaration per file.
this is similar for enums and generic type.
these features represent types in java and thus one generally expects to see one type per file.
the ratios for the other features are higher since they are expressions and statements.
for example the ratio of enhanced for loops is three4meaning files using the feature use it around three times.
to see how features were adopted over time we plotted histograms of each feature s use both by number of files and by number of projects.
after examining these plots for each feature we noticed similar trends.
they fell into two categories jls4 features and non jls4 features.
since the trends are similar across features we picked representatives from each category.
the histograms contain bins with day time ranges.
the first time a feature appears it is added to the respective bin.
see fig3this feature appears in .
of files or around 25k files and is used around 29k times total.
4this feature appears in .
of files or around 763k files and is used around .6m times total.
a first uses by file b first uses by project c use density by file d use density by project figure use of the annotation use language feature.
a first uses by file b first uses by project c use density by file d use density by project figure use of the diamond language feature.783ures 5a 5b and figures 6a 6b.
the plots also contain marker lines to indicate the release date of each jls.
we also plotted densities of each feature s use both by number of files and by number of projects.
points in these charts represent the number of files projects using a feature at that time divided by the total number of java files projects at that time to account for growing repositories.
see figures 5c 5d and figures 6c 6d.
for example figure shows a non jls4 feature annotation use.
the histograms all show increasing adoption of the features after release with peaks around .
then the number of files projects adopting the feature for the first time starts decreasing.
to better understand this decrease we investigate the density plots.
as can be expected the files and projects in the system were increasing over time.
the density plots remove this variable from our analysis by computing the percent of feature use at each time.
for example when we look at figures 5c 5d we see that even as the total number of files and projects in the system increases the relative percent is increasing too.
thus we can see that over time the use of the feature is consistently increasing for all features studied.
notice that figure a jls4 feature doesn t show as strong of trends as the previous two features discussed.
in this chart the histograms have less of an obvious trend to them due to the relatively low number of total uses for this new feature.
while the density graphs still show the same general trend of increasing use both by files and by projects there is less of a defined curve in these graphs.
investigating frequently used features.
as seen in figure most language features are used in a very small number of files or less .
the exceptions are annotation use enhanced for and generic variable declarations.
we further investigate some of these popular language features.
first let s look into the use of annotations by collecting the annotation types named at each use.
figure shows the topten frequently used annotation types and the number of uses for each.
as can be seen almost half of the annotation uses were the override annotation.
such widespread use of this annotation makes sense as ides such as eclipse typically automatically add this annotation.
this still counts as adoption however as developers accept and commit these automatically added annotations.
the second most used annotation test is used by unit testing frameworks.
in fact other than test and subl the annotations listed are all jdk or j2ee provided annotations.
we anticipated high use of jdk annotations as the annotation declaration language feature has less than .
use across all java files but the clear domination of those annotations was surprising.
annotation name uses percent override .
test .
suppresswarnings .
column .
xmlelement .
subl .
generated .
xmlattribute .
xmlaccessortype .
deprecated .
figure annotation uses.
percent is out of all annotation uses.
next let s look into the generic variable declarations by collecting the counts of each declared generic variable s type.
figure shows the top ten frequent generic types used top and the top tengeneric type uses percent list .
arraylist .
map .
hashmap .
set .
collection .
vector .
class .
iterator .
hashset .
generic type uses percent list string .
arraylist string .
class ?
.
map string string .
map string object .
set string .
hashmap string string .
vector string .
hashset string .
hashmap string object .
figure variables declared with generic types.
parameterized types bottom .
the results clearly show that the majority of generics are from collection types the most common being list string .
these results are consistent with the previously published study on generics use by parnin et al.
although our study was on a thousand times more projects.
.
rq3 how did committers adopt and use language features?
while in rq1 we showed that all features are adopted before their release and in rq2 we showed how features are adopted over time so far we have only evaluated feature adoption in terms of files and projects.
in this section we wish to evaluate if similar adoption trends also apply in terms of committers.
specifically we also wish to study the adoption behavior of individual committers.
to do that for each changed or added file that was recognized as containing a feature we collected its commit time and author.
for each commit that has changed files containing the use of a feature for the first time the corresponding author is counted as one committer using that feature.
the number of committed files containing the new features are also recorded and counted toward the number of uses for the corresponding committer.
the threat to this method of counting is that if a committer uses a feature in a file which has already contained that feature introduced by some other committer they would not be counted.
however this threat is minimized because in this dataset a file is usually owned and edited by one or a few committers as shown in figure 9b .
.
.
rq3.
how many committers adopted and used new features over time?
figures and show the result for the number of committers using two different features over time.
each bar shows the number of users in the corresponding month.
even though the features appeared at different times both show the same trend of adoption a few committers used the feature before its release then the number of users increases to a peak and finally decreases.
this is consistent with the adoption trend for projects and files seen in rq2.
among the committers using a feature we counted the ones who used that feature for the first time the lower area in red and the784 a number of committers in a project b number of committers editing a file figure number of committers per project and per file for java projects in sourceforge.
figure committers use of annotations over time.
figure committers use of diamond over time.
ones who had used that feature before the upper area in blue .
as seen in the figures after the release date more committers adopted the new features.
once a feature is used for the first time many committers kept using it in later commits in blue .
after a while the number of first time users in red decreases.
this trend is the same for all the features in our study.
comparing the charts the number of committers using annotations is much higher than that for diamond.
this result is expected and is consistent with rq2.
.
.
rq3.
how much did committers use each feature?
to answer this question we count the number of uses of each feature for each committer.
since different features are used at dif ferent levels of granularity in the source code e.g.
generic fields can only be declared at the type level while enhanced for loops can be used multiple times in the body of the method we used the granularity of files to compute the number of uses.
that is the number of uses for a committer is the number of files to which that committer was the first one introducing that particular feature.
figure shows the result for two features annotation use 12a and diamond 12b .
in each chart the x axis represents the committers ranked by their number of uses and the y axis in logarithmic scale is the number of uses.
each bar represents the number of uses for a single committer.
notice that a small number of committers accounts for a large number of feature uses.
about half of the number of committers introduced a feature to less than files while a few committers used the feature in tens hundreds to thousands files.
this trend holds for all features.
comparing the charts we can see that the number of committers are quite different about for annotation use 12a and about for diamond 12b .
in addition the number of committers with the same number of uses varies among features.
for example at uses there are about and committers respectively.
this suggests that there are some feature s which are more popular and widely used e.g.
annotation .
.
.
rq3.
did committers adopt features on an individual basis or as a team?
to answer this question we investigated how many team members adopted features in each project.
we first collected the set of committers for each project identified how many times each committer used a feature and ranked the committers per project based on their number of uses.
then for the top k committers for k we computed the proportion of the top k committers s uses over the total number of uses in the whole project.
in figure 9a we can see that the distribution of the number of committers in a project is right skewed.
that is many projects have only a few committers.
in those projects only one or two committers contribute almost of the uses.
to avoid that bias and to study the team culture we filtered out all projects having less than six committers .
after filtering there were projects remaining which we used for this study.
the result is shown in figure .
each chart shows the histogram of the proportion of feature usage in projects.
the bins are the ranges ... and .
figure 13a shows the result for the top user.
a single committer contributes of uses in over projects and of uses in almost projects.
in figure 13c when considering the top users the number of a annotation use b diamond figure use of language features by committers.
a top annotation use committer b top annotation use committers c top annotation use committers figure proportion of feature uses in projects.
uses increases to almost projects which are the majority of the projects that use that feature.
the other features not shown follow similar trends.
this result indicates that a feature is not widely adopted by all members of the team but instead are mainly championed by a small number of members.
this is also consistent with a previous study even though they studied only projects while we studied projects with at least six committers each .
.
.
rq3.
did committers use all features?
for this question we track the feature uses of a group of active committers who routinely committed code over a long enough period.
since jls3 had the most new features we used the set of committers at the release time of jls3.
we kept all committers that had routinely committed code at least every months in the time between releases of jls3 and jls4.
filtering for committers that used at least one language feature in our study the remaining set contained committers.
the scatter graph in figure shows their uses over time.
for better visualization we group related features from the same edition i.e.
annotation declaration use into annotation generics features into generics binary underscore literals into literal and try with resources and multicatch into trycatch.
a horizontal line shows the use over time for a single committer.
as seen from the graph among the committers only committer adopted features from all three editions.
most committers used features from jls2 and jls3.
jls4 was only used by committers and .
most of the committers used assert the only new feature in jls2 however they started late after its release.
meanwhile the committers adopted jls3 quite early and most of them used several different features.
in terms of individual feature uses up to now no committer has used all studied features.
committers figure tracking features used by committers.
have used at most out of different grouped features.
.
rq4 were there missed opportunities to use language features?
in this section we investigate missed opportunities to use new language features by mining the latest snapshot of source code to find locations where new language features could potentially be used.
for example we mined to find integer literals with or more characters that did not use underscores.
we also mined methods that have as their first statement an if condition that if true throws anillegalargumentexception which could potentially be turned into an assert statement methods that take an array as last argument instead of a varargs argument expressions where the literal was shifted left which could use binary literals generic instantiations that don t use the diamond pattern try statements with786more than one catch block having the same body and try statements with a call to a close method in the finally block.
the results are shown in figure .
in the first row we list the number of mined potential uses in files that existed prior to the feature s release.
these represent places where a maintainer could convert code to use the new language feature.
we found tens of thousands to millions of potential uses in old files.
assert varargsbinaryliteralsdiamond multicatchtry withresourcesunderscoreliterals old 89k 612k 56k .3m 341k 489k .2m new 291k .6m 5k 414k 24k 33k .3m all 380k .2m 61k .7m 365k 522k .5m files .
.
.
.
.
.
.
projects .
.
.
.
.
.
.
figure potential language feature uses in old files before feature release and new files after feature release .
the second line of the table shows potential uses in files that were added after the release of the feature.
these are locations that developers had the option to use a language feature but did not.
again we found thousands of potential uses for each feature and even millions of potential uses for two features.
while some of this unused potential has small impact such as underscore and binary literals making code more readable other missed opportunities could actually lead to erroneous behavior.
specifically we investigate regarding the try with resources language feature which aims to properly close resources.
as weimer and necula point out this is a common source of bugs in programs.
for example the code bufferedreader br ... string s br.readline br.close wouldn t call close if the call to readline throws an exception.
while we found over 500k potential uses for this language feature we were interested in how many of those might lead to buggy behavior.
we narrowed the results of the algorithm to only include methods that throw ioexception do not catch that exception anywhere in the body and contain a call to a close method.
we found instances of potential5resource handling bugs!
.
rq5 was old code converted to use new language features?
as we showed in the last section when new language features are released there is potentially a lot of existing code that could have used the new feature.
in this section we investigate if developers convert old code to update it to the new language features.
unlike the last section where we used only the latest snapshot in this analysis we mine each version of a file and compute the number of potential and actual uses of a language feature.
we then compute those values on the previous version of the file.
if the number of potential uses decreases by exactly the amount the actual uses increased we consider it a potential conversion.
this analysis is extremely conservative and may miss a lot of conversions but it should give a low number of false positives and make verification easier and allows us to confirm the existence of conversion activities to use new features.
we show the results in figure .
5manual verification of random samples showed accuracy.assert varargs diamond multicatchtry withresourcesunderscoreliterals count .1k .5k files .6k .8k projects figure detected conversions to use new features.
we verified the results by manually checking up to detected files from each feature grouping the results by project and systematically sampling from a random starting point in the list.
when verifying a file if other files from the same revision were in the dataset we also verified those.
in total we verified out of files as direct conversions as not conversions and as more complex conversions that also added the new feature.
during this process we found several commit logs mentioning conversions to jdk7 or specifically for one feature e.g.
diamond multicatch assert .
one even stated reviewing locations where throw appears and substituting by assert when convenient.
as we showed developers do convert existing code to utilize new language features after their release.
thus tool support for converting operations to use new language features and recommendation of code locations to convert is important for developers.
.
threats we identified a threat regarding who commits code versus who actually wrote it.
someone may commit a file they did not write perhaps adding a file from another library so it is local in their own repository.
our analysis would attribute the source of that file to the person who committed it which is why we focused on committers not developers.
similarly multiple committers may actually be the same person but count separately in our analysis.
a similar threat relates to the timestamps of committed code.
if someone commits a file they did not write the timestamp of the commit may be wrong.
it is possible that features were actually used earlier than identified in rq1.
we identified an external threat to our study regarding the generalizability of our results.
since we only studied open source software the results may not necessarily represent java language feature usage by non open source developers such as those in industry.
we also do not know the experience level of committers which may vary greatly and limits our ability to generalize.
we avoid generalizing our results and instead focus on if the trends we observed are similar to the trends the previous study observed.
.
discussion while we do not know whyin general people seem to avoid using new language features we did see a lot of unrealized potential to use these features.
it may be the case there should be more or better training of developers or perhaps better advertisement of new features.
or it may simply be user project preference or the feature isn t viewed as useful by the broader community.
what was clear from our study however was two facts.
first there is indeed a lot of code that could use these new features but currently does not.
this seems to indicate a need for recommendation systems to suggest using the newer language features.
the second fact was that people do tend to convert code to use these newer language features.
conversions and recommendation systems go hand in hand.
example if a user wrote int i an ide could show a suggestion to convert this code to use underscores for better readability.
similarly if a literal value of is shifted left it could recommend using binary literal notation.
currently netbeans has an inspect and transform feature that converts to use diamond underscore literals try with resources and multicatch.
eclipse will show a warning if you don t use the diamond operator this behavior is disabled by default7 and provides a quick fix to remove the redundant type arguments.
they also provide content assist for features such as diamond and multicatch.
there is also room for improvement in ides.
not all features are enabled out of the box some features may be slightly confusing such as eclipse giving a quick fix of surround with try catch and a second choice of surround with try multicatch and not all features have conversions or recommendations.
.
related studies grechanik et al.
performed a large scale study on java features on 2k projects from sourceforge.
they provided a relational database and studied features such as classes abstract nested etc methods arities return types etc fields conditional statements etc.
the majority of the features studied are object oriented language features available since jls1.
they did not study newer language features in jls3 or jls4.
their study also focused on releases of projects and not the full history of the repositories.
parnin et al.
mined the history of open source java projects to evaluate how java generics were integrated and adopted into open source software.
as we already showed our finding on the most popular generic types is consistent with their empirical result.
it is also true for the finding that generics are usually adopted by individuals championing for the features rather than all committers in the team.
hoppe and hanenberg performed a small empirical study to determine if generic types in java provide benefit to developers.
basit et al.
performed an empirical study on two projects regarding how java generics and c templates can help in code refactoring.
livshits et al.
focused on the reflection feature in java.
they introduced a static analysis based reflection resolution algorithm that uses points to analysis to approximate the targets of reflective calls as part of the call graph.
calla et al.
studied the reflection feature in smalltalk.
they reported that such a feature is mostly used in specific kinds of projects core system libraries development tools and tests rather than in regular applications.
richards et al.
performed a large scale study on the use of eval in javascript applications.
eval is used to transform text into executable code allowing programmers the ability to dynamically extend applications.
they studied large scale execution traces with 550k calls to the eval function exercised in over 10k websites.
they found that it is often misused and many uses were unnecessary and could be replaced with equivalent and safer code.
earlier richards et al.
analyzed a smaller set of javascript programs and concluded the popular usage of eval and reported the degree of dynamism in those programs.
ratanaworabhan et al.
reported on an existing benchmark for javascript and focused on two aspects of javascript runtime behavior functions and code and events and handlers.
yue and wang performed an empirical study on almost 7k websites regarding insecure practices of javascript inclusion and dynamic generation.
they reported that over of the websites dangerously use eval .
gorschek et al.
performed a large scale study on how de7 use object oriented concepts.
tempero studied how fields are used in java and reported that it is common for developers to declare non private fields but then not take advantage of that access.
tempero et al.
found higher use of inheritance than expected and variation in the use of inheritance between interfaces and classes.
muschevici et al.
studied multiple dispatch in several languages and compared its uses.
meyerovich and rabkin studied how programming languages are adopted by users via several large surveys.
their study was focused on which languages were adopted and did not go into detail of specific language features.
the sourcerer project provides a relational database of mined software artifacts.
their dataset contains over 18k java projects from sourceforge and apache.
the data is modeled as entities such as classes methods or fields and relationships among those entities.
the dataset contains the source code from the latest snapshot of each project.
baldi et al.
use the sourcerer project and topic modeling to empirically validate the theory that aspects are latent topics with a high scattering entropy .
while these previous studies have looked at various language features most are limited to studying a few features looked at a relatively small number of projects or did not look at the full history of the software studied.
our study looks at most of java s new language features studies over 31k java projects and uses each file s full history.
while grechanik et al.
and sourcerer provided potential datasets to use in this study we chose to use the boa infrastructure with over 31k java projects due to having full access to it as well as our intimiate familiarity with the infrastructure.
.
future work and conclusion programming languages evolve over time to meet the needs of developers.
what was needed was a study to see how those features are actually used by developers.
in this paper we investigated language feature usage for java s three newest editions.
our analysis revealed that some developers were eager to use these features even using them as far as six years before their release.
our results showed that every feature is indeed used over time.
the most used features we studied were the enhanced for loops declaring variables of generic type and using pre defined annotations.
the first two features are related and our analysis indicated their heavy use is influenced by the collections classes provided by java s runtime.
the heavy use of annotations but relative lack of custom annotations indicated the use was mostly by automated tools such as ides or code generators.
most features saw limited use but our further investigation showed millions of additional places features could have been used but were not.
this included old files that could be converted as well as new code.
we detected thousands of potential bugs in code that could be fixed by converting to use new features.
we also detected many places where developers had actually converted existing code to use new features indicating a need for tools to suggest and convert code to use new features.
in the future it would be interesting to perform a survey of the developers that appeared in this study to see why they chose to start using features when they did.
perhaps there is a need for better education outreach to inform developers of these new features.
.