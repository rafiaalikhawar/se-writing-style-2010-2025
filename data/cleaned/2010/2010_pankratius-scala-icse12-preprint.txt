combining functional and imperative programming for multicore software an empirical study evaluating scala and java victor pankratius karlsruhe institute of technology karlsruhe germany pankratius acm.orgfelix schmidt gilda garret on oracle labs oracle corporation redwood shores ca usa ffelix.schmidt gilda.garreton g oracle.com abstract recent multi paradigm programming languages combine functional and imperative programming styles to make software development easier.
given today s proliferation of multicore processors parallel programmers are supposed to benefit from this combination as many difficult problems can be expressed more easily in a functional style while others match an imperative style.
due to a lack of empirical evidence from controlled studies however important software engineering questions are largely unanswered.
our paper is the first to provide thorough empirical results by using scala and java as a vehicle in a controlled comparative study on multicore software development.
scala combines functional and imperative programming while java focuses on imperative sharedmemory programming.
we study thirteen programmers who worked on three projects including an industrial application in both scala and java.
in addition to the resulting scala programs and java programs we obtain data from an industry software engineer who worked on the same project in scala.
we analyze key issues such as effort code language usage performance and programmer satisfaction.
contrary to popular belief the functional style does not lead to bad performance.
average scala run times are comparable to java lowest run times are sometimes better but java scales better on parallel hardware.
we confirm with statistical significance scala s claim that scala code is more compact than java code but clearly refute other claims of scala on lower programming effort and lower debugging effort.
our study also provides explanations for these observations and shows directions on how to improve multi paradigm languages in the future.
i. i ntroduction multi paradigm programming languages conjecture that no single paradigm is suited to solve all possible problems in practice.
in particular recent proposals fueled the development of languages that unify the best of functional programming and imperative programming.
this direction is motivated by the need to produce more reliable software despite the growing complexity that programmers face in today s environments.
programming languages thus aim to offer a better cognitive match between their constructs and the problems that developers need to solve while mapping constructs more effectively to computational resources.
their major goals are to increase productivity ensure quality and take advantage of more sophisticated performance optimizations available in modern hardware.
the proliferation of multicore processors has created additional pressure to improve parallel programming.
multicore is here to stay because of stagnating clock rates and saturated power budgets .
standard desktop pcs are truly parallel machines with core or core processors while servers have processors with or more general purpose cores.
embedded devices and mobile phones are becoming parallel machines too.
programmers now need to deal with the additional complexity of parallel programming or miss opportunities for performance on modern hardware.
advocates of the functional style argue that it is less error prone and more productive compared to an imperative style so it should be used to make parallel programming easier.
advocates of imperative style by contrast favor more control to achieve better performance .
earlier empirical studies set up to assess these tradeoffs typically assumed a context that differs from the one today for example some assume that programmers have to use one style exclusively others focus on sequential programs and still others look at highly specific parallel constructs in imperative languages .
today languages such as scala and c allow the combination of functional and imperative programming in the same language so developers don t need to make an exclusive choice.
however new problems arise as it is largely unclear how programmers apply mixed programming styles in larger projects.
we lack empirical evidence from controlled studies to quantify the software engineering benefits to identify potential problems to evaluate which language features are most promising to extend and how to build tools.
as scala compiles to java bytecode program performance can now easily be compared on the same programming task and multicore environment while measuring relevant software engineering metrics in both languages such comparisons were difficult to set up in the past.
to our knowledge this is the first paper to answer key questions in a multicore context with scala and java such as who needs more effort?
who has the first parallelprogram?
whose code is more compact?
how are functional and imperative styles used?
who has the best performance?
how satisfied are programmers?
we analyze the status quo by studying subjects each of whom wrote programs in each of scala and java resulting in scala programs and java programs.
the main object of study is the parallelization of real world vlsi cad tool used in chip design.
our study is based on a counterbalanced withinsubjects design but also applies case study and interview techniques to generate insights that explain phenomena observed in the aggregated statistics.
in addition an oracle software engineer worked on the same project in scala and provided reference data.
the measured effects are strong and confirm with statistical significance that scala code is more compact than java code.
our data however clearly refutes other claims of scala on lower project effort and testing and debugging effort.
the lessons learned for the improvement of scala and java are nevertheless invaluable and show that multi paradigm languages are worth pursuing.
the paper is organized as follows.
section ii outlines multicore programming in scala versus java.
section iii presents claims from the literature that form the hypotheses on how scala s approach aims to improve java imperative parallel programming.
section iv details our study design.
sections v xi elaborate critical questions addressed in this study such as effort parallelization progress code compactness programming style performance and programmer feedback.
section xii discusses threats to validity.
section xiii contrasts related work.
section xiv provides a conclusion.
ii.
m ulticore programming in scala vs .
java scala scalable language is a statically typed multiparadigm language that compiles to bytecode on the regular java virtual machine.
a complete overview of scala is beyond the scope of this paper.
we therefore outline in this section some key principles to set the discussion in this paper.
to facilitate reading key principles are described by example.
for further details we refer to .
a. parallel programming example consider the well known producer consumer pattern that is frequently used in pipelined computations .
listing shows what programmers would typically have to do in java create a shared queue create threads that access the queue synchronize accesses to the queue and use wait and notify signals to let waiting producers or consumers know about an empty or full queue.
advanced programmers who aim to achieve better performance would also explicitly use locks instead of synchronized blocks.
queue item sharedqueue .
.
.
thread consumer t h r e a d synchronized sharedqueue f while sharedqueue .
s i z e fsharedqueue .
w a i t g item it em sharedqueue .
g e t h a n d l e i t e m g thread p r o d u c e r t h r e a d f o r .
.
.
fitem it em c r e a t e i t e m c o n t i n u o u s l y c r e a t e i t e m s synchronized sharedqueue f sharedqueue .
p u t ite m sharedqueue .
n o t i f y a l l gg listing .
producer consumer pattern in java c as e c l a s s item .
.
.
a c t o r consumer a c t o r v a l consumer a c t o r fr e a c t f c as e item .
.
.
h a n d l e i t e m gg a c t o r p r o d u c e r a c t o r v a l p r o d u c e r a c t o r ff o r .
.
.
f v a l it em c r e a t e i t e m c o n t i n u o u s l y produce i t e m s consumer !
i tem send i t e m t o consumer gg listing .
producer consumer pattern in scala in scala there are concurrent actors whose communication is based on message passing.
each actor implements send and receive operations.
in listing the case class construct allows automatic matches of received items based on their type and values.
scala s actor model is implemented on top of java s shared memory model.
scala therefore exposes programmers to different concurrent abstractions but eventually the compiler translates them into java bytecode.
b. functional and imperative programming example scala integrates functional programming with objectoriented imperative programming.
it supports higher order functions currying algebraic data types and native support of sequences such as lists or sets.
for example everything is an object and even would be treated as two int objects 1and2 where the addition is a call to a method of object 1named .
as another example consider the expression numberslist.filter x int x the expression uses the function x int with the body x to obtain all number objects of numberslist that are greater than zero taking advantage of the filter method that is provided for all collection object types.
note that it is not necessary to write a for loop that iterates over all objects to check each one for the desired property.
native frameworks provide frequently used data structures as mutable or immutable types.
in addition scala offers automatic type inference which aims to make coding faster.
programmers can choose to program in scala in an imperative style e.g.
by using explicit object definitions while loops shared state and reusing java code from existing packages such as the java.util.concurrent package.
in addition to java scala provides traits to enhance inheritance expressiveness .
today companies such as twitter employ scala.
scala s unique features promise to make parallel software development easier.
as scala s usage continues to increase programming effort and other aspects deserve a thorough empirical analysis such as the one in this paper.iii.
h ypotheses on scala in the literature scala s combination of functional and imperative programming is claimed to have advantages in comparison to java but there is little evidence from controlled studies.
we summarize important propositions as a motivation for a more thorough empirical examination.
effort.
scala s functional programming constructs make it easy to build interesting things quickly from simple parts .
scala is easy to get into .
the language constructs help programmers get started quickly .
the combination of functional and object oriented constructs have complementary strengths which lead to a legible and concise programming style .
programmers require less effort for reading and understanding scala programs .
for parallel programs programmers tend to find scala s shared nothing message passing model much easier to reason about than java s shared memory model with locks .
code compactness.
scala programs tend to be short in conservative cases a typical scala program should have about half the number of lines of the same program written in java .
in extreme cases scala programs may have one tenth of the lines of code loc of corresponding java program .
scala programs are more concise due to type inference optional semicolons.
p. control abstractions that avoid duplication .
high level data structures can be queried through predicates .
scala s syntax avoids some of the boilerplate that burdens java programs .
parallel programming.
actors are easier to work with than java s native style with locks .
java s concurrency support is sufficient but difficult to get right in practice as programs get larger and more complex p. .
debugging.
scala is less error prone than java as scala programs with fewer lines of code are assumed to have fewer possibilities for defects .
actors help avoid deadlocks and race conditions .
iv.
d esign of the empirical study to validate the aforementioned claims on the status quo of both languages we study thirteen subjects who work individually on two scala and two java projects during a training phase and afterwards on the actual object of study which consists of one scala project and one java project extending a real world application.
all projects require subjects to create bug free and well performing parallel applications.
additional data is provided by an oracle software engineer that agreed to work on the same project in scala.
a. preparations subjects.
the subjects are thirteen master s students close to their graduation who are on average in their fourth year of computer science studies.
subjects in the studyhad appropriate previous knowledge from courses in software engineering e.g.
programming languages patterns development environments and parallel programming e.g.
programming with shared memory and message passing .
subjects reported an average of four years of java experience and no scala experience.
they knew the eclipse and netbeans development environments.
for comparison purposes a software engineer at oracle agreed to work on the scala project and provide his results.
he was familiar with the algorithms relevant for our projects as well as with scala programming.
feasibility study.
prior to the study we conducted a feasibility study to ensure that the assignments have a solution i.e.
there are working parallelization strategies that are feasible to complete in the given period of time.
in addition the same oracle software engineer created a parallel scala program based on our project requirements.
b. a two phase approach the approach applied in this study consists of two phases where the subjects were asked to program in java and scala.
phase one training .
initially all subjects received the same training in programming with java and scala which took four weeks.
the java training covered parallel programming with shared memory.
the scala training included functional programming and parallel programing with actors were required reading .
in addition everyone was trained and tested on how to use eclipse and the netbeans development environment how to debug and how to conduct performance analyses for parallel programs.
every subject successfully delivered a working parallel implementation of the dining philosophers problem and mergesort algorithm both in java and scala i.e.
we obtained java programs and scala programs .
the delivered code was used to assess how subjects understood and employed the programming concepts of java and scala.
in this phase we also measured the level of proficiency a java pretest classified subjects as experts and as beginners.
a scala pretest classified subjects as experts and as beginners.
at the end of phase one everyone passed and was ready to work on a larger project.
phase two industry project .
this phase focuses on the actual object of study which is how programmers use scala and java in a larger and more complex parallel application.
we employ a counterbalanced within subjects design in which randomly chosen subjects are tasked to complete a four week project in java first whereas the other have to do it in scala phase 2a .
in another four weeks the subjects have to deliver another parallel program on the same specification but this time the subjects who started with scala switch to java and vice versa phase 2b .
this design was chosen as resources were available only for one complexproject.
subjects were unaware and were initially told that they will work on two different projects.
counterbalancing is frequently employed to offset learning and ordering effects when aggregating results .
for our study learning effects are discussed in section xii.
competition.
a competition was set up among the java teams and scala teams in both phases 2a and 2b with the goal of achieving the best performing parallel program for the given specification input benchmark and multicore machine.
the competition not only motivated subjects to achieve their best individual result but also reduced the incentive to collaborate which was not allowed anyway .
we also disallowed direct code reuse from the previous project and allowed using just the standard libraries and parallel constructs that come with scala and java e.g.
java.util.concurrent .
project description.
the requirements for the project were designed in collaboration with oracle as an industrial partner.
this setup provides a realistic and representative object of study that goes beyond a toy program.
in particular the electric vlsi design system developed at oracle labs was used.
electric is an open source vlsi cad application for the custom vlsi designs completely written in java.
among all possible cad tools available in electric the analysis tool known as drc design rules checker was chosen as a performance critical parallelizable task.
a design rule specifies certain geometric and connectivity restrictions to ensure sufficient margins to account for variability in the fabrication process.
basic design rules range from one layer e.g.
width area or spacing to multiple layer rules such as enclosure.
due to time constraints and the complexity of dealing with all drc rules involved in modern technologies subjects were asked to parallelize the minimum area checking algorithm.
this algorithm ensures that manufacturers do not print circuits in resolutions that are too small for a given technology and minimum rules might need to be satisfied for each layer of a chip.
to facilitate the study electric developers offered standardized apis for java and scala to create extensions for the drc tool already available in electric.
general literature on design rules checking e.g.
was handed out to subjects already in the first week of the study to give subjects enough time to familiarize themselves with the problem.
at the start of phase subjects were handed out a page document with more precise project and algorithm specifications.
this was accompanied by a tutorial that described the problem examples apis coding guidelines and instructions about data structures to use.
everyone received support to set up his working environment understand boilerplate code and compile project dummies.
questions were answered by instructors and oracle employees.
no one had problems understanding the assignment or working in the programming environment.the compulsory project specifications channel potential solutions into a certain range as assessed in our feasibility study.
they ensure that the submitted programs and results do not differ because subjects employ widely diversified algorithmic strategies and data structures.
in principle our algorithm uses a list of bit sets to merge adjacent boundaries of polygons of a metal layer and to ensure that the areas of all flattened polygons satisfy the minimum area rule.
c. sources of evidence and evaluation sources of evidence .
throughout the study we collect evidence from several sources weekly code submissions.
weekly semi structured interviews with every subject.
student diaries and final project reports delivered after the study .
time report sheets on a daily basis on which students tracked the hours spent on various software engineering task categories e.g.
design implementation testing .
the sheets were cross checked with our interviews and code inspections for validity.
questionnaires after the completion of each programming project phase 2a 2b captured feedback.
evaluation .
we employ statistics case study techniques survey techniques and interview techniques to extract the lessons learned from this study.
for presentation we aggregate most of the quantitative data into box and whiskers plots lower and upper box boundaries denote lower and upper quartiles of data visualizing variability a horizontal line within the box marks the median whiskers mark .
times the interquartile range on both box ends and data exceeding the whisker range is marked as outliers depicted as circles .
to gain further support beyond what is visible in the plots we also apply where possible wilcoxon s rank sum test paired on subject results.
informally speaking this non parametric test evaluates whether two populations differ with statistical significance see for details .
we also apply other tests for cross checks non parametric and parametric if data distributions allow it but typically omit their presentation to avoid overload.
the obtained p values appear in the respective graphs.
low p values mean that there is a low probability that the observed differences are accidental.
as in other similar studies e.g.
we interpret p as a strong indication for a difference which degrades as p increases p 1is the threshold where the difference becomes insignificant.
v. w honeeds more effort ?
our data reveals that completing the drc project in scala requires more effort than in java.
as an overview figure shows the person hours required for the scala and java projects sorted for each language in descending order.
figure illustrates the aggregated statistics.
the median effort is hours for scala and hours for java hours difference .
the mean effort is hours for scala and rankingproject person hours 140scala java 6figure .
effort required to complete the project in scala and in java sorted for each language in descending order.
hours for java which means that on average it takes hours longer to complete the scala project.
the populations differ significantly with p .
scala java20 120project person hours a effort p value .
.
.
.
.
.
.
project person hours b cumulative distribution function javascala figure .
aggregated effort statistics show a significant difference between scala and java.
as the data collection assigns person hours to particular categories we are able to provide additional details in figure which shows how much of the implementation time subjects spent working mostly on sequential code or parallel code.
in figure a the median time for parallel coding in scala is hours mean hours and hours in java mean hours and there is weak statistical support for the difference with p .
for time spent on sequential code in figure b the median in scala is hours mean hours and hours in java mean hours however the difference is insignificant p .
the most significant difference is due to testing and debugging effort in figure c the median in scala is hours mean hours the median in java is hours mean hours a clear difference supported by p .
scala java0 a impl.
parallel codeproject person hoursp value .
scala java0 b impl.
sequential codeproject person hoursp value .
scala java10 c testing and debuggingproject person hoursp value .041figure .
effort for all parallel projects split up into implementing sequential code parallel code and testing and debugging.
as a comparison the oracle software engineer needed about hours to create a sequential scala program on the same specification.
he required about hours which happens to be the mean effort of our scala subjects for a parallel version out of this time he spent hours on testing and debugging hours less than our subjects mean .
programmer skills as determined in our pretest see section iv b influence how each subject ranks in terms of effort but the aggregated statistics balance out this effect because there are roughly equally many experts and beginners in both scala and java.
we conducted a multivariate analysis of variance manov a that analyzes the impact of java and scala skills beginner expert on the java and scala effort of each subject the analysis was applicable in our case because the box test on equality of covariance matrices was insignificant .
results show that expert skills lead to lower effort in comparison to beginners p .
for java expertise and p .
for scala expertise .
the analysis on how skills affect parallel implementation time also reveals a combined influence i.e.
that the interaction of java skills and scala skills together affects the parallel implementation time p .
by contrast it is remarkable to observe that java and scala skills do not have a significant influence on testing and debugging time p which suggests that this big difference has nothing to do with skills.
explanations for the difference in testing and debugging effort come from our interviews and code inspections.
one of the main reasons why such effort is higher in scala is because type system features that actually aim to make programming more productive turn out to make debugging more difficult.
in particular subjects complained that the automated type inference required them to spend more time to understand which actual type each object has when errors are encountered and they were unsatisfied with tool support on this issue.
in addition automatic object creation and copying was another feature that required more time to track errors and optimize performance.vi.
w hohas the first parallel program ?
java programmers were the first to have a working parallel program.
as a measurement of parallelization progress we tracked the week when each subject had the first working parallel program based on code inspections and interviews.
figure illustrates that all subjects submitted a parallel version by the deadline of the project.
in the week before the deadline an equal number of nine parallel scala and java programs worked.
week week week week week subjects 12scala java figure .
number of subjects who had a working parallel program in a particular project week week represents submitted programs after the week deadline .
the chart also reveals however that no programmer had a working parallel scala program until the third project week even though roughly a third of parallel java programs were already working in the second week.
interview data suggests that subjects needed time to figure out how to exactly take advantage of the functional style in their particular program.
the results also match the effort observations in section v. as soon the problems were overcome increases in working parallel scala programs were much steeper than for java.
this observation suggests that scala is powerful because everyone was still able to make the deadline but it takes time to understand how to exploit its power.
vii.
w hose code ismore compact ?
one of scala s claims is that a scala program needs fewer lines of code compared to a similar java program.
our results support this claim in our drc project context.
figure summarizes the lines of code loc of all scala and java programs as well as their number of characters excluding comments and blank lines.
scala has median loc mean and java median loc mean but the overall box and whiskers of scala tend towards lower values.
also no scala program is longer than loc.
the paired wilcoxon rank sum test on each subject s solution shows support p that scala code is more compact.
quantitative claims of the literature however seem overgeneralized and are not supported.
in this experiment scala programs do not have fewer lines of code compared with their java counterparts.
figure refutes thisclaim revealing only a median difference of loc .
and mean difference of loc .
.
also the claim that in extreme cases scala has times less code than java does not hold for our application.
the difference between extremes is loc in java versus loc in scala which is just .
times less.
an additional analysis on the number of characters shows similar trends that scala programs are more compact than java programs but the statistical support is weaker p .
however the medians of scala and java programs are farther apart for characters than for lines of code.
a final comparison baseline is a sequential and a parallel scala program that were developed under the same specifications by an oracle software engineer.
his sequential program has loc and characters.
his parallel program has loc only less than our subject s median loc which shows that his program is comparable to our subject s programs.
however his program has characters less than our best subject showing that even more compactness is possible in scala.
viii.
h owarefunctional and imperative styles used?
in a multi paradigm language like scala a question of interest is how subjects actually employ the functional style and imperative style in practice.
we answer this question by analyzing the code of each subject s scala project.
we also provide a comparison with the parallel projects delivered during the training phase parallel mergesort and parallel dining philosophers .
in particular we start by classifying key language constructs as belonging to either a typical imperative style or a functional style as suggested in the common scala literature .
for example var object array while for abstract import java etc.
indicate an imperative style.
by contrast constructs such as val list map filter flatmap foreach list concatenation list cons operator indicate a functional style.
we count the occurrences of all such constructs in each project and calculate the percentage of how many belong to the imperative class and how many belong to the functional class.
figure summarizes the results of this analysis for each subject in the study.
in the drc project code figure a shows that subjects use more than imperative style right half of the diagram and use more than functional style.
at the extremes one subject uses imperative style and one subject functional style.
the project outcomes are roughly similar for the projects of the training phase.
for parallel mergesort in figure b subjects use more than imperative style.
at the extremes one program uses imperative style and one with functional style.
using functional style in this context is natural because of the algorithm design.
for the dining philosophers in figurescala java400 1000loc a lines of code p value .
.
.
.
.
.
.
loc b cumulative distribution function javascala scala java20000 characters c number of characters p value .
.
.
.
.
.
.
characters d cumulative distribution function javascalafigure .
code compactness analysis of scala versus java.
a parallel drc projectdata subj09subj05subj13subj08subj11subj04subj07subj06subj02subj10subj12subj01subj03020406080100 b parallel mergesortdata subj04subj06subj05subj07subj02subj11subj09subj08subj01subj13subj03subj12subj10020406080100 c dining philosophersdata subj09subj11subj02subj13subj06subj12subj04subj10subj01subj08subj05subj07subj03 imperative functional figure .
percentage of functional and imperative programming styles used by each subject in scala.
c subjects use more than imperative style.
at the extremes one program uses imperative style and one functional style.
by contrast the sequential drc project program created by the oracle software engineer uses imperative style and functional style.
his parallel version shifts towards imperative style and functional style.
as a cross validation another oracle software engineer familiar with scala inspected each program in the drc project and counted how many methods employ a functional style or an imperative style classifying them based on his impression and experience.
the resulting functional imperative percentages are similar to those of our construct counting method in figure a .
the median divergence is which is not surprising due to the more coarsegranular and subjective counting.
as both approaches show a similar trend we stick in the following discussion to the more objective construct counting approach.
it is insightful to note that many subjects use functional and imperative style in a quite balanced way.
however certain individuals heavily prefer either the functional or imperative style.
this preference can be observed quite consistently for both the training projects and the parallel drc project.
however no subject entirely rejects eitherstyle.
the data shows that functional programming is indeed useful for realistic parallel programming projects.
ix.
w hohas the bestperformance ?
in this study sequentially executed scala programs are faster than their java counterparts.
in the parallel case however java programs have better scalability with higher speedups.
the top run times are similar for both languages.
a. setup all drc project programs are evaluated on a representative real chip layout that has been successfully taped out in the past.
the input file has rectangles that are distributed over subcells with a maximum hierarchy depth of .
the bounding box of the entire chip is166 594units.
we ensured that every program worked correctly on this input programmers were given the opportunity to fix problems after the deadline which caused just minimal code changes .
all applications are benchmarked on the following machines core machine intel xeon x5677.
this machine has a single chip architecture with cores hardware threads per core gb ram and runs redhat enterprise linux .
.
core machine sun sparc t3 .
this machine has a 4chip numa architecture with cores per chip and hardware threads per core gb ram and runs solaris .
the scala projects are compiled with scala .
.
and the java projects with java .
compiling all scala projects takes times longer than compiling all java projects e.g.
on the core machine it took seconds for scala and seconds for java .
b. measurements all developers made the number of parallel threads configurable from the command line.
figures a d summarize execution times and speedups with respect to the execution with one thread on each machine.
all parallel java and scala programs are executed with s. j. s. j. s. j. s. j. s. j. s. j. a runtime intel xeon cores language.
threadsruntime sec s. j. s. j. s. j. s. j. s. j. c speedup intel xeon cores language.
threadsspeedup over serial s. j. s. j. s. j. s. j. s. j. s. j. s. j. s. j. b runtime sparc t3 cores language.
threadsruntime sec 11196s.
j. s. j. s. j. s. j. s. j. s. j. s. j. d speedup sparc t3 cores language.
threadsspeedup over serialfigure .
performance overview of all scala and java project programs for a varying number of threads.
threads to test scalability.
on the core machine we added and threads because the hardware offers more parallelism.
to avoid bias each performance data point is an average of runs on each configuration we remark that the input size is large enough so speedups do not come from data that remains in the cache between runs .
each box plot summarizes performance data points one for every subject for each thread configuration and language.
c. results the measurements in figures a and b reveal that the scala programs executed with one thread are typically faster than the java programs median difference is sec on the 4core machine and sec on the core machine .
our controlled experiments carried our after the study have identified the stack implementation in java java.util.stack as a major cause for performance problems that did not exist in scala.
with increased thread count however java programs exhibit better scalability and higher median speedups than the scala programs.
on the core machine figure a shows that the best scala runtime is sec at threads subject cf.
fig.
.
the best java runtime is sec at threads subject .
however the median runtime over all thread counts is sec for scalaand sec for java which shows that the average scala program is faster than the average java program.
on the core machine figure b shows that the best achieved scala runtime is sec at threads subject .
the best java runtime is close with sec at threads subject .
the median runtime is sec for scala and sec for java again with scala being faster.
by contrast the oracle software engineer achieved with his parallel scala program the following results best time on the core machine was sec at threads speedup .
.
best time on the core machine was sec at threads speedup .
.
these numbers match very well the performance of the top subjects in our study.
d. does functional programming harm performance?
the top performers on the core machine subjects and used functional style in their programs.
on the core machine the top performers subjects and used functional style.
subject who used functional style i.e.
imperative style which was the least functional style of all scala programs ranked among the worst performers along with subjects and on both machines.
these empirical results contradict popular belief that a functional programming style harms performance.
at thesame time they provide support for the promise of multiparadigm languages by showing that it is possible to do automated performance tuning under the hood.
the results also show the need for a combination of functional style and imperative style as no top performer used functional style exclusively.
our data thus solidifies the ground for language designers compiler writers and tool developers to direct more effort into multi paradigm parallel languages.
x. p rogrammer survey feedback programmer feedback collected at the end of the study provides additional explanations for the observations made so far.
the majority of the questions had a five level likert scale ranging from strongly disagree to strongly agree .
due to space limitations in this paper we provide a summarized interpretation and mention the percentage of subjects in favor or against a statement aggregating agree and strongly agree as agree and disagree and strongly disagree as disagree .
scala type system.
letting the compiler implicitly derive the types of variables can become a problem during debugging.
while of the subjects agreed that this feature was helpful when writing code of the subjects agreed that it leads to programming errors.
learning and code understanding.
programmers found java programs easier to understand than scala programs say understanding java programs is easy compared to for scala .
java syntax was perceived to be easier than scala agree that java syntax is simple agree that scala syntax is simple .
only say that adapting to scala s programming model was easy compared to for java.
concerning parallelism there is an opposite perception agree that using java parallel constructs is easy compared to who say that using scala parallel constructs is easy.
also say that scala parallel construct usage was easy to remember while say that java parallel construct usage was easy to remember.
these responses suggest that scala in general is not perceived to be easier than java but that the subjects felt like there are advantages for the understanding of parallel programs.
tool support.
tool support for scala needs further improvements.
just one subject said that tool support for scala is good compared to for java.
only of subjects are satisfied with scala ide support compared to for java.
satisfaction.
the answers show that most programmers have a positive attitude towards scala and java.
of the subjects agree that it is a pleasure to use scala compared to for java.
there are who say they will use scala again and said they will use java again.
concerning the programming style agree that functional programming is frustrating while disagree.
perceived productivity.
programmers feel productive in both languages but complain about the scala documenta tion.
of subjects feel productive in scala compared to in java.
only one programmer however agrees that the available scala documentation is good compared to for java.
parallelism.
scala parallel programming with actors is perceived to be easier than shared memory programming in java which is supported by of programmers in scala versus in java.
however most programmers said they tried to postpone parallelization work in both languages in scala versus in java .
programmers also seem to have more problems in scala because say they were afraid of breaking a working program by using additional scala parallel constructs compared to for java.
errors.
race conditions are ranked the most important encountered error in both scala and java.
in addition debugging a multi paradigm language such as scala seems to be a major problem.
just of programmers say that debugging scala programs is easy compared to for java.
consequently we need better techniques and tools.
composition.
to handle complex programs of subjects say that scala programs are easy to compose from simpler parts compared to for java.
scala obviously offered advantages to handle data structures as of programmers agree that applying operations on data structures was more flexible in scala compared to in java.
xi.
c ode inspection and interview insights code inspections and interviews are valuable sources of evidence that we explore to improve our understanding of scala and java usage in the context of multicore programming.
due to space limitations we present an excerpt of results that we consider most relevant.
performance.
bad scala performance was often related to immutable data structures which were typically used by subjects to achieve thread safety .
for example some subjects with bad performance overlooked that update operations implicitly triggered object copy operations that could be expensive for data structures with many objects.
errors.
race conditions were the major cause for delays in progress for both scala and java.
typically there was one major defect that cost subjects most of their debugging time.
for example one subject reported that it took him hours to find a race condition involving access to a scala collection that concatenated two immutable data structures but only one hour to fix it.
another scala programmer spent of his project time on debugging to track a race condition that broke a fork join parallelization pattern.
in java some subjects overlooked that concurrent reading operations on shared state required synchronization assuming that only writing needed protection.
others accidentally used multiple lock objects where they should have used just one lock.
moreover others used flawed double checked locking patterns .
even though the training phase addressed these problems and all subjects were able to avoidthem on smaller tests it appears that programmers need to rely on tool support for more complex projects in practice.
functional style and type system issues.
the functional code of some subjects was difficult to understand because they used functions with side effects that were not obvious.
implicit type conversions were powerful in saving code but turned out to make code understanding more difficult and add errors.
when reviewing their own code subjects reported that they had to spend a lot of time understanding return types of functions especially for larger functions.
xii.
t hreats to validity every empirical study including this one has limitations.
to construct internal validity we have carefully chosen our application to be representative but results may differ for other applications and hardware.
based on our feasibility studies and experience we are confident however that most of the issues and problems encountered in this study will also be encountered in similar parallel applications.
the effects we measured became already statistically apparent for the number of subjects participating in our study though it is possible that other subjects will obtain different results.
the skill levels measured in our own pre tests revealed a balanced number of experts and beginners.
our study design aimed to reduce bias by using randomized assignment of subjects to projects training everyone in the same way and using counterbalancing to cancel out ordering and learning effects.
learning effects are roughly similar in both groups in the drc project difference of median effort of the scalasecond projects is about less than scala first for javasecond it is about less than java first.
we used several sources of evidence to reduce other bias.
all data including effort surveys and interviews were reported individually at regular intervals.
we cross checked all data for plausibility and compared student reports with the delivered code and interview statements.
student statements were honest and matched the overall profiles and their history.
to validate our comparisons and create external validity an oracle software engineer agreed to work on the same project in scala.
as discussed throughout the paper the results show that our data is within similar ranges as for an industry professional.
xiii.
r elated work functional and imperative languages have a long tradition.
an individual comparison is beyond the scope of this paper so we refer to for a survey in the context of concurrency.
loop recognition in java and scala has been compared in .
empirical studies in multicore software engineering however are scarce.
recent studies compare transactional memory and locks pthreads and openmp as well as mpi and openmp .
empirical studies directly comparing functional versus imperative programming on today s multicore platforms have received little attentionso far.
the study of on sml versus c done years ago was not conducted with a multi paradigm language on multicore and unfortunately had implementations that were difficult to compare however that study reports similar results to ours that subjects need more effort to test functional code as opposed to imperative code.
an experience report on using the ocaml functional objectoriented language on a server application has been published by but it is not a controlled study with several subjects.
the study of focuses on type systems and finds a null result for the use of static type systems on development time.
an experience report on how scala has been used at twitter appeared in .
other studies such as focus on the high performance computing domain where application requirements largely differ.
yet other studies such as analyze the impact of team level metrics on product level software metrics.
the work of compares programming languages based on a sequential application with respect to general metrics like performance or lines of code.
xiv.
c onclusion multicore hardware is ubiquitous and software engineering has to catch up.
multi paradigm languages such as scala promise to alleviate the tough parallel programming problems that developers are facing today by combining functional and imperative programming style.
our data reinforces that this direction deserves more investigation.
results show that scala code is indeed more compact than java code.
scala application performance is also comparable to java.
results contradict popular belief that a functional programming style harms performance.
the top performers wrote about half their programs in a functional style and the other half in an imperative style.
however the results also show the need for a combination of functional style and imperative style as no top performer used functional style exclusively.
with respect to effort this study refutes the claim that scala programs are faster to develop in comparison to java scala requires more effort and especially more testing and debugging effort.
scala programmers also lagged behind java programmers to obtain the first working parallel applications.
programmer feedback in this study does not show that scala programs are easier to understand than java programs but we track the reasons down to the more complex type system.
the type system aims to speed up coding and make programs more compact but significantly complicates the reading and debugging process.
we need to address these issues better in the future to make programming in the multicore era easier.