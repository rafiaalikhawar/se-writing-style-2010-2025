codebook discovering and exploiting relationships in software repositories andrew begel microsoft research redmond wa usa andrew.begel microsoft.comkhoo yit phang university of maryland college park md usa khooyp cs.umd.eduthomas zimmermann microsoft research redmond wa usa tzimmer microsoft.com abstract large scale software engineering requires communication and collaboration to successfully build and ship products.
we conducted a survey with microsoft engineers on inter team coordination and found that the most impactful problems concerned finding and keeping track of other engineers.
since engineers are connected by their shared work a tool that discovers connections in their work related repositories can help.
here we describe the codebook framework for mining software repositories.
it is flexible enough to address all of the problems identified by our survey with a single data structure graph of people and artifacts and a single algorithm regular language reachability .
codebook handles a larger variety of problems than prior work analyzes more kinds of work artifacts and can be customized by and for end users.
to evaluate our framework s flexibility we built two applications hoozizat and deep intellisense.
we evaluated these applications with engineers to show effectiveness in addressing multiple inter team coordination problems.
categories and subject descriptors d. .
management productivity h. .
user interfaces user centered design general terms management human factors keywords knowledge management social networking mining software repositories inter team coordination regular expression regular language reachability .
introduction coordination between software teams is a persistent problem in software engineering.
teams are dependent on one another for code apis features schedules bugs and documentation and require frequent and effective communication and cooperation to accomplish their tasks .
unfortunately poor execution in these areas is often a cause of inter team conflict.
the industry s move towards distributed development and increased use of technologymediated communication only exacerbates the problems .
we conducted a survey at microsoft to learn about coordinapermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.tion problems between software development teams.
we asked survey respondents which included software developers testers program managers to prioritize different information needs around inter team coordination.
the results which we present in this paper section show that engineers want new solutions for finding people discovering and tracking dependencies learning about the status of work items and learning the rationale behind changes.
what is most interesting about this list is that the majority of indicated needs are about discovering meeting and keeping track of people not just code.
software engineers are connected to one another in many ways directly through face to face interactions and communication technologies and indirectly through their shared work artifacts which are stored and maintained in software repositories.
tools that discover connections inside these repositories can help address many of the engineers coordination needs.
this is an approach used by many applications in the field of mining software repositories msr .
msr applications typically address one particular information need at a time for example assigning developers to bugs detecting duplicate bugs or recommending related changes for more applications see kagdi et al.
s survey .
most applications read data from only one or two software repositories and are built on very different infrastructures.
these characteristics make it to difficult to address multiple information needs with a single tool or framework.
previously in our icse nier paper we proposed the idea of codebook as a social networking web service that helps engineers to find and maintain connections with colleagues .
in this paper we contribute the design implementation and evaluation of the codebook framework.
on top of this we have built several applications which address the information needs identified by our survey.
codebook discovers transitive relationships between people code bugs test cases specifications and other related artifacts by mining any kind of software repository section .
it extensively supports multiple information needs with one data structure a directed graph andone algorithm regular language reachability .
codebook is designed to be customizable by local domain experts who have the most accurate knowledge about their teams information needs and software development practices.
these experts codify their knowledge into regular expressions that describe paths through the nodes and edges in the graph.
codebook takes care of the processing and optimization that is needed for efficient crawling analyzing and querying of the data even for information that is indirectly linked across repositories a task which is inadequately addressed in prior work.
the following examples illustrate how a domain expert can write paths to help teammates discover who works most closely together .which developer owns some piece of code?
regular expression person commits changeset modifies filerevision modifies code .which program manager wrote the specification for that code?
regular expression code mentionedby worddocument authoredby person .which program managers and developers on the team work together combines and ?
regular expression person commits changeset modifies filerevision modifies code mentionedby worddocument authoredby person the results of computing these paths are pairs of people code bugs test cases specs etc.
and are revealed to front end applications via web services.
to evaluate the flexibility of our framework to address the multiple information needs identified by our survey we have built two applications on top of codebook.
both were designed and evaluated in consultation with the microsoft software engineers the tools were created to help.
our first application is hoozizat section .
which addresses four of the top ten information needs identified in our survey.
hoozizat is a web based search portal that helps engineers find their counterparts who are responsible for a particular feature api product or service.
given some search terms hoozizat returns a set of related people work items code and files from the repositories.
next to each result is a second shorter list of the engineers codebook has found to be associates for people in the results or owners for other items.
the second application is deep intellisense section .
which addresses another information need from the top ten list.
deep intellisense was first built on a prior implementation of codebook.
it is a visual studio add in that shows a complete history of events for any program identifier that the user clicks on in the editor including code changes filed bugs and forum discussions developers had about the code in question.
in addition we specify two more applications addressing three more of the top ten information needs section .
of the remaining two needs one is addressed in previous work and one we keep for our future work.
.
contributions this paper makes the following contributions the results of a survey of inter team coordination needs for a variety of software team roles.
section anovel flexible customizable framework for mining software repositories which can support multiple applications with single data structure and algorithm.
section wedemonstrated the flexibility of our framework by building two applications which address five of the top ten information needs reported by our survey.
section in addition we specify two additional applications to address three more of the top ten needs.
section microsoft engineers evaluated the usefulness of our applications in satisfying inter team coordination information needs.
section .
inter team coordination survey we conducted an anonymous web based survey in order to learn how software engineers prioritize different information needs about inter team coordination.
in june inside microsoft corporation we sent an email invitation to developers testers and program managers consisting of a random sample of employees in each job role .
respondents were offered a chance to win a single gift certificate as incentive for completing the survey.
of the invitees responded to the survey.
the survey was divided into a demographic section and a section that asked respondents to check any number of inter team coordination information needs derived from previous studies and interviews with software engineers section .
.
these needs were organized into eight categories change notification finding dependents finding other people finding artifacts awareness of other teams artifact history work planning and social networking.
respondents were asked to pick the tasks that are most important to you and where if you had a new tool that could make this task easier it would have a big positive impact on your work day.
respondents chose an average of .
tasks sd .
.
the ten most indicated coordination information needs amongst microsoft software engineers are listed below along with the percentage of respondents who indicated that response and a reference to where they are addressed in this paper.
.
given a feature api product or service finding out who the most relevant engineers developers testers program managers operations leads etc.
are in order to contact them.
!hoozizat section .
.
finding an expert to talk to who knows a lot about a feature api product or service.
!related work .
given a feature api product or service from another team getting a list of servers directories and repositories where the related code bug reports work items specifications etc.
are located.
!future work .
finding out why a recent change was made e.g.
the related bug report work item specifications or conversation threads in discussion lists.
!deep intellisense section .
.
being notified that there is a recent change that affects my code or work items.
!
anxious for awareness section .
.
finding out who might be affected by a change i make to my code api.
!
who is using our code?
section .
.
finding out who owns some code or has ever worked on it in the past.
!hoozizat section .
.
finding out who owns a specification or knows the most about it.
!hoozizat section .
.
finding out which teams own the feature product or service i or my team depend on.
!hoozizat section .
.
finding out everyone outside my team who depends on my feature api product or service.
!
who is using our code?
section .
notice that the top two needs are about finding the people responsible or knowledgeable in a feature api product or service.
five more of the top ten needs are also about finding people !
this may be to report a bug to get programming advice to learn about a scheduling change to request a new feature or perhaps to ask for a code review.
through interviews with thirteen engineers having various job roles at microsoft we found that mostsql serveradtfspath analyzerad crawlertfs crawler ......web servicecode recognizerwork item recognizerassociate pathscontexts pathspeople recognizer...ownership paths...crawlers recognizerspath queriesweb portal your app window namefileeditviewtoolshelpnamecreate datemod.
datesummaryobject test objectobject test objectobject test objectobject test objectobject test objectobject test objectobject test objectobject test objectobject test objectobject test objectobject test object app plugins visual studio outlooksharepointsharepoint crawlermailing listsdiscussion crawlerfigure the architecture of the codebook framework.
any number of repositories may be crawled analyzed and stored as a graph in a sql server database.
a set of paths created by domain experts is compiled uploaded into the system and used to discover the paths that exist in the graph.
front end applications then use web services to query the database for relevant people artifacts and paths that answer its end users information needs.
ask their friends or colleagues to direct them to the people they are looking for.
if their friends do not know the answer they usually know someone else who may.
this process of asking friends often resembles a game of six degrees of separation.
the people they seek can be found in the electronic repositories used by software engineers in their daily work practice.
much of that information however is hidden inside of these repositories and difficult to discover behind opaque query interfaces.
even after information is dug up correlating it with information from other repositories is quite difficult .
our goal for codebook is to build a framework general enough to answer inter team coordination information needs directly without requiring users to conduct in depth investigations of raw data sources on their own.
in the next section we describe the codebook framework and discuss our solution for binding raw information together to discover and exploit the connections found within.
.
the codebook architecture the key data structure behind codebook is a graph of typed nodes which represent repository objects such as people changesets work items files and source code and typed edges which label the relationships of the nodes to one another such as commits bug assignments caller callee use def textual allusions .1codebook s algorithm then walks the graph from one set of interesting objects to another via the relationship edges and discover which objects are ultimately transitively connected to each other.
to ensure scalability it is important to not compute transitive closure blindly which would take o n3 time and produce many many useless results but instead focus on useful paths between pairs of nodes in the graph.
a path through the graph recognized by the regular expression is useful if by computing the path and its endpoint nodes it answers a question posed by a domain expert.
paths are defined by regular expressions whose alphabet is com1this graph model was initially proposed by venolia in a workshop paper .
codebook is built on a direct descendent of that model.posed of the node and edge labels in the graph.
we achieve scalability by using an o n2 all pairs regular language reachability algorithm combined with an optimization specific to software engineering that drastically reduces the number of nodes considered by the algorithm.
several steps are involved in creating a codebook graph useful for answering end users questions about their team s software development activities.
first as illustrated in figure a set of crawlers mine objects from various software repositories for example a revision control repository a work item database and an employee directory and store them in the database as nodes in the graph.
relationships between these objects are derived from structure metadata or textual allusions and stored in the database as edges in the graph.
paths defined by regular expressions are written by domain experts and compiled by codebook into state machines and uploaded into the database.
the path analyzer runs a regular language reachability algorithm on the database to compute and store the start and end nodes for each path recognized by the regular expressions.
to support search applications a full text index is created for each object in the graph and its surrounding context objects as defined by another set of regular expression paths .
finally codebook s data is exposed to applications via web services enabling many different front ends to answer end user questions with facts from codebook.
in the next few sections we elaborate on these steps to explain architecture and design rationale for the various parts of codebook.
.
crawlers codebook is designed to be an extensible system consisting of a family of crawlers for different kinds of repositories and various types of data.
as part of the prototypes we have built codebook can index source code repositories microsoft visual studio team foundation server tfs and a microsoft internal source code repository server work item databases tfs and a microsoft internal work item server employee directories active directory emails from public mailing lists outlook and exchange source code assemblies using .net reflection on dll assemblies and web sites sharepoint and discussion forums .
all nodes and edges which represent objects and the relationships between them are stored in the database with a start date end date last modified date and are uniquely named by their uri.
each object additionally contains a bag of words used for the search index consisting of a concatenation of several strings of metadata specific to each object type.
relationships are stored unidirectionally but paths may be defined to traverse edges in the forward or backward direction.
.
.
source code repository crawler the source code repository crawlers start at the first checkin and proceed until the most recent checkin.
for each checkin the list of changed files is enumerated and each file s differences are analyzed.
before and after snapshots of the edited files are parsed with a code analysis and compared.
whenever the differences overlap a source code element that element is considered to have been changed by the checkin.
we do not currently track code that is renamed or moved between files.
our codebook prototype can analyze c c c and vbscript source code.
all of the symbols i.e.
identifiers contained within including inside method bodies and field initializers are stored as nodes in a database table with metadata columns for symbol name fully qualified name kind e.g.
class field method operator etc.
programming language and nesting depth.
a distinct bag of words is also stored for the bodies of the definitions of symbols such asclass definitions and method definitions to enable scoped searches.
simple relationships between source code symbols such as lexicallyenclosed lexical enclosure superclass superclass and subclass links calls method calls assigns variable assignment names labels parameter parameter of a method or generic type and