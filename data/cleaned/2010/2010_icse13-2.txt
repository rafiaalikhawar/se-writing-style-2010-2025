aluminum principled scenario exploration through minimality tim nelson1 salman saghafi1 daniel j. dougherty1 kathi fisler1 shriram krishnamurthi2 1department of computer science wpi worcester ma usa 2computer science department brown university providence ri usa tn cs.wpi.edu abstract scenario finding tools such as alloy are widely used to understand the consequences of specifications with applications to software modeling security analysis and verification.
this paper focuses on the exploration of scenarios which scenarios are presented first and how to traverse them in a well defined way.
we present aluminum a modification of alloy that presents only minimal scenarios those that contain no more than is necessary.
aluminum lets users explore the scenario space by adding to scenarios and backtracking.
it also provides the ability to find what can consistently be used to extend each scenario.
we describe the semantic basis of aluminum in terms of minimal models of first order logic formulas.
we show how this theory can be implemented atop existing sat solvers and quantify both the benefits of minimality and its small computational overhead.
finally we offer some qualitative observations about scenario exploration in aluminum.
i. i ntroduction a. the uses and benefits of scenarios in many software engineering situations authors of specifications in a high level declarative language such as firstorder logic benefit from scenarios which are instances of the specification.
for instance a user might specify a filesystem against which a scenario generating tool would generate directory structures populated with files using invented names and contents .
when a size bound on scenarios is given or can be computed users can even obtain an exhaustive set of scenarios that is the number of scenarios is finite and they can all be generated.
tools such as alloy and margrave support scenario finding as their primary activity.
the concreteness of scenarios makes scenario finding a popular technique in software engineering.
software modeling helps system designers understand the consequences of their specifications determine missing constraints and explore alternatives.
specification languages like uml benefit from scenario finding to help bridge concrete and abstract representations.
scenarios are also useful for presenting counterexamples to verification tasks.
this is especially widely used when studying security policies where the concreteness helps envision attack configurations .
network modeling systems similarly use scenarios to visualize designs .
indeed tools like alloy use scenarios for both exploration and counter examples and also let users visualize scenarios in a variety of ways both textual and graphical.
in short scenarios are useful for many reasons they are concrete making it easy for users to grasp the output and map it to reality.
they do not require logical expertise to grasp.
thus a logic aware modeler working with a domain expert innocent of the joys of logic can present the output scenarios to the domain expert who should be in a position to understand them.
despite the above they are rigorous in that we can ascribe a precise semantics to them.
this makes it possible to employ them in formal settings.
because of this unique combination of characteristics scenarios are attractive software engineering tools.
b. scenarios formally because the term scenario has many informal meanings it helps to pin down our terminology.
a specification is a firstorder logic description written by a user e.g.
in alloy syntax.
this will include an alloy command to be run the result of running a command is a set of models.
here model has its traditional meaning from logic an assignment of values to variables that makes a formula true.
a model can be either propositional orrelational the latter being the structures appropriate to first order logic we need to refer to both because our specifications are first order but the underlying sat solver produces propositional models.
which one we mean will usually be clear from context but where necessary we will disambiguate.
finally a scenario is a relational model that is shown to the user.
it may thus have embellishments for compelling visual presentation such as atom names drawn from the specification.
nevertheless because its semantic content is just a relational model we will feel free to use scenario and model interchangeably whenever it is clear that we are in a non propositional context.
c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.232c.
principles of scenario exploration almost any interesting specification will have many scenarios in fact most first order logic specifications will have an infinite number of them.
but even when scenarios are constrained to be finite for example by the imposition of a size bound so that there are only finitely many distinct scenarios making scenario finding effective requires focusing on what scenarios to present in what order and how to help users navigate them.
there is some work on this for instance alloy tries to exclude isomorphic scenarios on the grounds that these present no additional information.
beyond that however alloy lets the underlying sat solver dictate the order of presentation which is effectively unordered and lets users go from one to the next again with no semantics associated with the order of presentation.
alloy does however hope to present scenarios in a sensible order.
as jackson s book explains instance is alloy s name for a relational model he tool s selection of instances is arbitrary and depending on the preferences you ve set may even change from run to run.
in practice though the first instance generated does tend to be a small one.
this is useful because the small instances are often pathological and thus more likely to expose subtle problems.
in other words alloy wishes to present the smallest scenarios first.
it is therefore natural to ask whether it is possible to force it to do so.
there are two difficulties we might encounter semantic can this be computed?
and performance can it be done efficiently?
each of which can be an obstacle.
d. contributions in this paper we present a theory for scenario exploration which has been implemented in a modified version of alloy called aluminum .
aluminum has the following features itpresents minimal scenarios.
thus when confronting a scenario given by aluminum a user can be confident that every tuple1in the scenario is necessary for that scenario to satisfy the specification s constraints.
when a user chooses to view another scenario aluminum ensures this too is minimal.
by browsing the initial set of scenarios the user can quickly obtain a sense of the scope of scenarios engendered by the specification.
aluminum allows the user to augment a scenario with a tuple.
here again aluminum computes a minimal scenario which includes any other tuples that may necessarily follow from the augmentation.
for a given scenario and specification aluminum computes the set of tuples consistent with that scenario that is consistent with the specification but not currently realized.
these suggest natural ways to augment the scenario and hence continue the exploration.
1we use tuple to represent an atomic truth or falsity instead of the standard logical factin order to avoid potential confusion with alloy s fact keyword.abstract sig subject sig student extends subject sig professor extends subject sig class tas set student instructor one professor sig assignment forclass one class submittedby some student pred policyallowsgrading s subject a assignment sina.forclass.tas or sina.forclass.instructor pred whocangradeassignments some s subject some a assignment policyallowsgrading run whocangradeassignments for fig.
.
a simple gradebook specification these features respectively comprise the core operations of aluminum generatemin augment and consistenttuples .
the precise specifications of these operations comprising the basic semantics of aluminum as a tool are given in theorem .
exploration with minimal scenarios results in a different form of traversal of the space of scenarios than what alloy currently provides.
putting the user in control of exploration is perhaps the chief merit of aluminum s approach section ii .
we present the theory section iii and explain how we implement it atop alloy section iv including a brief discussion on the impact of symmetry breaking on minimality.
we show that users incur minimal performance penalty section v and finally section vi examine the user experience that ensues from the minimality driven approach.
ii.
a w orked example figure provides the alloy specification for a simple gradebook.
there are two kinds of users called subjects in the specification student and professor.
a class has one professor and a set of students designated as tas.
an assignment is submitted by a set of students for a specific class.
the gradebook specifies a policy on who may grade assignments specifically professors and tas may grade assignments in their associated classes.
a. scenario selection in alloy vs. aluminum the specification s run command asks for scenarios of who can grade assignments.
both alloy and aluminum present one scenario at a time users may request another scenario by clicking the next button.
aluminum produces a three initial scenarios in response shown in figure .
in contrast figure shows the first three scenarios that alloy produces out of over .
the order in which each of alloy233fig.
.
gradebook scenarios from aluminum fig.
.
gradebook scenarios from alloy and aluminum produces scenarios is non deterministic the scenarios in figure are representative of what we got in several independent runs.
space limits restrict the size of these images but their general shape will tell the story.
aluminum s scenarios illustrate three conditions under which one can grade an assignment the subject is a ta and also the submitter of the assignment the subject is a ta for the class but not the submitter of the assignment the subject is a professor for the class.
each of alloy s first three scenarios illustrate the first condition but with additional elements that are not necessary to satisfy the specification such as two additional classes .
some of alloy s scenarios not shown include additional tuples such as a second student submitter of some assignment.
while these extra elements and tuples can exist in a satisfying scenario they are not necessary .
aluminum in contrast weeds out all unnecessary tuples focusing instead on the essence of the scenario.
for the particular scenarios that alloy generated on this example one might posit that minimality is about the domain bounds used in the analysis had we run the gradebook specification with tighter bounds class professor assignment and students alloy would produce fewer and tighter scenarios.
minimality is however about more than just setting good domain bounds for two reasons.
first the bounds only control the number of elements not the number of tuples even with tight bounds non minimal scenarios can contain unnecessary tuples.
second by setting bounds too tight a user can fail to learn about potentially dangerous scenarios and gain inappropriate confidence in their specification.
thus finding good bounds is often a process of trial and error minimal scenarios eliminate unnecessary elements and tuples automatically without placing that burden on the user.b.
partitioning the scenario space each of aluminum and alloy embodies a choice of which scenarios to present.
since both tools build upon externallydeveloped sat solvers their choices are constrained to principles that can be encoded in the propositional formulas on which sat solvers operate.
within this constraint alloy attempts to partition the scenario space into equivalence classes based on isomorphism and presents one scenario per class as we discuss in more detail in sections iv and v but chooses the scenario indiscriminately.
aluminum instead organizes scenarios into a partial order based on the tuples they contain and presents the scenarios that are lowest in that ordering.
figure illustrates this fundamental difference between alloy and aluminum.
the black dots in a are scenarios of a specification.
the blobs group them into equivalence classes.
part b shows how alloy might present this space the red dots are representatives of each class alloy presents one representative each and the other members of the class hollow dots are not presented.
however there is no ordering to how these representatives are presented as we have already seen a fairly complex scenario could precede a very simple one.
part c shows what aluminum does we describe part d in section ii c. it groups scenarios and picks minimal representatives to show.
the next button shows only minimal scenarios but aluminum s augmentation command described in section ii c enables users to find scenarios the gray dots with selected tuples added.
as part c suggests augmentation might lead the user to scenarios the gray circles that are isomorphic to ones that have been seen previously.
we believe showing these scenarios is more sensible than refusing to show a user 234fig.
.
how aluminum and alloy organize the space of scenarios.
each circle is a scenario and blobs represent equivalence classes.
red circles are those obtained using the next button.
hollow circles are those never shown to the user.
arrows represent augmentation operations and gray circles are scenarios presented after exploration.
a shows a set of scenarios grouped by isomorphism.
b shows alloy s unordered presentation of representatives.
c shows aluminum s output presenting minimal scenarios and augmentation.
d shows a cone of scenarios.
constructed scenario just because symmetry breaking in the original generation procedure would have suppressed it.
nevertheless unreachable isomorphic scenarios are still excluded since the user cannot get to them through any operations this therefore shrinks the exploration space.
c. exploration via augmentation aluminum views minimal scenarios as a starting point for understanding specifications but not as sufficient.
alloy users commonly sanity check specifications with a simple query that says show me satisfying scenarios .
the following query does this for the gradebook specification run some class for aluminum produces only one minimal scenario for this query it contains a single class and a single professor who is the instructor for that class.
this is a sufficient scenario because the gradebook specification does not require students tas or assignments in a class.
sanity checking however requires illustrating some of the optional components of a specification.
these optional components are not however independent any gradebook scenario that contains an assignment for example must also contain a student who submitted the assignment.
a systematic technique for exploring the space of scenarios should help the user understand these dependencies.
aluminum provides two operations that support systematic exploration of the scenario space.
consistent tuples suggests avenues for exploration by producing a list of all additional tuples that are consistent with the current scenario and hence can be added to the scenario .
augment adds a user selected tuple to the current scenario producing a list of minimal scenarios that include both everything in the current scenario and the new tuple.
returning to our gradebook example for the scenario showing just a single class and professor aluminum indicates that the following additions are consistent student professor class assignment class.tas class.tas class.instructor class.instructor assignment.forclass assignment.forclass assignment.submittedby new assignment new subject each description string contains a relation name and enclosed in square brackets a list of atoms.
if an atom already exists in the current scenario it appears by the name given it in the visualizer e.g.
class orprofessor .
if the atom is not present in the current scenario its descriptor is new along with its internal name class subject etc.
.
visually it helps to imagine the cone of scenarios that extend and are consistent with a given scenario.
this is shown in part d of figure .
aluminum s consistent tuple computation shows all the tuples that can inhabit this cone thereby mapping out the cone s landscape.
these tuples may not all however necessarily co habit a tuple appears in this list if it exists in some satisfying scenario that extends the current one but the presence of some can exclude others due to specification constraints or domain size bounds.
suppose a user augments the scenario with the following assignment.forclass there is only one extended scenario and it includes a student as well as an assignment.
since aluminum produces only minimal scenarios even under augmentation this tells the user that every addition to this model which adds an assignment requires adding a student a form of deductive reasoning that alloy does not provide.
asking aluminum for the consistent tuples for this new scenario suggests some potentially interesting situations class.tas assignment.submittedby ... specifically the student who authored the assignment could also be a ta in the class and more than one student is allowed to submit the same assignment.
each of these may suggest additional queries to a user.
aluminum also implements a backtrack button so users can undo augmentation and continue exploration from a previous scenario.
235aluminum s combination of minimal scenarios and exploration helps users understand the implications of their specifications in a lightweight manner.
alloy in contrast does not offer an exploration mode much less one based on minimality .
if a user wants to see classes with assignments she must create a new runcommand that adds the assignment constraint.
the resulting scenarios may include unnecessary truths determining the status of each is left to the user to sort out typically by continuing to refine the query.
furthermore each change is followed by a new execution which may start the user out from a completely different initial scenario.
by supporting interactive exploration we feel that aluminum a reduces context switching b reduces exploration clutter in the specification and c helps users stay with the same example which can be lost when executing afresh.
d. tuple provenance because of the semantics of aluminum when confronted with a particular scenario a user can understand the provenance of each tuple in it it is present because it is either a part of a minimal scenario or b chosen by a user for augmentation or c the consequence of a user augmentation.
while we have not modified alloy to present this information explicitly this could easily become part of the user interface.
iii.
f oundations models for first order languages a relational model for a language lis a mapibinding each relational variable roflto an actual set theoretic relation i r .
iffis sentence oflandiis an model making ftrue we sometimes say that isatisfies f or iwitnesses f and writeij f. iftis a set of first order sentences we say that iis a model for t orisatisfies orwitnesses tifisatisfies each sentence of t and we writeij t. as jackson notes one can view alloy s specification language as first order logic or relational algebra.
a tuple over a modeliis given by a n ary relation rand a sequence of elements ofisuch that is ini r .
ifi1andi2are models we define i1 i 2to mean that for each relation r i1 r i r we writei1 i2if for at least one rthe inclusion is strict.
the cone of a modeli isfi0ji i0g intuitively this is the set of extensions of i such an extension can add elements and tuples but never lose information.
this relation is a partial order on the set mod t of models for any t we say that a model iisminimal fort if i ij tand ii there is no i0j twithi0 i. ift has any finite models then it has at least one minimal model in general of course tmay have several minimal models.
we will often consider models up to isomorphism models iandi0are isomorphic if they can be made identical by renaming of elements.
we write i1 i 2to mean that for somei0 1andi0 2isomorphic toi1andi2respectively i0 i0 .
models for propositional languages a propositional model for a given set of atoms for propositional logic is a function mfrom atoms tof0 1g quaffalse trueg .ifm1andm2are propositional models we define m1 m 2to mean that for each propositional atom p m1 p m p writem1 m2if for at least one p m1 p m2 p .
analogously with relational models the relation is a partial order on the set of models for any setbof propositional formulas and determines the obvious notion of cone over a propositional model.
a propositional modelmis minimal for a set bof propositional formulas if it satisfies bandbhas no satisfying model m0 m finite relational models can be encoded as propositional models using standard techniques.
indeed alloy s engine kodkod translates users relational specifications to the propositional world and the results back again for output.
propositional encoding of specifications alloy converts a specification into a constraint represented as a relational algebra expression encoding the axioms and declarations of an alloy module together with the predicate for which we seek a relational model.
kodkod translates such a constraint into following the language of a kodkod problem which is a triple consisting of a universe of elements a set of lower and upper bounds for each relation symbol in the language and a relational formula.
any kodkod problem pgives rise to a formula b p of propositional logic.
so given an alloy specification s we eventually arrive at a propositional logic formula b ps .
moreover if we remove the secondary variables that kodkod introduces when translating to conjunctive normal form kodkod also gives us a one to one correspondence between relational models of psand propositional models of b ps .
the orderings defined above for relational and propositional models are preserved under this mapping.
theorem states our correctness claims about aluminum.
space limitations prevent us from including proofs but they follow naturally from the algorithms in section iv.
theorem .
completeness of generation let sbe an alloy specification.
procedure generatemin generates a complete set of minimal models for sup to isomorphism.
that is for any modeliwitnessing s generatemin will produce some minimali0such thati0 i. correctness of augmentation let ibe an model witnessing specification sand let fbe a tuple overi.
procedure augment either returns a model i0such that i i i0 ii i0satisfies sandf and iii is minimal with respect to these properties or detects failure if there is no such model.
completeness of exploration let iandi each witness specification s withi i .
there is a finite sequence of augment steps leading from itoi .
completeness of consistency checking let ibe an model witnessing specification s. procedure consistenttuples returns the set of those tuples fsuch that there is at least one model i0withi i0withi0 witnessing sandf.236algorithm minimize .
input a model mand formula pwithmj p output m0 a minimal model for p repeat m0 m m reduce m until m m0 cannot minimize any more algorithm reduce .
input model mand formula b with mj b output m0 m withm0j b if one exists otherwise m c vf pjpis false in mg d wf pjpis true in mg ifthere is a model nwithnj b d cthen return n else return m mis minimal iv.
i mplementation aluminum modifies both the alloy analyzer s user interface and underlying constraint solver kodkod .
aluminum s user interface is based on that of alloy the user submits an alloy specification kodkod translates the associated constraint to a propositional formula the sat solver is iterated to produce propositional models and these are eventually translated to scenarios by kodkod and rendered by alloy.
the differences between alloy and aluminum lie in the nature of the iterator to produce the initial suite of scenarios and the facility for user controlled exploration of the space of scenarios.
this section outlines the algorithms underlying the functionality specific to aluminum.
a.generatemin the sequence of models produced by aluminum as a result of the initial execution of the specification is produced by procedure generatemin .
given a kodkod problem p aluminum initializes an iterator by invoking a sat solver sat4j in our implementation to return a model mofp mandp are then passed to the minimizer.
minimization consists of repeated calls to algorithm reduce algorithm until there is no change see algorithm .
minimization is not a deterministic process because a given model can lie in the cone of several different minimal models as figure c and d show .
this non determinism manifests itself in practice in aluminum because the output of reduce depends on choices made by the sat solver.
after each minimal model mis generated we of course want to ensure that mis excluded from future generation.
it is straightforward to filter the output to ensure this as alloy does.
in our setting the problem is somewhat more subtle since the process of minimization will of course return identical results from quite different models.
but in fact this is an opportunity for a significant optimization.
after each output modelmis computed aluminum adds to the current problemalgorithm consistent tuples .
input model mand formula b with mj b output the atoms false in mconsistent with mandb c vfpjpis true in mg d wfpjpis false in mg r repeat ifthere is a model nwithnj b d cthen f fpjn p andm p 0g r r f d d f until no change in r return r the disjunction of the negations of the atoms true in m. this ensures that no subsequent model from the sat solver will be in the cone ofm.
this is a sound pruning of the model space sincemrepresents each model in its cone.
suppressing isomorphic models.
we have seen how to suppress the generation of identical models but eliminating isomorphic models is much harder.
kodkod tries to avoid generating isomorphs by adding symmetry breaking formulas to the input.
this is necessarily heuristic since no polynomial time algorithm is known for detecting isomorphisms of relational models.
unfortunately symmetry breaking does not interact well with minimization.
for intuition consider part c of figure in which two non isomorphic models each lie in the cone of the rightmost minimal model in the equivalence class with three entries.
when these models are minimized they may return the same minimal representative depending on choices made by the sat solver.
it is even the case that if aluminum were to use the same mechanism as kodkod for symmetry breaking it could incorrectly conclude that a non minimal model is minimal.
aluminum thus uses a slightly different heuristic for symmetrybreaking.
space considerations preclude a detailed discussion of the issue here but one consequence is that alloy sometimes eliminates more isomorphic models than aluminum.
b.augment a key observation is that augmenting a model of a specification by a tuple is merely an instance of the core problem of minimal model generation the result of augmentation is precisely an iterator over minimal models of the specification given by the original specification along with the tuples of the given model plus the new tuple.
one detail is important for performance.
letting bbe the conjunctive normal form of the original specification and ap the boolean variable representing the augmenting tuple a the input for model generation is b fpjm p 1g fapg.
the point here is that since the augmentation is performed entirely at the propositional level aluminum avoids the cost of re translating from relational to propositional logic.237c.consistenttuples to aid the user in deciding how to explore the space of scenarios by augmentation aluminum can determine in advance which new tuples can be consistently added to a given scenario in the context of a given specification.
if mis a model ofb we say that atom disconsistent withmandbif there is a model of banddextending m. aluminum s procedure for computing consistent tuples modulo translation to and from the propositional level is given in algorithm .
if two unused atoms occur in the same position in otherwise identical consistent tuples aluminum presents only one such.
for instance suppose that following two augmentations are consistent student student that is there are two unused subject atoms and either of them may be instantiated into student.
in this case aluminum will only present the first.
since minimal models often have many unused atoms this filtering can substantially reduce the number of consistent tuples shown.
v. n umeric evaluation we now compare aluminum to alloy numerically.
we first study how the resulting scenarios compare mathematically to those produced by alloy and then explore how long it takes to compute these minimal scenarios.
we conduct our experiments over the following specifications with a short name that we use to refer to them in the rest of the paper.
in the tables where a file contains more than one command we list in parentheses the ordinal of the command used in our experiments.
the following specifications are taken from the alloy distribution addressbook 3a addr birthday bday filesystem file genealogy gene grandpa gpa hanoi hanoi iolus iolus javatypes java and stable mutex ring mutex .
in addition we use three independent specifications gradebook grade which is defined in figure and enhanced with two more commands run whocangradeassignments for 3but assignment class professor student and run some class for continue cont the specification of a conference paper manager from our prior work.
the authentication protocol of akhawe et al.
s work auth a large effort that tries to faithfully model a significant portion of the web stack.
a. scenario comparison we consider a set of satisfiable specifications for which we can tractably enumerate allscenarios.
this lets us perform an exhaustive comparison of the scenarios generated by alloy and aluminum.
the results are shown in figure .
the first data column shows how many scenarios alloy generates in all.
this number represents one more than the number of times the user can press the next button.
becausethe alloy user interface suppresses some duplicate scenarios this is a smaller number than the number of scenarios produced by kodkod we present this smaller number.
the second column shows the corresponding number of minimal scenarios presented by aluminum the red dots in figure c .
the third column shows how many scenarios it takes before alloy has presented at least one scenario in the cone of every minimal model from aluminum.
because a given scenario can be in the cone of more than one minimal scenario the number of scenarios needed for cone coverage may in fact be fewer than the number of minimal models.
an important subtlety is that an alloy scenario may not fall in a new cone but may be isomorphic to one that does i.e.
alloy may have produced a hollow circle in figure .
we use kodkod s symmetry breaking algorithm to try to identify such situations and credit alloy accordingly.
the fourth column shifts focus to minimal scenarios.
if a user is interested in only minimal scenarios how many scenarios must they examine before they have encountered all the minimal ones up to isomorphism detection ?
this column lists the earliest scenario as an ordinal in alloy s output starting at when alloy achieves this.
this number does not however give a sense of the distribution of the minimal scenarios.
perhaps almost all are bunched near the beginning with only one extreme outlier.
to address this we sum the ordinals of the scenarios that are minimal.
that is suppose aluminum produces two minimal models.
if the second and fifth of alloy s models are their equivalents then we would report a result of .
the fifth and sixth columns present this information for alloy and aluminum respectively.
the sixth column is technically redundant because its value must necessarily be n where nis the number of aluminum models we present it only to ease comparison.
to ensure understanding let us examine two rows in detail addr aluminum finds two minimal models.
the very first alloy model is in both their cones so the cone coverage value is lower than the number of minimal models.
such a model clearly cannot itself be minimal indeed since the minimal scenario coverage requires models and the alloy ordinal sum is the 3rd and 5th alloy models must have been equivalent to aluminum s minimal ones.
grade aluminum finds just one minimal model.
thus any model found by alloy including the first one must be in its cone so the cone coverage value is .
however it takes alloy another models before the minimal one is found.
we can now see aluminum s impact on covering the space of scenarios.
even on small examples such as grade there is a noticeable benefit from aluminum s more refined strategy.
this impact grows enormously on larger models such as java and grade .
we repeatedly see a pattern where alloy gets stuck exploring a strict subset of cones producing numerous models that fail to push the user to a truly distinct space of scenarios.
even on not very large specifications recall that grade is presented in this paper in its entirety it often takes hundreds of nexts before alloy will present a scenario from238spec.
models models cone min.
scenario ordinal sum ordinal sum alloy aluminum coverage coverage alloy aluminum addr bday bday gene gpa grade grade grade hanoi hanoi java fig.
.
alloy s coverage of minimal models and their cones.
spec.
aluminum alloy d avg avg bday .
cont .
cont .
file .
iolus .
mutex .
fig.
.
relative times ms to render an unsatisfiable result.
a cone it has not shown earlier.
the real danger here is that the user will have stopped exploring long before then and will therefore fail to observe an important and potentially dangerous configuration.
in contrast aluminum presents these at the very beginning helping the user quickly get to the essence of the scenario space.
the gene specification presents an interesting outlier.
the specification is so tightly constrained that alloy can produce nothing but minimal models !
indeed and equivalently it is impossible to augment any of these models with additional tuples as we will see in figure .
one important caveat is that these experiments were conducted with one particular sat solver using alloy s default parameters.
different sat solvers and parameters will likely have different outcomes and studying this variation is a worthwhile task.
nevertheless the above numbers accurately represent the experience of a user employing alloy version .
in a state of nature.
b. scenario generation having examined the effectiveness of aluminum we now evaluate its running time the space difference is negligible .
all experiments were run on an os x .
.
.26ghz core duo 4gb ram machine using sat4jversion .
.
.v20120709 .
we handled outliers using one sided winsorization at the level.
the times we report are obtained from kodkod which provides wall clock times in milliseconds ms .
all experiments were run with symmetrybreaking turned on.
numbers are presented with rounding but statistical computations use actual data so that values in those columns do not follow precisely from the other data shown.spec.
aluminum alloy d avg n avg n addr .
auth .
bday .
bday .
cont .
file .
gene .
gpa .
grade .
grade .
grade .
java .
hanoi .
hanoi .
fig.
.
relative times ms per scenario minimal in aluminum .
every process described below was run thirty times to obtain stable measurements.
to measure effect strength we use cohen s d .
concretely we subtract alloy s mean from that of aluminum and divide by the standard deviation for alloy.
we use alloy s in the denominator because that system is our baseline.
because aluminum slightly modifies kodkod to better support symmetry breaking we begin by measuring the time to translate specifications into sat problems.
across all these specifications aluminum s translation time falls between and that of alloy i.e.
our modification has no effective impact.
the absolute translation times range from 5ms for gradebook to 945ms for auth .
we use commas as separators and our decimal mark is a point.
thus 945ms .945s almost seconds.
though our focus is on the overhead of minimization in the interests of thoroughness we also examine unsatisfiable queries.
figure shows how long each tool spends in satsolving ignoring translation into sat and then presentation to report that there are no scenarios.
the d values show that in some cases the time to determine unsatisfiability is much worse in aluminum.
it is very important for the reader to remember that the d value is measuring the effect size notthe ratio of average times!
thus a d of almost 166239still results in only a .1x increase in time.
the effect is because of the way aluminum and alloy handle symmetrybreaking aluminum splits the formula produced by kodkod into two parts one representing the specification and query and the other capturing symmetry breaking whereas alloy keeps the formulas conjoined.
the conjoined formula offers greater opportunities for optimization which the sat solver exploits.
nevertheless we note that even in some of the large effects theabsolute time difference is relatively small.
for satisfiable queries we calculate the time to compute the first ten scenarios equivalent to clicking next nine times which we feel is a representative upper bound on user behavior.
when the tool could not find ten scenarios the ncolumn shows how many were found and the average is computed against this ninstead .
when queries are satisfiable aluminum s performs well compared to alloy.
first the overall running time is small for both tools so even large effect sizes have small wallclock impact.
indeed in the most extreme case aluminum takes only about .
seconds longer for a total time of .
seconds surely no user can read and understand a scenario in less time than that so aluminum could easily pre compute the next scenario.
second in many cases aluminum offers many fewer scenarios than alloy helping users much more quickly understand the space of models.
finally the time taken by kodkod to create the sat problem can be vastly greater than that to actually solve it which suggests that a more expensive sat solving step will have virtually no perceptible negative impact on the user experience.
we observe two outliers in the data.
first the time for minimization for auth is very significant.
for this specification we found that the number of extraneous tuples eliminated during minimization is on average.
this shows a direct trade off .
seconds in computing time for a possibly great impact on user comprehension.
second the standard deviation for alloy on hanoi looks enormous relative to the mean.
this is because kodkod is producing a second duplicate model which in fact is discarded by the alloy user interface very quickly.
this results in datapoints that take a long time for the first solution but close to zero for the second.
we also examine the time taken by aluminum s exploration features how long it takes to compute the consistent tuples and how long it takes to augment a scenario.
since the complete space of models is enormous we restrict attention to the first set of scenarios produced by aluminum i.e.
the red circles in the bottom row of figure c .
figure shows the consistent tuples times.
we compute up to ten scenarios five in the case of auth and for each of these we determine the number of consistent tuples.
the first column indicates the number of consistent tuples found averaged over the number of minimal scenarios i.e.
consistent tuples per model .
the zero values are not errors they arise because the specifications are sufficiently constrained that there is no room for augmentation beyond the initial scenarios.
the next two columns show how long it took to compute the number of consistent tuples.
these numbers are clearly very modest.
authspec.
cons.
cons.
tup.
time aug. tupls avg time addr auth bday bday cont file gene n a gpa n a grade grade grade java hanoi n a hanoi n a fig.
.
times ms to compute consistent tuples and to augment scenarios.
is the exception it produces models with on average over consistent tuples more than can be explored by hand.
implementing strategies for helping the user in such situations is an interesting topic for future work.
the last column shows how long on average it takes to augment a scenario with a consistent tuple backtracking between each augmentation .
the n a s correspond to specifications that have no more consistent tuples and hence cannot be augmented.
this too takes very little time.
vi.
q ualitative impressions we have run aluminum on many representative uses of alloy beyond those reported in section v. here we report on qualitative impressions.
instead of dwelling on successes we focus on those aspects of aluminum that are interesting potentially controversial and certainly deserving of future work such as rigorous user studies .
verification versus realization there is an informal distinction between two modes of exploring a specification verification where the user has a property to check and whose failure yields a counter example versus realization in which a user wants to see which scenarios are compatible with a specification.
minimality and orderly growth appear especially useful for the former where the pithiest counterexample is often the most useful but perhaps less so for the latter since the scenarios presented are less likely to surprise the user.
adding some of the other features discussed below would ameliorate this weakness.
negative information aluminum s consistent tuple enumeration does not list what cannot become true.
this negative information can be vital in comprehending scenarios and should ideally be incorporated into the exploration process.
random exploration using exploration an aluminum user can eventually reach any scenario that alloy would have generated theorem .
but our experience suggests that there is an important benefit to alloy s more random generation of scenarios richer scenarios raise situations that a user didn t think to ask about and can thus be insightful and thought provoking.
perhaps aluminum could add a surprise240me!
button that presents a random non minimal model to encourage adventitious discovery or alloy could be enhanced with aluminum s minimization and exploration facilities .
transition systems and framing conditions framing conditions describe what should not change between states of a system.
we found aluminum good at highlighting some missing frame conditions.
for instance in an address book as in if the add predicate fails to mention that all existing entries must be retained the book will contain only the entry just added.
thus two consecutive add operations will starkly illustrate the absence of a frame condition.
this absence may be masked by the non minimal models of alloy.
however frame conditions express not only lower bounds what must remain but also upper bounds what must not be added.
in the absence of upper bounds a scenariofinder is free to add extra domain elements or relational tuples.
alloy will frequently present just such models alerting the user to the lack of appropriate framing.
in contrast aluminum is guaranteed to excise such superfluity!
these superfluous entries are actually still present in the consistent tuples but we believe it is too difficult for users to find them there.
vii.
r elated work logic programming languages produce single least models as a consequence of their semantics.
because user specifications are not limited to the horn clause fragment aluminum can offer no such guarantee.
the more general notion of minimal model in this paper has already been used in specifying the semantics of disjunctive logic programming and of database updates and in non monotonic reasoning especially circumscription .
the development of algorithms for the generation of relational models is an active area of research.
the two most prominent methods are mace style which reduce the problem to be solved into propositional logic and employ a sat solver and sem style which work directly in first order logic.
the goals of these works are mostly orthogonal to ours since their concern is usually not the exploration of the space of all models of a theory.
generation of minimal models specifically usually relies on dedicated techniques often based on tableaux e.g.
or hyperresolution e.g.
.
since we are more concerned with exploration as an enhancement of established software design methodology we made a choice to work with the sat solver technology bundled with a tool alloy designed for presenting models.
koshimura et al.
uses minimality of propositional models to optimally solve job scheduling problems.
our minimization algorithm is essentially identical to theirs.
however their algorithms do not make use of symmetry breaking nor do they address augmentation or consistent tuple generation.
janota offers an algorithm to compute all minimal models of a formula once one is computed and shows how to compute a minimal model by modifying a sat solver satisfying a certain technical property.
our technique works with unmodified solvers it would still be interesting to compare the performance of janota s method with ours.
anotherinstance of changing the solver would be to use a specialized solver like max sat.
we opted to use an ordinary sat solver sat4j.core because using max sat would have involved significant changes that might have introduced confounding factors that would complicate a side by side evaluation.
the goals of the cryptographic protocol shapes analyzer are closely aligned with ours.
in analyzing protocols it too generates minimal models.
however its application domain and especially algorithms are quite different from ours.