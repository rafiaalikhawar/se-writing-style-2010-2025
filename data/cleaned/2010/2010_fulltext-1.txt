universit y of n ebraska l incoln digitalcomm ons u niversit y of n ebraska l incoln cse confe rence and w orkshop p apers comput er science and e ngineering departme nt of cassandra p roactive c onflic t m inimi zation through o ptimized t ask s chedulin g bakhtiar khan k asi university of n ebraska lincoln bkasi c se.unl.edu anita sarma university of n ebraska lincoln asarma c se.unl.edu follow thi s and a dditional w orks at igitalcommon s.unl.edu c seconfwork this article i s brought to you for f ree and ope n access by the c omput er science and e ngineering departme nt of a t di gitalcommon s u niversity of nebraska l incoln.
it has be en accepted for inclusion in c se confe rence and w orkshop p apers by an author ized admini strator of digitalcommon s u niversity of n ebraska l incoln.kasi bakhtiar khan and s arma anita cassandra proactive confl ict m inimi zation thr ough o ptimized task s cheduling .
cse co nference and w orkshop papers.
.
igitalcommon s.unl.edu c seconfwork 275cassandra proactive conflict minimization through optimized task scheduling bakhtiar khan kasi and anita sarma computer science and engineering department university of nebraska lincoln lincoln ne usa bkasi asarma cse.unl.edu abstract software conflicts arising because of conflicting changes are a regular occurrence and delay projects.
the main precept of workspace awareness tools has been to identify potential conflicts early while changes are still small and easier to resolve.
however in this approach conflicts still occur and require developer time and effort to resolve.
we present a novel conflict minimization technique that proactively identifies potential conflicts encodes them as constraints and solves the constraint space to recommend a set of conflict minimal development paths for the team.
here we present a study of four open source projects to characterize the distribution of conflicts and their resolution efforts.
we then explain our conflict minimization technique and the design and implementation of this technique in our prototype cassandra.
we show that cassandra would have successfully avoided a majority of conflicts in the four open source test subjects.
we demonstrate the efficiency of our approach by applying the technique to a simulated set of scenarios with higher than normal incidence of conflicts.
index terms collaborative development coordination collaboration conflicts task scheduling i. introduction conflicting changes in parallel software development occur frequently despite advances in communication and coordina tion environments .
conflicting changes typically occur because of breakdowns in an understanding of how one s work fits with others changes.
for example two developers can edit the same file concurrently direct conflict or an interface that was presumed to be stable is changed without appropriate noti fications to developers using it indirect conflict the state of practice aims for conflict resolution.
configu ration management cm systems allow each individual to check out files and work on their changes in local workspaces that are periodically synchronized with the repository.
while such a loose synchronization protocol enables rapid parallel development it also allows developers to inadvertently make conflicting changes.
automated diff and merge techniques help in resolving direct conflicts but often require manual intervention .
resolution of indirect conflicts is not currently supported.
our analysis of four popular open source projects reveals that conflicts are a regular occurrence.
in the projects analyzed merge conflicts ranged from .
to .
.
of the clean merges .
to .
had build failures and .
to of correct builds incurred test failures.
resolving these conflicts took substantial effort typically spanning multiple days.
in sum conflict resolution is costly it delays the project while developers backtrack to determine the reason s for the conflict and find a resolution.
research in coordination has focused on conflict mitiga tion that is identifying and notifying developers of potential conflicts as they emerge.
this allows developers to coordinate to resolve potential conflicts early while conflicts are still small and easier to resolve.
workspace awareness tools moni tor changes at real time to notify developers of emerging direct and indirect conflicts .
tools such as fastdash syde and others largely support direct conflicts whereas tools like palant r crystal and collabvs support both conflict types.
while these tools are proactive in identifying conflicts early they are still reactive since conflict resolution can only be performed post hoc after the conflict has already developed.
to alleviate this situation we present a novel conflict min imization technique that evaluates task constraints in a project to recommend optimum task orders for each developer.
a key goal is to proactively determine conflicting tasks tasks that will conflict when performed in parallel and appropriately schedule them to recommend conflict free development paths.
constructing a conflict avoidance task scheduler raises many questions including what are the different types of con straints in the context of parallel software development how can we prioritize constraints if all of them cannot be satisfied how can individual and overall team goals be reconciled how to provide guidance without overly restricting or overloading users and questions about scalability and general effectiveness of the approach.
in this paper we provide a first exploration in answering these questions through the implementation of our research prototype cassandra.
the specific contributions of this paper include empirical analysis of four open source projects to identify the distribution of different types of conflicts and the effort needed to resolve them.
contrary to common belief that higher order conflicts are harder to resolve we found that the resolution effort for direct and indirect conflict to be comparable in some projects.
further each project had a different conflict profile suggesting that there is no one size fits all analysis.
to the best of our knowledge ours is the first study to characterize the resolution effort needed for different types of conflicts.
an implementation of a novel conflict minimization tech nique that formalizes a parallel software development con text task dependencies file dependencies and developer .
c ieee icse san francisco ca usa732preferences into constraints and then solves these con straints to determine conflict minimal development paths for the team.
design and implementation of cassandra our research pro totype that implements the conflict minimization technique to provide developers a recommended list of conflict free tasks and the rationale for these recommendations in a con textualized manner.
an extensive evaluation of cassandra using data from sev eral open source projects as well as simulated data with a much higher distribution of conflicts than typically found.
the rest of the paper is organized as follows we present back ground on related work in section ii followed by our empirical analysis of open source projects in section iii.
section iv pre sents a motivating example followed by a discussion of our approach in section v. implementation details are presented in section vi and our evaluation in section vii.
we discuss the threats to validity in section viii and conclude with a brief outlook into future work in section ix.
ii.
related work change awareness tools many different kinds of conflicts can arise in parallel soft ware development when it is performed in distributed work spaces.
the impact of each type of conflict and the effort to resolve them vary.
three major categories of conflicts exist.
first merge con flicts arising because of parallel changes to the same artifact.
we refer to them as direct conflicts.
this type of conflict is typically identified when a developer attempts to check in their changes while a newer version already exists in the repository.
second build failures arising because of parallel changes to two different artifacts that cause syntactic mismatches and en suing compilation errors.
such conflicts are typically identified during a system wide build.
finally test failures arising be cause of parallel changes to two different artifacts that cause mismatches in program behavior.
such conflicts are only de tected during testing integration or may remain as defects.
conflicts arising because of changes in one file affecting changes in another are classified as indirect conflicts.
research on change awareness attempts to alleviate the im pact of conflicts by informing developer of ongoing changes that can potentially conflict.
the primary goal is to provide awareness an understanding of the activities of others which provides a context for your own activity so that develop ers can proactively coordinate their work while conflicts are still small and easier to resolve.
some examples tools are fastdash provides a dashboard visualization that spa tially represents the files each developer in a team is editing.
syde also identifies merge conflicts but reduces false pos itives via a fine grained analysis of the abstract syntax trees asts modifications.
in addition to direct conflicts palant r and collabvs detect indirect conflicts when a user starts edit ing a program element that has a dependency on another pro gram element that is being edited in parallel .
these techniques all identify conflicts at a syntactic level either ast differences or static dependency changes .
safecommit performs deeper program dependence analysis by identifying changes that pass a given set of test cases.
the proposed technique identifies changes that are cov ered by original and edited test suites either pass or fail as well as changes that do not have coverage to identify changes that may fail a given test suite.
crystal leverages the infra structure provided by decentralized version control systems e.g.
git and integrates commits local changes in a work space into a shadow repository and executes build and test scripts to identify potential changes sets that will cause merge conflicts or test or build failures.
the paper also presents data on the number of days it took to resolve merge conflicts.
guimaraes et al also use a shadow repository for merging changes that are then analyzed compiled and tested to detect merge conflicts.
the above techniques depend on the exist ence of robust build scripts and test cases in the project.
iii.
conflicts in practice coordination breakdowns and ensuing conflicts occur fre quently .
case studies have found that parallel changes are a leading cause of defects one study in a tele communication system found developers to be working in parallel on the same artifact coordination issues in dis tributed development lead to code integration problems developers have difficulty in identifying their impact network changes that may impact them or changes that may be impact ed and developers spend significant portion of their time in coordinating their efforts .
studies of coordination failures have been largely qualita tive thus far .
to the best of our knowledge there are only two studies that quantitatively characterize the distribution of conflicts these studies found the frequency of direct conflicts that required manual intervention to range from to in several open source projects.
of the two studies one brun et al.
investigated indirect conflicts.
they found that in the three open source projects studied of the merges that the version control system reported as being a clean merge resulted in an indirect build or test con flict.
these studies do not report on the time taken to resolve indirect conflicts empirical study we analyzed four open source projects see table i using similar techniques as brun et al.
.
our study is different since our primary goal is to analyze the dis tribution of conflicts to characterize the constraint space.
to the best of our knowledge we are the first to present resolution effort data for each type of conflict across multiple projects.
we chose projects that are hosted in github based on the following criteria popularity of the projects in github project activity at least developers and more than changesets inclusion of built and test scripts in the reposi tory and finally the project is not a git mirror of another cm system repository such as svn.
we use version histories of the following projects perl programming language jun to feb storm distributed real time computation system sep to jun jenkins continuous integration server mar to jun voldemort distributed key value storage system jun to jun we downloaded the version histories of the above projects in the specified time periods using our tool gitminer which converts the version histories into a graph database neo4j .
we use gremlin for traversal of the data.
733we determine the following information the three basic kinds of conflicts merge build and test failures their fre quency and the number of days the conflict existed in the repository which serves as a measure of its resolution effort.
we identify conflicts in each project by recursively inte grating developer changes into a shadow master repository.
when using git developers fork the main repository to create their own repository which contains their working copy of the code.
commits by each developer are logged as local commits in their respective repositories.
when a developer is ready to share her changes with the team she can either send a pull request or commit to the master repository.
in performing our analysis we make the following simplifying assumptions each developer has only one repository developers create local commits on finishing their tasks and developers fork from and commit to the master repository.
we recursively integrate changes into our shadow reposito ry based on the order in which these local commits appear in the master repository and progressively perform conflict anal ysis.
that is we first integrate local commits and if the git merge fails then we flag that merge as a failure.
if the merge is successful then we run build scripts on those clean merges if the build is successful then we run test cases.
conflict resolution times are approximated as the number of days between when a conflict first occurred and until when it was resolved i.e.
the number of days the conflict persisted in the master repository .
we calculate this by tracking the num ber of changesets between a failed and successful event in the repository.
for example if a build conflict is detected when a developer merges her changeset which she resolved in a sub sequent clean merge.
we consider all changesets between these two merges as the resolution effort.
here we are assuming that the set of changesets reflect the efforts of the developer in ex clusively resolving the conflict which might not always be the case in an open source project.
this might make our effort es timation results an over approximation.
our analyses show that conflict occurrences are a norm even in open source projects and occur irrespective of the size of the project kloc or the numbers of developers.
each pro ject exhibited different distribution of each type of conflict.
merge conflicts ranged from .
to .
build failures from .
to .
and test failures from .
to .
further analysis of the conflict distribution shows activity spurts distinct periods of high levels of parallel activity and conflicts followed by lower activity and conflicts see fig.
.
the resolution times for different kinds of conflicts also vary significantly across projects.
for example perl experi enced the least number of merge conflicts .
of total merg es of change sets but these required long resolution times .
days average and a days median .
in comparison storm had a high incidence of direct conflicts .
but re quired less resolution times days average .
our results provide two key insights project structures team policies development practices play a role in conflicts and their resolution the interplay of which needs to be further investigated and there is no one size fits all conflict miti gation technique analyses need to be fine tuned per project.
we use the distribution of conflicts and the severity of each type based on resolution efforts to guide our unsat heuris tics see section vi .
they are also used to guide the task simu lation that we use for our evaluation see section vii iv.
motivating example in this section we provide a highly simplified scenario that we will use throughout the paper.
let us assume that alice and bob are working on a hypothetical project see table ii in volving polygons where classes square.java rectangle.java and triangle.java inherit from class shape.java.
to plan for future additions of new shapes to the code base alice in task ta1 refactors shape.java to combine two methods for calculating areas into a single method by using a parameter for the type of shape s type .
she then updates existing meth ods in the project to reflect this change.
rectangle.java is the only class affected which she updates and commits.
alice s workspace bob s workspace ta1 shape.java area float l float w area float l area float l float w s type tb1 square.java innerarea float b shape.area l rectangle.java shape.area l w shape.area l w s type rectangle.java innerarea float b ta2 canvas.java tb2 triangle.java ta3 panel.java tb3 plot.java meanwhile bob in tb1 adds the functionality of calculating the area without its border innerarea to square.java and rec tangle.java.
these methods in turn call the respective methods in shape.area .
when committing his changes he faces a merge conflict and realizes that his copy of rectangle.java is out of date and needs to be reconciled with changes in the re pository.
he also faces a build failure for square.java since he used the earlier version of shape.area float which now also incudes the shape type parameter.
in tb2 bob creates a new class triangle.java.
bob ensures that he is calling the new shape.area float float type with the shape type parameter set as t .
however alice did not create functionalities for the area of a triangle in shape.java which defaults the shape to a rectangle.
bob s changes therefore lead to a test failure.
project kloc developers changesets merges conflicts merge build test conflicts resolution days average med failures resolution days average med failures resolution days average med perl .
.
.
.
.
.
.
storm .
.
.
.
jenkins .
.
.
.
.
.
voldemort .
.
.
.
.
.
table i. subject open source projects analyzed from github table ii.
task list for bob and alice 734alice s task ta3 depends on task ta2 where class panel ex tends from superclass canvas.
thus there is a precedence of task ta2 over ta3.
for simplicity we assume that alice s tasks ta2 ta3 are independent of bob s task tb3 .
our goal is to schedule tasks for alice and bob such that the conflicts in ta1 tb1 and tb2 can be avoided.
for example if alice works on ta1 then bob must work on tb3.
however if bob decides to work on tb1 first then alice must work on ta2 followed by ta3.
v. cassandra we designed cassandra a novel task scheduling system that aims to minimize conflicts by recommending task orders that restrict dependent tasks or tasks that share common files from being concurrently edited.
when implementing cassandra we make the following design decisions proactive a primary goal of cassandra is to move from reactive conflict mitigation to proactive conflict avoidance.
conflict mitigation techniques help in identifying conflicts early thereby allowing developers to resolve these conflicts while they are still small.
however effort is still needed for resolution.
in prior work we found that users of our work space awareness tool consistently took longer than the con trol group without workspace awareness granularity awareness tools typically provide change in formation at the file level.
it is the responsibility of the de veloper to keep track of this information and relate it to their current or future tasks.
we on the other hand provide information at the task level that parallels the developers logical unit of work.
cassandra presents contextualized in formation of the rationale for its recommended task orders.
timeliness a key principle of workspace awareness is to keep users abreast of ongoing changes.
tools therefore continuously push change information to the users work space albeit in an unobtrusive manner.
however user ex periments have shown that developers actually note change information at very specific points e.g.
check in of change starting a new task or taking a break .
we therefore update the user s task view and re evaluate the constraint space when a developer completes her work so that the in formation is ready when she is about to start her new task.
individual versus team strategy conflict resolution as well as mitigation tools make the user responsible for coordinat ing and resolving conflicts.
this can lead to individualistic strategies such as racing to finish one s work or checking in unfinished code to avoid having to perform conflict reso lution .
we aim to reconcile these conflicting individual and team goals by providing different heuristics for task scheduling that can be guided by team policies.
the architecture of cassandra is shown in fig.
.
grey compo nents represent generically available version control system issue tracker and development editor that are used in a project.
other components are implemented by cassandra and are ar chitecturally separated to allow extensibility.
the context gen erator and visualization components are implemented at the client side whereas the task scheduler and internal storage component are centralized.
we describe each of these compo nents below.
context generator is implemented as a set of workspace wrappers that track activities in the eclipse workspace events from the mylyn plugin and cm operations.
more specifi cally it logs the following activities workspace activities such as save open etc.
mylyn events such as creating or activating a task selecting files for a particular task and edit and propagation events cm operations such as check in check out update.
a primarily responsible of this component is to track the development context of a task.
we track three main context factors task precedence task dependencies created as a result of functional dependencies for example in our scenario class triangle depends on the existence of parent class shape task dependencies dependencies across tasks because of the underlying program dependencies among files that are to be modified in these tasks and developer preferences of the ordering of their tasks.
currently we track task precedence information from the issue tracker e.g.
bugzilla and monitor the ide for the other two pieces of information.
currently we rely on the developers interactions with mylyn to identify the set of files fe that they are going to edit for a task.
once we have the fe set we perform a simple call graph analysis using a third party tool dependency finder to identify the set of dependent files fd .
note that here we assume a team policy where developers when assigned a task use mylyn to identify the set of files that they intend to modify fe .
we note that this requires upfront developer effort and might not be feasible in all development contexts.
in the future we plan to use automated data mining and machine learning techniques to mine similar past issues to predict re sources that are likely to be used for a current task.
such tech niques have been successfully applied in automated bug tri aging .
any changes to the task context as a result of ongoing de velopment new files added to the fe set as well as cm opera tions are communicated to the scheduler component and stored in the internal storage component.
visualization component is created as an eclipse plugin that modifies the task view of mylyn to present the order of our task recommendation.
our goal is not to restrict but to guide the user in choosing their next optimum task.
we present the rationale for our task recommendation as a popup linked from the recommended task order number.
task scheduler formalizes the task precedence task de pendencies and developer preferences into constraints.
it pre processes the data to identify conflicting tasks that is if the tasks share a common file direct conflict or require modifica tion of dependent files indirect conflict which are then for malized.
if a constraint free solution exists then it is optimized fig.
.
cassandra architecture.
735to match developer preferences to the extent possible.
if no solution exists then constraints are progressively relaxed until a solution is achieved.
we explain this component in detail in the following section.
internal storage maintains an overview of development activities recommended task orders the particular task that are being edited in a particular workspace and their resources.
it also tracks the number and type of conflicts that have been predicted and those that have occurred in the project.
fi nally it keeps track of other cassandra events for bootstrapping new or returning clients.
the architecture of cassandra is explicitly designed to allow extensibility cassandra architecturally separates its main components to enable easy plug and play.
for example supporting a different ide e.g.
visual studio is possible by simply changing the context generator.
similarly incor porating a more sophisticated dependency analysis will only require changes to the conflict identifier component of the task scheduler.
flexibility different projects incur different frequencies of conflicts and have different team policies.
cassandra there fore provides different heuristics that a team can choose for relaxing constraints when conflict free development paths are not possible.
these heuristics also help in reconciling individual and team preferences.
vi.
constraint solving and task scheduling constraint satisfaction is the process of finding a solution to a set of constraints that impose conditions that a set of variables must satisfy in a given domain.
a constraint space can be ex pressed as a triplet !
!
!
!
where values are selected from a given finite domain d and assigned to each variable v while ensuring that the given set of constraints c are satisfied .
constraints can be of two types hard constraints that must always hold true when arriving at a solu tion and soft constraints that can be relaxed if necessary.
next we discuss our formalization of the constraint space and how we solve it.
formalizing constraints our goal is to identify a set of task ordering from a given set of tasks in the project that satis fies the constraint sets in task assignments.
for example given !
developers and m tasks per developer in a team t!
!
!
!
!
...
!
!
is a set of tasks for developer a. the set of all tasks is then t !
!!!!!!.
the tasks for each developer are ordered as a sequence o!
!
!!
!
!!
...
!
!!
which encodes a permutation of t!.
we write o!
to denote the !
!!
task in the sequence.
the constraints in the development context are formalized as follows see fig.
where our example scenario is formal ized using z3py notations .
first we formalize task prece dence relation as hard constraints since the implementation of a task is functionally dependent on the completion of anoth er !
!!!!
!
!!
!
!!.
in our example alice s task ta2 creating parent class canvas precedes ta3 child class panel see fig.
line second we need to identify those task dependencies that will lead to a conflict if a set of tasks are concurrently executed.
the fe files to be edited and fd dependent files sets provid ed by the context generator are used by the conflict identifier component see fig.
to detect potential conflicts.
potential direct conflicts occur when task pairs include files that are common in their fe sets !
!
!
!
.
potential indirect conflicts occur when dependent files of a task are modified by another developer f!
f!!
.
we note that these are currently simplistic measures.
we plan to next use program analysis techniques to create a more sophisticated conflict de tection algorithm.
also note that at this stage before tasks have started we cannot not differentiate between tests and build failures.
therefore both are grouped as indirect conflicts.
in our example alice and bob s tasks will result in direct rectangle and indirect square conflicts ta1 !
!
rectangle shape !
!
square tb1 !
!
rectangle square !
!
shape after we have identified the conflicts the constraint for malizer component see fig.
encodes these constraints.
we use the relation !
t t to define the existence of a conflict between a pair of tasks.
given two developers !
and b the ordering of their tasks must then be conflict free !
!!!!
!
!
!!
!
!!
.
we formalize conflicts direct or indirect between a pair of tasks as a set of soft constraints that discourages two tasks from being concurrently performed.
in our example scenario alice and bob faced one direct and two indirect conflicts fig.
line which are formalized as soft constraints lines .
next developer preferences are formalized1 so that they can be used to optimize the solution set explained later .
other implicit assumptions about the development context also need to be explicitly encoded.
for example our recommended task assignments should respect the actual developer task assign ments i.e.
alice can only be assigned to her tasks ta1 ta2 or ta3 fig.
lines .
similarly we assume that a developer performs only one task at a time line solving constraints constraint satisfaction problems on finite domains are typically solved using a form of search.
popular techniques include variants of backtracking con straint propagation and local search .
constraint satis faction problems csp arise in different application areas in cluding software engineering e.g.
static program analysis formalization not shown here because of space constraints.
see source code fig.
.
z3py constraint encoding of example scenario.
736test case generation symbolic execution .
a well known csp is propositional satisfiability sat that aims to determine whether a formula comprising boolean variables that are formed by using logical connectives can be solved by choosing true false values for its variables.
often richer languages arithmetic or linear inequalities better describe a given prob lem such as ours.
solvers for such formulations are called sat isfiable modulo theories or smt solvers.
research on smt solvers has produced several robust tools e.g.
barcelogic yices and z3 .
these solvers have made checking formulas with hundreds of thousands of variables tractable.
we decided to use z3 as our smt solver of choice since it is a generalized framework is well supported and well docu mented.
z3 allows constraints to be encoded via different pro gramming languages such as scala c and python.
we chose to use python z3py .
the constraint formalizer com ponent encodes the development context into a z3py script see fig.
to create the smt formula where logical connectives are combined with atomic formulas in the form of linear arith metic inequalities.
the z3 solver then solves this formula see fig.
line to check for a satisfiable assignment a map ping of task variables to the orders in which they should be performed.
optimizing solution space finding a conflict free order ing is not our only goal.
we aim to determine the optimum schedule that is if multiple conflict free development paths exist we match our recommended task orders with developer preferences to the extent possible.
for an average problem there may be multiple solutions.
selecting a solution that is best suited to a problem requires traversal of the solution space .
we optimize the solution by first restricting the solution space by implementing a cost function that evaluates the quali ty of the solution to an integer value e.g.
number of prefer ences violated .
we progressively add these values as a set of tighter constraints until we find the least cost solution we use half interval search .
in our example our optimized solution assigns alice the following task order ta1 ta2 ta3 whereas bob is assigned tb3 tb2 tb1 .
this indicates that alice can follow her preferred sequence whereas only one of bob s preferences tb2 is satisfied.
this gives us an optimization level of .
an alternate satisfiable solution among others is alice ta3 ta1 ta2 and bob tb2 tb1 tb3 satisfying only1 preferences.
other sophisticated cost functions can be easily implemented and plugged into our optimizer component see fig.
.
relaxing constraints if the development context is over constrained then the smt formula is unsatisfiable unsat .
this requires the identification of an unsat core that is a small unsatisfiable subset of the formula s clauses.
z3 returns unsatisfiable constraints as an unsat core.
however the unsat core is not minimal.
an unsat core is minimal if it becomes satisfiable whenever any one of its clauses is removed.
it is always desirable to find a minimal unsat core because this will ensure that relaxing the least number of constraints pro vides a solution.
algorithms for finding minimal sets are do main and context specific.
in the context of parallel collaborative software develop ment we identify four different approaches for relaxing con straint conflict focus that focuses on minimizing certain types of conflict e.g.
avoid test failures at all costs team focus that focuses on minimizing constraints for the entire team as compared to per developer task focus that attempts to relax constraints on the most constrained task or the reverse that is not relax constraints on certain critical tasks and file focus that prohibits relaxing constraints for critical files or en courages relaxing constraints based on files that are not prone to defects.
these heuristics are necessarily team spe cific and will be influenced by the conflict distribution and resolution efforts in a project.
note cassandra is explicitly designed to allow teams the flexibility to choose the heuristics that best matches their need or create new ones .
here we have implemented and evaluated two conflict focused unsat heuristics.
we decided to first implement this class of unsat heuristic since we only have conflict related data from the version histories of our subject programs which allowed us to design and evaluate these heuristics.
information needed for the other classes of heuristics information on criti cal files team policies or high priority tasks were not readily available to us.
the first conflict focus heuristics basic favors indirect conflicts over direct conflicts since direct conflicts are always flagged by the cm systems and can accurately localize the con flict.
on the other hand indirect conflicts are identified at a much later time either during a system build integration test ing or as defect which makes localizing the cause of the con flict more difficult.
therefore in this heuristic if the unsat core contains constraints related to direct conflicts they are first relaxed.
our second empirically guided approach prioritizes the dif ferent types of conflicts based on the effort it takes to resolve each.
for example we found that in a project like perl test failures are frequent .
and take longer time to fix medi an of days see table i .
in this case test failure constraints should be the last to be relaxed.
however in the case of jen kins direct conflicts occur frequently .
and take the longest to resolve median of days .
therefore in jenkins direct conflicts should be relaxed last.
reevaluating constraints as development progresses new constraints might be added changing the satisfiability and soundness of our solution.
for example a developer might edit a different file than what we initially predicted.
as changes take place in the project we can also better determine the seri ousness and probability of a conflict which can guide con straint relaxation.
therefore we need to reevaluate the con straint space periodically to ensure that satisfiability of the so lution is up to date.
a primary factor for deciding when to re valuate the constraint space is that developers cannot be asked to change their current task because of changes in the develop ment context.
therefore to avoid interruptions or disruption of a developer s task we re evaluate the constraint space when a developer has finished her changes.
that is we track commit operations from the workspace which triggers a reevaluation of the constraint space.
therefore by the time a developer is ready to work on her new task we have reevaluated and updat ed the recommended task order if needed.
the reevaluation of the constraint space takes place in a matter of seconds.
this reevaluation is computationally cheap er since now we have to find a non conflicting task for only one developer while the tasks for other developers are fixed.
also new constraints are incrementally added so that the solver can reuse its constraint decisions.
737vii.
evaluation here we aim to determine the feasibility of constructing a conflict minimizing task scheduler such as cassandra.
our evaluation goal therefore is to assess cassandra s success in minimizing conflicts when given a development context with software conflicts.
we measure success as the number of con flicts avoided effectiveness and the time taken to arrive at an optimized solution efficiency .
we perform a set of controlled experiments by running cassandra on data from a set of four open source projects see section iii .
we chose a range of time slices for our analysis weekly w monthly m quarterly q and monthly 6m .
the development context from these time periods were then encoded as constraints and solved.
note that in real life such analysis is likely to be performed at a daily or weekly basis.
we found that the changesets in these time periods were functionally dependent and retrospectively changing their order when integrating them into the master repository led to a dif ferent set of conflicts.
these functional dependencies could have arisen because of hidden task precedence conditions or situations where developers in addition to resolving conflicts also changed code functionality.
since we do not have control over these variables in our retrospective analysis we stop after arriving at optimized satisfiable task orders and do not inte grate the changes see table iii .
our analysis shows that while the selected projects had sub stantial number of conflicts in total their distribution is rela tively low when analyzed at weekly to quarterly basis.
fig.
shows conflict distribution data for jenkins on a quarterly basis.
therefore to stress test the efficiency of our approach we use data from one of the projects storm and mutate it to induce additional constraints see table iv .
all evaluation scenarios were evaluated on z3 version .
installed on a macbook pro .
ghz intel core duo with 4gb of memory and running osx .
.
.
a. open source data evaluation we analyzed data from our test projects across different time slices weekly monthly quarterly and monthly .
table iii reports our evaluation results for all time intervals in jenkins data and a single time interval for the other projects.
jenkins had the highest number of merges merges develop ers so we started our analysis with this project.
we found that the conflict scenarios for shorter time intervals w m q were relatively trivial for z3 to solve therefore here we only show month time period analyses for perl merges devel opers and voldemort merges developers .
we ana lyzed the entire project history of storm since it had only merges and developers.
for each time interval w m q 6m in the project we ana lyze the data and select a time period that is representative of that time interval.
for each time interval we select two time periods one with an average number of conflicts and the other with a high number of conflicts quartile .
from each of these chosen periods we extract the task scenarios the number of developers the number of changesets tasks and the files involved in that changeset the developers who committed these tasks and the number and types of con flicts along with affected resources.
an example scenario is a build conflict developed between changesets ta1 and tb1 which included resources shape.java and square.java and were committed by alice and bob respectively.
since conflicts are identified through a retrospective analysis and for the build failure to occur changes by alice had to precede that of bob we encode this conflict as a precedence relation.
test failures are similar and are treated as such.
table iii presents an overview of our results.
we find that the average conflict periods in jenkins had low conflict in stances ranging from for all time intervals w m q 6m .
finding a satisfiable unoptimized solution was trivial for the se scenarios .6s was the longest time for 6m .
for the high periods conflict numbers ranged from and the longest jenkins perl voldemort storm week month quarter months months months complete avg.
high avg.
high avg.
high avg.
high avg.
high avg.
high date range developers avg.
tasks avg.
files changesets merge failures build failures test failures direct conflicts indirect conflicts is sat?
unsat sat unsat unsat sat unsat unsat unsat sat unsat sat sat unsat dc relaxed ic relaxed conflicts avoided pref.
matched .
.
.
.
.
.
.
.
.
.
.
.
.
cpu time .
.
.
.
.
.
.
.
.
.
.
.
.
optimization time out pref.
matched .
.
.
.
.
.
.
.
.
.
.
cpu time sec .
.
.
.
.
.
.
.
.
.
.
table iii.
evaluation results for open source projects 738time to reach a solution was .65s indicating that solving conflict constraints using our approach encoded in z3 is trivial.
cassandra also avoided a majority of conflicts in these sce narios.
perl voldemort and storm have similar characteristics.
when we attempt to optimize task orders to match develop er preferences the order in which tasks appeared per developer was treated as their preference order we find that the time required to attain a solution increases.
in fact finding an opti mized task order for the 6m periods in jenkins took longer than minutes.
we used a threshold of minutes to terminate our analysis since a delay of minutes or more is sufficiently long to be considered disruptive by end users and can potentially frustrate them.
however note that this time period had a large changeset and for average and high activity peri ods .
it is highly unlikely that a team will need to schedule such a large number of tasks.
we note that our optimization matches developer preferences to a large extent .
.
in situations where the development context was unsatisfia ble the unsat core was small largest set being for storm .
interestingly all unsat cores only had a single type of con flict.
since these unsat cores were small and had a single conflict type both heuristics for relaxing constraints evaluated to be the same.
we only show results of the basic unsat heu ristic in table iii.
b. task simulation here we test cassandra and its efficiency in simulated task contexts with high numbers of constraints.
we do so by simu lating constrained tasks by mutating the data of one of our test subjects.
we choose storm as our subject since it is a small project and had the least skew in its development activity see fig.
b .
the mutation is performed by a task generator component that first creates a distribution of the changesets and conflicts for the entire project history.
it then identifies the sta tistics mean sd of the conflict distribution for each time in terval w m q 6m .
it then uses this data to create a normal distribution from where it randomly creates three scenarios for each time interval.
these scenarios include low quartile average and high quartile numbers of conflicts.
table iv.
evaluation result s for task generator task generator scenarios week month quarter months low high avg.
low high avg.
low high avg.
low high avg.
developers avg.
tasks avg.
files changesets merge failures build failures test failures direct conflicts indirect conflicts is sat?
sat sat sat sat sat sat sat unsat unsat unsat unsat unsat basic dc relaxed ic relaxed runs conflicts avoided empirically guided dc relaxed ic relaxed runs conflicts avoided pref.
matched .
.
.
.
.
.
.
.
.
.
.
.
cpu time .
.
.
.
.
.
.
.
.
.
.
.
optimization .
.
.
.
pref.
matched .
.
.
.
.
.
.
.
.
.
cpu time sec .
.
.
.
.
.
.
.
.
.
fig.
.
conflict distribution in projects a jenkins quarterly b storm monthly.
a b 739the scenarios are encoded by the constraint formalizer and solved see table iv .
as we can see the number of conflicts in each scenario is much higher than previously observed espe cially for the high conditions.
however despite these high numbers of conflicts the weekly and monthly data were sat taking only seconds to complete .33s was the longest for the high monthly condition.
most scenarios for the quarterly and monthly period had unsat cores.
cassandra identified op timized solutions much quicker than in the previous evaluation.
however because of the higher number of conflicts finding task orders that match developer preferences was more difficult .
to .
.
note that the high 6m periods has the low est preference matching .
but faces conflicts.
as expected the large number of conflicts in these scenari os causes z3 to return larger unsat cores.
table iii presents the results from our two unsat heuristics.
note that finding the minimal unsat core takes several iterations runs .
a set of conflicts is released at each iteration based on the un sat heuristic used after which the solver reevaluates the rest of the constraint space.
this process continues until a satisfia ble solution is reached.
note that of the two approaches the empirically guided approach performs better when we compare the number of con flicts avoided.
this is so since in storm merge conflicts had the highest incidence followed by test failures and then by build failures.
in the empirically guided approach constraints are relaxed in the reverse order.
whereas in the basic approach direct conflicts are first relaxed followed by build and then by test failures.
this shows that different heuristics can affect the quality of a solution.
also note that currently we relax all con straints of a particular type at every iteration we can further refine the process to select a subset of a type of conflict from the unsat core.
despite the high number of conflicts and higher number of iterations required for relaxing constraints solutions were still found quickly .33s was the longest time needed for the high 6m period .
viii.
threats to validity our empirical analyses and evaluations naturally leave open a set of potential threats to validity which we explain here construct we use version histories of open source projects to identify conflicts and when they were resolved.
when per forming this analysis we have assumed each developer only has a single line of development that is regularly synchro nized with the master repository if a developer faced a con flict then she exclusively worked to resolve that conflict merge build test in subsequent merges until the conflict was resolved and build and test scripts available in the version ing history repository are robust and have good coverage.
internal when scheduling tasks with cassandra we as sumed that all tasks were of equal length and functionally inde pendent allowing them to be reordered.
based on this infor mation we predicted the number of conflicts cassandra could have avoided.
however this was clearly not the case which precluded us from being able to retrospectively integrate changes based on our reordered task orders.
the main goal of this paper was to determine the feasibility of constructing cas sandra future studies will analyze current task contexts of teams.
external our retrospective studies only focused on four open source projects hosted on github.
while we ensured that we chose projects that were popular had high parallel activity and included conflicts they might not be representative of oth er projects.
moreover these are open source projects where contribution is voluntary and a small group performs the major ity of work.
commercial projects will have different character istics.
however studies have shown that such projects have higher number of parallel changes and conflicts which sug gests that cassandra will be even more useful in such settings.
ix.
conclusions collaborative software development allows developers to work in parallel which can result in software conflicts.
such conflicts are a norm rather an exception even in open source projects where developers often contribute in their spare time and the majority of work is performed by a small core group.
we analyzed four popular open source projects and more than one year s worth of data per project.
we found that all projects faced substantial number of conflicts ranging from to and required resolution times spanning multiple days.
moreover each project had different distributions of different types of conflicts and different resolution times for each con flict type.
given that conflicts are bound to occur in any collaborative development scenario and their resolution takes time even when detected early we present a novel conflict minimization technique.
this technique implemented in our research proto type cassandra proactively identifies conflicts and other con straints in a development context to determine task orders that will avoid the incidence of conflicts.
we evaluated the feasibil ity of constructing a system such as cassandra by evaluating its scheduler on data from four open source projects.
our results show that cassandra is able to solve a large set of constraints and able to avoid the majority of conflicts that were identified in our retrospective analysis .
this work was a first exploration in constructing a system such as cassandra.
there are several possible directions for enhancements.
first we will explore automated data mining and machine learning techniques to automate the context gen eration so that we can provide an initial set of resources to be edited per task which the user can then refine.
second we will explore program dependency analyses to refine our conflict identification technique.
finally we will implement other un sat heuristics task file team focused .
we will perform qualitative studies including surveys of development teams to guide the heuristic implementation.
acknowledgment we thank matthew dwyer for his guidance on constraint solving.
we thank patrick wagstrom and corey jergensen for the gitminer tool.
this research is supported by grants nsf and afsor fa9550 .