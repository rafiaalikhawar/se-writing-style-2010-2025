automatic verification of interactions in asynchronous systems with unbounded buffers samik basu department of computer science iowa state university ames ia sbasu iastate.edutevfik bultan department of computer science university of california santa barbara santa barbara ca bultan cs.ucsb.edu abstract asynchronous communication requires message queues to store the messages that are yet to be consumed.
veri cation of interactions in asynchronously communicating systems is challenging since the sizes of these queues can grow arbitrarily large during execution.
in fact behavioral models for asynchronously communicating systems typically have in nite state spaces which makes many analysis and veri cation problems undecidable.
in this paper we show that focusing only on the interaction behavior modeled as the global sequence of messages that are sent recorded in the order they are sent results in decidable veri cation for a class of asynchronously communicating systems.
in particular we present the necessary and su cient condition under which asynchronously communicating systems with unbounded queues exhibit interaction behavior that is equivalent to their interactions over nitely bounded queues.
we show that this condition can be automatically checked ensuring existence of a nite bound on the queue sizes and we show that the nite bound on the queue sizes can be automatically computed.
categories and subject descriptors d. .
formal methods model checking keywords asynchronous communication unbounded bu ers veri cation .
introduction asynchronous communication is commonly used in many domains that rely on concurrent and distributed processes this work is supported in parts by nsf grant ccf1116836.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright acm ... .
.
as operating systems web services and telecommunication systems .
in the asynchronous communication paradigm when a sender peer i.e.
process sends a message the message gets stored in a message queue to be consumed by a speci c receiver.
this message queue is often referred to as the receive queue of the receiver.
the receiver consumes messages in the order they are sent assuming a fifo communication model .
the sender and the receiver do not synchronize to exchange messages.
in an asynchronously communicating system the receive queues can grow arbitrarily large.
as a result asynchronously communicating systems exhibit behaviors over in nite statespaces.
in general computing reachable states of asynchronously communicating systems with unbounded receive queues is undecidable .
this implies that automatic veri cation of temporal properties of asynchronous systems is also undecidable.
as a result the veri cation problem is addressed either by identifying subclasses for which veri cation is decidable or by developing sound and incomplete veri cation techniques .
in this paper we focus on the interactions among the peers which are sequences of send actions.
each send action appends a message sent by a peer to another peer s receive queue.
note that receive actions are local to a peer where a peer consumes a message from the head of its receive queue.
we present the necessary and su cient condition under which interactions among peers in a system say a with unbounded receive queues are identical to another system s say b interactions involving the same peers with bounded receive queues.
if this condition holds then abecomes automatically veri able since i bcan be modeled with a nite state space hence ii bcan be automatically veri ed and iii the veri cation results of bremain valid fora.
asynchronous systems exhibit in nite state behavior when the sender can send unbounded number of messages to some peer which does not have the capability of consuming them or which does not consume at the same rate as the sender is producing messages thus forcing the receiver s queue to grow in an unbounded fashion.
we are not interested in identifying whether the receive queue remains nitely bounded.
instead our objective is to identify the condition which when satis ed ensures that behaviors exhibited in the presence of unbounded receive queues can be represented using behaviors with bounded receive queues.
intuitively the condition states that if a peer can send unbounded number of messages then the corresponding receiver must include some behavior where it can consume all the messages sent to it without disabling any of its own send actions.
we formally describe this condition and its properties in this paper.
we show that the condition can be automatically veri ed by exploring and analyzing nite number of states in the system.
once the condition is successfully veri ed which ensures the existence of some nite bound say k on the receive queue size one can automatically compute such a bound.
the process is based on iteratively checking whether the peer interactions with size ireceive queues are identical to peer interactions with size i receive queues starting from i .
this iteration is guaranteed to terminate when i k. this is because the interactions between peers using size ireceive queues include the same peers interactions using receive queues with size less than i .
.
background peers systems.
we rst present the formal models for asynchronously communicating peers and their interactions .
de nition peer behavior .
a peer behavior or simply a peer denoted by p is a finite state machine m t s wheremis the union of input min and output mout message sets tis the nite set of states s02tis the initial state and t m f g tis the transition relation.
a transition can be one of the following three types a send transition of the form t1 !m1 t2 which sends out a messagem12mout a receive transition of the form t1 ?m2 t2 which consumes a message m22minfrom its input queue and an transition of the form t1 t .
we writeta !t0to denote that t a t0 .
we will focus on deterministic peer behaviors where 8t1 t2 ta !t1 ta !t2 t1 t2 .
peer behaviors can be determinized following standard methods for translation of non deterministic state machines to deterministic ones.
figure a illustrates some example peers.
the initial states are subscripted with .
each transition is represented by send or receive actions.
de nition system behavior .
a system behavior or simply a system over a set of peers hp1 pni where pi mi ti s0i i andmi min i mout i is denoted by a state machine possibly in nite state i m c c wheremis the set of messages cis the set of states c0is the initial state and is the transition relation de ned as .m imi .c q t1 q t2 qn tnsuch that8i2 qi min i .c02csuch thatc0 s01 s s 0n and .
c m c forc q1 t1 q2 t2 qn tn and c0 q0 t0 q0 t0 q0 n t0 n a c!m !c02 if9i j2 m2mout i min j i ti!m !t0 i2 i ii q0 j qjm iii 8k2 k6 j qk q0 kand iv 8k2 k6 i t0 k tk b c?m !c02 if9i2 m2min i i ti?m !t0 i2 i ii qi mq0 i iii 8k2 k6 i qk q0 kand iv 8k2 k6 i t0 k tk c c !c02 if9i2 i ti !t0 i2 i ii 8k2 qk q0 kand iii 8k2 k6 i t0 k tk in the above a system state is described in terms of local states of the participating peers and their respective receive queues.
the transitions describe the evolution of the system from one state to another via send receive or internal actions.
the send action item 4a is non blocking and as a result of the send action the message sent is added to the tail of the receive queue of the receiver 4a ii .
the receive item 4b is blocking because a receiver can only make a move on a receive action if message to be consumed is present at the head of the receive queue 4b ii .
the epsilon labeled transition item 4c is presented to allow for internal actions in the peers internal actions simply change the local state of the peer executing it and do not directly a ect any other peers.
figure b presents a partial view of a system i. each con guration iniis denoted by a tuple capturing the local state of the peers and the state of the corresponding receive queues.
for instance initially all the receive queues are empty denoted by .
after p1sendsaand loops back to s0 the receive queue of p3gets updated to contain a denoted by .
whenever a receive action is performed by a peer it consumes the matching message present at the head of its receive queue leftmost element inside .
once a message is consumed it is removed from the queue.
de nition k bounded system .
ak bounded system denoted by ik is a system where the receive queue length for any peer is at most k. thek bounded system behavior is therefore de ned by augmenting condition a in de nition to include the condition jqjj k wherejqjj denotes the length of the queue for peer j. ink bounded system ikthe send actions are blocked when the corresponding receive queue where the sent message is supposed to be bu ered is full i.e.
it already contains k messages pending to be consumed by the receiver .
therefore ikhas a nite state space.
notations.
for a systemi m c c withnpeers hp1 p2 pniand a con guration c q1 s1 q2 s2 qn sn of the system we use c st s1 s2 sn projection of con guration to local states c st pi siprojection of con guration to pi s local state c st pi s1 s2 si si sn projection of con guration to local states of all peers exceptpi c qu pi qiprojection of con guration to receive queue of pi send sequences languages.
the following concepts form the basis for describing the interaction behavior of the system where the interaction is viewed as messages sent from one peer to another .
!ds0 s1 s2!a ?c ?d !a !a ?d t0 t1?e !d r0?a u0 u1 u2!c !e s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u1 s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u2 s0 t1 r0 u2 s0 t1 r0 u2 s0 t0 r0 u1!a !c !a?a !e ?e !d!a?a?a!c s0 t0 r0 u0 s0 t0 r0 u1!a!c s0 t0 r0 u0 s1 t0 r0 u1 s2 t0 r0 u1 s2 t0 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2?c !a !e ?e !d !ds0 s1 s2!a ?c ?d !a !a ?d t0 t1?e !d r0?a u0 u1 u2!c !e s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u1 s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u2 s0 t1 r0 u2 s0 t1 r0 u2 s0 t0 r0 u1!a !c !a?a !e ?e !d!a?a?a!c s0 t0 r0 u0 s0 t0 r0 u1!a!c s0 t0 r0 u0 s1 t0 r0 u1 s2 t0 r0 u1 s2 t0 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2?c !a !e ?e !d i p1 ii p2 !ds0 s1 s2!a ?c ?d !a !a ?d t0 t1?e !d r0?a u0 u1 u2!c !e s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u1 s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u2 s0 t1 r0 u2 s0 t1 r0 u2 s0 t0 r0 u1!a !c !a?a !e ?e !d!a?a?a!c s0 t0 r0 u0 s0 t0 r0 u1!a!c s0 t0 r0 u0 s1 t0 r0 u1 s2 t0 r0 u1 s2 t0 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2?c !a !e ?e !d !ds0 s1 s2!a ?c ?d !a !a ?d t0 t1?e !d r0?a u0 u1 u2!c !e s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u1 s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u2 s0 t1 r0 u2 s0 t1 r0 u2 s0 t0 r0 u1!a !c !a?a !e ?e !d!a?a?a!c s0 t0 r0 u0 s0 t0 r0 u1!a!c s0 t0 r0 u0 s1 t0 r0 u1 s2 t0 r0 u1 s2 t0 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2?c !a !e ?e !d iii p3 iv p4 !ds0 s1 s2!a ?c ?d !a !a ?d t0 t1?e !d r0?a u0 u1 u2!c !e s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u1 s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u2 s0 t1 r0 u2 s0 t1 r0 u2 s0 t0 r0 u1!a !c !a?a !e ?e !d!a?a?a!c s0 t0 r0 u0 s0 t0 r0 u1!a!c s0 t0 r0 u0 s1 t0 r0 u1 s2 t0 r0 u1 s2 t0 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2?c !a !e ?e !d a b figure a peers b partial view of icomposed ofp1 p2 p3andp4.
de nition language equivalence .
the language of a systemi m c c f denoted byl i is the set of sequences of send actions on any nite or in nite path fromc0.
systemsiandi0are language equivalent if and only ifl i l i0 .
going back to the example in figure b some of the example sequences of send actions that belong to l i are as follows i sequence of a s a aa aaa and ii a ce ajd !
where represents zero or more occurrences j represents or and !represents in nite repetition.
proposition .8k l ik l i l ik l ik proof.
the proof follows the same outline as the proof for synchronizability in theorem in where the proof was done for a speci c value k synchronous systems when the peers move in lock step .
given the systems xandy we say thatl x l y if8!2l x either!is subsequence of some !02l y or !2l y .
to prove 8k l ik l i l ik l i note that 8i l ii l ii andl ii l i .
this is because ii as well asi can mimic any send sequence present inii.
the receive queue size of ii andi is larger than that for ii which allows the former to avoid blocking of some send actions that are blocked in the latter.
therefore based on relation 8k l ik l i implies thatl ik l i becausel ik l ik l i .
to prove 8k l ik l ik l ik l i we rst show that8k l ik l ik 8i k l ii l ii .
this means that increasing receive queue size beyondkdoes not have any impact on the behavior in terms of send sequence.
therefore 8i k l ii l i .
we will proceed with proof by contradiction.
given that for somek l ik l ik assume that there exists n k such thatl ik l in i.e.
l ik l in .therefore there exists a nite length witness where bothin andik 1have a path over the same sequence of send actions such that the path eventually leads to a state from where incan perform a send action which is not possible in ik .
in the following we will consider paths with transitions such that!m represents a sequence of transitions containing zero of more transitions over actions in f g minand a single transition over !m.
consider that such a path with lsend actions is tn !m1 tn !m2 !ml tn linin and the corresponding path in ik 1that cannot mimic the above sequence after lsend actions is tk !m1 tk !m2 !ml tk linik such that8j2 tn j tk j. in the above paths assume that tn lis capable of realizing !m0 which is not possible from tk l i.e.
attk lthe peer sayp which is responsible for consuming m0is not ready to move on any receive action and its message queue is full containsk pending receive action .
asl ik l ik there exists a path tk !m1 tk !m2 !ml tk linik next we will show that one can construct a path over the same sequence of lsends m1m2 ml inik 1such that the receive queue of pdoes not exceed k. let us consider a path t0k !m0 t0k !m0 !m0 l t0k l where8i2 t0k i st p tk i st pandt0k i st p tk i st p. in other words in the above path the peer pmoves as it has moved along the path in while all other peers except pmove as they have moved along the path in .
our objective is to show that such a path exists and 8i2 m0 ican be made equal to mi.
745note that the states tk tk t0k are identical as these are initial con guration of the system i.e.
the local states of all peers at these states are identical.
base case i .
if !m1is an action where the sender or the receiver of the message is not p then there exists an identical action !
m0 !m 1as the states of peers that are not pare identical in tk 0andt0k .
the resulting next states oftk 0andt0k 0are also identical.
if !m1is an action where the receiver is the peer p then there exists an identical action !
m0 !m 1as the states of peers other thanpare identical in tk 0andt0k .
furthermore as !m1is allowed at the con guration tk the peerp must be capable of consuming a message from its receive queue if the addition of !m 1in its receive queue makes the length of the queue k. if !m1is an action from peer pto some other peer then there exists an identical action !
m0 !m 1as the local state ofpare identical in t0k 0andtk .
we can therefore construct a matching path of length fromt0k 0tot0k 1where m1 m0 1andt0k st p tk pandt0k st p tk st p induction step.
let8i j !m0 i !miandt0k i st p tk i st p andt0k i st p tk i st p. using the arguments as above we can prove that !m0 j !mj andt0k j st p tk j st pandt0k j st p tk j st p. therefore paths and are over exactly the same sequence of send actions.
note that at con guration t0k l peerphas a message queue with kpending messages as the local state of pat this con guration is based on congurations in path of ik.
as a result the con guration t0k l is capable of realizing the action !
m0.
this violates our assumption that the path in equation is a witness distinguishinginandik .
in other words no witness distinguishing l ik andin can be identi ed when l ik l ik .
therefore 8k l ik l ik 8i k l ii l ii .
temporal properties.
we consider temporal ordering of sends expressed in the logic of linear temporal logic ltl .
for instance gfa represents the ltl property which is satis ed if along all paths of the system message ais sent innitely often.
on the other hand fg a represents the ltl property which is satis ed if along all paths of the system messageais sent nitely many times.
for details of ltl refer to .
proposition .given two systems iandi0 ifl i l i0 then for any ltl property over the send actions i satis es if and only ifi0satis es .
the propositions and form the basis for the veri cation of systems with unbounded receive queues.
in the subsequent sections we identify the condition under which one can guarantee the existence of ksuch that the language of a systemiwith unbounded receive queues is identical to the language ofik.
once the existence of kis guaranteed the value of kcan be computed by checking iteratively for equality between l ii andl ii starting from i proposition .
finally the computed ikcan be used to verify any ltl property over send actions using traditional model checking tools and the veri cation results will hold forias well proposition .
.
condition for equiv alent bounded buffer beha vior in this section we present a condition which when satis ed in any con guration in the system i guarantees that the interactions between peers participating in the system cannot be represented by interactions in any ik.
we proceed by introducing the concept of unbounded send sequence.
de nition unbounded send sequence .
given a systemi m c c overnpeershp1 pni consider a con guration c2c.
a sequence of sends starting from c is unbounded if the following holds.
the composition of peers from their respective local states tis incproduces a cycle with respect to the local states i.e.
same set of tis are revisited in the cycle none of the peers consume messages from their respective receive bu er corresponding to the congurationc and when the cycle is detected there is some peer whose bu er holds more messages compared to the same peer s bu er at con guration c. the rst condition ensures that the peer compositions can send messages in a cycle.
the second condition ensures that there is no in uence of the history of events i.e.
messages pending in the bu er do not in uence the existence of a cycle.
this is because the messages in a bu er if consumed may allow for some nite unfoldings of a cycle but will not ensure its unbounded unfolding.
finally the third condition ensures that at least one of the peers will have an increase in the number of bu er elements after one unfolding of the cycle.
example.
figure presents p1along with three variants of a second peer p p0 2andp00 .
assume that at a particular con guration cof the system the peers are at their local states s0andt0.
the composition and subsequent detection of cycle with respect to local states is presented in the gure.
note that when the pairs p1andp00 2are considered there is no unbounded send sequence if at the con guration c the bu er ofp1is non empty or the bu er ofp00 2is non empty.
this may appear to be too restrictive because in the presence of some bu er contents the peers may still be able to produce send sequences that are unbounded for instance when initially p1containsain its receive queue bu er .
while con guration s0 t0 is not classi ed to produce unbounded send sequence as per de nition the system can proceed after p1consumes a to con guration s1 t0 which will be classi ed to produce unbounded send sequences as per de nition .
in short removing all history in uence does not discard any unbounded send sequences but ensures that no nite send sequence is incorrectly classi ed as unbounded.
going back to the figure b the start con guration of the system has the local states s0 t0 r0 u0 the peerp1is capable of sending unbounded number of a s to peerp3.
when the con guration of the system is such that the peers are at their respective local states s1 t1 r0andu2 then peers can send unbounded number of aanddmessages.
the unbounded sends can potentially make the size of the receivers queues to grow in an unbounded fashion resulting ?bt0 t1t0 t0 t1 t2s0 s1!a ?a ?b !b !a !a?b!a ?bt0 t1t0 t0 t1 t2s0 s1!a ?a ?b !b !a !a?b!a ?bt0 t1t0 t0 t1 t2s0 s1!a ?a ?b !b !a !a?b!a ?bt0 t1t0 t0 t1 t2s0 s1!a ?a ?b !b !a !a?b!ap1p2p0 2p00 compositions for nding unbounded send sequences p1 p2 s0 t0!a !
s0 t1?a !
s1 t1!b !
s0 t1?b !
s0 t0 no unbounded send sequence p1 p0 s0 t0!a !
s0 t0 unbounded send sequence p1 p00 s0 t0!a !
s0 t1!a !
s0 t2?a !
s1 t2!b !
s0 t2?b !
s0 t0 unbounded send sequence no unbounded send sequence when the bu er of p1orp00 2is non empty as per de nition figure illustration of unbounded send sequences in an in nite state space.
our objective is to nd the condition under which the size of the receivers queues can be nitely bounded without changing the behavior of the system as described by the sequences of send actions.
in other words we want to identify the condition which when satised guarantees the existence of ksuch thel ik l i .
the intuition for checking when how a nite queue size system ik can replicate all behaviors of unbounded queue size system i is as follows.
every unbounded send sequence will result in repetition of some sequence of messages being sent.
the receiver peers must be capable of consuming these messages in nitely often ensuring that the receive queues do not have to hold unbounded number of messages.
furthermore the receive actions of a peer are local and are not visible to the other peers as the receiver consume messages from its own receive queue .
therefore it is also necessary that after consuming any subsequence of unbounded sequences of messages receiver peers should be able to provide the same set of send sequences as they were able to before consuming the messages ensuring that any ordering of sends between peers that are possible in i is also possible in ik.
theorem below presents the necessary and su cient condition for guaranteeing the existence ofk l ik l i .
we proceed by rst describing the simulation relation with respect to the send actions.
this will be used to ensure that peers while consuming unbounded sequences of messages will not disable any sequence of send actions.
de nition send only simulation .
given a nite state machine m t s t12tis send simulated by t22t denoted by t1 !t2 if and only if 8t0 t1!m !t0 9t0 t2!m t0 t0 !t0 where!m denotes zero or more transitions followed by a !m.
the statess0 s1ands2inp1 figure a i are related to each other by the !
relation s0 !s1 !s2 !s0 each can perform unbounded number of !a .
theorem .giveni m c c over a set of n peers if and only if there exists acon guration c q s1 q2 s2 qn sn reachable from c0such that the condition 2holds atc where there exists an unbounded send sequence i.e.
there exists a set of peers pswhich can send unbounded number of messages to some peer pi ifpican move from sitos0 iby only consuming all the pending messages in its receive queue then si6 !s0 i. proof.
to prove .
let!be the sequence of sends leading to con guration cfromc0.
as there is a nite number of states in each peer an unbounded send sequence starting from cresults from an unbounded repetition of a sequence say .
first consider the case where pidoes not consume all messages in its receive queue qi negation of the antecedent of the implication in .
therefore it will require qito be of in nite size to allow storing of messages resulting from unbounded repetition of send sequence .
that is in the given path the send sequence !
will require that qi size is not nite.
next consider the case where pican consume all messages in its receive queue qito reachs0 ifromsiandsi6 !s0 i condition .
let 0be the sequence of sends possible fromsithat is not possible from s0 i. consider as before that !is the sequence that led to cfromc0and the unbounded send sequence results from the unbounded repetition of .
therefore ican have a sequence !
where the number of times can be repeated depends on the size of pi s queue at the state si.
in summary in the above paths it is necessary for the peer pito have in nite receive queue size.
therefore if holds then there does not exist any ksuch thatl ik l i .
to prove 9k l ik l i .
let there be no reachable con guration from where peers can send unbounded number of messages to some peer pi .
in this case the queue size is nite in all con gurations of the system.
therefore there exists a k l ik l i wherekis the maximum size of the queue in any reachable con guration.
next consider that 1holds resulting in unbounded number of sends.
further consider that qi mi1mi2 miland 747there exists some path over the sequence ?
mi1?mi2 ?mil fromsitos0 iin peerpi i.e along this path all pending messages in qiare consumed.
furthermore siands0 iallows the same sequence of send actions s i !s0 iaccording to .
in other words for all reachable con gurations c from where some peers can send unbounded number of messages all receiver peers e.g.
pi are capable of consuming all messages in their receive queues and are capable of sending the same set of messages.
this implies that along all paths of the system the queues of the peers that may receive unbounded number of messages become empty regularly within some nite bound .
as the peer behaviors are represented by nite state machines there is a way to restrict the queue size of any peer from growing unboundedly without disabling any send sequence behavior.
therefore implies that the send sequences in ican be replicated by those inikfor some nite k. example.
consider the partial view of iin figure b .
the con guration s t1 r0 u2 is one from where peersp1andp2can produce unbounded number of sends for peersp3andp1 respectively.
the peer p3can consume ain its receive queue and remain at r0 asr0 !r0 it satis es .
the peerp1can consume cfollowed by d from its receive queue and move to state s1.
note that s0 !s1 i.e.
the condition 2is satis ed.
if however the transitions2!a !s1was not present in p1 see figure ai thens06 !s1and 2would be satis ed.
in that scenario will hold.
the sequence of sends where cefollowed by any number of d s followed by any number of a s is possible iniand will not be possible in ikfor any speci c value of kif the transition s2!a !s1is absent inp1.
example.
consider the peer pairs illustrated in figure .
the pairp1andp2does not have any unbounded send sequence i.e.
condition 1is not satis ed which in turn implies that the composition of this pair of peers can be represented using nitely bounded receive queues.
the pair p1 andp0 on the other hand has unbounded send sequences.
consider the con guration s t0 where thep1has two messages in its receive queue.
as presented in the figure there is an unbounded send sequence from the local states s0 andt0 i.e.
condition 1is satis ed.
furthermore the peer p1ats0cannot consume all the messages in its receive queue i.e condition 2is satis ed.
therefore the behavior of the peer pairs p1andp0 2cannot be represented using nitely bounded bu er.
the same is true for the peer pairs p1andp00 .
.
unbounded to equiv alent bounded beha vior our objective is to present an algorithm that can automatically verify the condition in theorem for all possible con gurations in i. two problems need to be addressed to realize such an algorithm a identifying whether a set of peers in a reachable con guration can generate unbounded number of sends see section .
and b exploring su cient nite number of con gurations in the system to check see section .
.
.
configurations with unbounded send sequence an unbounded send sequence requires that at least one of the peers must have a cycle or loop in its behavior.
in order to check whether a set of peers psat a con guration ccan potentially send unbounded number of sends to some peer we deploy the following method.
consider some subset of peersps fp1 p2 pngand the local states of peers in psatcares1 s2 sn.
.
for eachpi2ps nd the strongly connected components scc i involving the corresponding local state si.
.
compose the sccs starting from sis as per de nition with additional constraints that a any send action meant for p62ps are bu ered but never consumed b all transitions depending on the inputs from p62 psare permanently blocked c all transitions depending on consuming messages from receive queue at con guration care blocked.
.
if there exists a path in the composition such that a it ends with a con guration where all the peers piinpsloop back to state siand b at least one of the bu ers has more pending messages when compared to the same at the con gurationc then it is said to exhibit unbounded send sequence as per de nition .
conditions requires sccs for possibly producing unbounded send sequences.
condition removes any external in uence including history in uence .
note that the state space resulting from composition can be unbounded however for the purpose of identifying unbounded send sequence it is su cient to check composition paths where each peer is allowed to move at most lsteps where lis the total number of transitions in all sccs.
if none of the composition paths satisfy the conditions a and b then no extensions of any of the paths will satisfy those conditions.
the proof of the above statement is straightforward.
first the longest cycle in any peer pi2ps at statesi is of the order of the size of the scc.
second lwill allow each peer to go through its respective scc if possible which is su cient to identify any unbounded sends from peers in ps.
.
algorithm for exploring i verifying in this section we focus on exploring su cient nite number of con gurations in the i nite number of times and verifying the condition see theorem .
algorithm explore describes such exploration.
explore essentially visits con gurations in iin a depthrst fashion starting from the initial con guration c0.
it carries two important information sets per depth rst exploration path a the set visited of visited con gurations projected onto local states of the peers along with the action that led to the con guration and b the set vobl of tuples of the formhc st c0 sti wherecandc0are con gurations ini.
the semantics of this tuple is explained below.
748algorithm depth rst exploration for checking procedure explore c m visited vobl ifreceivers cycle c then .receivers of unbounded sends obl forallp2 receivers do obl0 verify c p ifobl0 1then return false .cannot have equivalent nite bu er behavior end if obl obl obl0.set of all obligations end for if obl vobl then visited visited f c st m g forallc0incm0 !c0such that c0 st m0 62visited do if explore c0 m0 visited vobl then return false .terminate exploration end if end for return true end if vobl vobl obl .obligations for depth rst exploration end if forallc0incm0 !c0do.to all next con gurations if explore c0 m0 visited vobl then return false .terminate exploration end if end for return true.terminate exploration after the for loop end procedure the algorithm rst checks whether local states of the peers in the con guration ccan produce unbounded sequence of sends line .
it uses the algorithm cycle as described in section .
to identify the unbounded sends which returns the receivers of the send actions.
for each receiver peer algorithm verify is invoked to check whether a the peer can move from its current state to some state after consuming all the pending messages in its receive queue and b the destination state can send simulate the current state lines in algorithm verify .
if the check is successful a tuple is returned which contains local states of the peers in the current con guration and the local states of the peers after the receiver consumes all the pending messages.
we use the notationc st pto denote local states of the peers in cthat are not equal top.
we will refer to the returned tuple as veri cation obligation based on the fact that for each tuple of the formhc st c0 sti atc0some peer has the obligation to consume unbounded send sequences that can be possibly sent to it by some other peers from c0.
if the check is unsuccessful is returned in which case algorithm explore returns false lines .
in lines explore checks whether the obligation for the visited con guration has already been computed.
if the check is successful then exploration continues to con gurations that are yet to contribute tovisited set line .
note that the visited set only captures the local states projected from the con guration and the action that led to the con guration from which the local states are obtained.
therefore visited is nite as the peers have nite state space.
once the for loopalgorithm checking procedure verify c p s c st p q c qu p ifsmoves tos0by only consuming messages in qands !s0then returnhc st c st p s0 i end if return end procedure in lines completes intuitively this implies that the con guration wrt local states is revisited which in turn implies the presence of a cycle in some peers behavior.
furthermore as the receiver of the unbounded send sequences do not produce any new obligation tuple the receiver peer also exhibits a cycle where it can successfully consume the unbounded send sequences.
if the check at line fails the vobl set for this path of exploration are updated line and depth rst exploration continues lines .
example.
figure illustrates the partial exploration tree of algorithm explore for the peers in figure .
consider the path highlighted using dotted line.
the order in which they are visited and the corresponding obligations generated when sccs are considered in the exploration are also presented.
the exploration along this path terminates with a true result as two con gurations are visited with the same local states s2t1r0u2and with identical obligations last conguration in the highlighted path shown in the partial view .
all extensions of this path as per for loop at line of algorithm explore will return true e.g.
p1ats2sending !aor consuming ?d p2at statet1sending !d p3at stater0consuming ?a .
in this example algorithm explore returns true.
consider thatp4in figure is replaced by p0 4such that u0!e !u1!c !u2.
in this case algorithm explore returns false.
the reason for returning false is due to the path wherep4sendse which is consumed by p2followed by sending of message dbyp2.
this results in a con guration s t1 r0 u1 which is visited by algorithm explore .
at this con guration there a cycle where p2from state t1can send message dtop1 however p1 at states0cannot consume the messages from its receive queue.
the algorithm explore returns false i.e.
9k l ik l ik .
.
correctness of algorithm explore theorem .giveni m c c over a set of n peers explore c0 always terminates.
proof.
the proof follows directly from the niteness of state space of each peer behavior.
the set visited is always nite as there are nite combinations of local states of peers.
similarly the set vobl is nite.
theorem .giveni m c c over a set of n peers the following holds all con gurations reachable from c0satisfy see theorem for de nition of if and only ifexplore c0 returns true.
!ds0 s1 s2!a ?c ?d !a !a ?d t0 t1?e !d r0?a u0 u1 u2!c !e s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u1 s0 t0 r0 u0 s0 t0 r0 u0 s0 t0 r0 u2 s0 t1 r0 u2 s0 t1 r0 u2 s0 t0 r0 u1!a !c !a?a !e ?e !d!a?a?a!c s0 t0 r0 u0 s0 t0 r0 u1!a!c s0 t0 r0 u0 s1 t0 r0 u1 s2 t0 r0 u1 s2 t0 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2 s2 t1 r0 u2?c !a !e ?e !dcon guration obligations visited sccs receivers s0 t0 r0 u0hs0t0r0u0 s0t0r0u0i s0t0r0u0 s0!a !s0 p3 s t0 r0 u1hs0t0r0u1 s0t0r0u1i s0t0r0u1 !c s0!a !s0 p3 s1 t0 r0 u1hs1t0r0u1 s1t0r0u1i s1t0r0u1 ?c s1!a !s2!a !s1p3 s1?d !s1s2?d !s2 s2 t0 r0 u1hs2t0r0u1 s2t0r0u1i s2t0r0u1 !a s2!a !s1!a !s2p3 s1?d !s1s2?d !s2 s2 t0 r0 u2hs2t0r0u2 s2t0r0u2i s2t0r0u2 !e s2!a !s1!a !s2p3 s1?d !s1s2?d !s2 s2 t1 r0 u2hs2t1r0u2 s2t1r0u2i s2t1r0u2 ?e s2!a !s1!a !s2p3 s1?d !s1s2?d !s2 t1!d !t1 p1 s2 t1 r0 u2hs2t1r0u2 s2t1r0u2i s2t1r0u2 !d s2!a !s1!a !s2p3 s1?d !s1s2?d !s2 t1!d !t1 p1 s t1 r0 u2hs2t1r0u2 s2t1r0u2i s2t1r0u2 !d s2!a !s1!a !s2p3 s1?d !s1s2?d !s2 t1!d !t1 p1 figure system con gurations explored in algorithm explore partial view proof.
to prove all con gurations satisfy implies thatexplore c0 returns true.
this follows trivially asexplore algorithm visits subset of the reachable con gurations.
to prove there exists a reachable con guration satisfying implies that explore c0 returns false.
assume that holds in some reachable con guration and explore c0 returns true.
therefore there exists a path iniof the form c0 c1 cmsuch that8i ci2cand atcm some subset of peers pscan produce an unbounded send sequence for some peer pandpfrom the con guration cmcannot consume all the messages present in its receive queue negation of the antecedent of the implication in 2in theorem or after consuming all the messages present in its receive queue pmoves to a state that does not send simulate the state cm st p consequent of the implication in 2in theorem .
as per our assump tion such a con guration is not visited in the algorithm explore .
without loss of generality we can assume that there are two peers in the system peer pand its environment e. in other words at the con guration cm eis capable of sending unbounded number of messages to p. ascmis not visited along the path in algorithm explore there must exist some con gurations ciandcjsuch that .i j m .
the local states are identical ci st cj st and have the same actions leading to the con gurations ciand cj .
wlog assuming eis responsible for unbounded sends top the stateci st p same ascj st p can move to the same states0after consuming all messages in ci qu pand 750incj qu p recall that we are considering deterministic peer behaviors .
furthermore s0send simulates ci st p cj st p .
in other words there is a cycle in preachable from state ci st pwhich can consume unbounded number of messages sent to it from the cycle in estarting from state ci st e. therefore the repetitions of the behavior of eandpthat causes the sequence ci ci cjdoes not a ect the future behavior.
the above statement implies that we can remove this repetition in the behavior of eand generate a shorter path j 0j j j iniof the form c0 c1 ci c0 i c0 nsuch that the local states at cmandc0 nare identical.
therefore the state c0 n st ecan produce unbounded send sequence forpand the state c0 n st pofpcannot consume the messages in its receive queue c0 n qu p or can consume all the messages in its receive queue but ends up in a state which does not send simulate c0 n st p. if 0is not explored till c0 nby the algorithm explore then the above steps can be repeated to obtain a even smaller path 00with the same property.
proceeding further one can construct a short enough path where the last con guration is equal to cmwith respect to local states of pandeand algorithm explore visits and checks the last con guration.
this contradicts our assumption.
theorems and complete the proof of correctness of the algorithm explore .
the algorithm allows to automatically determine the existence of a ksuch thatl ik l i .
note that while the existence of kis guaranteed when the algorithm returns true it does not give us the actual value of k. however one can easily identify kfor whichl i l ik by successively checking for equality of l ii andl ii starting from i .
the process is guaranteed to terminate with aksuch thatl ik l ik see proposition .
finally the properties over the send sequences in ican be automatically veri ed by model checking the behavior of ik using traditional model checking tools e.g.
spin .
.
experiments we have implemented a prototype of our technique in the xsb tabled logic programming environment .
xsb s declarative language allows us to easily encode the transition relations of the peers and systems while xsb s tabling strategy allows for easy computation of least xed point models which is directly applied to compute send simulation using the strategy presented in .
we have used three types of speci cations in our experiments.
the rst type is service choreography speci cations metaconversation is a two peer protocol to decide the initiator of a conversation reservationsession is a client server protocol where the client is requesting a session waiting for response from the server cancel fail or success and asynchronously sending message to server to cancel the request.
the second type of speci cations are the channel contracts from the singularity os an experimental os developed at microsoft to allow process isolation tpmcontract see figure a tcpcontract and keyboardcontract.
in this case the processes interact asynchronously using fifo message bu ers following the contract speci cation.
the third type of speci cations are from the example suit of the spin model checker and includes the alternating bitprotocol with a variant that does not include re sending of messages when the sender times out before receiving acknowledgment and the snoopy cache protocol.
in addition we have also used the speci cation of a simple stockbroker example from see figure b .
note that there is no equivalent bounded bu er behavior for this example because the rst peer can send unbounded sequences of raw messages to the second peer which cannot consume them before sending a data message satisfying condition 2of unboundedness in theorem .
the table presents the results of our experiments.
the second column shows the number of peers in the system the third column presents a set of tuples where each tuple x y denote the number of states xand transitions yin the peer the fourth denotes whether or not the behavior with unbounded bu er i can be mimicked by some nitely bounded bu er behavior.
the fth column shows the number of con gurations explored by our algorithm before terminating with a de nitive answer and the sixth column shows the time in seconds.
the largest system that we have analyzed in this preliminary study is the snoopy cache protocol.
we encoded the spin speci cation ignoring the bu er restriction in xsb s input language using logical assertions and rules.
our analysis shows that the protocol behavior cannot be represented using nitely bounded bu ers.
the time taken for the analysis primarily depends on the size and number of cycles present in the peers and the corresponding systems experiments are conducted on .8ghz intel core i7 with 4gb memory .
all examples and our prototype implementation are made available at .
.
related work a number of solutions were provided to address the problem of verifying asynchronous systems where peers communicate using unbounded receive queues.
one class of solutions focuses on identifying restricted communication patterns that can render the problem decidable.
for instance in the authors consider half duplex communication paradigm containing two peers one where at most one receive queue is non empty.
in the authors relate decidability results with the type of communication topologies e.g.
trees .
in this paper we do not restrict the communication pattern or the communication topology.
it should be noted however that consider a more expressive peer behavioral model communicating well queuing push down systems as opposed to our nite state model .
we conjecture that our results can be extended to well queuing push down systems as well.
in the context of push down systems recently the authors in present su cient conditions for decidability of reachability which require the queue contents to be visibly pushdown.
in contrast we focus on algorithmically nding whether a given system behavior can be represented using nite bu ers which in turn ensures automatic veri ability.
another line of work stems from session types where correct interaction between peers is reduced to a typing problem.
the restriction imposed on the communicating peers is that the peers cannot have send and receive actions from the same state.
this condition referred to as theautonomous condition is also used in to identify the su cient conditions under which the behavior of asynchronously interacting peers can be mimicked by the 751case study of peers of peer states transitions equivalence con gs.
explored time metaconversation l i l i .63s reservation session l i l i .70s tpmcontract l i l i .76s tcpcontract l i l i .36s keyboard contract l i l i .50s stock broker example 8k l i l i k .21s abp 8k l i l i k .97s abp w o timeout l i l i .92s snoopy cache 8k l i l i k .52s table summary of results for the case studies s rss rs1 ?gettpmstatuss rs0 ?send !tpmstatus s ior !ackstartc rs0c ior ?ackstart c rs ?sendcompletec ior0 !gettpmstatus c rs1 !gettpmstatus !send s ior0 ?gettpmstatus !sendcomplete !tpmstatus ?tpmstatus ?tpmstatus s3s0 ?ack s1 !rawt0t1 ?raw t2 !data t3 ?rawt4 ?end !data !completeu0u1 ?start u2 ?data ?datau3 ?complete !ack !raws2 !end !start a start states s rs0 andc rs0 b start states s0 t0 andu0 figure a tpm singularity contract b stock broker example from behavior of the same peers interacting synchronously i.e.
with receive queue size .
this type of equivalence between asynchronous and synchronous interactions is called synchronizability and the system resulting from the interactions is referred to as synchronizable .
in we prove that synchronizability is decidable.
in this paper we present the conditions under which interactions of peers in the system can be automatically veri ed our results hold even for systems that are not synchronizable.
in the authors discuss deadlock freedom and local behavior conformance in mpi programs where concurrently executing processes interact via message passing.
for mpi programs deadlock freedom ensures the conformance to desired local behavior.
in contrast we are focusing on global interaction behavior.
additionally our work does not impose restrictions on the dependencies between send and receive actions which are natural for the mpi programs.
our results signi cantly broaden the scope of automatic veri cation of asynchronous systems and subsumes the existing results for asynchronously communicating peers when they are represented as nite state machines.
.
conclusions in this paper we focus on analyzing interactions of asynchronously communicating systems.
since veri cation of asynchronously communicating systems is undecidable in general previous results in this area identi ed subclasses synchronizable half duplex for which the analysis of interactions is decidable.
we signi cantly improve on these results by presenting a larger decidable class.
the key toour approach is identifying if the interactions of a given system with unbounded receive queues can be mimicked by the same system when the queues are bounded.
we present a prototype implementation and discuss the applicability of our technique in di erent types of case studies where asynchronous interaction plays an important role.
as part of future work in addition to focusing on e cient implementation primary overhead lies in detecting unbounded send sequences of our technique we plan to augment existing model checkers with our tool.
this will further broaden the application of automated techniques for verifying interaction properties of certain class of asynchronous systems that were previously deemed un veri able automatically.
.