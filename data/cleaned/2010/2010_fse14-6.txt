variable specific resolutions for feature interactionscecylia bocovichuniversity of waterloowaterloo on canadacbocovic uwaterloo.cajoanne m. atleeuniversity of waterloowaterloo on canadajmatlee uwaterloo.caabstractsystems assembled from independently developed featuressu er fromfeature interactions in which features a ect oneanother s behaviour in surprising ways.
thefeature intera ction problemstates that the number of potential interac tions is exponential in the number of features in a system.resolution strategies o er general strategies that resolve en tire classes of interactions thereby reducing the work of thedeveloper who is charged with the task of resolving interac tions.
in this paper we focus on resolving interactions dueto conflict.
we present an approach language and imple mentation based on resolution modules in which the devel oper can specify an appropriate resolution for each variableunder conflict.
we performed a case study involving au tomotive features and found that the number of resolutionsto be specified was much smaller than the number of possi ble feature interactions resolutions for features thatwhat constitutes an appropriate resolution strategy is di er ent for di erent variables and that the subset of situationcalculus we used was su cient to construct nontrivial reso lution strategies for six distinct output variables.categories and subject descriptorsd.
.
requirements specifications methodologies d. .
design d. .
interoperabilitygeneral termsdesign reliabilitykeywordsfeature interaction conflict resolution1.
introductionsoftware systems are growing in size and complexity.
the scale of large scale systems no longer refers simply to largepermission to make digital or hard copies of all or part of this work forpersonal or classroom use is granted without fee provided that copies arenot made or distributed for profit or commercial advantage and that copiesbear this notice and the full citation on the first page.
to copy otherwise torepublish to post on servers or to redistribute to lists requires prior specificpermission and or a fee.fse november hong kong chinacopyright acm ... .
.codebases but also to extremevariability including increas ingly larger sets of requirements greater optionality andcustomization and greater varieties of execution platforms.such complexity is partly addressed through decomposition.infeature oriented software development as y s t e m sfunctionality is decomposed into features where eachfea tureis an identifiable unit of functionality or variation.users view features as system capabilities e.g.
cut copy andpaste caller id cruise control that may be optional selectable or tari able.
software developers use features asthe basis for incremental software development character izing software releases in terms of the new features intro duced or updates to existing features.
feature orientationis particularly important insoftware product lines in whichfamilies of similar software products e.g.
smartphones aremanaged and evolved in terms of their features and whereindividual products are di erentiated by their optional fea tures .
feature orientation also has the added benefitthat features can serve as a shared vocabulary among di verse stakeholders e.g.
marketers customers other engi neers in a way that other types of software fragments suchas modules objects or components cannot.although features are considered individually they areoften not truly separate concerns and problems arise whendevelopers try to integrate them into a coherent product.afeature interactionoccurs when one feature a ects thebehaviour of another.
for example the software controllersfor the braking features on the toyota prius interactedbadly reducing drivers overall ability to brake and leadingto multiple crashes and injuries .
to be safe softwaredevelopers must consider how features interact and must re solve undesired interactions.
because features are optionalin many products or can be turned on and o dynamically the number of feature combinations to be analyzed and man aged is exponential in the number of features.
as a result asoftware team finds that the development of new features iseventually dominated by thefeature interaction prob lem the need to analyze resolve and verify interactions .researchers have proposed a number of general purposestrategies for resolving interactions such as resolution byfeature priority feature precedence negotiating compromises involving the user rollingback conflicting actions disabling feature activation terminating features and terminating the application.these strategies address the scalability aspect of the featureinteraction problem directly by providing a default strat egy for resolving interactions thereby reducing the num ber of interactions that need to be individually addressedpermission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page.
copyrights for components of this work owned by others than acmmust be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or afee.
request permissions from permissions acm.org.fse november hong kong chinacopyright acm ... .
the developers.
however most of these strategies arecoarse grained e.g.
based on the priority or precedence ofthe features themselves rather than the features interact ing actions they provide suboptimal win lose resolutionsin which some features actions are sacrificed in favour ofother features actions and they often require an upfronttotal or partial ordering on features .in this paper we propose a new approach to resolving fea ture interactions that maintains feature modularity andobliviousness allows the developer to specify a genericresolution strategy for each output variable and is ag nostic to the number and to the specifics of features in thesystem or the number of possible feature interactions.
eachfeature specifies actions and outputs in response to systeminputs and environmental conditions.
all of the actions thatapply to a particular output variable are input to a resolu tion module designed for that variable and the resolutionmodule produces a conflict free sequence of actions that arebased on the input actions and the developer provided reso lution strategy.
examples of simplified resolution strategiesinclude assigning an output variable to theaverageor theminimumor themaximumof the values specified by thefeatures actions.
a key benefit of this approach is that thedefault resolutions for conflicting actions on a variable areappropriate for that variable.the contributions of this paper are as follows we introduce a new approach to resolving features in teractions in which the resolution strategies are spe cific to the variables being acted on.
we present an implementation of the approach in whichfeature actions and resolution strategies are encoded insituation calculus and are executed by a gologintrepreter .
we identify su cient and necessaryconditions on the developer provided resolutions thatensure that a resolution has desired properties e.g.
isdeterministic is conflict free terminates .
we performed a case study in which we used our ap proach and implementation to model the actions of 24automotive features and to specify appropriate resolu tions for distinct output variables.
the results of thecase study demonstrate that di erent output variablesrequire di erent resolution strategies.
the case studyalso assessed the expressiveness of situation calculusas a suitable language for encoding feature actions andresolution strategies.our paper is organized as follows.
in the next section wegive an overview of feature oriented requirements modellingand the feature interaction problem.
in section we de scribe our approach to resolving feature interactions in termsof resolution strategies per output variable including how toencode feature actions and resolution strategies in situationcalculus.
in section we prove that the developer providedresolutions have desired properties e.g.
are deterministic are conflict free terminate and we present the results ofour case study.
in section we review the advantages ofour resolution and discuss future work.
section summa rizes related work and section concludes our work.
.
preliminariesthroughout this paper we use examples from the automo tive domain.
each feature extends a basic driving service bds which serves as a base system .
an automotivesystem comprises bds and a subset of optional features.
.
feature oriented requirementswe are primarily concerned with the requirements stageof feature oriented software development.
behavioural re quirements for each feature are modelled independently andthen composed into a system.
there are many ways tomodel feature behaviour but we focus on state machineapproaches .
the language we describe here is basedon the feature oriented requirements modelling language forml as it provides a rich syntax for expressingfeature behaviour.a system s behaviour is expressed in terms of its reactionsto changes and conditions in its environment and its actionson environmental variables.monitored variablessuchascar.speedrepresent environmental phenomena that aresensed by or act as inputs to the system.
changes to mon itored variables prompt reactions in the system behaviour.controlled variablesrepresent environmental phenomenathat are controlled or a ected by system outputs.
for ex ample the variablecar.accelerationrepresents the currentacceleration of the vehicle and is a ected by actuators suchas the throttle or vehicle brakes.
often related variablesare packaged into objects.
these variables are referred toas object attributes.
for example accelerationandspeedare both attributes of acarobject.
this relationship be tween objects and attributes is expressed using a dot nota tion as incar.speed .
together the values of world variablescomprise theworld state.
of particular importance is thecurrent world state wsc which represents the current valu ations of all environmental variables.
the current value ofattributeaof the objectois denotedwsc o.a.
changes invariable values between the previous world state wsp andthe current world state wsc represent events.a feature s behaviour is modelled as a state machine called afeature machine.
figure shows feature machinesfor bds and two optional features cruise control cc andspeed limit control slc .
a state in a feature machinereflects the current state of a feature s execution.
statesmay be hierarchical containing several sub states that morefinely describe feature behaviour.
superstates may also con tain concurrent regions that execute in parallel.
for exam ple the cc feature has active and inactive superstates thatreflect the feature s conditional behaviour.
the active statecontains three concurrent regions responsible for monitoringand controlling di erent phenomena.
a world state reflectsthe execution states of all feature machines as well as valu ations of all monitored and controlled variables.transitions between states may be labelled with an iden tifierid a triggering eventte a guard conditiongc and oneor more actionsa1 ... an.id te a1...ana transition from states1tos2is enabled if the machine iscurrently in states1 the guard condition evaluates to true and the triggering event occurs.
for example in the ccfeature machine the transition between inactive and activestates executes only if the triggering eventccactivateoccurs.triggering events refer to changes in variable values betweenthe previous world state wsp and the current world state wsc.
guard conditions are boolean expressions over current554basic driving service inactiveactiveacceleration deceleration steeringt1 ignitionon a1 car vehicle acceleration steering t2 ignitionoffa1 vehicle car controlt3 gaspressed a1 car.acceleration acceleration controlt4 brakepressed a1 car.acceleration acceleration controlt5 a1 car.steering steering cruise controlinactiveactive speed limit controlinactiveactive monitorcontrolt2 a1 car.accleration ccacceleration t1 ccactivated t1 slcactivatedmonitorcontrolt2 a1 car.accleration slcacceleration figure behaviour model of bds and some automotive featuresvalues of variables inwsc.
a feature action corresponds toa prescribed change to the current world state.features a ect the world state of a system by executingactions on controlled variables.
an action can add an ob ject to the world remove an object from the world or as sign a value to a controlled variable.
for example manyautomotive features modify vehicle acceleration to maintaindriver preferences or respond to safety concerns.
this ismodelled by actions that assign values to the controlled vari ablecar.acceleration.
often the details of calculating thesevalues are abstracted as uninterpreted functions a1 car.acceleration ccacceleration an execution step of a feature machine consists of theexecution of all concurrently enabled transitions and theiractions.
the behaviour of a system is the parallel executionof its feature machines.
an execution step of a system is thesimultaneous execution of each feature s transitions.
theresulting world state is determined by the new states in eachfeature machine and the e ects of the transitions actions onthe controlled variables.
.
feature interactions due to conflictscomposing independently developed features naturally leadsto feature interactions.
the literature lists multiple typesof feature interactions but in this paper we are concernedwith conflicts that occur in a single execution step.
acon flict occurs when the set of actions in an execution stepare impossible to execute simultaneously e.g.
incompatibleassignments to the same controlled variable .in figure we see the potential for conflict when bothslc and cc are active andsetspeed speedlimit slcwill try to decrease acceleration at the same time that cctries to increase it cc.t2.a1 car.acceleration ccacceleration slc.t2.a1 car.acceleration slcacceleration .
resolutionour aim is to resolve feature interactions in a way thataddresses key aspects of the feature interaction problem.
wedeveloped a strategy with the following high level goals.
.maintain the advantages of feature oriented softwaredevelopment.
this includes feature modularity andobliviousness to the presence of other features.
.enable conflict free feature composition.
feature com position should resolve feature interactions if they arepresent and should preserve feature behaviour in theabsence of interactions.
.allow resolutions to be based on all conflicting actionsrather than on the features that perform them.
thislimits the impact that adding or removing features hason the specification of resolutions.
.resolutions should be agnostic to the number of fea tures in the system and the number of features in an in teraction.
in addition the number of resolutions spec ified by developers should be small with respect to thenumber of interactions and should not grow linearly orsuper linearly with the number of features.
.the resolutions we devise should be deterministic andtotal.
determinism guarantees that given a currentworld state and a set of changes to monitored variables there is only one possible next world state.
as a result system behaviour is predictable.
totality guaranteesthat there will always be a valid next world state.we first give an overview of our approach to resolvingfeature interactions due to conflicting actions and describehow it fits into the execution model of a system composedof feature machines.
we then present the details of ourimplementation and provide examples of resolutions in theautomotive domain.555feature 1feature 2feature nmonitored variables controlledvariable a1resolvercontrolledvariable a2resolvercontrolledvariable amresolverpartitioning of features actions set of non conflicting actions.
.
.
.
.
.figure architectural model3.
overviewwe draw inspiration for our approach from the softwarecost reduction scr requirements method.
scr spec ifications follow a dataflow execution model in which re quirements are represented as a directed graph.
each nodein the graph is a function that calculates the current valueof a particular variable.
edges indicate the flow of data be tween nodes.
a node executes its function as soon as all ofits input data are available along incoming directed edges and it outputs the result along outgoing directed edge s tothe next node s .thus an scr specification defines a unique function foreach controlled variable.
this function calculates what thevalue of the variable will be at the end of an execution step.each function takes as input the current values of all moni tored variables the most recently computed values of localvariables and the current modes of all mode classes analo gous to the current states in a state machine and determin istically calculates the next value of the variable for whichit is defined.
there are no conflicts among variable assign ments in an scr specification because they are resolvedduring specification each function e ectively encodes allcontributions to a controlled variable s next value and com putes a single next value.in our approach we similarly define a unique function called aresolution moduleorresolver for each con trolled variable that computes the variable s next value.
how ever in our approach the sources of the inputs to a function that is thefeaturesthat are executing actions do not needto be known in advance.
each controlled variable resolvertakes as input the features actionson the variable and em ploys a feature independent resolution strategy to assign aconflict free value to the variable.figure depicts the architectural structure of our ap proach.
we define a feature module for each feature.
ineach execution step the feature machines in their modulesexecute in parallel reacting to changes in the values of mon itored variables.
each feature module outputs the set ofactions on the transitions that execute in that step.
theactions are partitioned according to the controlled variablethat they modify.
for each controlled variable in the currentworld state we define a resolution module that is given asinput all of the features actions on the controlled variable.the resolver computes and outputs a sequence of actions tobe executed atomically on the variable.the next world state wsn is the result of executing inparallel the output actions of each resolver together withthe next states of each feature machine.
thus a completeexecution step proceeds as follows .changes occur to the values of one or more monitoredvariables.
.feature machines react in parallel by executing tran sitions and outputting transition actions.
.our resolution introduces a third phase in the execu tion step in which the feature machine actions passthrough resolver modules one resolver per controlledvariable.
the output of each resolver is a sequenceactions to be performed atomically.
.the next world state wsn is determined by the resultof performing the transitions in step and the featureactions produced in step .there are a couple of details about the resolution modulesworth noting.
first our resolvers di er from the controlled variable functions in scr in that they take as input notonly the current values of monitored variables but also anarbitrary number of possibly conflicting actions on the con trolled variable in question.
in contrast scr functions takeonly values as input.second recall that a feature s actions can add a new ob ject to the world or remove an object from the world.
asobjects are added and removed resolution modules for theobjects attributes are instantiated and removed .
thus the set of resolvers in the system is dynamic.
.
detailsin this section we focus on the details of the resolutionmodules.
we describe a language that is suitable for ex pressing the inputs and outputs of a resolver as well as forspecifying a resolver s resolution strategy.
we then providean implementation that uses situation calculus and a subsetof the golog programming language.
.
.
input action languageour resolution language needs to be rich enough to encodethe inputs to a resolver.
this includes values of monitoredvariables and feature actions.
an assignment assigns a vari able to the value of an expression.
an expression may be asimple value or it may be a computation on other variablesor uninterpreted functions1.
the resolution language mustbe able to encode any relevant information about assignmentexpressions as the inputs to a resolver.
.
.
resolution languagehow conflicting assignments to a controlled variable areresolved depends on multiple factors including the variable s1the details of uninterpreted functions may be specifiedlater in development.556table domain independent situation calculus symbolssymbol type descriptionscconstant starting statedo a s function result of performing actionainsposs a s predicateacan be performed insrange of values the system domain and the e ect the vari able has on the behaviour of the system or on the system senvironment.
as such the developer or domain expert are inthe best position to determine the most appropriate resolu tion strategy for conflicting actions on a controlled variable.our goal is to provide a language that is suitable for themto program appropriate resolutions.consider two features a and b that control vehicle sta bility.
feature a monitors lane markings and detects thatthe vehicle has veered too far to the left and compensates byturning the vehicle to the right.
simultaneously feature bmonitors oscillation the sway of the vehicle detects thatthe vehicle is over steering to the right and attempts tocorrect this by turning the vehicle to the left.
in order toachieve maximum stability an appropriate resolution needsto consider the actions from both features.
a reasonableresolution might be to setcar.steeringto the average of thevalues assigned by features a and b.in general the resolution language needs to be expressiveenough to reason about a collection of actions and computea conflict free resolution.
examples of resolution strategiesinclude computing the minimum average or sum of theassignment expressions that are output by the feature mod ules.
each resolution module considers only theactionsonits controlled variable and not the sources of the actions.such strategies incorporateall assignmentsin the compu tation of the result value and thus o er an alternative to awin lose resolution in which only one feature s actions e.g.
those of the highest priority feature are preserved in thefinal resolution.even when it is possible to specify variable specific resolu tions priorities sometimes still play a role and our resolutionlanguage should support them.
for example in automotivesystems it is common to give higher priority to actions thatpreserve driver safety such as speed limit control slc compared to actions that maintain driver set preferences such as cruise control cc .
additionally we may wishresolutions to prioritize driver actions over feature actions.as such we categorize actions as being driver controlled safety or non safety and devise a resolution language thatsupports reasoning about action categories as well as thevalues of assignment expressions themselves.
we stress thatthese resolutions depend on an action priority not a priorityordering on features.
.
.
situation calculussituation calculus is a first order language that is well suited to expressing actions domain knowledge and the ef fects that actions have on the current domain state.
wechose to use situation calculus as a proof of concept imple mentation language because it naturally supports our re quirements with respect to both the input action languageand the resolution language.situation calculus constructs are grouped into three basiccategories situations fluents and actions.
asituationis afirst order term that represents a world state or a valuationof all variables.
a situation is the result of performing asequence of actions on a defined starting state2 sc.actionsin situation calculus are first order logic termsthat reflect a prescribed change to a situation or world state.these actions may take one or more arguments as inputs.for our purposes situation calculus actions are analogousto feature actions.
performing an actionaon a situationscis expressed using the special functiondo and results in anew situationsn do a sc .fluentsare functions and predicates that take a situationas one of their arguments they are referred to as fluentsbecause their valuations depend on the situation to whichthey are applied.
fluents can be used to refer to the valuesof variables in a particular world state.
for example thefunctional fluentcarspeed s returns the value of the car sspeed in the world state represented by situations.the developer uses a combination of situations actions and fluents to specify allowable steps in the execution of asystem.
these specifications are the axioms that constitutea domain theoryd.
starting state axioms are assertionson the values of fluents in a starting statesc.
successor state axioms define the e ects of performing an actionain asituations.
precondition axioms specify whether an actionamay be performed in a given situations they are expressedwith the special predicateposs a s .
table contains asummary of special situation calculus constructs.
.
.
encoding inputs to a resolution modulethe inputs to a resolution module for a controlled variableo.aare the values of monitored variables at the start ofthe execution step i.e.
the values of the monitored variablesin the world statewsc and the set of actions that areoutput by all the feature modules and that assign values too.a.the developer encodes the inputs to a resolution moduleas starting state axioms which assert constraints on the val uations of fluents in the starting situationsc.
the startingsituation of each resolver will reflect the current world state wsc.
given a monitored variableminwsc the developer as serts the relational fluentm v sc to be true if the value ofminwscis equal tov wsc m v .
to express the set in listform of input actions she asserts another relational fluentassignrqst l sc wherelrepresents the set of assignmentexpressions output by the feature modules.
that is if thefeatures perform the actionso.a e1 ... o .
a en thenl .
note that the numbernof actions outputby the feature modules depends on the transitions that ex ecute in the feature machines and varies between executionsteps.to distinguish between safety driver and non safety ac tions the developer may defineassignrqstfluents for eachcategory.
the fluentsassignrqstsafety l sc assignrqstdriver l sc andassignrqstnonsafety l sc correspond to lists of assignment expressions partitioned ac cording to the above categories.
in general the developermay define a fluent for every level of prioritization she wishesto express.2we deviate from the traditional situation calculus termi nology of initial state to avoid confusion with the conceptof the initial state for a state machine model.557table domain independent resolution symbolssymbol type descriptionempty l predicate listlis emptymember l e predicate elementeis in listlappend l e function append elementeto listlremove l e function remove elementefrom listlaverage l v predicate average value inlisvminimum l v predicate minimum value inlisvmaximum l v predicate maximum value inlisvsum l v predicate sum of values inlisv predicate equality and inequality function arithmetic operationsexample .suppose a developer is responsible for pro gramming the resolution module for the controlled variablecar.acceleration.
relevant monitored variables includecar.
speedandcar.acceleration.
the developer distinguishes be tween three levels of prioritization safety non safety anddriver features.in a particular world statewsc the cruise control featuremodule outputs the actioncar.acceleration ccaccelera tion speed limit control outputs the actioncar.accelera tion slcacceleration and the driver presses the accel erator to produce the actioncar.acceleration accelera tion the starting state axioms that encode these inputsare car.acceleration wsc car.acceleration sc assignrqstsafety sc assignrqstdriver sc assignrqstnonsafety sc .
.
encoding the resolutions of a resolvereach resolution module is responsible for assigning a valueto one controlled variable.
therefore the developer definesonly one situation calculus actionassign v per resolver theaction assigns the valuevto the controlled variable in ques tion.the developer uses precondition axioms to specify the out put of a resolution module.
a precondition axiom dictatesthe conditions under which a situation calculus action maybe performed in a given situation.
the special predicate poss a s signifies that the actionamay be performed insituations.
we characterize these precondition axioms us ing the fluents described above.
some helper predicates andfunctions that we deem useful for specifying resolutions thatare listed in table .
this list is by no means exhaustive the developer may define any first order logic predicate andfunction needed to provide appropriate resolutions for herdomain.example .recall the acceleration example discussed inexample .
there are several safety and convenience fea tures that modify the controlled variablecar.acceleration.
these include cruise control cc andspeed limit control slc which aim to keep the moni tored variablecar.speedat a driver set preference and belowthe speed limit of the road respectively.
additionally theheadway control hc feature changes the vehicle s acceler ation in response to upcoming obstructions or other cars onthe road and the driver can a ect vehicle acceleration bypressing her foot on the accelerator pedal.based on our understanding of how these features oughtto interoperate with each other we devised the followingresolution3.
our resolution considers three di erent levelsof priority driver safety and non safety actions.
driveractions to modify the car s acceleration have the highestpriority followed by actions from safety features followedby actions from non safety features.
if there are multipledriver related input actions the resolver module will assignthe minimum value.
if there are no driver related actions then safety actions will be considered.
if there is more thanone safety action then the minimum value is selected tobe the output action.
for example if there are no driver related actions and the two safety features speed limit con trol and headway control both contribute input actionscar.acceleration e1andcar.acceleration e2 then theoutput action will be the minimum of these two values.our resolution is expressed in situation calculus as follows poss assign v s 9l.assignrqstdriver l s minimum l v 8l.
assignrqstdriver l s !empty l 9l2.assignrqstsafety l2 s minimum l2 v 8l.
assignrqstdriver l s assignrqstsafety l s !empty l 9l3.assignrqstnonsafety l3 s minimum l3 s the interpreter will first see if there are any elements inthe list of input driver actions and take the minimum valueof this list.
if the list of driver actions is empty it willattempt to find the minimum value of the list of input safetyactions.
finally if there are no driver or safety actions the interpreter will output the minimum value of non safetyactions.as long as there is at least one enabled action there willbe a valuevthat satisfies the above formula.
if there areno input actions the resolver will not output any actionsand the value of the controlled variable will not change.
insection we discuss the necessary and su cient conditionsto ensure that resolutions are deterministic and total.
.
.
implementation in gologgolog is a programming language for situation calcu lus.
it provides procedures for outputting sequences of ac tions from a starting state that satisfy a collection of ax ioms.
given a domain theoryd comprising situation cal culus facts fluents and axioms and given a starting statescand a golog procedure the golog interpreter willfind terminating situationssnresult from the program executing from the starting statesc d do sc sn if the interpreter can find a situationsnthat satisfies thisentailment then the output of is a conflict free sequenceof actions to be applied to the resolver s controlled variable.we now explain how a single resolution module is imple mented in a combination of situation calculus and golog.3for the purposes of this paper it does not matter whetheror not we have a correct understanding of how feature inter actions ought to be resolved.
what matters is whether ourproposed resolution language is expressive enough to specifyinteresting non trivial resolution strategies.558as we walk through the explanation we will refer to theresolution ofcar.accelerationgiven in examples and .at the very beginning of an execution step the values ofall monitored variables in the current and previous worldstates wscandwsp are input to the feature machines.
thechanges in these variables will trigger transitions in the ma chines resulting in actions on controlled variables.
for ex ample an increase in vehicle speed may prompt slc to as sign a negative value to the car s acceleration if the vehicle sspeed exceeds the speed limit of the road.
all of the actionsoncar.accelerationfrom di erent features are then input tothe same resolver along with the current values of relevantmonitored variables.these inputs represent the state of the world before theresolution takes place and are encoded in situation calculusas starting state axioms.
in thecar.accelerationexample the inputs to the resolution module are exactly the axiomsgiven in example .the resolution strategy for the resolver s controlled vari able is encoded as a precondition axiom in situation calculus.this axiom poss assign v s encodes when it is possibleto execute an action of the formcar.acceleration v.the precondition axiom was given in example .
note thatits value depends on the evaluations of the starting stateaxioms given in example .the golog procedure specifies how the resolution strat egy is used to determine the resolver s output.
the gologprocedure to execute the acceleration resolution is procresolve v.assign v this procedure nondeterministically explores all possible as signmentsvto the controlled variable of the resolver lookingfor a value that satisfies the precondition axiom i.e.
the res olution strategy .
the output of this procedure will be theresult of performing a single actionsn do assign v sc .in simple cases as in this example the procedure invokesthe resolution strategy once to determine a single outputaction.
in more complicated cases a developer may wish toiterate the strategy to output sequences of actions.example .as a separate example there are a numberof features that a ect the direction in which the car is trav elling.
the controlled variable iscar.steeringand the af fecting features include lane centring control lcc andseveral stability features such as traction control tc andstability control sc .
the driver can also a ectcar.steeringby rotating the steering wheel.for this resolution we distinguish only between driver andnon driver actions.
driver related actions have the highestpriority.
if there are multiple assignments at the same pri ority level the variablecar.steeringis set to theaverageof the assignment expressions.
thus in this resolution theactions from all features contribute to the outcome of theresolution.
the inputs to the resolver are car.steering wsc car.steering sc assignrqstdriver l sc assignrqstnondriver l sc the resolution is encoded as a precondition axiom that pri oritizes driver related actions and computes the average ofthe relevant steering actions poss assign v s 9l.assignrqstdriver l s average l v 8l.
assignrqstdriver l s !empty l 9l2.assignrqstnondriver l2 s average l2 v the golog procedureprocresolve v.assign v executes the resolver module for a given set of input actionsand starting statesc and outputs a terminating statesn do assign v sc .the resolution examples discussed up to this point outputa single action to be performed on a controlled variable.
thenext example uses iteration of a resolution strategy to out put a sequence of actions.
we use successor state axioms insituation calculus to express the e ects of a single iteration.for example performing the actionassign vn on the con trolled variablecar.accelerationwill result in a new situa tiondo assign vn sc in which the value ofcar.accelerationis nowvn.
we specify this e ect in the domain theorydofthe resolution with the successor state axiomcar.acceleration vn d o a s a assign vn we express the iteration as part of the golog program.example .the variablecar.warninglighttypeis con trolled by alert features that try to get the driver s atten tion.
if multiple features want to set a particular light todi erent values one possible resolution is to satisfy all re quests sequentially.
for example if one feature turns a lighto and another turns the same light on the resolution is tohave the light blink on and o to alert the driver to a possi ble conflict among the features associated with the warninglight.
the inputs to the resolution are car.warninglight wsc car.warninglight sc assignrqst l sc because the resolution is a sequence of more than one ac tion the developer needs to write the successor state axioms car.warninglight v do a s a assign v assignrqst l do a s a assign v l remove k v modifyrqst k s the first axiom encodes how the warning light variable changeswith each assignment.
the second axiom specifies that aseach assignment is made the value of the assignment is re moved from the list of feature actions.
the warning lightassignments must be executed in some order.in our resolution in each situation the light is alwaysassigned to the maximum light value in the list.poss assign v s modifyrqst l s maximum l v this resolution is deterministic and it intuitively sets thewarning light to the strongest value first.
the golog pro cedure is iterates through the list of input actions until thelist is empty procresolvewhile modifyrqsts l now empty l do n.assign n .
analysisin this section we demonstrate that our resolutions to fea ture interactions have the desired properties that we listed inthe beginning of section that the resolutions are conflict free are deterministic and total and preserve the features actions in the absence of an interaction.the most important goal of our work is to enable conflict free feature composition.
recall that a feature interactiondue to conflict occurs when two or more features attempt tosimultaneously execute a set of incompatible actions.
theresolution approach that we have devised eliminates conflictsby computing a conflict free sequence of actions.
such acomputation is performed for the actions on each controlledvariable in each execution step of the system.theorem1.the set of action sequences output by theresolver modules are conflict free.proof.a feature may execute one or more actions ineach step.
these actions each belong to one of three cate gories adding an object to the world removing an objectfrom the world and modifying the value of a controlled vari able.
possible conflicts occur when .two or more features attempt to set the value of thesame controlled variable to di erent values or2.one feature attempts to remove an object while an other feature attempts to modify it.case all of the features assignments to the same con trolled variable are forwarded to the same resolution mod ule.
the resolver outputs one action or one sequence ofincremental actions that computes the resolved value thusthe actions of an individual resolver do not interact.
fur thermore each resolver produces a resolution for a distinctcontrolled variable thus the outputs of di erent the resolu tion modules do not conflict.case an action to remove an object results in the re moval of all resolver modules associated with the object scontrolled variables.
all attempts to assign a value to anyof these variables are ignored.
in this way object removalhas priority over assignment.in both cases the set of output actions is conflict free.a second goal of our work is that resolutions should bedeterministic and total for each set of features actions a resolver produces a unique sequence of assignments to thecorresponding controlled variable and for any set of fea tures actions on a controlled variable there exists a pos sibly empty sequence of conflict free actions output by thevariable s resolution module.
determinism and totality arenot guaranteed by the approach itself and are dependent onthe developers implementations.
specifically the develop ers resolution modules must meet the following obligations.ob .8v1.8v2.8s.poss assign v1 s poss assign v2 s !v1 v2ob .8s.9v.poss assign v s then there is always exactly one possible sequence of outputactions from the resolver and one possible next world statewsn.note that particular attention must be paid to computa tions that have loops the developer must prove that everyloop terminates 8s.9s0.
8p.
8s1.p s1 s1 8s1 s2 s3.p s1 s2 do s2 s3 p s1 s3 p s s0 theorem2.given the set of situation calculus facts flu ents and axiomsdfor a resolution module ob 1on theprecondition axiom ind a n dt h ec o r r e s p o n d i n gr e s o l u t i o nprocedure t h e nt h ef o l l o w i n ge n t a i l m e n th o l d s d 8sc s s0.do sc s do sc s0 !s s0proof.this is proven by structural induction on thegolog resolution program .theorem3.given the set of situation calculus facts flu ents and axiomsd f o rar e s o l u t i o nm o d u l e ob 2on the re solver s precondition axiom the corresponding golog pro gram a n do b l i g a t i o n sf o re a c hl o o pi n t h e nt h ef o l l o w i n gentailment holds d 8sc.9s.do sc s proof.this is proven by structural induction on thegolog program .finally a resolution should preserve the functionalitiesof the features as much as possible.
if the set of features actions on a controlled variable in an execution step are non conflicting then the resolution should include all actions onthat variable.ob .if in an execution step the features produce ex actly one actiono.a von the controlled variableo.athenposs assign v s for that variable.theorem4.ifob 3holds for every resolver function then feature functionality will be preserved in the absence offeature interaction conflicts.proof.this is proven by structural induction on thegolog program .
.
case studywe conducted a case study to analyze the expressive powerof our resolution language.
we examined automotive fea tures and identified six di erent controlled variables that aremodified by multiple features.
in section we presented theresolutions for three of these variables their resolutions werecreated during the development of our resolution language.the other three controlled variables described below serveas a test of our language s expressive power.we now provide the details of the variables in our casestudy and their appropriate resolutions.
we base these res olutions on feature specifications provided by our industrialpartner although the feature names we give are based oncommon features found on the internet.
.
.
brake pressurethere are three categories of actions that modify the con trolled variablebrake.hydraulicpressure.
the first cate gory of actions enhances driver preferences and inputs.
forexample the automatic braking ab feature performs ac tions that minimize stopping distance when triggered bythe driver applying a large amount of pressure to the brake560pedal.
the second category includes safety or stability ac tions such as those enacted by trailer stability ts andstability control sc .
these features apply brake pressureto each of the four wheels to maintain a straight vehiclepath and counteract vehicle oscillation.
the third categoryof actions maintains driver set acceleration preferences orprovides feedback to the driver.
these are grouped into anon safety action category.we give the highest priority to safety and stability actions.there are two ways in which safety actions a ect brake pres sure.
some safety actions reduce vehicle speed by apply ing an even application of brake pressure to all four wheels.other safety actions apply brake pressure unevenly with thegoal of controlling vehicle oscillation or stability.
our resolu tion di erentiates between these cases by observing the mon itored variablecar.oscillation.
ifcar.oscillationis less thana low threshold value the resolution setsbrake.hydraulicpres sureto the maximum of all assignment values.
if it is greaterthan the threshold we assume that multiple stability actionsare working to correct the oscillation of the vehicle and ourresolution setsbrake.hydraulicpressureto the average ofall assignment values.the precondition axiom for the resolution isposs assign v s 9l.assignrqstsafety l s maximum l v car.oscillation s t h r e s h o l d car.oscillation s threshold average l v 8l.
assignrqstsafety l s !empty l 9l2.assignrqstdriver l2 s maximum l2 v 8l.
assignrqstsafety l s assignrqstdriver l s !empty l 9l3.assignrqstnonsafety l3 s maximum l3 v .
.
warning chimefeatures such as cruise control cc basic braking bb parking brake pb manual park brake mpb and roadchange alert rca use the controlled variablealert.chime typeto alert the driver.
as the primary purpose of this vari able is to capture the driver s attention we operate underthe assumption that values for this variable can be rankedfrom less to more urgent.
we define the functionranklist l that takes a list of values and returns a corresponding listof rankings and we define the functiongettype x that re turns the chime type that corresponds to the rankingx.the inputs to the resolution are encoded in the predicateassignrqst l sc .the resolution will setalert.chimetypeto the most ur gent chime value.
the precondition axiom isposs assign v s 9l.assignrqst l s r ranklist l maximum r x v gettype x .
.
air flow ratethere are several features that control cabin temperatureand air quality.
each of these features modifies the variablecabin.airflowrate.
the air quality system aqs circu lates air to reduce pollution levels air conditioning ac and heater control hc use air flow to circulate cooler orwarmer temperatures and air recirculation ar recircu lates air at the driver s request.we prioritize actions that circulate air to improve air qual ity over actions that circulate air to improve the air tem perature.
input actions for air quality are encoded in thepredicateassignrqstquality l sc .
inputs actions for air temperature are represented asassignrqsttemp l sc .
in both cases we set the air flowrate to be the maximum assigned value.
the preconditionaxiom for this variable isposs assign v s 9l.assignrqstquality l s maximum l v 8l.
assignrqstquality l s !empty l 9l2.assignrqsttemp l2 s maximum l2 v .
discussionin this section we summarize the results of our case studyand the advantages of our approach.
.
utilityone goal of our resolution approach is to provide the mod eller with a language that is powerful enough to express res olution functions that are tailored to fit the domain and thebehaviour of each controlled variable in a system.
the pur pose of our case study was to gauge the expressiveness of ourapproach by specifying variable specific resolutions for a di verse set of controlled variables.
we found that the variablesin our case study called for unique variable specific resolu tions and we were able to express all desired resolutions.moreover we were able to express resolutions in which allfeatures contribute to the resolution result and not just thosewith the highest priority.
in the vehicle steering example every feature s assignment tocar.steeringis used to com pute the variable s next value.
thus all features win inthat resolution.
.
scalabilityone of the major advantages of our approach is the ab sence of a required priority scheme among features.
thedeveloper still has the option to define priorities betweentypes of actions as we did in our examples by grouping ac tions into safety and non safety categories.
however thisclassification is coarse and does not require a total or par tial ordering on all features.
when adding new features orremoving existing features from the system the developerneed only determine to which category the feature s actionsbelong.
classification decisions do not need to be revised asnew features are added to the system.additionally the developer does not need to know howmany features modify each controlled variable.
our resolu tion approach is agnostic to the number of features in thesystem as well as the number of feature interactions thatarise from their composition.
thus features can be devel oped independently and can be added to the system incre mentally.
if a feature introduces a new type of controlledvariable the developer does need to introduce a new reso lution module.
however our case study suggests that theintroduction of new controlled variables are rare we discov ered a total of only controlled variables of which aremodified by more than one feature in a group of auto motive features.
the number of resolution modules that thedeveloper writes can be further reduced by identifying theset of controlled variables that are assigned values by mul tiple features and writing resolvers only for these controlled561variables rather than for all controlled variables.
a simplestatic analysis can identify these variables.
.
threats to validitythe requirements documents on which we base our resolu tions provide information on a subset of automotive features.we specified what we considered to be appropriate resolu tions to conflicting assignments made by these features.
it ispossible that other features could modify the same variablesin a way that would warrant a di erent resolution strat egy.
this would weaken our claim that the addition of fea tures does not impact the resolution strategies.
these claimsshould be validated with future case studies.
.
future research directionssome of the resolutions we considered suggest that thereare dependencies among controlled variables.
for example brake.hydralicpressurea ectscar.acceleration.
our res olution does not consider dependencies or interactions be tween controlled variables.
we conjecture that such interac tions could be addressed by clustering related variables andresolving their conflicts or by imposing a partial ordering oncontrolled variables and using the resolutions of some vari ables as inputs to the resolver modules of others.
we leavethese investigations to future work.there is also the possibility for race conditions when fea tures execute at di erent speeds or asynchronously.
forexample actions by the features abs and cruise controlcan produce a shuddering e ect on the vehicle by bouncingback and forth between increasing and decreasing the vehi cle acceleration.
it may be possible to mitigate flip flops orreversals in assignments by remembering a short history ofresolutions and taking them into account when computingnew resolutions.
we leave the investigation of this problemto future work.while situation calculus and golog serve as an intuitiveproof of concept implementation of our resolution modules we believe there to be simpler and faster languages to accom plish the same goal.
by relying on a deterministic language many of the proofs in the analysis section would be mademuch simpler.
future research in this area will be to developand refine a more appropriate implementation language.
.
related workthe majority of related work on resolving feature inter actions relies on a priority ranking among features .
priority based approaches need a total or par tial ordering on features to support the resolution strategy.when a new feature is developed its place in the prior ity ordering must be determined making it di cult to addnew features.
in the case of a conflict only the actions ofthe highest priority feature are executed blocking the be haviour of all other features.
our resolution considers allenabled actions regardless of feature priority.some priority based approaches o er finer grained reso lutions.
laney et al.
propose resolutions in whichpriorities are considered at the granularity of individual fea ture requirements.
during feature composition the devel oper specifies which aspects of a feature s behaviour maybe left unsatisfied in the event of a conflict.
interactionsare resolved on a case by case basis.
thus this approachdoes not address the the feature interaction problem thenumber of interactions to consider resolve and verify is po tentially exponential in the number of features.
in addition the resolutions are win lose in that only the highest priorityrequirements are satisfied in case of a conflict.precedence based resolution strategies in whichfeatures are executed in a specified order display similarproblems to priority based approaches.
features are given atotal or partial precedence ordering and the task of deter mining a precedence order fornfeatures requires that thedeveloper consider up ton!
orderings.some work has been done to mitigate the task of spec ifying priorities or precedences among large collections offeatures by categorizing features and using automateddetection of feature interactions to find acceptable order ings .
however these approaches still su er from course grained resolutions based on feature priorities and o er onlywin lose resolutions to feature interactions.gri eth and velthuijsen reduce a developer s work by re solving conflicts through automated negotiation .
thegeneral idea behind negotiation based resolution is to o eralternative feature behaviours in the event of a conflict tomaintain the essential intent of the feature developer.
thisapproach has been applied to multi agent systems us ing situation calculus as the action language.
negotiationrequires multiple rounds of communication between negoti ating agents that act on the behalf of features.
many safety critical systems have strict timing requirements and cannota ord of multiple rounds of communication.
our approachresolves interactions in a single multi phase execution step by calculating variable specific resolutions to conflicting as signments.
these calculations are fast and each resolver isindependent so all resolvers may execute in parallel.
fur thermore features themselves do not need to interact witheach other.
this promotes feature modularity and oblivi ousness key attributes of feature oriented software devel opment.
.
conclusions and future workwe have presented an approach for resolving feature in teractions that addresses key aspects of the feature interac tion problem by providing means for developers to specifyan appropriate resolution strategy for each controlled vari able rather than for each possible feature interaction.
ourapproach exhibits several advantages the developer of a re solver module does not need to be aware of the number offeatures in the system and there is no need to impose apartial ordering on features.
this eases the task of addingfeatures to the systemwe show that the desired resolution for a controlled vari able depends on the roles that the variable plays in over all system behaviour.
our approach allows for resolutionstrategies that are tailored to the specifics of each controlledvariable.
we provide evidence in the form of a case studythat di erent controlled variables warrant di erent resolu tion strategies.
.