symmmu symbolically executed runtime libraries for symbolic memory access anthony romano ajromano cs.stanford.edudawson r. engler engler cs.stanford.edu department of computer science stanford university stanford ca usa abstract symbolic execution calls for specialized address translation.
unlike a pointer on a traditional machine model which corresponds to a single address a symbolic pointer may represent multiple feasible addresses.
a symbolic pointer dereference manipulates symbolic state potentially submitting many theorem prover requests in the process.
hence design and management of symbolic accesses critically affects symbolic executor performance complexity and completeness.
we demonstrate a symbolic execution extension the symmmu which separates access dispatch mechanism from policy by servicingmemory accesseswith symbolicallyexecuted runtime software handlers.
this runtime code concisely represents access policies including pointer concretization address forking and symbolic indexing.
these policies are competitive with a baseline hard coded memory policy.
furthermore the symmmu cleanly supports handlers for profiling heap analysis and demand allocated symbolic buffers.
in practice the symmmu flags hardware validated bugs for over a thousand linux program binaries.
categories and subject descriptors d. .
symbolic execution keywords access faults cross checking heap violations testing shadow values symbolic execution .
introduction symbolic execution is a popular technique for generating program test cases.
these test cases represent interesting program features such as faults vulnerabilities or covered code.
generally symbolic executors explore a program by applying the target s instructions to a mix of symbolic and concrete data.
symbolically executed instructions manipulateexpressions e.g.
x y z as data.
these expressions require semantics beyond a traditional concrete permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden.
copyright is held by the owner author s .
publication rights licensed to acm.
acm ... .
.
model.
notably an executor must dispatch memory accesses to both symbolic and concrete pointers.
a memory access is symbolic if its address expression contains a variable.
to illustrate figure demonstrates some symbolic accesses in the c language.
under symbolic execution the function faccesses memory data with two symbolic addresses s ands both covering all of the array s. initially sis zeroed.
assigning to the symbolic s makes all values in sdepend on wsince any element may absorb the symbolic write.
the following symbolic read s returns an expression containing the symbolic read indexrand the symbolic write index w. continuing to build onswith symbolic accesses creates large expressions which eventually overwhelm the executor s satisfiability solver.
a large body of work discusses symbolic execution and related memory access techniques.
all symbolic executors must handle symbolic accesses some policy applies constraints optimizations or analysis on the access.
such policies are built into the executor and must contend with complicated low level details.
we claim access policy belongs in a symbolically executed runtime library.
this paper presents a symmmu a runtime memory accessdispatcherforsymbolicexecution.
asymmmureroutes accesses to a runtime library which evaluates symbolic state in situ.
runtime libraries meet desirable criteria varietyof access policies such as which addresses are accessed and how those accesses are structured and analysis policies such as heap violation checking and execution on demand allocated symbolic buffers.
simplicity of implementation.
library code is short and core system changes are non invasive.
performance equaltoorbetterthanahard codedsymbolic executor memory access dispatcher.
this system makes several advances over the current state of the art.
at a design level it cleanly separates mechanism library call out for memory accesses and policy library implementation of access resolution the symmmu supports six well known symbolic access policies with few lines of code.
to our knowledge the symmmu s profiler which symbolically tracks address hits and heap analysis which finds over a thousand heap violations are the first applications of symbolically executed shadow memory.
additionally it is the first system to test unmodified machine codelibrarieswithdemandallocatedsymbolicbuffers which we use to find functional differences among several distinct libcimplementations.
finally results are tested independently of the symmmu to confirm the symbolic execution 1chars ... 2charf void int r sym range in t w sym range s return s line new expression ... if w ... if w read r if w ... if w figure symbolic memory access example code and its intermediate expressions.
agrees with physical hardware this produces thousands of high confidence faulting test cases by automatically pruning false positives.
the rest of this paper is structured as follows.
section discusses background for memory accesses and symbolic execution.
section describes the symmmu memory access dispatch mechanism in the context of a symbolic executor s state memory subsystem.
section continues by detailing several policies and analysis techniques supported by the symmmu system.
section evaluates the implementation of the dispatch and policies with benchmarks and a large set of linux programs.
finally section concludes.
.
background thissectionprovidesbackgroundinformationonhandling memory accesses symbolic execution systems and a formal description of symbolic memory accesses.
.
related work the symmmu touches a wide range of memory access translation topics.
at a low level address translation in hardware memory management units mmus and operating systems virtual memory have software controlled adjustable policies.
for software testing memory access instrumentation plays an important role in dynamic analysis.
allsymbolicexecutorshandlesymbolicaccessesbutmemory subsystems and analysis specialization differ across systems.
theusefulnessofsoftware definedmemorytranslationhas long been acknowledged.
risc architectures such as mips and sparc provide mechanisms for software translation lookaside buffer tlb handling accesses fault into software handlers which map virtual addresses to physical addresses.
software tlbs have a large design space and varying performance characteristics .
operating systems designers also recognize the importance of customization with virtual memory page faults .
the symmmu tlb mechanism .
.
shares a similar interface to software tlbs.
many dynamic program analysis algorithms rely on custommemoryaccesshandling.
metadataforthesealgorithms isoftenstoredinshadowmemory .
thismetadataincludes lock sets vector clocks heap allocation and information flow .
section .
describes a symbolic extension of shadow memory for partial heap checking.
the symmmu supports and extends prior work on symbolic execution.
despite its intrinsic capability to expresssymbolic policies symbolically executed runtime code has primarily only modeled specific system environments rather than core system functionality.
symbolic access policies include pointer concretization .
.
prioritized concretization .
.
symbolic indexing on objects .
.
and variable creation .
.
.
another policy tags floating point expressions to report errorsondereference .
othersystemslazilyinitializeordemand allocate accesses on symbolic pointers .
.
woodpecker can instrument accesses like a symmmu but only with built in checkers.
likewise fie s memory smudging and special memory io regions could be expressed as symmmu policies but are built into the executor.
.
symbolic execution and memory accesses a dynamic symbolic executor dispatches instructions to advance symbolic program states.
each state has an address space data memory and other resources.
when an instruction must dereference state memory for a load or store the executor issues a memory access to a software memory management unit that controls the state s address space.
a memory access is defined by a tuple s s w i v .
the access tuple consists of a state s including its address space and constraints a base pointer s the access width win bytes the access instruction i and an optional write value v. the access width wand instruction iare single valued concrete data.
the write value vand pointer sare expressions which may be symbolic.
symbolic accesses require formal attention.
let a symbolic pointer sbe an element of the set of pointer width expressionsonbit vectors.
accessinganaddressspacethrough sassumes the constraints of the issuing state s. when sis a symbolic pointer p s denotes pis a feasible concrete value for s i.e.
s p is satisfiable given swithp n .
ifpfeasibly maps into s s address space then p s. for a range of pointers p p n the subset relation p p n s is shorthand for the existence of a feasible solution for the conjunction p s ... p n s. any address not mapped in a state s s address space is a bad address for s. typically an access to a bad address is flagged as an error with an accompanying test case.
if the test raises a memory access fault under native execution then the test models a true bug.
symbolic accesses invoke a satisfiability solver to detect badaccesses.
theexecutorissuessolverqueriestodetermine whether a symbolic access is in s. an access s s w i v belongs to exactly one of three categories valid.
no faults p s p p w s. invalid.
all faults p s p p w ne ationslash s. contingent.
some faults p1 p2 s where p1 p1 n s p2 p2 n ne ationslash s. contingent accesses tend to impose the most overhead.
a complete symbolic executor finds all permissible accesses and generates at least one test case for a bad access.
to find non faulting accesses a solver call is submitted for every feasible memory object to check for pointer inclusion.
remaining feasible pointer values imply a bad access.
.
a symbolically executed mmu this section outlines the design and implementation of a symmmu for klee mc a modified version of the klee 248figure a memory object shared among three state s an object state shared between two states and an unshared object state.
symbolic executor.
first address space and state memory structures are given.
next the symmmu s dispatch mechanism and interface are discussed.
.
symbolic executor the symmmu implementation is based on several off theshelf components.
the symbolic executor core is a modified kleellvm symbolic interpreter a dynamic binary translation dbt layer based on valgrind .
.
translates x86 machine code basic blocks into llvm functions.
kleesymbolically executes these functions over a symbolic linux system call model to generate test cases containing of variable assignments.
the binary front end allows for cross checkingthesetestcasesagainsthardwareinsection5.
solver queries are submitted from kleeto the latest repositoryversionofstp throughitssmtlib1textinterface.
.
address space structures the symbolic executor stores target program information asacollectionofstates.
astaterepresentstheprocessimage of a partiallyexecuted path.
the statememory organization is borrowed from kleeand is a typical design.
figure illustrates the relationship among states address spaces and state data memory.
a concrete address space structure maps bit memory addresses to object pairs for each state.
object pairs consist of an object state and a memory object.
an object state is a copy on write structure which holds the state s memory data values.
every read and write accesses some object state.
a memory object is an immutable structure which tracks the concrete address and length of an object state.
the address space manages concrete addresses and lies below the symmmu symbolic addresses require special policies which issue solver calls.
.
soft handlers the symbolic executor dispatches memory data accesses through its memory management unit mmu subsystem.
the original kleeinterpreter uses a hard coded mmu that finds access violations resolves concrete pointers forks on multi object pointers and issues object wide symbolically indexed accesses.
symbolic data and queries must be explicitly managed in the executor however so augmenting such a policy is a delicate procedure.
in contrast the symmmu inklee mc bypasses these details by forwarding memory accesses to symbolically executed runtime soft handlers.
symmmu soft handlers are selected by a command line argument.
the executor loads a selected handler written in c compiled to llvm intermediate representation bitcode from a llvm bitcode file.
a handler translates either symbolic or concrete accesses translating both symbolic and concrete accesses with the symmmu uses at least two separatehandlers.
multiplehandlerscanbeconfigurablystackedfigure the symmmu pointer handling path.
table trap functions for a handler mwith access bit widths w soft handlers action mmu init m initialization.
mmu cleanup m add final constraints to test case.
mmu load w m p load from pointer p. mmu store w m p v storevinto pointer p. mmu signal m p signalspwa s made symbolic.
based on an input file a handler passes control down the sta ck by calling executor controlled function pointers.
.
.
library interface the executor forwards accesses to a library provided handler through a standardized function interface.
forwarding directs program state to handler bitcode with an implicit function call the interface is listed in table .
for a handler m the interface functionsare suffixed with mto distinguish a mong multiple handlers.
the handler initializes internal structures with an optional function mmu init which runs prior to executing the target program.
accesses forward to themmu load w andmmu store w functions based on the access width w. the handler defines mmu cleanup to impose additional constraints on a state prior to generating its test case.
when marking memory as symbolic the executor notifies the handler through mmu signal.
special intrinsic functions exposeexecutorresourcestothehandler each intrinsic makes at most one solver call to minimize time spent in non preemptible executor code.
.
.
access forwarding figure shows the dispatch process for accessing memory with a symmmu.
when the executor evaluates a memory access instruction it issues an access to the pointer dispatcher.
whether the pointer is a concrete i.e.
numeric constant or a symbolic expression determines the access path the executor forwards the state to a handler depending on the instruction and pointer type.
symbolic addresses always forward to a symbolically executed runtime handler.
concrete addresses if ignored or explicitly masked follow a built in fast path.
.
.
concrete addresses some memory analysis policies such as heap access checking must track accesses on concrete pointers alongside symbolic pointers.
however concrete accesses are necessary to symbolically execute symmmu handler code so care must be taken to avoid infinite recursion.
concrete translation through the symmmu is temporarily disabled on concrete 249table runtime primitives for memory access primitive description klee sym hash s hash expression sto constant.
klee wide load w s load with symbolic index s. klee wide store w s v storevto symbolic index s. klee enable softmmu enable concrete redirection.
klee tlb ins p default accesses to object at p. klee tlb inv p drop defaulting on object at p. accesses to limit recursion.
for each state a translation ena bled bit controls soft handler activation.
if the bit is set concrete accesses forward to the runtime.
the translation enabled bit is unset upon entering the handler forcing fast path translation for subsequent accesses.
prior to returning the handler re enables symmmu translation by setting the translation bit with the klee enable softmmu intrinsic.
.
.
translation lookaside buffer calling handlers for every concrete access is slow.
fortunately if most concrete accesses are irrelevant to the handler then the symmmu overhead is amortizable.
on an irrelevant access where the address s entire memory object is irrelevant the handler inserts the range into a software tlb so subsequent accesses follow the concrete fast path.
a runtime programmed tlb controls concrete fast path forwarding.
the concrete tlb maintains a fixed number of address ranges to pass to the fast path.
a concrete handler ignores accesses by registering address ranges with the tlb.
the handler reclaims accesses by removing address ranges from the tlb.
each state has its own private tlb because state interleaving interferes with reproducing paths flushing a global tlb on state reschedule alters the instruction trace past the preemption point from extra tlb misses.
.
access policies and analysis our symmmu supports a variety of access policies.
for symbolic accesses such policies affect solver overhead state dilation and testing completeness.
capturing all accesses lends itself to extending the executor with further analysis.
shadowed memory on accesses enables purely runtime controlled profiling and heap checking.
demand allocating memory buffers on access gives unconstrained execution.
.
symbolic access translation a symbolic access may resolve to multiple addresses.
the choice of access policy influences the performance and completeness of symbolic accesses.
we consider two types of policies partial and full.
partial policies transform pointers and check for properties but only occasionally dispatch an access and must be stacked.
full policies situated at the bottom of a handler stack always dispatch an access.
.
.
range checking a symbolic pointer spotentially generates many states because it may be unbound.
following through on every precise address where an unbound pointer access lands is expensive and usually uninformative it suffices to know the setoffeasiblepointers p p s islarge.
rangechecking finds widely stray accesses if sfeasibly exceeds a sensible distance weuse256mb fromsome p s thentheaccess is flagged otherwise the access continues down the stack.mmuops sextern rangechk define ma xrange ptrdiff t 0x10000000 static int te stptrinvalid in tptrts intptr tp klee getvalue s ptrdiff td s p return s x1000 d maxrange d m axrange uint8 tmmuload8rangechk vo id s if testptr invalid in tptrt s kleeuerror bad range !
ptr .
err return mm uopss rangechk .
mo next moload8 s figure range checking handler for bit loads.
uint8 tmmuload8uniqptr vo id s intptr tp si i ntptr t s p klee getvalue si ge t p in s kleeassume eq si p bi nd s p return u int8t p figure address concretization for bit loads.
fig ure lists an example partial symbolic bit load softhandler mmu load 8 rangechk which checks the range of a symbolic pointer s. first the handler issues a solver request in testptr invalid to find a p s then builds a symbolic range check for s. when scovers an extreme range the state forks on the ifinto an out of range and an in range state because testptr invalid s is feasibly both true and false.
the out of range state is assumed to fault and is reported.
the in range state proceeds down the stack to the next handler via the function pointer mo load 8. .
.
constant symbolic pointer resolution concreteaccessesarecheaperthansymbolic.
ifthestate s path constraints for a symbolic address to have exactly one solution every future access can be concrete.
when p1 p2 s p1 p2 constant symbolic pointer resolution replaces every swithp1and dispatches the concrete access.
.
.
create variable relaxing precise memory content can simplify symbolic access complexity with state overapproximation.
in this case reading from a symbolic pointer sreturns a fresh symbolic variable v. to reduce overhead our implementation keeps a mapping from old symbolic pointers to their variables.
this policy is unsound suppose p s .v ne ationslash p but similar strategies appear elsewhere .
.
.
pointer concretization a symbolic access on sisconcretized by choosing a single p s to represent s. the executor calls its satisfiability solver with the constraints for a state sto resolve a concrete value p s .
adding the constraint s p tos s constraint set binds ptos all subsequent accesses logically equivalent to sbecome logically equivalent to accesses to p. this incomplete policy misses every valid address p s wherep ne ationslash p but it is fast used in practice and makes for straightforward policy discussion.
figure lists an example full bit load soft handler which concretizes the access pointer.
an bit symbolic load access enters through mmu load 8 uniqptr.
a concrete value p s is retrieved with klee get value s the sole solver 250query .
next the handler binds ptosw ith the constraint p s through klee assume eq s p .
finally the handler safely dereferences p ifpis bad it is detected on the concrete path and returns the value to the target program.
.
.
fork on address forking a state for every p s explores all feasible accesses.
instead of calling klee get value once .
.
forking on address loops until all feasible addresses are exhausted.
since each feasible address consumes a solver call and a new state this policy is costly when s is large.
boundingexploredfeasibleaddressesreducesoverheadbut sacrifices completeness.
in order to shed some feasible address the handler chooses addresses based on desirable runtime or program properties.
we implemented two bounded policies in addition to complete forking one caps the loop to limit state explosion and the other forks on minimum and maximum addresses to probe access boundaries.
.
.
prioritized concretization blindly concretizing a symbolic read access potentially overconstrains the fetched value.
prioritized concretization searches for feasible addresses p s such that the value atpis symbolic.
if there is such a p thensis concretized top and the symbolic value is returned.
.
.
fork on objects the default kleepolicy and similar policies forks onfeasiblememoryobjects issuingobject wideaccessesover symbolic arrays.
when a symbolic access falls within a spatially local region e.g.
a page the access can be efficiently foldedintoanexpressionasinfigure1.
assumingthislocality forking for every feasible memory object with symbolic indexing reduces the total forked states.
the fork on object policy forks a state for every memory object covered by a symbolic memory access at s. for every memory object a wide memory access symbolically indexes the object state.
wide write accesses create large expressions containing update lists for the object at the time of write.
most memory objects are page sized so our implementation uses a faster and simpler forking algorithm than klee s binary search.
objects are enumerated by forking on unique page pointers p s .
if a feasible object is smaller than a page the handler iterates over objects in order until the next page boundary.
wide accessesareexplicitlyconstructed thehandleruses klee wide intrinsics to issue symbolically indexed accesses.
.
.
if then else reads asymbolicindexedreadonanobjectstateleadstounnecessary array overhead in the solver when the feasible pointer set size s is much smaller than the object.
if then else readstranslateanaccessintoanif then elseexpressionwhen the sets is small.
when the number of addresses is bounded by nforp1 ... pn s andpi pj i j the expression e1defined by the recursive relation ei if s pi pi ei en pn is returned by the dereference and the disjunction s p1 s p2 ... s pn joinss s path constraints when s nfor soundness.figure retrieving a disjunction of shadow values for a symbolic address.
.
shadowing memory a shadow memory analysis algorithm computes metadata from memory accesses and stores it to a mapping the shadow memory of addresses to features.
sincethesymmmucontrolsmemoryaccesses shadowmemoryisanaturalextension.
weuseashadowmemoryruntime library for two additions to the executor memory profiling and heap checking.
the profiler increments a per word shadow counter for every access.
the heap checker tracks program memory allocation status to detect heap violations.
.
.
runtime structures figure illustrates the symmmu shadow memory structure.
symbolic shadow memory is a map s a vfrom addresses to shadow values.
in the figure a symbolic access on two feasible bytes at areturns a shadow expression s a representing shadow values for both feasible bytes in a single state.
the hashed page number of aindexes into an array of page buckets.
each bucket holds a list of demand allocated shadow pages corresponding to pages of data memory.
retrieving s a uses a wide access so states only fork per shadowpage.
sincetheshadowmemorycodeisalibrary the executor transparently handles all constraints and states.
analternativeshadowmemorydesign usesatwo level page table on bit addresses.
an address indexes the table throughtwo levels of indirectionto retrieve a shadowpage in constant time.
in practice the symmmu shadow memory buckets remain small so linear time overhead is negligible comparedtotheextralevelsofindirectionorauxiliarytables needed for bit addresses.
likewise memory objects are usually page sized so wide accesses split into multiple states regardless of the data structure.
.
.
access profiling anaccessprofilercanhelpaprogrammerfindmemoryhot spots or understand cache behavior.
we developed a profiler to count symbolic accesses on each address.
the profiler keeps shadow counters for memory addresses on every state every symbolic access increments a setof feasible counters.
unlike a traditional profiler symbolic shadow state influences the profiler results.
for instance a complete symbolic bytestoreon s p p touchestwomemorylocations pandp .
storing to two feasible memory locations updates two shadow counters within a single state the shadow 251counters become symbolic via symbolic write.
the profiler is free to choose any feasible counter value.
in our implementation the profiler greedily increases memory coverage by choosing p s whens p and assuming s x on path termination when feasible for all addresses x. profiling also demonstrates the importance of guarding against recursion.
a symbolic access leads to a shadow counter update on multiple feasible shadow counters the shadowcounteraddressissymbolic.
incrementingthecounter through a symbolic pointer triggers another profiling event in the software handler causing an infinite loop.
to prevent hanging a flag guards against profiler handler reentrance.
.
.
heap checking heap access violations are common errors in system programs.
a program accesses freed or uninitialized heap data with little immediate consequence but eventual state corruption.
dynamic analysis algorithms detect these errors at the point of violation with shadow memory.
the symmmu extends the memcheck algorithm to binary symbolic execution with incomplete heap information.
symbolically processing heap memory accesses exploits pointer reach knowledge lost to concrete test cases.
although symbolically derived tests are compatible with traditional heap violation detection algorithms concrete testing alone leads to false negatives.
consider a read from abufferb initializeduptosome n atasymbolicoffset i n. for a concrete test imay be chosen such that b is initialized i n missing the error.
under symbolic analysis b is both initialized and uninitialized so the error is modeled.
the heap checker models the heap as the program runs.
a set of disjoint address ranges heap blocks a a n h tracks a state s current heap h. when a program allocates a heap block b the checker adds btoh.
if a pointer p s is inh b h. p b thensis a feasible heap address.
an access is checked by observing the shadow value for each accessed byte address.
each byte is assigned two bits of shadow state representing its heap status.
each byte is assigned one of the following shadow values ok. access is safe may be a heap data.
uninit.
heap address with uninitialized data.
free.
former heap address.
figure illustrates the finite state machine which manages the heap status.
initially accesses default to ok the tracked heap is set to empty.
to avoid overhead from repeatedly calling the symmmu long contiguous okranges are inserted into the concrete address pass through tlb.
when the program acquires a pointer pthrough an allocation function e.g.
malloc n the heap checker intercepts the call records the allocated block and marks the shadow memory for p p n asuninit.
when pis deallocated with a callfree p the heap checker retrieves p s length n marks p p n asfree and drops the p p n record from h. the heap checker detects three heap violations dangling accesses.
an access to freed heap memory is a dangling access.
this violates the heap discipline because all heap accesses from client code should reference allocated memory if a program accesses freed memory it may corrupt state or retrieve an unexpected value.
a handler reports a danglingaccesswheneveranaccesshasa freeshadowvalue.
uninitialized reads.
the contents of the heap are undefinedonallocation.
readsfromfreshlyallocateduninitialized memory produces undefined behavior.
if a read accessfigure the memcheck shadow state machine.
po inter maps to uninit the heap checker produces a test case for an uninitialized read.
double frees.
each heap allocation pairs with at most one deallocation.
deallocating memory twice consecutively causes the heap checker to terminate the state and report a double free.
early termination has a performance benefit by skipping the double free detection error path in libc.
.
unconstrained pointers unconstrained execution tests functions withoutpathcontexttobypassthereachabilityproblem.
instead of trying to reach a specific function through a path from the beginning of a program the symbolic executor jumps directly to the target function lazily initializing pointer arguments with symbolic data.
these unconstrained pointers initializeonfirstaccess expandedasneeded arerelocatable and require no type information.
we describe handlers written for the symmmu which manage unconstrained pointers.
unconstrained pointers are special symbolic pointers with no immediate concrete address that map to demand allocated memory.
all pointers passed to a target function for unconstrained execution are unconstrained.
to avoid false positives for memory access faults the executor optimistically assumes symbolic pointers are valid.
initially accessing an unconstrained symbolic pointer udemand allocates unconstrained memory buffers with symbolic data to backu.
these buffers have concrete physical length associated with the allocated backing buffer as well as a symbolic virtual length based on precise observed range of access which facilitates expansion.
subsequent accesses to uretrieve the same data through a consistent translation map.
the translationmap routes structurallydistinct but semantically nearby unconstrained pointers to the same buffer.
finally unconstrained pointers resolve to concrete pointers to generate a test case.
.
.
translation entries to make unconstrained accesses optimistic rather than unbounded and contingent the symmmu handlers must translate unconstrained pointers to buffers mapped into the state s address space.
figure shows the organization of this translation.
from the top unconstrained pointers map into atranslation table by expression hash.
the translation table points to translation entries which each describe an unconstrained pointer s demand allocated memory buffer.
thetranslationtablemapsunconstrainedpointerstotranslation entries by address expression hash.
a hash functionh e 64from expressions to bit values maps a symbolic address uto the table for solverless lookup.
sinceuis symbolic it must have some variable subexpression e.g.
select i a reads the symbolic array aat indexi .
the hash hfunction relies on the idea that dis252figure unconstrained pointer structures.
tin ct variable subexpressions imply feasibly distinct pointers.
for example u select x andu select x giveh u ne ationslash h u because the values are feasibly unrelated.
in contrast add select x and add select x refer to one base symbolic pointer uand therefore hash equally the difference is a small constant offset.
a translation entry defines a demand allocated buffer for an unconstrained pointer.
the buffer centers around a pivot u the unconstrained pointer of the first access.
the entry holds the buffer s concrete pointer pand its current concrete radiusrc.
for precise bounds the entry tracks the minimum uminand maximum umaxaccess pointers.
the difference between uminandumaxdefines a symbolic radius r. taking all entries the ith entry has a pivot uiand a symbolic radius ri.
pivots are ordered by entry u0 u1 ... u k when resolving to concrete addresses on path termination.
.
.
demand allocation unconstrained demand allocation has two phases.
first an initial access to a distinct unconstrained pointer creates a translation entry and buffer around the pointer.
next future accesses near the pointer expand the buffer keeping values and constraints from prior accesses.
buffer initialization.
an access to a new unconstrained pointeruallocates space so future accesses are consistent.
first the soft handler determines uis distinct and distant from previously accessed unconstrained pointers.
next the handler creates a translation entry pivoted around uand allocates a buffer centered about u. finally the access is servicedthroughthebufferandthetargetprogramproceeds.
ifuhas no translation the runtime allocates an unconstrained buffer.
first a translation entry keyed by h u is inserted into the table.
a small initial buffer bytes filled with unconstrained symbolic data is allocated to a fresh translation entry.
subsequent accesses around uroute to the buffer through the access handlers.
buffer expansion suppose an access to a pointer u based on an unconstrained pointer sexceeds the bounds of the initially allocated buffer.
by the optimistic access policy the buffer is extended when the distance from the buffer is reasonably short.
there are two cases the fast caseh u h u and the slow case h u ne ationslash h u .
the fast caseh u h u suffices to explain buffer extension the h u ne ationslash h u case is handled in section .
.
.
whenh u h u theruntimeusesthetranslationentry foru.
when the distance between uandu is less than the buffer radius u u rc there is no need to extend the buffer.
otherwise the buffer is copied to a new buffer witha radius of rc the buffer pointer and rcare updated in the translation entry to reflect the expansion.
.
.
aliasing two unconstrained pointers uiandujmay map to the same buffer ui uj ri but hash unequally h ui ne ationslash h uj .
having distinct translation entries for uiandujpotentiallyassignsmultiplevaluestooneaddress.
thisisaliasing we outline our method for efficiently resolving aliases.
an access to an unconstrained pointer uwith an untranslated hash h u undergoes alias resolution before acquiring a translation entry.
first the pointer uis tested for inclusion in the unconstrainedarena uc min ucmax with an and ma sk ifuis unconstrained then ucmin u ucmaxis s atisfiable.
next the runtime tests translation entry inclusion feasibility to resolve the entry for u. inclusion testing relies on the pivot ordering u0 ... u nand entry ordering ui ri ui ri uj rj uj rj wheni j. hence k argmin i u ui ri implies u uk rk uk rk .
if kexists the runtime updates the translation table to point h u to the entry for h uk .
inclusion testing may accrue additional aliases by forking new states where ui ri u ui rifori k. if there is no feasible entry h uk is assigned its own translation entry.
.
.
concrete address assignment a dereferenced unconstrained pointer eventually binds to a concrete address.
the runtime postpones address assignment by translating unconstrained pointers to a backing buffer on the fly.
to produce a concrete test case the runtime uses the solver to assign concrete addresses to pointers.
premature address assignment unnecessarily constrains unconstrained pointers masking otherwise feasible paths.
considerthe memcpylibrarycallwhichcopiesvaluesin memory from a pointer u1to a non overlapping location starting at pointer u2.
a na vememcpyloads a byte from u1 stores it tou2 then increments each pointer.
however this implementation has needless overhead multi byte accesses reduce the total iterations by at least half.
such multi byte accesses incur additional cost for unaligned addresses.
hence a fast memcpyuses distinct code depending on the alignment i.e.
the lower bits of u1andu2.
eagerly assigning concrete addresses to u1andu2drops the unaligned corner cases.
the pivots u0 ... unare assigned concrete addresses on path termination.
the handlers control assignment by ordering pivots at time of first access and bounding addresses within the unconstrained arena .
for the b ase case u0 the constraints ucmin u0 r0an du0 r0 ucmaxhold.
in general inserting the kth pivotuktakes the constraints uk rk uk rkanduk rk ucmax.
a c leanup handler minimizes rkto keep buffer sizes small.
.
ev aluation this section evaluates the symmmu against the criteria set in section .
simplicity of the symmmu is quantified in terms of the implementation s total lines of code.
dispatch microbenchmarks and a comparison of discovered access faults on linux programs demonstrate the symmmu s performanceiscompetitivewithabuilt inhard codedmmu.
policy microbenchmarks heap checking on programs and unconstrainedexecutiononlibrariesshowthesymmmuflexibly supports a useful variety of access and analysis policies.
253table lines of code for mmu components mmu component loc.
interpreter built in klee mmu built in symmmu instrumented symmmu shared mmu code runtime range checking constant symbolic resolution pointer concretization fork on address prioritized concretization fork on objects if then else reads create variable shadow memory access profiler heap checker unconstrained pointers .
implementation complexity fig ure3showstheamountofcodeforeachmmutoquantify relative implementation complexity.
the line counts were calculated with sloccount on the relevant source files.
the table is split between executor code c compiled to binary and runtime code c compiled to llvm bitcode .
of note the baseline kleemmu lines needs slightly more code than the symmmu lines implementation suggesting the symmmu is simpler to implement.
.
dispatch mechanism the design of the symmmu dispatch mechanism strongly influences its performance.
we use a microbenchmark to comparethebuilt insymmmuwithinstrumentationtoshow explicitsupportforasymmmuiscompetitivewiththebaselinekleemmu and superior to instruction rewriting.
furthermore wefindtheconcretetlbimprovessymmmuperformance on concrete workloads with low overhead.
.
.
access instrumentation we compared concrete access overhead among the baselinekleemmu the interpreter symmmu and an instrumented symmmu.
the instrumented symmmu replaces all target program loads and stores with runtime function calls which partition accesses as concrete or symbolic and forward to the appropriate handler.
each mmu was benchmarked withstrcpyon bytes repeated times in a program.
the baseline mmu and built in symmmu issued the same number of llvm instructions and used equal time.
the instrumented symmmu issued .
as many instructions and took .
longer to complete calling a handler on every program memory access is costly.
instrumentation is relatively slower so we only use the built in symmmu.
.
.
tlb to measure the cost of concrete symmmu handling we compared the performance among the fast path na ve handling and tlb assistance using the benchmark from section .
.
.
the concrete symmmu policy passes every con .
.
indexrindexstpcpystrcasecmpstrcatstrchrstrcmpstrcollstrcpystrcspnstrdupstrfrystrlenstrncasecmpstrncatstrncmpstrncpystrpbrkstrrchrstrspnstrstrstrtokstrxfrmtests over baselinetest cases generated by symmmu over baseline klee concrete forkaddr prconcrete forkobj ite createvar klee figure string microbenchmark testing speed up.
cr ete address to the built in fast path and the tlb is set to entries.
without tlb support the benchmark used .
as many instructions and .
as much time as the baseline mmu without concrete symmmu support.
with tlb support the benchmark dispatched .
as many instructionsandused1.
asmuchtimeasthebaselinemmu.
.
policy microbenchmarks a set of access intensive microbenchmarks measure the difference among symmmu policies and the baseline klee mmu.
each microbenchmark is compiled from c and symbolically executes one of standard libcstring functions for five minutes.
policy performance is ranked by generated tests over the baseline kleemmu i.e.
test case speedup .
the benchmarks frequently access symbolic string buffers stressing the mmu.
a symbolic buffer bspans two pages in length bytes to highlightforking on the fork by object policy.
two symbolic integers model offsets 1and 2into b another symbolic integer models string length e.g.
for strncpy .
two pointers p1andp2 withpk b k k pagesize givetwoin boundfeasiblyoverlappingpointers w hich are passed into the string function.
figure shows the test results.
a majority of benchmarks generate more tests than baseline more fewer .
conservatively most symmmu policies are no worse at completing paths than the baseline kleepolicy.
one exception is ite .
.
which submits many solver queries for feasible addresses before constructing an iteexpression.
on the other hand pointer concretization which should produce few tests sometimes outperforms baseline.
to explain the baseline forks all feasible states at once for a symbolic access issuing many queries.
by contrast the symmmu forks in the runtime so expensive accesses are preempted.
the inconsistent performance among policies and functions demonstrates the importance of policy variety since no one simple policy is best.
.
memory faults in linux programs tojudgetheeffectivenessofthesymmmuatscale weran bit linux programs taken from fedora for five minutes each under the symbolic executor to find memory access violation test cases.
these test inputs cause access faults in unmodified third party programs.
table shows the number of programs and test cases found by the symmmu to have memory errors using the 254table access faults found with symmmu error type programs tests range test symbolic load symbolic store concrete load concrete store total .
3500time s total queries shadowed symbolically accessed sitessymbolic sites versus time and queries for profiler benchmark time queries figure profiler benchmark performance.
kle epolicy .
.
binned by stack trace.
to be sure the results were true positives the table results were confirmed at the binary translation level through a test replay program based on the llvm jit.
for comparison the standard klee mmu flagged tests confirmed whereas the symmmu flagged tests confirmed by welch s t test the symmmu finds more faults than the hard coded klee mmu with confidence p .
.
two reasons explain the kleemmu s extra false positives first the kleemmu is poorly tested a few hundred llvm bitcode programs and second the kleemmu is intricate and difficult to get right.
similarly the symmmu pass issued .
solver queries over thekleemmu pass symmmu queries tend to solve faster.
.
profiler figure illustrates the symbolic profiler s cost for a simple benchmark.
the benchmark program tests the profiler coverage policy by looping over an array awithnelements writing to a where sis an array of symbolics s s assignment controls which elements of aare updated.
the shadow memory s granularity is configured to have a shadow word for each element in a. complete coverage of aimpliess contains all values between and n the profiler imposes these constraints on s. for overhead total solver queries grows linearly with respect to n. time for the benchmark exponentially rises with n peaking at seconds for elements at elements solver performance completely deteriorates and the benchmark times out after minutes.
.
heap violations the symbolic executor produces a concrete test case for every heap violation it finds.
since a test could be a false positive e.g.
from bugs in the tool it is important to automatically detect true positives.
unlike access faults heap violationsareinvisibletohardware.
sage forinstance table symmmu derived heap violations type testscode sites programs double free dangling access uninitialized read total tapebuffered read char shorthdr indes sizeof s horthdr filehdr cnamesize short hdr cnamesize filehdr cname ch ar xmalloc filehdr cnamesize cpiosafernamesuffix file hdr .c name .
.
.
char p safer namesuffix name .
.
.
sizetprefix len file system prefix len filename figure a tortuous heap read violation in cpio.
ha s special support to force crashes on heap violations.
to confirm errors without the luxury of faults the replay system feeds test cases with system call logs into an unmodified third party heap analysis tool valgrind memcheck.
replaying test cases under valgrind works through a combination of ptraceand iterative system call realignment.
the valgrind process runs the target program but is controlledbythetestreplayprocesswiththeoperatingsystem s ptracefacility.
the replay process intercepts valgrind s system calls a call is dispatched natively or intercepted and replayed.
two system models must be reconciled test cases use precise system call logs whereas valgrind rewrites and inserts system calls.
on interception if the requested systemcallmatchestheheadofthesystemcalllog thevalgrind process absorbs the log s side effects.
otherwise the call forwards to the operating system.
the system call log initially synchronizes with valgrind by ignoring the first nsystem calls.
the value nis found by successively incrementing n to maximize the number of replayed system calls.
we checked linux programs from the host machine s x86 gentoo usr bin sbin directories symbolically interpreted for five minutes.
binaries were taken from the host machine because valgrind is sensitive to its host configuration.
table lists valgrind confirmed heap violations by number of tests code sites to control for faulty libraries and programs to control for noisy programs .
in total14247violationswere flaggedin 761programs valgrind confirmed .
of these tests.
valgrind and the executor may disagree for several reasons neither are bug free system calls fail to align and differing memory layouts interfere with system call replay.
regardless cross checking with a third party tool strengthens evidence of legitimate bugs.
figure illustrates the complexity of errors found by the heap checker.
this pared down example from cpio2.11spans three files it reads a buffer length c namesize from input short hdr allocates a buffer c name passes it around then reads the data.
if c namesize is prefix len relies on uninitialized data leading to undefined behavior.
.
unconstrained pointers explicitly modeling data structures for testing function arguments is tedious.
demand allocation on unconstrained 255pointers derives argument structure automatically.
we evalu ate symmmu unconstrained pointers on bare functions by symbolically generating test inputs for functions in several compiled libcimplementations.
these tests directly translate to c sources which serve as native test fixtures.
replaying the tests across libraries reveals implementation differences and fundamental bugs.
.
.
generating libc inputs testinputswerederivedbysymbolicallyexecutingcstandard library libc libraries with unconstrained pointers.
we tested functions from four up to date libcimplementations newlib .
.
musl .
.
uclibc .
.
.
and glibc2.
.
functions were symbolically executed by marking the register file symbolic and jumping to the function root unconstrained pointers are demand allocated on dereference of a symbolic register.
each function was allotted a maximum of five minutes of symbolic execution computation time and test cases.
since we intend to find differences between supposedly equivalent implementations only functions shared by at least two libraries were evaluated.
in total functions shared among at least two libraries exhibited unconstrained demand allocations.
.
.
c test cases to run unconstrained test cases natively test cases are first converted into c code.
the unconstrained buffer information is translated to a c source file then compiled into a binary program.
the binary dynamically loads the library and runs the target function with the test input.
the c test fixture programs operate as follows declare initial data from unconstrained buffers.
allocate memory buffers at given addresses.
copy initialization data into buffers.
load target function pointer from shared library.
call target function with symbolic register arguments.
print buffer contents and function return value.
every c test case assigns unconstrained buffer data to physical locations in the test process.
every non alias translation entry has an unconstraineddescriptor structure which stored in an array of entries.
the descriptor includes the buffer contents and length the start of the buffer the base of the memory segment to allocate and its length in pages.
following the target function call test results come from two parts of the process state the return value and the input buffers.
if a function returns a value that can be dereferenced the value is translated to a fixed constant to conservatively avoid mismatches from differing addresses across libraries.
whena functionmutatesitsarguments thevalues from the input buffers soundly reflect the updates.
.
.3libc differences replaying the unconstrained buffers through the libraries revealed many implementation differences.
the system detects subtle bugs in uncommon but standard cases which rely on pointer arguments.
complete bulk results suggest manypotentiallyserious althoughoftenbenign mismatches.
figure shows an example broken edge case detected with symmmu unconstrained pointers.
the figure lists a simplified internet host address parser adapted from the musllibrary which converts an ipv4 numbers and dots notation string s to a network byte order integer address d .
during symbolic execution the unconstrained buffer fills inunsigned long a for i i i a strtoul s z if z s z z !
.
!
isdigit s return if !
z break s z switch i case0 a a xffffff a case1 a a xffff a case2 a a 0xff a for i i i if a return char d a figure simplified ip address parser from musl.
table mismatches against glibcinvolving unconstrained pointers library mismatched functions total tested musl newlib uclibc total the contents for swith symbolic values.
the code works for four numeric parts e.g.
.
.
.
but misinterprets other valid addresses.
for example the class c address .
converts to0x01000001 instead of the expected address 0x0101.
table summarizes the mismatches with glibcusing unconstrained pointers.
we were careful to exclude functions which rely on volatile system state use structures with undefined width e.g.
stdiofile functions return no value or always crashed.
the percentage of mismatching functions is considerable given our conservative analysis.
one interestingclassofdifferencesreflectsarcanespecializedconfiguration details.
for instance glibc s timezone support causesnewlibandmuslto drift several hours when computingmktime uclibc crashes lacking etc tz .
furthermore inconsistent locale handling across libraries contributes to mismatched wide character data.
.
conclusion this paper introduced symbolic execution with symbolically executed memory accesses through a symmmu.
by separating memory access policy from the dispatch mechanism we have implemented a variety of access policies and memory analysis algorithms with minimal effort.
microbenchmarks demonstrate the importance of access policy for symbolic executor performance.
large scale comparative results indicate the symmmu finds more access faults with fewer false positives than a traditional built in access dispatcher.
overall this work suggests that forwarding memory accesses to a symbolically executed runtime is a beneficial design choice in a symbolic executor.