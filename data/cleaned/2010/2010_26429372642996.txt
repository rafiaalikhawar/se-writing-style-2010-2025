validatingajax applications using a delay based mutation technique yuta maezawa kazuki nishiura shinichi honiden the university of tokyo tokyo japan maezawa k nishiura honiden nii.ac.jphironori washizaki waseda university tokyo japan washizaki waseda.jp abstract the challenge of validating asynchronous javascript and xml ajax applications lies in actual errors exposed in a user environment.
several studies have proposed effective and efficient testing techniques to identify executable faults.
however the applications might have faults that are not executed during testing but might cause actual errors in a user environment.
although we have investigated static methods for nding potential faults that seem to cause actual errors if executed developers need to con rm whether or not the potential faults are actually executable.
herein we propose a mutation based testing method implemented in a tool called jspreventer.
even if the potential faults are not easily executable in a given environment our method mutates the applications until they are executable using two delay based mutation operators to manipulate the timing of the applications handling interactions.
thus jspreventer provides executable evidences of the not easily executable faults for developers if it reveals actual errors by testing the mutated applications.
we applied our method to real world applications and found actual errors that developers could debug to improve their reliability.
therefore jspreventer can help developers validate reliable real world ajax applications.
categories and subject descriptors d. .
keywords ajax javascript web application testing software validation .
introduction asynchronous javascript and xml ajax make web applications responsive .
ajax applications improve usability because they can handle user events on the client sh inichi honiden and hironori washizaki are also affiliated to national institute of informatics japan.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
ase september vasteras sweden copyright acm ... .
.
and asynchronously retrieve data necessary to dynamically update web page content without page transitions and this is crucial to attracting web users .
moreover the number of users exceeded .
billion as of june making ajax applications essential platforms for daily life.
the challenge to validating ajax applications arises from their event driven asynchronous and dynamic features.
despite concerted efforts by developers these features mean that not all possible behaviors of running applications can be predicted and these difficult to predict behaviors may be error prone.
to nd faults in ajax applications a statebased approach may be more effective than navigation modelbased code coverage or black box ones .
several state ofthe art studies on state based testing have effectively and efficiently found executable faults using the state space of ajax applications.
however the applications might have faults that are not executed during testing if the faults cause actual errors only when speci c conditions are met such as unexpected user operations web browser behaviors and network delays.
since it would be unrealistic to test the applications under all possible conditions these faults are not easily detectable even if developers use the state of theart testing techniques.
consequently users might encounter erroneous behaviors in the applications when a user environment meets the speci c conditions.
in our previous studies we have investigated static methods for identifying ajax application behaviors that seem to cause errors when speci c conditions are met e.g.
unable to login using a correct username and password because of improper use of asynchronous communications .
figure overviews our tool called jspreventer that is based on our previously proposed tool called jsverifier and these features are highlighted below.
implementation we assume that ajax design patterns which have been collected from observations in many real world ajax applications describe of the properties of the application behaviors expected by developers.
hence the implemented ajax design pattern information iadp info can be leveraged to verify whether an ajax application is running as expected.
extractor we assume that interactions with ajax applications can trigger changes in the application states.
interactions correspond to how user events asynchronous server responses and timeouts are handled.
because the source code contains these events and event handlers our extraction method statically analyzes the relationships among interactions via a call graph and constructs a nite state machine.
... ... ... ... ... ... ... ... ... ... ... ... faulty source code faulty interaction sequences extractor verifier implementation ... ... ... ... ... ... ... ... ... ... ... ... debugged source code ajax design patterns formulator interaction invariants iadp info finite state machines revealer debugging actual errors jspreventer test data oracles ... ... ... ... ... ... ... ... ... ... ... ... mutated source code implemented ajax design pattern information jsverifier previous work proposed extension figu re overview of jspreventer formulator and veri er using the iadp info as a guide our veri cation method instantiates interaction invariants and the applications handle their interactions in invariant occurrence and order.
whether the extracted nite state machine satis es the interaction invariants is automatically veri ed using the nusmv model checker1.
finally jsveri er obtains faulty interaction sequences from counterexamples of the veri cation results e.g.
fonload init onclick callback ...g and reports the presence of potential faults that seem to cause actual errors if executed.
although we claim that faulty interaction sequences are associated with potential faults reported by jsveri er the following two research questions remain unanswered.
rq1 can jspreventer reveal actual errors caused by potential faults in ajax applications?
this question can be answered by testing whether actual errors are due to potential faults.
however the existing testing techniques cannot reveal such errors because the potential faults might not be easily executable.
rq2 can jspreventer reveal these errors in a feasible amount of time?
although testing all possible scenarios in every environment should reveal all errors such a method would be unrealistic.
this paper presents a mutation based testing method to answer the above questions.
revealer jspreventer gets the faulty interaction sequences as input from jsveri er and tries to nd executable evidences of the potential faults.
however jspreventer may not easily execute ajax applications on the faulty interaction sequences because a speci ed environment does not meet speci c conditions to reveal actual errors due to the potential faults.
therefore we assume that an unexpected network latency may make the potential faults executable.
to emulate an unexpected network latency we de ne synchronous and asynchronous delay based mutation operators section .
although a program mutation technique is basically used for injecting arti cial faults we leverage the technique to allow jspreventer to make potential faults executable in the speci ed environment.
1nus mv.fbk.euthis is because our mutation operators change nonfunctional aspects of ajax applications but the applications can handle speci c server responses after a given delay time has elapsed.
we expect that testing the mutated source code with the given test data and oracles will reveal actual errors.
thus jspreventer provides developers with executable evidences of not easily executable faults during testing i.e.
subtle network delays are required for revealing actual errors.
debugging outputs from jsveri er and jspreventer i.e.
an extracted nite state machine identi ed faulty interaction sequences and revealed actual errors are used to debug the original source code until jsveri er does not report any potential faults.
jspreventer can then be used for validating reliable ajax applications.
compared with our previous studies the novelty of this study lies in revealing actual errors due to potential faults in ajax applications.
since ajax design patterns aim to improve the usability of ajax applications code violations against the design patterns do not always lead to actual errors being debugged.
additionally the faulty interaction sequences that are identi ed are counterexamples in the extracted nite state machine.
counterexamples in an abstract model can be spurious therefore it is important to reanalyze them in an actual system .
consequently we argue that the novelty of our study is that it helps developers validate ajax applications.
our contributions are a mutation based testing method that reveals actual errors due to potential faults in ajax applications.
de nitions of synchronous and asynchronous delaybased mutation operators.
an implementation of our method in jspreventer.
case study experiments on real world ajax applications demonstrating that jspreventer can reveal actual errors due to potential faults.
this paper is organized as follows.
section uses an example to illustrate the challenge of ajax application validation.
section describes our mutation based testing method while section evaluates our method.
section covers related work and section is the conclusion.
.
motivating example to illustrate the aforementioned challenge we implemented a simple ajax application called qasite2.
qasite is a typical q a website where users can ask and answer each other s questions such as in experts exchange3and quora4.
in implementing qasite we referred to the user action ondemand javascript and direct login patterns described in the ajax design patterns .
figure brie y depicts the source code while figure shows screenshots of qasite which runs as follows.
2run ning examples and analysis results are available from mzw.jp yuta research ex qasite html head !
load e x t e r n a l javascript f i l e s c r i p t type text j a v a s c r i p t s r c j s prototype .
j s s c r i p t s c r i p t type text j a v a s c r i p t !
.
.
.
user action w indow .
onload function f username .
onfocus getseed password .
onfocus getseed l o g i n .
o n c l i c k validatelogin good .
onmousedown ongood 12g .
.
.
direct login 14f unction getseed f i f !
loggedin !
hasseed f n ewajax .
request login pr efix f method get parameters task getseed onsuccess handlehttpgetseed g g 21g 22f unction handlehttpgetseed r e s f set response to seed v a r i a b l e g .
.
.
25f unction validatelogin f n ewajax .
request login pr efix method get parameters task checklogin .
.
.
oncomplete trylogin g 30g31function trylogin r e s f i f i s s u c c e s s r e s f create logout anchor disable l o g i n form make answer readable gel sea l e r t i n v a l i d account 37g .
.
.
on demand javascript 39fu nction ongood f handle good !
button c l i c k s g .
.
.
42fu nction trylogout f disable logout anchor enable l o g i n form make answer masked 46g s c r i p t h ead body .
.
.
h1 q asite h1 .
.
.
h2 q uestion h2 .
.
.
h2 a nswers h2 .
.
.
bu tton id good good!
button .
.
.
di v id mask div !
f o r masking answer .
.
.
h2 l ogin out h2 .
.
.
in put id username type text in put id password type password in put id l o g i n type submit .
.. body html fig ure source code of our motivating example qasite figu re screenshots of qasite table actual errors in the qasite fis ajax design pattern brief explanation of erroneous behavior act ual error user ac tion qasi te might not prevent multiple calls to validatelogin un necessary when a user unexpectedly double clicks on the login button.
serv er sessions on dem and qasi te can handle ongood before successful login in valid user jav ascript du e to a dead link to the mask image le.
op erations direct login qasi te can send requests for login attempts without seed data.
in valid login then a user cannot log in with his or her username and password.
at tempts 493nameless 55 init onload onfocus handlehttpgetseed validatelogin loggedin !hasseed onmouse downonsuccess onmousedown getseed branch 136 nameless 55 nameless 55 nameless 55 init onload onfocus getseed handlehttpgetseed handlehttpgetseed handlehttpgetseed validatelogin validatelogin validatelogin hasseed onm dowonsuccess onmousedown branch 136 branch 136 handlehttpgetseed handlehttpgetseed handlehttpgetseed validatelogin validatelogin loggedin !
hasseed onmouse down onmousonmbranch 136 branch 136 branch 136 f qasite sends account info.
f without seed data e immediate resp.
faulty interaction sequence executed interaction sequence fig ure finite state machine extracted from qasite i page load upon a page load qasite registers user event handlers for the login form and the good!
button lines .
the user action pattern notes such implementations so that ajax applications can handle user events anytime.
additionally the qasite masks the answers line to prohibit guest users from viewing them.
this implementation is similar to the ondemand javascript pattern in which qasite should handle the click on the good!
button after users login.
ii login we implemented the login form according to the direct login pattern.
when a user sets the cursor on the input forms lines qasite determines that the user intends to log in and qasite asynchronously retrieves seed data from the server lines .
when a user clicks on the login button line qasite sends the username and a hash value with the password and seed data for secure communications to validate the account on the server side lines .
after receiving the validation result line qasite creates a logout widget and disables the login form if the information is valid lines .
iii answer view while it is creating the logout widget qasite removes the mask lines .
the user can then view the answers and click the good!
button lines and .
when the user logs out qasite disables the logout widget enables the login form and masks the answers again lines .
.
results of our previous studies although qasite seems to run as expected jsveri er proposed in our previous studies reports the presence of three potential faults which are listed in table .
herein we explain how jsveri er works.
jsveri er statically extracts a nite state machine from the source code of ajax applications extractor in figure .
in our static extraction method we focus on interactions with ajax applications such as mouse clicks and server responses as triggers that can change the application states.
the interactions are implemented at event handlers for user events or asynchronous communications in the source code therefore jsveri er can nd all the interactions in a static manner.
for example in figure line jsveri er nds that qasite changes its state when handling the onfocus event.
to construct a nite state machine based on the interactions jsveri er leverages a call graph that represents function caller callee relationships because the interactions are function callbacks in response to events.
thus jsveri er outputs an interaction based nite state machine containing application behaviors that are independent of the testing environment.
figure shows a nite state machine extracted from qasite.
additionally jsveri er runs the nusmv model checker to verify the correctness of the extracted nite state machine verifier in figure .
however the model checker cannot determine whether or not the behaviors of ajax applications are ones developers expect.
fortunately ajax design patterns are based on observations in many real world ajax applications.
therefore we assume that the design patterns present the properties of the application behaviors expected by developers.
hence we de ne invariants to be veri ed from the behavior properties relevant to the interactions.
for example the direct login pattern indicates that qasite should receive the seed data before sending the account information.
jsveri er also uses the property pattern mappings5 which provide template formulas for nite state veri cation to express invariants in veri cation formulas.
as template parameters jsveri er requires developers of functions or events where they implement ajax design patterns iadp info so that it instantiates veri cation formulas formulator in figure .
as an example of the direct login pattern in qasite developers input the handlehttpgetseed and validatelogin functions lines and in figure as the iadp info.
from a counterexample of the veri cation results jsveri er then identi es faulty interaction sequence regardless of whether or not it is executable in a testing environment visualized by the bold solid arrow in figure .
thus jsveri er reports the presence of potential faults in ajax applications that seems to cause actual errors if executed.
5pa tterns.projects.cis.ksu.edu 494faulty interaction sequences fiss test data mutated code executed interaction sequences eiss fiss eiss end revealing errors due to potential faults actual errors original code yes no executing on fiss step a applying mutation operators step testing mutated code step test oracle fiss eiss yes no executable faults efs executing on fiss step b eiss delay dependent potential faults ddpfs branch point found?
dependent potential faults dpfs no yes figu re jspreventer work ow .
the challenge the potential faults reported by jsveri er can be exposed under a speci c set of conditions but have little chance of being found if the set is unknown.
a problem with such faults is that developers have trouble detecting them during testing because they cause errors only when complicated conditions are met .
therefore our challenge in this study is to reveal actual errors due to faults in developers testing environments before users encounter erroneous behaviors in the applications.
as an example of faulty interaction sequence if qasite is validated with browsers in a reliable network e.g.
with firefox and chrome browsers in a local host environment it can immediately receive a response to obtain the seed data and cannot run along with faulty interaction sequence .
however an unexpected network latency that occurs when the seed data is being obtained enables qasite to send account information without the seed data which prevents the user from logging in with his or her correct username and password.
despite concerted efforts by developers identifying unexpected conditions such as speci c communication delays in the unpredictable context of a running application is still extremely difficult.
consequently jspreventer is designed to systematically test whether ajax applications run as expected on faulty interaction sequences that might not be easily executable in the given environments.
.
our approach figure depicts the three step process that jspreventer uses for validating ajax applications.
jspreventer initially executes ajax applications on the faulty interaction sequences identi ed by jsveri er step a .
if the potential faults associated with these sequences are not easily executable jspreventer mutates the source code until the ajax applications do execute the potential faults steps and 1b .
then developers test for the unexpected behavior due to the potential faults by using the mutated applications step .
additionally jspreventer classi es potential faults into executable delay dependent potential and dependent potential faults which are de ned in section .
.
bu tton o n c l i c k handleclick .
.
.
s c r i p t s r c handleclick .
j s figu re loading a javascript le with improper timing .
executing faulty interaction sequences because executing ajax applications results in actual errors if there are any jspreventer rst attempts to execute the applications in accordance with the identi ed faulty interaction sequences step a in figure .
although jspreventer uses the selenium webdriver6in order to make its execution as automated as possible developers must input test data that cannot be inferred by any tools such as a correct username and password in order to test a successful login scenario.
jspreventer executes applications with test data and obtains the executed interaction sequences from the execution results.
if the executed interaction sequences and faulty interaction sequences are identical jspreventer determines that potential faults in the applications are executable faults against the implemented ajax design patterns.
as previously mentioned executable faults can be revealed through state of the art methods.
if the potential faults are not executed jspreventer focuses on the differences between the faulty interaction sequences and the executed interaction sequences.
differences may occur because ajax applications cannot handle certain interactions in faulty interaction sequences.
the solid and dashed arrows in figure respectively represent faulty interaction sequence and its executed interaction sequence.
at the meshed circle in the gure webdriver emulates the onfocus user action but qasite actually handles the onsuccess event because of an immediate server response.
however the ability to manipulate the timing of the applications handling the interactions allows ajax applications to run as faulty interaction sequences.
thus a mutation technique can be used to manipulate the timing.
.
applying mutation operators by mutating the source code of the ajax applications jspreventer enables them to run on faulty interaction sequences in a given environment step in figure .
we assume that an unexpected network latency might allow potential faults to be executable and de ne the following delay based mutation operators.
synchronous delay a web browser parses the html code from top to bottom while loading a web page.
when the browser nds a script element whose src attribute has the location of an external javascript le it begins loading the javascript le.
because the javascript code can dynamically manipulate the web page content the browser blocks render the remaining html code until the javascript le is completely loaded.
therefore script elements can be implemented at the bottom of the html code in order to render all page elements as fast as possible.
this is a well known way to increase the perceived performance .
loading a javascript le at the improper time may cause an actual error.
figure shows brief code fragments to explain our synchronous delay mutation op6do cs.seleniumhq.org projects webdriver original code .
get myscript .
php url fna me yuta g query s t r i n g fu nction data f c a l l b a c k a l e r t response i s data g mutated code 9ne wdelayedrequest .
applyfunction .
get t a r g e t func myscript .
php url fna me yuta g query s t r i n g fu nction data f c a l l b a c k a l e r t response i s data g figu re example of our wrapper function erator.
in this application developers implement the handleclick function in the handleclick.js javascript le and set the function as the onclick event handler of the button element.
following common practice the script element is then implemented at the bottom of the html code.
however an unexpected network latency may delay loading of the javascript le.
the application cannot respond to the onclick event occurrence because this scenario allows a user to click a button even though the browser has yet to register the event handler.
to emulate a javascript le loading delay due to an unexpected network latency jspreventer inserts an arti cial script element whose src attribute is located in our server side program.
this program then sends an http response with a given delay time causing a synchronous delay.
this http response consists of header and body sections in which are set contenttype application javascript and an empty string respectively.
in this manner jspreventer can manipulate the timing of handling interactions relevant to page loading such as an onload event.
asynchronous delay although the most signi cant feature of ajax applications is the asynchronous communications between the client and server an unexpected network latency can signi cantly impact this feature.
unlike a synchronous delay an unexpected network latency does not inhibit rendering of web page content or handling of user interactions.
consequently it is extremely difficult to consider all possible states where ajax applications may have to handle a delayed asynchronous server response.
to emulate a handling delay with an asynchronous server response jspreventer rewrites the corresponding javascript code fragment by using our wrap function delayedrequest as shown in figure .
jspreventer nds a target function for an asynchronous server request in the original code and parses its arguments such as url query string and callback function.
instead of the original code jspreventer inserts an instantiation statement of the delayedrequest with a given delay time e.g.
msec.
the delayedrequest sends the same asynchronous server request as the original one but does not invoke the callback function even if a response is immediately received.
after the given delay time has elapsed the delayedrequest invokes the callback function.our mutation operators do not change the functionalities of ajax applications because the applications can still handle a speci c interaction after the given delay has elapsed.
to determine where to apply our mutation operators jspreventer searches for a branch point between the faulty interaction sequences and executed interaction sequences such as the meshed circle in figure .
the branch point may prevent ajax applications from running on the faulty interaction sequences.
the mutation operators are then applied to an interaction in the executed interaction sequences at this point e.g.
the onsuccess event handler.
even if the server immediately responds qasite does not handle the server response within the delay period.
by iterating steps b and in figure until the executed interaction sequences equal the faulty interaction sequences jspreventer arti cially sets up conditions in which potential faults can be exposed.
finally it classi es the potential faults that become executable by applying our mutation operators as delaydependent potential faults .
thus jspreventer provides developers with executable evidences of the delay dependent potential faults which are not easily executable faults because they are not executed without subtle network delays.
however not all applications can be mutated to produce identical executed interaction sequences and faulty interaction sequences.
faulty interaction sequence in table means that qasite can call the ongood function without receiving the server response for login.
although jspreventer injects the same arti cial delay as in the case of faulty interaction sequence the good!
button cannot be clicked because the mask works as expected.
this means that jspreventer cannot make the potential faults executable.
jspreventer classi es these potential faults as dependent potential faults which might cause actual errors for reasons other than delayed injection.
.
testing mutated code because developers implement ajax design patterns according to their intentions we assume that they can also implement test oracles to verify whether the patterns are correctly implemented in ajax applications or not.
with such test oracles jspreventer can determine whether the mutated code has passed the test step in figure .
if the code fails a test developers can determine the actual errors from the test results.
jspreventer outputs actual errors in addition to a nite state machine and faulty interaction sequences from jsveri er.
we assume that these outputs will help developers debug the original source code because they allow the complex behaviors of ajax applications to be understood the faulty behaviors of a nite state machine to be identi ed and unexpected behaviors due to potential faults to be observed.
thus developers can use jspreventer to prevent actual errors due to potential faults in ajax applications.
.
use scenario of jspreventer figure illustrates a jspreventer use scenario based on the results of our motivating example assuming that jspreventer is applicable in the context of iterative and incremental development .
in fact developers often select a simpli ed and rapid iteration development life cycle .
the scenario in jspreventer involves ve steps i the implemented ajax design pattern information iadp info is initially inputted to jsveri er ii jsveri er suggests faulty ... faulty interaction sequence i input iad p info iii input test data and oracles iv observe and debug actual errors ii notice potential faults v confirm correctness and reliabilityfig ure jspreventer use scenario interaction sequences in the applications against the iadp info and reports the presence of potential faults.
iii developers provide test data and oracles to jspreventer iv to reveal unexpected runs jspreventer mutates and tests the applications.
in this step if the potential faults become to be executable with subtle network delays we assume that the executable evidences and the revealed actual errors can be of help in validating and debugging the applications v through iterative development highly reliable ajax applications can be released.
.
evaluation we conducted case studies and evaluated the usefulness of jspreventer by answering the following research questions.
rq1 can jspreventer reveal actual errors caused by potential faults in ajax applications?
rq2 can jspreventer reveal the errors in a feasible amount of time?
.
subject ajax applications table shows the ajax applications which we used in our case studies.
to nd real world ajax applications in which developers had implemented ajax design patterns we searched by using keywords relevant to ajax design patterns with nerdydata7 which provides a search engine for the source code on websites.
2020m we searched for login con troller.js where james dam8implemented the direct login pattern9.
the 7ner dydata.com 8internet archive goo.gl s47avv 9ajax login system demo goo.gl yccxtnoptical accessory supplier website was found at the top of the search results.
ucdchina and esa additionally we searched for onblur checkinput and onsubmit validate which are representative of the live form pattern.
the live form pattern suggests that ajax applications should check form data before making a submission.
from the search results we found chinese and british companies portal websites.
.
experimental setup our case study experiments were conducted on a bit mac os x .
.
machine with an intel core i5 .3ghz and gb of memory.
first we saved complete web pages of the subjects by using mozilla firefox and obtained html css and javascript source code les.
then we leveraged code beauti er10to count lines of these codes as listed in table html css and js .
the 1k 10k lines of code range represents medium largish ajax applications.
note that only client side source code could be obtained therefore we implemented mock server side scripts in php.
next we used jsveri er to extract the nite state machine from each subject.
table lists the extraction time te and the numbers of states and transitions of the nite state machine states and trans .
table lists the interaction invariants used in our case studies.
the interaction invariants to be satis ed were determined for each subject .
in the source code of all the subjects we found implementations of asynchronous communications and page load event handlers.
therefore 10ct rlq.org beautifier 497tabl e subject ajax applications sub ject url html css js states trans.
te sec tv sec 0m .
.
ucdchina .
.
esa .
.
tab le interaction invariants derived from ajax design patterns exp ected application behavior ajax design pattern pattern category han dling user events during asynchronous communications xmlhttprequest call fundamental technology registering user event handlers at page load user action fundamental technology validating form data before submission live form functionality and usability retrieving seed data before login attempt direct login functionality and usability disabling login form after successful login direct login functionality and usability we determined that invariants xmlhttprequest call and user action should be satis ed in all the subjects.
additionally considering the search keywords we also determined that invariants and direct login in 2020m and invariant live form in ucdchina and esa should be satis ed.
jsveri er then veri ed all the invariants for each subject and reported the veri cation time t vin table and the veri cation results result vin table .
if the veri cation result was incorrect jspreventer executed the classi cation work ow shown in figure .
we set the delay time to be seconds.
additionally we provided all the necessary test data and oracles such as the correct username and password for successful logins in 2020m.
finally jspreventer classi ed the potential faults that caused incorrect veri cation results into executable delay dependent potential or dependent potential faults.
the result ccolumn in table corresponds to these classi cation results.
jspreventer also reported the execution mutation and testing times t x tm and tt .
additionally we conducted comparative experiments with crawljax11 which is a state of the art tool for nding faults in ajax applications .
the default setting of crawljax could not nd any delay dependent potential faults in the subjects.
.
results and discussions revealing actual errors due to delay dependent potential faults rq1 jspreventer could classify potential faults reported by jsveri er into executable delaydependent potential and dependent potential faults.
as indicated in table it found actual errors in the subjects.
we reviewed the source code of the subjects and con rmed that the actual errors could be exposed.
in 2020m users could not log in even with their correct username and password because 2020m sent the login request with the initial value at the declaration statement of the seed variable.
for secure password hashing 2020m used the md5 algorithm to a value obtained by adding theseed variable to the user password.
although 2020m should use the seed variable generated at runtime it hashed the value with the initial value hence 2020m sent the hashed value using the raw user password.
the md5 re11cra wljax.comverse lookup12might allow interceptors to reverse engineer the hashed value obtain the user password and log in 2020m illegally.
thus we could infer a vulnerability to intrusion.
additionally jspreventer revealed that ucdchina sent an empty text on its search form despite developers having incorporated a gosearch function to prevent it.
a cause of this erroneous behavior was that ucdchina could display the search form before loading the code fragment containing thegosearch function.
since the search form is the source where users enter the search query developers in this case had intended to improve the search form.
although they had expected only valid search queries would be sent from the search form the error indicates that ucdchina did not validate the search query at all and therefore it possibly sent every search query.
if so there would be an additional possibility that a server would receive malicious search queries e.g.
an sql code fragment that might lead to an sql injection attack.
jspreventer could nd an unde ned addthis close function call in esa by using the synchronous delay operator upon loading an addthis widget.js le.
the unde ned function calls can be fatal errors which might cause esa to crash.
although crawljax ran until it completed its exploration of the state space it did not reveal the actual errors found by jspreventer.
these results suggest that jspreventer reveals actual errors due to delay dependent potential faults.
feasible analysis time rq2 for each test subject jspreventer revealed the actual errors within one minute.
most of the te tx and ttvalues were required to initialize parsers and to launch the test browser.
although tvincreased linearly with the size of the extracted nite state machine the extracted nite state machines were small enough to be veri ed with the nusmv model checker.
tmwas much shorter than the other amounts.
these results indicate that jspreventer is practical.
false positives in dependent potential faults in our case studies three potential faults could not be executed using jspreventer and the delay based mutation operators.
as for the potential faults at invariants and in 2020m we observed that mozilla firefox prevented 2020m from running on the identi ed faulty interaction sequences by making 12se arch.cpan.org blwood digest md5 reverse .
498tab le classi cation results of our case studies sub ject invariant ajax design pattern result v tx sec tm sec tt sec result c 0m xmlhttprequest call correct user action false positive .
.
.
dpf direct login potential fault .
.
.
ddpf direct login false positive .
dpf ucdch ina xmlhttprequest call correct user action potential fault .
.
.
ddpf live form potential fault .
ef esa xmlhttprequest call correct user action potential fault .
.
.
ddpf live form false positive .
.
.
dpf ef ddpf and dpf in the column of result crepresent executable delay dependent potential and dependent potential faults respectively.
table actual errors due to delay dependent potential faults sub ject brief explanation inferred vulnerability 0m login failed with correct username and password intrusion ucdchina content search with an empty query sql injection esa unde ned function call application crash a pro per rendering block and page transition respectively.
since the extracted nite state machine did not contain the web browser behavior we determined that these potential faults were false positives due to spurious counterexamples.
additionally jspreventer could not make the potential fault at invariant in esa executable.
in the source code of esa we found that a conditional branch was implemented to prevent esa from executing the potential fault.
analyzing data dependent impossible behavior is currently beyond the scope of our research hence this result was a false positive due to our methods.
however this problem can be mitigated by using execution results to re ne the extracted nite state machine i.e.
by conducting further dynamic analyses together with jspreventer.
a remaining issue is that it is unknown whether ajax applications actually execute dependent potential faults.
therefore we are interested in de ning additional effective mutation operators to make dependent potential faults executable.
applying to generic ajax applications we designed jspreventer for developers who use ajax design patterns to build applications.
in actual ajax application development developers have their own design patterns.
if there are not given iadp info for the own design patterns jspreventer cannot determine code locations where our mutation operators should be applied.
to test ajax applications made with their own design patterns developers need to specify the code locations of synchronous or asynchronous communications which they suspect as the cause of errors when speci c network delays are present.
jspreventer then mutates the code fragments at the speci ed code locations and tries to reveal the errors.
debugging potential faults we assume that the actual errors revealed by jspreventer can help developers debug potential faults.
however this debugging task depends on the skills and experience of the developers.
in the future we plan to establish a method to support debugging.
.
threats to validity internal validity threats we considered two external factors that might affect results in our case study experiments.
the results from 2020m ucdchina and esa demonstrate the usefulness of jspreventer because these real world applications were obtained via a public search engine provided by nerdydata.
however their actual serverside scripts were not available therefore we implemented mock server side scripts in order to run these real world applications on our machine.
because the mock server side scripts may be a threat to internal validity we intend to conduct additional case studies using real world open source ajax applications.
additionally we provided the necessary information to run the test subjects e.g.
iadp info test data and oracles .
although the ability of developers to input correct information into jspreventer may affect the internal validity the results of our case studies show that jspreventer can reveal actual errors due to potential faults.
it should be noted that the test scenarios involved typical tests such as verifying user login success with the correct username and password.
in the future we intend to use jspreventer in actual ajax application development projects to evaluate whether developers can input correct information into jspreventer.
we are also interested in combining a searchbased testing technique with jspreventer in order to generate test data automatically.
external validity threats regarding the generality of our approach jspreventer can only reveal actual errors due to delay dependent potential faults.
however potential faults may depend on other reasons such as unexpected user operations and web browser behaviors.
therefore we are going to collect dependent potential faults by conducting additional case studies with jspreventer and de ne effective mutation operators for them.
499alth ough 2020m ucdchina and esa are practical ajax applications it would be interesting to determine the scalability of jspreventer by obtaining experimental results using many real world ajax applications.
.
related work in this section we describe the state of the art studies on the analysis and testing of ajax applications.
state based analysis and testing marchetto et al.
introduced the concept of state based analysis and testing to ajax applications .
their tool reajax extracts nite state machines from the execution results of ajax applications.
the nite state machines consist of document object model dom 13instances and the effects of callback executions as states and transitions.
however reajax requires developers to manually execute ajax applications to sufficiently trace the execution results.
towards automated execution mesbah et al.
implemented crawljax which can automatically emulate user actions i.e.
crawling ajax applications.
crawljax has been used to detect dom related faults to test cross browser compatibility and to determine whether css rules are unnecessary or not .
additionally choudhary et al.
leveraged crawljax to improve the accuracy of identifying cross browser issues .
although crawljax is very useful for nding executable faults such crawling approaches cannot reveal potential faults because they may not be easily executable in the given environments.
arzti et al.
presented artemis as a way to improve code coverage by using the feedback directed technique .
artemis analyzes historical test execution data and generates test cases to explore the state space of ajax applications.
the authors noted that artemis may help crawljax determine what user actions should be emulated.
however crawljax and artemis cannot be combined in a way that would determine potential faults in ajax applications.
hong et al.
have a similar concern of nding concurrency errors due to the improper timing of ajax applications handling the interactions .
their tool called wave is an extended implementation of the webkit14browser framework for managing event invocations on the javascript engine.
however the html rendering engine can also affect event invocations such as the rendering block as we mentioned in section .
.
since jspreventer reveals errors due to potential faults of ajax applications on standard web browsers that users actually use it can more precisely suggest erroneous behavior of the applications to developers.
static approach as for static approaches guha et al.
proposed a static method to prevent ajax applications from handling invalid server requests .
their framework constructs a request graph through control ow analysis which represents how ajax applications handle asynchronous server requests with an invariant order.
the request graph can be used as an oracle to validate runtime server requests.
however if developers cannot correctly implement ajax applications the request graph cannot reject invalid server requests relevant to potential faults.
thus developers debugging the potential faults using jspreventer can construct a more proper request graph from the debugged applications.
13www .w3.org dom et al.
also conducted a rules based static analysis to detect data races due to asynchronous calls i.e.
the sort of interactions dealt with in this paper in ajax applications .
although they focused on global variables which are shared by asynchronous calls jspreventer can identify faulty asynchronous calls without data races by leveraging the ajax design patterns as oracles.
additionally zheng et al.
were not interested in testing unexpected behaviors in the applications if a detected data race occurred.
although they suggested two methods to x data races we argue that the actual errors found by jspreventer can help developers debug their applications and con rm the correctness of the codes.
guarnieri et al.
introduced a pure static taint analysis for javascript code in order to identify security vulnerabilities such as cross site scripting and sql injection .
wei et al.
pointed out the dynamic feature of javascript javascript code can dynamically get additional code from the server at runtime.
they proposed a blended taint analysis of the javascript code that can be collected by executing test cases .
although these analyses can output precise control ows of only the javascript code jspreventer analyzes stateful behaviors in the html css and javascript code of ajax applications.
mutation analysis and testing mutation analysis is a fault based technique to assess the adequacy of test cases .
it seeds arti cial faults into the program under test and then measures whether the seeded arti cial faults can be detected in the test cases.
this technique in its original form might be applicable to ajax applications .
in contrast jspreventer leverages a deformed mutation analysis technique wherein seeded arti cial delays do not act as faults to be detected but expose existing potential faults in ajax applications.
although jspreventer cannot be used to assess the adequacy of test cases it can reveal actual errors due to potential faults.
.
conclusion we proposed a support tool called jspreventer for validating ajax applications by nding executable evidences of potential faults that may not be easily executed in the given development and test environments.
we implemented delaybased mutation operators to arti cially make the potential faults executable and reveal actual errors due to delaydependent potential faults.
our experimental results show that jspreventer reveals actual errors due to delay dependent potential faults in real world ajax applications in a feasible amount of time.
by debugging the revealed errors developers can develop and validate highly reliable ajax applications.
our future research will proceed in three separate directions.
one direction is to develop automated debugging.
besides establishing a method that effectively uses solutions in ajax design patterns we plan to combine jspreventer with mechanisms for determining actual errors in existing debugger tools such as firebug15.
the second direction is to implement more mutation operators to reveal actual errors due to dependent potential faults.
the third direction is to expand the range of case studies on large scale ajax applications in the real world.
15ge tfirebug.com .