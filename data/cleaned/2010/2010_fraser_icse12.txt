sound empirical evidence in software testing gordon fraser saarland university saarbr ucken germany fraser cs.uni saarland.deandrea arcuri certus software v v center simula research laboratory p .o.
box lysaker norway arcuri simula.no abstract several promising techniques have been proposed to automate different tasks in software testing such as test da ta generation for object oriented software.
however reported studies in the literature only show the feasibility of the proposed techniques because the choice of the employed artifacts in the case studies e.g.
software applications is usually done in a non systematic way.
the chosen case study might be biased and so it might not be a valid representative of the addressed type of software e.g.
internet applications and embedded systems .
the common trend seems to be to accept this fact and get over it by simply discussing it in a threats to validity section.
in this paper we evaluate search based software testing in particular the evosuite tool when applied to test data generation for open source projects.
to achieve sound empirical results we randomly selected java projects from sourceforge which is the most popular open source repository more than projects with more than two million registered users .
the resulting case study not only is very large public classes for a total of bytecode level branches but more importantly it is statistically sound and representative for open source projects.
results show th at while high coverage on commonly used types of classes is achievable in practice environmental dependencies prohibit such high coverage which clearly points out essential future research directions.
to support this future research our sf100 case study can serve as a much needed corpus of classes for test generation.
keywords test case generation unit testing search based software engineering class corpus security exception environment i. i ntroduction software testing is an essential yet expensive activity in software development therefore much research effort has been put into the question of how to automate it as much as possible.
in this paper we focus on test data generation for code coverage in particular branch coverage in the context of object oriented software.
the simplest automated testi ng technique in this context is perhaps random testing but during the years different sophisticated techniques ha ve also been proposed.
at a high level the current state of the art can roughly be divided into three main groups variants of random testing e.g.
randoop dynamic symbolic execution e.g.
cute and search based software testing e.g.
.
a recent trend also goes towards combining the individual techniques e.g.
.for simple techniques such as random testing it is possible to provide rigorous answers based on theoretical analyses e.g.
see .
for more complex techniques where mathematical proofs become infeasible or too hard researchers have to rely on empirical analyses.
there are several challenges when carrying out empirical studies among which there is the choice of the case study.
if a technique works well in the lab on a specific case study will it also work well in the real world when it is applied by practitioners on their software?
it might be that a novel technique works well in the lab just because the case study is too simple or small but then it might fail on real world instances.
even if real world instances are used in a case study the proposed technique might be too specific biased toward those instances and still fail when applied on new instances by practitioners.
how are case studies chosen in the literature?
in most cases this choice is not made in a systematic way i.e.
researchers choose software artifacts without providing a ny specific and unbiased motivation.
notice that in many software testing contexts this is the only viable option.
t his is a typical example in the context of testing techniques targeted for industrial systems.
obtaining real data from industry is a very difficult and time consuming activity and so case studies tend to be either small or biased toward a specific kind of software e.g.
software in the automotive industry seismic acquisition systems video conference and safety critical control systems .
the case of test data generation for open source software is very different from industrial software.
the world wide web hosts a huge amount of open source projects and there are specialized repositories that are freely accessible e .g.
sourceforge1or google code2 .
a researcher can easily download open source software and use those programs as case study.
but how to choose them?
for example it is quite common that empirical studies only involve container classes e.g.
lists and vectors see .
it is quite hard to generalize the conclusions from such empirical studies to any other kind of software.
even when case studies are large andvariegated e.g.
several hundreds of classes from accessed september .
accessed september .
.
c ieee icse zurich switzerland 178different kinds of software still a manual choi ce of software artifacts might introduce bias in the results.
f or example if a proposed testing technique does not support file system i o then that kind of software might have been excluded from the case study although programs with i o may be very common in practice.
to the best of our knowledge we are not aware of any empirical study in the literature in which this kind of threats to external validity has been addressed.
to cope with this problem in this paper we present what is perhaps the first empirical study where the choice of the case study is statistically sound as far as open source software is concerned.
we randomly selected java projects from sourceforge which is the most popular open source repository.
currently it hosts more than projects in several programming languages and it has more than two million registered users.
the resulting case study is very large consisting of classes for a total of bytecode level branches.
because the case study is randomly selected from an open source repository the proportions of kinds of software e. g. numerical applications and video games are statistically representative for open source software a more precise definition will be presented later in the paper .
on this large case study we applied e vosuite which is a search based test data generation tool for object oriented software written in java.
e vosuite is an advanced research prototype that can efficiently handle all the diffe rent kinds of programming structures in java e.g.
it has specifi c operators to handle string objects and arrays .
furthermor e it uses a sandbox where potentially unsafe operations e.g.
class methods that take as input the name of a file to delete are caught and properly taken care of.
this feature was essential for the chosen case study as real world open source programs likely have at least one unsafe operation.
the results of our empirical analysis show that as demonstrated by previous empirical studies test generation can indeed achieve high coverage but only on a certain type of classes.
in practice dependencies on the environment inhi bit high coverage and thus clearly point out directions into which future research needs to investigate more.
in many research disciplines common benchmarks allow tool comparisons and exploration of novel ideas in the field of software testing there is no such common benchmark despite recent community efforts to provide one.
our selection of sourceforge projects which we provide to the research community can serve as a corpus of classes for the field of test generation for object oriented softwar e. we call this corpus sf100.
the paper is organized as follows.
section ii surveys the literature on test generation for object oriented softwar e to gain insights into the current practice in performing exper iments.
section iii then describes the first sound experiment in software testing which allows us to draw conclusions about where the actual problems in this domain are.
basedtable i evaluation settings in the literature .
the container column denotes how many of the classes are container data structures in those cases where this was determinable .
the source column describes whether case studies were chosen from available open source projects os industry projects taken from the literature or created by the authors .
tool reference projects classes container source artoo open source autotest open source check n crash ?
os literature covana open source diffgen literature dsdcrasher open source dygen industrial eclat os lit.
constr.
ecrash open source ecrash open source etoc open source evacon open source evosuite os industrial jartege constructed jaut constructed jcrasher literature jcute open source jfuzz ?
open source jpf open source jpf constructed jtest daikon constructed lit.
jwalk constructed korat literature mseqgen open source mutest open source nighthawk literature nighthawk open source ocat open source palus os industrial pex constructed pexmutator open source randoop os industrial rostra constructed lit.
rutej open source symclat constructed lit.
symstra literature symbolic jpf industrial symbolic jpf industrial os taco os lit.
testera open source testful os literature n a open source n a open source n a open source on these results section iv discusses the threats of choosi ng an unsuitable case study and section v concludes the paper.
ii.
s oftware engineering experimentation to get a better picture of the current practice in evaluation s in software engineering research we surveyed the literatu re on test generation for object oriented software.
this is no t meant to be an exhaustive and systematic survey but rather a representative sample of the literature to motivate the wo rk presented in this paper.
table i lists the inspected papers a nd tools together with statistics on their experiments.179we explicitly list how many out of the considered classes are container classes if this was clearly specified.
this is of interest as container classes represent a particular typ e of classes that avoids many problems such as environment interaction and recent studies have shown that even simple random testing can achieve high coverage on such classes .
interestingly papers exclusively focus o n container classes and many other papers include container classes.
we also list how the evaluation classes were selected interestingly not a single paper out of those considered justifies why this particular set of classes was selected an d how this selection was done.
in principle this could mean that the presented set represents the entire set of classes on which the particular tool was ever tried on but it could also mean that it is a subset on which the tool performs particularly well.
an exception is industrial code where often there is no choice because the case study is selected by an industrial partner.
out of evaluations we considered in our literature survey selected their case study programs from open source programs while only six evaluations included indus trial code.
this is to be expected as it is difficult to get access to industrial code and even if one gets access it is not always easy to publish results achieved on this code due to privacy and confidentiality issues.
we also include the .net libraries as industrial code here although the byteco de is available freely.
on the other hand evaluations used artificially created examples either by generating them or by reusing them from the literature.
xiao et al.
evaluated problems in structural test generation concluding that the main problems in structura l testing are related to object creation and external method calls.
in related work jaygarl et al.
performed an experiment on open source libraries to determine the main reasons why branches were not covered by random testing.
in their experiment the main reason was also the problem of generating complex objects followed by string comparison s and container object access.
out of the analyzed branches only .
were not covered because of environmental dependencies that were not satisfied.
however the results that we will present later in this paper lead to different conclusions.
iii.
a s tatistically sound experiment section ii illustrated that the choice of case studies in software engineering experiments is often unclear result ing in a threat to the external validity of these experiments.
in this section we describe a sound experiment on software testing which does not suffer from this threat to external validity.
given these data we perform a reality check on the research field of test generation for object oriented softw are how good is the state of the art really and what are the real problems?a.
objectives the performance of test generation tools is commonly evaluated in terms of the achieved code coverage.
high code coverage by itself is not sufficient in order to find defects as there are further major obstacles most prominently the oracle problem except for special kinds of defects such as program crashes or undeclared exceptions the tester has to provide an oracle that decides whether a given test run detected an error or not.
this oracle could be anything from a formal specification test assertions up to manual assessment.
the oracle problem entails further problems f or example in order to be able to come up with a test assertion a generated test case needs to be easily understandable and preferably short.
however in all cases a prerequisite to th e oracle problem is to find an input that takes the program to a desired state.
therefore in our experiment we compare the results in terms of the achieved branch coverage.
in section ii we saw that many case studies focus on container classes which are often chosen simply because they are nice to test there is no i o no interaction with the environment no multi threading etc.
in practice one often uses existing libraries of container classes but want s to apply testing tools to other types of classes which may very well try to interact with their environment.
test generatio n for such code is unsafe as the tested code might interact with its environment in undesired ways for example by creating or deleting files.
to evaluate to what extent this is the case we want to find out how many unsafe operations are attempted during test generation.
this results in the following two research questions rq1 what is the probability distribution of achievable branch coverage on open source software?
rq2 how often do classes execute unsafe operations?
b. the evosuite tool for search based test generation as context of our experiment we chose the e vosuite tool which automatically generates test suites for java classes targeting branch coverage.
e vosuite uses an evolutionary approach to derive these test suites a genetic algorithm evolves candidate individuals chromosomes using operators inspired by natural evoluti on e.g.
selection crossover and mutation such that itera tively better solutions with respect to the optimization target e .g.
branch coverage are produced.
chromosomes in e vosuite are test suites and each test suite consists of a variable number of test cases which are sequences of method calls.
crossover produces offspring te st suites by exchanging test cases from two parent individuals and mutation either adds new randomly generated test cases or mutates individual test cases.
mutation of test cases may add remove or change the method calls in a sequence.
fitness is calculated with respect to branch coverage usin g a calculation based on the well established branch distanc e180measurement .
the branch distance estimates how close a branch is to evaluating to true or false for a particular run .
for each branch we consider the minimum branch distance over all test cases of a test suite.
the overall fitness of a test suite is the sum of these minimal values such that an individual with branch coverage has fitness .
through its use of method sequences e vosuite can handle any datatype and can be applied out of the box to any java program.
it only requires the bytecode to produce test suites which it outputs in junit format.
calculating the fitness value requires executing code and if this code interacts with its environment then unexpected or undesirable side effects might occur.
for example the cod e might access the filesystem or network causing damage to data or affecting other users on the network.
to overcome this problem e vosuite provides its own custom security manager the java language is designed with a permission system such that potentially undesired actions first ask a security manager for permission.
e vosuite uses its own security manager that can be activated to restrict test execution.
when running test generation on unknown code using a sandbox in which permissions are restricted is essential.
we therefore enabled the custom security manager for our experiment.
with respect to rq2 we are interested in finding out to what extent these unsafe operations are a problem for test generation.
consequently we kept track of which kinds of permissions were requested from the code under test.
however no permissions were granted except for three permissions which we determined necessary to run most code in the first place in our earlier experiments reading from properties loading classes and reflection.
except for these permissions all other permissions were denied.
this might be overly strict and indeed finding a suitable set of permissions for test generation is a future research question.
in our previous experiments we applied e vosuite with a timeout of minutes per class.
as we apply the technique to a larger set of classes in this experiment and a developer might not be willing to wait for minutes to see a result we chose a timeout of two minutes per class after which the search always ended except if coverage was already achieved earlier.
for all other settings we use d evosuite with its default parameter settings.
c. case study selection to select an unbiased sample of java software we consider the sourceforge open source development platform.
sourceforge provides infrastructure for open source devel opers ranging from source code repositories webspace discussion forums to bug tracking systems.
there are other similar services on the web for example google code github or assembla.
we chose sourceforge because it istable ii details of the sf100 case study .
for each project we report how many classes it is composed of and the total number of bytecode branches .
name classes branches name classes branches ifx framework mygrid jcvi javacommon jigen caloriecount shop openjms dsachat summa jaw br lilith gangup corina inspirento heal rif at robots2 j ext4j lhamacaw fixsuite xbus xisemele jiggler biblestudy dom4j imsmart jnfe jgaap hft bomberman templateit jiprof javaviewcontrol wheelwebtool tullibee sbmlreader2 httpanalyzer jdbacl asphodel db everywhere noen quickserver diebierse beanbin cards24 echodep gsftp jsecurity jni inchi objectexplorer io project jhandballmoves fps370 schemaspy battlecry twfbplayer celwars2009 nutzenportfolio ipcalculator openhre sugar apbsmem dvd homevideo geo google bpmail petsoar byuic lotus jclo follow omjstate jwbf saxpath lagoon sfmis gfarcegestionfa falselight a4j diffi dash framework nekomud javathena biff lavalamp classviewer jtailgui gae app manager javabullboard resources4j fim1 dcparseargs water simulator trans locator jopenchart shp2kml newzgrabber jipa feudalismgame templatedetails jmca greencow the dominant site of this type having more than registered projects at the time of our experiment.
we based our selection on the dataset of all projects tagged as being written in the java programming language.
in total there were such projects at the time of our experiment and applying e vosuite to all of them would not be possible in reasonable time.
therefore we sampled the dataset picking one randomly chosen project out of this data set at a time.
for each chosen project we downloaded the most recent sources from the corresponding source repository and tried to build the program.
it turned out that many projects on sourceforge have no files i.e.
they were created but then no files were ever added .
a small number of projects was also misclassified by their developers as java project although in fact they were writte n in a different programming language.
finally we did not succeed in compiling all of the projects sometimes because they were too old and relying on particular java apis that are no longer available.
where available we downloaded binary releases for projects we could not build as e vosuite does not actually require the source code for test generation.
in181total we therefore had to consider projects until we had a set of projects in binary format.
we call this case study sf100 corpus of classes.
table ii shows the number of classes and branches per each of the projects whereas table iii presents the summarized statistics e.g mean and standard deviation .
these numbe rs were derived using e vosuite which only lists top level classes e vosuite attempts to cover member or anonymous classes together with their parent classes.
furthermo re evosuite might exclude certain classes it determines that it cannot handle such as private classes.
in total there ar e classes and bytecode branches reported by evosuite in this case study.
both in terms of the number of classes and branches what stands out is the large variati on in the data e.g.
the number of classes in a project ranges from to and the number of branches in a class ranges from to .
furthermore these distributions present infrequent extreme deviations which is represented by hig h kurtosis values and are highly skewed skewness represent s the asymmetry of a distribution between its left and right probability tails .
notice that in the normal distribution skewness is equal to zero whereas kurtosis is equal to three regardless of the variance.
tables ii and iii report data only for the classes for which evosuite run without problems.
however there were a further classes in these projects for which e vosuite crashed without outputting any result.
the reasons behin d these crashes are still under investigation.
at any rate because these special cases represent only a tiny fraction of the case study i.e.
of the case study they do not pose any particularly serious threat to the validity o f this study.
d. results to account for the randomness of the evolutionary search we applied e vosuite to each of the selected case study objects times with different random seeds and then averaged the values.
in each run we left e vosuite running up to two minutes.
in total running the experiment took up to days recall that when coverage was achieved we stopped the search .
figure shows the distribution of the coverage results per project.
evosuite produces test suites per class and each project might have some more difficult classes and some easier classes.
figure therefore illustrates the distribution o f coverage across the classes rq1 .
this shows that there is a large number of classes which can easily be fully covered by evosuite coverage and also a large number of classes with problems coverage while the rest is evenly distributed across the range.
3the details of this selection process and the case study are a vailable online at coverage intervalspercentual of projects .
.
.
.
figure .
for each code coverage interval we report the p roportion of projects that have an average coverage averaged out of ru ns on all their classes within that interval.
labels show the upper limit i nclusive .
for example the group represent all the projects with averag e coverage greater than and lower or equal to .
coverage intervalspercentual of classes .
.
.
.
.
.
.
figure .
for each code coverage interval we report the p roportion of classes that have an average coverage averaged out of run s within that interval.
labels show the upper limit inclusive .
for exampl e the group represent all the classes with average coverage greater than and lower or equal to .
the large number of classes with full coverage suggests that there are many classes that are trivially covered by evosuite .
to analyze this further figure illustrates for each code coverage interval the average number of branches of the classes within this interval.
the interval contains on average the smallest classes suggest ing that a large number of classes are indeed easily coverable.
on the other hand the large number of classes that apparently have problems coverage is very large.
such low coverage may result if the security manager blocks execution of unsafe code in the tested classes.
to see to what extent this is indeed the case table iv lists the average coverage achieved for classes for each of the possible182table iii summarized statistics of the sf100 the case study .
for median average skewness and kurtosis we also report a confidence interval ci calculated with a run bootstrapping .
min median ci average ci std.
dev.
max skewness ci kurtosis ci tot al of classes per project .
.
.
.
of branches per class .
.
.
.
table iv for each type of permission exception we report in how many classes it is thrown at least once and the average coverage for those classes .
w e also show how many projects have at least one class in which s uch exception is thrown and the average coverage for those projects including also the classes in those projects for which that k ind of exception is thrown .
type per class per project occurrence mean coverage occurence mean coverage no exception .
.
.
.
allpermission .
.
securitypermission .
.
.
.
unresolvedpermission .
.
awtpermission .
.
filepermission .
.
.
.
serializablepermission .
.
.
.
reflectpermission .
.
runtimepermission .
.
.
.
netpermission .
.
.
.
socketpermission .
.
.
.
sqlpermission .
.
propertypermission .
.
.
.
loggingpermission .
.
sslpermission .
.
authpermission .
.
.
.
audiopermission .
.
otherpermission .
.
.
.
coverage intervalsaverage number of branches figure .
average number of branches of classes within each code coverage interval.
classes in the coverage range a re the smallest and thus potentially easiest classes.
permissions that the security manager may deny.
classes that raise no exceptions achieve an average coverage of whereas all classes that require some permission that i s not granted have lower coverage.
consequently interactio ns with the environment are a prime source of problems in10 coverage intervalsratio of classes that spawn threads .
.
.
.
.
.
.
figure .
average number of threads for classes within each code coverage interval multi threaded code does not per se inhi bit coverage.
achieving coverage rq2 .
it is striking that of all classes lead to some kind of filepermission in other words almost three quarters of all classes tried to access t he filesystem in some way!
it is important to note that this i o might not come directly from the class under test but one of its parameters when testing object oriented code one needs183sequences of method calls and as part of the evolutionary search e vosuite attempts to create various different types and calls many different methods on them.
this means that just the existence of a denied filepermission does not yet indicate a problem as there might be other ways to cover the target code that do not cause file access indeed even classes that achieve high coverage often lead to some kind of denied permission check.
however the fact that classes with file access achieved significantly lower average coverage is a clear indication that file access isa real problem.
the other two dominant types of permissions we observed were runtimepermissions and netpermissions.
runtimepermissions can have various reasons such as for example attempts to shut down the virtual machine or to access environment variables.
on closer inspection many cases of runtimepermissions turned out to be attempts to load gui toolkit libraries which are not java bytecode librarie s but platform dependent libraries.
therefore a large part of the classes causing runtimepermission checks of the classes are classes related to guis.
the number of classes causing netpermission checks is also surprisingly large .
again a netpermission check does not automatically mean that the code under test immediately tries to access the network but it might happen through the parameter generation sequences and netpermission checks are also caused for example by generation of an invalid url.
however the java language is by construction wellsuited for web applications and several of the projects are indeed web applications.
finally a common assumption for test generation tools is that the code under test is single threaded as multithreaded code adds an additional level of difficulty to the testing problem.
creating a new thread does not require any permissions in java only terminating or changing running threads leads to permission checks.
we therefore observed the number of running threads each time any permission check was performed and each time a test execution timed out e vosuite by default uses a timeout of five seconds for execution of one test case .
figure illustrates the relation of code coverage to the frequency of cases where we observed more than one thread classes that achieved coverage had the fewest cases of additional threads but in general the existence of threads does not per se seem to have a big impact on coverage as the largest number of multi threaded classes was observed in the range.
however in the case of multi threaded code simply covering the code is usually not sufficient as test cases might become nondeterministic.
furthermore multithreading introduces new types of faults deadlocks etc and using a randomized algorithm like e vosuite uses on code that spawns new threads may cause problems as java offers no way to forcefully stop running threads.
however on average we observed problems with multi threading in only .
of all projects.e.
manual inspection on a high level view the results of the experiment gives us a clear message test generation works well as long as the environment is not involved but usually it is involved.
to understand the problems in test generation better we manually inspected classes that had low coverage but no permission problems classes that had file permission problems classes that had network problems and classes with runtime permission problems.
for this selecti on we sorted the classes by coverage and then chose the classes with the lowest coverage for each of the categories but only one per project per category.
classes without permission problems classes with low coverage but no permission problems are of particular interest with respect to improving e vosuite but might not generalize to other tools.
for example in the classes we investigated we identified the following main reasons for low coverage complex string handling java generics and dynamic type handling and branches in exception handling code.
evosuite has basic support for string handling for example it replaces calls to string.equals with a custom method that calculates the levenshtein distance which can then serve in branches to give better guidance to the search.
however this by itself is not sufficient to properly exercis e complex parsers and string handling functions at least in the two minute limit given for test generation in our experiment.
however there are dedicated string solvers an d techniques to handle regular expressions so these classes might not be problematic for other tools.
the second problem is largely due to java s handling of generics all type information is erased during compilatio n. for example for the constructor statemachine list transition transitions evosuite only sees the parameter of type list but not that this is supposed to be a list of transition objects.
when generating list objects e vosuite only sees that it can add instances of type object to these lists and thus the chances of putting transition objects into the list are small.
these problems could be overcome by incorporating static analysi s or support for type constraints.
finally e vosuite usually has no guidance in reaching exception handling blocks unless there is an explicit branch in the target class that leads to a throw statement.
consequently e vosuite only covers such statements by chance.
note that other tools might have other problems.
for example tools based on dynamic symbolic execution have more problems related to object creation .
classes with file permission checks file handling is very common in java classes both in reading as well as in writing mode.
branches do not necessarily depend on file contents but sometimes just depend on file existence or file names.
however even though these example branches do184not depend on the file content usually such branches are followed by code that manipulates these files.
another file permission we frequently observed is when code tries to read custom property files.
even though granting read access to property files might not pose an immediate danger such files still need to exist and contain appropriat e content in order to allow testing.
consequently automatically setting up a suitable file environment for testing classes is a major technical obstac le.
besides the difficulty in covering branches there is also always the danger that code manipulating the filesystem can cause unwanted effects for example whenever new files are generated it is highly undesirable to let the genetic algori thm pass random strings as filenames as that way the filesystem will be cluttered with files with random names which is something we observed for several classes in the sf100 corpus when deactivating the custom security manager.
classes with runtime permission checks as indicated in the previous section a large share of the runtime permission checks we observed were due to code trying to set up a graphical user interface.
to do so java first tries to read the environment variable display and then attempts to read a custom gui toolkit e.g.
jre lib amd64 xawt libmawt.so .
furthermore most gui applications try to access files e.g.
.accessibility.properties .
java has its own class ofawtpermission that are related to gui events as loading of gui toolkits was prohibited we did not observe any such permission checks.
we tried to see what happens when granting permissions to load libraries.
however even with these permissions the coverage does not increase as it opens up a range of other permissions that gui programs require awtpermissions to access the mouse pointer a large amount of thread manipulation special exception handlers permissions to open windows etc.
besides gui related runtime checks there are other common permissions that are undesirable during test generation most prominent probably the permission exitvm.
which is required to shut down the running virtual machine.
other instances of runtime permission checks include actio ns on running threads modifythread stopthread loading of libraries queuing of printer jobs or changing the securit y manager none of these actions are desirable during test execution.
classes with network permission checks only few classes directly attempted to open sockets socketpermission although dependent classes or parameters did this more frequently in total for of all classes .
netpermission s were more frequent and the most common type of such network permission that we observed was due to invalid url generation specifystreamhandler .
this particular permission does not immediately signify network access but creationof a url for a resource to which the program would normally not have access to like file foo fum .
it will require further experimentation to determine how many of these permissions were caused by the test generation itself e.g.
random strings propagating to url generation and how many were real attempts to access resources through urls.
in general our observations suggest that in many cases the netpermission checks are in fact very similar tofilepermission checks which would mean that i o remains the most important issue.
in general the question of finding a perfect setting of permissions for test execution is a research question on its own and it might be possible to increase coverage by being more gratuitous with permissions for tests.
f .
threats to validity threats to internal validity come from how experiments were carried out.
we used the e vosuite tool for our experiment which is an advanced research prototype for java test data generation.
although e vosuite has been carefully tested it might have internal faults that compromised the validity of the results.
furthermore because e vosuite is based on randomized algorithms we repeated each experiment on each class times to take this randomness into account.
however because our study was focused on obtaining insights on the challenges of applying test generat ion tools in realistic settings our research questions did not deal with comparisons of algorithms and so statistical tests we re not required.
a possible threat to the construct validity is how we evaluated whether there are unsafe operations when testing a class.
we considered the security exceptions thrown by all method calls in a test case even when those methods do not belong to the class under test.
potentially e vosuite might have tried to satisfy parameters of the class under test usin g classes that lead to actions blocked by the security manager even if these parameters could also have been satisfied with other classes that do not result in any security exceptions e.g.
when a method is declared to take an object as parameter e vosuite considers every known class as a potential input .
the main goal of this paper was to deal with the threats to external validity that afflict current research in software testing.
the sf100 corpus is a statistically sound representati ve of open source projects and our results are also statistica lly valid for the other java projects stored in sourceforge.
for example even if we encountered high kurtosis in the number of classes per project and branches per class median values are not particularly affected by extreme outliers.
t o reduce such threat to validity we used bootstrapping to create confidence intervals for some of the statistics medi an average skewness and kurtosis .
our results might not extend to all open source projects as other repositories e.g.
google code might contain185software with statistically different distribution prope rties e.g.
number of classes per project difficulty of the softw are from the point of view of test data generation .
furthermore there might be a significant percentage of open source projects that are not stored in any repository.
furthermore results on open source projects might not extend to software that is developed in industry as for example financial and embedded systems might be under represented in open source repositories.
at any rate considering the two milli on subscribers of sourceforge even if our results would be valid only for sourceforge projects still they would be of practical value and important for a large number of practitioners both developers and final users .
iv.
i mplications for software engineering experimentation in the previous section we described and analyzed a sound empirical study in software testing.
given the insights fro m this experiment we now discuss the potential implications of the choice of case studies.
in other words we can answer the following research question rq3 what are the consequences of choosing a small case study in a biased way?
an analysis of the literature in test data generation has shown in section ii that a large portion of research body has practically ignored the issues of test data generation when the system under test interacts with its environment e.g.
file systems and networks .
but our empirical analysi s section iii has shown that .
of classes may lead to interactions with their environment.
when there are no interactions with the environment i.e.
in the .
of cases a research prototype such as e vosuite can achieve an average coverage as high as see table iv .
on the other hand when we apply e vosuite on a statistically valid sample of open source projects the average coverage is only .
therefore our analysis casts serious doubts about the external validity of many empirical analyses that reported successful results on only a small number of classe s with no interaction with their environment e.g.
containe r classes are a typical example .
does using a large and variegated case study solve this problem of external validity?
the answer is unfortunately no.
if we look at figure we can see that there are projects for which e vosuite achieves on average a coverage higher than .
if we wanted to boast and promote our research prototype e vosuite we could have carried out an empirical analysis with only those projects.
that would have resulted in a variegated and large empirical analysis.
in ot her words any case study in which the selection of artifacts is not justified and not done in systematic way tells very littl e about the actual performance of the analyzed techniques.
our empirical analysis on the sf100 corpus clearly pointed out which are the real main problems in test datageneration for object oriented software.
for a successful technology transfer from academic research to industrial practice it will be essential that the research community will solve all of these problems.
therefore we can provide the sf100 corpus of classes and pose this challenge to the research community as a research community can we develop novel techniques that achieve on average at least of bytecode branch coverage on this sf100 corpus?
v. c onclusions experimentation in software engineering research inherently suffers from a common threat to external validity caused by the choice of case studies for experimentation.
in this paper we have presented the sf100 corpus which is a statistically sound representative of open source proj ects.
it is composed of java projects that were randomly selected from sourceforge which given that it has more than thousand projects and two millions subscribers is perhaps the most used open source project repository on the web.
the sf100 corpus consists of classes for a total of bytecode branches.
to the best of our knowledge see section ii this corpus does not only represent the largest case study in the literature of test da ta generation for object oriented software to date but most importantly it is the only one that is not negatively affecte d by threats to external validity.
external validity is one of the main barriers for a successful transfer of research results to software development practices.
on this statistically valid corpus we applied our research prototype e vosuite .
evosuite uses many of the most advanced techniques from the literature on search based software testing.
our analysis shows that the large majorit y of classes i.e.
.
may lead to execution of unsafe operations which can potentially harm the execution environment e.g.
by deleting files at random in the file systems .
on classes without unsafe operations e vosuite achieves on average an impressive branch coverage while on the entire sf100 corpus it only achieves of coverage on average.
as most of the research body in the software testing literature seems to ignore these issues e.g.
how t o safely write read on file systems and open close network connections without negative side effects our empirical analysis is a valuable source of statistically valid inform ation to understand which are the real problems that need to be solved by the software testing research community.
with this paper we challenge the research community to develop novel testing techniques to achieve at least of bytecode branch coverage on this sf100 corpus because it is a valid representative of open source projects and our e vosuite prototype only achieved coverage on average.
to help the community in this regard we provide186the sf100 corpus.
for more information on e vosuite and the sf100 corpus of classes please visit our website at