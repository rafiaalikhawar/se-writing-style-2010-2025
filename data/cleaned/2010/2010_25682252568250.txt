codehint dynamic and interactive synthesis of code snippets joel galenson philip reames rastislav bodik bj rn hartmann koushik sen university of california berkeley usa joel reames bodik bjoern ksen cs.berkeley.edu abstract there are many tools that help programmers nd code fragments but most are inexpressive and rely on static information.
we present a new technique for synthesizing code that is dynamic giving accurate results and allowing programmers to reason about concrete executions easy to use supporting a wide range of correctness speci cations and interactive allowing users to re ne the candidate code snippets .
our implementation which we call codehint generates and evaluates code at runtime and hence can synthesize real world java code that involves i o re ection native calls and other advanced language features.
we have evaluated codehint in two user studies and show that its algorithms are e cient and that it improves programmer productivity by more than a factor of two.
categories and subject descriptors d. .
automatic programming d. .
programming environments general terms experimentation languages keywords program synthesis ide .
introduction many code fragments are di cult to write often because they involve using a new and unfamiliar api.
programmers have many tools at their disposal from search and autocomplete to advanced synthesis techniques but these often have only limited applicability.
for example autocomplete implementations can be helpful at nding a method to call but they require some knowledge of the static type of the receiver and can only generate tiny code fragments.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists contact the owner author.
icse may june hyderabad india copyright held by owner author.to solve the problem of synthesizing code fragments we believe that programmers need to be able to give partial speci cations rather than full correctness conditions that may depend on concrete program state.
our approach thus generates and evaluates code at runtime at a programmerchosen location while executing a speci c concrete input.
we propose a new approach for synthesizing code that is dynamic easy to use and interactive.
running in the dynamic context both allows us to nd and lter out candidates that static techniques could not and allows users to reason concretely about their desired result.
we support a wide variety of speci cations so that we can even aid programmers with very little knowledge of their desired code.
our methodology is interactive letting users incrementally give more information to re ne the candidate code fragments.
taking advantage of dynamic information allows our algorithms to be more accurate than static techniques by for example dereferencing exactly the expressions that do not evaluate to null in the current context and downcasting the result of a method call to its dynamic type to enable subsequent calls.
in addition users can use dynamic values in their speci cations and see the results of executing the candidates which can be helpful in choosing the correct result.
one major goal of our work has been to ensure that users can nd code snippets using whatever partial information they have about the desired result.
our partial dynamic speci cations or pdspecs can be any predicate in the host language.
this exibility allows us to represent the full spectrum of speci cation strength and context sensitivity.
for example our pdspecs can take the form of constraints on the desired value including demonstrating a concrete value dynamic type restrictions or even full functional correctness speci cations.
we also allow users to write code skeletons to shape the search space by giving a syntactic outline of the desired code with holes marking unknown fragments.
given a set of candidate statements synthesized by our tool users can re ne this set by continuing to run the program or by exercising it on di erent inputs in order to lter out more candidates that fail the speci cation.
this re nement process can quickly remove many undesirable statements.
users can also sort and lter the candidates and their results.
these features often allow users to nd their desired code even with simple pdspecs.
another goal of our work is to enable the synthesis of code in real world java programs.
because it actually executes candidates in a concrete program state our implementation can synthesize code that uses i o re ection native calls and more.
we propose novel new techniques for using stan permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for third party components of this work must be honored.
for all other uses contact the owner author.
copyright is held by the author owner s .
icse may june hyderabad india acm 1final jcomponent tree maketree 2tree.addmouselistener new mouseadapter 3public void mousepressed mouseevent e int x e.getx y e.gety object o null get the menu bar or the clicked element.
figure code that handles clicks on a graphical tree of elements.
dard features of jvms such as breakpoints to ensure that our evaluations have no undesirable side e ects which users can selectively enable or disable to control the tradeo between e ciency soundness and completeness.
by analyzing over ten million lines of code we have developed a probabilistic model of real world java code that helps guide our search toward more common methods and elds.
to demonstrate the bene ts of our approach we conducted two user studies involving subjects solving multiple programming problems in di erent domains such as guis string parsing and eclipse plugins.
the statistically signi cant results show that subjects using our tool complete more tasks in less time and with fewer bugs than those without it by more than a factor of two.
users gave our tool positive subjective ratings.
in summary the main contributions of this work are a new method section .
for synthesizing code that is dynamic giving accurate results and allowing programmers to reason about concrete executions easyto use supporting a wide range of correctness speci cations and interactive allowing users to re ne the candidate code snippets .
an e cient algorithm section .
that exploits the dynamic context to generate candidate statements that can include advanced features of the host language such as i o re ection and native calls.
an implementation section as a plugin for the eclipse ide called codehint that synthesizes java code including android programs.
empirical evaluations and user studies section that show that codehint is e cient and signi cantly improves programmer productivity.
.
overview we now present two example problems and show how codehint can solve them.
the rst demonstrates codehint s algorithms while the second shows the user s perspective.
both examples involve the gui code using the java swing toolkit shown in figure .
readers are also encouraged to watch a demo video of codehint athttp .
.
algorithm example imagine that a user writes the partial code shown in figure and then wants to write code at line to nd the menu bar for the window that contains the graphical tree and store it in the variable o. a simple internet search willreveal that the menu is represented by a jmenubar object but will likely provide little information on how such an object can be acquired.
to use codehint to nd this object the user can set a breakpoint after line e.g.
near the comment on line and run the program to that breakpoint which is the current context.
since she knows that she wants to assign a value of type jmenubar to the variable o she can provide the speci cation o0instanceof jmenubar tocodehint .
we call this speci cation a pdspec and the o0denotes the value of the variable oafter the code to be synthesized is evaluated.
thus this pdspec encodes the fact that oshould change so that it contains an object of type jmenubar .
given this query codehint will begin a search for expressions that it can assign to oto try to satisfy the pdspec.
this iterative search will start with local variables and generate larger expressions with operations such as addition and method calls.
codehint will evaluate these expressions in the current context un side e ects as they occur to enable it to get precise results that satisfy the user s pdspec.
a probabilistic model will guide the search toward more likely expressions and codehint will group equivalent expressions together to avoid duplicate work.
once this search is complete codehint will show the user approximately ve results.
she can then add a new testcase to the code and run that new input which will allow codehint to remove two of the previous results that crash in the new context.
we now walk through codehint s algorithm in detail.
first iteration.
codehint will rst query the debugger for all the variables in scope evaluating them so it knows their dynamic types.
these along with the special values null andthis will become the initial set of candidate expressions that codehint is considering tree e x y o this null second iteration.
in its next step codehint will combine these simple expressions into more complicated ones according to the java grammar.
to do this it will rst query the debugger for the dynamic type of each candidate.
for each object it will query the debugger for all accessible methods available on that type and its supertypes and then call each of those methods with all type safe combinations of the previous set of candidates as arguments downcasting when necessary .
as an example codehint will nd that tree is a value of type jtree which is a subtype of jcomponent the static type of the variable .
it will then ask the debugger for the methods of jtree one of which is getpathforlocation .
this method expects two integer arguments so codehint will nd all of the integer valued expressions in its previous set of candidates which in this case are xand y.codehint will then call this method with all possible combinations of these arguments producing the following four calls jtree tree .getpathforlocation x x jtree tree .getpathforlocation x y jtree tree .getpathforlocation y x jtree tree .getpathforlocation y y codehint will repeat this process for other methods and for654static methods of classes imported in the current le.
for each pair of primitives such as integers codehint will combine them with binary operations.
thus given xand y it will generate the following expressions x y x y y x x y x y y x x y x !
y x y x y x y x y it will similarly generate object comparisons array accesses and length eld accesses integer and boolean negation e.g.
x addition and subtraction with e.g.
x andx comparisons with e.g.
x and x and boolean conjunctions and disjunctions.
codehint will evaluate each expression as it is generated so that it knows its result.
however expressions with side e ects must be handled correctly so they do not a ect future evaluations.
for example tree.add maketree will modify the tree potentially causing future evaluations to return di erent results in this new context.
to avoid this problem codehint uses novel techniques based on breakpoints and the java security manager to undo in memory side e ects after they occur and block harmful native calls.
harmless native calls such as reading from a le proceed normally.
in practice we have found that allowing users to relax these restrictions often gives correct results in less time.
in this case evaluating tree.add maketree will modify a eld of tree.
this will trigger a breakpoint installed by codehint which will log the change and undo it after the evaluation nishes.
once this process is complete codehint will have a new set of approximately candidate expressions tree e x y o this null x y x y tree.gettoplevelancestor window.getwindows jtree tree .getpathforrow x ... the set of candidates can grow quite large so codehint applies some optimizations that make it signi cantly smaller to avoid duplicating work codehint builds equivalence classes of expressions based on their results and only retains one representative of each class in its set of candidates.
for example tree.gettoplevelancestor is equivalent to swingutilities.getroot tree in the current context so only one the former in this case will be included in the set of candidates.
as we will see shortly codehint will use the equivalent expressions that are not in the list of candidates to help generate the results it shows to the user by substituting equivalent subexpressions.
to avoid spending time searching expressions that are rarely used in practice codehint uses a probabilistic model to avoid unlikely method calls and eld accesses.
this model contains information from over ten million real world lines of code.
as one example the jtree class contains a method called getnextmatch that was not called once in all of the analyzed code so codehint will not call it in this iteration.
codehint would have approximately candidates without either of these optimizations and approximately without both.
since these candidates are used to generate more expressions in the next iteration these optimizations signi cantly improve performance.
none of these candidates meet the user s speci cation as none have type jmenubar so codehint will automaticallycontinue this process of creating larger expressions from its current candidates.
third iteration.
the third iteration proceeds exactly as the second it combines the current candidates to produce larger expressions.
in this iteration codehint will use its probabilistic model to avoid searching some additional expressions.
libraries such as swing often contain many constants that are intended to be used only in certain contexts.
for example keyevent.vk enter helps determine if the user pressed the enter key.
to avoid using such constants in unrelated contexts codehint s probabilistic model stores exactly how they are used in practice.
this allows it to avoid generating expressions such as tree.getcomponent keyevent.vk enter as it recognizes that keyevent.vk enter was never used as an argument to getcomponent in the analyzed code.
during this iteration codehint will nd that the expression tree.gettoplevelancestor whose static return type iscontainer has type jframe at runtime.
codehint will then explore all the methods it can call on a jframe includinggetjmenubar which returns a jmenubar .
it will thus add jframe tree.gettoplevelancestor .getjmenubar to its next set of candidates.
at this point codehint will also explore some expressions that it avoided before due to its probabilistic model such as calls to jtree.getnextmatch .
this allows the algorithm to prioritize more likely expressions while remaining complete.
since it calls each method with all possible type safe combinations of the previous set of candidates codehint might end up making an exorbitant number of calls to a single method.
for example in this iteration it attempts to call defaulttreecellrenderer.gettreecellrenderercomponent .
this method has seven arguments including one of type object of which codehint has seen over unique values one of type int of which codehint has seen over one hundred unique values and four booleans each of which can be true orfalse which would result in well over calls.
to avoid spending so much time calling a single method codehint only calls it a small number of times.
speci cally if a method can be called more than a certain number of times that grows exponentially with the current iteration codehint calls it at most that many times with arguments that were candidates from previous iterations.
at the end of this iteration codehint will have generated and evaluated over expressions.
once it has nished this process codehint will nd which of its candidates satisfy the user s pdspec.
in this case jframe tree.gettoplevelancestor .getjmenubar when assigned to o is the only expression that satis es the pdspec.
before showing it to the user codehint will generate more satisfying expressions by replacing its subexpressions with equivalent expressions.
for example because swingutilities.getroot tree is equivalent to tree.gettoplevelancestor codehint knows jframe swingutilities.getroot tree .getjmenubar will yield the same result and hence also satisfy the user s pdspec.
codehint will thus generate this expression and three others that are all equivalent to the original expression.
now that it has expressions to show to the user codehint will use its probabilistic model to present the user with the more likely options closer to the top.
a call s likelihood is the number of calls to it that the model contains and an655expression s likelihood is the product of its subexpression s likelihoods.
in this case the gettoplevelancestor method was called times in the model while getroot was called times so the former expression is shown rst.
codehint will then show the user these expressions that when assigned to o meet the speci cation as well as their values side e ects and string representations jframe swingutilities.getwindowancestor jtree .getjmenubar jframe tree.gettoplevelancestor .getjmenubar jframe swingutilities.getroot tree .getjmenubar ... ifcodehint had not found any results that satis ed the user s pdspec at this point it would have noti ed the user and asked if it should continue for another iteration.
note that the results codehint found all rely on being able to discover the dynamic type of an expression and downcast to it something that static tools will nd di cult to do.
refinement.
the user can now examine these expressions their results and their documentation to try to pick the one she wants to use.
if she is unsure which is correct she can re ne the set of results by running the program on a di erent input.
let us assume that the user modi es the code so that the tree is contained within an applet that is itself contained within the top level window which might be useful for running the same code both by itself and within a web browser.
once she makes this change she can run the new program until it reaches the point where she ran the previous search.
codehint will then evaluate the previous results in the new context.
in this case two of them including jframe tree.gettoplevelancestor .getjmenubar will crash.
codehint will show this smaller set of results to the user who may select one of them to use or continue the process with yet another input.
.
user perspective example a common task when writing gui code is to detect clicks on a graphical tree of elements.
a programmer might be unsure how to nd the clicked element so she can use it.
unfortunately as she does not know the api she is not even sure what type this object has it could be a node object the data it represents or the displayed string.
as she does not even know the type of the expression she desires it is di cult to nd.
using codehint she can easily run the code click on a node and give a pdspec that expresses which node she clicked.
to use codehint to nd the code she desires she can set a breakpoint after line and then execute her code and click on the top element.
knowing that in java most objects have a tostring method that gives a string representation of their value she realizes that if she clicks on an element labeled alice the tostring of her desired result should contain that string.
this insight can lead her to enter the pdspec o0.tostring .contains alice which encodes the fact that the value of the variable oshould be updated by the desired statement so that its tostring contains alice .
codehint will then generate eight expressions to assign to o jtree tree .getpathforlocation x y jtree tree .getselectionpath jtree tree .getlastselectedpathcomponent ...to reduce the number of candidates the user can continue the execution or restart it and click on a di erent element.
assume she does so and clicks on an element labeled bob .
when the execution suspends at the breakpoint codehint will show her all eight of the previous expressions with their results in the new context.
she can then give a new pdspec to lter out some expressions.
giving o0.tostring .contains bob will remove one expression.
alternatively by looking at the results of the eight expressions she might see that many return an object of type treepath that seems to do what she wants so she can use the pdspec o0instanceof treepath to keep only those.
assume that now the user clicks below all the elements.
she can then see all of the remaining candidate expressions with their new values and keep only those that evaluate tonull with the pdspec o0 null .codehint will then eliminate all but one candidate and nd the correct code o jtree tree .getpathforlocation x y this example shows how our approach can be useful even when a programmer has very little knowledge about her desired result perhaps not even its type by allowing her to refer to values in the concrete program state.
the programmer narrows down the set of candidate statements by incrementally providing pdspecs for di erent test scenarios.
a key advantage of our methodology is that programmers can mix and match value demonstrations type speci cations and arbitrary pdspecs as desired.
in addition the interactivity of codehint allowed the user to nd the correct result from the initial candidates.
this example was inspired by how one subject in our rst user study solved this problem.
this example also shows how our approach can easily synthesize real code involving complicated libraries.
while the nal synthesized code appears simple executing it involves making over method calls that allocate new objects and use complex objects generics and binary only libraries.
using skeletons.
perhaps now the user wants to get the data representing the object she clicked out of the treepath object she just assigned to o. let us assume that she changes o s type in the code and discovers from the type s documentation that it contains a getpathcomponent method that she thinks will help her.
however she is unsure what argument to pass to this method.
the user can encode this knowledge into a skeleton that codehint will use to guide its search.
speci cally she can enter the skeleton o.getpathcomponent ?
?
where the ?
?
represents the missing portion of the code.
given this skeleton codehint will search for expressions that can be used as arguments to getpathcomponent which expects an integer.
as before the user can set a breakpoint where she wants to insert code run the program on a test and click on an element to hit the breakpoint.
if she clicks on eve she can enter the pdspec rv0.tostring .equals eve to show that she now wants some object that represents eve the rv0represents the return value of the expression along with the skeleton discussed above to guide the search.
codehint will now search for integers that when passed togetpathcomponent meet the user s speci cation which include the following o.getpathcomponent e.getclickcount o.getpathcomponent o.getpathcount 656by re ning the set of candidates by giving di erent pdspecs in di erent states the user can remove incorrect expressions such as the rst one above.
this example shows how users can encode their partial knowledge of the correct code to allow codehint to focus its search on relevant code snippets.
.
pdspecs and synthesis algorithm we now de ne pdspecs and our synthesis algorithm.
.
pdspecs and our approach without loss of generality let us assume that we have an incomplete program in which a statement say st is missing.
the developer wants to synthesize this statement using codehint .
she creates a test input so that the execution of the program on the test input reaches the program location say that is just before the missing statement.
let be the program state when the program reaches the program location .
we use to denote the set of all feasible program states.
the goal of codehint is to discover the missing statementst.
let exec s be the program state obtained by executing the statement sin state .
let us use 0to denote exec st i.e.
the program state reached after the user executes the missing statement stin the state .
as a running example let us assume that isfx7!42gandst isx x .
then 0isfx7!84g.
the user does not know the missing statement st but she might have a good idea about what the program state should look like after the execution of st i.e.
.
with codehint the user can indirectly provide a hint about the statement stby giving information about the state 0using pdspecs.
a pdspec can give absolute information about 0by describing the updated program variables and their corresponding values or it can be a predicate relating the states and .
for example a pdspec can specify x0 where x0represents the value of xin state or it could specify x0 x a predicate that relates the states and .
in general a pdspec can consist of any expression in the host language.
note that a pdspec that is speci ed in the state may not be a correct pdspec if the program is in a di erent state at the location .
a di erent state at location can be reached by executing the program on a di erent test input.
for example x0 xis not a correct pdspec if the program state at location isfx7!
20g but it is a correct pdspec if the state isfx7!10g.
similarly x0 is not a correct pdspec for any program state with x !
.
note that x0 x is a correct pdspec for all program states that reach the location .
formally a pdspec is a logical predicate !
ftrue falsegwhere checks whether 0is a desired output state given the input state .
as a notational convenience for a pdspec we refer to variables in the input state using their names and variables in the output state 0using their primed names.
all variables not given in a pdspec must be equal in the two states and all expressions in a pdspec must be free of side e ects.
the user of codehint gives a sequence of pairs of program states at reached by executing the program on different test inputs and their corresponding correct pdspecs .
letsbe the set of all syntactically valid statements that can be written at location .
based on the sequence of pairs of states and pdspecs codehint returns a set of candidate program statements that couldreplace the missing statement.
for example if the user provides the sequence of pairs i i the set of suitable statements for the location is reduced to the set ci s2s j i j j exec j s the predicate j j exec j s is true if the state jand the state obtained after executing statement sin the state jsatisfy the pdspec j. statement sis in the candidate set if this predicate is true for all j. if a statement sis in the candidate set it implies that at least for the program states iobserved at the location the execution of the statement swill result in the user s expected program state.
if we could compute the candidate set for all possible pairs of programs states reachable at and their corresponding correct pdspecs the set is guaranteed to contain the target statement st. however in practice it not possible to enumerate all such possible pairs.
instead the user demonstrates such pairs one by one and codehint computes a candidate set from the pairs provided by the user.
note thatci ci so the size of the candidate set shrinks as codehint receives more pairs.
at any point if the user notices a statement she could use as a substitue for the missing statement she stops the process and uses the statement.
as the set of legal statements scould be in nite codehint restricts it to a nite set.
for example this set could only include statements whose abstract syntax trees have height at mostkand only use the variables available in the current scope.
we call kthe depth of the search space.
in practice users often have some idea of the structure of the statement they desire.
in our running example the user might know that she wants to multiply xby something but might not know exactly what should be multiplied.
by providing a skeleton discussed more in section .
the user can further restrict the search space.
here this skeleton might be x ?
?
x where ?
?could be replaced by any valid expression.
in our running example given the initial state fx7!
42g the pdspec x0 and the skeleton x ?
?
x we present the user with the following set of candidate statements c0 fx x x x x g without the skeleton we would additionally have included statements like x x x and x x x .
in either case the number of candidate statements might be large but will be nite.
given another initial state fx7!6g the pdspec x0 and the same skeleton we present the user with the subset c1 fx xg.
.
synthesis algorithm our algorithm generates statements containing java expressions that include variables array accesses casts eld accesses method calls constructor calls and unary and binary operators including calls to static methods and elds of imported classes.1it begins by collecting all the variables in scope and then iteratively uses the current set of statements 1there seems to be no technical barrier to extending this language to cover all java statements except for anonymous class declarations but we have seen no need to do so yet.657to generate larger ones.
when it reaches a xed maximum size it removes those that do not satisfy the user s pdspec.
in particular our algorithm generates statements in increasing order of depth which is the height of the parse tree.
as examples xhas depth foo.bar x y has depth and foo.bar.baz x y has depth .
a key insight is that if two statements have the same effects we can treat them as equivalent when generating further statements.
we take advantage of this fact by grouping statements into equivalence classes based on their e ects and values.
as an example there might be hundreds of pure boolean valued expressions at a given depth but they all evaluate to either true orfalse .
we henceforth describe our algorithm in this special case of expressions but note that it works for the more general class of statements.
we de ne an equivalence relation on expressions such that two expressions are equivalent if they have the same side effects and yield the same value in the current state.
we writee1 e2to denote that the expressions e1ande2 have the same side e ects and yield the same value in the state .
following standard java idioms and practices two expressions e1and e2are equivalent if both are primitives and e1 e both are objects of the same type and e1 null ?
e null e .equals e or both are arrays of the same type with the same number of elements and all corresponding elements are equivalent.
our algorithm iteratively builds all expressions up to a xed depth evaluating them with a timeout and creating equivalence classes as it goes.
for each equivalence class we use only one representative to generate further expressions.
for example if xand z.f are equivalent we generate x 1and foo x but not z.f orfoo z.f .
we take the current set of side e ects into account when generating new expressions from representatives of these equivalence classes.
for example when xis42we will notice that xand 42are equivalent.
later when considering expressions to add to x we will use the equivalence class for the state where xis43and consider xand42separately.
when the desired depth has been achieved we test the equivalence classes for the initial state against the pdspec lter out those that do not satisfy it and recreate the full set of candidate expressions from the equivalence classes.
once we discover that an expression satis es the pdspec we know that all expressions generated from it by replacing its subexpressions with expressions that are equivalent in the current state will also satisfy the pdspec.
continuing the previous example if p.bar x satis es the pdspec so will p.bar z.f .
we apply a number of optimizations to improve the e ciency of our algorithm.
we use a variety of simple structural techniques to avoid enumerating obviously equivalent expressions such as x yand y x .
we call the hashcode method to speed up checking equivalence between objects.
we cache the result of each expression and use that result instead of the expression itself in future evaluations and replay its side e ects to avoid duplicating work.
by actually evaluating the generated expressions our algorithm can synthesize real world java code including le i o binary libraries re ection foreign function calls and calling the user s own methods.2thus while the individual expressions we generate appear somewhat simple they can 2some of these features require the user to allow searching native calls in which case we cannot undo side e ects.in fact be quite complicated.
in addition we were able to synthesize code for android without any extra modeling.
probabilistic model and pruning.
to guide our algorithm toward exploring more likely expressions we have added a probabilistic model based on an o ine analysis of over ten million lines of code.
this allows us to compute how often certain types methods and elds are used.
having analyzed how often each method and eld is accessed we de ne the probability of accessing member m calling a method or accessing a eld of type tas p mjt p t accesses of mont of accesses on t of accesses on t of accesses the probability of an expression is then the product of the probabilities of its individual accesses.
in addition as java classes often contain many constants we store for each constant eld all the places it is used as an argument to a method.
this model is somewhat simplistic as it assumes that all method calls are independent but we have found it very helpful in practice.
we use this probabilistic model to avoid calling rare methods and using constants in places they were rarely used as well as to sort the candidates presented to the user.
the size of the space of expressions that our algorithm must search at a given depth is exponential due to method calls.
if at one point during a search we have seen different integer values there will be 503di erent ways to call a method with three integer arguments.
such growth can easily overwhelm our algorithm so we heuristically prune calls to methods that would otherwise be called with a large number of di erent arguments especially ones our probabilistic model de nes as uncommon.
that is if a method can be called more than a certain number of times that is exponential in the current depth we arti cially increase the depth of calls to it.
as we will see in section .
such calls occur infrequently in practice.
we believe this would be a promising area in which to integrate symbolic techniques.
skeletons.
as mentioned earlier users may provide a skeleton to shape the search space explored and guide it toward candidates they know to be likely.
skeletons consist of normal java code with holes for unknown code that should be synthesized.
the language contains two types of holes simple holes denoted ?
?
and list holes denoted .
simple holes can take the value of any expression or name in the language or be annotated with a set of candidates.
list holes are used for calling functions with an unknown number of arguments each of which is a separate expression hole.
users may additionally check a box indicating whether or not constructor calls and in x pre x operators should be searched.
to give some examples ?
?.??
represents accessing some eld of an unknown expression foo.??
bar baz ?
?
represents calling either the baror the bazmethod of the foo object with a single unknown argument and ?
?
represents calling an unknown method with any number of unknown arguments.
since the given pdspec applies to the whole statement we must explore the cross product of all the speci ed holes.
given a skeleton we ll each hole with type correct values using the algorithm described above unless the hole has been annotated with candidate values in which case we658simply try those values in lieu of a search .
if a skeleton has many holes we reduce the depth of our search for each hole.
.
implementation we have developed an implementation of our approach which we call codehint as a plugin for the eclipse ide for java.3this allows users to develop normally using our approach only when they wish to do so.
to use codehint a programmer must start a debug session and navigate to the program location and state in which she wishes to insert code.
she then enters a pdspec and possibly a skeleton through a dialog.
we then synthesize candidate expressions and show them their results and tostring s and their side e ects to the user who can select which to keep.
the user may also view the javadocs of methods and elds used in the candidates and sort or lter them.
if she does not nd any expressions she wants she can continue the search with an increased depth.
when execution encounters the location of a previous synthesis we begin our re nement process by showing the user the previously chosen candidates and their values in the new context.
she may enter a new pdspec to re ne the current set of candidates or lter or sort the results.
in addition she may abandon the current results and start a new search which can be useful if she previously gave an invalid pdspec or if our search did not nd any correct statements.
our implementation detects in memory side e ects while evaluating expressions by installing watchpoints to listen for eld accesses.
this allows us to log all the side e ects of an evaluation and afterwards undo them and show them to the user.
we use java s security manager to disable external side e ects such as deleting les and we block unknown native calls which do not go through the security manager .
users can selectively enable or disable these features to control the tradeo between e ciency soundness and completeness.
.
evaluation we now show through empirical analysis and two user studies that codehint is su ciently scalable and that it makes users more productive.
.
empirical evaluation scalability.
to analyze the e ciency of our implementation and demonstrate its scalability with regards to depth as de ned in section .
we ran the tasks used in our rst user study described in section .
.
with a typical pdspec i.e.
the one most frequently used by subjects in the study and a skeleton indicating that we should not search constructors and operators.
for each task we varied the maximum depth searched and for each depth we recorded the number of unique expressions evaluated and the total time taken.
the experiments were performed on an intel core duo e6850 with two ghz processors and gb ram although our current implementation is single threaded running linux .
.
and java .
.
.
the results in table show that our current implementation when not un side e ects can explore a search space of depths and in one second and depth in 3codehint its source and video demos are available at .
ve seconds.
we do not show depth for which we have not optimized and all but four benchmarks timeout after two minutes.
when un side e ects our unoptimized implementation takes a couple of seconds to search depth .
we believe these results are more than su cient for a useful tool and results from the user studies show that users agree.
as part of our methodology codehint nds all expressions in its search space that satisfy the user s pdspec not just one.
since we display each such candidate expression as soon as we discover it users can usually see some candidate expressions well before the search terminates.
to measure the e ectiveness of various parts of our algorithm we searched depth with pruning disabled and with pruning equivalence classes and the probabilistic model disabled.
the results given in the rightmost columns of table show that these improvements signi cantly reduce the search space enabling codehint to nd larger expressions.
without them it would not be able to search even depth .
to show that codehint can synthesize large code fragments we tracked the size of the expressions explored for each task.
the largest such code snippet contained ten method calls showing that our algorithms can indeed scale to non trivial code fragments.
analysis of expressions.
to justify our algorithm we analyzed ve medium to large open source java projects.
the key result is that the vast majority of assignment statements are actually quite simple with a depth of at most .
we analyzed hadoop a framework for distributed computing based on mapreduce with a distributed le system tomcat a web server findbugs a static analysis tool hibernate which maps objects into a database and jdk the implementation of java.
for each program we analyzed the right hand side of assignment statements which is the exact class of statements we currently generate.
hadoop version .
.
contains such expressions tomcat .
.
contains findbugs .
.
contains hibernate .
.
contains and jdk .
contains .
we began by analyzing the depth of the expressions.
all ve programs followed a similar pattern on average of expressions had depth had depth had depth had depth and were more complicated.
this shows that the vast majority in our study of statements in real java code have depth at most which our results above show that codehint can easily search.
to show that these results also hold for code programmers struggle to write we repeated the same experiment on code snippets gathered from questions asked on the popular stack over ow website.
we examined code samples containing lines of code and found nearly the same distribution had depth had depth had depth and had depth .
while users might want to synthesize multiple lines of code at a time we believe these results suggest that our current algorithms can help real programmers.
we conservatively bounded the number of cases in which we pruned calls to methods that could be called with many di erent arguments by analyzing the number of calls with a given number of arguments.
all ve programs followed a similar pattern of calls had no arguments excluding the receiver had one argument had two arguments had three arguments and had four or more.659table an empirical analysis of our algorithm.
each row represents one task from the rst user study.
the rst six result columns show how our algorithm performs at di erent depths the next shows the performance when we undo side e ects and the last two show the performance with various parts of the algorithm disabled.
the columns show the number of expressions searched and times are in seconds.
normal algorithm side e ects no pruning brute force depth depth depth depth depth depth time time time time p .
.
.
.
p .
.
.
.
p .
.
.
.
p .
.
.
.
p .
.
.
.
s .
.
.
.
s .
.
.
.
s .
.
.
.
s .
.
.
.
s .
.
.
.
r .
.
.
.
r .
.
.
.
r .
.
.
.
r .
.
.
.
r .
.
.
.
avg .
.
.
.
.
.
.
.
med .
.
.
.
thus of calls in practice contain two or fewer arguments and hence little combinatorial explosion and so biasing our search to avoid the rest seems bene cial.
we additionally note that just because a method has multiple arguments does not mean that there will be many ways to call it as arguments are often of types that have few values in practice such as singletons.
our heuristic will not avoid such calls.
.
user studies we conducted two user studies to evaluate the usability of codehint and learn how developers use it.
the rst study focused on constrained single line code edits and the second focused on larger open ended tasks and used an improved version of codehint .
observations from these studies generated additional areas for improvement that we implemented in the meantime including the skeletons of section .
.
.
.
methodology study line level tasks.
for the rst study we created three scenarios with ve sub tasks each that mimic code completion tasks programmers face in practice.
to focus on particular tasks where codehint could be applied we provided working wrapper code that participants had to extend.
the parse or p scenario manipulated strings and parsed email headers and command line arguments.
the swing or s scenario created a small gui.
the randomwriter or r scenario created a markov model to generate output that looked similar to input text.
we chose the rst two scenarios to represent common tasks involving apis and the third as an example application.
the rst part of section .
is a slightly modi ed version of one of the tasks.
at the time of the study codehint could solve thirteen of the fteen tasks we included the remaining tasks to see how subjects handled cases it could not solve both could havebeen found with a slightly higher search depth and can be found by the current version of the tool .
in our within subjects study each user received a random assignment of control experimental orchoice conditions to scenarios.
in the control condition users could not use codehint in the experimental condition they were required to use it although they could write code normally if it failed and in the choice condition they could decide whether or not to use codehint for each task.
we counterbalanced the order of the experimental and control groups and assigned the choice condition last so participants had experience both using codehint and writing code normally.
study open ended tasks.
the tasks in the second study were larger each task required writing three to sixteen lines of code that used complex apis.
two scenarios had three tasks each again scaffolded by wrapper code.
the eclipse scenario implemented a simple eclipse pro ler plugin and the note scenario involved writing a gui note taking application that synchronized data to the cloud.
example tasks included nding all the objects in the heap of a program running in eclipse and adding a menu item that made selected text bold.
each participant solved one scenario in the control group and the other in the choice group as de ned above .
subjects in the choice group could solve tasks using a combination of codehint and traditional techniques.
both the scenarios and the groups were ordered randomly.
we additionally allowed subjects who could not solve eclipse tasks in the control group to solve them with codehint .
the tasks were designed to be di cult to solve so we stopped subjects if they had not completed a task after twenty minutes.
.
.
participants nine subjects initially completed the rst study another ve were recruited later to complete only the choice con 120controlcodehint improved time s study task comp letion time figure the task completion time of subjects in our rst user study.
the error bars show the standard error.
80codehintcontrol completed study task c ompletion rate figure the task completion rate of subjects in our second user study.
the error bars show the standard error.
dition of the same study with an improved version of the tool to collect additional data.
twelve were graduate students in computer science at uc berkeley and two were undergraduates.
another fourteen subjects completed the second study which used a further improved version of codehint .
ten were undergraduates and four were graduate students in computer science at uc berkeley.
in both studies participants practiced on some training tasks rst and completed a post test questionnaire.
they were allowed to use a web browser to search for help.
none of the subjects had ever used codehint before but all were somewhat familiar with both java and eclipse.
.
.
measures we de ned the following measures task completion time time taken to either complete or abandon a task.
task completion rate percentage of tasks users successfully completed.
code quality number of bugs in participants task code.
tool choice fraction of tasks in the choice condition for which participants opted to use codehint .
.
.
results we rst discuss quantitative results followed by qualitative impressions of how our participants used codehint .
productivity and preference.
completion time in all but one case participants in the rst study completed all tasks so we focus our analysis on task completion times.
on average subjects using the improved version of codehint completed tasks in seconds and control participants took seconds see figure .
thisdi erence is signi cant two sample t p two tailed .
this suggests that programmers are more productive when using codehint .
completion rate participants in the second study did not complete many tasks so we focus on task completion rates.
figure shows the task completion rate for users in our second study with and without codehint .
on average subjects using codehint completed of sub tasks while those not using it completed n p which strongly suggests that programmers complete more di cult api tasks when using codehint .
code quality participants introduced bugs in tasks solved with codehint in our rst study and bugs in tasks in code written without it two sample t p two tailed .
this suggests that codehint improves code quality.
to focus on the completion rate we gave subjects in the second study a comprehensive test suite so they wrote almost no bugs.
tool choice in the choice condition each user could elect whether or not to use codehint for each task.
on average over both studies subjects used codehint of the time suggesting that users found codehint valuable.
in the questionnaire participants in both studies rated the overall usefulness of codehint at an average of .
out of with a standard deviation of .
.
all users reported that they would use codehint for their own development if it were available for their language and editor and had some simple aws xed.
six of the subjects asked for the plugin shortly after completing the user studies and installed it.
qualitative results.
codehint presented only a small number of candidates to the user after the initial pdspec in the rst study the average number of candidates across all episodes was and the median was and in the second the average was and the median was .
when re ning an existing set of candidates users in both studies provided pdspecs that reduced the number of candidates by on average.
however out of the re nements did not reduce the size of the candidate set at all mostly because all the candidates were already equivalent on all possible inputs.
ignoring those the average reduction was .
choosing a pdspec requires trading the strength of the speci cation for the ease of encoding it and the cost of evaluating it.
to examine this tradeo we classi ed all of the pdspecs used by subjects while completing the user studies and found that in the rst study demonstrated the desired value gave the desired type and were arbitrary predicates.
in the second study subjects used only type demonstrations for the eclipse scenario as its di culty lay in nding and using complex types but for the note scenario they gave value demonstrations type demonstrations and arbitrary predicates.
this shows that users can get bene ts with codehint even while demonstrating simple pdspecs but that the ability to provide more expressive pdspecs is sometimes valuable.
.
related work programming by demonstration also called programming by example is a popular area of research much of which deals with synthesizing macros and scripts .
unfortunately these techniques have not been widely adopted in part because users have di culty understanding and cor 661recting the learned generalizations .
we attempted to avoid these problems by integrating codehint into the user s work ow and encoding its state directly in the code.
there has been much work on live programming and how it can bene t programmers .
this work inspired us to design our methodology to support concrete reasoning.
program synthesis has had numerous successes at synthesizing code in small well de ned domains such as bitvector logic and data structures as well as somewhat more general classes of programs .
as they are backed by decision procedures and smt solvers these techniques are very e cient in certain domains that have been fully modeled while codehint is not domain speci c and works without any modeling e.g.
it can read from the le system .
we thus view these as complementary techniques.
there has been much research on helping programmers explore new apis by mining existing code to nd snippets that are used in practice .
unlike such systems by evaluating code at runtime we can di erentiate between di erent values of the same type downcast precisely and use more general speci cations as in section .
test generation techniques generate inputs to explore branches within code which is equivalent to satisfying boolean speci cations but they do not always generate the code to construct those inputs.
seeker synthesizes code fragments with a combination of dynamic and static analysis.
its reliance upon static analysis means it cannot generate certain code fragments that codehint can but allows it to be more e cient in many cases.
we would like to integrate similar techniques into codehint .
some existing code search tools allow more general speci cations such as natural language queries or testcases but they lack the full power of our pdspecs and our ability to use dynamic information.
our skeletons are similar to the partial expressions of and the holes of .
the smalltalk method nder allows programmers to specify concrete arguments and the desired result and then evaluates all methods of the given receiver with the given arguments to see which return that result.
the algorithm is thus very simplistic but it allows giving multiple demonstrations similar to our re nement methodology.
in summary the key bene ts of our approach are the precision enabled by our dynamic nature the generality of our pdspecs and the fact that we can handle the full java language without any modeling.
the main disadvantages are that we are less e cient and provide fewer correctness guarantees than some existing techniques.
the way our algorithm iteratively generates expressions of larger depth is similar to the approach used by chess as we both search the space in a way that prioritizes elements that are more likely to occur in practice.
our representation of the search space is similar to version space algebra but we can more e ciently eliminate redundant elements.
our equivalence classes are similar to ideas from daikon randoop and model nding .
unlike randoop we enumerate all solutions guided by our probabilistic model toward more likely expressions up to some bound instead of randomly searching the space.
our techniques are also more powerful than these and they handle primitives objects and arrays.
we also apply the algorithms in the new domain of program synthesis using them to gain the ability to synthesize real java code.
most importantly unlike these approaches we are sound in the presence of side e ects.our probabilistic model is currently simpler than those used in other work e.g.
.
as we have found our model to be very useful in practice we would like to improve it.
many existing techniques for un side e ects in java focus on transactions or sandboxing .
these approaches can be e ective but often require modifying the client code or the runtime system.
in contrast our watchpointbased algorithms are slower but require only a standard jvm.
research on speeding up watchpoints could improve the e ciency of our approach or we could use a more e cient technique.
some researchers have used standard jvm techniques to reset only static state our approach in some ways generalizes this work to reset all state.
.
future work we plan to continue to improve our algorithms.
one promising technique is to integrate a symbolic solver into our approach as both have complementary strengths our algorithm can handle arbitrary java method calls while symbolic techniques can quickly explore a very large search space in certain domains.
we would also like to continue to improve our probabilistic model of what code looks like in practice.
our approach seems well suited to dynamic languages as unlike static tools we can leverage their runtime information.
we would thus like to develop an implementation of codehint that works for a language such as javascript.
.
conclusion we have presented a novel methodology that helps programmers write di cult statements.
this methodology is dynamic evaluating code and runtime and letting users inspect the results easy to use accepting a wide range of speci cations and interactive helping users gain information about the missing code .
our algorithms are e cient and let us synthesize code that uses real world java features such as native calls and re ection.
we have run two user studies that shows that our tool codehint signi cantly improves programmer productivity.
.