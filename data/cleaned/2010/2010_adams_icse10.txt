identifying crosscutting concerns using historical code changes bram adams zhen ming jiang ahmed e. hassan software analysis and intelligence lab sail school of computing queen s university canada bram zmjiang ahmed cs.queensu.ca abstract detailed knowledge about implemented concerns in the source code is crucial for the cost effective maintenance and successful evolution of large systems.
concern mining techniques can automatically suggest sets of related code fragments that likely contribute to the implementation of a concern.
however developers must then spend considerable time understanding and expanding these concern seeds to obtain the full concern implementation.
we propose a new mining technique commit that reduces this manual effort.
commit addresses three major shortcomings of current concern mining techniques their inability to merge seeds with small variations their tendency to ignore important facets of concerns and their lack of information about the relations between seeds.
a comparative case study on two large open source c systems postgresql and netbsd shows that commit recovers up to .
more unique concerns than two leading concern mining techniques and that the three techniques complement each other.
categories and subject descriptors d. .
distribution maintenance and enhancement concerns mining software repositories general terms algorithms documentation experimentation keywords concern mining mining software repositories empirical research .
introduction a concern is commonly defined as anything that stakeholders consider as a conceptual unit .
concerns range from developmentoriented tracing and more general purpose caching to domainspecific business rules .
developers and architects continuously need up to date knowledge about concerns currently implemented in their systems and about the location of these concerns throughout the code.
for example during maintenance and re engineering permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
.developers need to locate specific concerns in the source code.
bug fixes must be propagated to the whole implementation of a concern and possibly to other concerns with which the concern interacts.
architects need to map the currently implemented concerns to the reference architecture to verify architecture conformance.
as such concern mining is indispensable for software maintenance reverse engineering re engineering and even for redocumentation.
as manual concern mining is tedious and subjective concern mining techniques support the identification of concerns in software systems.
static techniques analyze source code dynamic techniques analyze execution traces and history based techniques analyze changes in the source code repository.
the techniques generate concern seeds which are sets of program entities that possibly contribute to the implementation of a concern.
in a typical concern mining process developers perform the four steps .
generate concern seeds using concern mining techniques .
determine whether a seed represents a concern by analyzing how its fragments work together .
complete the seed manually if it represents a concern .
try to understand the interaction between concerns.
except for step the concern mining process is purely manual.
concern browsing tools can support the process but they still depend on the quality of the concern mining results and human input.
due to shortcomings in current concern mining techniques the mining process in practice requires considerable time and resources slowing down developers.
we identified three major shortcomings of current concern mining techniques which hinder multiple steps of the concern mining process s1 inability to merge seeds with variations concerns are often implemented by cloned code fragments .
customization and developer mistakes lead to slight variations between the clones.
concern mining techniques can no longer unify them.
this leads to duplicate seeds which developers must process in step of the mining process.
s2 tendency to ignore important facets of seeds most of the mining techniques describe the behavior of seeds functions but ignore the state of seeds variables and types andpreprocessor entities macros .
hence mined seeds are less representative of the actual implementation of a concern making steps and more time consuming for developers.
s3 lack of information about seed relations composite concerns are large widely scattered concerns that are hard to maintain.
they are usually composed of multiple sub concerns .
currently developers need to discover each collaborating sub concern manually in step .
305we propose a concern mining technique named commit concern mining using mutual information over time that addresses these three shortcomings.
commit analyzes the source code history to statistically cluster functions variables types and macros that have been changed together intentionally.
the links between the clusters reveal the relations between seeds.
we compare commit to two other state of the art mining techniques on the open source postgresql database and netbsd operating system.
we find that commit complements the other two techniques while recovering a larger number of unique and rich concern seeds many of which represent widely scattered composite concerns.
our main contributions are as follows identification and discussion of three shortcomings that hinder the concern mining process.
design of a history based concern mining technique commit to address these three critical shortcomings.
a large scale empirical comparison of commit with two leading mining techniques .
organization of the paper.
section introduces relevant concern mining terminology.
section discusses three identified shortcomings of state of the art techniques.
section presents commit and explains how it addresses the three shortcomings.
section compares commit to a leading static technique cbfa and history based technique ham by applying these techniques on the postgresql database and netbsd operating systems.
section discusses threats to validity.
related work is presented in section and section summarizes our findings.
.
background this section introduces important concern mining concepts.
for the reader s convenience we briefly explain how the state of theart cbfa and ham concern mining techniques work as we use them throughout this paper to motivate the shortcomings of current concern mining techniques and we compare our commit mining technique to them.
we illustrate cbfa and ham on figure which contains four successive versions of a simple c system consisting of a client server front end andback end.
.
terminology concerns can be categorized based on the modularity of their implementation.
modular concerns are the easiest to locate and understand as their implementation is concentrated in one source module or component.
crosscutting concerns cccs are concerns that are not modular.
their implementation is spread scattered across multiple modules.
each scattered code fragment of a ccc is called an instance of the ccc.
the instances of a ccc can be more or less identical to each other homogeneous ccc or exhibit large variations heterogeneous ccc .
acomposite concern is a ccc consisting of multiple smaller sub concerns that work together.
these sub concerns are typically spread out across a large number of components and development teams .
for example as encryption support without decryption support is meaningless a secure communication concern consists of multiple instances of an encryption sub concern one for each sender andmultiple instances of a decryption subconcern one for each receiver that work together.
concern mining techniques generate concern seeds i.e.
sets of related code entities that likely contribute to the implementation set of instances of a concern.
these techniques focus especially on cccs as modular concerns can be easily identified manually.
depending on the intended usage of a technique it can be applied as frequently as once per release for documentation up until once per feature request or even bug report.
.
cbfa clustering based fan in analysis cbfa is a recent generalization of the widely used fan in static mining technique .
cbfa uses the number of unique callers of each function i.e.
fanin value as an indicator of the scattering of the use sites of that function across the system.
cbfa then filters out functions that are invoked too frequently utility functions and getter or setter functions or not frequently enough.
functions with sufficiently similar substrings in their names are clustered together to create larger seeds.
finally cbfa ranks the seeds based on a cluster fan in metric i.e.
the sum of the fan in values of all functions in a seed.
the second column of table shows the concern seeds identified by cbfa in version of figure .
these seeds are ordered by their cluster fan in then by their dimensiond number of program entities that they contain .
the log lock3 functions rank very high as they are invoked eight times in total.
.
ham history based aspect mining ham is a history based concern mining technique .
ham clusters all functions nthat add or remove a call to the same function during a particular time interval or in all change transactions of a particular developer.
then ham assigns all functions fthat are called by the same cluster of calling functionsnto the same concern seed.
the third column of table shows the mining results of ham based on the four versions of figure .
ham orders its results first on the seed dimension d then on the scattering value s number of unique calling functions over which the concern is scattered .
the top results correspond to seeds of up to three program entities which are called from one or two functions.
the logging concern is not reported as a top result since the dimension dfor seeds five and six which correspond to the logging concern is only one.
.
three shortcomings modern concern mining techniques suffer from three shortcomings that hinder the concern mining process.
we discuss these shortcomings by comparing the results of cbfa and ham on figure against the desired mining results in the fourth column of table .
for each shortcoming we discuss its motivation give examples and explain how an ideal mining technique should deal with it.
the first shortcoming has been discussed before .
s1 inability to merge seeds with variations motivation concern mining techniques cannot cope well with variations in the instances of a concern.
such variations are quite common.
for example bruntink et al.
analyze the implementation of a tracing concern in a large company.
despite explicit coding guidelines the implementation of the tracing concern contained significant variations because of developer mistakes local optimizations and ambiguous coding guidelines.
concern mining techniques would typically generate separate seeds for each instance variation delegating the costly task of identifying and merging similar seeds to the developer step of the mining process .
examples figure contains two illustrations of a ccc with small variations in its instances and two illustrations of a ccc with large variations.
in version the back end developer accidentally or intentionally calls start log instead of end log in the back end.
ham is incapable of merging the concern seeds start log andend log into one seed because the sets of use sites of both seeds are not identical.
the set of use sites of start log contains client front end2 andback end while the set of use sites of end log contains client andfront 306void client void do something void front end void do something void back end void do something a version .void client void s t a r t l o g sending do something end log done!
void front end void s t a r t l o g receiving do something end log done!
void back end void s t a r t l o g storing do something s t a r t l o g done!
b version .extern queue t queue void client void start log sending do something lo ck queue enqueue queue ... unlock queue end log done!
void front end void start log receiving lock2 queue do something unlock2 queue end log done!
void back end void start log storing do something start log done!
c version .extern queue t queue void client void start log sending do something lock queue enqueue queue ... unlock queue end log done!
void front end2 void start log receiving s t a r t l o c k queue lock data queue do something unlock data queue end lock3 queue end log done!
void back end void start log storing lock data queue do something unlock data queue start log done!
d version .
figure motivating example that illustrates the shortcomings of concern mining techniques.
bold text corresponds to the addition or removal of dependencies on program entities between two successive versions of the example system.
cbfa ham desired 1start lock3 enqueue lock unlock lock unlock enqueue queue lock2 start log end log unlock2 start lock3 end lock3 end lock3 lock data queue unlock data queue 2unlock unlock data queue lock data queue start log end log lock data queue unlock data queue lock lock2 unlock2 n a enqueue start lock3 end lock3 n a n a start log n a n a end log n a table top six results for cbfa version and ham and the desired mining results for figure .
end2.
breu et al.
acknowledge this shortcoming of their technique.
cbfa tries to deal with variations in concern instances by taking into account naming conventions but this often backfires.
as the start lock3 start log end lock3 and end log functions pair wise share parts of their name cbfa assigns all these functions to the first concern seed.
however the log and lock3 functions are semantically unrelated.
version of figure gives two illustrations of a ccc with large variations in its instances.
ham cannot assign start lock3 end lock3 andlock2 unlock2 to the same seed because it does not recognize that the callers of these pairs of functions i.e.
front end2 andfront end are actually the same.
cbfa s heuristic algorithm is sensitive to variations in the order of functions in the source code.
cbfa assigned lock data queue to the same seed as unlock because unlock data queue had already been assigned to concern seed because of the common unlock and shares both data and queue with lock data queue.
however the algorithm accidentally processed lock before lock data queue and hence was unable to relate locktounlock andunlock data queue in concern seed .
desired outcome a concern mining technique should be robust to variations in the instances of a concern.
it should be able to identify that start log andend log belong to the logging concern and that lock2 unlock2 andstart lock3 end lock3 belong to the inter process communication concern.
s2 tendency to ignore important facets of seeds motivation analyzing and completing a seed are crucial steps in the concern mining process yet concern mining techniques provide developers only with a partial view on possible concerns i.e.
the behavioral facet of a seed functions while they ignore the state variables and types and any preprocessor entities macros of a seed.
this makes seeds less representative of actual concerns and slows down the concern mining process as state and preprocessor entities dominate the source code for procedural languages like c and state also plays an important role in object oriented systems for example in the singleton and flyweight design patterns .
307start logend loglockunlockenqueuequeuelock2unlock2start lock3end lock3lock data queueunlock data queue3.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.00figure desired mining results for figure .
examples in figure version introduces synchronization on aqueue between the client and the front end.
as this synchronization is implemented differently on the client and the server different functions are called the pair lock unlock is called in the client and the pair lock2 unlock2 is called in thefront end.
since the two pairs of functions have different names neither cbfa nor ham are able to link them to each other even though they operate on arguments of the same type and name.
focusing exclusively on function entities not only makes seeds less rich it also ignores important hints about the relation between seemingly unrelated program entities.
desired outcome if variable and type