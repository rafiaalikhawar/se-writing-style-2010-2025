which configuration option should i change?
sai zhang michael d. ernst department of computer science engineering university of washington usa szhang mernst cs.washington.edu abstract modern software often exposes configuration options that enable users to customize its behavior.
during software evolution developers may change how the configuration options behave.
when upgrading to a new software version users may need to re configure the software by changing the values of certain configuration options.
this paper addresses the following question during the evolution of a configurable software system which configuration options should a user change to maintain the software s desired behavior?
this paper presents a technique and its tool implementation called confsuggester to troubleshoot configuration errors caused by software evolution.
confsuggester uses dynamic profiling execution trace comparison and static analysis to link the undesired behavior to its root cause a configuration option whose value can be changed to produce desired behavior from the new software version.
we evaluated confsuggester on configuration errors from configurable software systems written in java.
for errors the rootcause configuration option was confsuggester s first suggestion.
for error the root cause was confsuggester s third suggestion.
the root cause of the remaining error was confsuggester s sixth suggestion.
overall confsuggester produced significantly better results than two existing techniques.
confsuggester runs in just a few minutes making it an attractive alternative to manual debugging.
categories and subject descriptors d. .
testing and debugging.
general terms reliability experimentation.
keywords configuration error diagnosis software evolution.
.
introduction many modern software systems support a range of configuration options for users to customize their behavior.
this flexibility has a cost a small configuration error may cause hard to diagnose behavior.
software configuration errors are errors in which the software code and the input are correct but the an incorrect value is used for a configuration option so that the software does not behave as desired.
such errors may lead the software to crash produce erroneous output or simply perform poorly.
in practice software permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.configuration errors are prevalent severe and hard to debug but they are actionable for users to fix.
prevalent.
a recent analysis of yahoo s mission critical zookeeper service showed that software misconfigurations accounted for the majority of all user visible failures .
configuration related issues caused about of all failures at a commercial storage company .
the vast majority of production failures at google arise not due to bugs in the software but bugs in the configuration settings i.e.
configuration errors that control the software .
severe.
configuration errors can have disastrous impacts.
for example an outage in facebook due to an incorrect configuration value left the website inaccessible for about hours .
the entire .sedomain of sweden was unavailable for about hour due to a dns misconfiguration problem .
a misconfiguration made microsoft s public cloud platform azure unavailable for about two and a half hours .
each such incident affected millions of users.
hard to debug.
configuration errors are difficult to diagnose.
they usually require great expertise to understand the error root causes.
for example a configuration error in the centos kernel prevented a user from mounting a newly created file system .
the user needed deep understanding about the exhibited symptom and had to re install kernel modules and also modify configuration option values in several places to get it to work.
techniques to help escape from configuration hell are highly demanded .
actionable.
unlike software bugs which can only be fixed by experienced software developers fixing a software configuration error isactionable for software end users or system administrators.
these users are not the software developers and cannot access much less understand the source code but they can fix a configuration error by simply changing the values of certain configuration options.
.
configuration evolution continual change is a fact of life for software systems.
among software changes configuration changes are prevalent.
we studied real world configurable software systems section and found configuration changes in every studied version of each system.
in many cases reusing the old version s configuration can lead the new software version to exhibit undesired behaviors even if the software is working exactly as designed .
take the popular jmeter performance testing tool as an example.
in version .
the testing report is saved as an xml file after running an example command jmeter n t .. threadgroup.jmx l .. output.jtl j .. test.log from the user manual.
however after upgrading to version .
the same command saves the testing report in a csv file.
further all jmeter regression tests pass on the updated version.
the new jmeter version behaves as designed but differently than a user was expecting.
our technique and its tool implementation confsuggester can help diagnose configuration errors.
for the jmeter example a userpermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
first demonstrates the different behaviors on two confsuggesterinstrumented jmeter versions.
then confsuggester analyzes the recorded execution traces produced by the two instrumented versions and outputs a ranked list of suspicious configuration options that may need to be changed.
at the top of the list is the outputformat option with a default value of csvin version .
.
to resolve this problem users only need to change its value to xml.
.
configuration option recommendation broadly speaking diagnosing a configuration error can be divided into three separate tasks reproducing the error recommending which specific configuration option is responsible for the undesired behavior and determining a better value for the configuration option to fix the error.
confsuggester addresses the second task recommending the root cause configuration option.
confsuggester specifically focuses on software configuration errors and aims to help two types of users software end users who may have problems with software installed on their personal computers and system administrators who are responsible for maintaining production systems.
they can use confsuggester to diagnose an unexpected configuration problem during software evolution.
the key idea of confsuggester is to approximate program behavioral differences by control flow differences between two executions by running the old and new program versions respectively and then reason about the control flow differences to identify configuration options that might cause such differences.
it uses three steps as illustrated in figure to link the undesired behavior to specific root cause configuration options instrumentation and profiling.
confsuggester instruments both the old and new program versions to monitor the execution of each statement as well as the evaluation result of every predicate.
then it asks the user to demonstrate the different behaviors on the two instrumented program versions.
execution trace comparison.
confsuggester analyzes the two execution traces to identify the control flow differences.
confsuggester identifies program predicates that behave differently between the two versions.
these behaviorally deviated predicates and their affected program statements provide evidence about which parts of a program might be behaving abnormally and why.
configuration option recommendation.
confsuggester uses a lightweight static dependence analysis technique called thin slicing to attribute control flow differences to specific configuration options.
finally it outputs a ranked list of suspicious options to the users.
compared to existing error diagnosis techniques confsuggester differs in four key aspects it diagnoses configuration errors caused by software evolution.
most existing configuration error diagnosis techniques identify errors from a single program version .
by contrast confsuggester is cognizant of software evolution and works on two different versions of the same program.
it uses the desired behavior of the old software version as a baseline against which to compare new program behavior and only reasons about the behavioral differences.
it requires no testing oracle .
some previous work requires the user to answer difficult questions like is the software currently working?
or why is the software not working?
by writing a testing oracle to check the software behavior.
by contrast confsuggester only requires users to demonstrate the different behaviors on two versions.
confsuggester uses the execution trace produced by the old version as an approximate oracle to reason about the undesired behavior on the new version.
it determines likely root cause options .
many error diagnosis and debugging techniques primarily focus on determining what causes the undesired behaviors e.g.
a snippet of code they leave the more challenging question of how to fix the undesired behaviors unanswered.
the user must manually inspect the analysis report to infer the root cause e.g.
a configuration option.
by contrast confsuggester makes reports in terms that end users can act on it explicitly guides users to specific configuration options that may fix the error.
it requires no os level support .
confsuggester does not need alterations to the jvm operating system or standard library.
this makes confsuggester more portable and distinguishes it from related techniques such as os level configuration error diagnosis .
.
evaluation we implemented confsuggester for java software and empirically evaluated its effectiveness using configuration errors from open source configurable java software systems.
we used confsuggester to recommend configuration options whose values can be changed to fix each error.
confsuggester successfully recommended correct configuration options for all errors.
for errors the correct option was confsuggester s first suggestion.
for error the correct option was confsuggester s third suggestion.
the root cause of the remaining error was confsuggester s sixth suggestion.
confsuggester is fast enough for practical use taking less than .
minutes on average to diagnose each configuration error.
confsuggester s accuracy and speed make it a promising technique.
we compared confsuggester to two existing configuration error diagnosis techniques called confdiagnoser and confanalyzer .
confdiagnoser assumes the existence of some correct execution traces on the new program version by contrast confsuggester eliminates the assumption.
confanalyzer exclusively focuses on diagnosing crashing configuration errors by contrast confsuggester can diagnose both crashing errors and non crashing errors.
our experiments show that confsuggester significantly outperforms these two existing techniques.
finally we evaluated two internal design choices of confsuggester.
first we showed that using thin slicing is a better choice than traditional full slicing to reason about root cause configuration options.
second we showed that confsuggester outperforms an alternative approach that solely uses predicate behavior change to reason about the root cause configuration options.
.
contributions this paper makes the following main contributions study of configuration changes.
we describe an empirical study of configurable software systems.
our study indicates that configuration changes are frequent during software evolution section .
technique.
we present a technique to diagnose configuration errors for evolving software.
our technique links undesired behaviors to specific responsible configuration options section .
implementation.
we implemented our technique in a tool called confsuggester for java software section .
it is publicly available at .
evaluation.
we applied confsuggester to configuration errors from configurable software systems and compared it with existing techniques.
the results show the accuracy and efficiency of confsuggester section .153program versions years loc latest version language mysql .
.
.
.
c c apache .
.
.
c c firefox .
.
versions c c randoop .
.
.
.
.
.
java weka .
.
.
.
java jchord .
.
.
java synoptic .
.
.
java jmeter .
.
.
.
java figure the open source software systems we studied and their characteristics.
column years is the active development period for the selected versions.
program added options deleted options modified options mysql apache firefox randoop weka jchord synoptic jmeter total figure the total number of new deleted and modified configuration options for each subject program.
.
real world configuration changes in the software engineering literature despite a rich body of software change analysis work software configuration changes across multiple versions are less studied.
do configuration changes arise during software evolution in practice?
this section describes an initial study of real world configurable systems to answer this question.
.
subject programs and study methodology figure lists open source configurable systems used in our study.
mysql is a popular relational database management system.
apache has been the dominant http server on the internet since .
firefox is an open source browser available on multiple platforms.
randoop is an automated test generator for java programs.
weka is a toolkit that implements machine learning algorithms.
jchord is a program analysis platform that enables users to design and implement static and dynamic program analyses for java.
synoptic mines a finite state machine model representation of a system from logs.
jmeter is a tool to loadtest functional behavior and measure performance.
each program is highly configurable and has evolved over a considerable amount of time for the selected versions years .
in our study we manually examined the revision history of each subject program and searched for keywords configuration option add option delete option rename option and change option in commit messages and in the change logs.
we searched commit messages and change log entries in which commit messages and change log entries were matched.
for each match we read the description of the change and the diff of the original file to check whether a configuration option is changed.
we collected distinct configuration changes in total.
.
findings figure summarizes the identified configuration changes for each subject program.
figure further classifies the configurationchange type description bugs fix existing bugs renaming change the option name features add remove or modify features reliability improve reliability or performance figure types of configuration changes identified in our study from the subject programs in figure .
program changed configuration options bugs renaming features reliability mysql apache firefox randoop weka jchord synoptic jmeter total figure the number of configuration changes of each type.
changes into four categories shown in figure each change belongs to a single category .
as shown in figure configuration changes occur in the evolution of every subject program.
in fact they occur in every version of each subject program not shown in figure due to space limits .
as shown in figure feature related configuration changes are the largest group across all subject programs.
these changes include adding new configuration options deleting existing options or modifying the default value of an option.
configuration evolution can have unexpected impacts on program behavior.
after configuration changes reusing an old configuration may yield a misconfiguration causing different results on the new version.
section shows concrete examples.
.
threats to validity our findings apply in the context of our subject programs and methodology they might not apply to arbitrary programs.
the configuration changes identified by our methodology are certainly not complete.
our keyword search might have missed some configuration changes.
our methodology only studies changes that are directly made to a software configuration option.
we may miss code or environment changes that indirectly affect the software behavior and require users to re configure the new software version.
.
technique confsuggester models a configuration as a set of key value pairs where the keys are strings and the values have arbitrary type.
.
overview confsuggester is based on two key insights.
first a program s control flow rather than data flow often propagates the majority of the effects of a configuration option.
in other words a configuration option is mainly used as a flag that affects the program behavior by changing the runtime execution path.
second the control flow differences between two execution traces approximate the behavioral differences of two versions they provide evidence about which parts of the program are behaving abnormally and why.
based on these two insights confsuggester uses three steps to link different behaviors across program versions to specific con1the bugs change type in figure represents that fixing some bugs led to changes in configurations rather than fixing some buggy configurations.154figure the architecture of our confsuggester technique.
the instrumented program versions and two execution traces are produced by the step in section .
.
the execution trace comparison step is described in section .
.
the configuration option recommendation step is described in section .
.
figuration options that cause the difference.
figure sketches the high level workflow of confsuggester.
in the first step confsuggester asks the user to demonstrate the different behaviors using the same input and configuration on two confsuggester instrumented program versions section .
.
then confsuggester identifies the control flow differences between the two execution traces produced by user demonstration.
in particular confsuggester identifies program predicates that behave differently across the two executions section .
.
after that confsuggester uses a lightweight dependence analysis technique called thin slicing to statically reason about which configuration options may cause the control flow differences.
finally confsuggester reports a ranked list of suspicious configuration options to the user section .
.
.
instrumentation and demonstration confsuggester first instruments both the old and new program versions to monitor the program execution at runtime.
confsuggester directly instruments the bytecode.
the instrumentation consists of two parts for each program predicate i.e.
a branch instruction in bytecode confsuggester inserts one probe before and one probe after it to monitor how frequently the predicate is executed and how often the predicate evaluates to true.
in our context a predicate is a boolean expression in a conditional or loop statement whose evaluation result affects the program control flow by determining whether to execute the following statement or not.
for each of the other statements confsuggester inserts one probe before it to monitor whether the statement gets executed or not at runtime.
the statement execution information is used to calculate the number of executed statements controlled by a predicate section .
.
after instrumentation confsuggester asks the user to demonstrate the different behaviors on the two instrumented program versions using the same input and configuration.
demonstration is one of the simplest ways for an end user to describe her problem and it is easier than writing specifications or scripts of any form.
executing the instrumented program produces an execution trace which consists of a sequence of executed statements as well as the execution count and evaluation result of each predicate.
the execution trace captured by confsuggester is by no means complete in recording the full program behavior it only captures the control flows a program is taking.
as demonstrated in our experiments such control flow information serves as a good approximation to diagnose the undesired program behavior.
.
execution trace comparison in this step confsuggester compares two execution traces from two program versions and identifies the control flow differencesbetween them.
confsuggester focuses on the recorded behavior of each predicate.
first it statically matches each predicate in the old source code to its counterpart in the new source code section .
.
.
then it identifies all predicates that behave differently across the execution traces section .
.
.
.
.
matching predicates across versions for each predicate recorded in the old execution trace confsuggester matches it in the new program version to identify its possiblyupdated counterpart.
the predicate matching process proceeds in two steps.
first confsuggester finds corresponding methods.
then confsuggester matches predicates within matched methods.
to match methods confsuggester uses the first of these two strategies that succeeds .identical method name.
return a method with the identical fully qualified name in the new version.
.similar method content.
return the method with the most similar content in the new version.
given a method in the old program version confsuggester uses the algorithm shown in figure details are discussed below to match it to every method in the new program version and then chooses the method in the new program version with the most matched statements.
after running the matching algorithm confsuggester further checks the ratio of matched statements in the old method and discards method candidates whose matching ratio is below a threshold default value .
.
if there is no match for the declaring method in the new program version confsuggester concludes that the predicate cannot be matched.
otherwise confsuggester runs the algorithm in figure or looks up a cached version of the result to establish the mapping between instructions and then returns the matched instruction of the predicate or null if the predicate cannot be matched .
statement matching algorithm.
the algorithm in figure is inspired by the jdiff program differencing algorithm .
the original jdiff algorithm is based on a method level representation called hammocks that models object oriented features.
it works in a hierarchical way by first identifying matched classes and then matched method pairs and uses textual similarity to compare two program statements.
by contrast our algorithm directly works on the bytecode using the program control flow graph representation to establish the matching between statements.
in figure confsuggester first constructs the control flow graphs of two given methods lines then pushes their entry nodes a synthetic node for each method onto a worklist stack line which retains the next statement pair for comparison.
the algorithm repeatedly pops a statement pair from the stack line and decides155auxiliary functions matches s s return whether two statements sands are matched.
details are explained in section .
.
.
bfs s cfg d return a list of statements reachable from statement sincfgwithin dgraph edges in breath first search bfs order.
firstmatchedpair stmtlist stmtlist return the first matched statement pair an bracketle ts s an bracketri htsuch that s stmtlist s stmtlist and matches s s return true.
return null if no such pair exists.
input two methods from two software versions moldandmnew a maximum lookahead value lh.
our experiment uses lh .
output matched statements between moldand mnew.
matchstatements mold mnew lh matchedstmts new map an bracketle tstatement statement an bracketri ht cfgold constructcontrolflowgraph mold cfgnew constructcontrolflowgraph mnew stack new stack an bracketle tpair an bracketle tstatement statement an bracketri ht an bracketri ht stack .push cfgold.entry cfgnew.entry while stack is not empty do an bracketle tstmt old stmt new an bracketri ht stack .pop ifmatchedstmts .keys .contains stmt old matchedstmts .values .contains stmt new then continue end if matchedpair null ifmatches stmt old stmt new then matchedstmts stmt new matchedpair an bracketle tstmt old stmt new an bracketri ht else stmtlist old bfs stmt old cfgold lh stmtlist new bfs stmt new cfgnew lh an bracketle tsold snew an bracketri ht firstmatchedpair stmtlist old stmtlist new if an bracketle tsold snew an bracketri ht ne ationslash nullthen matchedstmts snew matchedpair an bracketle tsold snew an bracketri ht end if end if ifmatchedpair ne ationslash nullthen foreach sin bfs matchedpair .first cfgold do foreach s in bfs matchedpair .second cfgnew do stack .push an bracketle ts s an bracketri ht end for end for end if end while return matchedstmts figure algorithm for matching statements from two methods.
whether the two statements are matched line .
each statement appears at most once in the result lines .
the algorithm decides whether two statements are matched by using the matches s s auxiliary function.
method matches s s returns true if both sands have the same statement type i.e.
the same instruction type in bytecode and if sands are field accessing or method invoking statements the same field or method is accessed or invoked by both statements.
such approximate matching tolerates small differences between two versions such as changes to constant values.
if two statements are matched the algorithm saves them in the result map line .
otherwise the algorithm compares each statement reachable within lhcontrol flow graph edges lines .
so permits the algorithm to tolerate some small changes in the method code and attempts to match as many statements as possible.when two matched statements are found stored in the matchedpair variable in lines or the algorithm pushes every pair of their successor statements onto the stack line .
it terminates after every statement has been attempted to match.
.
.
identifying behaviorally deviated predicates using the predicate matching information confsuggester next identifies predicates that behave differently between two versions.
given an execution trace t confsuggester characterizes a predicate p s behavior by how often it is evaluated i.e.
the number of observed executions and how often it evaluates to true i.e.
the true ratio .
the true ratio is an important characteristic of a predicate s behavior but it is less dependable the fewer times the predicate has been executed.
confsuggester combines the true ratio and number of executions by computing their harmonic mean.
p t trueratio p t totalexecnum p t in p t trueratio p t returns the proportion of executions of the predicate pthat evaluated to true in t and totalexecnum p t returns the the total number of observed executions of predicate pin t. to smooth corner cases p t returns if a predicate pis not executed in t i.e.
totalexecnum p t or a predicate p s true ratio is i.e.
trueratio p t .
we let null t 0for all t. given two matched predicates p1andp2from two different execution traces t1andt2 confsuggester uses the deviation function defined in figure to compute the behavioral deviation value.
in figure the deviation function discards a predicate pair whose behavioral deviation value is less than a pre defined threshold line .
this is for tolerating small non determinism during program execution and making confsuggester focus on predicates with substantial behavioral differences.
the identified behaviorally deviated predicates indicate different control flow taken between two versions under the same input and configuration.
such control flow differences are useful in explaining which part of the program might be behaving unexpectedly.
.
configuration option recommendation in this step confsuggester attributes the control flow differences to one or more root cause configuration options.
the key idea is to identify configuration options that may affect the behaviorallydeviated predicates and then rank these options by the deviation value computed by the deviation function in figure and the number of executed statements they control computed by the getexecutedstmtnum auxiliary function in figure .
to identify the configuration options that can affect a predicate a straightforward way is to use program slicing to compute a forward slice from the initialization statement of a configuration option and then check whether the predicate is in the slice.
unfortunately traditional full slicing would produce unusably large slices due to its conservatism.
to address this limitation confsuggester uses thin slicing to identify configuration options that directly affect a predicate.
different from traditional full slicing thin slicing only follows the data flow dependencies from the slicing criterion i.e.
the initialization statement of a configuration option and ignores control flow dependencies as well as uses of base pointers.
using thin slicing confsuggester separates pointer computations from the flow of configuration option values and naturally connects a configuration option with its affected statements by the data flow dependencies.
section .
.
empirically demonstrates that using traditional full slicing will decrease the accuracy of confsuggester.156auxiliary functions getpredicates t return all executed predicates in the execution trace t. getaffectingoptions p v use thin slicing to compute all configuration options that may affect predicate pin the software version v. getexecutedstmtnum p v t return the number of executed statements controlled by predicate p in trace tfrom software version v. deviation p1 t1 p2 t2 result p1 t1 p2 t2 is a pre defined threshold with default value .
ifresult then result end if return result input two software versions voldandvnew.
two execution traces toldandtnew on the respective versions.
a map of matched statements between voldandvnew stmtmap .
output a ranked list of likely root cause configuration options recommendoptions vold vnew told tnew stmtmap optionmap new map an bracketle toption float an bracketri ht each entry of optionmap is initialized to .
foreach poldin getpredicates vold do d deviation pold told stmtmap tnew options old getaffectingoptions pold vold w d getexecutedstmtnum pold vold told foreach option option inoptions olddo optionmap optionmap w end for end for foreach pnewin getpredicates vnew do d deviation stmtmap told pnew tnew options new getaffectingoptions pnew vnew w d getexecutedstmtnum pnew vnew tnew foreach option option inoptions newdo optionmap optionmap w end for end for return optionmap .sortedkeys figure algorithm for recommending configuration options.
function deviation is a helper function to compute the deviation value between two predicates p1and p2 and function used in deviation is defined in section .
.
.
to reason about the root cause configuration options confsuggester associates each configuration option with a weight which represents the strength of the causal relationship between the configuration option and the execution differences.
a larger weight value indicates that a configuration option potentially contributes more to the control flow differences as its value propagates in the program and thus the configuration option is more likely to be the root cause.
figure presents the configuration option recommendation algorithm.
for each behaviorally deviated predicate in an execution trace confsuggester first attributes the deviated behavior to its affecting configuration options lines and .
then confsuggester computes the number of executed statements controlled by that predicate lines and .
to do so the getexecutedstmtnum auxiliary function first statically examines the source code to compute the immediate post dominator statement of a predicate and then traverses the execution trace to count the number of statements that are executed between the predicate and its post dominator statement.confsuggester multiples a predicate s deviation value by the number of executed statements and then updates the weight of each affecting configuration option lines and .
finally confsuggester ranks all affecting configuration options in decreasing order by weight outputting a ranked list of suspicious options that might be responsible for the behavioral differences line .
if two configuration options have the same weights confsuggester prefers the configuration option affecting more statements in its thin slice.
this heuristic is based on the intuition that configuration options affecting more statements seem more likely to be relevant to the behavioral differences.
.
discussion we next discuss some design issues in confsuggester.
fixing configuration errors vs. localizing regression bugs.
the problem addressed in this paper is significantly different than the traditional regression bug localization problem .
a regression bug occurs when developers have made a mistake which causes the software to violate its specification after a session of code changes.
by contrast in our context the software behavior on the new version is still as designed by the developers but undesired by the users.
why not use a dynamic analysis to recommend configuration options?
confsuggester uses thin slicing to statically identify responsible configuration options for a behaviorally deviated predicate.
an alternative is to use a pure dynamic analysis to assess how a configuration option may affect the control flow.
techniques such as delta debugging value replacement and dual slicing use a similar idea they repeatedly replace a variable value with other alternatives and then re execute the program to check whether the outcome is desired.
there are two major challenges that prevent these dynamic analyses from being used.
first it can be difficult to find a valid replacement value for a non boolean configuration option such as a string or regular expression.
second automatically checking program outcomes requires a testing oracle which is often not available in practice and end users should not be expected to provide it.
to address these challenges confsuggester approximates the program behavioral differences by the control flow differences of two executions and then statically reasons about the responsible configuration options.
confsuggester s current limitations.
there are three major limitations in the our confsuggester technique.
first confsuggester assumes the different behaviors of two program versions are not caused by non determinism.
for non deterministic behaviors confsuggester could potentially leverage a deterministic replay system to faithfully reproduce the behaviors.
second confsuggester only matches one predicate in the old program version to one predicate in the new program version.
if a predicate evolves into multiple predicates in the new version confsuggester may output less useful results.
third confsuggester focuses on identifying root cause configuration options that can change the functional behaviors of the target program.
configuration options that affect the underlying os or runtime system such as the xmx option used to specify jvm s heap size when launching a java program are not supported by confsuggester.
.
implementation confsuggester uses the wala framework to perform offline bytecode instrumentation.
the instrumentation code records the execution of every statement and the evaluation result of each predicate.
confsuggester also uses wala to analyze java bytecode statically to identify the affecting configuration options for each predicate that behaves differently across versions.157program old version new version loc new version loc options randoop .
.
.
.
weka .
.
.
.
synoptic .
.
jchord .
.
jmeter .
.
javalanche .
.
figure all subject programs used in the evaluation.
column loc shows the number of changed lines of code between the old and new versions.
column options shows the number of configuration options supported in the new program version.
like other existing configuration error diagnosis tools confsuggester does not instrument libraries such as the jdk since a configuration option set in the client software usually does not affect the behaviors of its dependent libraries.
.
ev aluation we evaluated aspects of confsuggester s effectiveness answering the following research questions .how accurate is confsuggester in identifying the root cause configuration options?
that is what is the rank of the actual root cause configuration option in confsuggester s output section .
.
?
.how long does it take for confsuggester to diagnose a configuration error section .
.
?
.how does confsuggester s effectiveness compare to existing approaches section .
.
?
.how does confsuggester s effectiveness compare to two variants?
the first variant uses full slicing in identifying suspicious configuration options and the second variant only uses predicate behavior changes to recommend configuration options section .
.
.
.
subject programs we evaluated confsuggester on java programs listed in figure .
the first subject programs are the java programs studied in section and the remaining subject program is javalanche which is a mutation testing framework.
we included javalanche because one of its real users provided us a configuration error he encountered when using javalanche.
.
.
configuration errors for the java programs studied in section we manually examined all deleted and modified configuration options listed in figure .
the added configuration options are unlikely to cause a misconfiguration.
for each change based on our own understanding we wrote a test driver to cover it and then checked whether the test driver could reveal different behaviors on two versions.
for those programs we collected errors as listed in figure the first errors .
for the javalanche program we reproduced the reported configuration error.
in figure errors and can be reproduced together in a single execution and each of the other errors is reproduced in one execution.
our methodology of collecting configuration errors is different from what was used in collecting software regression bugs in the literature .
software regression bugs often can be found in well maintained bug databases.
by contrast finding recorded configuration errors is much harder mainly because most configuration errors have not been documented rigorously .
usually after a session of code changes when regression tests pass developers may treat the software behaviors as having been validated.
further because the software misconfigurations are user driven the fixes may be recorded simply as pointers to manuals or other documents.
.
evaluation procedure for each subject program we used confsuggester to instrument both versions.
for each configuration error we used the same input and configuration to reproduce the different behaviors on two instrumented versions.
the average size of the execution traces is 40mb and the largest one randoop s trace is 140mb.
when using confsuggester to diagnose a configuration error we manually specify the initialization statement of each configuration option as the thin slicing criterion.
this manual one time cost step took minutes on average per subject program.
after that confsuggester works in a fully automatic way it analyzes two program versions and two execution traces and outputs a ranked list of configuration options.
future work should automate this manual step.
our experiments were run on a .67ghz intel core pc with 4gb physical memory 2gb was allocated for the jvm running windows .
.
results .
.
accuracy as shown in figure confsuggester is highly effective in identifying the root cause configuration options that should be changed in the new program version.
the average rank of the root cause in confsuggester s output is .
.
for errors the root cause configuration option ranks first in confsuggester s output for error the root cause configuration option ranks third in confsuggester s output and the root cause option ranks sixth for the remaining error.
confsuggester is successful because of its ability to identify the behaviorally deviated predicates with substantial impacts through execution trace comparison.
the top ranked deviated predicates often provide useful clues about what parts of a program have performed differently.
summary.
confsuggester recommends correct configuration options with high accuracy for evolving configurable software systems with non trivial code changes.
.
.
performance of confsuggester we measured confsuggester s performance in two ways the performance overhead introduced by instrumentation when demonstrating the configuration error and the time cost of recommending configuration options.
figure shows the results.
the performance overhead to demonstrate the error varies among programs.
the current implementation imposes an average and .
slowdown in a confsuggester instrumented old and new program version respectively.
this is due to confsuggester s inefficient instrumentation code that monitors the execution of every instruction.
the overhead could be reduced by instrumenting at basic block granularity instead.
even so except for two errors errors and in jchord all other errors can be reproduced in less than seconds.
errors and require about minutes to reproduce.
confsuggester spends an average of .
minutes to recommend configuration options for one error including the time to compute thin slices and the time to suggest suspicious options .
computing thin slices for all configuration options is non trivial.
however this step is one time cost per program and the results can be precomputed.
the time used for suggesting configuration options is roughly158error id.
error description root cause options rank of the root cause configuration option program configuration option confsuggester confdiagnoser confanalyzer .
randoop poor performance in test generation usethreads n x .
weka a different error message when weka crashes mnumfolds .
synoptic initial model not saved dumpinitialgraphdotfile n x .
synoptic generated model not saved as jpeg file dumpinitialgraphpngfile n x .
jchord bytecode parsed incorrectly chord.ssa x .
jchord method names not printed in the console chord.print.methods n x .
jmeter results saved to a file with a different format outputformat x .
javalanche no mutants generated project.tests x average .
.
.
.
figure all configuration errors used in the evaluation and the experimental results.
only the 2nd error is a crashing error and all the other errors are non crashing errors.
column root cause configuration option shows the actual root cause configuration option.
column options shows the number of configuration options supported in the new program version taken from figure .
column rank of the root cause configuration option shows the absolute rank of the actual root cause configuration option in each technique s output lower is better .
x means the technique is not applicable i.e.
requiring a crashing point and n means the technique does not identify the actual root cause.
when computing the average rank each x or n is treated as half of the number of configuration options because a user would need to examine on average half of the available options to find the root cause.
column confsuggester shows the results of using our technique.
columns confdiagnoser and confanalyzer show the results of using two existing techniques as described in section .
.
.
error id.
run time slowdown confsuggester time s program old version new version slicing suggestion .
randoop .
.
.
weka .
.
.
synoptic .
.
.
synoptic .
.
.
jchord .
.
.
jchord .
.
.
jmeter .
.
.
javalanche .
.
average .
.
figure confsuggester s performance.
the run time slowdown column shows the cost of reproducing the error in an confsuggester instrumented version of the subject program.
the confsuggester time s column shows the time taken by confsuggester to diagnose configuration errors in seconds.
column slicing is the cost of computing thin slices on both old and new program versions.
proportional to the size of the execution trace rather than the size of the subject program.
summary.
confsuggester recommends configuration options for diagnosing configuration errors with reasonable time cost.
.
.
comparison with two existing approaches this section compares confsuggester with two existing approaches confdiagnoser and confanalyzer .
confdiagnoser and confanalyzer are among the most precise configuration error diagnosis techniques in the literature.
confdiagnoser proposed in our previous work is an automated software configuration error diagnosis technique.
confdiagnoser is notcognizant of software evolution and it diagnoses configuration errors from a single program version.
confdiagnoser assumes the existence of a set of correct execution traces which are used to compare against the undesired execution trace to identify the abnormal program parts.
when comparing the undesired execution trace with a correct execution trace confdiagnoser only uses a predicate s deviation value to reason about the most suspicious options while ignoring the statements controlled by a predicate s evaluation result.
to compare confsuggester with confdiagnoser we reused the pre built execution trace databases for the shared subject programs randoop synoptic jchord and weka from .
each exist ing trace database contains correct execution traces.
for the remaining two subject programs jmeter and javalanche we manually built an execution trace database for each of them by running correct examples from their user manuals.
the databases contain and execution traces for jmeter and javalanche respectively.
confanalyzer proposed by rabkin and katz is a lightweight static configuration error diagnosis technique.
confanalyzer tracks the flow of labeled objects through program control flow and data flow and treats a configuration option as a root cause if its value may flow to a crashing point.
since confanalyzer cannot diagnose non crashing errors we can only apply it to diagnose the crashing error in weka error in figure .
results.
columns confdiagnoser and confanalyzer in figure show the experimental results.
confsuggester produces significantly more accurate results than confdiagnoser primarily for two reasons.
first confdiagnoser focuses on diagnosing erroneous program behaviors and identifies their responsible configuration options.
however for the problem addressed in this paper the new software version that exhibits undesired behavior after applying the same configuration used in the old version is working exactly as designed .
in other words the execution trace obtained by running the new program version is stillcorrect .
therefore just comparing execution traces obtained from the new program version is not effective in identifying the abnormal behavior.
by contrast confsuggester compares execution traces from two different versions and directly reasons about the execution differences.
second confdiagnoser only focuses on the predicate behavior changes while ignoring the statements potentially impacted by the affected predicate.
this makes confdiagnoser fail to distinguish predicates whose behavioral changes can have different impacts.
section .
.
further evaluates this design choice showing that considering the number of controlled statements can substantially increase the diagnosis accuracy.
confanalyzer outputs the correct result for the crashing error in weka but cannot identify root causes for other non crashing errors.
the crashing error in weka occurs soon after the program is launched.
confanalyzer correctly identifies its root cause because a small number of configuration options are initialized and only one of them flows to the crashing point.
confsuggester is not directly comparable to other related configuration error diagnosis approaches .
existing approaches target a rather different problem than confsuggester 159error id.
rank of the root cause configuration option program confsuggester full slicing predicate behavior .
randoop .
weka .
synoptic .
synoptic .
jchord .
jchord .
jmeter n .
javalanche n average .
.
.
figure experimental results of evaluating two design choices of confsuggester.
column confsuggester shows confsuggester s results taken from figure .
column full slicing shows the results of replacing thin slicing with full slicing in confsuggester.
n means the technique does not identify the actual root cause.
column predicate behavior shows the results of confsuggester if it only considers predicate behavior change.
when computing the average rank each n is treated as half of the number of configuration options.
or require different inputs than confsuggester.
for example xray diagnoses configuration errors on a single program version.
peerpressure and rangerfixer only support configuration options defined by certain specific feature models.
general software fault localization techniques are not well suited for configuration error diagnosis since such techniques often focus on identifying the buggy code or invalid input values.
this has been empirically validated in our previous work .
summary.
configuration error diagnosis techniques designed for asingle program version achieve less accurate results in diagnosing configuration errors introduced in software evolution.
confsuggester reasons about the behavioral differences between two program versions and produces more accurate results.
.
.
evaluating two design choices this section evaluates two design choices in confsuggester.
slicing algorithms.
confsuggester uses thin slicing to identify configuration options whose values may affect a predicate.
we next evaluate a variant that replaces thin slicing with the traditional full slicing .
this variant changes the getaffectingoptions auxiliary function in figure by using full slicing to compute all configuration options that may affect a predicate.
figure column full slicing shows the results.
confsuggester achieves substantially less accurate results when using full slicing.
the primary reason is that full slicing identifies many irrelevant configuration options that indirectly affect a predicate of interest.
such configuration options are not pertinent to the task of error diagnosis.
linking them to the exhibited different behavior would degrade confsuggester s accuracy.
further computing full slices is much more expensive than computing thin slices.
wala s full slicing algorithm failed to scale to two subject programs jmeter and javalanche .
predicate behavioral change metrics.
confsuggester considers both the predicate behavior change and the number of affected statements in diagnosing configuration errors.
we next evaluate a variant that only uses the predicate behavior change to diagnose errors.
this variant changes the getexecutedstmtnum auxiliary function in figure by making it always return .
figure column predicate behavior shows the results.
confsuggester s accuracy degrades substantially when ranking predicates based on its behavioral changes without considering the number of affected statements.
the primary reason is thatbehaviorally deviated predicates occur all over the execution traces but each predicate may have different impacts to the overall program behavior change.
confsuggester uses the number of statements determined by the predicate evaluation result to approximate such potential impacts.
summary.
full slicing includes too many irrelevant program statements due to its conservatism and only using a predicate s behavior change is not enough to identify the root cause configuration options.
confsuggester using thin slicing and considering both the predicate behavior change and the impacted statements is a better choice in diagnosing configuration errors.
.
discussion threats to validity.
there are several threats to validity of our evaluation.
first the java programs might not be representative though some of them have been used in previous research.
likewise the configuration errors might not be representative even though we evaluated every error we found.
we only evaluated confsuggester on errors caused by one configuration option.
it is unclear whether confsuggester would produce useful results if fixing a particular configuration error requires changing values of two dependent configuration options.
second our evaluation focused on configuration errors rather than software regression bugs as all regression tests between two versions pass.
we have not evaluated whether confsuggester would help users work around buggy program versions.
third confsuggester s effectiveness depends on the effectiveness of the predicate matching algorithm.
in our experiments on average of lines are changed between the program versions.
confsuggester may yield less useful results for programs with significant code changes.
however different algorithms can be plugged into confsuggester.
fourth our evaluation only compared confsuggester with two other approaches.
comparing with other analyses or tools might yield different observations.
experimental conclusions.
we have three chief findings.
confsuggester is highly effective in diagnosing configuration errors introduced by software evolution confsuggester produces more accurate results than approaches designed to diagnose errors on a single program version and confsuggester outperforms two variants that use full slicing and only a predicate s behavior change in error diagnosis respectively.
.
related work the most closely related work falls into three categories techniques for supporting software evolution software configuration error diagnosis techniques and configuration aware software analysis techniques.
.
supporting software evolution as software evolves its behavior must be validated.
regression test selection indicates which tests need to be executed for a changed program.
program differencing techniques identify changes between two program versions and present the change list to developers for inspection.
change impact analysis techniques which are often built on top of program differencing techniques identify not only the changes but also code fragments that are affected by the changes.
different than confsuggester s predicate matching algorithm section .
.
existing program differencing techniques primarily focus on matching program elements at the method level or matching program statements on the source code based on textual similarity .
by contrast confsuggester s matching algorithm inspired by the jdiff algorithm is specifically designed to match160the evolved predicate in the new program version.
see section .
.
for a detailed comparison with jdiff.
the algorithm directly works on the bytecode of two program versions without any additional information from users such as a software revision history .
nagarajan et al.
developed a technique to match control flows of two program versions running with the same input.
different from confsuggester their work assumes semantically equivalent program versions e.g.
optimized and unoptimized while confsuggester compares two versions that include functional changes.
many techniques have been developed to identify failure inducing code changes for evolving software .
for example delta debugging aims to find a minimal subset of changes that still makes the test fail .
test minimization techniques simplify the failed test to ease comprehension for developers.
confsuggester differs from these techniques in three aspects.
first existing techniques focus on helping software developers localize a bug while confsuggester targets software configuration errors fixable by software end users.
as we have discussed in section .
configuration errors are fundamentally different than regression bugs.
they are mostly user driven and do not indicate problems in the source code.
second most of the existing techniques identify what e.g.
a snippet of code causes the regression bug but do not answer the question of how e.g.
which configuration option should a user change?
to fix the error.
by contrast confsuggester explicitly guides users to suspicious configuration options.
third most of the regression failure localization techniques require a testing oracle for automated correctness checking.
however such oracles are often absent in practice.
by contrast confsuggester eliminates this requirement by approximating the software behavioral difference as the control flow differences.
.
software configuration error diagnosis software configuration errors are time consuming and frustrating to diagnose.
to reduce the time and human effort needed to troubleshoot software misconfigurations prior research has applied different techniques to the problem of configuration error diagnosis .
for example chronus relies on a user provided testing oracle to check the system behavior and uses virtual machine checkpoint and binary search to find the point in time where the program behavior switched from correct to incorrect.
autobash fixes a misconfiguration by using os level speculative execution to try possible configurations examine their effects and roll them back when necessary.
peerpressure statistically compares configuration states in the windows registry on different machines.
when a registry entry value on a machine exhibiting erroneous behavior differs from the value usually chosen by other machines peerpressure flags the value as a potential error.
more recently confaid and x ray use dynamic taint analysis to diagnose configuration errors by monitoring causality within the program binary as it executes.
confanalyzer uses dynamic information flow analysis to precompute possible configuration error diagnoses for every possible crashing point in a program.
confsuggester is significantly different from the existing approaches.
first confsuggester is cognizant of software evolution while most previous approaches are not .
second confsuggester supports diagnosing both crashing and non crashing errors while most techniques can only diagnose configuration errors that lead to a crash or assertion failure .
third unlike several approaches confsuggester does not assume the existence of a testing oracle.
fourth confsuggester uses platformindependent offline instrumentation and requires no alternation to the underlying operating system or runtime environment.
this differs from existing os level diagnosis techniques .
fifth approaches like peerpressure and rangefixer benefit from the known schema of the windows registry and feature models but cannot diagnose configuration errors that lie outside these specific domains.
our technique of analyzing the execution traces is more general.
.
configuration aware software analysis software configuration management is a central component of software product lines.
many configuration aware software analysis techniques have been developed to analyze configurable software systems improve software configuration management and understand and test the behavior of a configurable software system .
compared to confsuggester these techniques have rather different goals.
they primarily focus on reducing the burden of configuration management and preventing certain errors from happening or creating test suites to find new errors in a configurable software system earlier.
they cannot diagnose an exhibited configuration error during software evolution.
by contrast confsuggester links the behavioral differences to a small number of configuration options and explicitly guides software end users to the root causes.
.
conclusion and future work this paper describes confsuggester a technique to help software users to troubleshoot configuration errors.
confsuggester focuses on errors caused by software evolution and recommends configuration options whose values should be changed to produce the desired behavior on the new software version.
in our experiments confsuggester accurately identified the root causes of configuration errors in real world software systems.
the source code of confsuggester is publicly available at googlecode.com .
as future work we plan a user study to evaluate confsuggester s usefulness to end users.
a challenge will be finding study participants who are familiar with only the old versions of given subject programs.
we also plan to develop techniques to automatically distinguish software bugs from configuration errors when a software system exhibits undesired behavior.
such techniques can help formulate guidance regarding when the user should give up on confsuggester and assume the error is not related to configuration.
.