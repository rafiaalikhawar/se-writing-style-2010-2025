see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation a degree of knowledge model to captu re sou rce code familiarity conf erence paper in proceedings int ernational conf erence on softw are engineering may .
.
sour ce dblp citations 130reads author s including thomas f ritz univ ersity of z urich publica tions citations see profile jing wen ou univ ersity of british columbia publica tions citations see profile gail murphy univ ersity of british columbia publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y gail murphy on may .
the user has r equest ed enhanc ement of the do wnlo aded file.a degree of knowledge model to capture source code familiarity thomas fritz jingwen ou gail c. murphy and emerson murphy hill department of computer science university of british columbia vancouver bc canada fritz jingweno murphy emhill cs.ubc.ca abstract the size and high rate of change of source code comprising a software system make it di cult for software developers to keep up with who on the team knows about particular parts of the code.
existing approaches to this problem are based solely on authorship of code.
in this paper we present data from two professional software development teams to show that both authorship and interaction information about how a developer interacts with the code are important in characterizing a developer s knowledge of code.
we introduce the degree of knowledge model that computes automatically a real value for each source code element based on both authorship and interaction information.
we show that the degree of knowledge model can provide better results than an existing expertise nding approach and also report on case studies of the use of the model to support knowledge transfer and to identify changes of interest.
categories and subject descriptors d. .
programming environments general terms human factors keywords expertise authorship degree of interest interaction degreeof knowledge onboarding recommendation .
introduction software developers working with source code face a deluge of information daily.
the development environments they use provide fast access to the many often millions of lines of code comprising the systems on which they work.
the hard work of their teammates often results in a high rate of change in that code.
for a professional software c acm .
this is the author s version of the work.
it is posted here by permission of acm for your personal use.
not for redistribution.
the definitive version was published in icse icse may cape town south africa .development team we studied each developer was on average accepting changes to over one thousand source code elements per day from other team members into their environment section .
the large ux in the source can make it di cult to know which team member is familiar with which part of the code.
for a developer lack of this knowledge can complicate many activities.
for instance the developer may not know who to ask when questions arise about particular code.
for a team lead lack of this knowledge can make it di cult to know who can bring a new team member up to speed in a particular part of the code.
existing approaches to determining who knows which code have sought to determine who has expertise based on authorship of changes to the code alone e.g.
.
these approaches ignore knowledge that is gained by a developer interacting with the code for such purposes as calling the code or trying to understand how the code functions.
in this paper we introduce the degree of knowledge dok model that takes a broader perspective on who knows what code by considering both authorship and a developer s interactions with the code.
a dok value for a source code element is a real value speci c to a developer di erent developers may have di erent dok values for the same source code elements.
we compute the dok values for a developer automatically by combining authorship data from the source revision system and interaction data from monitoring the developer s activity in the development environment section .
to determine whether both authorship and interaction have an e ect on knowledge we gathered data from two professional software development teams.
we report on this data to support two claims.
first the code that developers work on changes rapidly.
second code that developers create and edit overlaps but is not the same as the code with which developers interact.
using this data we conducted experiments with the members of two development teams to determine the relative effect of authorship and interaction towards modelling knowledge section .
we found that whether or not the developer was the rst author of a code element had the most e ect on the element s dok value.
however we also found that all aspects of authorship and interaction improve the quality of the model and help to explain a developer s knowledge of an element.
the availability of dok models for developers in a team opens up several possibilities to improve a developer s pro ductivity and quality of work.
we consider three possibilities in this paper through exploratory case studies section .
first we investigate whether dok values can support nding who is an expert in particular parts of a code base.
we found that our approach performed better than existing approaches for this problem that are based on authorship alone.
second we investigate whether dok values can help familiarize onboard a new team member onto a particular part of the development project.
from this study we learned about kinds of source code for which our current de nition of dok does not adequately re ect a developer s knowledge.
finally we hypothesized and con rmed that we can accurately identify bug reports that a developer should likely be aware of.
we achieve this identi cation by correlating the developer s dok values with a bug report s source code changes even when those changes were made by other team members.
this paper makes three contributions 2it introduces the degree of knowledge model that represents a developer s familiarity with each code element 2it reports on data about professional developers authorship and interaction with the code providing empirical evidence about the rate of information owing into a developer s environment and the need to consider both authorship and interaction to more accurately re ect the code elements with which a developer is familiar and 2it reports on the use of dok values in three di erent scenarios in professional environments reporting on the bene ts and limitations of the model and demonstrating a measurable improvement for one scenario nding experts compared to previous approaches.
.
related work previous automated approaches to determining the familiarity expertise of developers with a codebase rely solely on change information.
for instance the expertise recommender and expertise browser each use a form of the line rule which is a heuristic that the person committing changes to a le1has expertise in that le.
the expertise recommender uses this heuristic to present the developer with the most recent expertise for the source le the expertise browser gathers and ranks developers based on changes over time.
the emergent expertise locator re nes the approach of the expertise browser by considering the relationship between les that were changed together when determining expertise .
girba and colleagues consider ner grained information equating expertise with the number of lines of code each developer changes .
hattori and colleagues consider changes that have not yet been committed .
none of these previous approaches consider the ebb and ow of a developer s expertise in a particular part of the system.
the expertise recommender considers expertise as a binary function only one developer at a time has expertise in a le depending on who last changed it.
the expertise browser and emergent expertise locator 1we use the term le but many of these techniques also apply at a ner level of granularity such as methods or functions.represent expertise as a monotonically increasing function a developer who completely replaces the implementation of an existing method has no impact on the expertise of the developer who originally created the method.
our approach models the ebb and ow of multiple developers changing the same le a developer s degree of knowledge in the le rises when the developer commits changes to the source repository and diminishes when other developers make changes.
the approach we consider in this paper also di ers from previous expertise identi cation approaches by considering not just the code a developer authors and changes but also code that the developer consults during their work.
schuler and zimmermann also noted the need to move beyond authorship for determining expertise suggesting an approach that analyzed the changed code for what code was called but not changed .
in this way they were able to create expertise pro les that included data about what apis a developer may be expert in through their use of those apis.
in this paper we go a step further considering how a developer interacts with the code in a development environment as they produce changes to the code.
we build on earlier work from our research group that introduced degree ofinterest values to represent which program elements a developer has interacted with signi cantly .
the more frequently and recently a developer has interacted with a particular program element the higher the as a developer moves to work on other program elements the of the initial element decays.
our initial applications of this concept computed across all of a developer s workday .
subsequent work scopes the per task .
in this paper we return to the computation of all of a developer s work to capture a developer s familiarity in the source across tasks.
others have considered the use of interaction data for suggesting where to navigate next in the code for tracking the in uence of copied and pasted code and for understanding the di erences between novice and expert programmers .
none of these previous e orts have considered the use of interaction data for determining expertise in or familiarity with source code.
in a previous study we considered whether interaction information alone could indicate for which code a developer had knowledge .
this study involved nineteen industrial java programmers.
through this study we found that computed from the interaction information can indicate knowledge about a program s source.
this study also found that other factors such as authorship of code should be used to augment attempting to gauge a developer s knowledge of the code.
this paper builds on this previous work investigating how a combination of interaction and authorship information indicates a developer s knowledge of code.
.
authorship and interaction existing approaches to representing code familiarity are based solely on authorship e.g.
.
our previous study found that a developer s interaction with the code can indicate the developer s knowledge about source code .
these two results suggest a model of code familiarity should be based on both of these factors.
however if there is a strong degree of overlap between the code elements authored and interacted with by a developer it may be possible to base a model on only one kind of information as is currently thet t1 t2t3t4authorshipinterac g415on months7 work days work days a an abstract timeline t1 t2 t3 t4 site1 site224 b speci c points in time used at each site figure data collection time periods case with expertise recommenders.
to investigate the role of both of these factors we gathered data from two professional development sites nding that each presents a unique and valuable perspective on a developer s code knowledge.
site1involved seven professional developers d1 through d7 building a java client server system using ibm s rational team concert2system as the source repository.
the professional experience of these developers ranged from one to twenty two years with a mean experience of .
years standard deviation of .
years .
these developers each worked on multiple streams branches of the code we chose to focus our data collection on a developer s major stream.
one developer d5 could not identify a major stream of the four on which he worked as this work pattern makes authorship di cult to determine we have chosen to exclude his data from the presentation given in this section but have included his results in the experiment section and case studies section .
site2involved two professional developers who build open source frameworks for eclipse as part but not all of their work and who use cvs3as the source repository system.
one developer had three years of professional experience the other had ve years.
figure a provides an overview of the di erent periods of data collection.
authorship information was gathered for a three month period t 1to t .
the interaction data used to compute dok values was gathered over seven working days t 2to t .
the data reported on in this section is from data collected from t 1to t .
the interaction data from t 3to t 4was used to update the dok values as case studies were conducted during this period.
figure b maps abstract time points to particular dates used for each site.
we report in detail on the data from site providing only an overview of the data from site 2due to space limitations.
unless otherwise indicated we report the average mean of values with standard deviations represented as .
.
authorship data we distinguish between three di erent kinds of authorship events with respect to a developer d 2jazz.net veri ed veri ed rst authorship representing whether dcreated the rst version of the element 2number of deliveries representing subsequent changes after rst authorship made to the element by d 2acceptances representing changes to the element not completed by d. we found that the authorship of code loaded into a developer s environment at site 1changed frequently.
at this site a rst authorship delivery or accept event to an element occurred on average every seconds.
the developers had rst authorships produced delivery events and accepted changes to an element over three months.
the standard deviations for all of these values are high which is not surprising given the di erent roles of team members see section .
these aggregate statistics count multiple events happening to the same elements.
considering unique elements on average the developers rst authored elements4 delivered to unique elements and accepted changes on unique elements.
thus each day a developer authored ten new elements delivered changes to nine elements and accepted changes to elements on average over the period t1 to t3.
to provide more insight into this data we picked a random developer and ten random source code elements that had at least two authorship related events.
to give a sense of the ebb and ow of the authorship we estimated weightings for these events assigning a rst authorship event a value of .
a delivery event a value of .
since a delivery likely changes just part of the element and an accept event a negative value of .
since an accept event corresponds to someone else changing the element .
figure plots the resulting values for each of the ten source code elements over time each element is represented by a separate line.
only a few of these elements were the target of several events over the three months of data we collected these elements are indicated by the longer lines in the gure.
all elements except one on the far right have an accept event after a rst authorship or delivery meaning that someone else on the team has delivered a change to the element the lines for these elements have a declining slope.
over the three months and the six developers there is a ratio of to for accept events versus all rst authorship and delivery events.
this large ratio is indicative of the high rate of change occurring to elements in a developer s environment caused both by the team members themselves and by other developers making changes to the team s codebase.
.
interaction data we found at site 1that developers interacted with many di erent elements over a week of work some of them quite frequently.
the developers at this site had an average of interactions over the seven working days from t 2to t interacting with distinct elements.
as with the authorship information the di erence between individuals is quite substantial as it depends on the individual s role on the team and their individual work patterns.
analyzing the data for the developers separately over the ve day period from t3to t the number of elements each developer interacted 4the di erence between the number of rst authorship events and elements rst authored is caused by developers merging streams.
5050150250350degree of interest monday tuesday wednesday thursday friday a d1 monday tuesday wednesday thursday friday b d3 figure positive .
.
.
.
.
.
.
.
december january february degree of authorship doa figure authorship events for ten elements with over the prior seven days of interaction is relatively stable at .
one way to indicate a developer s ongoing interest in a particular code element is to consider a degree of interest real value for the element computed from the interaction information.
we provide an overview of the next section section .
and reported in earlier work .
a positive suggests that a developer has been recently and frequently interacting with the element a negative indicates a developer has been interacting with other elements substantially since the developer interacted with this element.
at site on average each developer had elements with a positive degree of interest per day.
we can see this stability in graphs we produced for two developers.
figures a and b show for the period of ve working days t3to t elements with a positive on at least one of the ve days for each of the two developers.5these graphs show the di erences in work patterns across the elements for di erent developers.
some developers such as 5the shown in these graphs were based on the prior seven days of interaction for each day indicated.d1 figure a continuously interact with a group of elements which results in many lines above zero.
other developers such as d3 figure b interact with more elements less frequently resulting in more lines below zero due to the decay of interest in elements.
most of the six developers also had at least one code element with which he or she was interacting with a lot more than with the rest of the code.
.
authorship and interaction we have argued that authorship and interaction can each contribute valuable information to representing a developer s degree of knowledge for a source code element.
to investigate whether there is a di erence in the elements a developer authors versus interacts with we considered for each of the ve days between t 3and t the intersection of all code elements that had a positive all elements that had at least one rst authorship or delivery event.
on average out of elements with a positive only also had at least one rst authorship or delivery event in the previous three months.
thus interaction information provides a di erent perspective on the code a developer is working with than solely authorship information.
our analysis of the data also showed that the number of elements worked with varies with the day of the week.
the plot in figure shows the number of elements with at least one interaction event and the number of elements with a delivery or rst authorship event for each of ve consecutive days t 3to t .
while the number of elements developers interacted with holds relatively steady the number of elements delivered or rst authored increases prominently on friday.
the data suggests that the developers created changes throughout the week but delivered most of them on friday.
this trend suggests that interaction may be a useful predictor of recent source code familiarity whereas authorship helps capture familiarity over a longer period of time.
.
site 2data the data collected at site 2shows a lower rate of change in authorship information than site but even at the lower rate a substantial amount of the code in a developer s environment is changing each day.
the data from site 2shows even less overlap between code interacted with than authored.authorship number of elements monday tuesday wednesday thursday friday interac g415on figure authorship and interaction over five days on average developers at site 2had a rst authorship delivery or accept event every seconds compared to seconds at site .
considering unique elements and comparing to site the developers authored .
times as many elements delivered .
times as many elements and accepted changes to only as many elements .
the developers at site 2averaged interactions over the seven working days interacting with distinct elements and ending on average with elements each day with a positive the number of elements with a positive also had at least one rst authorship or delivery event is four an overlap of compared to the overlap at the rst site.
there are several potential reasons for these di erences.
first whereas the source repository system in use at site supported atomic changesets with explicit accept events occurring within the development environment at site the source revision system lacked both of these features.
instead we inferred delivery events based on revision information to source code elements if a developer performed several commits to the revision system as part of one logical change we record this as multiple delivery events.
second the lack of an explicit accept event that could be logged meant that we had to infer at the end of each day that all outstanding changes were accepted potentially increasing the accept events.
finally the code at site 2is smaller and is being worked on by a smaller team potentially causing a di erent event pro le.
.
degree of knowledge model our degree of knowledge model for a developer assigns a real value to each source code element class method eld for each developer.
our de nition of dok includes one component indicating a developer s longer term knowledge of a source code element represented by a degree ofauthorship value and a second component indicating a developer s shorter term knowledge represented by a degreeof interest value.
.
degree of authorship from our study of nineteen industrial developers we determined that a developer s knowledge in a source code element depends on whether the developer has authored and contributed code to the element and how many changes not authored by the developer have subsequently occurred.
we thus consider the degree of authorship doa of a developerin an element to be determined by three factors rst authorship fa the number of deliveries dl and the number of acceptances ac .
.
degree of interest the degree of interest represents the amount of interaction selections and edits a developer has had with a source code element .
a selection occurs when a developer touches a code element for instance a selection occurs when the developer opens a class to edit the class.
an edit occurs when a keystroke is detected in an editor window.
the an element rises with each interaction the developer has with the element and decays as the programmer interacts with other elements.
di erent kinds of interactions contribute di erently to the an element for instance a selection of an element contributes less to an edit of an element.
we use weightings for interactions as de ned in the eclipse mylyn project which is successfully supporting hundreds of thousands of java programmers in their daily work.
the eclipse mylyn project uses de ned elsewhere .
in contrast to eclipse mylyn our use of all interaction a developer has with the environment and does not consider any task boundaries indicated by the developer as part of their work.
.
degree of knowledge we combine the doa and a source code element for a developer to provide an indicator of the developer s familiarity in that element.
the degree of knowledge we compute linearly combines the factors contributing to doa and the dok fa fa dl dl ac ac .
determining dok weightings completing our de nition of a degree of knowledge value for a source code element requires determining appropriate weightings for the factors contributing to the degreeof authorship and for the degree of interest.
as there is no speci c theory we can use to choose the weightings we conducted an experiment to determine appropriate values empirically.
in essence the experiment involves gathering data about authorship from the revision history of a project about interest by monitoring developers interactions with the code as they work on the project and about knowledge by asking developers to rate their level of knowledge of particular code elements.
using the developer ratings we then apply multiple linear regression to determine appropriate weightings for the various factors.
we report in this section on an initial determination of weighting values based on the data collected from site .
we then test these weightings at site .
our intent is to nd weightings that serve as a basis to support exploratory investigations of the degree of knowledge model.
determining weightings that might apply across a broader range of development situations would require gathering data from many more projects which was not warranted at this early stage of investigation.
.
method at time t 3in figure we chose for each developer forty random code elements that the developer had either selected or edited at least once in the last seven days orwhich the developer had rst authored fa or delivered changes to dl in the last three months.
we chose forty as a compromise between gaining data about enough elements and not encroaching too much on the developer s working time.
each developer was then asked to assess how well he or she knew each of those elements on a scale from one to ve.
to help the developers with the rating scale we explained that a ve meant that the developer could reproduce the code without looking at it a three meant that the developer would need to perform some investigations before reproducing the code and a one meant that the developer had no knowledge of the code.
although this process meant that sometimes we asked the developer about ner grained code a eld and sometimes coarser grained code a class subsequent analysis of the data did not show any sensitivity to granularity.
through this process we collected ratings for all seven developers.
this value is less than the possible ratings because some of the elements we randomly picked were not java elements the authorship and interaction data also included xml javascript and other types of code and the developers stated that they would have di culty rating them we therefore ignored these elements.
for this experiment we consider results to be statistically signi cant with p .
.
.
analysis and results for our rst experimental setting we applied multiple linear regression to the data collected from the source revision logs and the interaction logs collected as the developers from site2worked.
multiple linear regression analysis tries to nd a linear equation that best predicts the ratings provided by developers for the code elements using the four variables fa rst authorships dl deliveries ac accepts and multiple linear regression is suitable for our data even though the user ratings are ordinal because we are attempting to nd an approximation not a certain class for the user ratings.
the values of some of the variables especially accan be substantially higher than the values of the other variables.
to account for these di erent scales that could potentially make the weighting factors di cult to ascertain we applied the analysis both with and without taking the natural logarithms of the values.
with the developer rating on a scale of one to ve as the dependent variable the best t of the data was achieved with the values presented in table when the natural logarithm of the acand was used.
the resulting dok equation is as follows.
dok fa dl ln ac ln negative values of usage that is not recent.
in this analysis we considered any negative to be zero so as to not unduly penalize dok.
if we had allowed negative then elements that the developer had never interacted with may have a higher dok value than elements interacted with long ago.
the fa dlandacvariables are signi cant in this model and thus help to explain the user ratings.
the is very close to being signi cant.
an analysis shows that the not correlated to any of the other variables suggesting that plays a predictive role despite nottable coe cients for linear regression weighting std.
error p value intercept .
.
.
fa .
.
.
dl .
.
.
ln ac .
.
.
ln .
.
.
reaching signi cance.
we hypothesize that the lack of signi cance is from the lack of elements with a positive the set of randomly chosen elements.
only of all data points have a positive have a positive fa have a positive dland have a positive ac component.
the f ratio a test statistic used for determining the predictive capability of the model as a whole is .
with p .
.
this states that the model based on our four predictor variables has a statistically signi cant ability to predict the user rating.
the overall model has an estimated goodness of t r square of .
adjusted r square is .
.
r square represents the fraction of the variation in our user rating that is accounted for by our variables.
the correlation coe cient r that represents a measure of the overall t between our predictor variables and the user rating is .
.
the standard error of the estimate is .
.
the .
r square value shows that our model does not predict the user rating completely.
however the p value of the overall model as well as the p values for the variables indicate that there is a statistically signi cant linear relationship between our model and the user ratings and that each of the four variables contributes to the overall explanation of the user rating.
.
external validity of the model to determine if our weightings have any applicability in a di erent environment we conducted a similar experiment with the two professional java developers at site .
as we did at site we again chose forty random code elements for each developer with the same characteristics as at site and we asked each developer to rank the presented elements from one to ve.
we then computed the dok values for each of the elements using the weightings determined through the earlier experiment with the developers at site .
to see whether our previously determined model can describe the relationship between the four variables and the developer ratings atsite we applied the spearman rank correlation coef cient statistic.
the spearman rank correlation is a nonparametric statistic that is designed to measure correlations in ordinal data.
for the code elements we studied from the two developers there is a statistically signi cant correlation with rs p .
.
this result suggests that our model can predict dok values with reasonable accuracy even when the environments from which the data was collected have di erent pro les section .
.
we hypothesize that the correlation coe cient is low because the statistic is especially sensitive to individual di erences when the sample size is low.
.
case studies to determine if degree of knowledge dok values can provide value to software developers we performed several exploratory case studies.
two case studies were conducted with the seven developers at site .
a third case study was performed with three developers at site these developers di ered from those described in section as data was collected at a di erent time to support the study.
the three developers were working on a closed source development effort one developer was working part time.
the participating developers had an average of .
years of professional experience at the time of the case study.
the rst case study considers the problem of nding experts who are knowledgeable about particular parts of the code.
the second case study considers a mentoring situation where an experienced developer might use his dok values to help a new team member become familiar onboard into that part of the code base.
the third case study considers whether a developer s dok values can be used to identify which changes to the code might be of interest amongst the many changes occurring during development.
.
finding experts the problem of nding experts is to try to identify which team member knows the most about each part of the codebase.
our degree of knowledge model applies directly to this problem.
method.
at site the code is partitioned into projects where a project is a logical group of java packages.
for this case study we chose two projects with which most members of the team had interacted.
one project comprised java packages the other comprised packages.
for each class in these packages and for each of the seven developers participating in our study we calculated the dok value for each class developer pair and then computed dok values for each package developer pair by summing the developer s dok values for each class in the package.
using these values we produced a diagram which we call a knowledge map that showed for each package in a project the developer with the highest dok for that package.
figure presents a part of the knowledge map for one project.6in this gure each developer is assigned a colour and each package is coloured or labelled according to the developer with the highest dok values for that package.
for one project of the packages were labelled and for the second out of were labelled.
thus packages in total were labelled.
for the remaining packages the dok values for all developers were not positive meaning primary expertise might lie outside the team.
we then conducted individual sessions with each of the seven team members.
in each session we rst showed the developer a list of the packages without any dok values indicated and asked the developer to write down the name of the team member whom he thought knows the package the best.
when requested we showed the developers a list of the classes within a package.
after gathering this data we showed the developer the knowledge map and asked if the map re ected his view of which developer knows which part of the code.
this approach runs the risk of developers over6please note this gure is best viewed in colour.in ating their expertise in a package to avoid not appearing as an expert in anything.
we believe this over in ation did not happen because the two projects represent only a small fraction of the entire system so a developer who did not indicate expertise in the packages that were part of the case study might still be expert in some other part of the code.
results.
we gathered data from six developers d1 d6 one developer d7 did not interact with any of the code in the two projects and thus was not able to provide meaningful data.
for the of the packages labelled with a single developer we gathered developers times packages assignments from the developers participating in the study.
in of these cases the developers in the study assigned one developer as being the one that knows the most or owns the package.
in of these cases the result we computed based on dok values was consistent with the assignments by the developers.
the accuracy value is a lower bound of our approach s performance given that the developer assignments were sometimes guesses after seeing the knowledge map the developers realized their assignments were likely wrong.
all six developers stated that the knowledge map was reasonable using phrases like it is close d4 and it re ects correctly d2 .
for the out of the packages for which we did not nd anyone using the dok values the six developers assigned someone to a package in cases.
in of these cases the packages had not been touched for a number of months and were created six months ago.
given that our dok values were based on three months of data we were missing the initial authorship data.
developers stated that in blank cases d4 where our dok did not determine anyone we should adapt the dok to go back further in time.
comparison to expertise recommenders.
for this task it is possible to compare to other approaches since earlier work in expertise recommenders has considered the problem of nding experts.
as described in section these approaches are based solely on authorship information.
to approximate the results of these earlier approaches we computed experts for each package by summing up all rst authorship and delivery events from the last three months for a developer for each class in the package.
three months was the most history available for these elements due to a major porting of the code at that time.
the developer with the most experience atoms the most events for a package is the expert.
we applied this expertise approach to the two projects.
in out of the total packages the expertise approach labelled a package with a di erent expert developer than our dok based approach.
for these packages we had assignments from the six developers.
in of these cases our dok based approach agreed with the developer assignments whereas the expertise approach agreed in only of these cases.
thus the dok approach improves the results for the packages that were labelled di erently by the two approaches by more than and the overall result by .
this comparison shows that dok values can improve on existing approaches to nding experts.figure part of a knowledge map .
onboarding becoming productive when joining a new development project requires learning the basic structure of the codebase.
the process of becoming pro cient with a codebase is known as onboarding .
in this case study we investigated whether dok values computed from developers with experience in a part of a codebase could be used to indicate which code elements a newcomer should focus on when trying to learn that part of the code base.
method.
for this study we randomly chose three developers d1 d3 d5 .
we asked each developer to describe which code elements from the areas in which he was working would likely be the most useful for a newcomer trying to come up tospeed on the code.
we then generated for each developer the twenty elements with the highest dok and asked the developer to comment on whether these twenty elements would likely be helpful for a newcomer.
results.
only of the elements generated across all three developers were considered by the developers to likely be helpful for a newcomer.
the other elements were described by the developers as not being essential for understanding the code.
the elements generated using the dok values were only implementations d1 or secondary consumers d3 .
the developers described that a newcomer only needs to understand basic patterns d1 d5 and that while the elements generated using dok could serve as examples it would be necessary to traverse up the inheritance hierarchy to locate the elements the newcomer should study d1 .
these comments are consistent with the descriptionof the developers that they often recommend newcomers to look at api elements.
the dok values for the api elements were either very low or zero as they were neither changing nor were they referred to frequently by the developers who authored them.
perhaps the developers had internalized these apis and did not need to refer to them.
for onboarding then the elements with high dok values were not considered helpful.
however the developers comments suggest that the elements with high dok might be used as a starting point to nd useful elements for onboarding by following call or type hierarchies.
we leave the investigation of this potential use of dok values to future research.
.
identifying changes of interest in many development projects keeping up with how the work of teammates might e ect one s work typically requires monitoring the progress of changes.
in many projects changes to the source code are tied to bug reports either by listing the bug report in the change or by attaching the change to a bug report e.g.
by attaching the change itself or meta information such as a task context .
by monitoring bug reports instead of inspecting individual source code changes a developer can be provided more rationale about a change.
many bug reports for the project like source code elements also typically change daily.
a developer who wishes to monitor changes of interest must typically perform searches over the bug repository.
determining which changes the developer should consider and ensuring searches are returning interesting changes can be di cult.
in this case study we investigated whether a developer s dok values can be used to select changes of interest to the developer because of overlap between the source code change and the developer s dok model.
method.
for this study we computed a dok model for each of three developers from site .
on a particular day we determined all bugs that had changed in the previous seven days we refer to this set as bc.
as these three developers work on multiple projects and we are analyzing changes of interest for one project we used seven days to capture a su cient amount of change to the project we were targeting.
the same seven days were used for developers s1 and s2 a di erent seven days were used for developer s3.
these dates di ered to accommodate developers schedules.
we then determined the subset of bugs that had change information attached to the bug we refer to this set as bci.
for each bug report with change information in bci we computed the aggregate dok value for each element in the change information based on the developer s dok model.
we formed the set of bugs with an aggregate dok value that was positive we refer to this set as bpot.
we then removed the bugs in bpot when the developer was already mentioned on the bug as an assignee reporter or had commented on the bug.
the resulting set of bugs are those we 7for this project the change information were task contexts collected automatically as a developer worked and thus represented both the elements changed in the revision system and elements considered by the programmer in making the change.table size of bug recommendation sets developer bcbci bpot br s1 s2 s3 report as bugs of interest to the developer we refer to this set as br.
for each bug in br we asked the developer whether they had read the bug or whether they would have wanted to be aware of the bug.
results.
table summarizes the number of bugs in each set for each developer.
developer s1 was asked about the relevance of three bugs.
he noted that he had read each of these bugs to make sure no further action was required on his part.
developer s2 was asked about two bugs.
she noted that for one of these bugs she was asked in person about the contents of the bug although she had not read it previously.
the developer was impressed our approach had picked it out of the many bugs that were undergoing change.
developer s3 was recommended one bug.
he had read the bug but did not comment explicitly about whether the bug was relevant to his work.
overall our approach provided relevant information to developers in four out of six cases by recommending nonobvious bugs based on the developers dok values.
while our case study used a very coarse grained metric to determine relevance of bugs using dok values we were able to easily recommend more relevant bugs than noise.
.
discussion the degree of knowledge dok model is in uenced by both the software development process and the software system being developed.
we detail a number of the factors in uencing dok and how they pose threats to the validity of the experiments and studies we conducted.
.
amount of data our studies were based on three months of authorship data and seven working days of interaction data.
we chose this duration for authorship data based on interviews in our earlier study .
in these interviews developers had suggested three months as a lower bound for the period of time in which one still has knowledge about code after authoring it.
also based on our previous study we chose seven working days of interaction data.
seven working days was the average number of working days that showed a signi cant result for the correlation between a developer s knowledge and his interaction.
.
multiple stream development the seven developers we studied at the rst site share code in streams which are similar to branches in a source revision system.
the developers deliver their changes to one or more streams and accept changes from streams into their workspace.
normally the developers we studied work only on a small number of streams.
however during our data collection and study period some of the developers were working on many streams it s not a normal situation right now very branched out i almost spend more time merging than working on it d5 .
when streams representing di erent versions of the same code are merged additional authorship events are recorded that could skew the results of our experiment and studies.
we tried to minimize the in uence of these extra events by focusing on only one major stream for each developer.
.
project phase developers interact di erently with a codebase depending on the phase of the project on which they are working.
in the week in which we collected interaction data at site to determine the dok weightings the team was in a testing phase for an upcoming milestone release.
some of the developers reported that they were only performing minor adjustments to the code but not really making any bigger changes to ensure the code did not break.
some developers stated that a couple of months before they were working on new features during which a substantial amount of new code was created and the focus of individual developers in a part of the codebase was higher.
the number and size of changesets and the tasks of the developers i.e.
testing versus feature development in uences the authorship and interaction data.
by taking into account three months of authorship data seven days of interaction data and also con rming the results of the dok weighting experiment at a second site we have tried to minimize the impact of project phases on our results.
further longitudinal studies are needed to better understand the impact of project phases on indicators such as dok.
.
individual factors the rst team of seven developers we studied have a strong model of code ownership with code split amongst team members and certain individuals responsible for certain packages.
other teams we have spoken with have a model of mutual ownership with the team members often working on the same code.
the style of code ownership within a team in uences the data input to determine dok values.
we have tried to mitigate the risk of these di erent styles by considering whether the weightings determined for one team applied to another team.
however study of more teams is needed to determine how robust the dok values are to team and individual styles.
a developer s activity also has an in uence on the data.
for instance one developer in our study was working on more than four di erent streams and was expending e ort that week merging streams together.
when we applied linear regression on the data points gained from only this developer the result was not signi cant.
for other developers the goodness of t of the model is more than twice as good as the goodness of t for all developers.
thus while individual factors such as the team s style of code ownership and activities of individuals in uence results by having several developers each with a di erent activity we have tried to minimize the risk of individual biases.
.
api elements in the onboarding case study api elements a ected the outcome developers suggested api elements as important that dok values did not capture.
the root of the problem is that api elements by necessity do not change often.
in the three month period we considered for the authorshipcomponent of dok there was not a su cient number of events on the api elements for their dok to rise based on authorship.
furthermore as api elements often become basic knowledge developers do not need to interact with them frequently so the interaction data also does not cause their dok values to rise.
the developers who participated in the case study stated that the elements found using the dok are often one or two layers below the api elements.
a possible improvement to the dok could be to infer familiarity from subclasses up to the api elements that are the supertypes as it is likely a subclass user knows the api elements to some extent.
.
summary on average six professional java developers at a site we studied accepted changes to source code elements per day and interacted with distinct source code elements over a seven day period.
this data con rms what is apparent when one watches a professional developer at work the amount of information that ows into and changes in a developer s development environment is substantial.
by studying professional developers we also found evidence that the code a developer authors and the code with which the developer interacts are not the same.
this high degree of ux and differences in code authored visible to other team members from code considered not visible to other team members makes it di cult for developers to know who on their team has familiarity with di erent parts of the codebase.
to help capture and provide access to information about who knows what about the code we have presented the degree of knowledge dok model.
by incorporating both authorship and interaction information gathered for a developer a dok value for each source code element and developer pair can be produced.
we have de ned an equation to compute dok values and set the weightings for the authorship and interaction factors through an experiment with seven professional java software developers.
we con rmed these weightings through a second experiment at a second site with two professional java developers.
to show that the dok model can provide value we report on three exploratory case studies.
through these case studies we have shown how dok values can improve upon existing approaches to computing expertise that are based solely on authorship.
we have also shown how dok values might be used to pick out changes of interest in the environment to the developer.
directions for future work in improving dok were also determined through these studies such as ways to better capture familiarity in api elements.
the case studies we have conducted provide initial evidence to suggest that further study of the dok model is warranted.
in particular the weightings for the factors contributing to the dok model and the appropriate amounts of data to use to compute dok values require experimentation with more developers in a greater variety of situations.
.