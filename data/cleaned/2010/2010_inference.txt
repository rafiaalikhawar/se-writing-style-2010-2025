inferring better contracts yi wei carlo a. furia nikolay kazmin bertrand meyer chair of software engineering eth z rich switzerland yi.wei carlo.furia bertrand.meyer inf.ethz.ch nkazmin student.ethz.ch abstract considerable progress has been made towards automatic support for one of the principal techniques available to enhance program reliability equipping programs with extensive contracts.
the results of current contract inference tools are still often unsatisfactory in practice especially for programmers who already apply some kind of basic design by contract discipline since the inferred contracts tend to be simple assertions the very ones that programmers nd easy to write.
we present new completely automatic inference techniques and a supporting tool which take advantage of the presence of simple programmer written contracts in the code to infer sophisticated assertions involving for example implication and universal quanti cation.
applied to a production library of classes covering standard data structures such as linked lists arrays stacks queues and hash tables the tool is able entirely automatically to infer of the complete contracts contracts yielding the full formal speci cation of the classes with very few redundant or irrelevant clauses.
categories and subject descriptors d. .
software veri cation programming by contract assertion checkers reliability f. .
specifying and verifying and reasoning about programs keywords contract inference invariants data mining random testing .
introduction contracts are widely recognized as one of the most promising techniques for achieving software reliability.
the advantages of equipping software with contracts include not only avoiding mistakes in the rst place and documenting the software accurately but also if mistakes do remain improving dramatically the e ectiveness of tests and opening permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.up the possibility of proofs as well as automatic correction .
to yield the full range of these potential benets the contracts must be present throughout the software and must describe its semantics as completely as possible.
most practical software however comes equipped with no contracts or in languages enjoying support for design by contract with incomplete contracts.
to compensate researchers have explored techniques surveyed in section for inferring contracts from the code.
some of these techniques such as abstract interpretation involve static program analysis others such as daikon are dynamic and rely on data from program executions.
these developments have yielded many important results and insights but their practical usability remains limited.
the advantages and limitations of the two kinds of techniques are complementary static approaches report sound but conservative contracts and are mostly successful with small programs.
dynamic approaches scale better but tend to be limited to inferring simple properties such as a postcondition in a list insertion routine stating that the list size has been increased by they also produce properties that are redundant with others or subsumed by them such as the list has grown in size in this example and unsound properties that characterize the test suite rather than the program.
even when relevant and non redundant the simpler properties typically inferred may be disappointing to programmers writing in a contract equipped language as they often are the kind of contract elements that programmers naturally intuit what they expect from a supporting tool is that it will infer the more sophisticated properties.
the present work describes techniques for inferring advanced contracts especially in the case of a contract equipped language where the tools can take advantage of simple partial contracts written by the programmers.
its focus is onpostconditions ofcommands routines changing the state of objects as opposed to queries which return information about an object it more speci cally looks for two important kinds of command postcondition clauses clauses involving quanti cation to express for example that all previous elements of a structure are still present.
such clauses which programmers seldom write are critical to express frame properties.
clauses involving implications whose premises are single formulae or conjunctions of formulae.
both kinds of postconditions are di cult to handle with most existing approaches without customized instrumentation.
we demonstrate that when simple contracts are avail1listing programmer written and automatically inferred postconditions of linked list .extend .
1extend v g add v to end.
do not move cursor.
2ensure programmer written 4post occurrences v old occurrences v automatically inferred 7post count oldcount 8post ith oldcount v 9post forall i. i oldcount implies ith i oldith i 11post old after implies index oldindex 12post not old after implies index oldindex 14post last v 15post forall o g6 v. occurrences o oldoccurrences o 17post forall o g6 v.has o oldhas o able as in contract equipped languages our techniques can infer stronger contracts fully automatically.
experiments show that the proposed techniques which we have implemented in the autoinfer tool inferred of the complete postconditions for data structure classes such as linked list queue stack array and hash table from eiffelbase a production library which has been available for many years and is widely used in ei el applications.
the inferred contracts achieve a high relevance in that the various clauses are complementary and not mere repetitions and accurately record the e ect of each command on the visible state of the data structure.
autoinfer is entirely automatic.
it relies on dynamic analysis techniques and a general catalog of contract patterns.
to construct the test suite that serves as a basis for contract inference autoinfer relies on the autotest test generation framework.
section gives an example of the kind of sophisticated contracts that autoinfer is able to infer.
section describes the automatic generation of the test suite for classes under analysis.
section explains the calculation of change proles.
section describes how to infer sophisticated postconditions involving functions with arguments quanti cations and implications.
section evaluates the e ectiveness of the proposed inference techniques.
after the discussion of related work in section section presents future work.
section draws conclusions.
.
example and overview class linked list is the standard ei el implementation of linked lists using dynamic allocation.
a typical query is occurrences v g integer returning the number of times its argument vof generic type gappears in the list.
a typical command is extend v g extending the list by adding vat the end.
the class authors equipped many features with contracts.
for example they annotated extend with the postcondition clause post 1in listing to state that the command increases the number of occurrences of the inserted element v by one.
the listing only shows the command header and thepostcondition ignoring the precondition body and other clauses .
as it is often the case with contracts written by programmers the postcondition clause post 1is interesting but incomplete as it fails to mention the command s e ect on other components of the object state described by queries other than occurrences .
to be complete the postcondition should also state that the element vhas been inserted at the end of the list.
all the elements that were in the list before executing extend are still there in the same positions.
the internal cursor of the list does not change position.
the techniques described in the present paper implemented in our autoinfer tool can automatically infer postconditions clauses post 2topost 6in listing which completely formalize the e ects of extend post 2asserts that exactly one element is added.
post 3states that vappears at position oldcount the position next to the last valid position of the list before invoking extend .
post 4states that for every valid position iof the old list the element at position iis the same before and after the call.
post 5and post 6formalize the position of the cursor in terms of its integer position index if the cursor was after the last element of the list before invoking extend it is now after the new last element corresponding to an increment of index by one otherwise index is unchanged.
even though post post 6capture every e ect of extend observable through the queries of linked list redundant clauses may still be desirable to increase the readability and usefulness of the postcondition.
autoinfer indeed infers three additional clauses listed as post 7topost 9in listing vis the lastelement of the list post the number of times every element other than vappears in the list is unchanged post any element other than voccurs in the list after insertion if and only if it occurred before post .
overview.
figure gives an overview of the inference techniques described in the rest of the paper and of how autoinfer integrates them.
.
the input is an ei el class equipped with public queries commands and possibly a few basic contracts.
.
using the random testing techniques implemented in autotest autoinfer generates a test suite that exercises as many routines as possible section .
.
autoinfer executes the test suite and pro les the results monitoring in particular which arguments and values returned by queries change when executing a command.
this information is collected in a change pro le section .
1in listing forall o g6 v. ... is a shorthand for forall o g.o6 vimplies .... 2test suite change profile quantified expressions implication expressions inferred contracts change analysispredicate mining validation decision tree learningconfidence filtering basic templates validation eiffel class autotestfigure how autoinfer works.
.
autoinfer performs template based invariant detection a ladaikon to infer dynamically the simplest contract clauses.
the information in the change pro le is used to activate selectively a restricted number of templates thus minimizing the inference of uninteresting or redundant clauses section .
.
for example post 2and post 7in listing are discovered using this technique.
.
autoinfer mines the change pro le for predicates appearing in expressions which evaluate to di erent values in the pre and post state of some execution.
it then instantiates a number of pre de ned templates with the predicates to obtain a set of quanti ed expressions such as post post post and post in listing .
the expressions are candidate contracts which are validated against the test suite the candidates passing all test cases are likely valid contracts section .
.
.
autoinfer also applies machine learning techniques based on decision tree learning algorithms to expressions in the change pro le.
the goal is nding correlations between expressions that change or stay constant.
every correlation with con dence translates into a likely valid contract in the form of an implication section .
.
for example decision tree learning inferred post 5andpost 6in listing by observing queries that change when executing extend .
.
finally autoinfer collects all the inferred contracts and displays them to the user.
.
test suite generation autoinfer starts from dynamic techniques.
dynamic techniques observe the program state over multiple executions at pre de ned points such as the entry and exit of a routine and generalize these observations into likely valid contracts based on a given set of templates.
the inferred contracts are only as good as the test suite which exercised the program sound and interesting contracts require a set of test cases which execute program paths extensively and with varied values.
autoinfer takes advantage of the existing autotest random testing framework to build test suites completely automatically.
autotest works on ei el classes equipped with contracts.
its test generation mechanism produces apool of random objects by calling constructors and commands with random arguments.
then to generate a test case for a routine rof a class c it selects from the pool a target object of class cand a collection of objects and other values whose types make them appropriate as actual arguments for r. the precondition of rserves as a lter on the objects in the pool to select a valid input the postcondition ofrserves as an oracle to determine if the test case executed correctly or exposed a bug.
in this work we focus as noted on inferring postconditions of commands.
the reason for this choice is the empirical observation that preconditions are usually much simpler than postconditions in fact programmers often do write complete preconditions .
we modi ed autotest to discard failing test cases and increased its capability of exercising commands with the precondition satisfaction technique developed in recent work .
the test suites built with this method proved to be appropriate for dynamic contract inference techniques.
previous authors using dynamic techniques have stated that test suites produced with random test generation are unsuitable for contract inference .
our own experience shows otherwise in the case of programs that are already equipped with a few simple contract elements with the goal of inferring additional more sophisticated assertions.
.
change profile autoinfer runs the test suite generated by autotest evaluates a set of expressions at the entry and exit points of a command and determines how the command changes their values.
the result is a change pro le for the command consisting of the values and their changes.
the change pro le is the basis for deciding which templates to activate during the next phase contract inference section .
the rest of this section explains how to select expressions and compute their change pro les.
the key goal apparent in the notations introduced below is to go beyond the simple properties found by most previous tools such as count oldcount involving queries with no arguments and infer properties involving more complex queries with arguments as in occurrences v oldoccurrences v .
.
monitored entities whenever a test case exercises a routine autoinfer keeps track of the value of a number of entities before and after 3current vfigure an instance of linked list .
executing the routine s body.
the following notations are useful for a command cof a classcwith formal arguments a1 a mand ann argument public query qof a classd scdenotes the setfcurrent a1 a mgofsymbolic values corresponding to the current object this self and the formal arguments of c. tq c scdenotes the set of symbolic values in sc of type conforming to d every element in tq cis a type correct target for calls to q. aq c i scdenotes the set of symbolic values in scof type conforming to the i th argument ofq.
eq cdenotes the set8 a0 q a1 a n a02tq c i nai2aq c i9 of type correct expression calls toqwith target and arguments from sc.
example.
consider the command extend v g of linked list and the query has v g of the same class.
then sextendisfcurrent vg thas extendisfcurrentg ahas extend isfcurrent vg assuming that the generic type gallows nested lists ehas extendisfcurrent .has v current .has current g. .
value sets consider an execution kof a command c. for every public queryq vq c kis the set of triples he v v0isuch thate2eq c is an expression call to q vis the value returned by evaluatingeright before the execution kofc andv0is the value returned by evaluating eright after the same execution.
example.
continuing the example of section .
consider an invocation kof command extend v g on the list of figure .
vhas extend k is thenfhcurrent .has v false truei hcurrent .has current false falseig.
the value pre post and change sets summarize the effects of a command con the values of a public query qin every execution.
the value setvq c eof command conexpression e2 eq cis the set hv v0ijhe v v0i2 kvq c k of all values eevaluates to in any execution of c. the pre set vq c eofcone2eq cis the setfvjhv v0i2 vq c egof all values eevaluates to before executions of c. the post set !vq c eofcone2eq cis the setfv0j hv v0i2vq c egof all values eevaluates to after executions ofc.
the change setevq c eofcone2eq c de ned only for calls to queries returning numeric values is the set fv0 vjhv v0i2vq c egof all di erences between the valueseevaluates to after and before executions of c. an expression e2eq cisvariant with a command c i vq c econtains at least a pair hv v0isuch thatv06 v. the notion of variant expression guides the selection of potential consequents in contracts involving implications section .
.
examples.
the following examples again applying to extend oflinked list illustrate the notions of pre post and change set.
the query call current .isempty determines whether the current list is empty.
extend may execute on empty or non empty lists always yielding a non empty list.
hence for every non trivial test suite the pre set of extend oncurrent .isempty isftrue falseg the post set isffalseg and current .isempty is variant.
the query call current .count returns the number of elements in the list.
extend always increases count by one so the change set of extend oncurrent .count is f1g.
the post set contains all positive integers from to the maximum length of a list generated in the test suite.
.
inference techniques this section describes the inference techniques implemented in autoinfer.
.
illustrates how to generate candidate contracts involving quanti cation .
discusses the generation of contracts with implications .
describes how the inference of basic contracts integrates with the other techniques and .
presents validation techniques for candidate contracts.
.
contracts with quantification many interesting contracts compare the values returned by queries for di erent values of their arguments such contracts can be formalized with expressions involving quanti cation.
quanti ed expressions are particularly useful in contracts of container classes executing a command typically introduces local changes to the data structure for example by adding or removing an element a complete contract however should also mention explicitly that the state of the rest of the container has notchanged.
such invariance properties are also called frame properties .
consider for example the command start of the running example class linked list which moves the internal cursor to the rst position in the list.
while the e ect of start on the cursor is easily described in a contract expressing the absence of e ects on the elements of the list requires contracts involving quanti cation such as forall o.has o oldhas o which states that the list contains an object o after executing the command i it contained it before.
which query calls should appear in contracts involving quanti cations?
autoinfer mines the change pro le for calls to public queries on targets accessible from the current command.
in principle autoinfer can consider queries with any 4number of arguments.
to simplify the presentation however we focus here on single argument queries.
consider the set of expressions de ned by the grammar pc3p truejt qjnot pjoldp whereqranges over the set of all public queries and tranges overtq c. forp2pc letp o denote the call expression where the query appearing in p if any is applied to argumento.
for each choice of expressions2x y z2pcwhose arguments have compatible types autoinfer instantiates the following templates as candidate postconditions forc.
forall o.x o y o forall o.x o y o forall o.x o ory o implies z o forall o.x o and y o implies z o for eachx y z2pc if the command chas a formal argumentvof type compatible with the type of oinx o y o z o autoinfer also instantiates the following templates.
forall o6 v.x o y o forall o6 v.x o y o forall o6 v.x o ory o implies z o forall o6 v.x o and y o implies z o the idea behind this second set of templates is that if a commandcoperates on an argument vof the same type as some query q it is likely to a ect the values returned by the query di erently according to whether qis invoked with vor with a di erent value as argument.
for example this is the case of command extend in listing whose postcondition clauses post 8and post 9have been inferred according to the conditional quanti ed templates.
sequence based contracts.
many container data structures can enumerate the elements they contain in a linear sequence.
this obviously holds not only of lists but also of more complex structures such as trees through standard traversal mechanisms.
an indicator that a data structure may admit an enumeration of its elements is the presence of a public query with a single argument of type integer and a precondition constraining the values that the argument can take to an interval of the integers.
whenever a query en i integer with these characteristics exists we denote by enthe sequence of values en m en m en m it induces where is the integer interval determined byen s precondition .
for example the query ithof class linked list returns a reference to the i th element in the list provided i count .
this induces the sequence ithof values ith ith count .
whenever a sequence representation enis available autoinfer instantiates a number of candidate contracts that try to capture the e ects of any command con the sequence of values en.
these contracts are built by instantiating the template en old en z old en with values for x y z where denotes the subsequence of corresponding to the interval and denotes con2obviously redundant or trivial expressions are immediately discarded.
3all quanti cations are implicitly restricted to objects of conforming type.catenation.
our experience with model based contracts suggested the particular form of which is only a readable shorthand for the three candidate contracts with quanti cation in listing where abbreviates the expression m old x m and ifz denotes the empty sequence then c2is unde ned and z otherwise z .
the method for picking values for x y z is informally to use forxandzany two