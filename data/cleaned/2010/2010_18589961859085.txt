dynamic and transparent analysis of commodity production systems aristide fattoriyroberto paleariylorenzo martignonizmattia mongay aristide roberto security.dico.unimi.it lorenzo.martignoni uniud.it mattia.monga unimi.it dip.
di informatica e comunicazioneydip.
di fisicaz universit degli studi di milano universit degli studi di udine i milan italy i udine italy abstract we propose a framework that provides a programming interface to perform complex dynamic system level analyses of deployed production systems.
by leveraging hardware support for virtualization available nowadays on all commodity machines our framework is completely transparent to the system under analysis and it guarantees isolation of the analysis tools running on top of it.
thus the internals of the kernel of the running system needs not to be modied and the whole platform runs unaware of the framework.
moreover errors in the analysis tools do not a ect the running system and the framework.
this is accomplished by installing a minimalistic virtual machine monitor and migrating the system as it runs into a virtual machine.
in order to demonstrate the potentials of our framework we developed an interactive kernel debugger named hyperdbg .
hyperdbg can be used to debug any critical kernel component and even to single step the execution of exception and interrupt handlers.
categories and subject descriptors d. .
testing and debugging debugging aids monitors tracing d. .
systems programs and utilities general terms veri cation keywords hardware virtualization debugging system analysis .
introduction operating systems are peculiar and very complex pieces of software whose internals are critically vital for a system a failure or a bottleneck in any of their parts can lead to permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.catastrophic consequences.
therefore special care is needed to develop analyze test and pro le them.
to simplify their task developers and analysts rely on a large variety of tools and analysis techniques.
some of them are speci c for studying static properties of the operating system while others are more speci c for studying dynamic properties.
in particular the latter class of tools and techniques is nowadays very popular among kernel developers and analysts because it allows them to collect the information very quickly while hiding many of the intricacies of the kernel and can even be used on running production systems.
existing approaches for dynamic analysis of operating systems e.g.
debugging pro ling and tracing can be roughly classi ed in two groups kernel based and vmm based.
the approach taken by the rst group is to include some component into the kernel in order to intercept all the events of interest e.g.
the creation of a new process the execution of a system call and the execution of a kernel function and to execute a speci c action when such events occur .
this solution requires the installation of speci c hooks in the kernel to monitor run time events and it might be very di cult to apply to operating systems that do not natively o er facilities for dynamic analysis especially when the source code is not available.
the approach taken by the second group is to run the kernel and user space applications in a virtual machine and to intercept and respond to the events of interest from the virtual machine monitor vmm .
although this approach guarantees transparency and has a loose dependency on the operating system internals it cannot be used in all the settings since it implies that the system must be run as a guest of a virtual machine and production systems not running in virtual machines cannot be analyzed.
moreover vmm based solutions typically virtualize hardware devices to allow multiple guests to share the same physical peripherals.
this makes software virtualization approaches unsuitable to assist the analysis of components that need to interact directly with the underlying hardware.
in this paper we propose a framework that brings together the advantages of both approaches it can be used on commodity production systems i.e.
o the shelf products whose source code or debugging symbols are not necessarily available since it does not require to instrument the system under test and it is able to inspect systems running on real hardware since it does not require an emulation container.
similarly to existing frameworks the analyses that can be built on top of our framework include pro ling and tracing of the kernel and user space applications interactive debugging or even extension of system features.
however di erently from existing frameworks ours is fully dynamic transparent loosely dependent on the operating system and fault tolerant with respect to possible defects in the analysis code.
first our framework does not require recompilation or rebooting of the target system.
thus it can be used to analyze any running production system including commodity operating systems lacking native support for instrumentation and systems not running in virtual machines.
second the framework is not invasive since analyses can be performed on a virtually unmodi ed system as explained in the paper only a minimal driver needs to be installed and no parts of the kernel are patched in any way.
moreover since the framework itself is not accessible from the target system its code cannot be detected by malicious code or unwittingly in uence buggy operating system components.
thus the infrastructure can be applied to any operating system as the majority of the facilities it supports are completely osindependent and the only os dependent functionalities are just provided to ease the development of analysis tools.
finally the framework is fault tolerant as it guarantees that a defect in an analysis tool built on top of it does not damage the framework itself nor the analyzed system.
our framework leverages hardware extensions for virtualization available on commodity x86 cpus .
hardwaresupport for virtualization allows the development of virtual machine monitors that are very e cient completely transparent and non invasive to the systems running in the virtual machine.
to overcome the major limitation of traditional vmm based approaches i.e.
the impossibility to analyze productions systems not running in a virtual machine our framework exploits a feature of the hardware that allows to install a virtual machine monitor and to migrate a running system into a virtual machine .
when the analysis is completed the original mode of operation of the system can be restored.
practically speaking our framework is a minimalistic virtual machine monitor acting as a broker between the analyzed system and the analysis tool.
the framework abstracts low level events occurring in the analyzed system into high level events and guarantees fault tolerance by relying on the hardware to run the analysis tool in a isolated execution environment.
to demonstrate the potentials of our framework we have developed an interactive kernel debugger nicknamed hyperdbg constructed entirely using the programming interface exposed by our infrastructure.
hyperdbg adds live and interactive debugging support to microsoft windows xp so far only possible using very invasive tools like syser or traditional vmm based debuggers.
hyperdbg can be used to debug any component of the windows kernel including interrupt exception handlers device drivers and even supports single instruction stepping.
being completely separated from the debuggee hyperdbg is transparent to the analyzed system and can be even used to analyze protected and malicious code.
in summary the paper makes the following contributions.
.
we propose a framework to perform complex dynamic system level analyses of commodity production systems.
compared to existing frameworks the one we propose guarantees transparency e ciency and does not require the target system to be already installed on a virtual machine.
.
we implemented our framework in an experimental prototype for microsoft windows xp.
.
we describe the design and implementation of hyperdbg a kernel level interactive debugger built on top our framework.
both the analysis framework and hyperdbg are available at and are released under the terms and conditions of the gpl v3.
license.
.
related work the framework proposed in this paper shares many similarities with frameworks and techniques extensively explored in the past.
however by exploiting recent facilities available of modern intel x86 cpus our framework is able to combine and to o er simultaneously the main bene ts introduced by previous research work.
.
dynamic kernel instrumentation dtrace is a facility included into the solaris kernel that allows the dynamic instrumentation of production systems .
the key points of dtrace are e ciency and exibility.
first the instrumentation framework itself introduces no overhead.
second the framework provides tens of thousands of instrumentation points and the actions to be taken can be expressed in terms of a high level control language that also includes a number of mechanisms to guarantee run time safety.
similarly kerninst is a dynamic instrumentation framework for commodity kernels .
kerninst has been developed mainly to gather information about the performances of a running kernel but it has also been employed for run time kernel optimization.
di erently from dtrace kerninst is not transparent to the others components of the system and does not provide any mechanism for run time safety of the instrumentation routines.
none of the aforementioned approaches is os independent and they cannot be applied to closed source operating systems.
dtrace requires the pre existence of instrumentation points in the kernel.
kerninst instead requires to patch the code of the kernel of the operating system to add the missing instrumentation points.
clearly that is possible only if low level details about the internals of the kernel are made available.
our framework does not su er these limitations since it can instrument the kernel without modifying it and does not rely on any facility o ered by the kernel.
.
kernel level debugging several e orts have been made to develop e cient and reliable kernel level debuggers.
indeed these applications are essential for many activities such as the development of device drivers.
one of the rst and most widely used kernel level debuggers that targeted the microsoft windows operating system was softice but today the project has been discontinued.
however both commercial and open source alternatives to softice appeared.
modern versions of windows already include a kernel debugging subsystem .
unfortunately to exploit the full capabilities of microsoft s debugging infrastructure the host being debugged must be physically linked e.g.
by means of a serial cable with another machine.
all these approaches share a common factor to debug kernel level code they leverage another kernel level module.
obviously that is like a dog chasing its tail.
the framework proposed in this paper does 418operating system kernel user mode kernel mode user process user process operating system kernel user mode kernel modeuser processuser process non root mode root mode framework analysis tool install remove exit inspect figure overview of the framework not require any kernel support nor to modify the kernel to add the missing support at run time.
.
frameworks based on virtual machines instead of relying on a kernel level module to monitor other kernel code an alternative approach consists in running the target code inside a virtual machine and performing the required analyses from the outside .
in the authors propose virtual machines with execution replaying capabilities a user can move forward and backwards through the execution history of the whole system both for debugging and for understanding how a hacker intrusion took place.
finally in chow et al.
propose aftersight a system that decouples execution recording from execution trace analysis thus reducing the overhead su ered by the system where the guest operating system is run.
nowadays aftersight is part of the vmware platform and other mainstream commercial products provide similar capabilities.
the framework proposed in this paper can provide these functionalities even on systems not running in any virtual machine.
.
aspect oriented programming aspect oriented programming is a paradigm that promises to increase modularity by encapsulating cross cutting concerns into separated code units called aspects whose advice code is woven into the system automatically by specifying the properties of the join points.
aspectc is an aspectoriented framework that is used to customize at compiletime operating system kernels .
more dynamic approaches have been proposed for example toskana provides before after andaround advices for in kernel functions and supports the implementation of aspects themselves as dynamically exchangeable kernel modules .
the framework proposed in this paper allows to achieve the same goal while being transparent and fault tolerant.
.
overview of the framework figure depicts the architecture of our framework the installation and removal processes and the migration of the operating system and its applications into a virtual machine.
our framework consists of a virtual machine monitor vmm for short that provides a programming interface for the development of system level analysis tools.
as in traditionalvmm based analysis approaches the analysis tool is run within the vmm and thus completely transparent to guests of the virtual machine.
however compared to traditional vmm based ones ours does not require the system to be already running inside any virtual machine.
to achieve this goal our framework leverages hardware extensions for virtualization available on all modern x86 cpus which are unused in the majority of the deployments .
in short these extensions augment the instruction set architecture with two new modes of operation vmx root mode and vmx nonroot mode1.
these new modes of operation separate logically the virtual machine monitor from a guest without having to modify the latter.
more precisely we exploit a particular feature of these extensions that allows for late launching of vmx modes .
late launching of vmx modes permits to install a virtual machine monitor even if the system has already been bootstrapped.
in other words late launching allows to migrate temporarily a running operating system in a virtual machine and to analyze and control the execution of the system from the monitor.
through the rest of the paper we use the term guest to refer to the system under analysis that has been migrated into a virtual machine.
practically speaking the running operating system is not migrated anywhere and not touched at all.
rather by launching vmx modes the execution environment is extended with the two aforementioned operating modes the running operating system is then associated with non root mode while the vmm is associated with root mode.
thus in all respects the operating system and its applications become a guest of our special virtual machine.
following the same principle the vmm can be unloaded and the original mode of execution of the operating system restored by simply disabling vmx modes.
after the launch of the vmx modes the execution of the guest can continue exactly as before even in terms of interactions with the underlying hardware devices.
however during its execution the guest might be interrupted by an exitto root mode.
like hardware exceptions exits are events that block the execution of the guest switch from non root mode to root mode and transfer the control to the vmm.
di erently from exceptions the set of events triggering exits to root mode can be con gured dynamically by the vmm.
a routine of the vmm handles the exit and eventually enters non root mode to resume the execution of the guest.
being executed at the highest privilege level the routine handling the exit has complete read write control of the state of the guest system of both memory and cpu registers .
the framework itself does not perform any analysis.
it is only responsible for handling a small set of exits to control all accesses to the memory management unit of the cpu to prevent the guest from accessing the physical memory locations holding the code and the data of the framework.
on the other hand the framework provides a exible api to develop tools to perform sophisticated analyses of both kernel and user code running in the guest.
using the functionalities provided through the api the tool can request the framework to monitor certain events that might occur during the execution of the guest when such events occur it can inspect and even manipulate the state of the guest.
the events that can be monitored include but are not limited to system call invocations function calls context switches and 1vmx non root mode is the terminology used by intel amd adopts a di erent terminology.
.
interruptevent gate trap gate api analysis tool .
exit .
noti cation .
api call .
exception .
api request 4a.
inspect manipulate 4b.
request event noti cation .
recover information about events non root mode root mode user mode kernel mode hardware framework timer disk network video figure a close up of the framework i o operations.
practically speaking events are monitored through exits to root mode.
thus a request of the analysis tool to monitor a certain high level event e.g.
the execution of a system call is translated by the api of the framework into a sequence of low level operations that guarantee that all the occurrences of such event in the guest trigger an exit to root mode.
similarly the framework translates the exit into a higher level event and noti es the occurrence of the event to the analysis tool.
once noti ed the tool can recover information about the event e.g.
arguments and return value of a system call using the inspection functionalities o ered by the api.
an important requirement for the analysis of production systems is that analysis tools must not interfere with the correct execution of the guest.
this is particularly important for faults and deadlocks that might occur in the analysis tool.
the approach we adopt is to run the tool in a less privileged execution environment isolated from the analyzed system and from the framework.
the tool can interact with the guest only through the api exposed by the framework.
this approach guarantees the framework the ability to intercept any fault occurring in the tool to mediate all accesses to the analyzed system and to prevent write accesses and to terminate the tool in case of deadlocks or other anomalous situations.
.
design and implementation figure shows a more detailed view of the architecture of our framework.
intuitively this architecture is very similar to that of traditional operating systems the framework plays the role of the kernel and the analysis tool plays the role of a user space application.
as will become clear later this architecture prevents buggy analysis tools from compromising the guest system and the framework.
the separation between these two parts is made possible by the fact that when vmx is enabled root and non root modes o er two fully featured execution environments.
thus like the guest running in non root mode the framework running in root mode can rely on privilege separation to isolate the analysistool and can handle independently interrupts and exceptions that might occur while executing in root mode.
when an exit to root mode interrupts the execution of the guest the event is delivered to the event gate step in figure .
the event gate is responsible for abstracting low level events into higher level ones and to notify the analysis tool if the latter has requested to do so step .
on startup the analysis tool requests the framework to be noti ed of certain events not shown in the gure .
the tool can use the api provided by framework to query extra information about the event e.g.
the content of the stack location storing one of the arguments of a function .
since the tool is isolated from the framework api functions are invoked through software interrupts.
thus requests coming from the analysis tool are received by the trap gate step then forwarded to the component implementing the api step .
the tool can perform two types of api calls step 4a to inspect or manipulate the state of the guest and step 4b to control event noti cations e.g.
enable or disable the noti cation of certain events .
note that the component implementing the api is also used by the framework itself step to recover extra information about events e.g.
the return address of a function stored in the stack .
the trap gate also serves the purpose of detecting exceptions e.g.
page faults that might occur during the execution of the analysis tool.
if the trap gate intercepts an exception step it terminates the faulty tool and unloads the framework to resume the normal operation mode of the system.
finally the trap gate is also used to handle timer interrupts step that as will be discussed in section .
are employed to enforce a time bound on the execution of the tool.
the functionalities provided by the api of the framework can be classi ed into two classes execution and i o tracing and state inspection and manipulation .
the following paragraphs describe brie y the api.
more details are given in sections .
and .
.
execution and i o tracing facilities allow a tool to intercept the occurrence in the analyzed system of certain events and certain i o operations respectively.
table reports the main types of events that can be traced.
for each event the table also reports the arguments associated to the event arguments are information about the events most commonly used in tools.
for example the events functionentry and syscallentry are used to trace functions and system calls respectively.
the arguments associated to the functionentryevent are the address or the name of the function called the caller and the return address.
another example is the processswitch event that can be used to trace context switches between processes not threads .
from the point of view of the analysis tool all the events are handled in the same way the tool can subscribe to any event and when the event occurs can inspect its arguments and take the proper actions.
however at the framework level certain events are di erent from other ones.
indeed some of them e.g.
context switches between processes can be traced directly by the hardware.
that is the event triggering the exit corresponds exactly to the event being traced.
other events instead e.g.
function calls and returns cannot be traced directly by the hardware.
in all these cases the framework relies on other low level events to trace the execution and then abstract exiting low level events into higher level ones meaningful for the analysis tool.
arguments can optionally be used as conditions to limit 420event description arguments processswitch context process switch exception execution exception vector faulty instruction error code interrupt hardware or software interrupt interrupt vector requesting instruction breakpointhit execution breakpoint breakpoint address watchpointhit watchpoint on data read write watchpoint address access type hitting instruction functionentry function call function name address caller return address functionexit return from function function name address return address syscallentry system call invocation system call number caller return address syscallexit return from system call system call number return address iooperationport i o operation throught hardware port port number access type iooperationmmap memory mapped i o operation memory address access type table events traceable using our framework and corresponding arguments the argument that represents the current process is omitted as it is common to all the events the tracing to a subset of all the events.
conditions on events serve two purposes.
first conditions allow to simplify the analysis tools since events that do not match the requested conditions are discarded by the framework and thus do not need to be handled by the tool.
second some conditions allow preemptive ltering of the events.
in other words the framework con gures a priori which events trigger an exit instead of ltering out exits caused by uninteresting events.
for example in the case of the iooperationport event preemptive ltering means to con gure the cpu such that only i o operations involving a speci c i o port trigger an exit.
this feature is very important to minimize the number of exits and thus the overall overhead.
state inspection and manipulation primitives can be used by the tool to access the state of the guest in order to extract more detailed information about events or other data useful for the analysis.
for example these primitives allow to extract the arguments of an invoked function or to inspect the internal structures of the guest operating system.
note that by default write access to guest state is not granted to a tool.
if necessary such permission can be enabled at compile time.
obviously in this case the framework cannot protect the state of the guest from dangerous modi cations.
.
framework and analysis tool loading the framework and the analysis tool are loaded by a minimal kernel driver.
this is unavoidable since the operations we need to perform to load the framework require maximum privileges and can be performed only by the kernel of the operating system.
the driver however is indeed very simple and we put extreme care in avoiding any interference with the kernel.
moreover since once loaded the framework is completely invisible to the system we unload the driver immediately as soon as the framework has been installed.
when vmx modes are enabled a special vmx data structure vmcs in intel terminology is made accessible initially to the loader and subsequently when the loading is completed only to the framework.
this data structure stores the host state guest state and the execution control elds .
the host state stores the state of the processor that is loaded on exits to root mode and consists of the state of all the registers of the cpu except for general purpose registers .
similarly the guest state stores the state of the processor that is loaded on entries to non root mode.
the guest state is updated automatically at every exit such that the subsequent entry to non root mode will resume the execution from the same point.
the execution control elds allow a ne grained speci cation of which events should trigger an exit to root mode.
the task of the loader is to enable vmx modes and to con gure the vmx data structure such that the execution of the operating system and user space applications continue to run in non root mode while the framework and the analysis tool are executed in root mode.
moreover the loader has to con gure the cpu such that all the events necessary for the tool to trace the execution of the system trigger exits to root mode.
when the initialization is completed the driver unloads itself and resumes the execution of the system.
.
.
guest state configuration the guest state is initialized to the current state of the system.
in this way when the virtual machine is launched and execution enters non root mode the guest operating system will resume its execution as if nothing happened.
a tricky problem when initializing non root mode concerns the management of the memory.
more precisely we must prevent the newly created guest to use and access the physical memory frames allocated to the framework and to the tool.
otherwise the guest could detect and even corrupt the framework.
most recent cpus provide hardware facilities for memory virtualization e.g.
intel extended page table extension .
if these facilities are not available memory virtualization must be implemented entirely via software.
brie y software memory virtualization consists of intercepting all guest operations to manipulate the page table the data structure the cpu uses for virtual to physical address translation and in ensuring that none of the physical frames allocated to the framework and to the analysis tool are mapped into the guest.
in case the guest tries to map a reserved physical frame the framework assigns the guest a di erent one and masquerades the di erence.
.
.
host state configuration the host state is initialized as follows.
the cpu is con gured to use when in root mode a dedicated address space and a dedicated interrupt descriptor table idt .
this conguration simpli es the separation of the analyzed system from the framework and allows to detect and handle interrupts and exceptions that occur in root mode.
di erently from the address of the entry point of non root mode which is updated at every exit to allow to resume execution of the guest from where it was interrupted the address of the entry point of root mode is xed.
the entry point is set to the address of the routine that takes care of dispatching an exit event to the appropriate handler and that in turn 421event exit causenative exit processswitch change of page table addressp exception exceptionp interrupt interruptp breakpointhit debug except.
page fault except.
watchpointhit page fault except.
functionentry breakpoint on function entry point functionexit breakpoint on return address syscallentry breakpoint on syscall entry point syscallexit breakpoint on return address iooperationport port read writep iooperationmmap watchpoint on device memory table techniques for tracing events might notify the analysis tool i.e.
the entry point of the event gate .
.
.
execution control fields configuration to reduce the run time overhead su ered by the guest system the execution control elds are con gured to minimize the number of events that trigger an exit to root mode.
when the tool is initialized it speci es which events must be intercepted.
subsequently in response to the invocation of api functions the con guration of the execution control elds can be altered to intercept additional events or to ignore other ones.
.
execution tracing table describes the technique used to trace all the events currently supported by the framework.
low level events those with a mark in the last column correspond directly to exits to root mode e.g.
exception .
other events are traced through the aforementioned ones e.g.
breakpointhit and others again are traced through the latter e.g.
functionentry .
events that can be traced directly through the hardware are process switches exceptions interrupts and port based i o operations.
all these events exit conditionally they exit to root mode only when requested and can have optional exit conditions to limit exits to particular situations.
the remaining of this section presents how we developed the primitives for tracing higher level events starting from the aforementioned low level ones.
breakpoints and watchpoints are two of the most complicated events to implement.
modern cpus provide hardware facilities to realize e cient and transparent breakpoints and watchpoints.
unfortunately hardware assisted breakpoints and watchpoints are limited in number only and shared between non root and root mode.
therefore they cannot be used simultaneously by the analyzed system and by the framework.
the solution we adopt to allow an arbitrary number of breakpoints is to use software breakpoints .
a software breakpoint is a one byte instruction that triggers a breakpoint exception when executed.
software breakpoints are enabled by replacing the byte at the address on which we want the breakpoint with the aforementioned instruction.
when the breakpoint is hit the original byte is restored and the event is noti ed to the tool.
if the breakpoint is not persistent the execution of the system is resumed.
otherwise the instruction is emulated and then the breakpoint is set again.
clearly this approach to breakpoints is not transparent for the analyzed system.
however it is very e cient.
an alternative and transparent approach is to use the sametechnique we use for watchpoints as described in the next paragraph.
our framework supports both approaches.
the approach used in our framework to implement software watchpoints is based on protecting the memory locations from any access via hardware or just from write accesses depending on the type of watchpoint such that any access results in an exception .
more precisely since the nest level of protection o ered by the hardware is at the page level we mark the page containing the address on which we want to set the watchpoint as non present .
any future access to this page will result in a page fault exception that will be intercepted by our framework.
the framework analyzes the exception and checks whether the accessed address corresponds to the address with the watchpoint.
if the watchpoint is hit the framework delivers the event to the analysis tool otherwise it emulates the instruction and then resumes the normal execution of the guest.
emulation is necessary to execute the faulty instruction manually.
indeed to prevent a second fault the original permission of the memory page accessed by the instruction must be restored before executing the faulty instruction.
after the execution of the instruction the page must be marked again as non present to catch future accesses.
other higher level events such as function and system call entries and exits are traced through breakpoints.
when the analysis tool requests the framework to monitor a certain function the framework sets a breakpoint on the address of the entry point of the function.
later when a breakpoint is hit the framework checks whether the hit breakpoint corresponds to a function entry point and if so it delivers the appropriate event i.e.
functionentry to the analysis tool.
function exits instead are traced by setting a breakpoint on the return address.
the framework discovers the return address by setting a breakpoint on the function entry and by inspecting the stack frame of the function when the breakpoint on the entry point is hit.
a similar approach is used for tracing system calls entries and exits.
the approach for tracing function calls and returns just described allows to trace speci c functions whose names or addresses are supplied by the tool.
the tracing of all function calls and returns is instead more complicated because it is not possible to know a priori the addresses of all functions entry points.
the solution in this case is to perform a static analysis to identify the addresses of all functions entry points e.g.
by recognizing function prologues .
this feature is still not available in our current implementation of the framework.
nevertheless if needed the static analysis could be performed directly in the tool.
the tracing of all system calls is instead much easier since they are all invoked through a common gate.
the solution we adopt is to put a breakpoint on the entry point of the system call gate .
beside execution tracing facilities the framework also exposes to analysis tools the possibility of intercepting i o operations with hardware peripherals.
software can interact with hardware devices through hardware i o ports or it can leverage memory mapped i o. in the rst case vmx allows to intercept the operation without any e ort the framework simply con gures the execution control elds such that all the interactions with the speci c hardware ports trigger an exit to root mode when such an exit occurs the framework noti es the tool by means of a iooperationport event.
however for performance reasons modern peripherals typically resort to memory mapped i o. in this case read and 422write operations do not involve any hardware port as they are performed directly on memory.
to intercept such operations we set a watchpoint on the appropriate memory region.
thus when an access to memory region being watched is detected the framework delivers a iooperationmmap event to the tool.
.
state inspection and manipulation several situations require to access the state of the guest system in order to inspect and optionally manipulate both the registers of the cpu and the memory.
as an example the framework could need to read the return address of a function from the stack to access the parameters of a system call from the processor registers or to insert a breakpoint into the address space of a particular process.
similarly the analysis tool might need to extract data from the memory of the guest.
the inspection and manipulation of cpu registers is a straightforward activity.
these information are saved during an exit and restored before an entry.
thus the inspection and manipulation of registers merely consists of reading or writing the vmx guest state or the memory of the framework depending on the type of register .
inspection and manipulation of memory locations is much more complex.
when paging is enabled virtual addresses are translated by the hardware into physical addresses according to the content of the page table and direct physical addressing is not possible.
each process has its own page table therefore di erent processes have di erent virtual tophysical mappings and a process cannot access the memory of the others.
the framework is isolated from the guest using the same approach and thus it has its own page table and its own mapping.
consequently the framework cannot directly access memory locations of guest processes.
moreover inspection is complicated by the fact that page tables cannot be traversed via software but only via hardware the page table is a multilevel table and pointers to lower levels are physical.
to overcome this problem we have developed a speci c os independent algorithm that allows to access an arbitrary virtual memory location of an arbitrary process.
the core of the algorithm is a primitive that allows to access arbitrary physical memory locations.
this is accomplished by mapping a given physical address pto an unused virtual address vin the page table of the framework and subsequently by accessing v. then using this primitive the algorithm can traverse the page table of a process of the guest via software by iteratively mapping the physical addresses stored in the table.
the framework exposes memory inspection and manipulation facilities based on the aforementioned algorithm to the analysis tools through two api functions guestread p a n and guestwrite p a data .
the former reads nbytes starting from virtual address aof process p the latter writes the content of bu er data into the address space of process p starting from virtual address a. by default to preserve the integrity of the guest all guestwrite operations are forbidden.
on top of this functions we have built higher level ones that facilitates the extraction of functions arguments null terminated strings and to disassemble code.
.
tool isolation to be able to use our infrastructure on a production system it is essential to guarantee that any defect in the anal ysis tool will not a ect the stability of the analyzed system and of the framework.
at this aim the framework controls the execution of the analysis tool and if any anomalous behavior is observed the whole infrastructure is automatically unloaded.
as we outlined at the beginning of this section even if the analysis tool is executed in vmx root mode it is still constrained into a less privileged execution mode than the framework.
thus any operation the tool performs on the guest must be mediated by the framework.
this is exactly what happens in traditional operating systems a user mode process cannot access directly the resources of the operating system nor those of other user mode processes and any action it performs outside its address space must be mediated by the kernel.
similarly in our context to perform an operation on the guest system the tool must use the programming interface o ered by the framework.
in the default con guration the framework does not allow a tool to access in write mode to the state of the guest.
however there is still the possibility that the execution of an instruction of the tool raises an unexpected exception e.g.
a page fault on memory access or a general protection fault .
when such an event occurs the framework has no way to handle the anomalous situation and to allow the tool to continue its execution.
the only viable approach that also preserves the integrity of the guest system is to terminate the analysis tool and to remove the framework.
at this aim the solution we adopt is to intercept unexpected exceptions through the custom interrupt descriptor table idt installed when launching vmx modes.
the idt receives the trap and delivers it to the trap gate that eventually unloads the framework.
another problem that might arise with a buggy analysis tool is non termination if the analysis tool entered an in nite loop the guest system would never be resumed.
to prevent this problem we added to the framework a minimalistic watchdog and set a time limit on the execution of the tool.
the limit is not on the whole execution time of the tool but rather on the execution time to handle an event.
thus the analysis tool could potentially be run forever but with the guarantee that the execution of the analyzed system will be resumed within the speci ed time limit.
at this aim before delivering an event to the analysis tool the framework resets a timer.
then while the tool handles the event the framework periodically regains the control of the execution and checks whether the time limit has been exceeded.
to do that the framework registers in the idt a custom interrupt handler to handle timer interrupts and programs the interrupt controller to deliver only timer interrupts that is necessary to prevent the framework to consume interrupts for all the other devices .
before returning to non root mode the framework reprograms the interrupt controller to deliver all the interrupts to the analyzed system.
.
os dependent interface our framework provides a general programming interface completely independent from the operating system running inside the guest.
however in many cases some os speci c facilities can ease the analysis of the guest.
as an example the only os independent manner to identify a process is by means of the base address of its page table typically stored inside the cr3cpu register .
however it is quite awkward to refer to processes using page table base addresses and it 423name description getfuncaddr n return the address of the function n getfuncname a return the name of the function at address a getprocname p get the name of process with page directory base address p getprocpid p get the pid of process with page directory base address p getproclibs p enumerate the dynamically linked libraries loaded into process p getprocstack p get the stack base for process p getprocheap p get the heap base for process p getproclist enumerate processes getdriverlist enumerate device drivers table os dependent api is more natural to identify a process through its process id pid or through the name of the application it executes.
the os dependent interface we provide leverages virtual machine introspection techniques to analyze the internal structures of the guest operating system to translate os independent information e.g.
process with page table base address 0x13cdc000 into something more user friendly e.g.
process notepad.exe .
moreover using debugging symbols the framework allows to resolve symbols names and addresses e.g.
functions and global variables .
in this way a tool can ask to interrupt the execution of the guest when function ntcreatefile is invoked instead of referencing the function through its address.
similarly when a function is invoked it is possible to inspect its call stack and to resolve the name of the caller functions and even to recover the libraries to which the various functions belong to.
some of the os dependent functionalities provided are summarized in table .
in case the guest operating system is not supported the os dependent module is disabled and only os independent functionalities are available.
our current implementation o ers an os dependent interface only for the windows xp operating system.
.
applications in this section we present hyperdbg an interactive kernel debugger for microsoft windows xp we built on top of our framework.
in our strive to contribute to the open source community we released the code of hyperdbg along with the code of the framework under the gpl v3.
license.
the code is available at the following address the section also discusses other possible applications that could be constructed using our framework.
.
hyperdbg hyperdbg is an interactive kernel debugger we developed on top of our analysis framework.
it o ers all the features commonly found in kernel level debuggers but being completely run in vmx root mode it is os independent and grants complete transparency to the guest operating system and its applications.
the debugger provides a simple graphical user interface to ease the interaction with the user.
this interface is activated in two circumstances i when the user presses a special hot key or ii when the debugger receives the noti cation for an event that requires the attention of the user e.g.
when a breakpoint is hit .
from this interface figure hyperdbg in action the user interacts with the debugger and can perform several operations including setting breakpoints and watchpoints tracing functions and system calls and inspecting and manipulating the state of the guest since all interactive debuggers allow to modify the state of the debuggee we decided to enable write access to the guest as well .
figure shows hyperdbg in action2.
in particular the gure shows the debugger notifying the event that interrupted the execution of the analyzed system displaying a fragment of the code of the process currently running in the analyzed system and displaying a backtrace of the function calls that are currently active.
additionally the debugger displays information about the status of the registers at the time the event occurred in the case of the gure the event is the pressure of the hot key .
to facilitate the analysis the debugger leverages os dependent information.
for example the screenshot in figure shows that the debugger resolved the id and the name of the process in a ms windows xp guest by knowing how the process table is managed by the operating system.
it is worth pointing out that hyperdbg can be used to debug anypiece of code of the guest system including critical components such as the process scheduler or interrupt and exception handlers.
indeed figure shows that the guest operating system has been stopped while executing the ps keyboard mouse driver i8042prt.sys .
thanks to the fact that the framework on which the debugger is built on is completely transparent to the analyzed system the user can use the keyboard to interact with the debugger even though the keyboard driver of the guest is being debugged.
hyperdbg consists of less than lines of code of the code implements the graphical interface of the code provides the facilities required for keyboard based user interaction and the remaining is responsible for handling events and for all the other interactions with the framework.
note that certain functionalities e.g.
disassembling a code region are implemented directly in the framework since most likely they will be used for other types of 2the screenshot was taken using our development environment based on an intel x86 emulator supporting extensions for virtualization i.e.
bochs .
424analysis as well.
the framework is about four times bigger than the debugger without considering the disassembly module embedded in the framework as it is based on an o the shelf disassembler .
we believe these numbers are very signi cant.
the number of lines of code we had to write to implement hyperdbg clearly witnesses that complex analysis tools like an interactive kernel debugger are straightforward to implement using our framework.
the remaining of this section describes how we used the facilities of the framework to implement the user interface and the component to receive commands from the user.
.
.
user interface although the graphical user interface of the debugger is rough its implementation is very challenging.
the reason of the complexity is the fact that we cannot rely on any high level graphical facility available in the analyzed system to render the interface.
such approach would be too osdependent and not transparent at all.
the lack of graphical primitives obliged us to interact directly with the video card.
the video memory is mapped at a xed address in the guest and thus unmodi ed inspection and manipulation api i.e.
guestread and guestwrite can be used by the debugger to render the interface.
note that this approach is not dependent on the os nor on the hardware.
we developed a small video library that provides basic graphical functionalities and translates our requests into data that are written directly in the memory of the video card.
before rendering the graphical interface to the screen the debugger backups the content of the video memory and restores the content right before resuming the execution of the analyzed system.
.
.
user interaction user interaction is keyboard based.
when in non root mode the user can switch into hyperdbg by pressing a hot key.
then in root mode the user can control the debugger.
for these reasons hyperdbg must be able to intercept keystrokes both in root and non root mode.
to intercept keystrokes in non root mode we monitor all the read operations from the hardware i o port devoted to the keyboard.
in other words hyperdbg registers to the core for all the iooperationport events that satisfy the event condition port keyboard port access read .
when such operation is detected hyperdbg checks whether the key pressed corresponds to the hot key that enables the debugger.
if the key pressed matches the hot key the debugger pops up the graphical interface and waits for commands.
otherwise the debugger passes the keystroke to the analyzed system such that the latter will continue its execution as if the keystroke were read directly from the keyboard.
keyboard handling in root mode is done by polling the keyboard hardware i o port.
since direct access to i o ports is not permitted to any analysis tool the debugger relies on a api function exported by the framework which mediates all accesses to i o ports and allows if the permission is granted at compile time certain analysis tools to read data from certain i o ports.
.
future work hyperdbg demonstrates that our framework is very versatile and that enables new opportunities for dynamic analysis that we will explore in our future research.
an interesting extension of hyperdbg will be the sup port for kernel level omniscent debugging.
omniscent debugging allows developers to inspect the status of their programs in past execution instants in order to detect the cause of a failure without the need to run the target program multiple times .
hyperdbg could be extended to allow a user to record and inspect the values a memory location stored during the time and the exceptions and interrupts occurred.
such a feature would ease a user to discover when a memory location of the kernel gets corrupted and which instruction is responsible for the corruption.
moreover the ability to log asynchronous events such as interrupts would allow to spot defects connected to non deterministic behaviors of the analyzed system.
our framework already o ers all the necessary facilities for this kind of debugging exception and interrupts can be traced natively by the framework and memory accesses can be traced using watchpoints.
another interesting application of our framework will be dynamic aspect oriented programming of operating system kernels.
as discussed in section several approaches have been proposed to apply aop to kernels.
the main advantage o ered by our framework over the approaches proposed so far is that it does not require any modi cation of the source code of the kernel nor any modi cation of the image in memory of the kernel.
moreover our framework protects the running kernel from defects in the woven code.
one approach to facilitate the use of such technology would be to provide programmers a source to source translator to translate aspect oriented code written in languages like aspectc into c code that uses the api o ered by our framework.
in particular the translator would be responsible for translating pointcuts into api calls to trace the corresponding events using advices as events handlers and for translating all pointer dereferences into calls to inspection api to read the memory of the guest.
.
conclusions we proposed a framework to perform complex run time analyses of both system and user level code on commodity production systems.
the framework exposes an api that eases the development of analysis tools on its top.
the approach we described leverages hardware extensions for virtualization available on modern processors to overcome the limitations that a ect existing approaches for the analysis of system level code.
in particular the solution we proposed does not require to recompile or reboot the target system it is not invasive it is almost completely os independent and it guarantees that a defect in an analysis tool cannot damage the framework itself nor the analyzed system.
to demonstrate its potentials we developed hyperdbg an interactive kernel level debugger for microsoft windows xp.
hyperdbg and the framework have been released as an open source package.