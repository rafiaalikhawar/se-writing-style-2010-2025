staticdetectionof resourcecontentionproblemsin server sidescripts yunhui zheng xiangyu zhang department of computer science purdue university zheng16 xyzhang cs.purdue.edu abstract with modern multi core architectures web applications are usually configured to serve multiple request s simultaneouslybyspawningmultipleinstances.theseinst ances may access the same external resources such as database tabl es and files.
such contentions may become severe during peak time leading to violations of atomic business logic.
in thi s paper we propose a novel static analysis that detects atomi city violations of external operations for server side scripts.
the analysis differs from traditional atomicity violation det ection techniques by focusing on external resources instead of sha red memory.
it consists of three components.
the first one is an interprocedural and path sensitive resource identity ana lysis that determines whether multiple operations access the sam e external resource which is critical to identifying conten tions.
the second component infers pairs of external operations th at should be executed atomically.
finally violations are det ected by reasoning about serializability of interleaved atomic p airs.
experimental results show that the analysis is highly effec tive in detecting atomicity violations in real world web apps.
keywords php resource contention static analysis constraint solving i. introduction web is becoming an important computation platform.
many daily tasks such as online shopping social networking data storage and document processing are carried out by web applications apps .
an important trend of web apps is to leverage modern multi many core architectures .
however the incompatibility between the sequential programming model of server side scripts and the concurrent execution model configured in servers to leverage multiple coresmay lead to harmfulcontentionson externalresources .
particularly for design simplicity popular server side scripting languages such as php do not support threading.
as a result web app developers tend to think that they are performing sequential programming and they are at a safe distance from troubles caused by concurrency.
however it is not true under the most popular lamp linux apache mysql and php web app environment in which apache is the web server and server side scripting support is provided through php.
php scripts communicate with a database system e.g.
mysql or the file system to provide services.
to optimize server performance apache is usuall y configured to run in the mpm multi processing modules mode which allowsmultipleinstancesof a serverside scrip t being spawned each serving an independent client request.
although these instances do not share variables in memoryas variables are by default local to a thread they do share external resources such as database tables and files.
such sharings nonetheless cause race conditions.
many web application failures are essentially due to such race conditions.
for example in productcart and opencart they led to products being over sold resulti ng in back orders.
in drupal and joolam bibtex they caused critical runtime exceptions and file corruptions.
unfortunately there are mis perceptions that induce developers to overlook such problems.
one of such is that race conditions on external resources are well guarded by the internal protection in the database engine and the file system otherwise any regular sequential programs would be vulnerable as multiple instances of the same program may share the same resources.
the observation is that while it is unlikely that multiple instances of a regular sequenti al program are running simultaneously the likelihood is much higher for a web app as it aims to deliver the same service to many users.
in other words we argue that the problem is substantially exacerbated in the context of web apps.
existing solutions for detecting concurrency errors fall short.
most race detection and atomicity violation detection technique s rely on analyzing synchronization primitives.
however suc h primitives are simply not provided by server side scripting languages.
most existing techniques work by reasoning about the interleavings of accesses from different threads on shared memory.
however scripts usually do not share memory.
sharing is on external resources instead.
to reason about the effect of interleaving external resource accesse s one needs to model these external operations e.g.
queries to the database engine.
furthermore these operationscann ot be simply modeled as reads or writes on shared objects.
for example the delete and insert database queries have more complex semantics that cannot be described as simple reads writes.
identifying the resources being accessed al so poses a unique challenge as they are usually denoted in the program as concatenations of strings and variables.
one has to reason about the equivalence of such representations to determine if the same resources are being accessed.
there has been some recent work specifically focusing on concurrency errors in web apps.
in researchers proposed a technique to detect race conditions caused by the asynchronous ajax requests.
the technique is unfortu nately not applicable as it only works on client side through javascript and does not reason about external resources.
a dynamic analysis was proposed to detect race conditions caused by interactions between a web app and the database .
it collects sql query traces and checks whether a specific interleaving pattern occurs in traces.
it demands a proper input and a proper interleaving to expose a bug which are in general hard to acquire due to non determinism.
the technique also completely neglect s program semantics leading to false positives.
inthispaper weproposeawholeprograminterprocedural static analysis that detects atomicity violations regardi ng external resources in php scripts.
the overview of our technique is presented in fig.
.
it takes the php code of a web app and translates it to c. the c code is analyzed in three phases.
the first phase is the resource identity analys is that determineswhether multiple operationsaccess the sam e externalresource whichiscriticaltoidentifyingconten tions.
the second phase infers pairs of external operations that should be executed atomically.
in phase three violations are detected by reasoning about serializability of interle aved atomic pairs.
we make the following contributions.
we develop a context and path sensitive interprocedural static analysis to automatically detect atomicity violations on shared external resources in php code.
we develop the resource identity analysis a technique toreasonabouttheequalityofresourcesbeingaccessed by external operations.
it is interprocedural and path sensitive leveraging a smt solver.
we propose a novel way of statically inferring atomic regions in php code which avoids demanding the developer to annotate such regions or guessing them fromsynchronizationprimitivesordynamictraces .
it leverages the observation that atomicity properties in php programs are more amenable for automatic inference compared to general concurrent programs in c and java as php developers usually follow a sequential programming paradigm.
we develop expressive abstractions for external operations.
they go beyond the read and write abstractions for shared memory accesses.
we define atomicity violations based on these abstractions.
we evaluate the technique on real world web apps.
the results show that it is highly effective detecting real bugs.
some of them have financial impacts.
ii.
motivating examples a. atomicity violation in opencart .
.
.
we first use a bug in a recent version of opencart v1.
.
.
to motivate our technique.
opencart is an open source shopping cart application.
it was reviewed as one of the best open source e commerce platforms in .
a user of opencart can be either a normal user or an catalog controller checkout confirm.php public function index tmp coupon this session data coupon getcoupon tmp coupon if coupon data coupon else data this session data create dat a catalog model checkout coupon.php public function getcoupon coupon coupon query mysql query select from coupon c ... where ... c.code .
coupon .
and ... x coupon query row sql select count as total from order where... .
coupon id .
x coupon redeem query mysql query sql total coupon redeem query row coupon validation if ... total allowed coupon data coupon query return coupon data catalog model checkout order.php public function create data create an order using a valid coupon y data sql insert into order set...coupon id .
y... 3mysql query sql figure .
code snippet from opencart v1.
.
.
.
the two recta ngled database queries may not execute atomically while they shou ld.
the update query is transitively dependent on the select query throu gh the underlined variables.
for readability we normalize the code snippet b y breaking some statements into sub statements described by the subscrip ts.
administrator.
the administrator can add modify or delete products and coupons.
a normal user can place orders with the option of applying coupons.
the problem to be demonstrated allows illegal coupon usage.
in particular when multiple usersplace ordersconcurrently whichis ver y likely to happen in peak time a coupon can be applied for arbitrary number of times ignoring its use limit.
fig.
shows the relevant code snippet.
function index inconfirm.php validates a coupon by calling getcoupon at line201and then places the order by calling create .
incoupon.php function getcoupon dispatches two queries at lines and .
the first query is to retrieve the coupon information from database.
the second query is to determine the number of coupon uses by accessing tableorder.
if the coupon has reached its limit variable coupondataholds the falsevalue at line which is returned to method index indicating expiration of the coupon.
otherwise the coupon details such as discount are loaded to coupondataand returned.
finally at line in functioncreate inorder.php anorderisplacedbyinserting a record to table order with the same coupon id.
the bug manifests itself when multiple users apply the same coupon in the mean time.
to simplify discussion static atomic property inference serialibility analysis resource identity analysis operations on the same resource php code atomic pairs php to c c code violations figure .
overview of our technique.
order request 1handler .
sql select ... .
coupon redeem query mysql sql total coupon redeem query row total ...... .
if ... total allowed allowed coupon valid .
coupon data coupon query ...... .
sql insert... .
3mysql query sql order request 2handler .
sql select ... .
coupon redeem query mysql sql total coupon redeem query row total ...... .
if ... total allowed allowed coupon valid .
coupon data coupon query ...... .
sql insert... .
3mysql query sql figure .
the buggy interleaving for the opencart example.
s ymbol .
means line in the 1st thread.
suppose there are two concurrent order requests with the same coupon that is supposed to be redeemed only once.
they can be processed concurrently by two threads on two respective cpus leading to arbitrary interleaving of the entailed database operations.
fig.
shows a failure induci ng interleaving in which the coupon usage selection query of theseconduser line2.
happensinbetweentheselectio n query line .
and the order insertion query line .
of the first user.
as a result both users observe a valid coupon and are allowed to apply the coupon.
opencart has alsoothersimilarbugs leadingtovariousundesirableeff ects such as products being over ordered.
although the essence of such bugs is typical atomicity violation static detection of such violations for web appl ications is challenging due to the following reasons.
compared to traditional atomicity violations which are caused by shared memory accesses not being sufficiently protected web app atomicity violations have different characteristics.
they usually don t involve sharedmemory but ratherexternalresources.php does not have any build in synchronization primitives either.
to reason about external resources we have to model the semantics of the operations on these resources as part of the php program.
some apps leverage external synchronizations e.g.
database transactions which need to be properly modeled in the analysis too.
the operations involved in an atomicity violation have to access the same external resource.
otherwise there are no real contentions.
however determining if multiple operations access the same resource is highly challenging.
consider the opencart example.
we need to determine that the select query at line 132and the insert query at line 702access the same tuples so that a concurrent execution of the select query may observe a stale value aboutthe same coupon .it requiresproving thatxat132is equivalent to yat702 demanding a non trivial interprocedural analysis.
a necessary condition for the technique is the availability of atomic region definitions as violations are include transfer.php function download url outputfile fh fopen url rb ofh fopen outputfile wb failed false while !
feof fh !
failed buf fread fh if fwrite ofh buf !
strlen buf failed true break fclose ofh fclose fh figure .
code snippet from extplorer file manager v2.
.
r c3 identified by reasoning about serializability of these regions.
there are often a lot of operations accessing the same external resources and only some of them need to be atomic.
traditional ways to defining atomic regions include user annotations leveraging existing critical sections e.g.
regions delimited by lock acquisitions and their correspondingreleases and inference from dynamic runs .
however none of these solutions are applicable in our context.
furthermore atomic regions in web apps may not be lexical i.e.
they do not form a lexical region such as a branch or a block of straight line code .
in many cases the operations that ought to execute atomically distribute in different functions.
for example in fig.
atomicity is present in the two rectangled sql queries that are in differentfunctionsand the region i.e.
the path between them is non lexical.
the goal of our work is to develop a static analysis that overcomes the aforementioned challenges.
b. atomicity violation in extplorer file manager besides databases file system is another external shared resource that can suffer from similar problems.
next we use the popular extplorer file manager v2.
.
rc3 web app to explain the atomicity violation problem in file system.
extplorer is a php based file management system.
according to the stats of sourceforge extplorer has been downloaded for more than times since its initial release in july .the versionwe use is the latest release .
its ui is similar to that of a pc file manager.
after logging in the user can create browse edit upload download and archive files.
while operations are executed on the server via server side scripts the user controls through a webbased interface on the client side.
some operations may entail downloading files from other remote servers to the local server.
fig.
shows a code snippet from extplorer in which functiondownload is used to download files from other remote servers.
it takes two parameters the address of thesource file urland the local path on the local server outputfile to savethedownloadedfile.at line it firstly reads from a remote server to a local buffer and then writes the buffer to the local path at line .
the read and write are inside a while loop.
depending on the size of the file fwrite may be invoked several times.
since a file is incrementally written in the loop between invocationsto fwrite in consecutiveiterations a concurrent fwrite to the same file througha differentuserrequestmay happen corrupting the file.
detecting such file system related atomicity violations requires addressing the same set of challenges as for database related violations.
iii.
resource identity analysis in order to reason about atomicity violations regarding external resources we have to determine if multiple operations are accessing the same external resource.
we develop aresource identity analysis for this purpose.
the analysis encodes the semantics of external operations into bit vect or logic constraints.
these constraints together with those generated from the regular php statements are resolved by a smt solver to determine if two given operations are accessing the same external resource.
we will focus on analyzing database operations which is more challenging than analyzing file system operations.
a. analyzing database queries we assume that all sql queries in a program have their keywords table names and tuple field names as constants1.
we preprocess the program to its ssa form so that one variable represents one value in the rules in this section.
moreover we preprocess the program by introducing dummy variables to represent non keyword constant strings and values.
this is to simplify the descriptionof the analys is as we don t need to distinguish cases operating on constants from those operating on variables.
modeling simple queries.
we first discuss select queries that retrieve a set of tuple fields from a single table with a where clause.
such a select query is modeled as a set of conditional assignments of tuple fields to the result data structure.
the assignments are guarded by the conditions described by the where clause.
r lmysqlquery select f1 ... fnfromtwhere .
c t c tuple l t r.f1 t.f1 ... r.fn t.fn logicalandtext t c tuple l negationslash t select c1.
and .
c2 t t c1 t c2 cond and c1.
or .
c2 t t c1 t c2 cond or f .
x t t.f x clause 1in our experience dynamic table column names are not commo n. for example opencart has data tables all static and que ry strings with only using a variable as the column name.the above rule select presents the encoding.
rules cond and cond or and clause describe the where clause encoding.
we use .
to denote string concatenation.
program statements are on the left and the corresponding encodings are on the right.
the arrow in the middlelabeledwith representsthetransformation whichis sometimes also denoted as a function with an optional superscript representing its context.
for example symbol trepresents that the transformation is in the context of abstract tuple t. we introducean abstract tuple tto represent the tuple being selected.
observe that tis not constrained.
later we will show how to properly constrain the abstract tuple based on the information from other queries.
also while at runtime multiple concrete tuples may be retrieved we statically represent them with the same abstract tuple.
the supporting function tuple in rule select maps a program point denoted by label l to an abstract tuple.
it denotes the query at lentails reading tuple t. we support regular comparison operations in the where clause denote d by in rule clause .
mysqlqueryl insert into t f1 ... fn values .
x1.
... xn tl.f1 x1 ... tl.fn xn insert rule insert showstheencodingforaninsert query.note that we introduce an abstract tuple tlspecifically for the query at label l denoting the tuple inserted by that query.
the encoding process models an insert query as a sequence of assignments to the fields of the abstract tuple.
mysqlqueryl update tset f1 x1 ... fn xn where .
c t c tuple l t tl.f1 x1 ... tl.fn xn logicalandtext t c tuple l negationslash t update an update query at label lis encoded to conditional field assignments to tuple tl guarded by the conditions in the where clause.
since an update query entails reading tuple s we usetuple l tto denote the tuple to be read at l. note that we use differentabstract variables tandtlto denotethat the tuple has different values before and after the update.
constraining abstract tuples.
in our analysis we aim to determine if multiple operations are accessing the same shared resource.
for instance we may need to know if a tuple inserted by query at l2can be accessed by a selectquery at l1 assuming the same table and l1precedes l2 .
if so l1in a thread may contend with l2in another thread leading to atomicity violations recall the opencart examp le in section ii .
toleveragethesmtsolvertodetermineresourceidentity we constrain the abstract tuple in the select query to those in the insert update queries guarded by the where conditi on of the select query.
intuitively it means that if the tuple s added changedby the insert updatequeriessatisfy the whe re condition of the select query they may be retrieved by the select query and thus the two queries access the same tuple.
it is possible that multiple inserted updated abstr acttuples satisfy the where condition in the select query.
in such a case the retrieved tuple can be any of them without assuming any specific order.
without losing generality we assume there are writequeries i.e.
insert or update queries to the same table tin the program at labels l1andl2.
the revised encoding rule fora select query select x to tis presentedas follows.
r lmysqlquery select f1 ... fnfromtwhere .
c f1 f2 fboth fneither select x f1 tl1 c tl2 c tuple l tl1 r.f1 tl1.f1 ... r.fn tl1.fn f2 tl1 c tl2 c tuple l tl2 r.f1 tl2.f1 ... r.fn tl2.fn fboth tl1 c tl2 c tuple l tl1 r.f1 tl1.f1 ... r.fn tl1.fn logicalortext tuple l tl2 r.f1 tl2.f1 ... r.fn tl2.fn fneither tl1 c tl2 c tuple l negationslash tl1 tuple l negationslash tl2 the revised encoding of a select query is the conjunction of four clauses f1 f2 fboth andfneither.f1constrains the selected tuple with the tuple at l1but not the one at l2.f2 is the opposite.
fbothdescribes that if both tuples at l1and l2satisfy the where condition the selected tuple could be either of them.
example.
consider a simple php program as follows.
it performs three queries the first two insert two tuples with the first field being and respectively and the third query selects the tuples with the first field greater than .
therefore only the tuple inserted at is selected.
mysql query insert to t f1 f2 values .
x mysql query insert to t f1 f2 values .
y r mysql query select f2 from t where f1 the corresponding encoding is as follows.
from the three formula it is easy to infer tuple t1.
t1.f1 t1.f2 x t2.f1 t2.f2 y t1.f1 t2.f1 tuple t1 r.f2 t1.f2 logicalandtext ... aggregation queries are very common in php programs.
sample aggregation queries include those acquiring the count sum averageoftuples fields.theyareusuallyaccom panied by the groupby keyword.
it is difficult to statically model values of aggregation queries.
fortunately in our context we only need to model the correlation between queries such as if an insert query affects the result of an aggregationquery whichismainlydeterminedbythewhereconditioninstead of the specific aggregationfunction.hen ce our encoding is very similar to that for regular selects and thus elided.
our technique currently does not support subqueries.
modeling php statements.
modeling queries alone is not sufficient to reason about resource identity as queries mayuse variables that are computed by regular php statements.
therefore we have to model regular php statements as part of the analysis including assignments conditionals loo ps and simple arithmetic operations.
assignment statements are encodedas simple equivalence constraints.
the encoding is field sensitive supporting definitions and uses of data structure fields.
it also models the access of a query result through keyword row.
for instance x r row f is modeled as x r.f1.
similar to all constraint solving based static analysis loops need to be unrolled to conditional statements.
i n this work we unroll the loop body twice.
it allows us to reason about the operations in consecutive iterations.
mor e unrollings are unlikely useful as it is unlikely for a resour ce identity property to manifest itself after a large number of iterations in php programs.
conditional statements are encoded from their ssa form.
the following example shows a typical ssa transformation.
1if c x e1 3else x e2ssa 11if c x1 e1 13else x2 e2 x3 c ?
x1 x2 a conditional assignment such as the one at line is further encoded to a constraint by the following rule cond assn .
x c?
y z c x y c x z cond assn condition cin the rule corresponds to the predicate in the original conditional statement.
it is also called the guard of the assignment.
our analysis is hence path sensitive as by encoding predicates we are able to leverage the solver to associate a resource identity property with a feasible path determined by finding a satisfying solution to the related guards.
our analysis is also interprocedural.
it is summary based.
at last we deliver analysis results through a primitive relationsameresource which can be queried by other analysis components.
sameresource l1 l2 program tuple l1 tl2 the meaning of the relation is that the program is accessing the same resource at program points l1andl2if the formula to the right of symbol is satisfiable.
intuitively it means that from the program encoding we can infer that the tuples accessed at l1andl2are the same.
example.
considerthe motivationexamplein fig.
.
part of the encoding is presented in table i. from the conjunction of we can infer tuple 3so that we havesameresource .
in particular the condition in i.e.
t703.couponid x can be inferred from x couponquery.couponidand the equivalence of y andcouponquery.couponid which is established from the conjunction of and .
squaretable i part of the encoding of the code snippet in fig.
.
statement encoding x coupon query.coupon id t703.coupon id x tuple coupon redeem query.total fv133 logicalandtext... total conpon redeem query.total coupon data1 coupon query total allowed coupon data2 coupon data1 total allowed coupon data2 false coupon coupon data2 data1.coupon id coupon.coupon id data2.coupon id coupon false data3 data1 coupon false data3 data2 data4 data3 y data4.coupon id t703.coupon id y fv133in is a free variable.
b. analyzing file operations determining if multiple file operations have the same subject file is relatively easier.
in this work we focus on file open read and write.
we do not consider other file operations e.g.
getting a file s path as they are less likel y to be error prone due to their nature.
the basic idea of our analysis is to use the label of a file open statement as the abstractionofthefileandthenuseconstraintsolvertoreas on about if multiple operations are on the same abstract file.
analysis results are delivered through the same primitive relationsameresource l1 l2 .
iv.
serializability analysis atomicity violation detection is a process of reasoning about serializability of operations in atomic regions.
specifically given an sequence of interleaved operations from multiple usually two atomic regions in different threads processes a violation is reported if the sequence is notserializable.hence atomicregiondefinitionsare crit ical.
in this work we do not require the developer to annotate atomic regions.
a way to addressing the lack of atomic region definitions as in is to reason about pair wise atomicity instead that is to reason about if two consecutive accesses of the same shared memory location inside a thread called local accesses should be atomic.
for example in if during training executions two consecutive local accesses are never observed to interleav e with another access from a different thread called the remote access they are considered to be atomic.
the key observation is that inferring atomic pairs is a lot more tractable than inferring an arbitrary atomic region.
in this work we adopt a similar solution by considering pair wise atomicity of external operations.
however we do not rely on dynamic runs but rather infer statically leveragingthe aforementionedresource identityanalysis and program dependences.
with such atomic pairs violations are detected by reasoning about serializability of interle avedpairs.
we will discuss how to infer atomic pairs in the next section.
in this section we assume the availability of atom ic pairs and discuss the serializability analysis.
typical serializability analysis not applicable.
in existing work it was shown that to detect pairwise atomicity violations it is sufficient to analyze seria lizability when an atomic pair of accesses are interleaved with a remote access.
because shared memory accesses are modeled as two kinds readandwrite.
there are totally possible patterns.
table ii presents some of these patterns .
forexamplein case two givenanatomic pairthat first reads r and then writes w if it interleaves with a remote read r the resulting sequence is serializable as it is equiva lent to the sequence of r r w. in contrast case one is not.
table ii determining pair wise atomicity violations for shared memory .
rdenotes read wdenotes write .local are the two local accesses involved in an atomic pair .each entry shows a pair interleaved with a remote access .
caselocal1remote local2serializable r w w no r r w yes 3w w w yes ... ... 8w w r no however such analysis is not sufficient for our purpose.
first modeling external operations to merely reads and writes is problematic.
for example intuitively we should model a file write as w. according to case 3in table ii two local file writes interleaved with a remote file write are serializable which is wrong.
consider another example .
intuitively sql selects should be modeled as r and deletes as w. in case a local select and a local delete interleaved with a remote delete on the same tuple are not serializable which is incorrect as it has the same consequence as first performing the two local operations and then the remote deletion which becomes a no op.
the reason of these problemsis that the semantics of file writes and sql deletes cannot be precisely described as low level writes.
second while all the eight patterns are possible for shared memory accesses a lot of them are rarely observed in external operations in our experience.
for instance an atomic pair with the form of wr is common for shared memory accesses.
but it may not be the case for external operations especially in php code because it is unlikely that a program first writes to a tuple file and then reads it in the same thread.
table iii categorizing external operations .
category description operations a append sql inserts file writes d delete sql deletes w write sql updates r read sql selects file reads our solution.
we propose to model external operations to four access categories as shown in table iii covering r r a w d a w a a r w a w a r w a d d a a figure .
atomicity violation patterns for external operat ions.
remote operations are superscripted.
the most common external operations.
two new categories appendanddelete are introduced.
note with the new categories theoreticallythere are many more interleaving patterns.
fortunately according to our discussion earlier most of them are not feasible in practic e. we hence only consider a small subset as listed in fig.
.
we also preclude patterns that are serializable.
the examples in fig.
and belong to the patterns r r a a and a a a respectively.
one example of pattern is that two update queries update two disjoint sets of fields of the same tuple.
a select query from a different thread is not supposed to see the partially updated tuple.
note that pattern involves four operations which are the interleaving of two da atomic pairs.
the code snippet in fig.
shows an example.
it corresponds to the coding pattern of cleaning stale data maybe multiple tuples befo re inserting a new tuple with the same key.
sequence d d a a is not serializable as two tuples will be inserted.
this pattern also discloses that reasoning about only triples t wo locals and one remote as in shared memory serializability analysis is not sufficient for external resources.
observe t hat although pattern is unserializable its sub patterns d d a and d a a are serializable.
s1 delete from book where id .
bookid .
r1 mysql query s1 update information about the book s2 insert into book values .
bookid .
.... r2 mysql query s2 figure .
example for an atomic pair involving delete and in sert queries.
v. atomicpairinference in this section we discuss how to infer atomic pairs from php programs.
considering all operations in a php thread process atomic is too simplistic to be useful.
many operations present in a program allow concurrency.
our experimental results in section vii show that naively consideringall operationson the same resourceatomic lead s to many false positives.
we propose to consider program dependence in order to infer pair wise atomicity properties.
the observation is t hat iftwoexternaloperationsarecorrelatedthroughprogramd ependences the original intention of the developer was most likely to assume such program dependences are exercised in a way identical to a sequential execution.
recall that in the opencart example in fig.
.
the insert query is transitivel y dependent on the select query as the execution of the insert query is determined by if the value of the selected total number of coupon uses has not reached the allowedlimit.
the precise dependence path is indicated in the figure by underlining the involved variables.
the assumption implie dby the dependence path is that the total number of uses should remain constant from the select query till the inser tquery that places a new order.
we consider program dependences in two different ways depending on the category of an atomic pair.
a pair of operations with the first operation being a read is consideredatomicif there is a dependencepath including both control and data dependences from the first operation to the second.
it corresponds to that the result of the first operation is used in the second operation.
the opencart example illustrates this case.
a pair of operations with neither being a read is considered atomic if both are data dependent on the same variable and there is a valid program path correlating the two operations.
intuitively it means that both operations are consuming storing the same or correlated computation results.
such a process is oftennotintendedtobeinterferedbyotherthreads.the extplorerexampleinfig.4illustratesthiscase.thefile writes in two consecutive iterations are both dependent on the creation of the output file.
another example is presented in fig.
in which the two operations are delete and insert.
both are dependent on the definition point of variable bookid.
datalog rules for atomic pair inference.
the atomic pair inference process is described as datalog rules in fig.
.
datalog uses a prolog like notation.
it provides a neat representation for whole program analysis.
data flow facts can be formulated as relations.
analysis is represented as inference rules on these relations.
relations are in the for m p x1 x2 ... xn withpbeing a predicate and x1 ... xn representing program artifacts such as labels.
a predicat e is a declarative statement on the variables.
for example datadep l1 l2 denotes that there is a data dependence path froml1tol2.
the form of an inference rule is as follows.
p b1 b2 ... b n b1 b2 ... and bnare either relations or negated relations.
the rule means that if b1 b2 ... and bnare true thenpis true.
relations can be either inferred or atoms.
in program analysis weoftenstartwithasetofatomsthatdescribebas ic facts of the program and then infer other more interesting relations.
in fig.
we assume program dependence relation dep and data dependence relation datadep as atoms.
these relations are generated through standard program analysis .
rules d1 and d2 present the rules that infer atomic pairs.
rule d1 describes the process of inferring atomic pairs with the first operation being a read.
it infers from atoms in which sameresource relation is described in section iii.
in the opencart example an entry sqlatomicra is inferred.rule d2 describes the inference of atomic pairs with neither operation being a read.
note that in d1 we don t explicitly require l2is reachable from l1because dep l1 l2 implies that.
in the example in fig.
an entry sqlatomicda is inferred.
rules d5 and d6 describe the inference of file operationatomicpairs whichisverysimilarto databaseoperati on pairs.notethatthepossiblepatternsforfileoperationato mic pairs are fewer.
other patterns are either impossible or rar e. vi.
violation detection given the inferred atomic pairs violations are detected by observing if the interleaving patterns presented in fig.
can happen.
since the remote operation is from a different execution instance of the samephp code it is sufficient to analyze if the same program contains the specific offending remote operation.
although php does not provide any buildin synchronizationsupport developerscan make use o f externalprimitivessuchasdatabasetransactions tablel ocks and file locks to ensure atomicity.
therefore our technique also needs to detect if an atomic pair is well protected by those external primitives.
rule d3 determines if a given pair of program points l3 l4 is nested in a database transaction.
it requires the existence of a transaction that starts and ends at l1andl2 respectively and l1dominates l3andl2post dominates l4 such that all paths leading from program entry to l3must go through l1and all paths from l4to program exit must go throughl2.
rule d4 detectsqueryatomicityviolationsofthepattern wr wwithr beingaremoteselect query.itreports l1 l2 as an atomic ww pair that could be violated if there exists a sql select at l3that operates on the same abstract tuple and l1 l2 is not protected by a database transaction.
our analysisalso modelstable locks.due to the space limitatio n we are not presenting the relevant rules.
detection rules for other sql operation and file operation interleaving patterns can be similarly derived as rule d4 .
vii.
evaluation our system is implemented on llvm an open source php compiler phc and the stp solver .
phcis used to translate php to c. the main analysis is implemented in llvm.
it takes the c program and transforms it to constraints which are resolved by the solver.
we translate php to c to leverage llvm for call graph construction points toanalysis etc.
aswe arenotawareofinfrastruct ures that allow us to analyze php direclty.
sincephcaims to generate c code that is compilable and executable the php features not directly supported by c are realized by chunks of c code.
for example array fields in php can be added dynmaically.
in translated c hash tables are used substantially increasing difficulty f or our analysis.
we therefore modified the code generator ofphcto generate simplified c code by replacing those hash table accesses with field accesses.
the resulting code may not be executable but reflecting the original semantics.
the llvm component translates the generated c programs to their ssa forms which are further encoded to constraints.
in order to understand external operations an d encodethemproperly weimplementasimplestringanalysis that tracks string concatenations so that we can acquire the the query strings.
a string variable is mappedto a linked lis t of constants and variables denoting its value.
query string s can be parsed to identify table name and field names.
our system currently requires these names to be constant.
since php files are largely independent modules it is unnecessary to encode all the files of a web app.
we use a demand driven strategy.
in particular given a query abou t resource identity we performprogramslicing to identify t he relevant php modules and functions and then only encode the slice.
we apply our technique to a set of real world web applications.thebenchmarksaremainlyfrompreviousphp analysis works excluding those that have trivial external resource accesses or functionally overla p with the selected ones.
in addition the shopping forum and wiki kinds of apps are often accessed concurrently so we randomly pick opencart phpbb aphpkb for each kind.
the characteristics of these programs are listed in table iv.
observe that many of them are very large web apps with a few hundred php files and over 100k loc.
all experiments are run on an intel dual core .5ghz machine with 2gb memory.
the os is linux .
.
.
table iv program characteristics .
php php loc application filesmean stdev max total opencart v1.
.
.
phpbb v3.
.
ajallerix v0.
extplorer v2.
.
rc3 scarf v2007 phpoll v0.
beta awcm v2.
webchess v1.
.
rc2 faqforge v1.
.
schoolmate v1.
.
timeclock v1.
aphpkb v0.
.
news pro v1.
.
dcp portal v .
.
employee scheduler v2.1beta table v presents the result of violation detection.
php loc w inclusion is the average loc of php files after inlining the scripts indicated by the include keyword.
converted c loc is the average loc of the c programs translated from the expanded php.
constraint complexity presents the average number of variables andconstraints in the formula.
the last four columns present the number violations reported and the number of false positives for ou r technique and a simplified static analysis.
sa w o dep.
atoms dep l1 l2 there is a program dependence path from l1tol2 including both data and control dependences.
datadep l1 l2 there is a data dependence path from l1tol2.
sqlr w a d l there is a sql select update insert delete query at l. filer a l there is a file read write operation at l. reachable l1 l2 l2is reachable from l1.
trans l1 l2 a database transaction is created at l1and then released at l2.
dom l1 l2 l1dominates l2.
pdom l1 l2 l1post dominates l2.
rules for database queries l1 l2 is a sql rw ra rd atomic pair d1 sqlatomicrw ra rd l1 l2 sqlr l1 sqlw a d l2 sameresource l1 l2 dep l1 l2 l1 l2 is a sql da ww wa atomic pair d2 sqlatomicda ww wa l1 l2 sqld w w l1 sqla w a l2 sameresource l1 l2 reachable l1 l2 datadep l l1 datadep l l2 the two operations at l3andl4are protected by the transaction in between l1andl2 d3 intrans l1 l2 l3 l4 trans l1 l2 dom l1 l3 pdom l2 l4 wr w atomicity violation l1andl2should be atomic but the interleaving with l3is not serializable d4 sqlviolation wrw l1 l2 sqlatomicww l1 l2 sqlr l3 sameresource l3 l1 intrans l4 l5 l1 l2 rules for file operations l1 l2 is a file ra atomic pair d5 fileatomicra l1 l2 filer l1 filea l2 sameresource l1 l2 dep l1 l2 l1 l2 is a file aa atomic pair d6 fileatomicaa l1 l2 filea l1 filea l2 sameresource l1 l2 reachable l1 l2 datadep l l1 datadep l l2 figure .
datalog rules for atomicity violation detection f or external operations.
w r a and d denote write read app end and delete.
table v analysis result.
php loc w converted complexity avg our method sa w o dep.
application inclusion avg c loc avg variable constraint viocfpcviosfps opencart v1.
.
.
phpbb v3.
.
ajallerix v0.
extplorer v2.
.
rc3 scarf v2007 phpoll v0.
beta awcm v2.
webchess v1.
.
rc2 faqforge v1.
.
schoolmate v1.
.
timeclock v1.
aphpkb v0.
.
news pro v1.
.
dcp portal v .
.
employee scheduler v2.1beta total represents a technique that can be considered as a static version of the one used in which is dynamic .
in particular it does not infer atomicity properties from php code but rather directly comparesthe query strings.
queri es that access the same table and abstract tuple and may form unserializable interleavings are reported.
the analysis t ime is mostly within a few seconds and thus elided.
we make the following observations from the result.
our analysis is able to detect many violations in these real worldweb apps.we manuallyvalidateeach bugby constructing a real test input and exercising the problematic interleaving pattern.
these bugs could lead to problems such as coupon misuses product being oversold data corruption and runtime database exceptions.
our analysis produces very few false positives.
the simplified approach producesmany false positives.
this illustrates the benefit of analyzing php code.
it also suggests that even though many queries are accessing the same table and the same tuples they are allowed to execute concurrently.
slicingisaneffectiveoptimizationbecauseeventhough the programsare large on average the averagenumbers of constraints and symbolic variables are small.
false positive .
our analysis sometimes reports false positives.
a typical example is shown in fig.
.
variables such as post hold the values submitted by the client so that they are defined in the client side.
our analysis is not able to make any assumptionsabout these values.
therefore we treat them as free variables.based on such assumptions the predicates at lines and5are both satisfiable rendering the path between the two queries at lines and feasible.
since the queries access the same resource and both depend on the same post variable according to our detection rules the two operations are considered to be atomic.
interleaving hence constitutes a violation.
howe ver in practice these two queries are not related.
the reason of the fp in fig.
is that we missed the constraint that a client can never submit a single request that can add a new record and edit an existing one in the meantime.
we speculate if we can model the client side logic such fps can be eliminated.
we leave it to our future work.
if post s1 update courses set ... post ... r1 mysql query s1 if post s2 update courses set ... post ... r2 mysql query s2 figure .
false positive example simplified snippet from schoolmate .
false negative .
our analysis is incomplete and may have false negatives.
for example the atomicity inference is heuristic based.
the current string analysis handles strin g concatenation but doesn t support functions such as substr orstrrpos .
however without an oracle it s hard to determine false negatives automatically.
we leave it to our future work.
viii.
r elatedwork data race and atomicity violation detections .
there are many works on data race detection and atomicity violation detection .t hey are mostly addressing problems caused by shared memory accesses.
they often leverage synchronization primitives .
in contrast the problem in our scenario is caused by sharing external resources.
server side scripts provide no build i n threading or synchronization support.
in other words we have to address a largely different set of challenges.
web app testing .
server side script testing is increasingly studied lately.
wassermann et al.
designed an automatic input generation algorithm for web apps based on concolicexecution.theyalso modelsthe semanticsof strin g operations and solve constraints involving different type s. harmanet al.
proposeda session data repairmethodfor regression testing.
the work by halfond et al.
precisel y identifies a web app s interface to improve test input generation via symbolic execution.
artzi et al.
proposed to combine concrete and symbolic executions to automatically generatetest casesthatexposefaultsbyanalyzingtheserv erside script.
sprenkle et al.
suggested that statistica l model based test generation can be adopted and applied for web app testing.
marchetto et al.
proposed a testabilit ymeasurement that can be leveraged in automated testing of web apps.
the vulnerability measurement proposed in heuristically inspects sql hotspots in server scripts to decide priority.
carzaniga et al.
proposed an automati c workaround of web app failures.
provided a failure it tries to find a differentexecution sequence that achieves the same functionalitywhile bypassthe failure.
the aboveapproach es do not address problems caused by concurrent executions.
web app comprehension.
since web app source code is usually not well organized it is difficult for human developer maintainer to understand the complex correlati ons between modules.
thus many works have been proposed to help people get better understanding.
hassan et al.
proposed to extract code structure and display the interactions between components.
wanda instruments web apps and combines dynamic and static informations to address the problem.
similarly the integration of ware andwanda combines static and dynamic analysis to enhance comprehension.
these works are too general to solve our problem.
ix.
conclusion we propose a static analysis that detects atomicity violations in web apps regarding external resources.
the technique features a novel resource identity analysis that is interprocedural and path sensitive.
it models external op erations to constraints and leveragesa smt solver to determine whether multiple operations are accessing the same externa l resource whichisacriticalconditionforcontention.wea lso develop an automated approachto statically infer if a pair o f operationsthat access the same resource demands atomicity .
violations are detected by reasoning about serializabilit y of interleaved atomic pairs.
our results show that the techniq ue is highly effective capable of detecting many real atomici ty violations in large web apps.