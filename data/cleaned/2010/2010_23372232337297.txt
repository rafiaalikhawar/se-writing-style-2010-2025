enhancing architecture implementation conformance with change management and support for behavioral mapping yongjie zheng institute for software research university of california irvine irvine california usa zhengy ics.uci.edu richard n. taylor institute for software research university of california irvine irvine california usa taylor ics.uci.edu abstract it is essential for software architecture to be con sistent with implementation during software development.
existing architecture implementation mapping approaches are not sufficient due to a variety of reasons including lack of sup port for change management and mapping of behavioral archi tecture specification.
a new approach called .x way architec ture implementation mapping is presented in this paper to address these issues.
its contribution includes deep separation of generated and non generated code an architecture change model architecture based code regeneration and architecture change notification.
the approach is implemented in archstu dio an eclipse based architecture development environment.
to evaluate its utility we refactored the code of archstudio and replayed changes that had been made to archstudio in two research projects by re them with the developed tool.
keywords software architecture architecture change management architecture implementation mapping i. introduction architecture implementation mapping is a process of converting software architecture to and from implementa tion with the goal of maintaining their conformance with respect to certain criteria.
it directly determines the degree to which software architecture a set of principal design deci sions made about a software system can be used in de velopment to improve software productivity and quality.
the mapping process however is often done manually by a team of software developers based on their understandings of the architecture.
the limitations are obvious low efficiency and error proneness.
the difficulty comes from the fact that there is a conceptual gap between software architecture and im plementation and both artifacts are under constant changes during software development.
a number of architecture implementation mapping ap proaches have been developed to automate this process.
they either rely on after the fact consistency checking to detect the inconsistency correct by detection or apply technologies like code generation to avoid the inconsistency correct by construction .
another perspective with which to look at existing approaches is assessing which artifacts can be manually changed during software development.
from this angle there are approaches of one way mapping and two way mapping.
table i presents the classified approaches.
the italicized words represent instances of each approach.
table i. architecture implementation mapping correct by construction correct by detection one way mapping .
full code generation domain specific mdd dssa .
architecture refinement sadl .
reverse engineering reflexion model .
runtime monitoring verification pattern lint discotect archsync two way mapping .
code generation separation emf diaspec .
architecture framework myx.fw unicon .
unifying descriptions archjava archface correct by detection approaches detect the architecture implementation inconsistency by extracting or inducing the architecture from the code and comparing the obtained archi tecture with the existing architecture.
they essentially as sume the relative constancy of software architecture.
this is why there is no two way mapping of correct by detection.
approaches in the category require the software be relatively complete or even executable so that reverse engineering or runtime verification can be done.
for this reason they are more appropriate for use in software maintenance rather than software development.
in contrast correct by construction aims to avoid inconsistencies from the very beginning.
one way mapping approaches in this category try to achieve the goal through complete code generation or step wise architec ture refinement both of which face the challenge of bridging the abstraction gap.
what they are trying to do is essentially promoting software development to the level of software architecture so that source code editing can be completely avoided.
however this only works for some highly special ized domains or specific architecture styles.
what seems most promising is two way mapping of cor rect by construction.
approaches in this category recognize the essential role of both architecture and code during soft ware development and provide certain forms of inconsisten cy prevention mechanisms such as separation of generated and non generated code and use of pre defined architecture implementations.
what makes these approaches not sound however is when architecture and implementation changes occur or when the architecture contains information that .
c ieee icse zurich switzerland goes beyond structure e.g.
system dynamics.
specifically the existing approaches in this category are often found defi cient in the following aspects.
mapping code changes to architecture.
this is essen tially a hard problem of machine based abstraction.
it can be partially addressed by automatically gener ating code from the architecture and forbidding manual changes to generated code.
with current code separation mechanisms e.g.
filling in blanks however this only works under the assumption that programmers are highly disciplined.
even so acci dental changes are still a possibility.
mapping architecture changes to code.
complete code regeneration with primitive merge support e.g.
emf s jmerge is usually used for this purpose.
in the cases where user defined code already exists and needs to be preserved during code regeneration this method deteriorates quickly into a manual mapping.
what makes the problem even worse is that pro grammers often have to figure out by themselves what was changed in the architecture.
support for the behavioral mapping.
software archi tecture encompasses both structural and behavioral decisions of the system under development.
in con trast most architecture implementation mapping ap proaches are structure oriented only.
this is mainly because architecture behavioral specification e.g.
uml s sequence diagrams is not complete enough to generate code from and its corresponding code is inevitably mixed with user defined dynamic details.
protection of architecture prescribed code becomes extremely difficult in this situation.
given all these challenges we developed a new correct by construction approach of architecture implementation mapping.
the approach is called .x way architecture implementation mapping.
different from previous work it only allows manual changes to be initiated in the architecture and a separated portion of the code .x with archi tecture prescribed code updated solely through code genera tion.
this is enabled by a new code separation approach deep separation where architecture prescribed code and user defined code of each architecture component are sepa rated into two independent program elements e.g.
classes .
in this way mistaken changes of architecture prescribed code are completely suppressed.
user defined code is also prevented from being overwritten during code regeneration.
in particular the behavioral architecture implementation mapping can be supported with modeled system dynamics generated into a program construct that is not manually mod ifiable by programmers.
additionally an architecture change model is developed to explicitly record and analyze various architecture changes.
based on it specific support is provided to map specific kinds of architecture changes to code.
most architecture changes can be automatically mapped to the code through an architecture based code regeneration mechanism.
for archi tecture changes that may require modifications to user defined code architecture change notifications are also gen erated and automatically sent across the separation boundary.
all these features are applicable to both structural and behav ioral architecture specifications.
the rest of the paper is organized as follows.
section ii introduces the .x way mapping approach including its deep separation and change management mechanisms.
section iii illustrates how behavioral mapping is supported in .x way mapping.
section iv presents the implementation of the ap proach in archstudio.
section v describes the evaluation of .x way mapping including its current limitations.
section vi discusses the related work with the focus on representa tive two way mapping approaches.
finally section vii con cludes the paper.
ii.
.x way architecture implementation mapping software architecture in .x way mapping is modeled as a configuration of components with executions of signifi cance i.e.
behaviors defined by uml like sequence dia grams and state diagrams.
a component is a locus of compu tation and state in a system.
it communicates with other components through explicitly defined interfaces each of which contains a list of operations.
the architecture modeling notation used in .x way mapping is xadl .
an extensible xml based architecture description lan guage.
java is used as the programming language in our cur rent implementation.
figure shows an overview of .x way architecture implementation mapping.
it is assumed that all the develop ment activities shown in the figure take place in an integrated software development environment ide where the tools used for creating and managing the system at different ab straction levels are able to communicate with each other and share information.
a typical example of such an environment is the eclipse platform.
figure .
an overview of .x way architecture implementation mapping.
architecture prescribed code generated code editormapping toolimplementation details user defined change notificationsregistrationarchitecture editorarchitecture changesarchitecture change model warning messagesprimitive operationsarchitecture resourcesregenerated coderecorded changes 629as shown in the figure the implementation of each archi tecture component is separated into two independent pro gram elements architecture prescribed code and implemen tation details.
architecture prescribed code is automatically generated.
it codifies all the externally visible information of a component that is specified in the architecture including its identity interfaces and properties.
user defined code con tains the internal implementation of a component that is to be manually developed by programmers.
on top of them three tools represented by ovals in the figure work closely in the ide to map architecture changes to the code.
architecture editor is responsible for the manipulation of architecture models.
in particular it maintains an explicit change model that records and classifies all the considered architecture changes.
mapping tool is able to automatically map most of the changes to code without requiring manual work on the code given that all the category information e.g.
compo nentchanges linkchanges etc.
is recorded in the change model.
for those architecture changes that may require mod ifications to the user defined code change notifications are sent to code editor.
in response warning messages are prompted in the code to highlight changes that have to be made.
to reduce the number of unnecessary notifications a plug in can be built to allow programmers to register for particular architecture changes.
we are currently making this one of our future tasks which is why it is represented by a dashed line in the figure.
important technologies developed in .x way mapping include deep separation of generated and non generated code an architecture change model architecture based code regeneration and architecture change notification.
each is introduced in the following subsections.
a. deep separation a new code separation mechanism deep separation or linguistic separation is developed in .x way mapping to decouple generated and non generated code.
it separates architecture prescribed code generated and user defined code non generated of each component into two independ ent program elements e.g.
classes and relies on program composition mechanisms to explicitly integrate separated code.
specifically the user defined code of a component provides a set of low level operations or primitive opera tions from which high level operations in the architecture prescribed code are constructed.
meanwhile available archi tecture resources e.g.
required interfaces architecture prop erties are passed to the user defined code for use in the im plementation of those low level operations.
this is essential ly different from existing code separation approaches such as filling in blanks and subclassing.
these approaches are called shallow separation or spatial separation in this re search work because their code is physically separated but is still coupled and implicitly integrated by some inherent language relationship same class inheritance etc.
.
a calculator application is used as an example in this pa per to illustrate how .x way mapping works.
its structural architecture is shown in figure .
this is not a complex ap plication.
however it provides concrete situations in which automatically maintaining the architecture implementation conformance is difficult.
simply speaking the calculator works as follows.
the gui component is responsible for collecting user s input of digits and operators and displaying both intermediate and final results the controller component accepts calculation requests from gui and either pushes entered digits and operators to the corresponding stack or sends them to math unit for calculation depending on which state it is in and what the input value is.
the register com ponent saves the intermediate result that is to be displayed.
whenever the value in register is changed gui is notified and has its display field updated correspondingly.
figure .
structural architecture of the calculator application.
the code below shows the implementation of the con troller component with deep separation enforced.
other components in the figure can be implemented in the same way.
two classes controllerarch controllerimp and one interface icontrollerimp are created for the component.
controllerarch is architecture prescribed code that is auto matically generated.
the interface icontroller that it im plements thus operations that are included enteroperator and enterdigit and the