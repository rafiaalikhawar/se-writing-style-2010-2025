mining branching time scenarios dirk fahland1 david lo2 and shahar maoz3 1eindhoven university of technology the netherlands 2singapore management university singapore 3tel aviv university israel d.fahland tue.nl davidlo smu.edu.sg maoz cs.tau.ac.il abstract specification mining extracts candidate specification from existing systems to be used for downstream tasks such as testing and verification.
specifically we are interested in the extraction of behavior models from execution traces.
in this paper we introduce mining of branching time scenarios in the form of existential conditional live sequence charts using a statistical data mining algorithm.
we show the power of branching scenarios to reveal alternative scenario based behaviors which could not be mined by previous approaches.
the work contrasts and complements previous works on mining linear time scenarios.
an implementation and evaluation over execution trace sets recorded from several real world applications shows the unique contribution of mining branching time scenarios to the state of the art in specification mining.
i. i ntroduction specification mining methods which extract candidate specifications from source code or execution traces have attracted much research efforts in recent years.
the mined specifications serve as input for downstream tasks such as testing formal verification and program comprehension.
specifically we are interested in mining scenario based specifications where the mined specifications consist of a set of typically short sequences of events intuitively depicted using variants of classic sequence diagrams.
in recent work two of the co authors of the present paper have presented mining of scenario based specifications in the form of universal live sequence charts lsc .
universal lscs specify rules of the form whenever a sequence of events happens eventually another sequence of events will happen .
that is they specify a universal linear temporal logic property.
however a specification of the behavior of a system may often be characterized not only by linear invariants but also by possible choices.
in the context of scenario based specifications these are best represented using existential conditional lscs as defined in .
such a branching lsc specifies a rule of the form when a sequence of events happens another sequence of events is a possible continuation .
that is they specify a conditional branching temporal logic property.
in this work we present mining branching time scenariobased specifications in the form of the branching existential conditional lscs described in .
the input for our technique are a set of execution traces a log that have been recorded from a running application and two parameters a support threshold sets how often a particular lsc has to occur in the log i.e.
when it is relevant enough and aconfidence threshold sets the fraction of times the property specified in the discovered lsc has to hold allowing the lsc to be violated on some occurrences .
the output consists of a set of existential conditional lscs that is correct and complete with regard to the support and confidence the given log satisfies each returned existential conditional lsc and any other existential conditional lsc occurs less often than the given support threshold or the log violates the lsc more often than allowed by the confidence threshold.
to better understand the difference between mining linear lscs and mining branching lscs and thus motivate our work consider the following two example lscs delete anddownload shown in fig.
and fig.
respectively.
both lscs were mined in our experiments from an execution trace set of crossftp an open source ftp server see sect.
v for details .
as these are branching lscs each specifies a possible continuation to the onconnect call a continuation which was observed with high support and confidence in the trace set executing the delete or the download ftp commands we mined several additional lscs with the same pre chart onconnect all together covering several additional commands of the ftp protocol .
however when mining for linear lscs as in from the same trace set none of these lscs is found because in the trace set onlogin is not always followed by the setdelete command by the setdownload command or by any other single ftp command.
instead only linear invariants are mined with high support and confidence such as the linear lsc shown in fig.
which specifies that whenever onconnect is called in the trace eventually there will be calls to onlogin setuser and setlogout in this order .
this example shows the difference between mined linear and branching scenarios in terms of their expressiveness and their ability to explain and reveal the behaviors embedded in an execution trace set.
we have implemented our ideas and evaluated them on execution trace sets recorded from two applications.
all trace sets and mining results are available at .
we summarize the contribution of our work as follows definition and algorithm for mining branching time scenarios evaluation over a number of trace sets including a discussion and comparison of branching vs. linear scenarios in the context of specification mining implementation for mining of linear and of branching scenarios available for download with all trace sets data 1lsc b delete setuser onlogin ondeletestart statreqcontpassdele setdelete ondeleteend setlogout onconnect reqhfig.
.
the branching lsc delete specifying one possible continuation after login dealing with the ftp delete command.
lsc b download setuser onlogin ondownloadstart statreqcontpassretr setdownload ondownloadend setlogout getfileoffset reqh getdatatype transfer onconnect fig.
.
the branching lsc download specifying one possible continuation after login dealing with the ftp download command.
setuser onlogin reqcontpassretronconnect lsc l login setlogout fig.
.
the linear lsc login specifying that whenever onconnect is called eventually there will be calls to onlogin setuser setlogin and setlogout in this order .
to allow readers to reproduce our experiments.
the formal methods community has had a long debate about the relative merits of linear vs. branching time logic as they are used for system specifications which one is easier for engineers to formulate and understand which one may have better performing synthesis and verification algorithms which one allows compositional reasoning etc.
see e.g.
.
one may view our present work as another contribution to this long debate specifically in the context of specification mining.the paper is organized as follows.
sect.
ii provides background and definitions.
the mining algorithm is presented in sect.
iii.
an extension to leverage additional user inputs to improve the mining process is presented in sect.
iv.
sect.
v presents an evaluation sect.
vi discusses related works and sect.
vii concludes.
ii.
b ackground and definitions we recall the semantics of branching lscs and their formal relation to execution trees.
we further define a number of measures required in the context of scenario mining.
a. branching lscs and traces branching lscs we use the branching lscs defined in with totally ordered events.
an lsc consists of lifelines representing participating objects and of events between them.
events are partitioned into pre chart and main chart events with the following conditional branching semantics whenever a sequence of events in the pre chart happens the sequence of events in the main chart must be a possible continuation .
syntactically pre chart events use blue dashed lines and main chart events use red solid lines.
figures show examples.
fig.
shows an example of an execution tree which illustrates the semantics of branching lscs.
the tree represents three different merged execution traces all starting with onconnect and ending with setlogout .
the tree satisfies the branching lsc delete whenever its pre chart onconnect occurs there exists a continuation with its mainchart including ondeletestart etc .
like a linear lsc a branching lsc abstracts from events not mentioned in its preor main chart as illustrated by the occurrence of delete in the right branch of fig.
.
for the same reason the branching lsc download is satisfied.
there are even two different traces that continue with the main chart of the branching lsc delete as highlighted in fig.
.
in contrast the tree violates branching lsc rename2 .
there is no trace that continues every occurrence ofondeleteend with event onrenamestart etc.
the right branch does continue with rename2 whereas the left branch does not .
branching lscs vs. linear lscs intuitively to be counted for branching an lsc needs to occur on one branch and to be counted for linear it has to occur on allbranches.
the tree of fig.
illustrates this difference.
if we would interpret download of fig.
as a linear lsc then the tree of fig.
would violate this lsc because one trace continues without completing the occurrence of the main chart of delete .
more precisely the occurrence of setlogout at the right most branch of the tree will violate the main chart of lsc download which requires in a linear interpretation getfileoffset to occur after setuser .
thus branching lscs allow one to describe alternative continuations of a pre chart.
in contrast linear lscs such aslogin of fig.
specify invariants of each trace.
the tree of fig.
satisfies login which specifies that each call toonconnect leads to a subsequent setlogout along the sequence of events specified in the chart .
2onlogin setuser getfileoffset ondownloadstart getdatatype transfer setdownload ondownloadend setlogout onconnect ondeletestart setdelete ondeleteend 1234567891011161718ondeletestart setdelete ondeleteend setlogout 12131415onrenameend setlogout 19202122onrenamestart getrenamefrom lsc b deletelsc b downloadlsc l renamefig.
.
execution tree of a trace set from crossftp represents merged traces highlighting occurrences of the lscs of figures .
lsc l renameonrenamestart reqcontrntosetrenamefrom onrenameend onrenamestart reqcontrntosetrenamefrom onrenameend lsc b rename2deleondeleteend fig.
.
linear lsc rename and branching lsc rename2 specifying renaming in different contexts.
basic notions lscs traces and positive witnesses more formally an lsc event is defined by a triple s r m where sdenotes the sender object method caller rthe receiver object callee and mthe method that sinvoked to communicate with r. if all events of an lsc are totally ordered an lsc l pre main can be formalized as two sequences of events describing the pre chart preand the main chart main .
for example lsc login reads as h retr pass onconnect i h pass cont onlogin ... retr req setlogout i .
in the following we abstract from the inner structure of events and treat each triple a hs r m ias a single letter a. in this abstract setting we consider traces over a finitealphabet a b c .
.
.
of events.
the symbol denotes the concatenation of two finite words.
then an lsc l pre main induces a word w pre main .
let ldenote the alphabet of visible events appearing in w. semantics of linear lscs intuitively require that in every execution an occurrence of the pre chart preis followed by an occurrence of the main chart main .
we formalize these occurrences as positive witnesses as follows.
a possibly empty word pisprefix ofu written pvuiff there is a possibly empty word u0s.t.u p u0.
a word sis a subword of a word uif there are possibly empty words u0 andu00s.t.u u0 s u00.
for a word sand a set of visible events the projection of sonto 0is written s .
apositive witness of a word wwrt.
the visible events 0in a word uis alength minimal subword sofusuch that w s .
execution trees and branching time semantics the branching time semantics of lscs requires that each positive witness of preis followed by a positive witness ofmain in some run which is naturally expressed on the semantic domain of execution trees.
an execution tree over alphabet is a rooted labeled t v e v with nodes v edges e root v0 and a labeling of nodes and edges such that v0 the empty word and for each edge v v0 2eholds v v0 a2 such that v a v0 .
each node node v2vdescribes a run v from the root v0 tov.
a node v2vis a leaf oftif for no node v02v v v0 2e.
a node v0is reachable from a node v written v v0iff v v0 2e the reflexive transitive closure of e .tis deterministic iff for any two edges v v0 v v00 2ewith v v0 v v00 holds v0 v00.
fig.
shows an example of a deterministic execution tree with three leaf nodes .
the semantics of branching lscs as defined in reads on execution trees as follows.
let l pre main be an lsc.
a word uends with the pre chart preiffuhas a suffix s u pre s such that sis a positive witness of prewrt.
linu.
let t v e v be an execution tree.
a node v is apositive witness ofpreiff v ends with pre.tsatisfies liff for each positive witness vofpreexists a node v02v v v0 such that v0 is a positive witness of pre main wrt.
l we call v0apositive witness oflint.
thus note that the semantics of branching lscs and of linear lscs do not constrain events not appearing in the lsc to appear or not to appear in the tree and trace set including in between events that do appear in the lsc.
for example node 2of fig.
is a positive witness of the pre charts of the lscs of figures .
node 11is a positive witness of download and login 15and 22are positive witness of delete and login .
node 21is a positive witness of rename2 .
in the following we consider weighted execution trees t v e v where the weight function assigns each node v2va positive integer v .
3b.
relating execution trees and traces a weighted deterministic tree represents a multi set of traces if two traces share the same prefix w then this prefix is represented in the tree only once by a node v v w.w e use the weight of vto represent how many times v occurs as a prefix of a trace in this set.
the weights will be relevant to discover how many times a particular scenario occurs in a set of traces.
atrace tis a finite word over aloglis a finite multisetof traces the natural number l t describes how often t occurs in l. each log lhas a canonical representation as a tree the unique deterministic tree twhere each leaf represents exactly one distinct trace.
the number of occurrences of traces inlis captured by node weights of t. the formal definition requires an auxiliary notion for any word p let cont p l t2t pvt denote the set of traces of lthat continue a prefix p. now a weighted treet v e v represents the log liff for each t2l exists node v2vwith v t for each leaf vofv v 2l v1 v2 implies v1 v2 for all nodes v1 v22v and for each v2v holds v p t2cont v l l t .
condition implies that tis deterministic.
condition states that the weight of each node is the sum of all occurrences of all traces that run through it note that this implies v v0 for all v v0 2e.
in the following we assume that all traces in lstart with the same event that is v0ofthas exactly one outgoing edge.
for example the tree of fig.
represents three traces induced by its leaf nodes .
nodes 4have weight nodes 10have weight and all other nodes have weight .
the weight function allows us to see that the pre chart onconnect of fig.
occurs times in the tree.
we use the weight function to define measures on scenarios as follows.
c. measures for lscs on execution trees our goal is to discover from a given log of execution traces a set of lscs that describe the behavior in the log according to the branching time semantics given in sect.
ii a. we introduce basic measures that express how good a set of discovered lscs may describe the behavior recorded in a log.
negative witnesses support and confidence support measures the number of times an lsc l pre main occurs in the execution tree tthat represents the log.
confidence measures the likelihood that a positive witness of preis followed by a positive witness of main in some branch of t. for this we introduce weak and strong negative witnesses .
anegative witness of lis a witness of prethat is not followed by a witness of pre main .
the witness is weak negative if some trace could be extended to a witness of pre main by adding missing events and strong negative otherwise e.g.
events occur out of order .
formally let t v e v be an execution tree and l pre main be an lsc.
aweak negative witness oflintis a positive witness v2vofpresuch that for no node v02v v v0holds v0 is a positive witness of pre main .
astrong negative witness oflintis a positive witness v2vofpresuch that for every leaf v02vand every finite word wholds v0 wisnota positive witness ofpre main .
support and confidence measures are based on the weights of all witnesses.
let pos l t wneg l t and sneg l t denote the positive negative and strong negative witnesses oflint respectively pos pre t denotes the positive witnesses of pre chart pre.
the weight of a witness vint is v .
for a set wof witnesses let w p v2w v be the sum of all weights of all witnesses.
the support of lintissup l t pos l t the confidence of lintis conf l t pos l t wneg l t sneg l t pos pre t .
to account for incomplete traces confidence only penalizes strong negative witnesses of l as weak negative witnesses of lcould be extended to positive ones.
for example in the tree of fig.
lsc delete has support 2and confidence .
lsc download has support 1and confidence .
linear lsc login has support 3and confidence .
.
in contrast lsc rename2 has support 1and confidence .
.
its pre chart has a positive witness at nodes 14and18 but its main chart has only a witness at node .
thus 14is a weak negative witness forrename2 as the trace could be extended after node to a positive witness of rename2 .
if the edge from 14to 15was labeled with setrenamefrom 14would be a strong negative witness as event onrenamestart would be missing.
as in the case of linear lscs the support measure for the branching case is monotonic.
for an execution tree t an lsc l and a word w pos pre main t pos pre main w t .
this monotonicity extends to pos pre main t pos pre main w t because v v0 for all edges v v0 oft.
we take advantage of this monotonicity to prune search when support falls below a threshold.
note that the weight function is needed for mining branching scenarios because the tree merges prefixes of traces into the same node.
when mining linear scenarios one can count the scenarios in the trace set and no weight function is needed.
two notions of coverage finally the branching semantics of lscs gives rise to another measure.
a setof lscs is comprehensive if it can explain every branch in the execution tree.
we formally capture this property in two coverage measures the fraction of tree nodes covered by an lsc pre and main chart and the fraction of nodes only covered by main chart events.
for example the tree of fig.
is completely covered by lscs delete upload and rename fig.
top .
when considering main chart coverage node 19is not covered neither by delete nor by rename as event onrenamestart is not a main chart event of these lscs.
we can cover node 19with lsc rename2 fig.
bottom .
main chart coverage measures the fraction of events in the 4tree that are not explained as the consequence of some prechart .
for example rename2 explains onrenamestart as the consequence of ondeleteend whereas rename assumes onrenamestart to be given.
more formally a node v6 v0of an execution tree tiscovered by an lsc l pre main written vcovliff there exist nodes v1 v22v v1 v v2such that v2is a positive witness of lint v1is the corresponding positive witness of preint and the incoming edge v0 v 2e is labeled with an event v0 v lofl vismainchart covered byl vcovml iff v0 v 2eis labeled with a main chart event of l. for a set sof lscs we write vcovs vcovms iff vcovl vcovml for some l2s.
thecoverage andmain chart coverage oftbysare defined as cov s t v2v vcovs v v0 andcovm s t v2v vcovms v0 respectively where v0 v v0 v v0 v 2e .
we use these notions of coverage as a yardstick for the quality of the mined branching lscs1.
iii.
m ining algorithm we now present the main contribution of this paper a mining algorithm for branching lscs.
sect.
iii a introduces measures to characterize the output of a mining algorithm and discusses variants of mining.
sect.
iii b explains the basic algorithmic idea and sect.
iii c presents the actual algorithm.
in sect.
iii d we discuss correctness and complexity.
a. characterizing mining results a mining algorithm mextracts from a given log la finite set sof lscs.
one can impose properties on sto characterize desirable results of a mining algorithm.
for the branching semantics three properties are of interest correctness completeness and coverage.
we state these properties in terms of the execution tree tthat represents l. intuitively a set sof lscs is correct wrt.
tif each lsc exceeds a given confidence threshold c has no or only a specified ratio of negative witnesses in t and its support exceeds a given threshold s occurs often enough .
sis complete wrt.
tif for any other lsc lthat is satisfied by t confidence exceeds threshold c the support of lis below threshold s. finally a set of lscs covers tif a given percentage of nodes of the execution tree is explained by at least one lsc.
formally a set sof lscs is correct with respect to tand thresholds sandciff each l2shas support sup l t s and confidence conf l t cin the execution tree t that represents l. a set sof lscs is complete with respect to tand thresholds sandciff for each lsc lholds sup l t sor conf l t corl2s.
1note that our definition of coverage relates a set of mined branching lscs wrt.
a set of traces as it is represented in the execution tree.
we do not consider here how well does the set of traces cover the behaviors of the application from which they were extracted.
a set sof lscs covers twith respect to threshold kiff cov s t k. the mining algorithm s objective is to return a set of lscs that is correct and complete wrt.
the chosen thresholds.
b. algorithm idea and monotonicity the mining algorithm proposed in this paper builds on the mining algorithm for universal lscs that was proposed first in .
the algorithm has two major steps.
in the first step the set of candidate words that exceed the chosen support threshold sare discovered.
in the second step each candidate word wis split into all possible pre and maincharts pre main w each splitting gives rise to a unique candidate scenario l pre main for which the confidence is checked that is whether each occurrence of preis followed by an occurrence of main up to the chosen confidence threshold .
all lscs that reach the chosen confidence threshold are returned the others are discarded.
the key to efficiently find a complete set of lscs above a certain threshold is a monotonicity property on the number of positive witnesses of words.
for two finite non empty words w u the word w uwill occur at most as often in a tree t as the word w because not each occurrence of wis followed by an occurrence of u. thus the discovery starts with single events that are extended to words by exhausting all possible event combinations.
once an explored word woccurs less often than the support threshold s exploration stops for w as no extension w uwill occur more often than stimes.
hence every lsc l pre main that can be built from a discovered word w pre main will satisfy sup l t s and any other lsc has a support sint.
c. mining algorithm in the following we consider only lscs l pre main where in pre main each event occurs at most once.
the algorithm s main procedure minelsc is shown in fig.
.
it contains the two main steps described above discover candidate words and discover lscs from candidate words .
its input consist of the tree and of thresholds for support and confidence.
its output is a correct and complete set of statistically significant lscs i.e.
exactly all branching lscs that meet the thresholds.
discovering candidate words begins with discovering the frequent events that each occur in tmore often than the support threshold s an event occurring less than stimes cannot be part of an lsc that exceeds s see procedure minesupportedwords .
then procedure minerecurse recursively builds candidate words from frequent events as follows.
extend a word wwith each frequent event eto a word w e. ifw eoccurs more often than threshold s then w eis a candidate word and then continue recursively with w e. eventually w efalls below the threshold or wrepresents a complete trace ending at a leaf of t and the recursion terminates.
the main difference between our branching lsc mining algorithm and the original linear lsc mining algorithm of 5procedure minelsc inputs t input tree min sup min.
sup.
thresh.
min conf min.
conf.
thresh.
output a set of statistically significant lscs letwset minesupportedwords t m i n sup letlscresult for every word w2wset for every prefix preofw letmain s.t.pre main w letnewlsc create new lsc pre main if conf newlsc t min conf add newlsc tolscresult return lscresult procedure minesupportedwords inputs t input tree min sup min.
sup.
thresh.
output a set of supported words letev single events occurring min supint letwset for every ev2ev call minerecurse t min sup ev e v wset return wset procedure minerecurse inputs t input tree min sup min.
sup.
thresh.
ev frequent events curw current word considered wset current set of supported words output updated set of supported words wset add curw towset for every ev2evwith evnot in curw letnxtw curw ev if pos nxtw t min sup call minerecurse t min sup ev nxtw wset fig.
.
mining algorithm lies in the computation of positive and negative witnesses of an lsc l pre main which has to be performed on the canonical tree tto determine l s support and confidence.
function conf l t called in minelsc is straightforward.
find all nodes v1 v2 ... oftwhere vi i 0ends with pre.
then for each vi perform a depth first search ontstarting at vito find a positive witness of main .
collect all positive and weak negative witnesses to compute conf newlsc t .
d. correctness and complexity the mining algorithm of fig.
is correct the set lscresult returned by minelsc is correct and complete w.r.t.
the given tree tand given support and confidence thresholds min supandmin conf.
the proof holds by the same arguments as for the linear case as follows.
first minesupportedwords returns in wset each word wwith support min sup.
this proposition holds as minesupportedwords recurses over all variations permutations of subsets of events that occur at least min suptimes weighted occurrences .
recursion stops only for every word wwith support min sup and by the monotonicity of support no word w uhas support min sup.
second all lscs that can be built from wset as assumed all lscs where each event occurs at most once willbe considered in minelsc .
thus each lsc with support min supis considered.
third lscresult contains only those lscs with confidence min conf.
thus lscresult is the set of all lscs having support min supand confidence min conf.
regarding complexity let nbe the number of single events occurring at least min suptimes in t weighted occurrences .
then up topn k 1n!
n k !supported words can be found.
each supported word wof length k 1gives rise to k lscs l pre main with pre main w. thus in worst casepn k 2k n!
n k !candidate lscs have to be checked for confidence.
checking confidence of one candidate lsc requires basically one depth first search on t. thus if thas mnodes the check succeeds in o m steps.
altogether this gives a worst case complexity of o pn k 1n!
n k !
pn k 2k n!
n k !
m o pn k 2k n!
n k !
m .
this is a very coarse approximation.
by far not each possible variation of events is a supported word and recursion stops as soon as the support drops.
also heuristics allow to prune the search space number of recursions significantly.
the complexity of the branching case deviates from the linear case in the final step when checking confidence of lscs.
the linear case has to consider the entire log number of cases times average length of all cases which is usually larger than the tree.
iv .
m ining triggers and effects in addition to finding a complete set of lscs discovery can also be driven by the questions which triggers are needed to observe a given behavior main ?
and what behaviors are triggered by a given pre chart pre?
.
these two questions lead totrigger andeffect mining respectively .
here the goal is to find for a given pre chart pre main chart main the correct and complete subset sof lscs that have this pre chart mainchart .
mining scenarios given triggers and effects can be beneficial for two reasons.
first the number of mined scenarios is typically small and users are presented only with scenarios of interest.
second the efficiency of the mining process could be improved significantly.
this section shows how to extend the basic mining algorithm of fig.
to solve this problem variant.
as an example of trigger and effect mining users can provide the pre chart or main chart of the scenario shown in fig.
as a trigger or an effect .
the mining algorithm would then only return the set of branching scenarios with pre charts matching the given trigger or main chart matching the given effect .
this would include the scenario shown in fig.
and possibly many others but exclude other scenarios that are not of interest e.g.
the one shown in fig.
bottom .
we first describe a straightforward solution and give a more efficient one afterwards.
to mine from a given tree tscenarios that are triggered by a given pre chart pre or have the given effect main with support sand confidence c we can compute s minelsc t s c and then filter sby the given prechart or main chart trigger s pre pre main0 pre main0 2s and 6e ect s main pre0 main pre0 main 2s .
the result is correct and complete in the following sense.
siscorrect with respect to tree t support s confidence cand pre chart pre main chart main iff scorrect with respect to t s and c as before and additionally pre0 main0 2simplies pre0 pre main0 main .
siscomplete wrt.
t s candpre main iff for each lsc l pre0 main0 s one of the following holds sup l t sorconf l t corpre pre0 main main0 .
note that in trigger effect mining a given pre chart predefines its own support value sup pre t as upper bound for the support threshold s. ifs sup pre t then the resulting sets .
a similar observation is also valid when mining triggers for a main chart main .
to improve efficiency we adapt procedure minesupportedwords of fig.
for trigger and effect mining.
for a given pre chart prewe call minerecurse with preas first supported word if preis supported in t .
for a given main chart main callminerecurse with main as first supported word ifmain is supported in t and compute the next word as nextw ev curw in the recursion step to build up the pre chart for main .
in sect.
v we show that this improves the efficiency of the mining process significantly.
v. i mplementation and eva l uat i o n we report on experimental evaluation of mining branching scenarios in particular compared to linear time scenarios.
a. experiment design the main aim of our experiments was threefold to show the feasibility of our algorithm to discover branching time scenarios on actual data sets to gain insights on how branching time scenarios relate to linear ones on actual data and to evaluate the benefit of trigger and effect mining for branching scenarios.
we thus formulated four research questions.
rq i in what ways is mining of branching scenarios different than mining of linear ones?
rq ii which properties of traces impact mining branching or linear scenarios?
is it possible to estimate useful support confidence thresholds from the traces prior to mining?
rq iii is there an advantage to mine both linear and branching scenarios from the same set of traces?
rq iv could we improve the efficiency of the mining process by allowing users to specify triggers or effects of interest?
what insights can be gained with this technique?
b. experiment setup implementation we implemented the mining algorithm of sect.
iii as well as the linear mining algorithm of in the java based command line tool sam that is available at sam takes as input a log file in xes format and support and confidence thresholds and returns the discovered scenarios astable i basic data on the logs .
max.
log traces nodes degree width depth crossftp columba modal uml sequence diagrams .
the results are shown on an html page scenarios are grouped by equivalence classes sharing the same pre charts.
sam also visualizes occurrences of the discovered scenarios on the execution tree of the given log similar to fig.
.
the implementation improves over the algorithm of sect.
iii in two ways.
we use a heuristics to prune the search for supported words as follows.
instead of extending a found supported word wwith all supported events we prefer extending wwith the successor events of all occurrences of wthat have been found in the tree.
when wcannot be extended further we return to naive recursive search and also check each subword ofw by removing single events that allows for further extension not possible for w. we found this heuristics to greatly reduce the search space and hence the runtime needed to identify candidate words.
we filter from the resulting set of lscs all lscs that are subsumed by some other lsc.
intuitively lsc lsubsumes lsc kifkholds whenever lholds.
formally lsc l prel main l subsumes lsc k prek main k iff either prelis a subword of prekand main kis a subword of main l lrequires less in the pre chart and provides a larger main chart or prek main kis a subword of main landprelis not a subword of main k k s pre chart and main chart occur while l s main chart occurs and not earlier .
in both cases every positive witness of prek succeeds a positive witness of prel hence loccurs on some branch and every positive witness of lsucceeds a positive witness of k hence an occurrence of limplies an occurrence ofk .
as a consequence all smaller lscs contained in some larger lsc are omitted from the results.
data we validated our approach on logs obtained by tracing method calls of running applications where each method call was logged as an event calling class called class called method .
for the experiment we used logs obtained from crossftp server and from columba mail client .
tracing was repeated several times from a welldefined start state for crossftp no open connections for columba showing the main screen of the application which yielded several traces per log.
the logs are available at tab.
i shows basic data.
experiment execution for each log we mined branching lscs and linear lscs for several support and confidence thresholds on a standard laptop at .4ghz and 4gb ram.
the resulting lscs were grouped by equivalence classes of identical pre charts and classified as strictly branching if an lsc was found by the branching miner of this paper and not by the linear miner strictly linear vice versa and both otherwise.
additionally we measured main chart coverage of the tree for all kinds of scenarios.
7c.
results and analysis as expected we did not find any strictly linear scenario each scenario found by the linear miner was also found by the branching miner.
all results for both logs are available tab.
ii gives a summary.
research question i as each linear time scenario is also a branching time scenario each lsc satisfied according to linear time semantics of lsc is also satisfied according to branching time semantics we focused our evaluation on strictly branching time scenarios ones that are not mined as linear time scenarios .
in all the execution trace sets we analyzed we were able to mine linear as well as branchingtime scenarios.
for all logs and parameters the branching miner returned at least the scenarios that also the linear miner returned plus additional strictly branching time scenarios.
we observed in all logs that strictly branching time scenarios have a lower support than linear scenarios for high enough support thresholds only linear lscs are found see lscs in tab.
ii .
for given support and confidence thresholds the maximal and average number of events and number of participating objects in the mined branching lscs was higher than those in the mined linear lscs however pre charts of linear lscs tend to be longer see length pre main chart in tab.
ii .
moreover we often found linear lscs to abstract from many behaviors between two events whereas branching lscs tended to contain more contiguous sequences of events without abstraction.
these observation make sense as the branching ones are in a sense weaker than the linear ones for a behavior to be counted for branching it is enough if it appears on one branch to be counted for linear it has to occur on all branches.
as a concrete example recall the two branching lscs delete and download and the linear lsc login .
linear and branching scenarios also differ regarding the coverage measure.
branching time scenarios yield at least the same coverage as linear time scenarios and the lower the support value the higher the coverage.
we observed consistently higher main chart coverage for branching time scenarios see coverage in tab.
ii .
depending on the log linear scenario can cover the entire log with pre and main charts e.g.
crossftp for support .
however linear scenarios are unable to give complete main chart coverage with confidence .0if the tree has width .
as a consequence reasons for occurrences of a particular branch cannot be discovered with linear scenarios.
for branching scenarios main chart coverage with confidence .
is possible but not guaranteed as discussed in sect.
v c2.
we found the branching scenarios most informative when a number of mined branching lscs share an identical pre chart and thus the overall interpretation is that of several alternative continuations.
for example for the traces of crossftp and support we rediscovered the six main commands the server can handle upload download delete and rename a file create delete and rename a directory.
for instance lscs delete anddownload shown in fig.
and fig.
have 77a3b2a11bc421bc4c1e1ea1e1f1h1g7abc 1d342abc114bcad2113b2a1e1b1e2b1e1f44ca1c11c1hgtbranchingpoints of tfig.
.
branching diversity in execution trees node weights inscribed .
been mined.
in contrast the linear miner was only able to discover the invariants of each individual ftp command and returned only the lscs corresponding to rename of fig.
which provide no context of their occurrences relative to each other.
the main commands of columba were harder to rediscover as we discuss next.
research question ii we observed that for given support and confidence thresholds some execution trace sets revealed relatively more branching lscs than others.
while simple tree properties such as maximum out degree or width did not explain the relative share of branching lscs compared to linear lscs we found the consistency of branching in the tree to have a significant effect on branching scenarios.
tree tof fig.
left shows an example ais always followed by b andcand only occasionally by d as alternatives whereas c never has the same successor.
thus only bandcfollow awith confidence .
.
however by lowering confidence thresholds also dbecomes a possible continuation of a. this variation with respect to branching can be quantified in a measure on the weighted tree t v e v .
for any two events a b let a p v2v a v where v a v v0 v 2e v0 v a number of occurrences of a and a b p v v0 2e a b v where e a b v v0 2e v2v a v02v b number of a s having bas successor and a b p v v0 2e a b v0 number of b s having aas predecessor .
a branching lsc that contains aandbhasat most confidence a b a andat least support a b .
by the branching points of tshown in fig.
right a b a c .
a d .
b e .
b a .
b f .
and c h .
.
letconf a a b1 a ... a bn a be the vector of confidence estimates for direct successors b1 ... b n ofain descending order.
also let supp a a b1 ... a bn be the corresponding support vector.
in fig.
conf a .
supp a forb c d conf b .
.
supp b for e a f conf c .
.
.
supp c fora g h .
this profile lifts to entire tby the vectors conf t and supp t with conf t i max a2 conf a iand supp t i supp a iifconf t i conf a i for i max outdegree of t. in fig.
conf t .
supp t telling that we find two alternative scenarios with confidence 1and support bandcafter a and three alternatives with confidence .33and support e a f after b .
8table ii results of the mining algorithms for branching and linear miner .
log supp.
conf.
lscs length pre chart length main chart coverage runtime all non subsumed avg.
max.
avg.
max.
all main chart crossftp .
.
.
.
.5s .5s .
.
.
.
.
.
.
.
26s 31s .
.
.
.
.
.
.
.
685s 1008s columba .
.
.
.
2s 2s .
.
.
.
.
.
.
154s 159s .
.
.
.
.
.
.
.
.
2055s 2191s .
.
.
.
.
.
.
.
2125s 2256s all values strictly branching lscs linear lscs table iii branching profile of the logs .
k crossftp supp conf .
.
.
.
.
.
columba supp conf .
.
.
.
.
.
.
.
table iii shows the vectors for the two logs.
we can clearly see distinct characteristics of the two trees regarding consistency of branching.
intuitively setting confidence and support to conf t k andsupp t kallows to find at least kdifferent branching scenarios that contain the same event as for these thresholds there is some event having kdifferent successors .
we could confirm on our data that conf t and supp t roughly correlates with the number of branching scenarios having the same pre chart.
for crossftp we found for support and confidence .
two equivalence classes each having branching scenarios with the same pre chart.
we did not find any branching scenario for support values .
for columba we found branching scenario for support 20and confidence .
.
support 10and confidence .0yielded classes of branching lscs and class of branching lscs with the same pre chart each.
when lowering confidence to .
see tab.
ii we discovered among others class of branching lscs with the same pre chart which also revealed the main uses case of columba read message send message view account view sub folder and variations of these see for details.
asconf t andsupp t can be computed by a depthfirst search on t this profile allows to quickly check whether the tree branches consistently enough to allow mining relevant branching scenarios.
if branching is too diverse mining lineartime lscs with high confidence is preferable over mining branching time lscs with low confidence.
the branching diversity of a tree is not necessarily inherent to the original application branching diversity may also be high if some branches were just not recorded in the log.
this is comparable to a log having only few traces.
then discovering linear time lscs with high support is also impossible.
research question iii our experiments show that mining both branching and linear scenarios from the same trace set is indeed valuable as the two sets of mined scenarios reveal different somewhat complementary information about the behaviors of the application at hand.table iv mining all lsc sv s.trigger and effect mining on cross ftp at support confidence .
results for strictly branching linear scenarios .
setting lscs lscs max.
runtime all red.
length all .
.
685s 1008s trigger 18s 18s trigger 1s 1s trigger 1s 1s effect 1s 1s effect 27s 27s effect 1s 1s trigger effect honconnect i trigger effect hsetlogout i trigger effect honrenamestart setrenamefrom onrenameend i this is particularly evident when considering sets of branching and linear scenarios that share the same pre chart.
the branching scenarios usually show alternative continuations of the same behavior such as the commands of crossftp.
often these branching scenarios are accompanied by one or more linear scenarios describing invariants that hold in all alternative scenarios.
there may be several such invariants.
the two branching lscs delete andupload fig.
and and the linear lsc login illustrate this.
usually the linear scenarios capture the behaviors that are identical and common to all alternative scenarios.
we found this combination helpful to quickly understand where alternatives do differ.
in addition to invariants across all alternatives we often could find for each strictly branching time scenario a shorter linear time scenario that describes the essence of the branch for instance rename .
by combining both the linear time scenarios give insight into framework behaviors and core behaviors of an application login and rename are respective examples while the branching time scenarios glue the linear time ones together.
research question iv finally we investigated the proposed extension of mining scenarios with given a trigger or an effect of interest in the context of branching scenarios.
first we checked whether efficiency was improved by reduced runtime and smaller and more focused sets of scenarios.
for this we chose triggers and effects for the crossftp log shown in tab.
iv based on the lscs in figs.
and employed trigger and effect mining at support 10and confidence .
.
table iv compares the number of found scenarios and runtimes to the case of discovering all lscs of given support and confidence.
the number of mined lscs reduced significantly from 9onrenamestart contrntoreqsetrenamefrom onrenameend lsc b rename deletedelestat ondeletestart setdelete ondeleteend fig.
.
branching lsc rename delete specifying subsequent occurrences of rename and delete operations.
.
106scenarios strictly branching and linear to about 103scenarios in total.
this comes with a significant reduction of runtime down to a few seconds.
after removing subsumed scenarios result sets are of similar size but scenarios are shorter see max.
length in tab.
iv which allows to analyze behavior of interest in a more focused way.
because of significant improvements in running time trigger effect mining allows to drill down in the given log and investigate less frequent behaviors.
based on the branching profile of crossftp tab.
iii we ran a trigger effect analysis for support 1and confidence .45for trigger effect tab.
iii .
this allowed us to find branching scenarios that were not found before at support .
in particular we found rename2 of fig.
and rename delete of fig.
.
together these two strictly branching scenarios describe that the ftp operation rename can follow the ftp operation delete and delete can follow rename at confidence .
.
in other words we see that one ftp command can follow another ftp command without logging out which was not observable at support .
vi.
d iscussion and related work linear vs. branching time scenarios.
the formal methods community has had a long debate about the relative merits of linear vs. branching time logic as they are used for system specifications which one is easier for engineers to formulate and understand which one may have better performing synthesis and verification algorithms which one allows compositional reasoning etc.
see e.g.
.
linear and branching time logics correspond to two distinct views of time and the logics ltl and ctl are expressively incomparable .
thus we consider also the choice between a universal linear semantics for lsc as presented in and a branching semantics for lsc as presented in to be open and depend on the specific way one wishes to use the scenarios.
one may view our present paper as another contribution to this long debate specifically in the context of specification mining it makes sense to consider both lineartime and branching time behavior together .
two of the three authors of the present paper have introduced mining of linear scenario based specifications in .
several variants and extensions of this initial work have been presented .
the present work is different from all of the above as it mines for branching scenarios.
some of thevariants and extensions applied to mining linear scenarios may be applied to branching time scenarios as well.
other notions of branching existential conditional scenarios exist though these cannot be discovered by our approach as they are based on partial order semantics.
a possible use of mined linear and branching scenarios is formal verification.
recently ben david et al.
have presented a translation of branching scenarios into cssl a new logic based on an extension of ltl with limited branching expressiveness with an efficient model checking procedure specifically suitable for branching scenarios.
our mined branching scenarios may be used for model checking using the logic and procedure presented in .
other approaches to specification mining.
specification mining has attracted much research efforts in recent years many approaches and techniques have been suggested.
the different approaches vary and can be roughly categorized along two dimensions.
some works use static specification mining and learn candidate specifications from source code see e.g.
while others like our present work use dynamic specification mining i.e.
look for candidate specifications in execution traces see e.g.
.
an advantage of the former is that it does not depend on the quality or coverage of a specific set of executions.
on the other hand like other static analysis methods it may only provide an over approximation of the actual behaviors the program may exhibit at runtime.
as future work we consider the use of source code for mining branching time scenarios on the one hand as well as advancing the results of our present dynamic approach by using techniques that can improve the coverage of the set of executions we use as input.
some works look for value based invariants that hold at specific points in the program see e.g.
while others like our present work look for temporal behavioral rules regarding the order of program actions over time see e.g.
.
as shown in these two approaches may be combined.
as future work we consider such a combination in the context of branching time scenarios.
vii.
c onclusion we introduced mining of branching time scenarios in the form of existential conditional live sequence charts using a statistical data mining algorithm.
we showed the power of branching scenarios to reveal alternative behaviors which could not be mined by previous approaches.
our work contrasts and complements previous works on mining linear time scenarios.
an implementation and evaluation over execution trace sets recorded from several real world applications shows the unique contribution of mining branching time scenarios to the state of the art in specification mining.
we consider several directions for future research.
first the integration of our present work with value based invariants following the ideas presented in .
second a parametric extension of our present work following the ideas presented in .
10references m. acharya t. xie j. pei and j. xu.
mining api patterns as partial orders from source code from usage scenarios to specifications.
in esec sigsoft fse pages .
s. ben david m. chechik a. gurfinkel and s. uchitel.
cssl a logic for specifying conditional scenarios.
in sigsoft fse pages .
columba java email client.
crossftp server.
sourceforge.net projects crossftpserver .
w. damm and d. harel.
lscs breathing life into message sequence charts.
j. on formal methods in system design .
f. c. de sousa n. c. mendonc a s. uchitel and j. kramer.
detecting implied scenarios from execution traces.
in wcre pages .
m. el ramly e. stroulia and p. g. sorenson.
from run time behavior to usage scenarios an interaction pattern mining approach.
in kdd pages .
acm .
e. a. emerson and j. y .
halpern.
sometimes and not never revisited on branching versus linear time temporal logic.
j. acm .
d. r. engler d. y .
chen and a. chou.
bugs as inconsistent behavior a general approach to inferring errors in systems code.
in sosp pages .
m. ernst j. cockrell w. griswold and d. notkin.
dynamically discovering likely program invariants to support program evolution.
tse .
d. fahland.
oclets scenario based modeling with petri nets.
in petrinets volume of lncs pages .
springer .
d. fahland.
from scenarios to components .
phd thesis humboldtuniversit at zu berlin .
d. fahland and a. kantor.
synthesizing decentralized components from a variant of live sequence charts.
in modelsward 1st international conference on model driven engineering and software development proceedings pages .
insticc .
isbn .
d. fahland d. lo and s. maoz.
mining branching lscs crossftp columba traces and results.
3tu.datacentrum .
m. gabel and z. su.
symbolic mining of temporal specifications.
in icse pages .
m. gabel and z. su.
online inference and enforcement of temporal properties.
in icse pages .
n. gruska a. wasylkowski and a. zeller.
learning from projects lightweight cross project anomaly detection.
in issta pages .
d. harel and s. maoz.
assert and negate revisited modal semantics for uml sequence diagrams.
software and systems modeling .
s. kumar s. c. khoo a. roychoudhury and d. lo.
mining message sequence graphs.
in icse pages .
c. lee f. chen and g. rosu.
mining parametric specifications.
in icse pages .
z. li and y .
zhou.
pr miner automatically extracting implicit programming rules and detecting violations in large software code.
in esec sigsoft fse pages .
d. lo and s. c. khoo.
smartic towards building an accurate robust and scalable specification miner.
in sigsoft fse pages .
d. lo and s. maoz.
mining scenario based triggers and effects.
in ase pages .
d. lo and s. maoz.
specification mining of symbolic scenario based models.
in s. krishnamurthi and m. young editors paste pages .
acm .
d. lo and s. maoz.
mining hierarchical scenario based specifications.
inase pages .
d. lo and s. maoz.
scenario based and value based specification mining better together.
in ase pages .
d. lo and s. maoz.
towards succinctness in mining scenario based specifications.
in iceccs pages .
d. lo s. maoz and s. c. khoo.
mining modal scenario based specifications from execution traces of reactive systems.
in r. e. k. stirewalt a. egyed and b. fischer editors ase pages .
acm .
d. lorenzoli l. mariani and m. pezz e. automatic generation of software behavioral models.
in w. sch afer m. b. dwyer and v .
gruhn editors icse pages .
acm .
l. mariani s. papagiannakis and m. pezz e. compatibility and regression testing of cots component based software.
in icse pages .
ieee computer society .
l. mariani and m. pezz e. behavior capture and test automated analysis of component integration.
in iceccs pages .
t. t. nguyen h. a. nguyen n. h. pham j. m. al kofahi and t. n. nguyen.
graph based mining of multiple object usage patterns.
in esec sigsoft fse pages .
a. pnueli.
linear and branching structures in the semantics and logics of reactive systems.
in icalp volume of lncs pages .
springer .
m. pradel and t. r. gross.
automatic generation of object usage specifications from large method traces.
in ase pages .
ieee computer society .
j. quante and r. koschke.
dynamic protocol recovery.
in wcre pages .
s. shoham e. yahav s. fink and m. pistoia.
static specification mining using automata based abstractions.
in issta pages .
g. sibay s. uchitel and v .
a. braberman.
existential live sequence charts revisited.
in icse pages .
w. m. p. van der aalst.
process mining discovery conformance and enhancement of business processes .
springer .
m. y .
vardi.
branching vs. linear time final showdown.
in tacas volume of lncs pages .
springer .
n. walkinshaw and k. bogdanov.
inferring finite state models with temporal constraints.
in ase .
a. wasylkowski and a. zeller.
mining temporal specifications from object usage.
autom.
softw.
eng.
.
j. yang d. evans d. bhardwaj t. bhat and m. das.
perracotta mining temporal api rules from imperfect traces.
in icse pages .