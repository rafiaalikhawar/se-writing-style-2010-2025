efficient data race prediction with incremental reasoning on time stamped lock history malay k. ganai nec labs america princeton usa abstract we present an efficient data race prediction algorithm that uses lock reordering based incremental search o n time stamped lock histories for solving multiple races eff ectively.
we balance prediction accuracy coverage and performance with a specially designed pairwise reachability algorithm that can store and re use past search results thereby amortizing t he cost of reasoning over redundant and overlapping search spa ce.
compared to graph based search algorithms our algorithm incurs much smaller overhead due to amortization and can potentially be used while a program under test is executing.
to demonstrate such a possibility we implemented our approac h as an incremental p redictive a nalysis ipa module in a predictive testing framework.
our approach can handle traces with a few hundreds to half a million events and predict known unknow n real data races with a performance penalty of less than in addition to what is incurred by runtime race detectors.
i. introduction concurrent programs often have bugs that are exposed only by certain interleavings.
even for a single test input systematic exploration of all possible interleavings is al most impractical making concurrency testing a real challengin g problem.
predictive testing appears more promisin g in managing exploration of such large interleaving space and discovering hard to find concurrency bugs often misse d by race detection techniques such as .
the idea is to observe a given execution trace of the program under test and then predict alternate interleavings i.e.
re o rdering of observed trace events that are more likely to contain scheduler dependent bugs such as data races atomicity violations order violations mismatched communication an d deadlocks.
search engines for prediction i.e.
to find such witnessinterleavings aretypicallybasedonlight weigh tstatic analysis and usually are made tractable by employing sever al pruning and approximation techniques.
pairwise reachability problems checking if a pair of threads can simultaneously be at a given pair of respective threadlocations oftenariseduringpredictivetestingof multithreadedprograms.fore.g.
checkingatomicityviolation data races mismatched communication and non determinism can be reduced to solving multiple pairwise reachability probl ems that can arise at the rate of 104per second in a typical run of a real multi threaded application as observed in our experiments .
clearly such a volume of reachability check s would also increase the total end to end time for predictiv e testing that includes several tasks recording identifyi ng target pairs solving pairwise reachability generating witn esses and validating the results.
in general reasoning techniqu es typically make trade offs between accuracy coverage and performance to manage concurrency testing effectively.in this paper we focuson designinglight weightsearch and pruning techniques that can solve a large volume of pairwise reachability problems effectively by avoiding the repeti tive search over redundant and overlapping space.
we have set a multi dimension goal with our unique search approach a we aim to improve performance compared to graph based predictiveanalysissuchas althoughwearewillingtoi ncur small performance penalty over runtime race detectors b we aim to improve accuracy and coverage over race detectors while achieving similar accuracy and cover age as c we aim to support applications that may also use non nesting locking i.e.
a lock that is first acquired i s notreleased last .
ultimately we aim to improve end to end predictive testing performance.
a. basic idea pairwise reachability problem .
given two threads ta tb with time stamped lock histories tlh ha an bracketle ta1 am an bracketri ht andhb an bracketle tb1 bn an bracketri ht where ai biare lock events i.e.
acquires and releases .
assume that the threads are current ly at locations aand b respectively.
the goal is to show that the location pair a b is reachable along a consistent sequence that satisfies locking and causal ordering start ing from a1 b1 in a most effective way .
we will assume a b are not causally ordered.
further locksets i.e.
sets of l ocks held by each thread at a b i.e.
ls a andls b respectively are mutually exclusive ls a ls b otherwise a happens before analysis or lockset analy sis would detect a b pairwise unreachable.
example.
in the sequel we use the following running example to illustrate our approach.
two threads taandtb with various events are shown in figure .
tlhs comprise only lock events such as ai bibut not other events such as wait notify.
we also use ai bjto denote the thread locations of corresponding tlh events.
for e.g.
the thread at locatio n a2has completed lock ta l3 ata1.
we do not separately identify locations of non lock events but use the location s of the immediate lock events preceding it.
for e.g.
we use a10 to denote the location of write x event that occurs between two lock events a10anda11.
l1is a re entrant lock in thread tb.
for such a re entrant case we record the outer lock unlock events at b1 b4 and ignore the nested ones.
the waitevent after b3 is synchronized with the notifyevent after a2 by signal s. we show the locksets at each thread location as the tuple of boolean values an bracketle tlh0 lh3 an bracketri htwherelhi 1if and only if lock liis heldby the thread.for e.g.
lockset an bracketle t0 an bracketri htat location a3denotesl2 l3are held by thread ta.
.
c ieee ase palo alto usa37 lockset threadta threadtb lockset an bracketle t0 an bracketri hta1.lock l3 b1.lock l1 an bracketle t0 an bracketri ht an bracketle t0 an bracketri hta2.lock l2 b2.lock l3 an bracketle t0 an bracketri ht an bracketle t0 an bracketri htnotify s b3.unlock l3 an bracketle t0 an bracketri ht an bracketle t0 an bracketri hta3.unlock l3 wait s an bracketle t0 an bracketri ht an bracketle t0 an bracketri hta4.lock l1 lock l1 ignore nested an bracketle t0 an bracketri hta5.unlock l2 unlock l1 re entrant un lock an bracketle t0 an bracketri hta6.lock l2 b4.unlock l1 an bracketle t0 an bracketri ht an bracketle t0 an bracketri hta7.unlock l1 b5.lock l3 an bracketle t0 an bracketri ht an bracketle t0 an bracketri hta8.lock l0 b6.lock l2 an bracketle t0 an bracketri ht an bracketle t1 an bracketri hta9.unlock l2 b7.lock l0 an bracketle t0 an bracketri ht an bracketle t1 an bracketri htwrite x b8.unlock l3 an bracketle t1 an bracketri ht an bracketle t1 an bracketri hta10.lock l3 b9.unlock l0 an bracketle t1 an bracketri ht read x an bracketle t0 an bracketri ht b10.unlock l2 an bracketle t0 an bracketri ht an bracketle t1 an bracketri htwrite x write x an bracketle t0 an bracketri ht an bracketle t1 an bracketri hta11.
b11.
an bracketle t an bracketri ht fig.
events of threads taandtb.
our goal is to check the pairwise reachability of a10 b10 a10 b11 a11 b10 and a11 b11 corresponding to various data races on variable x i.e.
write read write write writeread and write write respectively.
considerana veapproachtocheckthepairwisereachabili ty of a10 b10 .
conceptually it involves traversing a lockset graph lg built using the events in the lock history of each thread as shown in figure for threads taandtb.
we use li ulito denote the lock unlock of the lock object liresp.
for now assume a3 b4 is pairwise reachable.
we first compute lockset at each thread location.
a pair of thread locations ai bj with locksets ls ai andls bj resp.
is unreachable if the locksets intersect.
the lg is quadratic i n the size of lock histories i.e.
o m n wherem nare the sizes of lock histories of respective threads.
the na ve approach solves the pairwise reachability by finding a consistent sequence i.e.
a sequence of tlh events satisfying locking discipline and causal ordering starti ng from a3 b4 to a10 b10 .
it can find such a sequence if and only if the pair is reachable.
a simple depth first search strate gy would require o m n re ordering steps.
a3 b4 l3 a4 b4 a5 b4 a10 b4 a6 b4 a3 b10 ul1 l2 l0 ul3 ul0ul3 l2 ul1l1 ul2 a3 b5 a3 b6 a3 b7 a3 b8 a3 b9 l0 ul2 a7 b4 a8 b4 a9 b4 g898 g62 g1005 g899 g923 g271 g1008 g898 g62 g1007 g853 g62 g1006 g899 g923 g258 g1007 g898 g62 g1006 g899 g923 g258 g1008 g898 g62 g1006 g853 g62 g1005 g899 g923 g258 g1009 g898 g62 g1005 g899 g923 g258 g1010 g898 g62 g1005 g853 g62 g1006 g899 g923 g258 g1011 g898 g62 g1006 g899 g923 g258 g1012 g898 g62 g1004 g853 g62 g1006 g899 g923 g258 g1013 g898 g62 g1004 g899 g923 g258 g1005 g1004 g898 g899 g923 g271 g1009 g898 g62 g1007 g899 g923 g271 g1010 g898 g62 g1006 g853 g62 g1007 g899 g923 g271 g1011 g898 g62 g1004 g853 g62 g1006 g853 g62 g1007 g899 g923 g271 g1012 g898 g62 g1004 g853 g62 g1006 g899 g923 g271 g1013 g898 g62 g1006 g899 g923 g271 g1005 g1004 a11 b11 a3 b11 ul2 g898 g899 g923 g271 g1005 g1005 a11 b4 g898 g62 g1004 g853 g62 g1007 g899 g923 g258 g1005 g1006l3 a6 b11 a5 b11 a4 b11 a7 b11 a8 b11 a9 b11 a10 b11 a11 b5 a11 b6 a11 b7 a11 b8 a11 b9 a11 b10 a10 b10 g100 g258 g396 g336 g286 g410 g3 g393 g258 g349 g396 g400 fig.
check reachability of target pairs a10 b10 a10 b11 a11 b10 a11 b11 .
preview of our approach.
given multiple pairwise reachability problems our primary goal is to find for each pair aconsistentsequenceofthetlheventsifandonlyifoneexist s. we solve them without traversingor constructingthe comple te lockset graphs and achieve almost linear time complexity in the length of tlhs by amortizing the search cost over multiple problems.
we designed a search algorithm that improves the na ve algorithmby employingvariouspruningand incrementalste ps to reduce the amortized cost of reasoning over redundant and overlapping search space.
loosely speaking redundancies in search space occur due to independentlock events i.e.
eve nts that do not conflict while overlaps in search space occur du e to overlapped tlhs of multiple pairwise reachability problems.
specifically we take the following steps for checking multiple pairwise reachability problems reduce the effective length of tlhs by selecting a suitable starting pair.
for given tlhs ha an bracketle ta1 am an bracketri ht and hb an bracketle tb1 bn an bracketri ht we identify a suitable reachable pair astart bstart to start the search where astart an bracketle ta1 am an bracketri ht andbstart an bracketle tb1 bn an bracketri ht.
such a selection reduces the search complexity to o a b where a bare the lengths of the reduced sequence an bracketle tastart am an bracketri htand an bracketle tbstart bn an bracketri ht respectively.
identify and avoid inconsistent sequences .
we will not explore those sequences that do not satisfy locking discipline.
for e.g.
a sequence an bracketle ta6 b6 a7 an bracketri htwill not be explored as tais holding l2at location a7.
identify and avoid redundant sequences w.r.t.
consistent space.among those sequences that are equivalent we will explore only one.
our choice of the sequence will be guided by the reduction in the inconsistent search space.
consider a reachability target pair a10 b10 starting from a3 b4 .
for that search space suppose sequences 1 an bracketle ta6 a b5 an bracketri htand 2 an bracketle tb5 a6 a an bracketri htare equivalent where arepresents a sequence of tlh events of thread ta and represent a sequence of tlh events of any thread.
then we explore only the sequence 2andnot 1. the choice of 2 however is driven by a key insight ref.
lemma that whether 1 2are equivalent or not if 1is consistent then 2is also consistent.
the other way argument may not hold if they are not equivalent.
here is a simple explanation.
the lock l3is not acquired or released by tabetween locations a5anda10.
therefore if 1is consistent then 2obtained after re ordering b5 beforea6will also be consistent.
incrementalsearchtoamortizethecostformultiplechecks .
for checking reachability of multiple pairs we find that the corresponding tlhs often overlap.
to avoid repetitive search one can store and re use previous search results and thereby reduce the redundancy and consistency checks during re ordering.
for e.g.
there are significant overlap s of tlhs of target pairs a10 b10 a10 b11 a11 b10 a11 b11 starting from a3 b4 .
instead of re the entire search for each pair we selectively store the intermediate results while targeting a pair and re use them for the other target pairs.
we show later that we can reduce the number of re ordering steps from number of edges in lockset graph to 8for38the target pair a10 b10 .
when we target all four pairs using our incremental search we can reduce the total number of re ordering steps to 21from446 sum total of all edges in lg for each target .
we summarize and highlight our key contributions in the following key idea.
we present anefficient racepredictionalgorithm thatuseslock reorderingbasedsearchontime stampedloc k histories.
we aim to reason multiple pairwise reachability problems arising during predictive testing of multi threa ded programs by finding for each pair a consistent sequence satisfying locking discipline and causal ordering if and on ly if one exists.
in our search strategy we store and re use pas t search results and thereby amortize the cost of reasoning over redundant and overlapping search space.
in terms of accuracyandcoverage weclaimsimilarlyasingraph based approach i.e.
under data abstraction our approach guarantees no false positive or no false negative but not both for a three or more threaded concurrent program and guarantees no false positive and no false negative for a twothreaded program.
keybenefits.
ourapproachsupportsvariouslockingstyles as used in real programs where locks can be acquired or released in any manner recursive non nested or nested.
i n terms of performance cost although the worst case search complexity of our approach is quadratic in the length of the tlhs in practice the effective running cost is linear in th e length of tlhs due to amortization.
key differentiators.
our search strategy has many key differentiating benefits which are not easily achievable b y smt based and graph based search engines .
it supports effective pruning of redundant and inconsistent interleavings.
it enables incremental se arch which is a much coveted feature for solving frequently arising multiple pairwise reachability problems.
it incur s comparatively low overhead and ideally suited for predictive testing.
thus one may also use our search technique at runtime testing when a program is executing.
proof of concept.
we implemented our approach as an incremental p redictive a nalysis ipa module in an x86based binary predictive testing framework.
we apply the ipamodule while the program under test is executing.
in our experimentation with various publicly available c c java applications we demonstrate its efficacy in handling traces with a few hundreds to half a million events and predicting known unknown real data races and generating witness interleavings that can be validated by a n independent replayer.
our approach incurs a performance penalty of less than in addition to what is incurred by race detectors imprecise but fast based on lockset and happens before analysis.
in a separate controlled study w e also evaluated the benefits of incremental search over nonincremental and found that the former can give orders of magnitude improvement over the latter.
b. related work the related work can be categorized as race detection techniques such as fuzzing based runtime testing predictive analysis dynamic model checking and staticdata race analysis .
most runtime testing techniques i.e.
techniques used whi lea program under test is executing use a lockset based ana lysis ahappens beforeanalysisbasedonvectorclocks or a combination of both for detection o f data races.
a lockset based analysis tracks a set of locks i.e.
lockse ts currently held by each thread.
pairwise reachability betwe en the current thread locations is inferred when locksets at th ose locations are disjoint which can be checked in o l time l number of locks .
in general this technique can give false positives i.e.
spuriousreachability asit failst o consider the causal ordering of synchronization events.
a happens before analysis is often used in conjunction with lockset analysis to improve accuracy.
it use s vector clocks to order inter thread synchroniza tion events such as lock unlock wait notify etc.
pairwise rea chability is inferred when the vector clocks at a pair location arein comparable i.e.
not ordered which can be checked in o t t number of threads .
for checking data races the vector clock of the current memory access is compared against that of the last observed memory access of the same memory location and at least of the accesses is write .
a pure happens before analysis such as however can miss a data race due to enforcing an inter thread order between non causally ordered events such as unlock lock events.
in practice a hybrid approach is often used where ordering between unlock lock is not strictly enforced the reby more races are detected than by a pure happens before analysis.
to avoid potential false positives the ordering betw een unlock lock events is relaxed only if a read after write or der is not violated.
in to overcome the non linear search i t processes events in the order as observed and uses sliced causality induced ordering and lockset based criteria to i nfer races.
in a notion of causal precedesrelation weaker than happens before was used to guarantee no false positive und er the assumption of nested locking.
to search for consistent i.e.
feasible schedules for the detected race candidate s and avoid the search for all permutations o k t k number of observedevents variousadhoc schemes such as fixed window sizes are employed to achieve linear scalability.
to overcome the imprecision of lockset based analysis and thereby improve the accuracy of data race analysis lock histories lh are used albeit at a higher cost.
for nested locks it was shown that pairwis e reachability can be reasoned in o m n wheremandn are the number of lock unlock events in the history of the respectivethreads.particularly an atomicitycheckingt ool was proposed that used data abstraction under nesting locki ng for reasoning pairwise reachability.
for non nested locks it was shown that pairwise reachability can be reasoned in o t m where m is the maximum length of the synchronization events such as lock unlock and wait notify.
it involves building a univer sal causality graph ucg using various synchronization event s and checking if it is acyclic.
each directed edge in the graph corresponds to happen before induced by wait notify events and potential race events.
a cycle in the graph implie s infeasibility however absence of a cycle does not imply feasibility of a consistent sequence of lock events in gener al.
for a two threaded program it was shown that acyclicity is both a necessary and sufficient condition for reasoning39table i comparing tools for predictive testing.
jpredictor penelope ucg pecan best cp exceptionullfeatures ipa prediction hybrid hb lhgraph based lhsmthybrid hb smttlh search scope ppf pfppf partial full trace data abstraction noyesyes yesyes noyesyes non nested locks nonoyes noyes noyesyes incremental search nonono nonononoyes coverage on relative scale more means better coverage pairwise reachability under data abstraction.
however fo r a program with more than two threads acyclicity was shown to be only the necessary but not the sufficient condition i. e. a false positive may occur.
to improve accuracy of prediction yet further more heavyweight approaches such as sat smt based symbolic analysis are proposed.
although a symboli c analysis can provide better precision and prediction its h igh overhead prohibits its use for traces of sizes more than tens of thousands.
to reduce the analysis cost some methods use a fixed size exploration window bounded search for reordering events some others use a restrictive form of lock synchronization nested locks only wh ile some use a fixed number of read write pairing combined with smt analysis all of which can lead to false positives and or false negatives.
the graph based analysis is inherently non incremental as the acyclic check is done on a graph built specifically for each problem instance moreove r it deduces synchronization induced edges indirectly fur ther adding to the analysis cost.
clearly these search engines a s such are not geared for incremental reasoning of multiple problems frequently arising during a run of a real applicati on with a general locking scheme.
in table i we compare qualitatively state of the art predictive analysis tool s against our tool ipa.
dpor based approaches explore interleaving space by executing each interleaving while ipaexplores the space using light weight static analysis.
unlike dpor ipauses lookahead to check if both ordering need to be explored to avoid inconsistent redundant interleavings.
ipais goal directed stateful and incremental while dpor is pa thcoverage directed stateless and systematic.
outline we provide necessary background in section ii and present our approach in section iii.
we discuss our experiments in section iv proofs in section v and conclude in section vi.
ii.
preliminaries a multi threaded program consists of a set of concurrently executing threads t each thread with a unique identifier t. the threads communicate with shared objects some of which are used for synchronizationsuch as locks and signals.
a tra ce of a program is a total ordered sequence of observed events corresponding to various thread operations on shared objec ts.
eachevent eofthe sequence i.e.
e iscarriedoutbysome thread denoted as tid e at a thread location loc e .
these events include the following write read t x write read by ton memory object x lock unlock t l acquire release by ton a lock l wait notify t s wait notify by ton a signal s fork t t thread start t tforks a thread t join t t thread end t twaits until t ends letc loc e andc loc e .
we say the pair c c ispairwise reachable iff the respective threads can be at thoselocationssimultaneously.thecorrespondingevents e e however may not be enabled simultaneously.
when obvious fromthecontext weuse e e toreferthelocationpair c c .
a pair of read write accesses on the same shared object isconflicting if at least one of the accesses is write.
a data raceoccurs when the memory accesses by two threads are conflicting and the access locations are pairwise reachabl e. happens before .
given a program trace ande e we sayemayhappens before e i.e.
e precedesequale ifeisobserved beforee in the trace.
notably ecompletes beforee .
we say emusthappens before e causally ordered i.e.
e e if e precedesequale holds and one of the following holds e e are in thread program order i.e.
e poe e notify t s ande wait t s t ne ationslash t e fork t t ande threadstart t t ne ationslash t e join t t ande threadend t t ne ationslash t e1 .
e e1 precedesequale or e2 .
e precedesequale2 e in the sequel we use happens before or hb to denote must happens before relation unless otherwise stated.
alinearization ofa giventrace is a permutationofevents such that causal ordering of events are preserved.
we identify the events wait threadstart andjoinas blocking events and the events notify fork andthreadendas the respective unblocking events .
for correct synchronization a thread has to be in a blocked state by initiating one of the blocking events ebkbefore the matching unblocking eventeuk unblocks it andthe unblocking event completes before the blocking event.
we use ub to denote the happensbefore relation between the matching unblocking event euk and blocking ebkevent i.e.
euk ubebk.
a happens before relation can be maintained easily using vector clocks .
the relations ubcan be checked simply by comparing the time stamps i.e.
the vecto r clocks oftheevents.foraconcurrentprogramwith tthreads such a check would cost o t comparison.
we use e e todenotethat e e arein comparable i.e.
e ne ationslash e e ne ationslash e.this occurs if and only if the events e e do not have an observed unblocking blockingsynchronization in between.
a neces sary condition for e e to be pairwise reachable is e e .
write read dependency .
we say two events e write t x ande read t x have write read dependency ift ne ationslash t e precedesequale andeis the last write to xbeforee .
we refer to a linearization obtained without considering write read dependency on non synchronization memory objects asdata abstraction .
in this work we consider linearization based on data abstraction although one can include suc h dependencybyenforcinghappens beforeorderingbetweent he memory accesses.
note including write read dependency ca n eliminate infeasible linearization but may miss feasible ones.
locking.
innested locking all locks follow a simple rule a lockthatis first acquiredisreleasedthe last.
a lockingsch eme that does not follow the nesting rule is often termed as nonnested locking .
in this work we consider the general form of40locking i.e.
re entrant nested and non nested.
for re entrant lockswhere lock can be acquired by a thread multiple times without releasing we record the first lock and the last unloc k operations for each re entrant lock.
alocksetis a set of locks held by a thread at location c denoted as ls c .
when c loc e we use ls c and ls e interchangeably.
a necessary condition for e e to be pairwise reachable is that ls e ls e .
time stamped lock history tlh given a thread taat its current location a a time stamped lock history denoted as ha an bracketle ta1 a2 am an bracketri htis a thread order sequence of observed lock unlock events referred henceforth as tlh events whe re each event is tagged with a time stamp maintained using vector clocks and amis the last such event before a. a happens before ordering between tlh events of two threads can be checked using time stamps in o t time.
we usenext e prev e to denote the next previous tlh event w.r.t.
an observed event e respectively.
for e.g.
a2 next e where e a1 or a1 poe poa2 .
similarly a1 prev e where e a2 or a1 poe poa2 .
consistent sequence we say a total ordered interleaved sequence of tlh events is consistent iff the following two conditions are satisfied a between any two consecutive lo ck events there is an unlock event on the same lock object by a thread the first lock i.e.
mutual exclusion and b tlh events follow the happens before ordering i.e.
causal ordering .
if a b is pairwise reachable and there exists a consistent sequence of tlh events starting from a b such that inter thread events a b are adjacent in the sequence then we say a b i.e.
loc a loc b is also pairwise reachable .
the reasoning of pairwise reachability is then reduced to checking existence of such a consistent sequence from previously established known reachable pai rs.
equivalency two sequences of synchronization events an bracketle te1 ei ei en an bracketri htand an bracketle te1 ei ei en an bracketri htareequivalent ifei ei 1do not occur on the same synchronization object.
the rule can be applied transitively to show equivalency.
iii.
ourapproach as mentioned before our primary goal is to show that there exists some consistent sequence of tlh events without constructingortraversingtheentirelocksetgraph.speci fically we take the following steps for checking multiple pairwise reachability problems reduce the effective length of tlh by selecting a suitable starting pair that is also pairwise reachable.
identify and avoid redundant and inconsistent sequences.
incrementalsearchtoamortizethecostformultiplechecks .
predictive testing .
before we delve into details we present an overview of predictive testing using incremental predic tive analysis ipa as shown in figure .
during the execution of a program under a given test input the recorder observes various synchronization events as they occur.
the module check reachperforms reasoning of pairwise reachability and may not wait for the recording of the full trace.
for data race checking it is invoked whenever a read write even t occurs and each such access is then paired with the observed conflicting reads writes.
it first prunes away non racy pair s using lockset ls and happens before causal ordering hb analysis before applying tlh analysis as discussed next.
g90 g286 g272 g381 g396 g282 g286 g396 g62 g94 g3 g1085 g3 g44 g17 g3 g4 g374 g258 g367 g455 g400 g349 g400 g100 g62 g44 g3 g4 g374 g258 g367 g455 g400 g349 g400 g894 g282 g381 g890 g400 g286 g258 g396 g272 g346 g895 g449 g349 g410 g374 g286 g400 g400 g3 g400 g272 g346 g286 g282 g437 g367 g286 g90 g286 g393 g367 g258 g455 g258 g271 g367 g286 g845 g87 g396 g286 g282 g349 g272 g410 g349 g448 g286 g3 g100 g286 g400 g410 g349 g374 g336 g455 g286 g400 g374 g381 g381 g271 g400 g286 g396 g448 g286 g282 g3 g286 g448 g286 g374 g410 g400 g454 g1012 g1010 g3 g3 g17 g349 g374 g258 g396 g455 g3 g3 g3 g3 g3 g1085 g3 g100 g286 g400 g410 g3 g282 g258 g410 g258 g349 g87 g4 g894 g18 g346 g286 g272 g364 g890 g396 g286 g258 g272 g346 g895 fig.
predictive testing with ipa.
the search module generates witness schedules for a post ru n validation with an independent replayer that reports wheth er the schedule was replayable or not.
procedure check reach check pairwise reachability 1input given tlhs ha an bracketle ta1 am an bracketri htandhb an bracketle tb1 bn an bracketri htof threads taandtb with their current events aand b respectively.
2goal check if a b is pairwise reachable.
3output success fail check hb criteria 6if a b or b a return fail check lockset criteria 8if ls a ls b ne ationslash return fail ref.
section iii a 11let astart bstart be the start tlh event pair.
12letelbe a snapshot of tlh events ref.
eqn search pairwise reachability from astart bstart 15return dosearch astart bstart a b we now describe the procedure check reach.
basic check lines .
we check if the pair a b has a causal ordering or an intersecting locksets.
if any of the criteria holds we return faildenoting unreachability.
this step is similar to runtime race detectors such as .
identify start tlh event pair lines .
we first identify a pair astart bstart whereastart an bracketle ta1 am an bracketri ht and bstart an bracketle tb1 bn an bracketri htto start the search.
evidently such a pair could reduce the search complexity to o a b where a bare the lengths of the reduced sequence an bracketle tastart am an bracketri ht and an bracketle tbstart bn an bracketri ht respectively.
to identify such a starting pair we use a snapshot i.e.
collect a set of lock events per thread whenever an unblock event occurs discussed more in section iii a .
since the pair is observed reachable we can guarantee no false positive.
search for reachability line .
we invoke a recursive procedure dosearch table iii to search for a consistent sequenceofthe tlh eventsin ha hbfrom a b to a b .
we discuss more in section iii b. we have two contrasting strategies complementary in strengths strategy i andstrategy ii .
instrategy i we ignore tlhs of the remaining threads ne ationslash ta tb .
in this strategy if failisreturned thepairisguaranteedunreachable theorem however if success is returned the pair may be unreachable false positive .
in strategy ii we consider the tlhs of remaining threads to guarantee the pairwise reachability if success is returned theorem .
however iffailis returned the pair may still be reachable false negative .
for two threads the results of strategy i or strategy ii is guaranteed i.e.
a success result implies41reachability and a failresult implies unreachability theorem .
the search complexity of either strategy i or strategy ii iso a b .
a. selecting start tlh event pair consider two threads taandtbat their current locations aand b respectively and their respective tlhs ha an bracketle ta1 am an bracketri htandhb an bracketle tb1 bn an bracketri ht figure .
we identify events using the following legends a dotted box for a shared read write event an unfilled box for a block unblock event and a filled box for a lock unlock event.
leteukandebkbe the matching unblocking and blocking events between taandtb resp.
in the example eukis a notify event atta andebkis a wait event at tb.
leta bdenote the respective thread locations of these events i.e.
a loc euk andb loc ebk .
leta b denotenextthread locations after these events occurred.
lemma1 the pair a b is pairwise reachable.
proof.
for correct synchronization the blocking operatio n ebkhas to block the thread before the unblocking event eukof the otherthreadoccurs.however as eukcompletesbefore ebk a b has to be pairwise reachable.
as tbgets unblocked a b becomes pairwise reachable.
one can show that a b and a b are pairwise unreachable.
squaresolid letai bj be the next lock eventof ta tb aftera b resp.
and euk ebkbe the last matching unblocking blocking events between taandtbresp.
in a run.
lemma2 the pair ai bj is pairwise reachable under data abstraction.
proof.
follows from lemma and our assumption that euk ebkare the last matching unblock block events.
squaresolid we select ai bj as the starting lock event pair.
note ifa b locationscorrespondto lockeventsi.e.
a loc ai andb loc bj left of fig.
then clearly ai bj is also pairwise reachable as per lemma .
in the running example we select a3 b4 as the starting pair as the last matching notify wait pair occur just before that.
although the above case is not common typically what we found is that for a matching wait notify pair such as in pthread cond waitandpthread cond signal b is a location of a locking event which is eventually enabled by an unlocking event ewhere e ai or ai poe .
in such a case ai bj is also pairwise reachable.
how to select a start tlh event pair if there is no matching unblock block events between taandtbso far in the run?
we illustrate the case in figure right where there are no matchingunblock blockeventsbetween ta tb.notethatsucha situationcan onlyoccurwhenthereare morethan two threads .
letebkdenote the last blocking event by tdw.r.t.
aand bin the observed run and let eukdenote the corresponding unblocking event by tc.
letsnapshot1denote a set of lock events one per thread recorded at the instant eukcompletes.
1we use a global lock to take a snapshot.
a snapshot can be taken at any moment however we take it at the synchronization eve nts such as blocking unblocking.
the argument is that these synchro nization points between threads are chosen by developers and they are inten ded to occur deterministically at those program points.bel bnceltb tc b1 c1 blast unblock block events deltd d1 ael amta a1 aeukebk elaia a b b wait a loc notify a loc after notify b loc wait b loc after wait for matching wait notify events a b a b are pairwise reachable a b a b are pairwise unreachable.ai ambj bj bnta tb a1 b1 ablast unblock block eventslock unlock eventsblock unblock eventsshared read write events euk ebk notify fig.
example to illustrate start pair selection left matchin g unblock block events occur between ta tb right no matching unblock block events occur between ta tb.
given the set snapshot we obtain a set elof tlh events as follows el le le next e wheree snapshot as shown in right of figure we obtain el ael bel cel del corresponding to euk.
depending on our strategy we select the start pairs2as follows strategy i we use a1 b1 as the starting pair in our search for reachability.
it is a conservative choice to guar antee no false negative for a given run.
strategy ii we use ael bel as the starting pair.
as per lemma ael bel is pairwise reachable.
we also compute and use the set elfor both cases shown in figure to consider possible interference due to the other threads an d thereby guarantee no false positive under data abstractio n. b. search for reachability and witness generation the recursiveprocedure dosearch shownin table iii is used to check the pairwise reachability of a b from a b and to find a consistent sequence if and only if it is reachable .
if it finds one it will return success otherwise it will return fail.
each recursive call corresponds to a traversal of an edge in lg graph figure .
note a return with failin a nested sub procedure indicates the search is not over yet.
foreaseofreadabilitywedividedthechecksin dosearch into three groups a b and c. a check in each group determines what action to be taken when the check condition holds.
if a check condition does not hold the check listed in the following row is applied.
for e.g.
if vc revisit check listed in row succeeds then the recursive sub procedure returnsfail otherwise the check in the next row i.e.
tc terminal check is applied.
the checks make at most one recursive call and are intended to prune the search by avoiding inconsistent and redundant recursive calls.
in th e worst case when none of the conditionsin checks holds dosearchwill be called on a next b and next a b .
for incrementalsearch we also recorda subset of reachable pairs as established during the search in a set incpairs.
we mark those checks with shown in 3rd column table iii to indicate that the pair a b will be stored for a potential start pairs.
we will discuss more in section iii c. 2we assume that there is no established reachable pair by our p revious search otherwise we select that as the start pair.42witness generation is quite straightforward.
it basically involvesconcatenationoftwosequences onethatestablishe sthe reachability of start tlh pair i.e.
a b which could be the prefixoftheoriginaltraceorapreviouslyestablishedsequ ence to reach a b and the other that shows the reachability of a b from a b .
table ii a run of check reachon reachability of a10 b10 .
visited pairsnext pair checkavoided pairsincpairs a3 b4 a4 b5 rc3 a3 b5 a4 b5 a4 b5 a5 b5 rc4 a4 b6 a4 b5 a5 b5 a6 b5 rc2 a5 b6 a4 b5 a6 b5 a6 b6 rc5 a7 b5 a4 b5 a6 b5 a6 b6 a7 b6 rc7 a6 b7 a4 b5 a6 b5 a6 b6 a7 b6 a8 b6 lcc4 a7 b7 a4 b5 a6 b5 a6 b6 a8 b6 a9 b6 lcc4 a8 b7 a4 b5 a6 b5 a6 b6 a9 b6 a10 b6 lcc4 a9 b7 a4 b5 a6 b5 a6 b6 a10 b6 a10 b7 lcc3 a4 b5 a6 b5 a6 b6 a10 b6 a10 b7 lcc2 a4 b5 a6 b5 a6 b6 a10 b6 a10 b7 example.
we illustrate a run of check reachin figure on checking reachability of a10 b10 starting from a3 b4 .
we use a to denote a visited unvisited pairs resp a to denote a start tlh event pair a thick thin arrow to show the visited unvisitededges resp.
a cross x to denoteth at the lockeventisdisabled.wealsoshowthelocksetsateachthre ad location.
in table ii we show the scenarios used for detecti ng corresponding cases where we avoid exploring both ordering of tlh events.
for now ignore the column with incpairs and distinction between bold and not bold pairs within the avoided pairs which we will discuss in section iii c. in the lattice of figure there are a total of 97edges but the procedure dosearchmakes only recursive calls i.e.
visited edges to show the pair a10 b10 unreachable.
c. incremental search the procedure dosearchcan be used incrementally for checking multiple pairwise reachability problems that ari se frequently during race detection especially when the pai rs underconsiderationshaveoverlappingtlhs.in the followi ng we discuss one such way that uses the visitedstate information and incpairsset of pairs gathered during calls to check reach checks marked with in table iii .
theincpairsis a subset of reachable pairs which are not required to be explored in the last call of check reach but may be required in future search due to new tlh events.
as shown in table ii some of the avoided pairs i.e.
not shown inbold may need to be explored.
we update the incpairs accordingly in rc4 rc5 rc7 lcc3 and lcc2 checks.
note those avoided pairs shown in boldare truly redundant and are not required to be re explored.
for e.g.
a4 b6 pair is not required for exploration in the last search due to rc4 check.
however with a new tlh event lock ta l3 ata10 we may need to re evaluate rc4 check for a future search.
therefore we update the set incpairswith a4 b5 .
assume that we invoke check reachfor given tlhs ha hbwhereha an bracketle ta1 am an bracketri htandhb an bracketle tb1 bn an bracketri ht starting from the pair astart bstart .
letnha nhbdenote the updated tlhs where nha ha an bracketle tam am an bracketri ht andnhb hb an bracketle tbn bn an bracketri ht.
assume that the starttlh event pair astart bstart used in the previous call a3 b4 l3 a4 b4 a5 b4 a10 b4 a6 b4 a6 b10 a5 b10 a4 b10 a3 b10 ul1 l2 l0 ul3 a7 b10 ul0ul3 l2 ul1l1 ul2 a3 b5 a3 b6 a3 b7 a3 b8 a3 b9 l0 ul2 a7 b4 a8 b4 a9 b5 a8 b10 a9 b10 a10 b10 g898 g62 g1005 g899 g923 g271 g1008 g898 g899 g923 g271 g1009 g898 g62 g1007 g899 g923 g271 g1010 g898 g62 g1006 g853 g62 g1007 g899 g923 g271 g1011 g898 g62 g1004 g853 g62 g1006 g853 g62 g1007 g899 g923 g271 g1012 g898 g62 g1004 g853 g62 g1006 g899 g923 g271 g1013 g898 g62 g1006 g899 g923 g271 g1005 g1004 g898 g62 g1007 g853 g62 g1006 g899 g923 g258 g1007 g898 g62 g1006 g899 g923 g258 g1008 g898 g62 g1006 g853 g62 g1005 g899 g923 g258 g1009 g898 g62 g1005 g899 g923 g258 g1010 g898 g62 g1005 g853 g62 g1006 g899 g923 g258 g1011 g898 g62 g1006 g899 g923 g258 g1012 g898 g62 g1004 g853 g62 g1006 g899 g923 g258 g1013 g898 g62 g1004 g899 g923 g258 g1005 g1004 lwait edge g28 g282 g336 g286 g400 g3 g410 g396 g258 g448 g286 g396 g400 g286 g282starting pair candidate start pair for future search visited pairunvisited pair g28 g282 g336 g286 g400 g3 g374 g381 g410 g3 g410 g396 g258 g448 g286 g396 g400 g286 g282 fig.
check reachability of a10 b10 .
ofcheck reachhas not changed.
we start the procedure dosearchonlyfrom the pairs in the set incpairs and use thevisitedstate information to avoid exploring the already visited pairs.
as each pair p incpairsis reachable from astart bstart the reachabilityfrom pimpliesthe reachability from astart bstart .
the main observation is that only the pairs in the set incpairsare required to be re checked as the redundancy conditions rc4 rc7 and terminal conditions might have changed due to the new tlh events.
if there exists a matching unblocking blocking events euk ebk that happens after am bn i.e.
am poeukandbn poebk or am poebkandbn poeuk we use tlh event pair next euk next ebk asthestartingpair ref.sectioniii a .
example.
we show how we incrementally check the reachability of pairs a10 b11 a11 b10 and a11 b11 as shown in the figure .
we start with the pairs in the set incpairs as shown in .
we avoid the nodes that are already visited shown with oval circle .
we explore the alternate paths from the pair a6 b5 as rc5 check fails due to the new eventlock ta l3 ata10.
similarly we explore the alternate path from the pair a6 b6 .
the newly explored edges and nodes are indicated in the figure.
we find that the pairs a10 b6 a10 b7 are deadlock states true if found using strategy ii under data abstraction theorem .
further we find that the pairs a10 b11 and a11 b11 are reachable indicating two write write races and that the pair a11 b10 is unreachable.
the incremental search makes recursive calls with a total of total calls for solving the four target pairs.
without incremental search but using our pruning as described in the previous section we would require calls.
without any pruning checks we would require recursive calls equal to the sum total of al l the edges in the lock order graphs one graph per target pair .
our incremental reasoning framework is geared for predictive testing with runtime analysis.
the key engineering challenge we solve in this work is to achieve similar accurac y and coverage of ucg approach andobtain comparable performance of runtime race detectors .43table iii checks in a recursive procedure dosearch a b .
if a check condition does not hold the next check in the row i s applied otherwise the corresponding action is taken as indicated i n the last column.
for checks mark with the pair a b is also stored in a set incpairsfor incremental search.
strategy ii includes all the checks while strategy i includes all but row .
checks in do search a b if the condition holds group type description return fail success or recurse 1vc revisit check if a b was previously visited returnfail 2tc terminal check if a b is a b i.e terminal pair returnsuccess a basic checks 3hb happens before check if a b return dosearch next a b 4hb happens before check if b a return dosearch a next b 5lcc1 deadlock check if threads ta tbdeadlocks returnfail b inconsistency checks6lcc2 stall check if one thread is waiting for a lock held by the other thre ad while all events in tlh of the other have been traversedreturnfail 7strategy ii check if strategy ii is selected and there exists a thread ne ationslash ta tbthat is waiting for a lock held at loc le or somele a b wherele elreturnfail 8lcc3 lock consistency check if a aornext a is disabled due to a lock held by tbatbreturn dosearch a next b 9lcc4 lock consistency check if b bornext b is disabled due to a lock held by taatareturn dosearch next a b 10rc1 redundancy check ifaislock l andbisunlock l andl ne ationslash l apply lemma return dosearch a next b 11rc2 redundancy check ifaisunlock l andbislock l andl ne ationslash l apply lemma return dosearch next a b c simplification checks12rc3 redundancy check if aisunlock l andbisunlock l andl ne ationslash l apply lemma return dosearch next a next b 13rc4 redundancy check if aislock l andbislock l andl ne ationslash l andunlock l ne ationslash an bracketle tb bn an bracketri ht apply lemma return dosearch next a b 14rc5 redundancy check if aislock l andbislock l andl ne ationslash l andunlock l ne ationslash an bracketle ta an an bracketri ht apply lemma return dosearch a next b 15rc6 redundancy check if aislock l andbislock l andunlock l ne ationslash an bracketle ta an an bracketri ht l l same or different apply lemma return dosearch a next b 16rc7 redundancy check if aislock l andbislock l andunlock l ne ationslash an bracketle tb bn an bracketri ht l l same or different apply lemma return dosearch next a b 17default no pruning when none of the above check holds return dosearch a next b or dosearch next a b iv.
experiment weimplemented ipamoduleinanx86binary basedpredictive testing framework figure .
at runtime the applicat ion binary and dynamically loadable libraries such as pthread are instrumented by a recorder module using pin a dynamic instrumentation tool.
the recorder observes various synchronization events such as wait notify lock unlo ck create start end join sem wait sem post and heap memory accesses.
in this experiment we evaluate our approach on reachability problems arising from predicting data races.
our implementation of hb and lockset analysis basic check procedure closely follow that of race detectors .
we did not experimentally compare with ucg as the known implementation is not engineered to handle so many reachability problems.
we experimented on a bit linux bo x with intel r cpu q6600 .4ghz with 4gb memory.
benchmarks evaluation .
we used multi threaded publicly available applications written in c c java with 1k33k loc.
we used gcc g gcj compilers to transform c c java programs to x86 binaries.
table iv gives a short description of these applications.
we ran two sets of experiments one to evaluate the performance of our approac h section iv a and second to compare incremental vs. nonincremental search section iv b .
a. pairwise reachability data race results we raneachapplicationwith differentthreadsettingsand or test inputs.
we evaluate performance of our online reasonin g in predictingdata races and reportresultsin table v. we us ed incremental search in this evaluation.
for each application column we provide trace information columns race results with hb lockset analysis columns race results with our check reach a3 b4 l3 a4 b4 a5 b4 a10 b4 a6 b4 a3 b10 ul1 l2 l0 ul3 ul0ul3 l2 ul1l1 ul2 a3 b5 a3 b6 a3 b7 a3 b8 a3 b9 lwait edge g28 g282 g336 g286 g400 g3 g410 g396 g258 g448 g286 g396 g400 g286 g282l0 ul2 a7 b4 a8 b4 a9 b4 g898 g62 g1005 g899 g923 g271 g1008 g898 g62 g1007 g853 g62 g1006 g899 g923 g258 g1007 g898 g62 g1006 g899 g923 g258 g1008 g898 g62 g1006 g853 g62 g1005 g899 g923 g258 g1009 g898 g62 g1005 g899 g923 g258 g1010 g898 g62 g1005 g853 g62 g1006 g899 g923 g258 g1011 g898 g62 g1006 g899 g923 g258 g1012 g898 g62 g1004 g853 g62 g1006 g899 g923 g258 g1013 g898 g62 g1004 g899 g923 g258 g1005 g1004 g898 g899 g923 g271 g1009 g898 g62 g1007 g899 g923 g271 g1010 g898 g62 g1006 g853 g62 g1007 g899 g923 g271 g1011 g898 g62 g1004 g853 g62 g1006 g853 g62 g1007 g899 g923 g271 g1012 g898 g62 g1004 g853 g62 g1006 g899 g923 g271 g1013 g898 g62 g1006 g899 g923 g271 g1005 g1004 a11 b11 a3 b11 ul2 g898 g899 g923 g271 g1005 g1005 a11 b4 g898 g62 g1004 g853 g62 g1007 g899 g923 g258 g1005 g1006l3 last visited pairstarting pair candidate start pair for future search visited pairunvisited pair g28 g282 g336 g286 g400 g3 g374 g381 g410 g3 g410 g396 g258 g448 g286 g396 g400 g286 g282 fig.
check reachability of pairs a10 b11 a11 b10 a11 b11 incrementally.
table iv short description of multi threaded applications.
apps description ver loc lang account a concurrent handler for banking transactions java .
aget a parallel http download accelerator aget .
.2k c .
alsa a pcm player for unix linux using alsa library alsapla yer0.
.
33k c .
axel a concurrent replacement of wget axel .0b .1k c .
bzip a parallelizer of bzip2 for smp bzip2smp .
.4k c elevator an elevator application java .
proz an http ftp downloader with multiple connections to multip le servers prozilla .
.
.7k c .
tsp a concurrent solver for traveling salesman problem java .44table v pairwise reachability predicting data races .
trace information race w hb lockset race w check reach i race w check reach ii racy src lines apps events vars hb timehb ls timeovhdhb ls timeovhdpredtrueupper nmelecemvlvcvhbls sec tlhcalls sec tlhcalls sec racesracesbound 1238917k12532661831839.
.
.
.
.25511account719916k72820687879.
.
.
.
.
.
.
.
.
.0444aget11684144020535121k9k4.
9k84k4.
.
9k77k4.
.
64k28164558135732227110.
.
.
.
.6362638alsa64k25924758335742937910.
.
.
.
.
.
.
.
.
.3333033axel1111323610212519609604.
.
.
.
.
4507k357361k5552k52k19.
.
.
.
.20053bzip8506k3511361k5552k52k19.
.
.
.
.
443318k443202393910.
392k10.
.
.2k10.
.6111elevator533018k7432310262610.
261k10.
.
181k10.
.
.
.
.
.
.2444proz13614711322494920198558015.
.
.
.
.
tsp 6141k18k927k231413m10k40.
10k630140.
.
.
.
using strategy i columns race results with our check reachusing strategy ii columns and number of source line races columns .
wealsoobservedthatmanypredictedraces column20 are instances of multiple races of the same source lines execute d in the same different threads.
to focus on unique source lev el races that programmers would care to know and eventually fix we project reachable pairs i.e.
predicted data races a s shownin columns12 onuniquepairsof sourcelines i.e.
x86 instruction addresses .
the results are as follows pred the number of projected pairs found using strategy ii and reported in column true the number of replayable pred pairs indicating presence of malign benign bugs and upper the number of projected pairs found using strategy i and reported in column .
we did not report similar counts for hb ls analysis as these are the same or more than upper as the dynamic counts of hb ls analysis are same or more than that of strategy i .
the description of remaining columns are as follows trace information columns .
the trace characteristics ofeachrunareasfollows thenumberofthreads n thenumber of shared memory events me the number of lock events le the number of communication events blocking unblocking ce the number of shared vars mv the number of lock vars lv and the number of communication vars cv.
race w hb lockset columns .
the results of online detectors are as follows the number of pairs reachable usin g hb analysis alone hb the number of pairs reachableusing hb and lockset analysis hb ls and the total time taken in sec for hb and lockset analysis including pin instrumentation and application runtime .
race w check reach i columns .
the results of tlh analysis performed by check reachusing strategy i with incremental search are as follows the number of pairs reachable using hb lockset and tlh analysishb ls tlh the number of recursive calls made to dosearch the total time taken in sec for the combined analysis including pin instrumentation and application r untime the time overhead in over hb and lockset analysis.
race w check reach ii columns .
the results are similar to columns but with strategy ii .
discussion .
comparing the race results of hb ls analysis column strategy i column and strategy ii column we find that both strategies and even more with strategy ii have better accuracy than hb ls analysis.our proposed tlh analysis easily handles trace lengths rangingfroma fewhundredstohalfamillionevents columns .
the tlh analysis adds less than overhead over lockset and hb analysis columns .
the end to end online analysis time was found to be very small less than a minute for these applications columns .
moreover it narrows down the potential races obtained using hb locke t analysis.forsomeapplicationsuchas bzip thereductionwas found to be significant.
we also observe that the upper bound on potential races column closely matches the predicte d races column indicating a tight bound.
although we use data abstraction we could replay most of the witnesses corresponding to the predicted races column s vs .
the witness trace lengthsrange from a few hundred to 160k.
we observed that the most of these applications we tested the shared variables have little role in controllin g the path of the execution.
for effective management of testing resources this is an interesting observation as it highlig hts that the scheduler dependent bugs can be exposed using ligh tweight static analysis with data abstraction.
we do not report the original run time of individual executions.
however hb ls analysis incur 20x slowdown.
this is a typical of dbi based race detectors such as google s threadsanitizer .
clearly the overhead of tlh analysi s is dwarfed by the instrumentation and hb ls analysis and hence race detection can be augmented with runtime prediction to improve accuracy and coverage incurring marginal overhead.
our approach can also be integrated with parallel data race detection to further improve its performance .
inalsa we found many predicted races to be real.
in fact someofthemalso ledtheapplicationtocrashduringreplay.
in elevator we found a replayable race that was not reported by any of previous methods possibly missed due to read after write constraint .
the race involves concur rent update and read access of lift.java count variable.
our end to endcheckingtakesabout11s.tocompare penelope tool takes about an hour for offline analysis.
we found severalknownracesin account andtsp andmanypreviously unreported races in axelandprozapplications.
b. incremental vs. non incremental we now compare the performance and further details of online reasoning using strategy ii with and without incremental search as shown in table vi.
for these results we carriedoutbothincrementalandnon incrementalchecksin the45table vi incremental vs. non incremental search.
incremental non incrementalappspcc c pc blccrcc c pc blccrc 15k3222.
.
07250account6k1272.
.
1m6.8k .
.4k068k .
.2k47k0aget13m77k0.694371k0473k .
.9k335k0 19m2301.
.4k .
0340961alsa25k2461.
.7k .
.2k 00na0000na 000alsa00na0000na .
.
000bzip2150.
.
447k2.2k .
.0k2586.3k .
.7k3.6kelevator27k1k3.901k01.5k .
.4k40 38k7051.
.3k .380416435proz214k1.6k .86094744610k .
.6k2.1k tsp1m7.5k .
.2k954k .
.7k35k1.8k same run ratheron separaterunsforeach case.
the rational ity for so is that it is unlikely that the two respective run s will take the same program path and therefore we can not guaranteethesamenumberofreachabilityproblems.simila rly performing results using strategy i are not presented due to space constraints.
in column we present the number of potential recursive calls made pc .
the details of actual recursive calls made in anincrementalsearchis shownin columns3 7as follows the number of actual recursive calls made c also in column table v the ratio in of actual to potential calls c pc the number of times both branches were taken b the number of times lcc branch were taken lcc and the number of times rc branch were taken rc.
the columns describe similar results for non incremental search.
discussion .
we observe that the number of actual calls made is a small fraction of the potential calls.
also the incremental search reduces the overhead of repetitive sear ch onoverlappingspacefurtherbyanorderofmagnitudein some cases thereby amortizing the search cost.
in the most case s check conditions holds and the procedure dosearch avoids re exploring both ordering of tlh events.
v. searchcorrectness and complexity let arepresent a sequence of tlh events of thread ta and represent some sequence of tlh events.
lock objects l l can be same or different lemma3 if a sequence lock ta l a unlock tb l is consistent then the sequence unlock tb l lock ta l a is also consistent.
lemma4 if a sequence unlock ta l a unlock tb l is consistent then the sequence unlock tb l unlock ta l a is also consistent.
lemma5 if a sequence lock ta l a lock tb l is consistent and unlock ta l ne ationslash a then the sequence lock tb l lock ta l a is also consistent.
lemma6 if a sequence lock ta l a lock tb l is consistent and unlock ta l ne ationslash then the sequence lock tb l lock ta l a is also consistent.
theorem for given time stamped lock histories of twothreadedprogram the procedureforcheckingpairwise reac hability check reachguarantees no false positive and no false negative under data abstraction using either strategy i or ii .
proof.
the starting pair selected is pairwise reachable as per lemma .
using lemmas we show that the recursivecalls made on only one branch in rc1 rc7 checks do not affect the reachability.
other checks such as hb1 hb2 and lcc1 lcc4 avoid inconsistent sequence.
thus if there exists a consistent sequence the procedure returns success otherwise it returns fail.
the claim follows.
squaresolid theorem for given time stamped lock histories of three ormorethreadedprogram theprocedureforcheckingpairwi se reachability check reachguaranteesno false negativeunder data abstraction using strategy i .
proof.
in strategy i we ignore the locks held by the other threads but maintain causal ordering between tlh events.
the starting pair is either reachable as per lemma or corresponds to the very first tlh events of the respective threads.
if a pair is found unreachable the pair is indeed unreachable as holding a lock by a third thread will not affec t the unreachability result.
squaresolid theorem for given time stamped lock histories of three ormorethreadedprogram theprocedureforcheckingpairwi se reachability check reachguarantees no false positive under data abstraction using strategy ii .
proof.
if there is a matching unblocking blocking events between the corresponding thread pairs then the starting p air astart bstart is reachable as per lemma .
otherwise we use astart bstart el where el corresponds to the most recent snapshot as starting pair.
this pair can be argued to be reachable by construction and lemma .
to guarantee no false positive we show that a third thread will not interfere with the two threads.
assume that the procedure returns success with a consistent sequence.
for each a an bracketle tastart am an bracketri ht b an bracketle tbstart bn an bracketri ht le el tid le ne ationslash ta tb the following holds by strategy ii check listed as check le aora le and le bor b le ls le ls a andls le ls b .
clearly the sequence is consistent as each le elof a third thread ne ationslash ta tb will not interfere with it.
squaresolid search complexity .
we describe the cost of each check in the procedure dosearch.costs of each hb checkis o t each lcc check is o l strategy ii check iso l t and rc1 rc7 is o respectively.
thus each call of dosearchcostso l t .
the locksets for each history event can be computed in o m n .
if we make recursive calls by exploring only one branch i.e.
checks then the search complexity is o m n assuming l t are bounded.
however if we traverse both branches btimes the search complexity is o b m n .
in practice b m n and the procedure runs almost in linear time.
vi.
conclusion we presented an effective incremental reasoning to check pairwise reachability and find data races in predictive test ing of multi threaded programs.
by avoiding the cost of repetit ive reasoning over redundant and overlapping search space our search incurs much smaller overhead.
as a proof of concept we integrated the search module in a runtime testing and show it effectiveness over race detection approaches witho ut much performance degradation.
our approach compares most favorably in accuracy coverage and performance with othe r predictive testing tools.46references f. chen t. f. serbanuta and g. rosu.
jpredictor a predi ctive runtime analysis tool for java.
in proc.
of icse .
a. farzan p. madhusudan and f. sorrentino.
meta analy sis for atomicity violations under nested locking.
in proc.
of cav .
c. wang s. kundu m. ganai and a. gupta.
symbolic predic tive analysis for concurrent programs.
in symposium on formal methods .
v. kahlon and c. wang.
universal causality graph a preci se happensbefore model for detecting bugs in concurrent programs.
in proc.
of cav .
f. sorrentino a. farzan and m. parthasarathy.
penelop e weaving threads to expose atomicity violations.
in proc.
of fse .
s. kundu m. ganai and c. wang.
contessa concurrency te sting augmented with symbolic analysis.
in proc.
of cav .
m. ganai.
scalable and precise symbolic analysis for ato micity violations.
in proc.
of ase .
y. smaragdakis j. m. evans c. sadowski j. yi and c. fla nagan.
sound predictive race detection in polynomial time.
in proc.
of popl .
a. farzan m. parthasarathy n. razavi and f. sorrentin o. predicting null pointer dereferences in concurrent programs.
in proc.
of fse .
s. savage m. burrows g. nelson p. sobalvarro and t. a nderson.
eraser a dynamic data race detector for multithreaded prog rams.
in acm trans.
comput.
syst.
.
r. o. callahan and j. d. choi.
hybrid dynamic data race d etection.
in symposium on principles and practice of parallel programmi ng .
u. banerjee b. bliss z. ma and p. petersen.
a theory of data race detection.
in proc.
of padtad .
e. pozniansky and a. schuster.
multirace efficient on the fly data race detection in multithreaded c programs.
in proc.
of concurrency and computation practice and experience .
c. flanagan and s. n. freund.
fasttrack efficient and pr ecise dynamic race detection.
in proc.
of pldi .
k. serebryany and timur iskhodzhanov.
threadsanitize r data race detector in practice.
in wbia .
b. wester d. devecsery p. m. chen j.flinn and s. nara yanaswamy.
parallelizing data race detection.
in proc.
of asplos .
a. mazurkiewicz.
basic notions of trace theory.
in workshop on linear time branching time and partial order in logics and m odels for concurrency volume of lncs pages .
springer verlag .
m. ganai n. arora a. gupta and g. balakrishnan.
best a symbolic testing tool for predicting multi threaded program failur es.
inproc.
of ase .
c. s. park and k. sen. randomized active atomicity viol ation detection in concurrent programs.
in proc.
of fse .
s. park s. lu and y. zhou.
ctrigger exposing atomicit y violation bugs from their hiding places.
in proc.
of asplos .
c. flanagan.
verifying commit atomicity using model checking.
in proc.
of spin workshop .
j. hatcliff robby and m. b. dwyer.
verifying atomicit y specifications for concurrent object oriented software using model chec king.
inproc.
of vmcai .
c. flanagan and p. godefroid.
dynamic partial order re duction for model checking software.
in proc.
of popl .
v. kahlon f. ivancic and a. gupta.
reasoning about thr eads communicating via locks.
in proc.
of cav .
a. farzan and p. madhusudan.
causal atomicity.
in proc.
of cav .
v. kahlon y. yang s. sankaranarayanan and a. gupta.
f ast and accurate static data race detection for concurrent progra ms. inproc.
of tacas .
v. kahlon s. sankaranarayanan and a. gupta.
semantic reduction of thread interleavings in concurrent programs.
in proc.
of tacas .
f. mattern.
virtual time and global states of distribut ed systems.
in workshop on parallel and distributed algorithms france .
j. fidge.
timestamps in message passing systems that p reserve the partial ordering.
in australian computer science conference .
v.kahlon.
boundedness vs.unboundedness oflock chain s characterizing decidability of pairwise cfl reachability for threads c ommunicating via locks.
in proc.
ieee symposium on logic in computer science .
v. kahlon.
reasoning about threads with bounded lock ch ains.
inproc.
of concur .
j. huang and c. zhang.
persuasive prediction of concurr ency access anomalies.
in proc.
of issta .
c. k. luk r. s. cohn r. muth h. patil a. klauser p. g. lowney s. wallace v. j. reddi and k. m. hazelwood.
pin building customized program analysis tools with dynamic instrument ation.
in proc.
of pldi .
c. flanagan and s. qadeer.
a type and effect system for at omicity.
in proc.
of pldi .
geeknet inc. freshmeat.
.
geeknet inc. sourceforge.
.
c. von praun and t. r. gross.
object race detection.
in oopsla .