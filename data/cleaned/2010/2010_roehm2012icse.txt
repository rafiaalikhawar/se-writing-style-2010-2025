how do professional developers comprehend software?
tobias roehm tu m nchen munich germany roehm cs.tum.edurebecca tiarks university of bremen bremen germany beccs tzi.derainer koschke university of bremen bremen germany koschke tzi.dewalid maalej tu m nchen munich germany maalejw cs.tum.edu abstract research in program comprehension has considerably evolved over the past two decades.
however only little is known about how developers practice program comprehension under time and project pressure and which methods and tools proposed by researchers are used in industry.
this paper reports on an observational study of professional developers from seven companies investigating how developers comprehend software.
in particular we focus on the strategies followed information needed and tools used.
we found that developers put themselves in the role of end users by inspecting user interfaces.
they try to avoid program comprehension and employ recurring structured comprehension strategies depending on work context.
further we found that standards and experience facilitate comprehension.
program comprehension was considered a subtask of other maintenance tasks rather than a task by itself.
we also found that face to face communication is preferred to documentation.
overall our results show a gap between program comprehension research and practice as we did not observe any use of state of the art comprehension tools and developers seem to be unaware of them.
our findings call for further careful analysis and for reconsidering research agendas.
keywords program comprehension empirical studies software documentation maintenance context awareness i. i ntroduction program comprehension is an important activity in software maintenance.
it consumes about half of the time spent by developers in maintenance as reported by fjeldstad and hamlen .
according to singer et al.
program comprehension mainly takes place before changing code because developers must explore source code and other artifacts to find and understand the subset of the code relevant to the intended change.
the strategies followed to understand software might vary among developers depending on their personality experience skills and task at hand.
the goal of this study is to review the state of the practice in program comprehension and learn how programmers in industry comprehend programs.
we aim at gaining deep insights into program comprehension practice examining the usage of research results in practice validating findings of similar studies and overcoming limitations of earlier studies.
furthermore hypotheses generated from our observations serve as starting point for a need driven research agenda.
earlier studies that empirically survey program comprehension practices suffer from limitations calling for adeeper up to date examination.
for example the studies of fjeldstad and hamlen and singer et al.
are rather old.
since their conduction new programming languages like java and practices like agile development and open source development have become popular.
latoza et al.
study developers from a single company and robillard et al.
study only five developers in a lab setting.
our study surveys developers working in different companies of different size using different technologies and has a larger sample size of developers.
further we follow a different method enabling detailed descriptions of rationale and thoughts behind observed behavior.
the contribution of this paper is threefold.
first it describes in detail strategies followed information needed and tools used during program comprehension as well as the rationale behind.
second we develop a catalogue of hypotheses about program comprehension that can be used to guide further research effort and tool development.
third we describe how we conducted our study which consists of observations and interviews.
the study design can be reused in other studies to understand developer behavior.
the paper is organized as follows.
section ii describes the design of our study.
section iii summarizes the findings and presents hypotheses derived from observations.
section iv discusses the implications of our findings and threads to validity.
finally section v presents related work and section vi concludes the paper and sketches future work.
ii.
s tudy design after presenting the research questions of the study we detail on the method followed including participant recruitment and reliability measures.
a. research questions the goal of this study is to qualitatively explore how program comprehension is done in software industry.
this includes studying how program comprehension tools are used in practice generating hypotheses about industrial program comprehension and testing established theories.
we refrain from quantifying certain comprehension aspects as the distribution and characteristics of the whole population is unknown and our sample is relatively small in statistical terms.
further we do not explicitly aim for new theories.
.
c ieee icse zurich switzerland 255in order to structure the study and focus our effort we investigate three main areas strategies developers follow information developers interact with or that is missing and tools used.
we formulate the research questions as follows rq1 which strategies including steps and activities do developers follow to comprehend programs?
rq2 which sources of information do developers use during program comprehension?
rq3 which information is missing?
rq4 which tools do developers use when understanding programs and how?
b. research method our study is designed to meet two requirements realism and replication.
to meet the requirement of realism we chose situations representative for realistic program comprehension tasks.
we observed developers in their realwork environment.
we did not predefine the tasks the participants worked on.
the task was chosen by the participants themselves.
we only requested a task that included program comprehension activities and that required the participant to spend about one hour of time in order to ensure that the task was large enough to evolve a program comprehension strategy.
to meet the requirement of replication we prepared material such as questionnaires and a protocol form and describe our study in detail in this section.
our method includes a combination of observation and interview with the observation mainly targeting what developers do and the interview mainly targeting the motivation behind developer s actions.
this combination was most appropriate to answer our research questions.
automated observations through instrumentation of development environment do not reveal reasons and motivations behind observed behavior.
experiments imply controlling particular variables assuming they are independent.
finally surveys or interviews assume that the questions are correct and complete.
they can be short in explaining real behavior in detail and answers might deviate from real practices.
observation during the observation session we concentrated on which andwhen questions like which activities does a developer perform?
.
for the observation session we used the think aloud method i.e.
we asked participants to comment on what they are thereby enabling the observers to understand what is going on and get access to thoughts in participants mind.
in case participants stopped talking we asked questions to start the information flow again.
but we took care not to interrupt the workflow of participants and deferred questions calling for long detailed answers to the subsequent interview.
before starting we shortly presented the study goals to the participants its exploratory nature i.e.
no right or wrong behavior was expected and assured them anonymity and confidentiality.
to document the observation sessions we created a protocol covering the current time a description of thetable i protocol excerpt of participant p5 daytime relative timeobservation quote postponed questions ... ... ... ... read jira ticket comment this sounds like the ticket from yesterday what information considered?
refresh source code repository publish code to local tomcat debug code in local tomcat why debugging?
open web application in browser and enter text into form fields change configuration in xml file content.xml exclamation not this complicated xml file again how known what to change?
publish changes to local tomcat debug local tomcat ... ... ... ... participants actions and quotes.
an excerpt of such a protocol is shown in table i. when we discovered interesting issues like unclear actions or counterintuitive behavior we noted them down and discussed them in the subsequent interview.
we observed a single participant for minutes leaving us another minutes for the interview and not spending more than hours in total.
the reason for this time constraint was not to observe people too long as concentration decreases over time.
in each session one participant was observed and interviewed by one observer.
interview during the observation sessions we got a good understanding of the context of participants and their workflows.
in order to gain more insight about rationale behind actions and figure out whether the observed behavior is representative for the developer we conducted a contextualized interview directly after each observation session.
we put special emphasis on understanding events and actions that occurred during the observation.
the interview focused on exploring how andwhy questions like why did you debug?
or how did you realize that method y is buggy?
.
we conducted semi structured exploratory interviews.
we used prepared questions1 but did not stick to them rigidly.
we rather used the questions as guidance to explore the subfields of program comprehension we were interested in i.e.
strategies employed information sources missing information and tools used.
at the start of each interview we gave a short definition of program comprehension in order to focus the discussion.
minutes were manually created one to two days after each interview.
testing the method before we observed programmers in industry we conducted a test session with a postgraduate student and observed him during a development task using a first version of our observation sheet and questions.
the sheet turned out to be suitable its use became better with increasing experience of observers.
however the questions had to be revised.
first we realized that we had too many questions and dropped less important ones in order to stick to our timeframe of min.
second we realized that some questions target the same information and we merged them for instance which steps are difficult when understanding software?
and which problems occurred during understanding software?
.
evaluation in order to analyze the results of observations and interviews we used two different approaches.
we summarized each session by collecting interesting observations i.e.
those that were not expected occurred in a similar way in other study sessions or differed among participants.
we clustered these observations by topic and compared similarities and differences in the behavior of different participants with respect to a specific topic.
we collected all answers to a specific interview question summarized them and compared the answers of different participants.
the results of both evaluation approaches were iteratively combined and incorporated in textual descriptions which can be found in section iii.
the validity of a single result is strengthened if it is both observed and reported.
reliability measures to increase the reliability of our findings we employed the following measures independent peer observations to eliminate observer bias we report in this paper only on observations that were independently reported at least in two different sessions by two different observers.
peer debriefing after each study day every observer discussed its observations and findings of that day with another author.
discussing results helped in summarizing important findings relating results to results from other sessions and interpreting observations.
triangulation of data sources our study design has the advantage that it produces two kinds of data sources observation protocols containing what observers saw and interview transcripts containing what participants told.
combining these triangulates between different data sources and improves reliability.
participant checking we sent a first draft of the findings in section iii to two participants that were observed earlier and asked them for feedback.
participant p1 agreed with hypotheses was not sure for hypothesis and .
he disagreed with hypothesis which he could not confirm by experience.
participant p2 agreed with hypotheses was not sure for hypothesis and and disagreed with hypothesis which he could not confirm by experience.table iii observ ations with participant and company counts observation p c comprehension strategies s1 employ a recurring structured comprehension strategy depending on context26 s2 follow a problem solution test work pattern s3 interact with ui to test expected program behavior s4 debug application to elicit runtime information s5 clone to avoid comprehension and minimize effort s6 identify starting point for comprehension and filter irrelevant code based on experience10 s7 establish and test hypotheses s8 take notes to reflect mental model and record knowledge9 information sources i1 source code is more trusted than documentation i2 communication is preferred over documentation i3 standards facilitate comprehension i4 cryptic meaningless names hamper comprehension i5 rationale and intended usage is important but rare information10 i6 real usage scenarios are useful but rare tool usage t1 dedicated program comprehension tools are not used t2 standalone tools are used in addition to ides t3 compiler is used to elicit structural information t4 tool features for comprehension are unknown c. participant recruitment our participants had to work for a software development company and spend most of their time coding to make sure to study software developers .
we excluded other people especially students and university researchers from the study because we want to study industry practice.
we also allowed participants with different tasks different project roles different experience different technology used and different company size in order to explore program comprehension as broad as possible and to improve external validity.
table ii gives an overview of all participants.
five participants work for companies located in spain and the rest for companies located in germany.
the column w. exp.
represents how many years of work experience a participant had.
the role developer denotes that the participant mainly implements new functionality.
the role maintainer denotes that the participant mainly fixes bugs.
the column fam.
denotes whether a participant was familiar with the program they are trying to comprehend during the observation.
tec.
exp.
represents the experience with the technology used in years.
all participants worked in projects that used a proprietary customized agile development process.
iii.
f indings we summarize the observation and interview answers formulate hypotheses summarizing the observations and relate our findings to the findings of similar studies.
table iii gives an overview of our findings and the number of participants and companies that support each finding.257table ii overview of participants id company w. exp.
project role domain fam.
technology used tec.
exp.
task during observation p1 c1 de .
developer maintainerfacility control java netbeans .
application familiarization p2 c2 de technical documenterfleet management pl sql oracle sql developer .
technical documentation p3 c3 es manager developerevent management x delphi delphi ide client java eclipse server bug fixing p4 c3 es manager developerevent management x delphi delphi ide client java eclipse server feature implementation p5 c4 es developer port management x oracle db java oracle toad eclipse tomcat2 bug fixing feature implementation p6 c4 es .
maintainer port management x oracle db java oracle toad eclipse tomcat1 feature implementation 2x p7 c4 es .
developer maintainerport management x oracle db java oracle toad eclipse2.
porting a feature p8 c5 de developer consultantautomotive software x c ascet sourceinsight application familiarization p9 c5 de developer automotive software x c notpad version comparison p10 c5 de researcher automotive software x c ascet notepad version comparison p11 c5 de developer automotive software x c eclipse code review p12 c5 de developer automotive software x c eclipse sourceinsight code review p13 c5 de developer automotive software x c visual studio feature implementation p14 c5 de developer maintainerautomotive software x c xml codewrigth editor feature implementation 2x p15 c6 de .
developer computer aided design x python eclipse .
feature implementation 3x p16 c6 de developer computer aided design x python eclipse bug fixing p17 c6 de developer product management x python sqlite toad code review p18 c6 de .
developer databases x c python xml vi feature implementation porting a feature p19 c7 de developer content management x c visual studio bug fixing p20 c7 de developer content management x vb vb .net visual studio bug fixing p21 c7 de developer content management x vb .net c visual studio bug fixing p22 c7 de developer content management x java tomcat netbeans feature implementation p23 c7 de .
developer content management x java netbeans .
feature implementation p24 c7 de developer content management x java eclipse feature implementation p25 c7 de developer content management x vb .net sql server visual studio bug fixing p26 c7 de developer content management x vb vb .net visual studio bug fixing p27 c7 de developer content management x vb.
net visual studio editor bug fixing p28 c7 de developer content management x vb .net visual studio bug fixing a. comprehension strategies by comprehension strategy we mean the overall approach and activities performed to reach a certain comprehension goal e.g.
debugging to determine why a nullpointer exception occurs or asking colleagues to acquire a certain information.
we observed the following strategies.
s1 employ a recurring structured comprehension strategy depending on context we noticed that many participants approached tasks using a recurring structured strategy.
participants confirmed in the interviews that they follow such a strategy.
but the strategies differed among them.
sixteen participants argued that they start with reading source code and locating the code where the change should be performed.
three participants said that they start with inspecting documentation or requirements.
p1 reported that his comprehension strategy depends on the type of application in case of a server application or library he tests possible calls and the corresponding behavior a black boxapproach whereas in case of applications with a graphical user interface gui he identifies methods that are executed as a consequence of button clicks a white box approach .
the strategy used by participant p7 depends on previous knowledge.
if he already knows an application he runs it and inspects source code.
but if he is completely unfamiliar with an application he either talks to a person with knowledge about it or implements some dummy functionality to test the application behavior.
p3 reported to use a task independent high level strategy by ensuring that code can be compiled and run as a prerequisite for all other comprehension activities.
we observed that participants used different strategies for bug fixing e.g.
reproduce bug locate cause apply fix and feature implementation e.g.
understand behavior of application analyze similar code copy and adapt code .
hypothesis developers usually follow a recurring structured comprehension strategy that varies with the type of258task developer personality the amount of previous knowledge about the application and the type of application.
there is a distinction between what we describe as recurring structured approach and what littman et al.
describe as systematic and opportunistic strategies .
what littmann et al describe as systematic and opportunistic approach refers to reading code line by line systematic or in a more arbitrary order.
our strategies are not limited to the way developers read code but describe a whole workflow e.g.
reading documentation locating a bug applying changes .
we did not observe whether the code reading as a part of those strategies was systematic or opportunistic.
the strategies we observed were recurring and depend on the context factors mentioned in hypothesis .
s2 follow a problem solution test work pattern we observed that participants followed a work pattern including three steps identifying the problem implementing the solution and testing the solution.
each of these steps had a different comprehension goal.
the focus of the first step was to understand what happened before a bug occurred and why this causes the bug in case of bug fixing or to understand application behavior in case of feature implementation .
the focus of the second step was to understand how the bug can be removed bug fixing or how the feature can be implemented e.g.
which code has to be changed and which code has to be added.
for example p3 tried to fix a coloring bug in the ui.
he resumed this task because he could not finish it the day before.
p3 tried to identify the cause of the bug by debugging the application and executing it with print statements step .
despite several code modifications step and subsequent testing step p3 could not solve the problem during our observation session.
in contrast p5 was able to complete two tasks during our observation session and completed two passes through the work pattern.
the first task was to fix a sqlexception problem.
p5 inspected the problem by analyzing the sqlexception trace and discovered that two table attributes were missing in the database of the production environment step .
as solution p5 wrote a sql script creating those two missing attributes step and tested it by running it on the local test system step .
the second task was to add additional information to a view in the gui.
p5 debugged the application in order to identify the code location where to add new instructions step copied an existing table structure adapted it added code to fill the adapted structure step and tested the implementation by restarting the application and inspecting the table in the gui step .
similarly boehm observed that modifying software generally involves three phases understanding the existing software modifying the existing software and revalidating the modified software.
maalej and happel also found that about of developers describe their work by using problem solution phrases.hypothesis for tasks including changing source code developers employ a work pattern with three steps identification of the problem in case of bug fixing or identification of code locations as starting points in case of feature implementation searching for and applying a solution and testing the correctness of the solution.
s3 interact with ui to test expected program behavior participants worked on applications that exhibit a user interface ui and of them used the ui to comprehend the application or stated this in the interview.
p1 inspected which code is triggered by a button click and used this information as a starting point in exploration.
p3 related control flow to the user interface during debugging we only passed two times in this loop because we have two categories of events displayed in the user interface .
p2 p5 p17 and p19 p28 interacted with the user interface entered values in text fields expanded drop down lists or clicked on buttons in order to familiarize with the application s functionality and test whether the application works as expected.
p4 tested the correctness of application implementation and his conceptualization of it by entering values in a ui form and verifying that these values are stored in the database.
hypothesis developers interact with the user interface of the software to test if the application behaves as expected and to find starting points for further inspection.
s4 debug application to elicit runtime information all participants from companies c1 c4 c6 and c7 read source code and executed the application.
sixteen of them used the debugger to inspect the state of the application at runtime.
the participants from company c5 did not have the possibility to execute or debug the application because they can only access and compile parts of the software they are working on as the overall system has to run on a special hardware that is not available to single developers.
this finding matches with results of murphy et al.
who found that debuggers are frequently used by developers.
hypothesis developers frequently debug the application to acquire runtime information.
s5 clone to avoid comprehension and minimize effort we observed participants reusing code or documentation by cloning.
to avoid breaking existing code p3 copied a piece of code and adapted it instead of refactoring the original code.
the fear of breaking originates from not knowing all possible usages of the piece of code i do not know if it is used otherwise and not being able to test all possible usages after a modification to check the correctness of the modification i can t test everything later .
p2 stated another reason for copying and adapting documentation copy documentation to have a uniform structure simplifying the use of the documentation and the access of information needed during comprehension.
an interesting code reuse strategy was observed for participant p7.
the task was to re implement an already259existing functionality from another customer specific version of the application.
p7 copied big blocks of code containing several methods and deactivated the whole copied code by commenting it out.
then he looked at compiler warnings that indicated that a certain method was not found by the compiler.
following these warnings p7 removed the comments and reactivated the appropriate methods.
p7 applied this strategy repeatedly until all compiler warnings disappeared.
using this strategy p7 traced which methods in the copied code were really needed.
with this strategy p7 did not try to understand how each method works.
another reason reported by participants for cloning code is to reuse an existing implementation and save effort compared to writing code from scratch.
most participants claimed that they clone code to save effort and only few reported that they clone code to avoid comprehension.
this finding matches with the results of singer et al.
who reported that novice developers do not comprehend system aspects that go beyond the needs of their current tasks.
hypothesis developers try to avoid comprehension by cloning pieces of code if they cannot comprehend all possible consequences of changes.
hypothesis developers prefer a unified documentation structure to simplify finding information needed for comprehension .
hypothesis developers usually want to get their tasks done rather than comprehend software .
s6 identify starting point for comprehension and filter irrelevant code based on experience during the observations we noted that many participants had an idea where to start inspecting the program behavior.
when asked how they choose these starting points participants agreed that they know from experience where to begin.
for example p3 explained if you know the application you know where to touch the code .
eight participants explained that they choose a specific starting point because this is always the starting point in all our systems and most of them referred to the application architecture as crucial information.
we observed that experience also influenced the recognition of data structures and helped in the location of concepts.
p11 for example realized very quickly that a specific feature in the software was implemented as a state machine because he knew this concept from other parts of the system.
we also observed that participants often decided whether to take a closer look on a certain code fragment or not based on experience.
participants p2 p9 and p10 ignored parts of the source code arguing e.g.
that this part implements calculation which is not important for my current task .
this observation matches with results from sillito et al.
who found that developers minimize the amount of code to read.
hypothesis experience of developers plays an important role in program comprehension activities and helps to iden tify starting points for further inspection and to filter out code locations that are irrelevant for the current task.
s7 establish and test hypotheses we observed that participants comprehend code by asking and answering questions or establishing hypotheses and testing them.
nine participants verbalized such questions or hypotheses during observations.
for example p1 asked questions like where do corba calls happen?
or what do i have to change to implement user profiles?
.
four participants p11 p12 p14 p15 asked themselves where certain values were set or used.
participants p2 and p3 established hypotheses about the application behavior and compared them to actual observed behavior reflected in statements like i assume this method fetches the maximum value p2 or the problem should be in method prepareitem p3 or the values printed should be all x ... ... oh they are different p3 .
this finding matches with results reported by brooks mayrhauser et al.
and ko et al.
.
according to these authors questions lead to informal hypotheses that are verified by developers.
hypothesis developers comprehend software by asking and answering questions and establishing and testing hypotheses about application behavior .
s8 take notes to reflect mental model and record knowledge nine participants took notes on a separate piece of paper or used a text editor as a temporal memory during comprehension activities.
these notes varied from single function names mappings between ids and labels to complex flow charts corresponding to the part of the application studied.
we also observed one participant writing down how a specific module could be used and accessed.
three participants drew flow charts.
they started by writing down a condition that they assumed to be the starting point.
during the next inspection the participants refined the charts by adding further conditions and incorporated additionally acquired knowledge into them.
p3 wrote down the method name and parameters of a server call to be able to debug a server call with the original parameters.
all participants started their tasks without using existing notes.
p9 stated that notes are only important for the current mental model and participant p11 reported that notes are only for personal understanding and are not archived or used beyond the current task.
hypothesis some developers use temporal notes as comprehension support.
this externalized knowledge is only used personally.
it is neither archived nor reused.
b. information sources we made six main observations about information sources needed during program comprehension how knowledge was documented and shared and which information was missing to developers.
i1 source code is more trusted than documentation participants reported that they get their main information from source code and inline comments whereas only four stated that documentation is their main source of information.
p2 verified the correctness of existing documentation by inspecting source code in order to make sure that a ratio in the documentation is really a ratio .
p9 questioned the trustfulness of documentation in general you cannot trust the documentation and p5 reported that technical documentation covers only of the application .
the lack of documentation was confirmed by p1 source code is documented sparsely .
p5 explained that the reason for this phenomenon as follows documentation costs much time usually more than actual implementation.
that s the reason why people try to avoid documentation.
this finding matches with the results of other researchers who reported that documentation is seldom kept up to date .
singer et al.
also reported that source code is read frequently while documentation is not.
hypothesis source code is considered a more credible source of information than written documentation mainly because documentation is often non existent or outdated.
i2 communication is preferred over documentation seventeen participants reported that communication with colleagues is a more important source of information than written documentation.
p5 reported that only little is documented most knowledge is in comments or experts heads and p1 employed a strategy to ask colleagues for information in case of problems in components developed by them.
participants from company c7 stated that communication is the most important source of information as documentation is rarely available.
p4 and p7 compared the benefits of writing documentation with explaining to colleagues orally.
according to them an explanation can be tailored to the information seeker by relevance or by previous experience whereas a written documentation can be re read in case some details were forgotten.
p7 stated i have the feeling that our bosses want us to explain to people not to document .
p15 and p17 stated that due to the small size of the project team it is much easier to go next door and ask a colleague than searching for the information needed in the documentation .
this result is consistent to the findings reported by latoza et al.
who emphasized the importance of people to gain information compared to written documents.
hypothesis communication with colleagues is a more important source of information than written documentation because written documentation is non existent and some developers prefer direct communication over writing documentation.
the advantage of direct communication is that answers can be tailored to the information seekers whereas the advantage of written documentation it is reusable.
i3 standards facilitate comprehension twelve participants agreed that the consistent use of naming conventionsand a common architecture simplify program comprehension tasks considerably.
p1 and p3 searched for starting points to inspect the code by using the standard structure of an application.
p1 used web application resources such as the web descriptor web.xml while p3 used standard naming scheme of delphi ui triggers such as s how or c reate methods.
p5 p6 and p7 reported that a standardized architecture helps them to locate code that has to be changed for a bug fix or a feature implementation.
further p2 reported that most of the functions he analyzed had the same structure filter data set global variables calculation and he ignored those parts of the structure that are not relevant for his current task.
naming conventions played a central role for company c5.
the participants even used a self developed translator that transformed cryptic names of functions and variables into a meaningful human readable form which helped to get a better understanding of the software.
this finding is consistent with the finding of rajlich and wilde who reported that regularities in the design and especially in the naming of functions and data may greatly facilitate concept location .
hypothesis standardization the consistent use of naming conventions and a common architecture allows developers to become familiar with an application quickly and makes program comprehension activities easier and faster.
i4 cryptic meaningless names hamper comprehension the issue of low quality names of variables methods and constants was raised in the observations and interviews by ten participants.
p2 was angry when encountering cryptic variable names like ct a vg ac or gt ccmp several times and had no idea what they meant.
p6 explained that a reason for using cryptic names is that database field names were restricted to characters and hence only abbreviations could be used as names.
p3 reported that confusing names are due the lack of a mandatory coding style and the mixture of english and spanish names.
additionally the participant stressed the importance of semantic names of trigger components like s how to identify source code with a specific functionality.
p5 explained that well written code uses semantic names and of code is well written .
during the interviews two participants explicitly said that it is very difficult to understand source code that is not properly formatted according to style guides.
company c5 enforces naming conventions that can be translated to semantic names by a translator.
participants from c5 agreed that this helps to understand the rationale behind the code.
however improper use of naming conventions also led to misunderstandings.
p9 for example assumed a different meaning of a function due to its misleading name.
he explained that the function name took me to the wrong direction.
according to our naming convention the name should have been different .
hypothesis cryptic non semantic names hamper understanding of a piece of code.261hypothesis naming conventions can help to mitigate this effect but if they are too complicated they can have a negative effect.
i5 rationale and intended usage is important but rare information participants were interested in information about the purpose and idea behind a class or method and how it should be used .
p1 mentioned that rationale gets lost and cannot be restored when it is not documented even for code written by the participant himself without documentation i would forget quickly .
the results from the observation were approved during the interview where ten participants argued that understanding the rationale behind the code is very exhausting.
in contrast we did not observe a single participant documenting rationale for own code.
this finding supports the result of latoza et al.
that understanding the rationale behind code is a big problem for developers.
hypothesis knowledge about rationale of the implementor and intended ways of using a piece of code help to comprehend code but this information is rarely documented.
hypothesis there is a gap between the interest of developers in this information and the lack of documenting it for their own code.
i6 real usage scenarios are useful but rare five participants reported the importance of knowledge about how end users use the application as context information for comprehension.
p3 explained that needs that are supported by the application are an information necessary to understand programs.
p2 had a dedicated item in his documentation scheme called user goals .
he reported that use cases and requirements of potential users is an information that is missing to him i am not sure how potential users will use the system or what their intentions are .
p15 reported that it is often unclear how the end user uses the application and that he has limited knowledge about the application domain.
hypothesis the way in which end users use an application is a helpful context information in program comprehension.
hypothesis in many cases this information is missing.
c. tool usage we made four main observations about tool usage i.e.
which tools were used and how they were employed to understand software.
t1 dedicated program comprehension tools are not used twenty two participants used an integrated development environment ide to read source code and sixteen participants used the debugger to inspect the state of the application during its execution.
but we did not observe any usage of special program comprehension tools such as visualization concept location or software metric tools.
someparticipants from company c5 used s ource insight2to view source code but we did not observe them utilizing the built in program comprehension features.
p3 reported to use w ireshark3 a network packet analyzer to inspect network communication while p4 reported to use s elenium4 a macro recorder of user interactions to simulate user interactions for testing purposes.
hypothesis industry developers do not use dedicated program comprehension tools developed by the research community.
t2 standalone tools are used in addition to ides during the observations we realized that even though participants used an ide to read and change source code fiveparticipants employed other tools to perform actions that could also be done by the ide.
for example p14 used the e clipse ide that supports full text search but the participant executed a search using grep from the command line.
p14 argued that it is much quicker and i am more used to this kind of search .
p3 viewed a previous source code version in n otepad and the current version in d elphi because it would be too difficult to open this also in d elphi and switch between the current and previous code versions .
this finding is consistent with the results from latoza et al.
who reported on the use of standalone tools in addition to an ide in a bug fixing scenario.
singer et al.
and maalej also found that developers complain about loose integration of tools which might hinder comprehension as information required is scattered across different tools.
hypothesis during comprehension tasks ide and specialized tools are used in parallel by developers despite the fact that the ide provides similar features.
t3 compiler is used to elicit structural information five participants used the compiler to elicit structural information.
p3 used the compiler to search for locations where a specific constant is used by changing the name of that constant in its definition and examining the locations of the resulting compiler errors.
p4 used the compiler to find out where he inconsistently adapted a copied piece of code e.g.
inconsistent changes of variable names.
p7 used the compiler extensively to check which methods of a copied code block are necessary as described in finding s5.
p15 and p18 used the compiler messages to find error locations.
starting from the compiler message variable x not defined they performed a full text search for the code locations where variable x is used.
hypothesis the compiler is used by some developers to elicit structural information such as dependencies and usage locations of code elements.
t4 tool features for comprehension are unknown we made an unexpected observation with p3.
in order to find all locations where a specific constant is used p3 changed the name of the constant in its definition and inspected resulting compiler warnings.
p3 was working in e clipse that provides the feature r eferences for retrieving such a list of constant usage.
when asked about the motivation behind this behavior p3 answered that he did not know the e clipse feature despite of years of professional experience and years using e clipse .
p22 solved the same problem by performing a full text search for a method name.
these observations match with results from sillito et al.
who reported that developers make inefficient use of tools.
hypothesis developers do not know some standard features of tools.
iv.
d iscussion we discuss the implications of our findings for researchers tool vendors and practitioners and reflect on limitations and threads to validity.
a. implications the fact that none of the participants used dedicated program comprehension tools such as visualization concept location or software metric tools reveals a gap between program comprehension research and practice.
implications for researchers in order to validate understand and deal with the gap between research and practice researchers should investigate the scope of the gap reasons behind it and align research efforts to the needs of industry.
possible reasons behind the gap are a research results and their benefits being too abstract for industry b lack of knowledge about available tools among practitioners c fear of familiarization effort and lack or trust in new tools or d that using new tools requires too much training for practitioners.
implications for tool vendors similar to researchers vendors of software development tools should investigate the reasons behind the gap between research and practice carefully select which tools developed by the research community that provide benefits for program comprehension tasks and incorporate them as features in their tools.
the observation that some developers do not know standard features such as the e clipse feature r eferences see hypothesis emphasizes the need to educate developers to use tools efficiently and to proactively inform them about new features.
we wonder how many features can be incorporated into a tool such as e clipse before it becomes to overwhelming for a developer to first comprehend its features and then use them appropriately in program comprehension.
moreover insights about the work patterns of developers from this and other studies e.g.
can be used to build tools that are aligned to the workflow of developers.
for example a tool that detects the current high level activity of developers from low level actions can be used to provide only information that is relevant for the current problem .
implications for practitioners in order to benefit from research results on program comprehension practitioners should examine the results of the research community assess their usefulness and ask tool vendors to incorporate them in their tools.
as standardized coding style was reported to facilitate see hypothesis and cryptic names to hinder see hypothesis program comprehension practitioners should think about what kind of coding style they want to implement in their organization if not yet done.
if a coding style already exists it may be worth to analyze its impact on comprehension.
the observation that communication is preferred over documentation in many comprehension situations see hypothesis has two drawbacks.
first information might get lost when experts leave the organization.
second experts frequently get interrupted from their tasks.
practitioners need thus to assess this tradeoff when deciding about information sources to use for program comprehension.
b. limitations and threats to validity there are several limitations to the internal and external validity of our results.
as for the internal validity we are aware that in min.
we can only observe a fraction of developer s work day.
we might have missed certain types of tasks comprehension strategies information sources or tools.
however we think that extending the observation time would not fundamentally change the findings due to the variation of the tasks observed.
first these tasks were randomly selected by the participants.
we only constrained the tasks to include program comprehension.
second the tasks observed were different in duration and nature.
while few subjects managed to complete two tasks in the observations session others did not manage to complete one task.
another potential threat to the internal validity is that observers might had assumptions and expectations and might considered only clues affirming these expectations while ignoring clues indicating different unexpected behavior observer bias .
in order to deal with this threat we report in this paper only on findings that were observed by two observers independently from each other in two different sessions.
similarly participants might have behaved differently because they were observed.
this threat cannot be eliminated completely but we addressed it by assuring participants complete anonymity and confidentiality.
we also stressed that there was no right and wrong behavior as we only aimed at documenting the state of practice.
finally there might be misinterpretations of the think aloud comments and interview answers due to insufficient language skills.
for sessions both participant and observer were either native or proficient speakers.
in two sessions a translator was present due to participant s insufficient english skills.
keeping in mind our reliability measures263 i.e.
the triangulation of data sources and the participant checking we think that the effect of this threat is minimal.
our study was designed to have a strong degree of realism rather than a high external validity.
because we did not study a random sample that is fully representative of the target population of software developers it is difficult to generalize our findings.
in addition we neglected other interesting aspects such as time spent on single activities or communication behavior within a team.
we were unable to draw representative samples from all developers of the companies involved.
however the distribution of participants includes different company sizes different experiences different application domains different programming languages different roles and different countries representing a wide range of potential participants.
this give use some confidence that the results have a medium degree of generalizability.
v. r elated work singer et al.
empirically studied developer s habits and tool usage during software development.
latoza et al.
conducted a similar study focusing on software maintenance.
both studies were hosted in a single company while our sample includes developers from various companies and domains.
other researchers studied developer behavior during maintenance tasks and program comprehension activities.
deline et al.
sillito et al.
ko et al.
and robillard et al.
studied developer behavior while updating unfamiliar source code.
these studies used an experimental setting with a small number of participants from one or two companies working on unfamiliar code.
von mayrhauser et al.
also studied developer s behavior during maintenance tasks focussing on cognitive processes and mental models.
their results are complementary to ours as we focussed on other research questions developer s externalized behavior and its rationale.
other studies examined information needed to comprehend software.
sillito et al.
examined what information developers seek during software maintenance tasks.
ko et al.
studied information needs in software development in general.
both studies concentrated on information needs formulated in form of questions asked and answered during a programming task.
we also observed information needed focussing on the sources of information and overall access and sharing approaches.
these studies observe developers from a single company.
lethbridge et al.
and forward and lethbridge studied how developers use and maintain documentation.
we made similar observation without restricting our observations to software documentation but also comprehension approaches and tool usage.
other studies examined how developers use tools to accomplish maintenance tasks.
murphy et al.
studied howprogrammers use the e clipse ide by analyzing the interaction data collected by instrumenting e clipse .
maalej studied tool usage and problems developers face regarding tool integration using interviews and online questionnaires.
these studies used different research methods and are thus complementary to our study.
we explicitly identified overlaps between results of related studies and our study during the description of our findings.
vi.
c onclusion in this study we observed developers from software industry to get insights into the state of the practice in program comprehension.
some of our findings confirm observations made by other researchers others are new and surprising.
we showed that previous observations cf.
findings s2 s4 s5 s6 s7 i1 i2 i3 i5 t2 are valid in different contexts.
one of our most interesting findings is that developers put themselves in the role of end users whenever possible.
we observed developers inspecting the behavior visible in user interfaces and comparing it to the expected behavior.
this strategy aims at understanding program behavior and getting first hints for further program exploration.
it presents an alternative to reading source code and debugging.
moreover developers sometimes try to avoid comprehending programs.
instead they clone source code and adapt it to fulfill their current task.
cloning avoids comprehending possible consequences of modifying code directly.
wherever possible developers seem to prefer strategies that avoid comprehension because of time and mental effort needed.
program comprehension is rather considered as a necessary step to accomplish different maintenance tasks than a goal by itself.
when software architecture and code has to be investigated we found that standards as well as experience are important facilitators to quickly familiarize with an unknown program and find starting points for further investigation.
most observed developers choose from a set of structured comprehension strategies e.g.
follow a problem solutiontest work pattern depending on their work context.
thereby context constitutes of the type of task at hand the type of program to comprehend previous knowledge about the program and the developer s general experience.
overall we found that state of the art tools in program comprehension are either unknown or rarely utilized.
this reveals a gap between the state of the art of program comprehension research and the state of practice in industry at least in observed companies .
the next step is to investigate the reasons behind this gap and to test the hypotheses resulting from our study to improve generalizability.