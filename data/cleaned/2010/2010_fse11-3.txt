inferring datapolymorphism insystemscode brian hackett stanford university bhackett cs.stanford.edualexaiken stanford university aiken cs.stanford.edu abstract we describe techniques for analyzing data polymorphism in c and show that understanding data polymorphism is important for statically verifying type casts in the linux kernel where our techniques prove the safety of of downcasts to structure types out of a population of .
we also discuss prevalent patterns of data polymorphism in linux including code patterns we can handle and those we cannot.
generalterms verification experimentation keywords type checking type casting static analysis .
introduction consider a typical linux function saa7146 buffer timeout which is part of the device driver for the saa7146 chipset drivers media common saa7146 fops.c void saa7146 buffer timeout unsigned long data struct saa7146 dmaqueue q struct saa7146 dmaqueue d ata struct saa7146 dev dev q dev unsigned long flags ... this function casts its integer parameter datato a pointer to typesaa7146 dmaqueue and then accesses the contents of that structure.
if datareally is an integer or if datais a pointer to an object that is not of type saa7146 dmaqueue then these accesses will corrupt or crash the system.
type casts like this one are ubiquitous in linux and other large c codebases.
analyzing these casts to determine their correctness requires deep reasoning about the heap control flow and data flow of the system.
in addition many of these casts this work was supported in part by nsf grants cns050955 and ccf with additional support from darpa and gifts from intel and ibm.
permission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bearthisnoticeandthefullcitationonthefirstpage.
tocop yotherwise to republish topostonserversortoredistributetolists re quirespriorspecific permission and orafee.
esec fse september5 szeged hungary.
copyright2011acm ... .
.are used to implement polymorphism including the above cast and thus any successful analysis needs to model common patterns of polymorphism.
we have developed a static analysis that augmented with programmer annotations proves the safety of of the downcasts to structure types in linux .
.
.
.
the complete analysis consists of many components in this paper we focus on what we consider the most novel and difficult issue the problem of analyzing data polymorphism which is needed for of the casts we are able to verify as well as most of the casts we are not able to verify.
in section we expand the example show why the cast is correct and motivate the problem of understanding data polymorphism.
in sections and we reduce the problem of analyzing data polymorphism to discovering structural relationships andstructural correlations and describe our algorithm.
section presents experimental results including examples that are beyond the reach of our fully automatic analysis which we handle using programmer annotations.
we postpone a discussion of our contributions until section after we have presented the extended example and the definition of structural relationships and structural correlations the key ideas underlying our approach.
.
example to verify the cast in saa7146 buffer timeout we must show the function s callers always pass a pointer to a value of typesaa7146 dmaqueue .
now saa7146 buffer timeout is never called directly.
in fact it is mentioned in only two functions.
the two cases are similar one is shown below drivers media common saa7146 vbi.c static void vbi init struct saa7146 dev dev struct saa7146 vv vv init list head vv vbi q.queue init timer vv vbi q.timeout vv vbi q.timeout.function saa7146 buffer timeout vv vbi q.timeout.data unsigned long vv vbi q vv vbi q.dev dev ... thetimeout field has type timer list a core kernel structure with a function pointer field function and an integer fielddata among others.
after the function field of the timer list is assigned saa7146 buffer timeout where can the function eventually be called?
the function field never has its address taken and is only assigned to a local variable fnin the core kernel function run timers kernel timer.c static inline void run timers tvec base t base struct timer list timer ... while ... ... void fn unsigned long unsigned long data timer list entry head next struct timer list entry fn timer function data timer data ... fn data ... function run timers repeatedly pulls timer list s off of lists and calls timer function withtimer data .
this exposes the design intent of the timer list structure whatever is stored in the function field of a timer list is called with the datafield of that same timer list .
thefunction field points to saa7146 buffer timeout for timers whose datafield was written by vbi init .
after such writes the datafield points to the vbi q field of a saa7146 vv structure which has type saa7146 dmaqueue which is just what saa7146 buffer timeout expects.
thus we know that if the function saa7146 buffer timeout is only called with vbi q for itsdataparameter then the cast it performs is safe.
so might saa7146 buffer timeout be called with a parameter other than vbi q ?
two possibilities must be considered.
first the datafield could be assigned another value of a possibly different type between the calls to vbi init and run timers .
second the function field could be called somewhere outside run timers with a parameter other than the datafield of the timer list .
it turns out bothpossibilities actually occur see below but neither affects any timer list containing saa7146 buffer timeout in thefunction field.
normally the function anddatafields of a timer list are written at the same time shortly after the timer list is created after all run timers requires both fields to be set.
however in a few places the datafield is written without any corresponding write to the function field such as intlclk interrupt drivers char tlclk.c static irqreturn t tlclk interrupt ... ... if int events holdover 01 mask alarm events pll holdover switchover timer.expires jiffies msecs to jiffies switchover timer.data inb tlclk reg1 add timer switchover timer ... under certain circumstances tlclk interrupt changes the data field of the global switchover timer variable to a non pointer integer value.
but switchover timer cannot alias atimer list containing saa7146 buffer timeout switchover timer is a statically allocated timer list while the timer manipulated by vbi init is embedded in another structure.
the other way saa7146 buffer timeout might receive a value other than vbi q is if the function field is invoked with an argument other than the datafield.
there are fiveplaces in the kernel where the function field is invoked and run timers is the only one where the datafield is passed.
the function ctnetlink del conntrack is representative of the other four net ipv4 netfilter ip conntrack netlink.c static int ctnetlink del conntrack ... struct ip conntrack ct ... ct tuplehash to ctrack h ... if del timer ct timeout ct timeout.function unsigned long ct ip conntrack put ct return instead of passing ct timeout.data toct timeout.function ctitself is passed exploiting knowledge that ct timeout.data ct in this context.
we know ct timeout cannot alias the timer from vbi init the two timers are embedded in different types of structures.
thus ct timeout.function cannot invoke saa7146 buffer timeout .
.
analyzing polymorphism whensaa7146 buffer timeout is called by run timers the data passed is provably generated by a previous call to vbi init not any of the hundreds of other assignments to thedatafield of atimer list in the linux kernel.
the proof relies on two facts.
first the indirect call in run timers exploits a structural relationship between the function pointer target and function argument these are fields of the same timer list structure.
in general a structural relationship is a pair of locations reachable via zero or more field accesses and dereferences from a common base structure or two locations reachable from the arguments to a common function.
second the possible values of the locations in a structural relationship have structural correlations with one another the function field of a timer list issaa7146 buffer timeout if and only if the datafield was set by vbi init and similarly for the hundreds of other functions that may be used in atimer list .
structural relationships are related to the standard notion of type polymorphism in languages with more advanced type systems than c commonly but not exclusively fields in a structural relationship would have related polymorphic types in statically typed functional or object oriented languages.
however solving our problem requires more than identifying polymorphic fields as we must also understand the actual contents of those fields which means finding and correlating the field assignments.
in the example the correlation is easily identified as the structural correlation involves only two fields of a single structure and both fields are assigned in vbi init .
in more complex scenarios the structural relationship may span chains of dereferences across several structures and the correlated assignments to the fields of the structural relationship may also be spread across multiple functions.
it is the combination of identifying polymorphic data structures and the correlated side effects to different parts of these structures in the heap that makes understanding data polymorphism a challenging problem.
structural correlations are also related to standard notions in points to analysis.
consider a field athat can take on values in set aand field bthat can take on values in set b. context insensitive points to analyses are oftentoo inaccurate in the sense that the cross product a b contains too many possibilities to be useful.
by adding some form of context we split the fields aandbinto multiple abstract locations a1 a2 .
.. b1 b2.
..representing smaller sets of runtime values which will have analysis sets a1 a2 .
.
.
b b2 .
.
.associated with them.
the client of the points to analysis must still consider the cross products of values in these sets but by adding context we hope that the set of pairss i jai bjwill be much smaller than the original cross product a b. the major difference with our approach is that structural correlation defines the desired output directly without committing to a particular implementation strategy.
points to analysis in contrast defines a particular framework in which the approach to improving precision is to refine increase the set of abstract locations.
no context sensitive points to methods have been shown to scale to programs the size of the linux kernel and based on the efforts that have tried we believe it is necessary to take a different approach.
the space consumption of a global points to graph particularly a context sensitive one is difficult to control.
thus our method does not build a global points to graph.
instead we first perform only local analysis of each function which is in fact much more detailed than a points to computation .
at the interprocedural level we trade time for space using an escape analysis to follow values through the program.
this analysis queries the local analysis information but does not build a global points to graph construct explicit contexts or refine abstract locations.
because we do not build a global points to graph or any global structures except for the structural correlations that are the output of the data polymorphism analysis we do not encounter the memory consumption problems that appear to limit the scalability of context sensitive points to analyses.
structural relationships and correlations are sufficiently general to tackle our polymorphism problem the algorithm for which we break into two phases.
first we scan all indirect call sites to identify the important structural relationships holding between the function pointer used to invoke the call and the data or other function pointers reachable from the arguments to the call section .
second we take in turn all the structural relationships identified for some indirect call site by the first phase and for each of these identify all the possible structural correlations between particular functions and values which could exist for that relationship section .
our algorithm is sound in the sense that if it identifies a structural relationship and associated structural correlations it is guaranteed that allof the possible structural correlations for that structural relationship have been discovered the algorithm has a complete view of the possible combinations of values that can be assigned to the fields involved in the structural relationship.
our algorithm is conservative in that it is not guaranteed to discover every structural relationship with non trivial correlations and even for the structural relationships it identifies as important it may fail to compute a set of structural correlations.
any field not in a structural relationship or in a structural relationship that could not be successfully analyzed is conservatively assumed to be able to take on any possible value for the field independent of the values of other fields.in summary our main contributions are we introduce structural relationships and structural correlations which characterize the desired output of any analysis of data polymorphism without implying a particular implementation technique.
we present an algorithm for computing structural correlations that is substantially different from conventional points to analyses and has advantages for analyzing very large systems.
in particular we combine very precise but separate local analysis of individual functions with demand driven and space efficient interprocedural search algorithms.
the core component of our search algorithm is an interprocedural escape analysis that may be of independent interest.
the novel aspect is tunable precision allowing us to conduct escape analysis at different granularities and use the most precise analysis which terminates with acceptable cost.
because both the cost and precision of an escape analysis query is unpredictable the ability to try different strategies is very important.
we give numerous examples of data polymorphism from the very simple to the very involved including examples that our system cannot handle fully automatically.
while the simple examples can be expressed in modern languages using parametric polymorphism the most involved examples are not readily expressible in any static type system known to us and furthermore we are unaware of any previous literature where such coding patterns are described.
these examples point out future challenges for both static analysis and static type systems in obtaining more expressive and automated systems for checking properties of large systems.
we give the results of a large experiment in which we are able to statically verify of downcasts to structure types in a version of the linux kernel out of a population of .
most of the components of our system have been described previously.
it is the system architecture the way the components are assembled that is new.
thus with a few exceptions for key aspects of our approach structural relationships correlations and some aspects of the interprocedural escape analysis we describe our approach at a relatively high level details may be found in .
.
structural relationships atrace is an access path a series of field accesses and pointer dereferences beginning with a global variable local variable function parameter or allocation site.
for example x f.g h is a trace starting from variable x. arelative trace orrtrace drops the starting variable or allocation site it is a pure sequence of field accesses and dereferences.
structural relationships are recorded in two maps one for structural relationships on types and one for functions srtype callsite trace type rtrace rtrace srfunc callsite trace trace trace consider a function gwith an indirect call f x at call site i. letatbe the trace which the call uses to access x inthis case a function argument and more generally a sequence of field selections dereferences from an argument .
now c rft rt srtype i at if there is a structure of typecsuch that the function pointer fis at relative tracerftfromcandxis at relative trace rtfromc.
also ft t srfunc i at if the function pointer fis reachable from an argument to gwith trace ftandxis also reachable from one of g s arguments with trace t. for the indirect call in run timers and the call s first argument a single structural relationship is found for sr type timerlist .function .data computing structural relations is a straightforward intraprocedural analysis.
taking a tuple i at as input we determine the trace ftthrough which the indirect call is invoked and the trace tpassed as argument atto the indirect call the memory model accounts for all prior assignments and control flow in the function invoking i .
occasionally there may be multiple different values for ftort depending on the path taken to reach i an example of this dentry open is shown in section .
.
in such cases we compute the relationships separately for each possible ft t. there is a problem however.
while using the plain arguments is sufficient for run timers some calls are concerned not with an argument but a field or transitive field of an argument again see section .
.
in general the amount of data reachable from each argument and thus the number of possible structural relationships is unbounded.
to bound the number of structural relationships we focus on relationships between function pointers and untyped data void pointers and integers which could be pointers in disguise such as the argument to saa7146 buffer timeout .
these relationships are the most likely to have meaningful structural correlations as well as being the most useful to the casting analysis.
the argument traces atwe consider are void call arguments void fields of call arguments or fields of fields transitively without following dereferences any trace that might be cast by a target of the indirect call as determined by a separate interprocedural analysis to determine possible function pointer targets and a prepass to look for casts in each function.
.
structural correlations for each structural relationship for some function call we represent the correlations that may hold sctype name rtrace rtrace name name trace scfunc name trace trace name name trace each fnptr fn dt sctype c ft t is a possible correlation for the c ft t structural relationship.
for a value of typec the value assigned to trace ftmay be the function fnptr and the value assigned to trace tmay be the value of dtwhen accessed from some call to fn the function name fn is needed to give the context in which trace dtis interpreted.
the relation sc func is similar.
for the timer list relationship timer list .function .data there is a singlecorrelation introduced by vbi init saa7146 buffertimeout vbiinit vv vbiq there are hundreds of correlations for this relationship but no other uses saa7146 buffer timeout for the function pointer.
to compute correlations for a structural relationship r we first compute tuples wfn wft wt where function trace wftand trace wtmay be set for rwithin function wfn.
for sctype wfnincludes functions that write the fields of the relationship and wftandwtare the possible pairs of values written to those fields.
if only one field is written the other reflects the field s initial value.
for sc func wfnincludes functions calling the function containing the indirect call i andwftandwtare the corresponding values passed at that call site in wfn.
the actual correlations fnptr fn dt are computed from the triples wfn wft wt by converting the trace wftto one or more concrete function names fnptr via any of the following methods use an escape analysis to determine where wftcame from and which functions it could refer to section .
.
follow transitive structural relationships between wft andwt section .
.
if wftandwtare derived from the same structure or both passed into the current function they share a relationship whose correlations are a superset of the possible values for wftandwt.
ifwfnis always invoked through an indirect call look for structural relationships between wftand the function pointer used to invoke wfn section .
.
each of these approaches either fails or generates an overapproximation of the values of wftandwt.
if all approaches fail we set sc type or sc func to we could not capture the effect of all writes affecting the relationship.
otherwise we take the intersection of all the result sets to get the tightest overapproximation we can for the correlations on wfn wft wt .
.
escapedcorrelations we have developed an escape analysis determining where a value escaped from or where it may escape to.
as mentioned in section we use escape analysis to avoid the unpredictable space consumption of a global points to graph.
the escape analysis most novel aspect is tunable precision which we discuss further below.
our escape analysis is built upon a path sensitive intraprocedural memory and alias analysis that computes all aliases for each memory location accessed within a function body or loop in the manner of .
given a pair of traces this per function analysis returns the path sensitive condition within that function under which the two traces alias.
note that if the condition is false the traces cannot alias.
the escape analysis is demand driven flow insensitive and has limited context sensitivity but suffices for determining the functions referred to by many values of wft.
consider a function trace wfnin function f.escape backward f wfn the set of functions that could flow to wfn is calculated as follows we do not describe escape forward which is symmetric .
first f s local information is queried to determine traces wfnis equivalent to and in particular whether wfnis derived from a global or local variable an argument off a field of a heap allocated data structure or a constant a concrete function name .
the most interesting cases are handled as follows ifwfnaliases a function name we return a singleton set containing that function.
ifwfnaliases an argument xoff we return the union over all the following sets.
without loss of generality assumexis the only argument of f. for any direct call f e occurring in a function g we compute escape backward g et whereetis the trace for e. if the address of fis taken in function h we also compute the set of indirect call sites of fviaescape forward h ffn whereffnis the trace of the location to which fis assigned.
we add to the outputescape backward k at for each such indirect call in a function kwith argument trace at.
ifwfnaliases a structure field then we must compute both forwards and backwards escape information for that field to see what assignments to the field may flow towfn.
the output of the escape analysis is the set of concrete function names that can flow to wfn.
in the simplest cases such as in vbi init wftis already a named function and the escape analysis gives us an exact singleton set.
now consider the function vbi init without the write to vv vbi q.timeout.function i.e.
the line marked is removed .
in this case the value of wftis the value of the function pointer on entry to vbi init which is simply vv vbi q.timeout.function .
to compute the correlations we need to know what values this function pointer can have.
there are several ways to determine which concrete functions escape to this value we can examine values assigned to the.function field of a timer list anywhere in the program values assigned to the field .timeout.function of asaa7146 dmaqueue or to.vbi q.timeout.function of asaa7146 vv or values passed to vbi init through the function argument vv vbi q.timeout.function .
these are ordered by increasing precision any value assigned to the.timeout.function field of a saa7146 dmaqueue is also assigned to the .timeout field of a timer list but not vice versa.
a low level of precision may be too imprecise.
however the escape analysis cannot always determine the set of concrete functions for a value at a higher level of precision because it may be too expensive to explore all the possibilities at a very fine level of granularity.
in practice the best level of precision varies widely we try several and use the most precise result that succeeds.
in this example escape analysis using .function finds every function that could be assigned to anytimer list a uselessly imprecise overapproximation.
on the other hand usingvv vbi q.timeout.function followsvveverywhere it is passed in the code and the escape analysis fails after exceeding a resource threshold.
escaping using .timeout.function or.vbi q.timeout.function yields the correct result finding the only value that is assigned directly to this field chain is saa7146 buffer timeout and that the address of .timeout is not passed anywhere which will lead to thefunction field being written.
.
transitivecorrelations sometimes structural relationships are dependent on one another.
consider this code from the linux irq subsystem kernel irq manage.c int request irq unsigned int irq irqreturn t handler int void struct pt regs unsigned long irqflags const char devname void dev id struct irqaction action ... action kmalloc sizeof struct irqaction gfp atomic if !action return enomem action handler handler action flags irqflags cpus clear action mask action name devname action next null action dev id dev id ... typeirqaction has a function pointer handler called when a specific interrupt is received.
the handler field is passed among other things the void fielddev id so.handler and .dev id have a structural relationship r. eachirqaction is created within request irq note the function arguments handler anddev id .
there is thus another structural relationship r between variables handler anddev id and because of the assignments marked any correlations in r are also correlations of r. we detect such dependencies between structural relationships in a manner similar to the handling of indirect call sites section .
when computing structural correlations for the handler anddev id fields of irqaction we notice the assignments to those fields in request irq participate in r and add all correlations for r tor.
because there may be cycles in the graph of dependencies between structural relationships this process is iterate d to a fixed point i.e.
until no new transitive correlations are discovered .
.
dominatingindirectcalls more complicated types of data polymorphism correlate data with multiple function pointers.
these function pointers often manage the data s contents and we can recover correlations from calls to these functions.
consider this function in the saa7146 driver drivers media common saa7146 fops.c static ssize t fops read struct file file char user data size t count loff t ppos struct saa7146 fh fh file private data switch fh type ... thefile private data pointer has type void and thusfops read performs a cast we are interested in checking for type safety.
what s going on with this function?
in keeping with unix practice user applications in linux interact with many devices as if they were regular files.
linux has a common interface for defining new files the file operations structure a table of function pointers though not all are used by each driver or filesystem .
include linux fs.h struct file operations struct module owner loff t llseek struct file loff t int ssize t read struct file char user size t loff t ssize t aio read ... ssize t write ... ssize t aio write ... ... int open struct inode struct file int flush struct file int release struct inode struct file ... interaction with a fileis primarily through the function pointers in the f opfield pointing to the file s file operations .
for example vfs read reads out of a file include linux fs.h struct file ... struct dentry f dentry struct vfsmount f vfsmnt const struct file operations f op ... void private data ... fs read write.c ssize t vfs read struct file file char user buf size t count loff t pos ... ret security file permission file may read if !ret if file f op read ret file f op read file buf count pos ... return ret the system call sys read invokesvfs read directly.
to allowvfs read and other top level file operations to interact with saa7146 devices the saa7146 driver creates a file operations structure whose readfield is set to fops read .
notevfs read will indirectly call fops read .
drivers media common saa7146 fops.c static struct file operations video fops .owner this module .open fops open .release fops release .read fops read .write fops write ... now that fops read can be invoked why is the cast it performs correct?
interestingly video fops is never directly assigned to any file f op and writes to the f opfield are never directly correlated with writes to the private data field.
a more elaborate mechanism is in use.
function dentry open which opens a file sets the f opfield and calls itsopenmethod.
fs open.c static struct file dentry open struct dentry dentry struct vfsmount mn t int flags struct file f int open struct inode struct file ... f f dentry dentry f f vfsmnt mnt f f op fops get inode i fop ... if !open f f op open f f op open if open error open inode f if error goto cleanup all ... returning to the video fops used to store fops read we see the corresponding open function is fops open which sets theprivate data field of the file to the value expected by fops read .
drivers media common saa7146 fops.c static int fops open struct inode inode struct file fil e struct saa7146 fh fh null ... fh kzalloc sizeof fh gfp kernel if null fh ... goto out file private data fh fh dev dev fh type type ... for the polymorphic data analysis we need to correlate the f op read field of a file with the private data .
we cannot do this by looking for matched writes of f opand private data but instead by matching up the f op open function and the writes it performs with the f op read function.
the write we are most concerned with is in fops open tofile private data .
we are interested in the possible values for file f op read here and while that value is not written in fops open we can get information about it from the call stack.
now fops open is only called indirectly through dentry open and a few similar functions.
in each such function we can prove fops open is only called through file f op open the code is some variant of file f op open inode file .
we thus know in fops open file f op open fops open .
when this equality holds what are the possible values for file f op read ?
if we track the structural relationship for type file operations between its openandreadfields we can answer this question with the resulting correlations.
finding the correlations for this file operations relationship is straightforward as the openandreadfields are always written in synchronization with each other almost always in a global initializer.
with fops open in theopen field the only value for the readfield isfops read which is thus correlated with the value written to private data in fops open .
this dominating caller technique is geared towards relationships involving function pointer tables with an open type method that fills in private data for other methods in the table to access.
the technique in whole is .
for a function fn find a function pointer trace xft such that fnis called only when xftis a particular function xfnptr .
this dominance relation holds for fn if either fnis only called indirectly and xftis the invoked function pointer at each parent call site.
in this casexfnptr fn.
eachpfnthat can invoke fnis itself dominated by calls where xfnptr yftfor some yftinpfn.
searching for dominators is k limited to avoid unbounded call graph exploration using k has been sufficient.
.
look for a structural relationship on a struct type between xftandwft.
normally the type is a function pointer table like file operations .
.
if there is such a relationship then for each correlation between xfnptr and some zft the possible values for wftare the union over the the zft.
normally each zft is a particular function if not resolve with the escape analysis as in section .
.
.
results the version of linux we analyzed .
.
.
contains about .
million lines of code and indirect call sites.
of these call sites involve structural relationships a parameter to the call was either a void pointer or was a structure containing a void field.
from these call sites structural relationships were identified and an additional relationships were added by transitive correlations see section .
for a total of structural relationships.
of these were between structure fields and between the arguments to a function.
we successfully found the correlations for relationships including structure field relationships and function argument relationships the remainder were marked as failed .
of the call sites with relationships correlations were found for at least one relationship at sites.
our parallel implementation of the analysis took hours and minutes to run on a core cluster using hours of cpu time the analysis was written using a logic programming language which in our experience is much easier to develop analyses in than c but incurs a 20x to 40x slowdown over c .
analysis timed out on functions or .
of all functions analyzed these timeouts can cause us to unsoundly underapproximate the correlations.
we examined many of these timeouts which were generally caused by functions where the analysis would have ultimately failed anyway and thus did not affect the generated correlations.
the results of this analysis are crucial for our broader analysis for proving the safety of type casts .
out of a population of downcasts we prove the safety of .
of the total.
of the proved casts or require the polymorphic relationships identified here.
a small group of structures with polymorphic relationships are responsible for most proved casts different structures have some associated relationship used to prove at least one cast.
of the casts proved using polymorphism use relationships from a set of structures used to prove or more casts each and use relationships from a set of structures used to prove or more casts each.
this latter set includes both the file structure used to prove casts and timer list structure used to prove casts .
analyzing polymorphic relationships with sufficient precision for the casting analysis required annotations for several million lines of code .
these annotations are trusted they are assumed by the analysis and must be checked manually.
annotations are needed for three broad reasons general analysis imprecision leading to results too imprecise for the casting analysis.
this imprecision accounts for about of the annotations we needed.
the initialization of a structure may not fit the inference techniques our analysis uses to find correlations.
the fit is often close and we can use annotations to adjust the inference to match the initialization.
the structure s polymorphism might not fit the model of structural relationships our analysis uses.
we can sometimes fit these cases so that we can capture the needed correlations even if our analysis of the structure s internals is largely incomplete.
the following subsections give examples of each category.
.
analysis overapproximation when initialization of multiple fields of a data structure is split across many functions we need precise knowledge of which fields are uninitialized null or non null at various control points to generate precise correlations.
consider again the dentry open function from section .
.
in this example we are interested in structural relationships between the private data field of a fileand thereadand other fields of that file s f optable.
the f opis written in dentry open andprivate data is written in the indirect call toopen.
our analysis sees the f opwrite in dentry open and noprivate data write and so correlates all possible values off op read all filereadfunctions in existence with the input value f private data .
simply inlining the possible targets of opencannot help some openmethods do not setprivate data as those filesystems never use that field.
now dentry open is only called during initialization of f and the only possible value for f private data at entry to dentry open isnull.
unfortunately our system misses that f private data isnulldue to tricky initialization code.
usually dentry open is called through dentry open which directly allocates a filewithnullcontents throughget empty filp this case is easy to analyze.
fs open.c struct file dentry open struct dentry dentry struct vfsmount mnt int flags struct file f ... f get empty filp if f null ... return dentry open dentry mnt flags f null the difficult case is lookup instantiate filp another caller of dentry open which passes in as the file argument nd intent.open.file a pointer to data allocated by its own callers.
fs open.c struct file lookup instantiate filp struct nameidata nd struct dentry dentry int open struct inode struct file ... nd intent.open.file dentry open dget dentry mnt get nd mnt nd intent.open.flags nd intent.open.file open ... while the nd intent.open.file pointer is always either nullor points to an empty filein this function it is allocated several levels up the call chain and across potentially multiple indirect calls.
we use one annotation to disable correlations between fields of the filestructure within dentry open .
in general the annotations we used to fix imprecision either disable a portion of the analysis for some function where so will not cause the correlations to be underapproximated or correct some intermediate analysis information to increase the precision of the correlations.
.
unhandledinitialization some data structures have important structural relationships but the initialization is a poor fit for our inference algorithm.
for example in some sound pcm layer structures snd pcm ops is a function pointer table used by snd pcm and its children include sound pcm.h struct snd pcm struct snd card card ... struct snd pcm str streams ... void private data void private free struct snd pcm pcm ... struct snd pcm str int stream struct snd pcm pcm unsigned int substream count unsigned int substream opened struct snd pcm substream substream ... struct snd pcm substream struct snd pcm pcm struct snd pcm str pstr void private data ... struct snd pcm ops ops ... struct snd pcm substream next ... eachsnd pcm has two child snd pcm str structures in itsstreams field each snd pcm str has a list substream of snd pcm substream structures that are linked through the nextfield.
each object has pointers back to its parents.
there are important structural relationships between the function pointers in the opsfield of a snd pcm substream and itsprivate data field.
writes to the opsandprivate data fields ofsnd pcm substream are not correlated in the usual way.
instead of writing both fields together functions initializing the parent snd pcm write to the opsfield ofallthe associated substreams with the snd pcm set ops helper function but only write to the private data of the parentsnd pcm .
an example is in snd atiixp pcm new which is called during device probe and allocates and initializes a new snd pcm .
sound core pcm lib.c void snd pcm set ops struct snd pcm pcm int direction struct snd pcm ops ops struct snd pcm str stream pcm streams struct snd pcm substream substream for substream stream substream substream !
null substream substream next substream ops ops sound pci atiixp modem.c static int devinit snd atiixp pcm new struct atiixp m odem chip struct snd pcm pcm int err ... err snd pcm new chip card ... pcm if err return err snd pcm set ops pcm sndrv pcm stream playback snd atiixp playback ops snd pcm set ops pcm sndrv pcm stream capture snd atiixp capture ops pcm dev class sndrv pcm class modem pcm private data chip ... after initialization the substream s opsis set but not itsprivate data .
this state persists until the substream is opened in snd pcm open substream which looks up the substream via snd pcm attach substream which scans the substreams in the snd pcm finds one that is not in use and sets itsprivate data to theprivate data of the parent snd pcm .
sound core pcm native.c int snd pcm open substream struct snd pcm pcm int stre am struct file file struct snd pcm substream rsubstream struct snd pcm substream substream int err err snd pcm attach substream pcm stream file subst ream if err return err ... if err substream ops open substream goto erro r ... sound core pcm.c int snd pcm attach substream struct snd pcm pcm int st ream struct file file struct snd pcm substream rsubstream struct snd pcm str pstr struct snd pcm substream substream ... pstr pcm streams if pstr substream null pstr substream count return enodev ... for substream pstr substream substream substream substream next if !substream busy substream break if substream null return eagain ... substream private data pcm private data substream ffile file pstr substream opened rsubstream substream return by correlating a write to snd pcm private data with calls tosnd pcm set ops a pcm driver ensures when the substream is opened the correlation between private data and theopsused insnd pcm set ops is introduced as a correlation in the snd pcm substream structural relationship.
our annotations add correlations for snd pcm substream whensnd pcm private data is written or snd pcm set ops is called not when the opsorprivate data fields of the snd pcm substream itself are written.
.
unhandledpolymorphism the most interesting uses of polymorphism are those our analysis cannot even express.
there are not many of these but they are generally important.
we have annotated one such case the sysfs filesystem providing a mechanism to check the casts performed by clients of sysfs with the usual limitation that the annotations are trusted we assume sysfs follows the annotated behavior.
in this section we describe the interface sysfs uses to expose its polymorphism which we have annotated and the internal invariants sysfs maintains for this interface which our analysis has little understanding of.
sysfs provides a mechanism for userspace programs to query and update attributes of the drivers and associated devices by accessing files in the sysdirectory.
to the driver writer this functionality is behind a simple polymorphic interface which relates a kernel object kobj each device used in sysfs has its own kernel object with an attribute with a name and access mode read read write etc.
.
include linux sysfs.h int sysfs create file struct kobject kobj const struct attribute attr struct attribute const char name struct module owner mode t mode the driver uses sysfs create file by passing the device s kernel object and the attribute to associate with the device.
drivers block aoe aoeblk.c static ssize t aoedisk show state struct gendisk disk char page struct aoedev d disk private data return snprintf page page size ... static struct disk attribute disk attr state .attr .name state .mode s irugo .show aoedisk show state static void aoedisk add sysfs struct aoedev d sysfs create file d gd kobj disk attr state.att r sysfs create file d gd kobj disk attr mac.attr sysfs create file d gd kobj disk attr netif.att r sysfs create file d gd kobj disk attr fwver.att r in this example there is a correlation where the disk parameter to aoedisk show state is equal to the d gd value as passed into a call to aoedisk add sysfs .
we need to know this correlation to show that the cast of disk private data performed by aoedisk add sysfs is correct.
we use a total of annotations to capture the correlations introduced by calls to sysfs create file and several wrappers which create sysfs files for particular kinds of devices.
these annotations do not address the internal invariants of sysfs the machinery hidden behind sysfs create file and the filesystem itself which ensures aoedisk show state is called with the right value.
the remainder of this section describes these invariants.
calling sysfs create file eventually leads to a file with the following file operations see section .
for a description of file operations .
fs sysfs file.c const struct file operations sysfs file operations .read sysfs read file .write sysfs write file .llseek generic file llseek .open sysfs open file .release sysfs release .poll sysfs poll when a user tries to read this file the sysfs read file function is called which invokes aoedisk show state on the correctdiskargument to get the state of the disk.
fs sysfs file.c static ssize t sysfs read file struct file file char user buf size t count loff t ppos struct sysfs buffer buffer file private data ... if buffer needs read fill fill read buffer file f dentry buffer ... static int fill read buffer struct dentry dentry struct sysfs buffer buffer struct attribute attr to attr dentry struct kobject kobj to kobj dentry d parent struct sysfs ops ops buffer ops ... count ops show kobj attr buffer page ... fs sysfs sysfs.h static inline struct attribute to attr struct dentry de ntry struct sysfs dirent sd dentry d fsdata return struct attribute sd s element static inline struct kobject to kobj struct dentry dent ry struct sysfs dirent sd dentry d fsdata return struct kobject sd s element block genhd.c define to disk obj container of obj struct gendisk k obj static ssize t disk attr show struct kobject kobj struct attribute attr char page struct gendisk disk to disk kobj struct disk attribute disk attr container of attr struct disk attribute attr if disk attr show disk attr show disk page static struct sysfs ops disk sysfs ops .show disk attr show .store disk attr store now the function sysfs read file calls the helper functionfill read buffer which gets an attribute andkobjectfrom the file and performs an indirect call ops show to fill in the data from the attribute which will be returned by the file read.
if the attribute read is disk attr state.attr or any other attribute of a gendisk theopspoints to disk sysfs ops andops show callsdisk attr show which backs out the kernel object pointer to the containing gendisk d gd in the call to aoedisk add sysfs and the attribute pointer to the containing disk attribute disk attr state .
finally disk attr state.show points to aoedisk show state completing the call chain from sysfs read file .this example assumes numerous data invariants which must hold or else the indirect calls will break.
our analysis can capture some of these invariants but user annotations are required for the rest for more details see .
more complete automatic checking for these properties at this scale is well beyond what is currently feasible with existing techniques.
.
relatedwork our analysis can be characterized as simultaneously scaling to large programs millions of lines of code being a verifier i.e.
proving properties in contrast to finding bugs and being highly heap sensitive meaning simply that to be successful it requires a relatively deep understanding of the relationships between data structures in the heap.
several bug finding non verifying efforts have scaled to systems of the size we consider representative examples include .
fewer verifiers have been demonstrated to work on million line programs and these have focused on finite state properties these systems are subject to the caveat as is our system that portions of the analysis may be unsound due to time outs and other resource limits for a small portion of the analysis .
we are not aware of any previous work on verifying type casts that scales to programs of the size that we analyze and more generally we are not aware of any verification system that is heap sensitive on multi million line programs.
c and c are alone among widely used typed languages today in not providing type safety guarantees.
consequently research has sought to ensure that c programs are type safe or to replace c with similarly expressive type safe alternatives.
most work focuses not just on type safety but memory safety as well ensuring nullor dangling pointers are not dereferenced buffers do not overrun and so forth .
siff et.
al.
describe rules for physical subtyping in c and examine the casts in several hundred thousand lines of code.
they find that about of the downcasts involving structure types in c are between void orchar and a structure rather than between different structure types.
in the linux kernel version we analyzed we found far fewer casts involving structure subtyping just out of casts or and involving just different supertypes.
for these casts we use the same physical subtyping rules as to determine compatibility between the structures.
however rather than just counting the number of downcasts in a program our interest is in proving these casts correct.
loginov et.
al.
compute type information for c programs at runtime and check the program s behavior against these types to find type safety violations.
since virtually any access in c might be type unsafe virtually all memory accesses are instrumented by this method leading to an average slowdown of greater than times the original program s runtime.
havoc is a static analysis system for c programs that uses function preconditions postconditions and loop invariants to perform modular verification of memory safety and other properties.
havoc has recently been used to verify type safety for a few windows device drivers .
havoc provides far stronger guarantees about a program than the casting analysis we present we are only checking downcasts to structure types while havoc checks these as well as downcasts to other types use of the container of macro to jump to a structure s base pointer buffer overflows andall other ways type safety might be violated.
however to completely verify lines of code havoc requires changes to the code trusted annotations annotations which like our annotations are not checked for correctness and untrusted annotations which are checked for correctness .
at these rates annotating and checking a system the size of the linux kernel would require several hundred thousand lines of annotations.
ccured uses pointer type qualifiers in combination with runtime checks to check type and memory safety in c with fairly low overhead.
pointers used in downcasts are transformed into fat wild pointers structures which contain both the pointer and additional bounds and runtime type information to perform the appropriate checks at accesses to the pointer.
the initial version of ccured would mark as wild any pointer whose value might have been used in a downcast or might in the future be downcast according to a global flow and context insensitive algorithm .
for polymorphic structures such as file and timer list this would encompass all uses of the data which at any point were stored in their void data fields.
an improvement allows most pointers which are downcast to be less than fully wildat the cost of limited runtime type information attached for checking the downcast is safe.
after the downcast and checks are performed the result is a safepointer which can be accessed in the future with few additional checks.
deputy is a type system for c that uses a more lightweight approach than ccured inserting runtime assertions where necessary without changing the in memory layout of pointers and other structures.
when dealing with downcasts from one type to another deputy soundly checks the cast at compile time provided the pointers are annotated with correct dependent types.
the dependent types used by deputy cover the parametric polymorphism as used in many of the linux kernel data structures but not other rarer constructs such as pointers whose type depends on a program condition.
moreover even if suitable polymorphic types are assigned for the various polymorphic structures in linux it is not clear that the deputy checker can deal with many of the intricacies found in initialization of these structures for example the f opfield of a filemay be freely changed so long as its private data isnull section .
.
cyclone is a c like language that ensures memory and type safety sharing many of the same features as ccured and deputy.
pointers used in arithmetic can be either fat as in ccured or be associated with a specific length as in deputy.
casts are allowed in cyclone but only from a subtype to a supertype downcasts are disallowed.
types in cyclone can be polymorphic in a similar fashion to deputy again handling many of the polymorphic structures we have seen in linux and removing the need for many downcasts.
still cyclone requires that the type over which a polymorphic structure is instantiated be set at the creation point of the structure which breaks on initializers such as thefileopen example section .
.
our approach to modeling polymorphic structures is more indirect than the approaches used by deputy and cyclone and does not try to associate type variables with the structure declarations and concrete type instantiations at each point the structure is used.
this allows us to handle cases such as the fileopen example as we do not have to fix a type to a fileat the points where it in fact has no type.finally more modern languages than c such as c and java have richer type systems that can directly express polymorphic interfaces a c programmer must construct by hand.
for example timer list could be implemented as a c template structure and file operations could be implemented as virtual methods in a c class.
whether such languages are appropriate for a full fledged operating system is a divisive topic we observe though that the file open example illustrates the flexibility of c to write code which falls outside the usual approach of a c or java program.
.
conclusion big software systems are tremendously complex with all their details taken together.
by focusing on downcasts we are able to peel away and characterize a small portion of this complexity.
the combination of polymorphic data structures and initialization via assignment leads to important and sometimes complex relationships that are critical to proving basic safety properties of large systems.
understanding these heap invariants is a challenging static analysis problem and we have shown that it can be solved automatically for many but not all of the common idioms in the linux kernel.
we suspect the results apply beyond linux and c in particular we expect large systems written in untyped scripting languages will display similar phenomena and we even suppose that similar implicit structural correlations can be found in large systems written in strongly typed languages such as java at least for properties of fields that are not directly enforced by the strong type system.
.