scenario based and value based specification mining better together david lo school of information systems singapore management university davidlo smu.edu.sgshahar maoz dept.
of computer science rwth aachen university germany maoz se rwth.de abstract specification mining takes execution traces as input and extracts likely program invariants which can be used for comprehension verification and evolution related tasks.
in this work we integrate scenario based specification mining which uses data mining algorithms to suggest ordering constraints in the form of live sequence charts an inter object visual modal scenario based specification language with mining of value based invariants which detects likely invariants holding at specific program points.
the key to the integration is a technique we call scenario based slicing running on top of the mining algorithms to distinguish the scenario specific invariants from the general ones.
the resulting suggested specifications are rich consisting of modal scenarios annotated with scenario specific value based invariants referring to event parameters and participating object properties.
an evaluation of our work over a number of case studies shows promising results in extracting expressive specifications from real programs which could not be extracted previously.
the more expressive the mined specifications the higher their potential to support program comprehension and testing.
categories and subject descriptors d. .
software engineering requirements specifications tools d. .
distribution maintenance and enhancement restructuring reverse engineering and reengineering general terms algorithms design experimentation keywords specification mining dynamic analysis live sequence charts value based invariants .
introduction a specification typically imposes constraints both on sequencing of method calls or statement executions ordering constraints and on values that method parameters or some variables at a program point could have value constraints .
one takes a separate viewpoint from the other and each independently although interesting is unable to present the full picture on the specification that a system should follow.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.motivated by the lack of documented specifications recently a number of studies have investigated mining of suggested specifications from program executions e.g.
.
the mined specifications whether value based invariants automata finite state machines or scenario based behavioral models may be used for tasks related to program comprehension verification and evolution.
one pioneering work daikon mines for value based invariants that hold at user specified program points .
values of method parameters object properties etc.
are collected at selected program points during execution and are then generalized in order to suggest invariants that hold at these points.
also recently we have investigated mining an expressive visual sequence diagram like scenario based specification in the form of live sequence charts lsc using a data mining approach .
however these have only considered ordering constraints among method calls.
in this paper we merge the two specification mining approaches the value based approach of daikon and our scenario based approach resulting in one that mines a combination of ordering and value based invariants.
the key to the merging is a multi step mining process and a novel dynamic slicing technique we call scenario based slicing where the mined scenarios are used as a slicing criteria over the input traces.
following the initial scenario based mining value based invariants found over the sliced traces are compared against value based invariants found over the original traces so as to distinguish the ones unique to the scenarios context.
finally the invariants found are attached to the mined scenarios.
thus the resulting approach strengthens the expressive power of the mined scenarios by enriching them with scenario speci c value based invariants .
to illustrate the advantages and challenges of mining scenarios with value based invariants consider the following example taken from one of our case study applications crossftp a commercial open source ftp server.
using the scenario based specification mining technique presented in previous work we were able to mine the scenario shown in fig.
.
roughly this scenario specifies that whenever a pasv command object calls the method setpasvcommand ... of the ftpdataconnector dc and the dccalls the getssl ... method of a ftpdataconnectionconfig dcc it must eventually call the createserversocket of an ssl object ssl .
however the mined scenario does not provide information on the values of parameters used and participating object properties whenever this scenario indeed happened .
are there any value based invariants related and unique to this scenario?
note that discovering general value based invariants related to the methods that appear in this scenario or to its participating objects may not be good enough.
the same method may be called with different parameters in different contexts and thus the invariant we may extract from its calls would be too general in essence too weak not contributing to the understanding of the scenario at hand.
similarly participating object properties may hold different values in different contexts.
scenario based slicing is used to address this problem.
following the process of scenario based specification mining we construct a sliced trace by selecting from the original traces used for mining a concatenation of only the sub traces representing instances positive witnesses of the mined scenario at hand.
we then look for value based invariants twice on the original trace and on the sliced trace and compare the results in order to identify the scenario specific invariants those value based invariants that are unique to the witnesses of the scenario.
indeed to continue the example just presented we were able to find that whenever this scenario happens the property secure of the ftpdataconnection dc is true.
this invariant does nothold in general in our traces and hence is not suggested by daikon when running on the original traces.
however it does hold whenever the scenario we examine happens!
thus the combination of value based specification mining and scenario based specification mining through the use of scenario based slicing is able to produce expressive candidate specifications that each of the mining approaches alone is unable to produce.
as shown in previous work the mined specifications may be used for tasks related to program comprehension testing and verification.
naturally the more expressive the specification mined the better it may support these tasks.
specifically program comprehension is enhanced with stronger candidate invariants combining execution order and values.
tests that are induced by these invariants are more accurate and hence more valuable.
we have implemented our ideas and evaluated them using a number of case study applications see sec.
.
the examples throughout the paper are taken from two of these crossftp mentioned above and jeti a feature rich instant messaging application.
specification mining in general and combining mining of value based invariants with mining of ordering constraints in particular has been recently considered and implemented see e.g.
.
we discuss related work in sec.
.
paper organization sec.
covers background material on lsc scenario based specification mining and value based specification mining.
the syntax and semantics of scenarios with value based invariants our target specification formalism are presented in sec.
.
sec.
describes the mining framework and algorithms.
the results of case studies are given in sec.
.
sec.
discusses some advanced issues of our work its advantages and its limitations sec.
discusses related work and sec.
concludes.
.
background we provide background material on lsc scenario based specification mining and value based invariants mining.
.
live sequence charts live sequence charts lsc extend classical sequence lsc set pasv short setpasvcommand ... createserversocket ... ssl dcc dc pasv getssl ... figure example lsc secure pasv diagrams with a universal interpretation and must may modalities.
they thus allow the specification of scenario based temporal invariants describing interactions between system objects.
the language has been used in the context of execution verification and synthesis see e.g.
.
a translation of lsc into temporal logics appears in .
a trace based semantics for a uml2 compliant variant of lsc appears in .
we use here a subset of the language with total order events.
an lsc is composed of two basic charts a pre chart and amain chart .
a basic chart is a tuple c cl ce c where clis a set of lifelines representing system objects ceis a set of inter object events involving the objects represented by the lifelines in cl and c is a total order on ce.
thus a chart can also be represented as a chain of events e1 e n .
we denote an lsc by l pre full where preis the pre chart and full is the concatenation of the pre chart and main chart.
syntactically lifelines are drawn using vertical lines.
interobject events are drawn using horizontal arrows from caller to callee pre chart events use dashed blue lines main chart events use solid red lines.
semantically an lsc specifies a temporal invariant whenever the events in the pre chart occur in the specified order eventually the events in the main chart must occur in the specified order.
an lsc does not restrict events not appearing in it to occur or not to occur during a run.
fig.
shows an example lsc.
roughly this lsc means that whenever a pasv command object calls the method setpasvcommand ... of the ftpdataconnection dc and thedccalls the getssl ... method of a ftpdataconnectionconfig dcc it must eventually call the createserversocket of an sslobject ssl .
.
scenario based specification mining scenario based speci cation mining is concerned with extracting statistically significant lscs from inter object traces of a system under investigation.
inter object trace event.
aconcrete inter object trace is a sequence of inter object events.
a concrete inter object event evis a tuple el1 el2 m representing an object el1 the caller calling method mof object el2 the callee .
we define the signi cance of an lsc based on its occurrences in the traces and measure it using support andcondence commonly used metrics in data mining .
below we recall the concepts of scenario instance positive and negative witnesses support and confidence defined in .
chart instance.
satisfaction of a chart follows the semantics of lsc.
we refer to a sub trace or a segment of consecutive events in the trace satisfying the chart cas an instance of c. a segment of a trace is said to be an instance of a chart cif it obeys the ordering specified by c. each event in the chart must map to a corresponding event in the segment appearing in the specified order.
other events not 388specified by the chart can occur in any order unrestrictedly.
to describe an lsc chart instance we use quantified regular expressions qre .
in our context quantified regular expression is similar to standard regular expression with as concatenation operator as exclusion operator i.e.
means any event except p and s1 and as the standard kleene star.
the formal definition of an instance of a chart is given in defn.
.
see definition .
instance of a concrete chart .
given a concrete chart c cl ce c a trace segment sb sbi sbi sbi m is an instance of cifsb follows the qre expression e1 e2 en where ce e1 e2 e n i n ei cei and g ce.
fig.
shows a short sample from a trace.
the trace includes instances of the lsc shown in fig.
i1 i2 .
pasv dc setpasvcommand dc dcc getssl dc ssl createserversocket fri dc getdatasocket pasv dc setpasvcommand fw fri getuserargument dc dcc getssl pasv dc setpasvcommand fw fri getuserargument dc dcc getssl dc ssl createserversocket fri dc getdatasocket pasv dc setpasvcommand figure part of a sample trace pasv stands for the pasv class dcfor ftpdatacontroller dccfor ftpdataconnectionconfig the actual trace includes the full quali ed signatures of the classes and methods involved witnesses.
based on the above definition of a chart instance we define the notion of positive and negative witnesses of an lsc.
recall that an lsc is composed of a prechart and a main chart.
a positive witness of an lsc l l pre full is a trace segment satisfying i.e.
is an instance of the full chart by extension the prechart as well since preis a prefix of full.
a negative witness oflis a positive witness of prethat can not be extended to a positive witness of l orfull .
we say that a negative witness is a weak negative witness if the positive witness of precannot be extended due to end of trace being reached see discussion in .
we denote the set of all positive witnesses of an lsc l in a trace t by pos l t .
similarly we denote the set of negative witnesses as neg l t .
support con dence.
we use the above notions of witnesses to define the statistical support and con dence metrics for lsc.
support and confidence are commonly used statistics in data mining .
given a trace t the support of an lsc l l pre full denoted by sup l is simply defined as the number of positive witnesses of full found int.
the con dence of an lsc l denoted by conf l measures the likelihood of a sub trace in tsatisfying l s pre chart to be extended such that l s main chart is satisfied or the end of the trace is reached.
hence confidence 1the original notation is slightly modified for brevity.is expressed as the ratio between the number of positivewitnesses and weak negative witnesses of the lsc and the number of positive witnesses of the lsc s pre chart conf l t defjpos full t j jw neg full t j jpos pre t j notation wise when tis understood from the context it can be omitted.
the support metric is used to limit the extraction to frequently observed interactions.
the confidence metric restricts mining to such pre charts that are followed by particular main charts with high likelihood.
in scenario based specification mining we are interested in mining statistically significant lscs those which occur frequently in the trace have high support and in which the pre is followed by the main chart with high likelihood have high confidence .
a chart is said to be signi cant if it obeys minimum thresholds of support and confidence denoted by min supand min conf respectively.
for the lsc shown in fig.
and the trace shown in fig.
sup l conf l .
data mining algorithms to compute a statistically sound and complete set of lscs given a trace or a set of traces and thresholds for minimal support and confidence were presented in .
these were extended in to handle symbolic scenario based specifications at the class level rather than the object level in to handle the special case of trigger and effect mining and in to take advantage of architectural hierarchies.
.
value based invariants mining value based dynamic detection of likely invariants is concerned with reporting likely program invariants which hold at a certain point or points in a program s execution.
basically dynamic invariant detection runs a program observes the values that the program computes and then reports properties that were true over the observed executions.
a primary example of a dynamic invariants detector is daikon .
other examples are described in e.g.
.
as opposed to scenario based specification mining which like e.g.
is concerned with detecting temporal invariants in the form of ordering constraints over program events these tools aim at detecting value based invariants e.g.
in the form of arg1 false orreturn !
null for a certain method this.field has only one value for a certain object etc.
in our present work we integrate temporal invariants with value based invariants.
for value based invariants detection we use daikon.
for details on daikon internals see .
.
scenarios with value based invariants we now describe our target formalism namely scenariobased specifications with value based invariants.
we consider three types of value based invariants inside lscs invpre invpost and invglobal invpreandinvpostare attached to lsc events and may refer to event parameters or properties of the objects caller and callee involved in the event invglobal invariants are attached to the lsc as a whole and involve properties of objects participating in the lsc.
more formally a chart with value based invariants is a tuple ca cl ce c a where the events in ceare 389tuples el1 el2 m inv pre invpost representing an object el1 the caller calling method mof object el2 the callee with invpreholding immediately before the call invpostholding right after the call and ais a set of global invariants holding throughout the chart instance occurrence.
semantically an lsc l pre full made of basic charts annotated with value based expressions specifies a temporal invariant whenever the events in the pre chart occur in the specified order their corresponding invpreandinvpost expressions hold and the pre chart s global invariants hold throughout its occurrence eventually the events in the mainchart must occur in the specified order their corresponding invpreand invpostexpressions must hold and the mainchart s global invariants must hold throughout the occurrence of the main chart.
naturally an lsc does not restrict events not appearing in it to occur or not to occur during a run and does not restrict the properties appearing in its value based invariants to take any value outside the lsc context.
in the visual syntax of the lsc invpreandinvpostexpressions may be drawn adjacent to the arrow representing their corresponding event or in a table below the chart together with the invglobal expressions.
fig.
shows an example lsc annotated with a valuebased invariant.
the invariant found this.secure true is a global one related to a property of dc one of the objects participating in the scenario.
additional examples are shown in sec.
.
note that the lsc language as described in includes conditions also called state invariants which specify hot cold conditions that must may hold during the occurrence of a scenario.
also the variant of lsc defined in includes forbidden conditions which may be used as invariants over the scope of the entire scenario.
our target formalism is similar with cold pre chart conditions and hot main chart conditions.
however it is also somewhat different tying conditions directly to events pre and postoccurrence and specifying not what should never happen but what should always happen throughout the occurrence of a chart.
.
mining framework our mining solution integrates daikon a value based specification miner with our previous solution for mining scenario based specifications in the form of lsc .
as is shown in fig.
the framework involves a number of steps trace generation and conversion scenario based specification mining scenario based slicing value based invariant generation via daikon and selection and integration of scenario specific invariants.
first the input application is instrumented using the daikon front end.
running the instrumented program produces a trace file daikon trace file dt which is converted to the format accepted by the scenario based specification miner lsc miner trace file lt .
running the scenario miner produces a set of scenarios all of which may be further enriched with value based invariants.
for each of the scenarios we take dt and transform it to a scenario based sliced trace sdt .
daikon is then invoked on the sliced and original traces i.e.
dt and sdt.
a comparison of the invariants found on the sliced trace and the original trace allows us to identify scenario specific invariants used to enrich and strengthen the suggested scenario based specifications.
.
instrument program using daikon chicory .
capture caller callee relationship object ids .
scenariobased specification miner .
scenariobased slicer .
daikon .
invariant comparator .
integrate scenariospecific value based invariants into the lscs daikon trace dt lsc miner trace lt scenarios lscs sliced daikon trace sdt invariants on dt invariants on sdt scenarios lscs daikon trace dt scenario specific invariants figure mining framework the steps are described in further detail below.
.
trace generation and conversion we use the daikon tool s front end to generate traces.
daikon provides a number of front ends for java c etc.
all of which produce a common trace format for daikon s input.
the trace files of daikon contain the list of records corresponding method entries and exits during the run.
each record contains information on method signature along with the values associated with different parameter values and global variables when each of the methods was entered or exited.
these traces are very rich as compared to the typical traces collected by most specification mining tools that mine for temporal ordering constraints invariants.
this is particularly needed by daikon so as to be able to infer valuebased invariants.
on the one hand the scenario based specification miner looks only for temporal relationships and does not need to know about parameters and global variables.
on the other hand the scenario based specification miner needs more information pertaining to the caller and callee of method calls.
thus we employ a converter to extract caller callee information based on the method entry and exit entries in daikon trace.
the converter also remove unneeded information for the scenario based mining process including values of global variables parameters etc.. .
scenario based specification mining given the converted traces we run a scenario based specification mining algorithm.
we are interested in finding scenarios that appear more times than a specified user defined min supthreshold.
each extracted scenario must also have its main chart appearing after each pre chart with likelihood higher than a min conf threshold.
the scenario based specification mining algorithm works in three steps mining frequent charts chart composition to lsc and chart redundancy elimination and post processing.
frequent chart mining.
the frequent chart mining algorithm is a variant of a pattern mining algorithm that models mining as a search space exploration.
different from a standard pattern mining algorithm that is agnostic to semantics of program specifications our specification mining algorithm follows the semantics of lsc when identifying and 390counting the chart pattern occurrences in the traces.
also since we consider scenario based specifications in the form of sequence diagrams the input events are not atomic symbols but rather triplets of caller callee and method call signature.
a simplified pseudo code is shown in fig.
.
procedure minefrequentcharts inputs t input trace min sup minimum support threshold output all frequent charts method let fev all frequent events in trace t for each evinfev growchart ev t fev min sup min conf procedure growchart inputs p chart so far t input trace fev frequent event min sup minimum support threshold output all frequent charts in the form of p evs method let nxtpat p e e fev for each nxtinnxtpat if sup nxt min sup output nxt growchart nxt t fev min sup min conf figure frequent chart mining algorithm the frequent chart mining process starts with chart of size and then tries to form longer patterns.
based on an anti monotonicity property see the support or number of occurrences of a pattern pshould be larger or equal to the support of pattern p evs where evsis one or more events.
in this case we only need to consider patterns of length one with support larger than the min supthreshold i.e.
frequent ones line .
each of the frequent events is then grown to form longer frequent patterns lines .
the search space of all patterns is traversed in a depth first fashion by appending one event at a time line .
at each step one would compare the number of occurrences of a pattern to the min supthreshold lines .
if the minimum support threshold is not met then based on the anti monotonicity property there is no need to grow the pattern further as longer patterns would not be frequent.
if the threshold is met the algorithm will output the pattern line and continue to try to grow the pattern further line .
the algorithm will eventually terminate with the set of all frequent charts.
chart composition to lsc.
an lsc consists of pre and main charts and has the semantics that dictates that the pre chart must be followed by the main chart.
given the set of frequent charts mined one could form lscs by composing these charts.
in particular one could pair two charts one being a prefix of the other.
consider two charts pre andpre post one could then form the lsc having preas the pre chart and post as the main chart.
the process is illustrated in fig.
.
note that due to the anti monotonicity property the support of the pre chart is larger or equal to the support of the chart del a ondeletestart fc dele lsc del setdelete setdelete ondeleteend fsi fc delelsc del setdelete setdelete ondeleteend fsi fc dele chart del b setdelete ondeletestart ondeleteend fsi fc deleu conf lsc del min conf ?
outputyes figure chart composition to lsc pre chart concatenated with the main chart.
following the semantics of lsc we are only interested in retrieving lscs where the pre is followed by the main chart.
since the trace could be incomplete there could be bugs in the system and we are analyzing long running reactive systems we provide users with the ability to extract near perfect scenarios where the pre chart is only followed by the main chart with likelihood less than .
we refer to this notion of likelihood based on the observed traces as the confidence of the lsc.
hence given a composition of two frequent charts resulting in an lsc with confidence greater than a minimum confidence threshold min conf we would output the lsc.
we refer to the lscs obeying the min supandmin conf thresholds as the set of signi cant lscs.
redundancy elimination and post processing.
often there are too many significant lscs.
one potential root cause is that all sub lscs of a large and significant lsc are potentially significant too.
thus there could be a combinatorial number of mined lscs.
thus it would be better to mine a representative set of lscs.
to do this we only extract maximal lscs without any larger lscs having the same significance values of support and confidence.
to do this efficiently we first bucketize the lscs into support and confidence value buckets.
a one to all comparison to look for non redundant lscs should only then be performed among lscs in each bucket rather than over all frequent and confident lscs.
the number of buckets depends on the number of unique combinations of support of confidence values of the lscs.
the more spread out the distribution of support and confidence value pairs the more effective the proposed process would be.
the process is illustrated in fig.
.
.
scenario based slicing after a set of scenarios is mined each scenario or selected ones may be enriched with value based invariants.
to do this the parts of the traces that correspond to a scenario under consideration are selected.
we refer to this process as scenario based slicing .
consider a scenario land a trace t the slice of the trace twith respect to lis the sequence of positive witnesses of lin the trace t. let and represent the concatenation of two sequences of events and the sub sequence relationship between two sequences of events.
391bucketization based on support and confidence values all significant live sequence charts bucket redundancy elimination one bucket at a time bucket bucket n figure redundancy elimination the scenario based slicing operation is defined as follows.
definition .
scenario based slicing .consider a trace t ev1 ev n and an lsc l. slicing twith respect to lproduces a sub trace st such that stis the maximal sub sequence of tcomposed of series of positive witnesses of l. formally st st1 stn where st tand st1 stn pos l t .
as an example consider the following trace user ftpwriter send ftpwriter ftprequestimpl getuserargument user ftprequestimpl resetstate pwd ftprequestimpl getsystemfileview pwd ftpwriter send user ftpwriter send ftpwriter ftprequestimpl getuserargument pwd ftpwriter send user ftprequestimpl resetstate lsc send simple getuserargument send resetstate ftprequestimpl ftpwriter user figure lsc send simple slicing the above trace with the lsc shown in fig.
results in the following sliced trace user ftpwriter send ftpwriter ftprequestimpl getuserargument user ftprequestimpl resetstate user ftpwriter send ftpwriter ftprequestimpl getuserargument user ftprequestimpl resetstate note that the 4th 5th and 8th events in the original trace are removed.
the above shows the simplified representation used for scenario based mining.
the system maintains a oneto one correspondence between the events in the lsc mining trace and the events in the daikon trace.
converting the events in the sliced traces back to daikon events produces a sliced daikon trace.
with the original daikon trace and the sliced daikon trace we are ready for the next step.
.
scenario specific invariants running daikon on the original trace produces invariants for entry and exit points of each of the instrumented methods.
these invariants hold for every invocation of the respective method in the traces.
while these are useful they are too general or generic and not scenario specific.
thus they are not good enough for our purpose.
on the other hand running daikon on the sliced trace produces invariants that hold at entry and exit points of each of the instrumented methods only when these methods participate in the witnesses of the scenario at hand .
this is because method invocations that do not participate in the scenario are not included in the sliced trace and hence are not considered for the computation of the invariants.
based on the invariants mined on the original and sliced traces we define the concept of scenario speci c invariants below.
definition .
scenario speci c invariants .let invorigandinvsliced be the set of invariants mined by daikon on the original trace and sliced trace respectively.
as the sliced trace is a sub trace of the original trace the invariants found on the former are equal to or stronger than the ones found on the latter.
we distinguish the strictly stronger invariants using a comparison of the two sets.
we call these invariants scenario speci c. this is the set invsliced invorig.
for example for the pasv scenario shown in fig.
daikon has not found an invariant related to the boolean property this.secure fordcin the original trace because in the original trace this property was sometimes true and sometimes false .
however daikon did find the invariant this.secure true in the sliced trace which included only the sub traces representing witnesses of the pasv scenario.
note that a syntactic comparison of the two sets is typically good enough for our purposes based on the assumption that daikon outputs semantically equivalent invariants using syntactically identical representations.
we discuss this assumption and its consequences in sec.
.
at the end of the process we have collected a potentially empty set of scenario specific invariants including invpre invpostfor each method and invglobal for the pre chart and the main chart.
finally we output the mined scenarios annotated with these invariants.
.
experiments evaluation we have implemented our ideas and evaluated them on two case study applications crossftp server and jeti instant messaging application .
crossftp is a commercial open source ftp server built on top of apache ftp server.
it consists of loc packages classes and methods.
jeti is a popular open source instant messaging application.
its core contains 49k loc packages classes and methods.
we report here on the results of our experiments running on an intel core duo .
ghz .
gb ram windows xp tablet pc .
the algorithms are implemented in c .net compiled using vs.net .
we used daikon chicory to generate traces from crossftp running it on usage scenarios involving start up file transfers administrator login and query server maintenance etc.
similarly we used daikon chicory to generate traces from jeti running it to chat or communicate with a remote client.
various details of the 392program crossftp jeti trace size evs evs scenario mining 53s 2s daikon all 132s 54s slicing time 11s 3s daikon sliced 31s 23s table experiment details program trace size scenario mining time daikon time trace slicing time and daikon mining on sliced traces time experiments including trace sizes and runtimes are shown in table .
we illustrate some miend scenarios in the following paragraphs.
retrieving connection information.
fig.
shows a scenario from crossftp specifying how the server retrieves information about the connection it is serving.
in the figure thectm ftpconnectiontablemanager retrieves the name and login time of the connecting user.
the table at the bottom of the lsc shows the scenario specific value based invariants found the colargument of method getvalueat is always set to when the scenario occurs.
this is nota general invariant for the method ctm but rather a scenariospecific invariant related to the context of this scenario.
different values of colargument are found in the traces.
additional scenarios involving other values of colare given in the technical report .
for the scenario shown in fig.
a total of scenariospecific invariants are reported.
this is much less than the value based invariants reported by daikon on the original trace consisting invariants.
indeed out of the cases described in this section and in the accompanying technical report the number of invariants on the sliced traces is only .
.
of that found in the original traces.
thus this demonstrates an additional benefit of scenario specific invariants limiting the number of value based invariants presented focusing particularly on a scenario context under investigation.
lsc retrieve connection info getvalueat ... getname ... getuser ... getlogintime ... fri buser env ctm col getvalueat value invariant post value invariant pre method col getvalueat value invariant post value invariant pre method figure mined lsc retrieve connection info pasv ftp command.
fig.
shows another mined scenario which holds when the pasv command is set.
an ftp has two modes of operation namely port and pasv in addition to secure using tls or ssl or regular.
the scenario captures the case when pasv command is set together with ssl.
we highlighted the most relevant scenario specificinvariant namely issecure true .issecure is a property of the class dc ftpdataconnection .
lsc set pasv command ssl getpasvport ... setpasvcommand ... getpasvaddr ... createserversocket ... ssl dcc dc pasv this.secure true ... dcvalue invariant object this.secure true ... dcvalue invariant objectgetssl ... getinetaddr ... getport ... send ... fri resetstate ... getftpdataconnection ... fw releasepassiveport ... figure mined lsc pasv command secure sending data several commands.
figs.
and show two different scenarios for crossftp where data packets corresponding to ftp commands user and pwd are issued.
two particularly interesting scenario specific valuebased invariants related to the parameters code and subid of the method send ... are found.
each of the two scenarios has unique scenario specific value based invariants for these two parameters.
similar examples are available in .
lsc send data user getuser ... getargument ... isloggedin ... setuserargument ... fw fri user subid.tostring user ... code subid.tostring user ... send value invariant post value invariant pre method subid.tostring user ... code subid.tostring user ... send value invariant post value invariant pre methodsend ... getuserargument ... isutf8encoding ... resetstate ... figure mined lsc send data user port command line startup.
fig.
shows one of the scenarios when the crossftp server starts using the command line option.
it shows the default case when the server is started up with no parameters.
it is also possible to start the server by passing an xml file.
note that for this scenario we capture the scenario specific invariants about the method getconfiguration including the size of the input args array must be empty and the type of the returned object must be equal to propertiesconfiguration .
another vari393lsc send data pwd getfilesystemview ... fw fri pwd subid.tostring pwd ... code subid.tostring pwd ... send ... value invariant post value invariant pre method subid.tostring pwd ... code subid.tostring pwd ... send ... value invariant post value invariant pre methodsend ... getlanguage ... resetstate ... figure mined lsc send data pwd port ant involving start up using xml file was also mined and is given in .
lsc command line start up default getfileftpd ... sf cl env args .tostring return.getclass org.apache.ftpserver.config.
propertiesconfiguration.cla ss ... args .tostring ... getconfiguration ... value invariant post value invariant pre method args .tostring return.getclass org.apache.ftpserver.config.
propertiesconfiguration.cla ss ... args .tostring ... getconfiguration ... value invariant post value invariant pre methodgetconfiguration ... figure mined lsc command line startup normal start chat window.
fig.
shows one of the scenarios when jeti is used to communicate with a remote client.
it specifies the scenario where a message comes the system beeps and a window is popped up by the jeti client.
eventually the chat window is set up and the system is ready to accept reply messages from the user.
this scenario involves jh jabberhandler jabber cws chatwindows and cw chatwindow .
note that for this scenario we capture scenario specific invariants about the method receivepackets .
the method accepts many different types of packets involving presence updates e.g.
busy away extended away etc error messages etc.
however in the context of this scenario there should be only one type of packet being received by method receivepackets namely message .
also we capture the scenario specific invariants involving the return type of method getchatwindow which in this scenario is always null a chat window creation occurs the create event which only happens if two parties have not communicated before causing the call to method getchatwindow to return a null value.
add incoming new picture.
fig.
shows a scenario where jeti received a new picture creation message from lsc create chat window beep ... message ... getchatwindow ... startchat ... cwcws jabber arg0.getclass nu.fw.jeti.jabber.elements.
message.class receivepackets ... return null getchatwindow ... value invariant post value invariant pre method arg0.getclass nu.fw.jeti.jabber.elements.
message.class receivepackets ... return null getchatwindow ... value invariant post value invariant pre method create setcwposition ... receivepackets ... requestcomposing ... jh appendmessage ... figure mined lsc create chat window another client the packet is received newmessage arrival message is passed the history is updated a creation object is created appropriate new picture creation methods are executed and finally the updated window is shown.
the scenario involves jh jabberhandler jabber pc picturechat pc a nameless internal class of picturechat ph picturehistory c creation and hp historypanel .
note the scenario specific invariant found for method addincomingmessage .
the method accepts many different types of messages involving picture updates e.g.
creation display deletion change in background setting etc.
as the first argument i.e.
arg0 .
however for this scenario there is only one type of message being received by the method namely creationmessage .
lsc add incoming new picture newmessage ... pc jabber ... arg0.getclass nu.fw.jeti.
plugins.drawing.elements.creati onmessage.class ... addincomingmessage ... value invariant post value invariant pre method ... arg0.getclass nu.fw.jeti.
plugins.drawing.elements.creati onmessage.class ... addincomingmessage ... value invariant post value invariant pre method create addaction ... receivepackets ... jh pc ph chp addincomingmessage ... execute ... showwindow ... execute ... figure mined lsc add incoming picture .
discussion choice of the target formalism.
the popularity and intuitive visual nature of sequence diagrams as a specification language in general together with the additional unique features of lsc in particular the universal interpretation 394and its expressive power motivate our choice for the target formalism of our mining work.
moreover the choice is supported by previous work on lsc see e.g.
which can potentially be used to visualize analyze manipulate test and verify the specifications we mine see .
still one may consider other scenario based formalisms with different semantics as targets for mining e.g.
or more generally the mining of other useful behavioral patterns .
these alternatives require further investigation.
soundness and completeness.
our previous work on scenario based specification mining was sound and complete all mined scenarios met the minimum support and confidence thresholds soundness and all the scenarios meeting these thresholds were mined completeness .
hence it is important to note that our present work on adding valuebased invariants to the scenarios preserves soundness but gives up completeness.
since scenario based mining is done first independent of value based mining our current method might miss scenarios whose confidence statistics depends on their restriction with value based invariants when the pre chart is restricted the actual confidence may be higher than the one we computed without the restriction.
still our present work is sound all mined scenarios with their value based invariants indeed meet the minimum support and confidence thresholds.
developing a sound and complete method to mining scenario based specifications with value based invariants is left for future work.
identifying scenario speci c invariants.
a rather simple syntactic comparison of the invariants found on the original trace and on the sliced trace suffices to identify the scenario specific invariants we are looking for.
comparison correctness relies on the fixed and simple default syntax of daikon s output textual representation of these invariants.
however in some cases a simple syntactic comparison may not be good enough because two equivalent invariants may be represented syntactically different.
this indeed happened in one of our experiments where daikon reported this.language orig this.language for the original trace and this.userargument this.language this.userargument orig this.language for the sliced trace see fig.
just after the return of getargument .
to handle such cases in general a constraint solver should be used to identify semantic differences regardless of the syntactic representation.
we leave this for future work.
additional limitations.
two additional limitations of our present work should be mentioned.
first we handle only fully ordered scenarios and cannot handle partial orders.
second in a multi threaded environment one may be interested in mining thread specific specifications however our present work is agnostic to threads.
we leave these two as challenges for future work.
integration with previous work.
it is important to note that our method of adding value based invariants to scenario based specification mining is applicable to the various variants of the latter that is to the mining of scenariobased triggers and effects presented in and to the mining of hierarchical scenario based specifications presented in .
also in the present work object ids are abstracted away from the input traces.
as discussed in previous work this cannot be done in the general case thus we implicitly assume no overlapping lscs.
relaxing this restriction requires further work see .
we leave the implementation of these integrations and their evaluation for future work.
.
related work reverse engineering of sequence diagrams.
many works present various variants of reverse engineering of objects interactions from program traces and their visualization using sequence diagrams see e.g.
.
these may seem similar to our current work.
unlike our work however all consider and handle only concrete continuous noninterleaving and complete object level interactions and are not using aggregations and statistical methods to look for higher level recurring scenarios the reverse engineered sequences are used as a means to describe single concrete and relatively short sub traces in full and thus may be viewed not only as concrete but also as existential .
in contrast we look for universal modal sequence diagrams which aim to abstract away from the concrete trace and reveal significant recurring potentially universal scenario based specification ultimately suggesting scenario based system requirements.
automata based speci cation mining.
most specification miners produce an automaton e.g.
and have been used for various purposes from program comprehension to verification.
unlike these we mine a set of lscs from traces of program executions.
we believe sequence diagrams in general and lscs in particular are suitable for the specification of inter object behavior as they make the different role of each participating object and the communications between the different objects explicit.
thus our work is not aimed at discovering the complete behavior or apis of certain components but rather to capture the way components cooperate to implement certain system features.
indeed inter object scenarios are popular means to specify requirements see e.g.
.
the addition of value based invariants strengthens the expressive power of the mined scenarios.
mining of automata with value based invariants.
most studies on specification mining extracting automata to date do not capture value based invariants.
some recent works do.
we briefly discuss these below.
mariani and pezze work reports both value based invariants and automata to help component integration.
the value based invariants are mined using daikon while the automata are mined using an automata learner.
in contrast we do not mine general invariants rather we merge value based invariants and sequencing constraints to form scenario specific specifications.
also while an automaton describes the entire behavior of a system a scenario describes only a certain aspect of it.
different from the model mined in our mined scenarios also capture caller and callee relationships and present them in the intuitive visual syntax of sequence diagrams.
lorenzoli et al.
integrate daikon invariants with an automaton using a four steps approach merging all traces with the same sequence of methods invoked with different values of the parameter inferring daikon invariants from each of the merged traces creating an initial automaton and merging locally equivalent states based on the next k steps to obtain the final automaton.
our work is substantially different.
first we mine scenarios in the form of lsc which express universal properties in the form of whenever the pre chart occurs the main chart must eventually occur .
the automaton mined in expresses a global existential property modeling all executions that are allowed in the traces.
due to this difference the mining algorithms are very different see .
second may mix between different behaviors as it merges similar methods into one.
the different context of each invocation is lost in the merging.
in contrast our use of scenario based slicing and differencing ensures the mining of scenario specific invariants where the context information is preserved and highlighted.
mining of temporal rules with equality constraints.
lo et al.
mine length quanti ed temporal rules in the form for all x whenever method ais called with the nth parameter equals to x method cwould eventually be called with the mth parameter equals to x .
permits equality constraints.
in our present work we mine for scenarios in the form of lscs not limited to length two.
lscs capture caller and callee relationships not considered in .
while the approach in is shown to work only on equality constraints we support a wider subset of daikon invariants.
we introduce the concept of scenario specific invariants and realize it by scenario based mining slicing and differencing.
however captures quantified variables not supported in our present work.
adding quantification to our approach is left for future research.
.
conclusion future work we presented scenario based mining with value based invariants as an expressive extension of scenario based specification mining in general.
the key to the extension is a new technique we call scenario based slicing to distinguish scenario specific invariants from general ones.
the resulting suggested specifications are rich consisting of modal scenarios annotated with scenario specific value based invariants referring to event parameters and participating object properties.
an evaluation over a number of case studies shows promising results in extracting expressive specifications from real programs which could not be extracted previously.
the more expressive the mined specifications the higher their potential to support program comprehension testing and verification tasks.
the work is part of the larger framework of specification mining integrating behavioral models mining with value based invariants mining to improve the state of the art support for property discovering tasks.
future work directions relate to the challenges discussed in sec.
.
these include among others the development of a complete rather than only sound solution handling of partial orders and integration with previous work through lm the lsc mining tool .