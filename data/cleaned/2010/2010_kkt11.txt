a rule based approach to the semantic lifting of model differences in the context of model versioning timo kehrer udo kelter software engineering group university of siegen germany email fkehrer kelterg informatik.uni siegen.degabriele taentzer philipps universit at marburg germany email taentzer mathematik.uni marburg.de abstract in model based software engineering models are primary artifacts which iteratively evolve and which are often developed in teams.
therefore comparison and merge tools for models are indispensable.
these tools must compare models in a technology dependent run time representation and will initially derive low level changes which can differ considerably from user level editing commands.
low level differences are often incomprehensible and should be semantically lifted to the level of editing operations.
this transformation of differences depends on the model type supported editing operations and user preferences thus specific transformers are needed and building them is a challenge.
we present a rule based approach to this problem low level differences are represented based on the eclipse modeling framework.
they are transformed into representations of editing operations using a rule based model transformation engine.
the necessary transformation rules are automatically derived from basic transformation rules for the editing operations.
i. i ntroduction model driven software development mdsd is becoming common practice in many application domains.
models are in the center of development activities here they are iteratively edited during the development process.
mdsd requires fullyfledged tool support which includes tools for comparing merging and patching of models which we will collectively refer to as difference tools.
currently available difference tools for models are far from satisfying the low quality of these tools is often considered as one of the biggest obstacles against the wide acceptance of mdsd in practice .
this unfortunate situation has one main reason difference tools must be specifically engineered for each modeling language and more often than not be adapted to other tools and user preferences.
methods for developing better difference tools for models with limited implementation effort are therefore a primary concern.
this paper addresses a significant deficiency of current difference tools they present differences in terms of low level changes related to internal often tool specific representations of models.
in contrast to this developers perceive models in their external typically graphical representation and prefer changes to be explained in terms of basic editing commandsand if available in terms of refactorings and further complex editing operations.
difference tools are basically faced with two models which are to be compared and which are represented as contents of persistent storage media or as runtime objects.
persistent storage media include xml files proprietary file formats and relational databases.
in order to be processed by tools persistent representations of models must be loaded i.e.
must be converted into an internal representation consisting of runtime objects.
the internal representation can have the same structure as the persistent representation e.g.
some textual format but often it is converted into a tree structure.
it is commonly agreed that comparing textual representations of models does not produce usable results and that models should be compared on the basis of graph based representations.
internal representations of models depend on the technologies being used to implement difference tools notably the specific programming language and where applicable modeling frameworks such as the eclipse modeling framework emf .
internal representations can normally be considered as implementations of abstract syntax graphs asgs which represent the conceptual parts of models only.
fig.
.
original model a and its revision b the external and internal representations of a model and related changes can differ quite substantially.
figure showsan example based on uml models model a is the base version revision b has been obtained by two editing steps the navigation of association worksfor is restricted to one end indicated by adding an arrowhead1.
the attribute name was moved to superclass person using the refactoring pull up attribute .
if available difference tools compare the above versions a and b they will find the following set of low level changes on the basis of the first editing step reference ownedattribute from class person to property employer has been removed.
reference ownedend from association worksfor to property employer has been added.
reference class from property employer to class person has been removed.
reference owningassociation from property employer to association worksfor has been added.
these low level changes are not understandable for normal tool users who are not familiar with meta modeling and the internal representation of models.
we will recall the ecorerepresentation of uml models in section ii and present our internal representation of model differences in section iii.
there are several other examples where a seemingly simple change in the external graphical and or textual representation of model elements causes significant structural changes in the internal representation dragging an association end to another class or changing the text which represents the multiplicity of an association end a parameter list or a list of stereotypes discusses further examples in state machines and similar types of models.
the second editing step in figure pullupattribute leads to a model difference which contains low level changes the attribute name in the classes developer andmanager has been deleted and an attribute name has been created in class person .
most likely the tool user prefers the change being explained as application of refactoring pull up attribute on class person for the attribute name .
the examples mentioned have in common that a potentially large unstructured set of low level changes should be grouped in such a way that editing operations can be recognized.
editing operations form an adequate abstraction level for the user perception of model differences.
we use the term semantic lifting of differences to refer to this transformation of low level changes to more conceptual descriptions of model modifications.
in this paper we propose a technique for designing and implementing tool components which can semantically lift model differences.
we assume the usual structure of state based differencing algorithms as shown in figure initially a matching algorithm identifies corresponding model elements and relations in both models i.e.
corresponding nodes and edges in their asgs.
model elements and relations not involved in a correspondence 1we assume the usual presentation option here that an association without arrowheads is navigable in both directions.are considered to be deleted or created these insertions and deletions form the low level difference.
fig.
.
model differencing pipeline the low level difference is further processed by a semantic lifting component which identifies sets of atomic changes that implement an editing operation and determines these operations as well as their parameters.
these results are used by further components for e.g.
visualizing differences and merging models which are out of the scope of this paper.
in our approach the semantic lifting component is implemented using henshin a transformation engine for emf models.
to that end a low level difference is represented as an emf model.
finding groups of related low level changes is basically a pattern matching problem which is solved by the matching engine of henshin.
such a group is annotated with information about the editing operation it implements by a model transformation.
the main task to implement a semantic lifting component is thus to program henshin rules which find groups of related low level changes and which annotate these groups accordingly.
most of these henshin rules can be automatically generated from transformation rules specifying the corresponding editing operations i.e.
in accordance with mdsd principles we automatically derive these rules rather than to manually program them.
the effort required for implementing a semantic lifting component is significantly reduced in this way.
the rest of the paper is structured as follows.
section ii recalls how to specify editing operations of emf models by model transformation rules.
in section iii we introduce our representation of model differences which is later extended by the definition of semantic change sets.
section iv introduces our approach to specify instances of semantic change sets by recognition rules while section v explains how the recognition rules are to be executed.
section vi evaluates our approach and section vii compares our approach with other work.
section viii concludes the paper.
ii.
e diting of emf m odels throughout this paper we use the eclipse modeling framework emf as underlying technology for modeling.
emf allows us to specify modeling languages by the ecore metamodel.
moreover emf forms a suitable basis for model editors.
for example graphical editors based on emf can be generated by the graphical modeling framework gmf while the generation of textual editors is well supported by e.g.
xtext .
in we show how gmf generated editors can be extended by complex editing operations specified by emf model transformation rules.
to understand this idea better we reconsider the example presented in the introduction.to restrict the navigability of an association to one end the corresponding edit operation can be specified as in figure .
the variable p1serves as a parameter which shall be bound to the association end property to be restricted in navigability when the rule is applied.
variables r p2 c1 and c2 will be automatically bound to the association the opposite association end property and the adjacent classes.
fig.
.
sample editing operation in concrete syntax in order to be processed by modeling tools editing operations have to be specified based on the internal model representation.
since we consider uml models and take emf as underlying technology models are internally represented in the ecore based specification of the uml2 syntax.
figure shows a small excerpt from this meta model which is relevant for our example.
it shows three model elements class association and property together with their various relations.
properties being association ends may be owned by classes via ownedattribute or associations viaownedend .
an association end is navigable if it is owned by a class or if it is a navigableownedend owned by the association.
in this paper we assume navigable ends to be owned by classes and non navigable ends to be owned by associations.
fig.
.
excerpt of the ecore based implementation of the uml2 superstructure specification figure shows the effects of executing the first editing operation in our example i.e.
the restriction of navigability in the internal model representation.
initially property employer is owned by class person the ownership changes to association worksfor .
thus