dtam dynamic taint analysis of multi threaded programs for relevancy malay ganai neclabs america malay nec labs.comdongyoon lee university ofmichigan dongyoon umich.eduaarti gupta neclabs america agupta nec labs.com abstract testinganddebuggingmulti threadedprogramsarenotorio uslydifficult due to non determinism not only in inputs but also in os schedules.
inpractice dynamicanalysisandfailurerepla ysystems instrument the program to record events of interest in the te st execution e.g.
program inputs accesses to shared objects synchronization operations context switches etc.
to reduce the o verhead ofloggingduringruntime thesetestinganddebuggingeffo rtshave proposed tradeoffs for sampling or selective logging at th e cost of reducing coverage orperforming more expensive searchoffli ne.
we propose to identify a subset of input sources and shared ob jects that are in a sense relevantfor covering program behavior.
we classify various types of relevancy in terms of how an inpu t sourceorasharedobjectcanaffectcontrolflow e.g.
acond itional branch or dataflow e.g.
state of the shared objects in the program.
such relevancy data can be used by testing and debuggin g methods toreduce theirrecording overhead andtoguide cove rage.
to conduct relevancy analysis we propose a novel framework basedond ynamictaintanalysisform ulti threadedprograms called dtam.itperformsthread modular taintanalysisforeachthread in parallelduringruntime andthenaggregatesthethread mo dularresults offline.
this approach has many advantages a it is fa ster than conducting taint analysis for serialized multi threa ded executions b it can compute results for alternate thread int erleavings by generalizing the observed execution and c it prov ides a knobtotradeoffprecisionwithcoverage dependingonhowt hreadmodular results are aggregated to account for alternate int erleavings.
wehaveimplementeddtamandperformedanexperimenta l evaluationonpubliclyavailablebenchmarksforrelevancy analysis.
our experiments show that most shared accesses and conditio nal branches are dependent on some program input sources.
inter estingly in our test runs on average only about input sourc es and shared objects affect other shared accesses through c onditionalbranches.
thus itisimportanttoidentifysuchrele vantinput sources and sharedobjects for testingand debugging.
categories and subjectdescriptors d. .
testingand debugging keywords taint analysis relevancy generalization .
introduction with the advent of multi core processors there is great nee d to writeparallelprograms totakeadvantage ofparallelcompu ting resources.
however programming debugging and testing con current programs are notably difficult because of two types of in herent non determinism in multiprocessor systems inputs i. e. user permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and thefull citation on the firstpage.
tocop y otherwise to republish topostonserversortoredistribute tolists re quires priorspecific permission and or afee.
sigsoft fse november cary nc usa copyright acm ... .
.and system data from non deterministic sources and os sche dules i.e.
order of accesses tosharedobjects .
different inputs and schedules of concurrent threads may affect the shared objec t state andcontrol flow of programs.
thisimplies thatprogrammers have to reason about all possible inputs and schedules to underst and the behavior of multi threadedprograms.
therearemanyexistingeffortsfrombothsoftwareandhardw are communities to build useful tools that help program develop ers to address these challenges.
for example deterministic repl ay systems enable reproducing concurrency bugs suc h as data races and atomicity violations and backward time tra vel debugging.
systematic exploration techniques explo re all feasible schedules for a given test input.
runtime techniqu es such as fuzzing based testing focus onimproving the int erleaving coverage of some meaningful set using random sleep de lays while trace based analysis focus ondetectingandpredictingprogram errorsingeneralizati ons ofan observed schedule using either offline search or online analysis .
these testing and debugging tech niques instrument the program to record events of interest in the te st execution e.g.
inputs accesses tosharedobjects synchron ization operations context switches etc.
the recorded information are then used for detecting concurrency related bugs for predicti ng bugs in other thread interleavings for expanding testing cover age over otherthreadinterleavings orforreconstructinganobser vedfailure.
to reduce the overhead of recording inputs and events during runtime these testing and debugging efforts have proposed tra deoffs for sampling or selective recording at the cost of reducing coverage or performing more expensive search offline to find a tra ce with failure.
for example to reduce the performance overhe ad of dynamic data race detection a sampling based approach wa s proposed to process a small percentage of shared accesses b ased on infrequent visits thereby avoiding the need to analyze every shared access executed by the program.
though many of these previous efforts have addressed the cha llengesinthespaceofpossiblethreadinterleavingsinduce dbyshared object accesses the space of program inputs has received li ttle attention.
for instance deterministic replay systems record all program inputs regardless of their effect on pro gram behavior.
deterministic execution systems and syst ematic testing tools provide determinism or testing coverage guarantee only for a given input.
in addition some concurrency b ug reproduction tools assume that they can provide the sam e input during analysis.
the recording of inputs helps to reduce the search space however atthe cost of partialcoverage andinc reased overhead performance penalty .
to address these issues we propose relevancy analysis to id entify a subset of input sources and shared objects that can aff ect an execution of the multi threaded program.
we classify relev ancy basedonhowtheseinputsourcesandsharedobjectsaffectth econtrolflow branches ordata flow accesses of shared objects inthe program.
wealsoanalyzehowbranchesorsharedaccessesdep end oninput sources andshared objects.
therelevancyanalysisforinputscanbeusedtoreducethesp ace of inputs considered by other techniques.
a possible use ca se isto perform relevancy analysis on representative test data a s a preprocessing step before carrying out time sensitive testin g debugging or runtime monitoring to reduce the performance overh ead.
some examples of potential benefits provided to other techni ques are a a deterministic replay system need not record some i nput source if it does not impact program behavior and it can be eas ily generatedduringreplay.
thus monitoringandrecordingon lyrelevant input sources would reduce the overhead of such systems .
b in testing generating different input stress data only for relevant input sources would improve the testcoverage effectively.
similarly relevancy analysis for shared objects can also p rovide notable benefits a it can help to classify data races as mal ign or benign.
for example if a data race is on a shared object tha t does not have any effect on conditional branches one may cla ssify the race as benign since it is unlikely to affect the pro gram path.
b it can also empower a data race predictor to relax ce rtainread after writeorderingconstraints during the sea rchfordata races.
data race predictors such as use a happens bef ore analysis often with a relaxed ordering of lock unlock as lo ng as read after write raw constraints for shared objects are not violated.
thisavoidsreportingfalseraces.
however ifashar edobject does not affect any conditional branch itmay ignore its ass ociated raw constraints during race prediction thereby finding mor e potential races.
c it can also help sampling based race dete ction such as tofocus on onlyrelevant shared objects.
to conduct relevancy analysis effectively we propose a nov el frameworkbasedond ynamic taintanalysisform ulti threadedprograms called dtam.taintanalysisisshownuseful inmanyapplications includingsecurityattackdetectionandpreventi on informationflowpolicyenforcement andsoftwaretestinganddebugging .
static taint analysis e.g.
computes conservatively in formationflow within a program whereas dynamic taint analysis identifies flows that actually occur in one of the observed executions.
static analysis can produce spurious flo ws due toimprecisioninthetaintpropagation whiledynamic anal ysiscan misspotentialflowsdue tounobserved program executions.
i nthis work we focus on dynamic taint analysis and address its sho rtcoming initsapplication tomulti threadedprograms.
the general idea of dynamic taint analysis is as follows dur ing runtime it tags data from an external input source propaga tes the taint tag along data and control flows and then checks if tagg ed dataisusedatatargetinstruction statement e.g.
targe tlocationof ajumpinstruction .
inourdtamframework weuseauniqueid to tagdatafromeachinputsource andfromeachsharedobject.
i nput data include the return value of system calls and data copied from kernel to user space e.g.
data read by sys read .
our run time system propagates the tag along both data and control flows d escribed later .
we check the tags on instructions correspon ding to shared accesses and conditional branches toidentifyinpu t sources that are relevant.
although we target instructions corresp onding to shared accesses and conditional branches our dtam framewo rk is general and one canspecifyany targetlocation s of inte rest.
dynamic taint analysis for sequential programs is straight forward and efficient implementations have been proposed in pr ior work .
however dynamic taint analysis for m ultithreaded programs on multi core platforms remains a challe nge.
an implementation needs to carefully handle concurrent acc esses to shared objects from multiple threads and guarantee atom icity of original code and added instrumentation for taint propag ation and checking.
a naive approach would be to serialize the mult ithreadedexecution andsimplyapplysequentialdynamicta intanalysis on it.
however this approach would suffer from bad perf ormance due to serialization i.e.
loss of parallelism in the application and from low coverage due to consideration of only one s erialized observed trace.
to address these problems our g oals in dtamaretwofold a support parallelthread modular tain tanal ysis atruntime b generalize thread modular taintanaly sis results i.e.
to cover alternate os schedules in a post execution offline stage.
although thread modular analysis has been exploite d previously such as for procedure summarization and m odel checking its use in dynamic taint analysis has not b een investigatedso far.
we refer to the approach with serialization execution as dtamserial andimplementeditwithinour dtamframework.
itisbuilt over dytan a taint analysis generic framework for seque ntial programs.
in addition to dtam serial we also propose two ne w approaches named dtam parallel anddtam hybrid .
they comprise two main stages an online stage where each thread p erforms taint analysis locally in parallel with other thread s at runtime and an offline stage where the thread modular resul ts are aggregated tocapture taint propagations across threads.
toenable thread modular taint analysis in the first stage we treat a s hared read event by a thread as another type of input and generate a pseudo taint tag for that event.
furthermore whenever a thr ead executes a shared write event we log the shared object and th e propagatedtainttags ifany forfurtherpropagationduri ngthesecond stage.
in the second stage an offline merger collects the taint results for each thread and aggregates them for the multi th readed program.
it recursively replaces the pseudo taint tags on sh ared reads withthe taint tags onshared writes tothe same object from remote threads until convergence.
there are two advantages of using dtam parallel compared to dtam serial.
first it can take advantage of parallelism by performing thread modular taint analysis.
second itcan prov ide generalized results corresponding to many schedules.
note tha t dynamic taint analysis on a serialized execution dtam seria l inherently follows the observed schedule and it may require e xploring a large number of serialized schedules to get adequate co verage.
ononehand dtam parallelimplicitlycapturestheeff ectsof many possible schedules when merging the thread modular re sults offline.
on the other hand depending on the precision of the i nterthread propagation there is a tradeoff involved in using th is parallel approach.
inaddition to a one time additional cost of an offline merge stage dtam parallel approach may lead to over taint ing if itconservativelypropagatesthetainttagtoallremotethr eadswhen thereexistsasharedwrite readpairtothesameobject eve nthough such pairingmaynot be feasible due tosynchronization.
to remove the imprecision of this over approximation we pr oposedtam hybridwhichconsidersmust happens beforerel ationships due to synchronization operations.
in this approach we allow a taint tag to be propagated from a shared write in one thre ad to a shared read on the same object in another thread only i f there isno must happens before ordering betweenthe reada ndthe write.
by considering synchronization operations dtam h ybrid approach enables us to collect generalized results i.e.
n ot limited totheobservedschedule incomparisontodtam serial whi leaddressing some over tainting issues in dtam parallel.
whil e these ideas are similarto techniques for static dataflow analysis and predictive analysis for multi threaded programs we use them t o provide a flexible framework for dynamic taint propagation that can tradeoff precision and coverage.
the proposed technique dtam can give both false positives i.e.
spurious relevancy duetoofflinemerging andfalsen egatives i.e missing relevancy due to unobserved program paths .
h owever as mentioned earlier it can still be useful in many bes t effort applications such as debugging stress testing runtime mo nitoring to reduce logging overhead and improve coverage.
to summari ze the contributions of thispaper are as follows wepropose adynamic relevancyanalysis for multi threaded programstoidentifyasubsetofinputsourcesandsharedobjects thatcan affect shared object stateor control flowof t heprograms.
relevancy is classified in terms of their effect on branches and on shared accesses.
such an analysis can supplement other techniques to provide the following benefits reduce recording overhead improve testing coverage improve data race prediction and help classify benign malig n data races.
we present a dynamic taint analysis framework for multithreaded programs dtam .
it uses parallel thread modular taint analysis with an offline aggregation for propagating taints across threads.
it provides flexibility to tradeoff p recision and coverage ranging from results over only the observed serialized execution to generalized results over ot her thread schedules.
although we focus here on its use for performing relevancy analysis it is a general framework that can be usedfor other applications of taint analysis for mult ithreaded programs.
the rest of the paper is organized as follows.
we start with ba ckgroundandnotationinsection2.
section3presentsthemain ideas in relevancy analysis.
section describes our proposed dyn amic taint analysis framework which we use toperform relevancy analysis andsection5presentsitsimplementation.
wediscuss anempirical evaluation insection .
finally we compare our wor k with other relatedeffortsinsection7and conclude insection8.
.
background a multi threaded program consists of a set of concurrently e xecuting threads.
the threads communicate with shared objec ts some of which are used for synchronization such as locks and s ignals.
atrace ofaprogramisatotalorderedsequenceofobserved events corresponding to various thread operations such as s hared accesses and external api calls.
eachevent eof the sequence i.e.
e is carried out by some thread denoted as tid e at a thread program location loc e .
these events include the following write read t x write readby tona shared object x nd t a non deterministic external input api call by t including hardware interfaces system calls branch t a conditional branch taken by t wait notify t s wait notifyby ton a signal s fork t t thread start t tforks a thread t join t t thread end t twaits until t ends ashared instruction isaloc e where a write read occurs.
happens before .
given a trace of a program and events e e we say ehappens before e i.e.
e precedesequale ifeisobservedbeforee inthetrace.
wesay emusthappens before e i.e.
causally ordered denoted as e e ife precedesequale holds and one of the following holds e e belong tothe same thread e notify t s ande wait t s t ne ationslash t e fork t t ande thread start t t ne ationslash t e thread end t ande join t t t ne ationslash t e1 .
e e1 precedesequale or e2 .
e precedesequale2 e a must happens before relation can be maintained easily using vector clocks .
a vector clock of a thread denoted as vc t records the clocks of all threads.
whenever a non locking synchronization occurs vector clocks are updated.
each ev ent is time stamped with a vector clock.
implementation details o f vector clocks canbe found .
effect chains .
we now define source sink and conduit in a multi threaded program w.r.t.
effectchains.
source a source is a non deterministic external input api or a shared object associated with the event ndorread respectively.
we refer to the former source as inputand the latter source as sharedobject .
inthesequel weuse inputstodenoteinputsources.
sink a sink is a loc e where event eis either a read write on a shared object or a branch.
we refer to the former sink as shared access and the lattersinkas branch.
conduit a conduit determines propagation of the effect from a source toa sinkthrough aread after writedependency.
ifa neffect propagates throughawrite followedbyaread onthesamesh ared object we refer to the conduit i.e.
the pair of events as shared accesses.
if an effect propagates through a branch we refer to the conduit as branch.
leta b source conduit sink .
a b aaffects or propagates aneffect to b a zb adoes not affect orpropagate an effect to b. za b bdoes not get aneffect propagated through a. an effect propagation chain is shown as source conduit sink.
for the above chain we also say that the conduit sink is dependent on the source.
.
relevancy analysis wediscussrelevancyoftwosourcesofnon determinisminmu ltithreaded programs i.e.
inputs and shared objects with re spect to how they impact other shared accesses and branches in sec tions .
.
.
goinginthe other direction from sinks tos ources wealsodiscussthedependencyofsinks sharedaccessesand branches onvarious sources insection3.
.
.
relevantinputs sources inmulti threadedprograms inputscanaffectsharedobjec tstate control flow orboth.
theinputs correspond tohardware inte rfaces suchasnetwork disk userkeyboard andnon deterministi csystem apisuch as gettimeofday sys read rdtscinstructions etc.
we propose six possible relevancy types for inputs based on how they influence branches or shared accesses i irrel i bs b i sb s i sb s i sbs andi sbs.
these types are described in table .
the key to understanding the mnemonics for these types is as follows istands for inputs bstands for branches and sstands forsharedobjects oraccesses.
here thepositiveforms b s mean that there is influence while the negative forms b s mean that there is no influence.
for example i bs bdenotes that the input does not influence any branch either directly or through a sh ared access.
the type i irrelis shorthand to denote inputs that do not influence any branch or any shared access.
the remaining type s denote cases where an input affects a branch.
among these we distinguish cases where the branch is or is not affected th rough a sharedaccess mnemonically bisprecededby sor s respectively .
we also distinguish cases where the branch itself affects o r does not affect a shared access mnemonically b is followed by sor s respectively .
this leads to four types denoted mnemonica lly as i sb s i sb s i sbs andi sbs.
table relevancy types for inputs type description i irrel affectsneither any branchnor any sharedaccess.
i bs baffectssome sharedaccessbutnot any branch.
i sb saffectssome branchbut not anysharedaccess.
i sb saffectssomebranch through somesharedaccess but thebran ch doesnot affectany sharedaccess.
i sbs affects some branch not through any shared access and the branch affectssomesharedaccess.
i sbs affectssomebranchthroughsomesharedaccess andthebran ch affectssomeshared access.
these six input types are also shown pictorially in figure a wherethecirclesshowthedifferentdomains i inputs br branches sh shared accesses .
note that i are the sources and br and s h can be either conduits or sinks and various intersections d enote howinputsinfluencethem.
theinputsthatdonotaffectanysh ared access and do not affect any branch denoted by type i irrel are regarded as irrelevant andthe rest are regardedas relevant.thegoalofrelevancyanalysisistoidentifyrelevantinput swhich may affect shared object state and control flow of multi thr eaded programs.
informationabout relevant inputs canhave manyp otentialusesinmonitoringandanalyzingmulti threadedprogr ams.
for example deterministicreplaysystems needn otmonitor irrelevant inputs for which natural unlogged input d uring replaycanbeusedsincetheywouldnotaffecttheshared objec t state of the program nor the program path e.g.
taken branches .
s imilarly deterministic execution systems systemati c schedule testingtools andconcurrencybugreproductiontools also canbeaugmentedwithsystemsupportformonitoringonlyrel evant inputs.
relevant input analysis can also have a significant e ffect on testing as one need not explore the space of irrelevant in puts.
given limited testing time one can selectively alter only r elevant inputs toprovide improved test coverage.
g47 g3 g894 g400 g381 g437 g396 g272 g286 g895 g17 g90 g94 g44 g349 g890 g271 g400 g271 g349 g890 g400 g271 g400 g853 g3 g349 g890 g400 g271 g400 g349 g890 g400 g271 g400 g349 g890 g400 g271 g400 g349 g890 g349 g396 g396 g286 g367 g94 g3 g894 g400 g381 g437 g396 g272 g286 g895 g17 g90 g400 g890 g349 g271 g400 g400 g890 g349 g271 g400 g400 g890 g349 g271 g400 g853 g400 g890 g349 g271 g400 g400 g890 g349 g396 g396 g286 g367 g94 g44 g400 g890 g271 g400 g894 g258 g895 g894 g271 g895 figure relevancy typesfor a inputs i b shared objects s b ased on their effect on branches br and shared accesses sh .
the relevant input types of interest may vary for different a pplications.
wehighlight some of the potential uses one may be interested in the subset of inputs which affect branches only but not any shared object i.e.
those that do not influence the interleaving coverage ordering of shared accesses .
such inputs identified by the type i sb s are included inthe intersectionof i andbr.
similarly one may be interested in the subset of inputs that do not affect branches but only some shared accesses i.e.
that do not influence any program path but may be just the outputs .
such inputs identified by the type i bs b are includedintheintersectionofiandsh.fromthepointofview of deterministic replay such inputs mayalso be irrelevant .
onemaywanttoobtainasubsetofinputswhichaffectsome shared accesses that are control dependent on inputs i.e.
thosethatmayinfluencethelocalbranchesbutnotthebranch es oftheotherthreads.
suchinputs identifiedbythetype i sbs are included inthe intersectionof i br andsh.
based on above potential uses we also identify some useful groups of relevant types as shown in table .
we discuss the s ignificance of the grouping shortly but first we provide illust rations of the types of inputs as shown in table .
for each type shown in column we show the effect propagation chain in column .
in column we use two threads t1 and t2 communicating with shared objects sands and local objects x y z and highlight the corresponding input types withcode snippets.
inthe res t of the columns we identifythe membership of eachtype inthe group s. the groups of input types weconsider are as follows i sb inputsthataffectsomebranchesnotthroughanyshared access i bs inputs that affect some shared accesses through some branches i b inputs that affect some branches shared object may or maynot be a conduit i s inputs that affect some shared accesses branch may or maybe a conduit i b s inputsthataffecteithersomesharedaccessesorsome branches note that both i bandi sincludei bs andi b ssubsumes all relevant input types.
our experimental evaluation descri bed later uses these groups.
table input relevancy groups group i irrel i bs bi sb si sb si sbsi sbs i sb x x i bs x x i b x x x x i s x x x x i b s x x x x x table3 types and groups of inputs relevancy g47 g374 g393 g437 g410 g400 g3 g258 g296 g296 g286 g272 g410 g349 g374 g336 g3 g400 g346 g258 g396 g286 g282 g3 g258 g272 g272 g286 g400 g400 g286 g400 g3 g894 g94 g44 g895 g853 g3 g258 g374 g282 g876 g381 g396 g3 g271 g396 g258 g374 g272 g346 g894 g17 g90 g895 g100 g346 g396 g286 g258 g282 g3 g28 g454 g258 g373 g393 g367 g286 g400 g894 g454 g853 g455 g853 g460 g855 g367 g381 g272 g258 g367 g854 g3 g94 g853 g94 g859 g855 g3 g400 g346 g258 g396 g286 g282 g895 g47 g374 g393 g437 g410 g3 g90 g286 g367 g286 g448 g258 g374 g272 g455 g894 g39 g396 g381 g437 g393 g400 g3 g381 g296 g3 g410 g455 g393 g286 g400 g895 g3 g100 g455 g393 g286 g400 g28 g296 g296 g286 g272 g410 g18 g346 g258 g349 g374 g400 g100 g1005 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g100 g1006 g47 g890 g400 g271 g47 g890 g271 g400 g47 g890 g271 g47 g890 g400 g47 g890 g271 g890 g400 g349 g890 g349 g396 g396 g286 g367 g47 g1111 g3 g94 g44 g853 g3 g17 g90 g349 g890 g271 g400 g271 g47 g1111 g3 g17 g90 g1111 g3 g94 g44 g3 g1111 g3 g17 g90 g454 g855 g1089 g374 g282 g894 g895 g854 g94 g855 g1089 g454 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g121 g121 g349 g890 g400 g271 g400 g47 g1111 g3 g94 g44 g1111 g3 g17 g90 g3 g1111 g3 g94 g44 g454 g855 g1089 g374 g282 g894 g895 g854 g349 g296 g894 g454 g895 g121 g121 g121 g349 g890 g400 g271 g400 g47 g1111 g3 g94 g44 g1111 g3 g17 g90 g1111 g3 g94 g44 g454 g855 g1089 g374 g282 g894 g895 g854 g94 g855 g1089 g3 g454 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g349 g296 g894 g455 g895 g898 g460 g855 g1089 g1005 g899 g121 g121 g121 g349 g890 g400 g271 g400 g47 g1111 g94 g44 g3 g1111 g3 g17 g90 g1111 g3 g94 g44 g454 g855 g1089 g374 g282 g894 g895 g854 g349 g296 g894 g454 g895 g898 g94 g855 g1089 g454 g854 g3 g899 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g121 g121 g121 g121 g121 g349 g890 g400 g271 g400 g47 g1111 g3 g94 g44 g1111 g3 g17 g90 g3 g1111 g3 g94 g44 g454 g855 g1089 g374 g282 g894 g895 g854 g94 g855 g1089 g3 g454 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g94 g859 g855 g1089 g1004 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g349 g296 g894 g455 g895 g898 g460 g855 g1089 g94 g859 g899 g121 g121 g121 g121 .
relevantsharedobjects sources likeinputs sharedobjects caninfluenceothershared objectstate or control flow or both.
table4 relevancy types for sharedobjects types description s irrel affectsneither a branchnor another sharedaccess.
s bs affectssomeshared accessbutnot any branch.
s ib saffectssomebranchwithout propagatingtheeffectof anyin put but thebranch doesnot affectany sharedaccess.
s ib saffects some branch with propagating the effect of some inpu t but thebranch doesnot affectany sharedaccess.
s ibs affectssomebranchwithout propagatingtheeffectof anyin put and thebranch affectssomesharedaccess.
s ibs affects some branch with propagating the effect of some inpu t and thebranch affectssomesharedaccess.
table sharedobject relevancy groups group s irrel s bss ib ss ib ss ibss ibs s ib x x s bs x x s b x x x x s s x x x s b s x x x x x we propose six possible relevancy types for shared objects as sources basedonhow theyinfluencebranches orsharedacce sses s irrel s bs s ib s s ib s s ibs ands ibs.
these aredescribed in table and the mnemonics used here are similar to those fo r inputs as sources described earlier.
also these types ar e shown pictorially in figure b .
the shared objects that do not af fecttable types and groups for sharedobject relevancy g94 g346 g258 g396 g286 g282 g3 g381 g271 g361 g286 g272 g410 g400 g3 g258 g296 g296 g286 g272 g410 g349 g374 g336 g3 g400 g346 g258 g396 g286 g282 g3 g258 g272 g272 g286 g400 g400 g286 g400 g3 g894 g94 g44 g895 g853 g3 g271 g396 g258 g374 g272 g346 g286 g400 g894 g17 g90 g895 g100 g346 g396 g286 g258 g282 g3 g28 g454 g258 g373 g393 g367 g286 g400 g894 g454 g853 g455 g853 g460 g855 g367 g381 g272 g258 g367 g854 g3 g94 g853 g94 g859 g855 g3 g400 g346 g258 g396 g286 g282 g895 g94 g346 g258 g396 g286 g282 g75 g271 g361 g286 g272 g410 g90 g286 g367 g286 g448 g258 g374 g272 g455 g3 g894 g39 g396 g381 g437 g393 g400 g381 g296 g3 g410 g455 g393 g286 g400 g895 g100 g455 g393 g286 g400 g28 g296 g296 g286 g272 g410 g18 g346 g258 g349 g374 g400 g100 g1005 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g100 g1006 g94 g890 g349 g271 g94 g890 g271 g400 g94 g890 g271 g94 g890 g400 g94 g890 g271 g890 g400 g400 g890 g349 g396 g396 g286 g367 g94 g44 g1111 g3 g94 g44 g853 g3 g17 g90 g400 g890 g271 g400 g94 g44 g1111 g3 g17 g90 g1111 g3 g94 g44 g454 g855 g1089 g1006 g854 g94 g855 g1089 g454 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g121 g121 g400 g890 g349 g271 g400 g47 g1111 g3 g94 g44 g1111 g3 g17 g90 g3 g1111 g3 g94 g44 g454 g855 g1089 g94 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g94 g855 g1089 g1006 g349 g296 g894 g454 g895 g121 g121 g121 g400 g890 g349 g271 g400 g47 g1111 g3 g94 g44 g1111 g3 g17 g90 g1111 g3 g94 g44 g454 g855 g1089 g374 g282 g894 g895 g854 g94 g855 g1089 g3 g454 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g349 g296 g894 g455 g895 g898 g460 g855 g1089 g1005 g899 g121 g121 g400 g890 g349 g271 g400 g47 g1111 g94 g44 g3 g1111 g3 g17 g90 g1111 g3 g94 g44 g454 g855 g1089 g94 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g94 g855 g1089 g1006 g854 g349 g296 g894 g454 g895 g898 g94 g855 g1089 g454 g854 g3 g899 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g121 g121 g121 g121 g121 g400 g890 g349 g271 g400 g47 g1111 g3 g94 g44 g1111 g3 g17 g90 g1111 g3 g94 g44 g454 g855 g1089 g374 g282 g894 g895 g854 g94 g855 g1089 g3 g454 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g94 g859 g855 g1089 g1004 g854 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g3 g455 g855 g1089 g94 g854 g349 g296 g894 g455 g895 g898 g460 g855 g1089 g94 g859 g899 g121 g121 g121 g121 any shared accesses and do not affect any branches indicate d by types irrel are regarded as irrelevant .
the remaining types are regarded as relevant.
some potential applications of relevancy analysis for shar ed objects are as follows one may be interested to know if a shared object can influence a branch but not another shared access.
such shared objects identifiable by types s ib sands ib s are included inthe intersectionof s source andbr sink .
one may like to know if a shared object can not influence any branch.
such shared objects identifiable by type role s bs are included in the intersection of s source and sh sink .
for example if a race is on a shared object that does nothaveanyeffectoncontrolflow onemayclassifytherace as benign otherwise potentiallymalign.
itcanalsoempoweradata racedetectortorelaxcertainrea dafter write ordering constraints while predicting data ra ces.
data race detectors such as use happens before analysis often with a relaxed ordering of lock unlock as long as read after write raw constraints are not violated.
such constraints are enforced to avoid potentially false infea sible data races.
however if a shared object does not affect any branch it may ignore those constraints during race predictiontofindmore potential races.
asampling basedracedetectionsuchas canalsobenefit byfocusingonasmallersetofsharedobjects.
inour experimental data we found that on average about shared objects affect some branch .
again basedonpotentialuses wehavegroupedthesharedty pes intothe following fivegroups alsoshown intable .
s ib sharedobjectsthataffectsomebrancheswithoutpropagatingthe effect of any input s bs shared objects that affect some other shared accesses through some branches s b shared objects that affect some branches input can be a source s s shared objects that affect some other shared accesses branch canbe aconduit input can be a source s b s shared objects that affect either some other shared accesses or some branches like types for inputs we also illustrate the various types f or shared objects using small examples as shown intable6.
.
dependenciesofsinks so far we have addressed relevance of sources inputs share d objects by following chains of influence from these sources to sinks branches shared accesses .
going in the other direc tion g47 g17 g90 g94 g44 g3 g894 g400 g349 g374 g364 g895 g94 g44 g890 g349 g94 g44 g890 g349 g890 g271 g94 g44 g890 g271 g94 g44 g890 g374 g381 g282 g286 g393 g47 g17 g90 g3 g894 g400 g349 g374 g364 g895 g17 g90 g890 g349 g17 g90 g890 g349 g890 g400 g17 g90 g890 g400 g17 g90 g890 g374 g381 g282 g286 g393 g94 g894 g258 g895 g894 g271 g895 figure dependencies of sinks a shared accesses sh b branch es br basedontheir dependency oninputs i branches b shared objects s .
we can also identify dependencies of sinks i.e.
how shared a ccesses andbranches depend oninputs branches shared obje cts.
we identify four types of shared access dependencies as sho wn infigure a .
sh i b sharedaccessesthataredependentonsomebranches andon some inputs sh i shared accesses depending only on some inputs not dependent onany branch sh b shared accesses depending only on some branches not dependent onany input sh nodep shared accesses that depend neither on any input nor on anybranch similarly we identify four types of branches dependencies as shown infigure b .
br i s branches that depend on some inputs and some shared objects br i branches depending only onsome inputs br s branches depending onlyon some shared objects br nodep branches that depend neither on any input nor onany sharedobject .
dynamictaintanalysisformulti threaded programs in this section we describe how dynamic taint analysis can b e used for relevancy analysis and describe some challenges in multithreaded programs in section .
.
then we provide our propo sed dynamictaintanalysisapproachesformulti threadedprog rams namely dtam serial dtam parallel anddtam hybrid.
.
taintanalysisforrelevancyanalysis therearethreemainstepsintraditionalsequentialdynami ctaint analysis tagging i.e.
identifying data from external inputs and marking them as tainted propagating the taint tag along the data and control flow through the program and checking whethertainteddataisusedunsafely.
weusethisdynamicta inttag propagationandcheckscheme toenable relevantanalysis.
w ealso generate a unique taint tag on data from each input and from ea ch shared object reads and propagate it along data flow and con trolflow.
however inourrelevancyanalysis wedonotusetainta nalysistofocusonsecuritypolicyordetectsecurityattacks i nstead we perform runtime checks on shared accesses and or branches.
for example when a taint tag from input data propagates to a shar ed access through a branch or directly we say that the input af fects shared objectstate.
weclassifyitaccordingtoourreleva ncytypes.
extending a sequential dynamic taint analysis to multi thr eaded programs isnon trivial.
oneneeds toconsider concurrent a ccesses to a shared object with additional guarantee that a shared in structionandinstrumentedcodefortaintpropagationareexecut edatom g100 g346 g396 g286 g258 g282 g3 g1004 g100 g346 g396 g286 g258 g282 g3 g1005 g24 g100 g4 g68 g882 g400 g286 g396 g349 g258 g367 g18 g258 g400 g286 g3 g1005 g855 g3 g349 g296 g3 g894 g400 g410 g373 g410 g1006 g1095 g400 g410 g373 g410 g1011 g895 g18 g258 g400 g286 g3 g1006 g855 g3 g349 g296 g3 g894 g400 g410 g373 g410 g1011 g1095 g3 g400 g410 g373 g410 g1006 g895 g1005 g855 g454 g855 g1089 g3 g47 g1004 g47 g1004 g1111 g454 g1111 g94 g1004 g1111 g455 g1111 g17 g90 g1004 g1111 g94 g1005 g47 g1004 g1111 g454 g1111 g94 g1004 g854 g94 g1004 g1111 g17 g90 g1004 g1111 g94 g1005 g894 g437 g374 g282 g286 g396 g3 g410 g258 g349 g374 g410 g895 g1006 g855 g94 g1004 g3 g855 g1089 g454 g1011 g855 g455 g855 g1089 g3 g94 g1004 g47 g1005 g1111 g460 g1111 g94 g1004 g1111 g17 g90 g1005 g854 g3 g94 g1005 g1111 g94 g1004 g1111 g17 g90 g1005 g47 g1005 g1111 g460 g1111 g94 g1004 g1111 g17 g90 g1005 g854 g3 g94 g1005 g1111 g94 g1004 g1111 g17 g90 g1005 g1012 g855 g349 g296 g3 g894 g455 g895 g3 g898 g3 g876 g876 g17 g90 g1004 g1013 g855 g94 g1005 g3 g855 g1089 g3 g857 g856 g24 g100 g4 g68 g882 g393 g258 g396 g258 g367 g367 g286 g367 g899 g100 g346 g396 g286 g258 g282 g1004 g855 g100 g346 g396 g286 g258 g282 g3 g1005 g855 g1005 g1004 g855 g69 g381 g410 g349 g296 g455 g894 g895 g47 g1004 g1111 g454 g1111 g94 g1004 g94 g1004 g1111 g455 g1111 g17 g90 g1004 g1111 g94 g1005 g373 g437 g400 g410 g3 g346 g258 g393 g393 g286 g374 g400 g882 g271 g286 g296 g381 g396 g286 g47 g1005 g1111 g460 g1111 g94 g1004 g1111 g17 g90 g1005 g854 g3 g94 g1005 g1111 g94 g1004 g1111 g17 g90 g1005 g894 g381 g448 g286 g396 g3 g410 g258 g349 g374 g410 g349 g374 g336 g895 g1007 g855 g3 g116 g258 g349 g410 g894 g895 g1008 g855 g460 g855 g1089 g3 g47 g1005 g24 g100 g4 g68 g882 g346 g455 g271 g396 g349 g282 g1009 g855 g94 g1004 g3 g855 g1089 g3 g460 g3 g1085 g3 g94 g1005 g100 g346 g396 g286 g258 g282 g1004 g855 g100 g346 g396 g286 g258 g282 g1005 g855 g1010 g855 g47 g296 g3 g894 g94 g1004 g895 g898 g876 g876 g3 g17 g90 g1005 g47 g1004 g1111 g454 g1111 g94 g1004 g94 g1004 g1111 g455 g1111 g17 g90 g1004 g1111 g94 g1005 g857 g3 g876 g876 g3 g374 g381 g400 g346 g258 g396 g286 g282 g3 g258 g272 g272 g286 g400 g400 g47 g1005 g1111 g460 g1111 g94 g1004 g1111 g17 g90 g1005 g854 g3 g94 g1005 g1111 g94 g1004 g1111 g17 g90 g1005 g899 figure example of dtam analysis.
on the left code example i0 and i1 a re program inputs x y andzare local objects s0ands1are shared objects where statements and haveadata race i.e.
stat ement can happen before precedesequal statement or vice versa and there exists amust happe ns before order between statements and enforced by notify and wa it .
on the right we show the results of dtam serial dtam parallel and dtam hybrid approaches.
dtam serial depends on the serialized schedul e so it may lead to under tainting as in case .
for dtam para llel and dtam hybrid the dotted arrowsrepresenttheresultofofflineanalysis.
sincedtam paralleldoesnotconsider amust happens before ordercon structed bysynchronization operations it may result in over tainting.
ically.
in addition to thread local data and control flow on e also need to consider inter thread flow for taint propagation where in a taint tag can propagate from one thread to another through r eadafter write raw shared object dependency.
.
dtam serial one straightforward solution for multi threaded programs is to serializethemulti threadedexecution andthenpropagat etainttags along the serialized schedule while ensuring atomicity bet ween a sharedinstructionandinstrumentedcode fortaintpropaga tion.
we call this approach dtam serial.
in dtam serial approach there exists a single taint map for shared objects which holds propagated taint tags for each sh ared object.
this map is shared by all threads so that one thread ca n see the effect of taint propagation by the other.
in addition each thread has its owntaint mapfor registers whichcontains thr ead local context information.
though dtam serial is easy to reas on about and implement it has two drawbacks.
first it cannot e xploit application level parallelism and therefore it is m uch slower than normal executions even without considering instrumen tation costs.
second dtam serial is carried out on the observed se rialized schedule so it may lead to undertainting w.r.t.
other possible interleavings onthe same inputs.
weillustratetheabove issueinfigure3.
ontheleftcode exa mple i0 and i1 are program inputs x y andzare local objects s0 ands1aresharedobjects.
notethatstatements2and7havead atarace.
on the right we show the result of dtam serial approac h based on two different schedules.
if statement happens be fore statement case then taint tag for i0 is propagated to y br0 ands1in thread via read after write raw shared accesses of s0.
however if statement happens before statement case thenthetainttagfori0wouldnotbepropagatedtothread1.
t hus serializinganexecution potentially leads toundertainti ng.
.
dtam parallel to overcome the two limitations of dtam serial i.e.
seria lizationandundertainting weproposeaparalleldynamictaint analysis technique namely dtam parallel.
inaddition tothread lo cal data and control flows a taint tag can be propagated from one threa d to another through write and read accesses to the same shared ob jectin multi threaded programs raw dependency .
therefore i t is necessary to deal with this additional inter thread flow in d ynamic taint analysis for multi threaded programs.
for each threa d the shared writes are the points where a local taint tag can be pot entially propagated to the other threads and the shared reads are the ones where a remote taint tagcanbe propagated intoa thread.
like dtam serial dtam parallel marks each input data with a uniqueinput taint tag.
however in dtam parallel each thread maintainsitsowntaintmapforsharedobjectsandperformst hreadmodular taint propagation.
when a thread performs a shared r ead itcreatesaunique pseudotainttag andpropagatesitasiftheshared read was treated as an external input.during offline analysi s this pseudo taint tag will be replaced by taint tags which can be p ropagatedvia sharedwrites performed onthesame object byre mote threads.
to obtain this additional information when a thre ad performs a shared write it logs the shared object identifier su ch as memory address and corresponding taint tags.
on completio n of thread modular taint propagation an offline analysis coll ects the taint results of each thread and aggregates them by replacin g the pseudo taint tags on shared reads withthe propagated taint t ags on shared writes performed onthe same object byremote threa ds.
there is a performance precision tradeoff in using the dtam parallel approach.
by performing taint analysis for each th read it cantake advantage ofparallelism buttheofflinemergingst epmay lead to over tainting because it does not consider must hap pensbeforerelationduetosynchronizationoperations.
itcons ervatively propagates the taint tag from one thread to another whenever there exists asharedwrite readpairtothesame shared object.
ho wever ifthesharedwritehappensafterthesharedread thetaintt agshould not propagate from writetoread.
althoughnotprecise thisconservativepropagationprovi desgeneralization over other interleavings on the same inputs.
th e proposed dtam parallel approach implicitly captures the effe cts of many possible interleavings when merging the thread modul ar resultsoffline however thiscomesatthecostofover tainti ng.
inthe following section we discuss our final technique namely dt amhybrid whichtakesintoaccountthemust happens before r elationshipenforced by synchronization operations.
figure shows this tradeoff.
in dtam parallel thread log staint tagi0 and i1 on shared writes on statements 2and res pectively and thread treats the shared read as a pseudo input on statement .
this allows two threads to perform thread modu lar taint analysis in parallel.
then the offline analysis merge s the results by replacing pseudo taint tags with the propagated inp ut tags on shared accesses tothe same object as represented bythe d otted arrowsintheexample.
however dtam paralleldoesnotcons ider amust happens before orderbetweenstatements10and3enf orced by notify and wait thus it could result in over taintin g i.e.
it may conclude that i1canalsoaffect y br0 and s1.
.
dtam hybrid dtam hybrid tracks synchronization operations and takes i nto account the must happens before relationship to address t he above over taintingproblem.
suchtypes ofsynchronization prev ent local taint tags from being propagated from a shared write to a shar ed read if the shared read must happen before the shared write.
we also record vector clocks for each read and write event in ad dition to the shared events and tags.
such information is used f or determining the must happens before relationship during aggregationstep as discussed inthe next section .
figure3showsthedifferencebetweendtam parallelanddta mhybrid.
dtam hybrid is aware of the must happens before or der between notify in thread and wait in thread .
therefor e during the offline merge stage it does not allow taint tag of i in thread 0tobe propagated tothread1.
in table we present the results of taint analysis in identi fying various relevant inputs and shared objects for the examp le in figure .
similarly in table we present the results of tai nt analysisinidentifyingvariousdependenciesofsharedacc essesand branches.
note all branches and shared access have depende ncies on inputs and or sharedobjects.
as one would expect dtam hybrid gives the most precise1result compared todtam serial anddtam parallel.
table input and sharedobject relevancy input groups sharedobjectsgroups dtami sbi bsi bi si b ss ibs bss bs ss b s serial i0i0 i1i0 i1i0 i1 s0s0 s1s0 s1s0 s1 serial i1i0 i1i0 i1s0 s0 s1s0 s1s0 s1 parallel i0 i1i0 i1i0 i1i0 i1 s0 s1s0 s1s0 s1s0 s1 hybrid i0i0 i1i0 i1i0 i1 s0s0 s1s0 s1s0 s1 table sharedaccess andbranch dependency shared access branch dtamsh i bsh ish bbr i sbr ibr s serial s1 s0 br0 br1 serial s0s1 br1 br0 parallel s1 s0 br0 br1 hybrid s1 s0 br0 br1 .
aggregationofthread modularresults inthissection wedescribe howweperformtheofflinemergin g. we firstintroduce some notation i a set of allinput tainttags i.e.
inputs s a set of allpseudo taint tags i.e.
sharedobject reads t aninput or a pseudo taint tag i.e.
t i s t.r readaccess event corresponding topseudo tainttag t t.obj shared object corresponding topseudo taint tag t t.lw last observed thread local write event to t.obj t.lw precedesequal t.r 1dtam hybridmaystillhaveovertaintingproblemifthecaus al ordering permits infeasible permutation of trace events.
although one may av oid the problem by using maximal causal models one mayincur lowcoverage.
t.gw last observed global write event to t.obj t.gw precedesequalt.r t.a a set of allshared writeevents byother threads to t.obj w.t a set of taint tags propagated during thread modular taintanalysis towriteevent w the goal of aggregation is to obtain a transitive dependency on inputs taint tags or pseudo taint tags for a given set of tai nt tags propagated at sinks ina thread modular taint analysis.
for a given relevancy group r e.g.
i b s b letr.ddenote a set of pseudo taint and input taint tags that were relevant fo rras obtained from the thread modular taint analysis.
wethenobtainasetofallinputtainttagsthatarerelevantf orr denoted as r.i as follows r.i uniondisplay t r.dt.i wheret.iis the set of all input taint tags that can possibly affect t computed as described below .
similarly weobtainasetofallpseudotainttagsthatarere levant forr denoted as r.s asfollows r.s uniondisplay t r.dt.s wheret.sis the set of all pseudo taint tags that can possibly affect t. wenowdescribe how weobtain t.iandt.sforatagt.
lett.w denoteasetofallwriteaccessesthatcanpossiblyaffectth ereadof t.obj.
in the following we define t.win such a way that we can uniformly handle dtam serial parallel hybrid.
t.w t.gw serial t.lw t.a parallel t.lw w w t.a t.r ne ationslash w hybrid wethen compute t.iandt.srecursively using t.was follows t.i braceleftbigg t ift i uniontext w t.w uniontext t w.tt .i ift ne ationslash i t.s braceleftbigg ift i uniontext w t.w uniontext t w.tt .s ift ne ationslash i .
implementation in this section we describe our implementation for relevan cy analysisbasedondynamictaintanalysis.
wefirstdiscussap rofilebased approach to identify shared instructions in section .
and thendiscusstheimplementationofdtamapproachesinsecti on5.
.
.
profilingsharedinstructions for a given program dtam needs to identify a set of shared instructions i.e.
program locations of read write event s for two reasons first the dtam approaches proposed in section re ly on shared instructions for inter thread data flow based raw dependency taint propagation.
for example dtam serial ens ures atomicity between shared accesses and instrumented code.
f or dtam parallel and dtam hybrid the pseudo taint tags are ge nerated at shared read accesses and the taint tags are logged during shared write accesses.
second the relevant analysis perfo rm taint checks on the shared accesses as we are interested in the inpu ts and shared objects that can affect the outcome of the shared a ccesses.
the process of identifying shared instructions can be done through profiling or static analysis.
in our implementation we use g47 g374 g400 g410 g396 g437 g373 g286 g374 g410 g286 g282 g17 g349 g374 g258 g396 g455 g3 g28 g454 g286 g272 g437 g410 g349 g381 g374 g75 g296 g3 g373 g437 g367 g410 g349 g882 g410 g346 g396 g286 g258 g282 g286 g282 g87 g396 g381 g336 g396 g258 g373 g94 g286 g396 g349 g258 g367 g349 g460 g286 g282 g3 g100 g258 g349 g374 g410 g3 g258 g374 g258 g367 g455 g400 g349 g400 g100 g346 g396 g286 g258 g282 g882 g373 g381 g282 g437 g367 g258 g396 g100 g258 g349 g374 g410 g3 g258 g374 g258 g367 g455 g400 g349 g400 g100 g349 g373 g286 g882 g400 g410 g258 g373 g393 g286 g282 g3 g400 g455 g374 g272 g286 g448 g286 g374 g410 g400 g3 g396 g286 g272 g381 g396 g282 g349 g374 g336 g90 g286 g367 g286 g448 g258 g374 g410 g3 g349 g374 g393 g437 g410 g400 g853 g3 g400 g346 g258 g396 g286 g282 g3 g381 g271 g361 g286 g272 g410 g400 g24 g286 g393 g286 g374 g282 g286 g374 g410 g3 g271 g396 g258 g374 g272 g346 g286 g400 g853 g3 g400 g346 g258 g396 g286 g282 g3 g258 g272 g272 g286 g400 g400 g286 g400 g100 g346 g396 g286 g258 g282 g882 g373 g381 g282 g437 g367 g258 g396 g410 g258 g349 g374 g410 g286 g282 g3 g282 g258 g410 g258 g94 g455 g374 g272 g882 g437 g374 g258 g449 g258 g396 g286 g68 g286 g396 g336 g286 g94 g455 g374 g272 g882 g258 g449 g258 g396 g286 g68 g286 g396 g336 g286 g100 g346 g396 g286 g258 g282 g3 g349 g374 g410 g286 g396 g367 g286 g258 g448 g286 g282 g410 g258 g349 g374 g410 g286 g282 g3 g282 g258 g410 g258 g75 g374 g367 g349 g374 g286 g3 g894 g396 g437 g374 g410 g349 g373 g286 g895 g75 g296 g296 g367 g349 g374 g286 g3 g894 g393 g381 g400 g410 g882 g286 g454 g286 g272 g437 g410 g349 g381 g374 g895 g94 g286 g396 g349 g258 g367 g44 g455 g271 g396 g349 g282 g87 g258 g396 g258 g367 g367 g286 g367 g94 g286 g396 g349 g258 g367 g3 g68 g286 g396 g336 g286 figure dtamoverview a profile based approach where we execute the programs mult iple times with representative test data and collect the set o f shared instructions along withitstype of operation writeor rea d .
we used pin a dynamic binary translation tool to instru ment and profile application x86 executables.
we maintain me tadata for each byte of location address which represents the access history of each thread.
an instruction is marked sharedif the instructionaccessesasharedobjectwhichhasbeenaccessedb yother threads.
insteadofusinginstructionaddress wenameeach instructionthe tuple of loaded image name and offset sothat wecan re fer to each instructionuniformly for different profiled runs e .g.
a dynamically linkedlibrarymay be loaded intodifferent addre sses .
.
dtam weimplementedtheproposeddtamapproaches dtam serial dtam parallel anddtam hybrid basedondytan whichpr ovides a generic framework for dynamic taint analysis.
dytan supports dynamic taint analysis for an x86 executable by instru menting it on the fly to produce an instrumented executable usi ng the pin tool.
dytan maintains taint tags for each byte of loc ation addressandsupportsallocatingvirtuallyanynumberoftai ntmarkings whichallowsustospecifydifferenttaintmarkingfor different input sources.
dytan also supports both explicit data flow based and implicit control flow based information flow.
for cont rolflow basedtaint propagation dytanperforms staticanalysi s on the binary to find immediate post dominator of a conditional bra nch.
allthestatementsthatbelongtothepathsstartingattheco nditional branch andending withitsimmediatepostdominator arecons ervatively marked as tainted if the conditional branch depends o n the tainted data.
in addition to leveraging the default functio nalities in dytan we extended the framework tosupport dtamas follows.
first dytan was originally developed for supporting seque ntial programs.
for sequential programs there is no inter threa d taint propagation.
however concurrent accesses to shared locat ion locations and corresponding metadata updates should be caref ully handled in multi threaded programs.
in dtam serial mode w e ensure atomicity between shared accesses and taint propaga tion using locks as all threads share a single taint map for share d objects.
in dtam parallel and dtam hybrid each thread maint ains its own taint map for shared objects and performs thread mod ular taintpropagation.
notethatinter threadtaintpropagati onsarehandledbytheofflinemergestage.
onthethread modulardata w ecan also do a serialized merging as shown in eq to obtain dtamserial data.
figure gives an overview of the implementatio ns of the various dtamapproaches.
second as our goal is to identify relevant inputs dtam tain ts all the program inputs.
this is not true for traditional dyna mictaint analysis tools including dytan as most of them refer t o some not all inputs that stem from external sources such as netw ork disk user keyboard etc.
to be tainted.
traditional dta to ols were primarily used to track untrusted user input data.
for example dtam considers the return value of system calls such a s gettimeofday rdtsc to be tainted because its value can have an effect on shared state or control flow of the program.
in con trast dytanclears the taint tagfor the targetregisters.
third dtamsupportsprecisecontrol flowbasedtaintpropa gationattheflag bit granularityofstatusregister e.g.
ef lags .in dytan like other registers taint tags are maintained for t he whole eflags status register thus dytan cannot differentiate th e taint tag for each flag bit such as cf carry flag pf parity flag an d zf zeroflag .
however most x86 instructions do not affect a ll the flagsinthestatusregister soflag sensitivetaintpropaga tionforthe status register canleadtobetter precision.
.
experimentalresults we now report evaluation of dtam approaches for relevancy analysis.
we begin with describing our evaluation methodol ogy.
then we compare the result of relevancy analysis for differ ent dtam approaches.
last we show the distribution of shared ac cessesandbranchesintermsoftheirdependencyoninputs b ranches and sharedobjects.
experimental setup .
we ran all experiments on a .8ghz 2core xeon processor with 4gb of ram running linux .
.
kernel.
we used two sets of benchmarks.
the first set consists of six desktop applications from open source repositories namely aget pfscan pnscan pbzip2 fastspy and axel.
th e test setup for each application is as follows agetdownloads a 47kb file inparallel pfscansearches inparallel for the string debug in a directory with 30kb of sources files pnscanscans tcp port in parallel to find running web servers pbzip2compresses a .8kb log file in parallel fastspyscans port to for a given ip address and axeldownloads a 47kb file.
the second set consists of threerepresentatives ofscientificapplicationwithdiffe rent characteristicsfromparsec .1suite blackscholes canneal and streamcluster .
weused simsmall input sets forthe evaluations.
table characteristicsof multi threaded applications.
apps loc lang neidyniscshsonoff aget .1k c 484k3186535k8.5k918 pfscan 1k c 347k1974937k8691730 pnscan .5k c 26k776662k931320.
pbzip2 5k c 35k252557121k280.
blackscholes c 32k192396836950.
canneal .7k c 37k204434k71750.
streamcluster .2k c 520k2k4410k804204 fastspy .2k c 1273k7405428k7k971 axel 4k c 764k15686532k11.5k234 in table we report the run time characteristics for the tes ts conducted for the applications listed in column .
the numbe r of threads n column was between to and the number of observed events was between 2k to 84k e column .
we use idynto denote the number of ndevents column ranging from to 2k.
we count each instance of system calls return value datacopiedintouser levelprocess andnondetermi nistic instructions e.g.
rdtsc as input source.
the static count o f inputs column i sc is the count of loc e whereeisndevent ranging from to .
it is obtained by combining the effect of multip le dynamic instances i.e.
ndevents .
we use sh todenote the number of read write events column ranging from to 37k.
2blackscholeshascoarse graineddata parallelparalleli zation withlowsharing canneal has fine grained unstructured parallelism with high fr equent sharing pattern and streamcluster hasmedium grained andmedium level ofshari ng characteristics.the number of shared objects column s refers to the disti nct objects where each object was accessed by at least two threa ds.
we ran each application times first to profile a set of shared instructions.
the online thread modular taint analysis c olumn on took between to minutes about minutes on average perapplication.
theofflineaggregationofthethread modu lartaint results column off took between a few seconds to minutes 15minutesonaverageperapplication.
thesetimes sh ownin min.
can be improved further witha better implementation.
resultsofrelevancyanalysis .
forcomparingdifferentdtam approaches on the same observed trace we use the same thread modular data for aggregation for serial parallel hybrid.
the left half of figure shows the results of relevant input analysis based on dtam hybrid.
results for dtam serial and dtam parallel show similartrends andarenotshown.
eachbarrepresents t heratio of relevant inputs to the total number of inputs i sc for a given relevant input type.
for aget i sbis i bsis i bis i sis and i b sis resp.
the average of eachbar isshown rightmos t. for dtam hybrid and similarly for parallel and serial on average about15 ofinputsarecategorizedintorelevantgro upi sb that affects branches not through any shared access about of inputs are categorized into group i bs andi b .
the percentage increases to on average for i s andi b s on our benchmarks.
thisimpliesthatabout15 inputs i b s i s thataffect shared accesses do not have control over the program paths a nd inputs are irrelevant.
we found that many rdtscinstructions e.g.
inpfscan are justused forlogging time s tampof events e.g.
thread creation and never affect branching many return values from system calls e.g.
sys close sys fstat64 sys write sys mprotect etc.
are not used whereas some returnvalue matters e.g.
sys open .
forcomparing different dtamapproaches we show results fo r groupi bsas shown in the right half of figure .
for three applications i.e.
aget fastspy andaxel dtam parallela nddtamhybriddemonstratethegeneralizationeffect resultingi nlargerrelevancyratioscomparedtoserial.
dtam hybridaddressesth eovertaintingissueindtam parallel andundertaintingissuei ndtamserial as observed for agetin particular.
we observe that the ratio of shared objects s to that of inputs i sc for these three applications is about while that of the rest is about .
such a la rge ratioindicates more pronounced generalization.
the lefthalf of figure 6shows the results of relevant shared object analysis based on dtam hybrid.
results for dtam seri al and dtam parallel are similar and are not shown.
each bar r epresents the ratio of relevant shared objects to the total num ber of shared objects for a given relevant shared type.
the average of each bar is shown rightmost.
we observe that relevancy ratio s ib fortheseapplicationsis0 i.e.
allsharedobjectsthataffectsome branch also propagate the effect of some input to the branch.
further the relevancy ratioforgroups s bsands bisabout each on average indicating that shared objects have very small i mpact on the control over the program paths.
the ratio increases to onaveragefor s sands b seach indicatingthatthe10 shared objectsthataffectothersharedaccessesdonotcontrolthe program andabout87 sharedobjectsareirrelevant.
comparingalld tam approaches hybridgives betterprecision as observed for axel.
disclaimer the relevancy ratios for inputs and shared objects reflect the trends observed on the test runs of the benchmarks used in our experiments.
it may hold for other multi threaded ben chmarks thatwere not used butmay not holdingeneral.
sinkdependencies.
we now evaluate the dependency for sinks shared accesses and branches i.e.
how many shared acc esses depend on inputs and or branches and how many branches re ly on inputs and or shared objects.
we chose dtam hybrid torep resent the results as other methods give similarresults.the left half of figure shows the distribution of dynamic in stancesofsharedaccessesthataredependentoninputsand orbranches amongalltestedapplications.
exceptforblackscholes we observe that more than of shared accesses turn out to be dependent upon inputs sh iandsh i b atruntime andmostof themdepend onboth inputs and branches.
the right half of figure shows the distribution of dynamic i nstances of branches that are dependent upon inputs and share d objects.
similartopreviousresult mostofbranchesdependo ninputs br i or bothinputs and shared objects br i s .
these results highlight that most shared accesses and branc hes are dependent on some inputs.
this implies that without prop erly monitoring such relevant inputs it is extremely diffic ult to reconstruct shared state or control flow of multi threaded pro grams whichjustifies our motivation of relevancy analysis.
.
related work ourwork isrelatedtodynamic taintanalysis andruntime mul tithreaded program monitoring.
dynamic taint analysis.
in the last few years there have been many proposals tobuildefficientdynamic taintanalysis too lsfrom both software and hardware communities.
overall the previ ous proposalscanbecategorizedintothreeapproachesbasedon underlying infrastructure used dynamic binary translation db t based approaches whole system emulation ba sed approaches andhardware assisted systems .
dynamicbinarytranslationhasbeenlargelyusedforimplem entingdynamic taintanalysis asitworks easilyonagivenexec utable binary and most previous works have focused on reducing per formance overhead of taint propagation and runtime checks for s equential programs with better instrumentation techniques .
for example tainttrace based on dynamorio leverages one t o one tablemappingbetweendataandtaintmetadataforfastlooku p and also implements a fast switch between original code and inst rumentation using dead register analysis and eflag liveness an alysis.
similarly lift implemented by stardbt proposes a co nditional branching mechanism between a fast path w oinstrum entation anda slowpath withinstrumentation toskipredunda nt runtime checks.
italsoimplements an efficientinstrumentatio n mechanism without stack switches.
recently tainteraser based onpin proposestoleverageuser annotatedfunctionsumma riesto speed up runtime taint propagation and checks.
even though w e also use the dynamic binary translation tool pin our focus i s not on improving performance using better instrumentation lik e previous works.
instead wefocus onenabling paralleltaintanal ysis for multi threadedprograms.
allthepreviousdbt basedworks either do not consider multi threaded programs or simplyassume s erialized executions like dtam serial .
on the other hand prev ious whole system emulation based approaches enable dynamic ta int analysisformulti threadedprograms buttheysufferfrom highperformance overhead and require support from operating syste ms or hardware for practical implementation.
runtime monitoring for parallel programs.
with the advent ofmulticoreprocessors runtimesystemsthatexploitextr acoresto monitor multi threaded programs have been proposed.
log b ased architecture lba supportsahardwareeventqueuewhic hefficientlycollectsruntimeexecutionevents e.g.
memoryope rations .
the logged information can be dequeued by lifeguards which run in parallel with the original program on spare cores and perf orm runtimechecks.
forexample bufferflyanalysis hasbee nbuilt on top of lba for efficient memory bound analysis and taint ana lysis for multi threadedprograms.
respec proposesasoftware onlysystemthatenablesde coupledruntimechecksofmulti threadedprogramsbasedonano nline deterministic replay technique.
respec records non deter ministic eventsoftheoriginalprocessandreproduces themforthere playedfigure l ratio of relevant inputs to total inputs i sc for dtam hybrid r comparison of serial parallel hybr id fori bs.
figure l ratio of relevant shared objects to total shared objects s for dtam hybrid r comparison of serial parallel hy brid fors bs.
figure distribution of dynamic instances of left shared accesse s that depend on inputs and or branches right branches th at depend on inputs and or shared objects.
process which run in parallel on extra cores.
as replayed ex ecution is guaranteed to be same as the original execution it allows users to perform heavy weight runtime checks on replay ed executions without pausing the original executions.
as an e xtension doubleplay timeslicesmulti threadedexecutio nsintosocalled epochs and runs each epoch in uniprocessor concurre ntly withoriginalexecution.
aseachepochisexecutedinunipro cessor doubleplay enables using sequential version of monitoring tools suchasboundchecks taintchecks etc.
withoutmodificat ionand its runtime cost canbe parallelized.
in contrast our system dtam monitors each thread independently i.e.
performs thread modular taint analysis and considers the effect of shared accesses laterinanoffline analysis.
.
conclusions wepresentedathread modular dynamic taintanalysisformu ltithreaded programs which can provide generalized taint anal ysis from a single observed execution.
we used this analysis to id entify a smaller set of inputs and shared objects in a multi thr eaded program.
in future work we plan to evaluate the benefits of re levancy analysis to a replay system for multi core platforms.
based on potential uses we also introduced various relevancy typ es and groups for inputs and shared objects.
such relevancy analys is can be used to improve testing verification debugging and pro gram understandingformulti threadedprogramsduringdevelop ment or for failure diagnosis afterdeployment.