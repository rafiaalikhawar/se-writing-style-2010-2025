refactoring java programs for flexible locking max sch fer oxford university computing laboratory max.schaefer comlab.ox.ac.ukmanu sridharan julian dolby frank tip ibm t.j. watson research center msridhar dolby ftip us.ibm.com abstract recent versions of the java standard library offer flexible locking constructs that go beyond the language s built in monitor locks in terms of features and that can be fine tuned to suit specific application scenarios.
under certain conditions the use of these constructs can improve performance significantly by reducing lock contention.
however the code transformations needed to convert between locking constructs are non trivial and great care must be taken to update lock usage throughout the program consistently.
we present relocker an automated tool that assists programmers with refactoring synchronized blocks into reentrantlock s andreadwritelock s to make exploring the performance tradeoffs among these constructs easier.
in experiments on a collection of real world java applications relocker was able to refactor over of built in monitors into reentrantlock s. additionally in most cases the tool could automatically infer the same readwritelock usage that programmers had previously introduced manually.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms measurement performance keywords refactoring monitors read write locks .
introduction as multi core processors are becoming pervasive programs are becoming more concurrent to take advantage of the available parallelism.
however increasing concurrency in a program is often non trivial due to various potential scalability bottlenecks.
one common bottleneck is lock contention where scalability is limited by many threads waiting to acquire some common lock in order to safely access shared memory.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.various solutions exist for addressing lock contention each with benefits and drawbacks.
approaches that avoid locks altogether include lock free data structures see e.g.
and transactional memory tm .
however writing correct lock free data structures requires more expertise than can be expected from most programmers and the semantics of tm may not be suitable in some cases e.g if i o needs to be performed .
making locking more fine grained can also increase concurrency but potentially risks introducing subtle race conditions.
in the context of java the standard java.util.concurrent library in the sequel abbreviated as j.u.c provides a number of data structures and locking constructs that could also be helpful with their own tradeoffs.
with all these options there is a strong need for tool support to help programmers experiment with different solutions to see what works best in a particular situation.
in this paper we focus on refactoring support for the advanced locking constructs available in j.u.c .
the reentrantlock type enables many features unsupported by java s built in locks such as non block structured lock operations checking if a lock is held trylock interrupting lock acquisition and specifying fairness behavior under contention.
additionally the readwritelock type enables distinguished reader and writer locks where multiple threads holding the reader lock may execute concurrently.
the goal of our research is to provide refactoring tools that support the transition from built in locks to these advanced lock types.
many difficulties arise when manually transforming a program to use the locking constructs of j.u.c motivating better tool support.
first these constructs lack the concise and intuitive syntax of the synchronized blocks associated with java s built in monitor locks.
instead locks are modeled as objects and lock operations as method calls and the burden is on the programmer to ensure that acquisition and release of locks are properly matched.
second the relative performance of different lock types strongly depends on the number of threads and their workload and on the architecture and jvm being used.
as we shall show in section these performance tradeoffs are often unclear and may change as programs and jvms evolve.
therefore programmers may need to switch back and forth between different lock types to determine the best lock for the job.
third the transformation from one locking construct to another can require tricky non local reasoning about program behavior.
all code blocks using the same lock must be transformed together to ensure behavior preservation and discovering all such blocks can be nontrivial.
in some cases the migration to advanced locks is impossible when the program extends a framework that relies on a specific form of synchronization.
introducing read write locks requires careful reasoning about where a read lock is safe to introduce as incorrect use of a read lock can lead to subtle race conditions.
in this paper we present relocker an automated refactoring toolthat can replace built in monitor locks with reentrantlock s and readwritelock s.1building a practical tool for performing these lock refactorings is challenging the transformations involved require knowledge about object aliasing and possible heap side effects but most analyses for computing such information are not suitable for use in a refactoring tool due to performance issues or the assumption that all relevant code is reachable from a set of entry points.
relocker is carefully designed to enable automation of most of the code transformations needed to switch between locking constructs in real world programs while only using analyses suitable for a practical refactoring tool.
the contributions of this paper are algorithms for converting from built in monitor locks to reentrantlock s and for converting from reentrantlock s toreadwritelock s. an implementation of these algorithms in an automated refactoring tool called relocker .
an evaluation of relocker on a set of java programs demonstrating that relocker was able to refactor over of all monitor locks into reentrantlock s and showing that on several programs that already used readwritelock s relocker was able to infer read locks in most cases where programmers had previously introduced them manually.
the remainder of this paper is organized as follows.
section presents background on the advanced lock types from j.u.c and an example to motivate our refactorings.
sections and present algorithms for converting from monitor locks to reeentrantlock s and from the latter to readwritelock s respectively.
in section we present the implementation of relocker and its evaluation on a set of java benchmarks.
section discusses related work and conclusions are presented in section .
.
motiv ating example in this section we give an overview of our proposed refactorings via three versions of an example class implemented with the different locking constructs.
we introduce these constructs and present variants of the example class using each of these constructs in section .
.
then in section .
we discuss the complex performance tradeoffs between the variants motivating the need for a refactoring tool to enable experimentation.
finally section .
illustrates some challenges of performing the refactorings in the context of the examples.
.
example figure illustrates the different locking constructs involved in our refactorings.
the figure shows three different implementations of a class syncmap asynchronization wrapper similar to the ones available in class java.util.collections .
each syncmap implementation handles all map operations by acquiring a lock delegating to the corresponding operations in a contained mapobject and finally releasing the lock.
the program of figure a uses the built in monitor locks that are associated with java s synchronized blocks.
while these locks have the benefit of concise syntax and low overhead in the uncontended case there are situations where more flexibility is required and where their performance is suboptimal.
to address these shortcomings two alternative types of locks are available in java standard libraries since java .
in package java.util.concurrent.locks 1refactoring reentrantlock s and readwritelock s back into builtin monitor locks is easy provided that none of the features specific to the advanced lock types are used.throughput ops second jvm sync d reentrant r w cores readers writers sun .
.0 07 .
.
.
sun .
.0 07 .
.
.
sun .
.0 07 .
.
.
sun .
.0 15 .
.
.
sun .
.0 15 .
.
.
sun .
.0 15 .
.
.
sun .
.0 17 .
.
.
sun .
.0 17 .
.
.
sun .
.0 17 .
.
.
table synthetic benchmark throughput.
all measurements are averages of runs of seconds each.
core numbers were taken on a way dual core .2ghz intel xeon linux machine with 20gb ram.
core numbers were taken on a 2ghz amd athlon x2 dual core linux machine with gb ram.
reentrantlock has similar behavior to a built in monitor lock but is more flexible by i allowing non block structured regions to be protected by locks ii supporting trylock a mechanism for testing whether a lock is held and iii supporting fairness parameters and multiple condition variables.
areadwritelock has an associated read lock and write lock.
only one writer thread may execute while holding the write lock but multiple reader threads can execute concurrently while holding the read lock as long as no thread holds the write lock .
this construct enables better performance when write operations are relatively infrequent.
both of these types of locks require slightly more awkward syntax than traditional synchronized blocks the programmer creates a lock by calling the constructor for the appropriate lock type and must call methods on the returned lock object to perform lock unlock trylock operations.
figure b shows an alternative implementation of class syncmap based on reentrantlock s that is semantically equivalent to the one in figure a .
in this version the lock is created when the syncmap object is being constructed a call to lock is inserted at the beginning of each method and a call to unlock before returning.
note that a try finally construct must be used in order to ensure that the lock is released when a method exits exceptionally.
the solution based on readwritelock s shown in figure c is analogous to that of figure b but utilizes the read lock obtained by invoking method readlock for methods that do not update the map only method put requires the use of the write lock.
.
performance tradeoffs the performance differences between the different locking constructs can be both dramatic and unpredictable.
table presents a performance comparison of a synthetic benchmark using our implementations of syncmap on different jvms and hardware.
the benchmark spawns some number of reader and writer threads that respectively perform random reads i.e.
getandcontainskey operations and writes i.e.
putoperations to a shared syncmap and then measures throughput in terms of total operations per second.
the final three columns of table give throughput numbers for the syncmap implementations using synchronized methods reentrant locks and read write locks figure a b and c respectively .
clearly switching to a different type of lock can have significant performance benefits.
for example on the core machine 2the full benchmark code is available at comlab.ox.ac.uk projects refactoring relocker .public class syncmap private final map map public syncmap map map this .map map public synchronized object put object k object v return map.put k v public synchronized object get object k return map.get k public synchronized int size return map.size a public class syncmap private final reentrantlock lock private final map map public syncmap map map this .map map lock new reentrantlock public object put object k object v lock.lock try return map.put k v finally lock.unlock public object get object k lock.lock try return map.get k finally lock.unlock public int size lock.lock try return map.size finally lock.unlock b public class syncmap private final readwritelock lock private final map map public syncmap map map this .map map lock new reentrantreadwritelock public object put object k object v lock.writelock .lock try return map.put k v finally lock.writelock .unlock public object get object k lock.readlock .lock try return map.get k finally lock.readlock .unlock public int size lock.readlock .lock try return map.size finally lock.readlock .unlock public int sizeviaiter lock.readlock .lock try iterator i map.entryset .iterator int count while i.hasnext count i.next return count finally lock.readlock .unlock c figure alternative implementations of class syncmap based on standard monitor locks a reeentrantlock s b and on readwritelock s c .
running the sun .
.0 07 jvm switching from a monitor based implementation of syncmap to one based on readwritelock s yielded a more than twofold increase in throughput when read operations dominate.
when the sun .
.0 15 jvm was used on the same configuration the version based on readwritelock s won by an even more dramatic factor of .
however in a configuration where write operations were more prevalent the version with synchronized blocks was faster than one based on read write locks with the sun .
.0 07 jvm faster with the sun .
.0 15 jvm .
in a low contention case with just reader and writer the performance differences were less extreme and each of the three types of locks yielded the fastest version on at least one machine vm configuration e.g.
note that reentrantlock s were fastest on the core machine with the sun .
.0 15 jvm .
as shown by table the relative performance of different types of locks strongly depends on the mix of read and write operations and on the architecture and jvm being used.
careful experimentation is needed to determine which locks perform best and this argues strongly for refactoring tools that make it easy to switch between different types of locks.
.
refactoring challenges therelocker tool that we developed is capable of automatically inferring the version of syncmap of figure b from the originalcode in figure a .
while the transformation needed to perform the refactoring is fairly straightforward for the simple example under consideration a slightly more involved transformation is sometimes needed.
also determining when the transformation is safe requires non local reasoning.
with the syncmap example in addition to the code shown the refactoring must check which other synchronized blocks in the program might lock a syncmap object.
this check requires aliasing information which is typically computed with expensive whole program analysis.
however we have devised techniques that are sufficient for handling typical usage of synchronized blocks and methods while avoiding any costly whole program analysis.
section details our algorithm for refactoring built in monitor locks into reeentrantlock s. relocker can also automatically refactor from reentrantlock s toreadwritelock s transforming the class in figure b into that of figure c .
a key goal of this refactoring is to introduce as many read locks as possible in order to increase potential parallelism in the refactored program.
however determining when a read lock can be used safely can be quite challenging in the presence of heap updates only some of which are relevant to locking.
consider the contrived sizeviaiter method in figure c which computes the size of the map by iterating through its entries.
for typical java iterator s the next method updates the state of the object to reflect the current traversal position.
in this case however this heap update mutates a local object allocated by the iterator call and hence does not affect the correctness of using a read lock.
most attempts to prove such program properties in the literature are again based on costly whole program analysis but in section we describe a carefully designed local analysis that often suffices for the task of read lock inference.
.
introducing reentrant locks theconvert to reentrant lock refactoring allows the programmer to replace all uses of a built in monitor with corresponding uses of an object of type reentrantlock in particular it can transform the code from figure a to that of figure b .
all operations on built in monitors have their equivalent on reentrant locks and moreover the semantics of reentrant locks with respect to ordering visibility and atomicity is the same as for built in monitors .
hence this refactoring preserves program behavior as long as it is performed consistently in the following sense two operations on the same built in monitor in the original program either still operate on the same monitor in the refactored program or they have both been refactored to work on the same reentrant lock and vice versa.
because using reentrantlock objects for locking can carry a higher overhead than using built in monitors on modern jvms this refactoring can degrade program performance.
as explained previously however reentrant locks offer additional features such as non block structured locking that may be useful in some circumstances.
while this refactoring does not aim to introduce the use of such features into the program it makes it much easier for the programmer to experiment with them it also lays the groundwork for a more sophisticated refactoring for converting reentrant locks to read write locks introduced in section .
it is of course not possible for the refactoring to transform a singlemonitor as it exists at runtime into a reentrant lock for instance the same synchronized instance method will use different monitors when invoked on different objects and the monitor expression of asynchronized block may evaluate to different objects at different times.
hence it is more correct to think of the refactoring as changing a setmof monitors into a set lof reentrant locks.
to achieve the goal of consistently refactoring all uses of monitors frommto corresponding uses of locks from l we have to answer two questions which monitor uses have to be refactored together and how they ought to be refactored.
to answer question we must categorize all uses of built in monitors into those that use a monitor from m and hence must be refactored and those that cannot possibly do so.
for the second question we have to uniquely assign a lock from lto every monitor from m and replace all relevant monitor uses with a use of the corresponding lock.
in principle the two questions are independent.
however answering the second question leads to a simple and practical answer to the first so we discuss how to perform the refactoring section .
before discussing what code to refactor section .
.
.
how to refactor we call a language construct that operates on a built in monitor amonitor action .
every monitor action ahas a monitor expression me a that evaluates to the object whose monitor is accessed by the action.
there are four kinds of monitor actions .synchronized instance methods which enter and exit the monitor of their receiver object their monitor expression is this .synchronized static methods which enter and exit the monitor of the class object for their enclosing class their monitor expression is a class literal for that class class c private map m new hashmap public object get object k synchronized m return m.get k public void put object k object v synchronized m m.put k v figure monitor actions on unshared fields .synchronized blocks which enter and exit the monitor of the object their expression evaluates to that expression is their monitor expression .calls to methods wait notify andnotifyall which operate on the monitor of their receiver object their monitor expression is their receiver argument.
note that both types of synchronized methods can easily be desugared into synchronized blocks.
hence we limit our discussion to handling of synchronized blocks and calls to wait ornotify .
for a synchronized block with monitor expression e let lock expression l e evaluate to a corresponding reentrant lock.
given l e the block can be rewritten like this synchronized e ... l e .lock try ... finally l e .unlock as the program transformation is straightforward the main problem in performing the refactoring is determining l e .
our strategy for associating a reentrant lock with an object o is to store the lock in a field lofo which is made public to allow access from any package.
this technique is natural as it matches the association of java s built in monitors with unique objects.
syntactically the refactoring needs to insert a final instance field lof type reentrantlock into the declaration of the class of o and initialize it to a new instance of reentrantlock .
now l e can simply be defined as e l. this strategy only works if the type of ois a class since java interfaces cannot have instance fields and if the source code of the class is modifiable i.e.
it cannot be a library class.
for static synchronized methods the instance field insertion strategy does not work the locked object for a synchronized static method in class cis of type class c which cannot be modified.
fortunately we can achieve the same effect by storing the reentrant lock in a new static field c l again assuming cis modifiable .
in this case we define l e to bec l. this leaves us with the case of monitor actions on expressions whose type is neither a parameterized instance of class nor a modifiable class.
such monitor actions occur quite frequently in real code and hence cannot be ignored by the refactoring.
a common usage pattern of this kind is shown in figure class chas a member field m which is initialized to a fresh object and is used to synchronize access to other data in this case the map itself .
we can exploit encapsulation to handle most such cases.
note that the reference stored in mis never leaked in any way so the stored hashmap object is only accessible through mitself.
consequently the field satisfies the following important property any monitor action that operates on the monitor of an object stored in the field must access it through that very field.we call fields with this property unshared .
the field mof figure is unshared since it is only ever assigned newly created objects its value is never assigned to another variable and the methods invoked on it hashmap.put andhashmap.get do not leak the value of their receiver object.
in section we will discuss a simple syntactic check to determine whether a field is unshared.
suppose we want to refactor the set of monitors associated with all the objects stored in an unshared field like m. to associate lock objects with these monitors we introduce a new lock field lintom s enclosing class c which must be modifiable .
every monitor action operating on mhas a monitor expression of the form e.m so we can easily refactor it into a corresponding lock operation on e.l. to refactor invocations of wait and notify we utilize the condition variables of type condition associated with reentrantlock s. multiple condition variables can be associated with a reentrantlock via calls to newcondition but for our refactoring only one such variable is needed.
the refactoring introduces an additional condition variable field calongside the lock fieldland initializes it to a new variable whenever lis initialized to a new lock.
uses of wait andnotify can then be straightforwardly rewritten into corresponding uses of await andsignal onc.
.
what to refactor the previous subsection introduced three ways of associating a lock object with a built in monitor as an instance field of the typecof the object to which the monitor belongs as a class field of the type cto whose class object the monitor belongs and as a sibling field of the unshared field fto whose value the monitor belongs.
this suggests an abstraction of sets of monitors as abstract monitorsof the following three types .for a type c the t monitor tm c represents the monitors belonging to all objects of type cor its subtypes .for a type c the c monitor cm c represents the single monitor belonging to the class object of type c .for an unshared field f the f monitor fm f represents the monitors of all objects stored in f. for an abstract monitor m we write jmkto denote the set of concrete monitors it represents.
we write m m0to denote jmk jm0k and m?m0to denote jmk jm0k .
for instance we have cm c tm java.lang.object for any class c since class c extends java.lang.object .
similarly if field fhas type c then fm f tm c and of course tm c tm b whenever cis a subtype of b. on the other hand note that cm c ?fm f for every cand f if the class object of cwere stored in f then fwould not be unshared since its value could be accessed as c.class without reference to f. likewise for two unshared fields fandg jfm f k and jfm g kare either equal or disjoint and they can only be equal iff g. to determine which monitor actions to refactor the refactoring assigns to every monitor action aan abstract monitor m a that conservatively overapproximates the set of monitors that acould operate on at runtime.
given this assignment if mis the abstract monitor representing the monitors whose uses are to be replaced with reentrant locks then all awithm a mshould be refactored and for all other actions a0we must have m a0 ?m.a straightforward definition of m a is as follows m a fm f ifme a is an access to unshared field f cm c ifme a is of type class c tm c otherwise where me a is of type c however this definition does not capture all the information we need.
if m a istm c we only know that aoperates on the monitor of some object assignable to type c. in fact however a also cannot operate on the monitor belonging to any object stored in an unshared field even if that field is of type c for otherwise m a would have to be an f monitor.
in order to track this additional information we slightly modify our definition of tm c .for a type c the abstract monitor tm c represents the set of all monitors belonging to all objects of type cor its subtypes except those stored in unshared fields .
the definition of m a above still gives a sound overapproximation of the set of monitors that acould operate on under this new definition but it is now very easy to check inclusion and disjointness of abstract monitors.
to describe how we compute inclusion and disjointness let us first define the type tp m of an abstract monitor mby stipulating that tp cm c class c and tp tm c c whereas tp fm f is undefined.
then it is easy to see that m m0iff either m m0 or tp m is a subtype of tp m0 m?m0iff one of the following holds misfm f m0isfm f0 andf6 f0 miscm c m0iscm c0 andc6 c0 tp m andtp m0 have no common reflexive transitive subtype.
.
the algorithm we now describe the refactoring algorithm in more detail.
figure gives a pseudocode description of the main procedure of the refactoring convert to reentrant lock.
given an abstract monitor mto refactor it creates a corresponding lock field using procedure createlockfield and then iterates over all monitor actions ain the program.
those actions that must acquire the same monitor m a m are refactored using procedure transformaction for all others the refactoring ensures that their set of monitors is disjoint fromm and aborts if that is not the case reverting any changes it has already made.
procedure createlockfield shown in the same figure analyzes the kind of mand creates the lock field in the appropriate type ensuring that the type is modifiable.
we ignore here shallow issues to do with name binding for instance the name of the lock field cannot have the same name as a field already declared in the same class.
procedure transformaction syntactically transforms a given monitor action ainto a corresponding action on reentrant locks.
we use function mklockaccess to compute an expression lthat refers to the reentrant lock object.
finally transformaction performs the appropriate syntactic transformation of the program.
3note that in some cases lis inserted into the program twice.
if lis a complicated expression that should not be evaluated twice or whose value may have been changed by the block we can first perform an extract temp refactoring to extract its value into a fresh local variable x and then perform locking and unlocking on x instead.
procedure convert to reentrant lock abstractmonitorm createlockfield m for all monitor actions ado ifm a mthen transformaction a else assert m a ?m procedure createlockfield abstractmonitor m ifmisfm f then assert fis declared in a modifiable type create lock field las sibling field of f for all assignments atofdo insert assignment l new reentrantlock aftera else if miscm c then assert cis a modifiable type create static lock field linc else mmust be of the form tm c assert cis a modifiable class create lock field linc20 procedure transformaction monitoraction a assert ais from source code l mklockaccess a ifaissynchronized e ... then replace awith l.lock try ... finally l.unlock else if ais a synchronized method then remove synchronized modifier from a replace body of awith l.lock try ... finally l.unlock else amust be call to wait ornotify function mklockaccess monitoraction a e me a ifm a isfm f then eis of the form e0 f return e0 l else if m a iscm c then return c l else m a must be of the form tm c return e l figure refactoring convert toreentrant lock we have elided the code to deal with refactoring of wait and notify monitor actions.
to handle this we need a procedure createconditionfield to create a field to hold the condition variable which is completely analogous to createlockfield and procedure transformaction must rewrite the method call in question into an appropriate call on the condition variable field which is created by a function mkconditionaccess similar to mklockaccess .
observe that this refactoring can fail for three reasons refactoring the abstract monitor would require refactoring a monitor action that comes from compiled code and is hence not modifiable line there are ambiguous monitor actions that cannot be refactored consistently line the refactoring would need to modify an unmodifiable type lines .
.
introducing read write locks as discussed in section lock contention can sometimes be reduced through use of a read write lock which allow threads to read the state protected by the lock concurrently as long as no other thread is writing the state.
in this section we present a refactoringconvert to read write lock that enables programmers to more easily experiment with using read write locks to improve performance.
note that we only describe the refactoring for programs already using reentrant locks the convert to reentrant lock refactoring of section can be used to introduce such locks if needed.
our refactoring aims to introduce read locks rather than write locks whenever it can prove it is safe to do so thereby maximizing potential concurrency in the transformed program.
conceptually a reentrant lock lcan only be transformed into a read lock if any code that may execute while lis held does not modify the shared state protected by l. most java code does not formally document the relationship between locks and the corresponding protected shared state.4hence our algorithm checks for anymodification of potentially shared state while a lock is held and it only introduces a read lock when no such modifications are found.
4when such relationships are documented e.g.
through guardedby annotations we can easily use the information in our analysis to potentially infer more read locks.figure gives pseudocode for the convert to read write lock refactoring.
the refactoring takes a field fthat must be of type reentrantlock .
it changes the type of the field and adjusts any assignments to f including its initializer if it has one.
this step of the refactoring requires that fmay only be assigned newly created objects line in order to maintain a one to one correspondence between reentrant locks in the original program and read write locks in the refactored program.
now every use of fis adjusted.
to preserve type correctness all uses of fhave to be invocations of its lock andunlock methods and we require that these appear in the standard try finally pattern seen in earlier examples.
in practice most developers seem to follow this pattern so this is not a serious restriction.
handling more general cases would require some form of data flow analysis to determine what code may execute while the lock is held.
the refactoring now invokes function canusereadlock defined in lines to determine whether the block bof code protected by the lock is free from non local side effects so that a read lock can be introduced.
this function in turn uses function nonlocalsideeffects to determine whether any of the instructions sinbmodify non local state.
function nonlocalsideeffects lines takes as parameters a set sof instructions in some method mand a set pof the relevant parameters of m. as shown in the nonlocalwrite function lines a heap write instruction iis deemed non local iff iwrites a static field or iwrites an instance field or the array contents of some object o such that ois reachable via some sequence of dereferences from non local state defined as a static field or some parameter in p. the reachability check is performed via the reachablefromnonlocalstate call on line and may be implemented with any conservative may alias analysis.
the parameter set pis used in nonlocalsideeffects to exploit knowledge about purely local objects which may be safely mutated while a read lock is held.
initially pcontains all formal parameters of the method mcontaining the protected block b line as mutations to the state of any of m s parameters may prevent the use of a read lock.
when analyzing some method transitively called bym however we need only consider side effects to any formal parameter fwhose corresponding actual parameter aat the caller1 procedure convert to read write lock field f assert fhas type reentrantlock change declared type of ftoreentrantreadwritelock for all assignments to fdo assert fis assigned a new reentrantlock object change to assignment of new reentrantreadwritelock for all usesuoffdo assert uis call f.lock orf.unlock ifuintry finally construction with body b andcanusereadlock b then replace use of fwithf.readlock else replace use of fwithf.writelock function canusereadlock block b s instructions in b ifbis in a constructor or method mthen p parameters of m including this ifmis not static else p return nonlocalsideeffects s p function nonlocalsideeffects set instr s set param p for all instructions i2sdo ifnonlocalwrite i p then return true else if iis a method call then for all methods m0possibly called by ido s0 instructions of m0 p0 ff formals of m0jais actual for f reachablefromnonlocalstate a p canreachnonlocalstatevia a p g ifnonlocalsideeffects s0 p0 then return true return false function nonlocalwrite instr i set param p ifiwrites a static field then return true else if iwrites an instance field or array element then return reachablefromnonlocalstate baseptr i p else return false figure refactoring convert to read write lock public string tostring flock.lock try stringbuilder result new stringbuilder f1.tostring result.append n result.append f2.tostring return result.tostring finally flock.unlock figure example of writes to local objects.
satisfies either areachable via dereferences from non local state or non local state can be reached via dereferences from a. we need condition since the callee may read the non local state from aand then mutate it.
line in the pseudocode determines the relevant formals using procedures reachablefromnonlocalstate and canreachnonlocalstatevia both implementable via may alias analysis .
by ignoring writes to local objects via these relevant parameter sets our algorithm is able to infer more read locks than if it treated all writes as suspect.
figure gives an example tostring method that illustrates the benefits of ignoring writes to local state.
the method appends fields f1and f2to a stringbuilder and returns the resulting string while holding the flock lock.
the calls to stringbuilder.append mutate the state of the stringbuilder .
if the analysis did not distinguish writes to local state this mutation would prevent the use of a read lock.
however our analysis is able to show that the stringbuilder pointed to by result is purely local.
hence when the append method is analyzed for side effects the receiver argument is not considered enabling the analysis to prove that using a read lock is safe.
note that cases like that of figure arise very frequently in real code as string concatenation in java is performed via allocating local stringbuilder objects and appending to them.
hence reasoning about local state is essential to our read write lock refactoring as failing to infer a read lock incases like figure would greatly frustrate users.
for performance we bound the call depth to which our analysis searches for side effecting statements not shown in figure for clarity .
if the call depth exceeds the bound the analysis conservatively assumes that unanalyzed calls may write to non local state.
potential targets at virtual calls are computed based solely on the program s class hierarchy more precise reasoning typically requires computing what code is reachable given certain entrypoints which is unsuitable for refactoring tools e.g.
when refactoring a library with no client code available .
in our implementation we use a custom demand driven mayalias analysis to implement the reachablefromnonlocalstate and canreachnonlocalstatevia procedures.
whole program pointer analyses often cannot be used in a refactoring tool due to excessive runtime and their reliance on knowing program entrypoints.
instead we determine potential aliasing by following interprocedural defs and uses as needed.
again we set a maximum call depth bound for performance and make pessimistic assumptions about method behavior beyond the bound for soundness.
.
ev aluation we have implemented the two refactorings introduced in the previous sections as a plugin for the eclipse ide.5in this section we report on an experimental evaluation of these refactorings on real world benchmarks.
.
implementation issues our implementation of convert to reentrant lock closely follows the pseudocode given in section .
to determine whether a fieldfis unshared it checks the following three conditions .
any assignment to fassigns it either null or a new object .the value of fis never assigned to a field passed as an argument to a method or constructor or returned as a result .no method invoked on fcan cause its value to become shared.
5the plugin is available for download from comlab.ox.ac.uk projects refactoring relocker .benchmark number of fm cm tm involves ambiguous unmodifiable refactorable mon.
actions library mon.
action type hsqldb .
xalan .
hadoop core .
jgroups .
cassandra .
total .
table evaluation of convert to reentrant lock.
to check the third condition we make sure that any method that is invoked on fisdiscreet meaning it does not synchronize on this nor assigns this to a field nor passes it as an argument or returns it as a result and only invokes discreet methods on this .
clearly these conditions are sufficient for fto be unshared.
while it might be possible to analyze methods for discreetness during the refactoring it turns out that in real world code only a few methods mostly from the collection classes in the standard library are usually invoked on unshared fields.
we hence decided to hardcode in our implementation a list of methods that we manually checked to be discreet and consider every other method to be indiscreet.
another pragmatic issue that arises when implementing convert to reentrant lock is concerned with the presence of monitor actions in compiled code.
for performance reasons it is infeasible to compute the abstract monitor of every such monitor action which in particular involves local type inference on bytecode methods .
instead we decided to only consider the monitor actions arising from compiled synchronized methods ignoring compiled synchronized blocks and calls to wait andnotify .
in principle this might lead to unsoundness in situations where a library synchronizes on an object created in application code that is passed to it as an explicit method parameter i.e.
a parameter other than this .
however such coding practices would give rise to extremely fragile code that could deadlock unexpectedly.
we thus felt justified to ignore this potential source of unsoundness all the more so because a conservative approach based on static analysis would likely be very imprecise and disallow the refactoring in many cases where it is perfectly safe.
to the best of our knowledge our benchmarks do not exhibit this kind of behavior.
our implementation of convert to read write lock closely follows the pseudocode presented earlier see figure in section .
the side effect and alias analyses are implemented using wala .
in our experiments we bound the call depth explored by the main refactoring to and the alias analysis depth for larger bounds yielded little benefit in our experiments.
the implementation relies on specifications of the heapupdating side effects of certain frequently used methods from the standard java library e.g.
equals and hashcode from java.lang.object some methods of class string and stringbuffer and several methods from the standard collection classes.
these specifications significantly improve the effectiveness of the refactoring enabling it to skip analysis of common library methods and well understood methods from the application e.g.
implementations of equals improving performance and precision.
while strictly speaking unsound pragmatic assumptions like this are common in the literature on static analysis see e.g.
.
we believe that the remote chance of unsoundness is outweighed by the significantly improved effectiveness of the refactoring.
.
evaluation of convert to reentrant lock for the convert to reentrant lock refactoring we measured its applicability on several real world java programs by ex haustively applying the refactoring to all built in monitors trying to refactor as many of them as possible.
our evaluation aims to answer two basic questions how useful is the proposed classification of abstract monitors and how many monitors of each kind occur in real world code?
how effective is the refactoring i.e.
what percentage of uses of built in monitors is it able to refactor and why does it fail in the other cases?
table shows the results of our evaluation.
we ran our refactoring on five benchmarks two fairly large programs with the database engine hsqldb at about thousand lines of source code ksloc6 and the xslt processor xalan at ksloc and three medium size programs with the hadoop core component of the apache hadoop framework at ksloc the jgroups toolkit at ksloc and the distributed database system apache cassandra at ksloc.
our untuned implementation took no longer than minutes to refactor a particular monitor.
the first data column gives the total number of source level monitor actions in the program the next three columns show their classification fm indicates the number of actions whose abstract monitor is an f monitor cm of those with c monitors and tm of those with t monitors.
as it turns out many monitor actions in real code have nothing to do either with unshared fields or with class objects the latter two categories often forming a small minority.
nevertheless it is essential to give unshared fields a special treatment many unshared fields are of type object if they were classified as t monitors they would effectively prevent us from refactoring any other t monitor since our type based analysis would not be able to exclude the possibility of aliasing.
the next three columns of the table account for those monitor actions that could not be refactored categorizing them according to the source of failure the first column gives the number of monitor actions that could not be refactored because this would necessitate refactoring another monitor action which is not from source the second tallies those monitor actions where another monitor action was encountered that might operate on the same monitor but does not definitely do so and the final column shows the number of monitor actions that could not be refactored because the refactoring would have entailed modifying an unmodifiable type declaration.
monitor actions of the first category are often synchronized methods in user defined subclasses of the library class java.lang.thread that class has some synchronized methods which cannot be changed so neither can the methods in any of its subclasses.
for many of the monitor actions in the second category a more precise analysis would presumably be able to prove that no monitor aliasing is possible and hence allow the refactoring 6as determined by david a. wheeler s sloccount .benchmark read write uses of corr.
inf.
locks read lock write lock read locks hsqldb .
hadoop core jgroups mina cassandra .
seraph total .
table evaluation of convert to read write lock.
to go ahead nevertheless it is encouraging to see that even a very simple type based analysis can handle most cases well enough.
the final column gives the number and percentage of monitor actions that could be successfully refactored.
generally our tool is able to refactor upwards of of all monitor actions in some cases significantly more.
we do not suggest that all these monitor actions should be replaced by corresponding uses of reentrant locks that is not for a refactoring tool to decide.
rather our tool provides the possibility for the programmer to perform this refactoring successfully in the vast majority of cases at the push of a button.
.
evaluation of convert to read write lock to evaluate the convert to read write lock refactoring we looked at six major applications that already use read write locks.
we then manually refactored them back to reentrant locks and used our tool to attempt to re infer the original read write lock usage.
our measure of success for this refactoring is simply how many uses of read locks the refactoring is able to infer correctly.
inferring write locks is of course trivial.
the results of this experiment are given in table .
we use mostly the same benchmarks as above except for xalan which does not use read write locks at all instead we consider the apache mina network application framework a medium sized program of ksloc and the j2ee web application security framework atlassian seraph which consists of only about lines of source code.
refactoring a reentrant lock to a read write lock took no more than one minute for any benchmark.
for each benchmark we give the total number of read write lock fields in the program.
next we list the number of uses of the read and write locks respectively and finally the number and percentage of correctly inferred read locks.
in all cases with write locks our analysis soundly determined that use of a read lock was unsafe.
we were able to infer all read locks for mina hadoop jgroups and seraph and more than half for cassandra but only for hsqldb .
having inspected the cases where we fail to infer read locks in hsqldb andcassandra more closely we believe handling them is beyond any practical analysis for a refactoring.
in all of the failing cases writes to non local state can actually occur while the read lock is held assuming the corresponding call targets in our classhierarchy based call graph are feasible.
building a more precise call graph via flow analysis is quite difficult since in many cases client code for library methods using read locks is missing.
hsqldb in particular makes fairly sophisticated use of read locks as fields in certain caches are updated in a racy manner while read locks are held.
we consulted the hsqldb developers by email about this issue and they confirmed that such races can in fact occur but are harmless since the cached data is not mutated at the same time and hence the result will always be consistent.
the kind of global reasoning required to prove the safety of read locks in such cases is clearly beyond the capabilities of our analyses and it seems likely that any analysis powerful enough to handle this kind of situation would be too heavyweight for use in a refactoring tool.in contrast to convert to reentrant lock the convert toread write lock refactoring hardly ever fails since it can always just replace uses of the reentrant lock with uses of the write lock.
we envision its use as a first step in converting a reentrant lock to a read write lock it will consistently update the declaration and all uses and directly introduce read locks for the simple cases staying on the safe side and introducing write locks for the trickier ones.
it is then up to the programmer to convert those remaining locks to read locks if needed based on their understanding of the semantics of the program.
.
assumptions and threats to validity our implementation make two pragmatic but strictly speaking unsound assumptions.
first we assume that synchronized blocks and invocations of wait andnotify in compiled methods can be disregarded for analysis purposes.7second we provide specifications of the non local side effects of several well known standard library methods and assume that all overriding methods conform to these specifications.
these assumptions motivated and justified in greater detail in section .
are the only two sources of potential unsoundness.
for performance reasons we use imprecise approximations in two other places we use a built in table of known discreet methods and when analyzing code for potential non local side effects we bound both the call graph exploration depth and the interprocedural alias analysis depth.
in both cases however we make conservative assumptions in cases where the approximation fails which cannot introduce unsoundness.
perhaps the main threat to the validity of our results is that the benchmark programs may not be representative of all programs however we have chosen a set of programs that represents heavily used examples of several major application domains databases xml processing column stores and map reduce frameworks.
thus while it may be that other classes of applications could exhibit very different attributes it seems very likely that even if that were to be our results should still apply across a wide range of applications.
.
related work most previous work on refactoring has concentrated only on sequential programs without considering the implications of concurrency.
early refactoring research studied the mechanics of expressing behavior preserving transformations for sequential programs using pre and post conditions and program dependence graphs .
later work considered various features of sequential programs such as class hierarchies generics design patterns and access modifiers .
other research has focused on refactoring support to adapt programs to evolving libraries combining refactorings with other programs transformations empirical studies and domain specific languages for specifying refactorings .
sch fer et al.
proposed to formulate refactorings in terms of their effect on static semantic dependencies such as name binding or def use dependencies.
the present authors then showed how this approach can be extended to a concurrent setting by using dependencies to statically capture concurrent behavior .
recently there has been a lot of interest in refactoring programs to enhance their concurrent behavior.
the concurrencer tool of dig et al.
refactors code to make use of concurrenthashmap s and atomicinteger s also provided by the j.u.c library.
use of such types is another technique for improving scalability by reducing 7recall however that compiled synchronized methods are handled soundly.lock contention.
dig et al.
s relooper tool refactors loops to execute in parallel via the proposed parallelarray class.
recently the same group have also proposed a technique and a tool for making classes immutable thereby ensuring their thread safety .
balaban et al.
considered the issue of migration from legacy classes e.g.
vector to functionally equivalent classes that replace them e.g.
arraylist .
while this work was primarily concerned with handling incompatibilities in the apis some support was provided to ensure that synchronization behavior was preserved by inserting synchronization wrappers where needed.
the reentrancer tool transforms sequential programs to be reentrant enabling safe parallel execution .
finally several researchers have tackled the problem of implementing refactorings for x10 a javabased language with sophisticated concurrency support and have reported promising first results .
.
conclusions and future work the java class libraries now provide flexible locking constructs that can improve performance by reducing lock contention.
however experimenting with these locks has been difficult as it requires non trivial code transformations.
we have presented algorithms for determining how programs can be refactored to use reentrantlock s and readwritelock s instead of built in monitor locks and implemented these algorithms in an automated refactoring tool called relocker .
in an evaluation on a collection of java programs relocker was able to convert over of the monitor locks in these programs into reentrantlock s. moreover relocker was able to infer read locks in most cases where programmers had previously introduced them manually.
future work includes the design of refactorings for shrinking the regions of code protected by locks possibly by taking advantage of the ability of reentrantlock s to protect non block structured regions.
in the same spirit a future tool could help developers safely downgrade write locks to read locks a feature supported by readwritelock to further decrease lock contention.