recovering traceability links between an api and its learning resources barth el emy dagenais and martin p. robillard school of computer science mcgill university montr eal qc canada fbart martin g cs.mgill.ca abstract large frameworks and libraries require extensive developer learning resources such as documentation and mailing lists to be useful.
maintaining these learning resources is challenging partly because they are not explicitly linked to the frameworks api and changes in the api are not reflected in the learning resources.
automatically recovering traceability links between an api and learning resources is notoriously difficult due to the inherent ambiguity of unstructured natural language.
code elements mentioned in documents are rarely fully qualified so readers need to understand the context in which a code element is mentioned.
we propose a technique that identifies code like terms in documents and links these terms to specific code elements in an api such as methods.
in an evaluation study with four open source systems we found that our technique had an average recall and precision of .
i. i ntroduction reusable assets such as frameworks and libraries are generally provided with resources to help software developers learn how to use these assets.
learning resources for developers typically include tutorials reference manuals and various mailing lists and forums.
writing moderating and maintaining such resources require a considerable effort .
for example the spring framework reference manual has more than words and the hibernate framework forum has more than messages.
even a smaller library such as httpcomponents which contains classes has a developer documentation of words divided in two manuals and a mailing list that includes more than messages.
ideally developer learning resources should be both extensive covering all parts of the framework s api and detailed explaining many low level programming patterns while being continually maintained to keep up with feature additions api usability problems and community requests.
for instance we observed in a recent study on developer documentation that when a question is repeatedly asked on a mailing list framework contributors see this as an indication that the documentation needs to be clarified .
in cases where there are multiple support channels chat mailing lists forums and multiple contributors operating in different time zones the contributors are often unaware that the same code element e.g.
function is the root cause of several questions.
specifically because the support channels and the documentation are not explicitly linked to the api it isdifficult for a contributor to determine which code elements cause the most problems and need to be further explained in the documentation.
the main challenge in linking code elements with existing learning resources comes from the inherent ambiguity of unstructured natural languages.
for example the user guide of the joda time library mentions in the middle of the date fields section ... such as year or monthofyear .
although it is clear from this sentence fragment that a method named year is mentioned there are classes not all in the same hierarchy that declare a year method in joda time.
the code like term year could also refer to a method declared in an external library frequently used with joda time e.g.
java standard library .
in this particular case a human reader would know that the term refers to datetime.year because the class datetime is mentioned at the beginning of the section i.e.
in the context of the method year .
however a simple mechanical match based on the method name and ignoring the context of the term would fail.
in fact in the four open source projects we studied section iv we found that a mechanical match would have failed to find the correct declaration of of the methods mentioned in the learning resources because the methods were declared on average in .
different types.
several techniques have been previously proposed to link project artifacts.
however there is currently no technique that precisely links the documentation the support channels and the api together at a fine level of granularity.
for example hipikat links coarse grained project artifacts such as code commits emails and bug reports based on bug numbers .
bacchelli et al.
devised a technique that identifies source code e.g.
code snippets in emails and that can link classes mentioned in the email to classes declared in a codebase but the technique does not work at the sub class level of granularity.
we propose a technique that automatically analyzes the documentation and the support channel archives of an open source project and that precisely links code like terms e.g.
year to specific code elements e.g.
datetime.year in the api of the documented framework or library.
our technique considers the context in which a term is mentioned and applies a set of filtering heuristics to ensure that terms referring to external code elements are not spuriously linked.we implemented our technique in a tool called recodoc and applied it on four open source systems.
we found that our technique identified on average of the code like terms recall and linked these terms to the correct code element of the time precision .
the high accuracy of our technique will enable the development of reliable approaches that can improve the learning resources based on the relationships between these resources and the api.
our contributions include a meta model to represent documentation support channels code and their relationships and a fine grained technique to link the contents of developer learning resources with code elements validated on an extensive collection of artifacts from three open source programs.
recodoc is open source and publicly available .
we begin by presenting a meta model to represent the various project artifacts section ii .
then we describe the linking technique we devised to associate the code like terms from the learning resources to the code elements of an api section iii .
we present the evaluation we performed on four open source projects in section and we discuss the related work in section .
ii.
p roject artifacts meta model a variety of information is needed to understand the context in which a code like term is mentioned.
in the documentation example of figure the method getparams is declared in eight types in the httpclient library.
we can precisely find which method declaration is referred to if we know that getparams is mentioned in section .
.
section .
is part of section .
httpget is mentioned in section so it is in the context forgetparams .
httpget does not declare getparams but inherits it from httpmessage which declares getparams .
based on our previous study on developer documentation and on initial prototyping with various releases of the spring framework a large and complex java project we designed a meta model to universally represent the documentation support channels and api of any open source project.
we use this meta model to understand the context in which a code like term is mentioned.
the main elements of the meta model are described in the next paragraphs and are represented in figure .
project.
a project may have different releases and each release is associated with a particular codebase and documentation.
for example the httpcomponents project has three major releases .
.
and .
with a corresponding codebase and documentation.
codebase.
we consider that the api of a project consists of code elements e.g.
class method field parameter xml element .
recodoc currently parses java codebases xml schema files and dtd files.
a code element may havesection httpget implements the http get request in httpclient.
section .
call getparams to obtain the parameters of the get request.
you can call redirectstrategy.getredirect to determine the redirect location from a request.
figure .
documentation example loosely adapted from the httpclient tutorial.
figure .
documentation meta model one or more parents e.g.
a java class implements multiple interfaces and may declare other elements e.g.
a class declares methods .
additionally each kind of code elements is internally represented by a specialized class that keeps track of its specific attributes e.g.
a methodcodeelement has a list of parameters not shown in figure .
document.
the documentation of a project consists of one or more documents .
for example the httpcomponents project has two main documents the httpclient and httpcore tutorials.
each document has a list of pages and each page has a list of sections e.g.
section .
.
.
http request .
a section may be part of a larger section e.g.
section .
.
.
as we explain in section ii we consider a documentation page to be equivalent to an html page and not to a printed page.
support channel.
a project may have one or more support channels such as a mailing list or a forum.
for example the httpcomponents project has a mailing list httpclient users .
a support channel contains a list of support threads which contain a list of messages .
code like terms and code snippets.
messages and documentation sections can refer to code like terms andcode snippets .
a code like term is a series of characters that matches a pattern associated with a code element kind e.g.
parentheses for functions camel cases for types anchors for xml elements .
for example section .
in figure con tains three code like terms getparams redirectstrategy and getredirect .
a code like term list or term list is a sequence of code like terms.
we thus consider that the term listredirectstrategy.getredirect contains two code like terms and that the first term is the parent of the second.
a code snippet is a small region of source code that can be further divided into a list of code like terms.
for example in a java code snippet all method calls would be represented by code like terms.
finally a code like term may refer to one or more code elements in the codebase.
for example the term println from the term list system.out.println might refer to all overloaded declarations of println injava.io.printstream .
context.
we consider that there are three levels of context that can be associated with code like terms.
the immediate context contains all the code like terms in a term list.
the local context contains all the terms in the same documentation section or the same support message.
the global context contains all the terms in the same documentation page or in the same support thread.
for example the immediate context the local context and the global context forgetredirect in figure are respectively fredirectstrategy g fredirectstrategy getparams g fredirectstrategy getparams httpget g. we consider that a codelike term aiscloser to a term bthan to a term cifbis in a more specific context than c. for example getredirect is closer to getparams than to httpget .
generating models.
we generate a documentation model from a set of artifacts and recover the links between codelike terms and code elements.
figure demonstrates this process.
artifacts collection.
our technique takes as input the source code of a system the url of the documentation index such as the table of contents of a reference manual and the url of a support channel archive such as the first page of a forum.
we then crawl the documentation and the support channel archives to download the relevant html pages i.e.
documentation pages emails forum threads .
all documentation tools and archives we are aware of can produce an html output.
model generation.
we use an extensible parsing infrastructure to generate the model from the project artifacts.
for example the html output of documentation tool docbook differs from the html output produced by the maven tool so we created a mavenparser and a docbookparser that both extend a documentationparser .
we parse the java source code using the eclipse compiler .
content classification.
once the model is generated the parsing infrastructure classifies the content of the documentation and the support channel it identifies the codelike terms the code snippets and their probable kind e.g.
class method xml element java code snippet xml code snippet .
we relied on existing techniques described in theliterature and in our previous work to implement the content classification step.
a brief description of the classification process and the evaluation of its accuracy is presented in a technical report .
snippet parsing.
we further parse snippets to identify the code like terms within them.
for example we identify all calls declarations and