search based genetic optimization for deployment and reconfiguration of software in the cloud s oren frey florian fittkau and wilhelm hasselbring software engineering group kiel university kiel germany fsfr ffi whag informatik.uni kiel.de abstract migrating existing enterprise software to cloud platforms involves the comparison of competing cloud deployment options cdos .
a cdo comprises a combination of a specific cloud environment deployment architecture and runtime reconfiguration rules for dynamic resource scaling.
our simulator cdosim can evaluate cdos e.g.
regarding response times and costs.
however the design space to be searched for wellsuited solutions is extremely huge.
in this paper we approach this optimization problem with the novel genetic algorithm cdoxplorer.
it uses techniques of the search based software engineering field and cdosim to assess the fitness of cdos.
an experimental evaluation that employs among others the cloud environments amazon ec2 and microsoft windows azure shows that cdoxplorer can find solutions that surpass those of other state of the art techniques by up to .
our experiment code and data and an implementation of cdoxplorer are available as open source software.
index terms cloud computing search based software engineering deployment optimization i. i ntroduction the disruptive cloud computing paradigm paves the way for approaching the long desired idea of utility computing .
in the last years it gained considerable attention from industry and in academia.
along with the steadily increasing interest in cloud computing there also emerged an enormous demand for leveraging cloud technologies for existing systems .
however migrating and deploying enterprise software to the cloud still entails a wealth of challenges and potential pitfalls.
for example it is tedious to select an adequate cloud environment and the best suited virtual machine vm instance types with regard to inevitable trade offs between costs and performance from the plethora of available cloud offerings.
then the application and deployment architecture have to be reworked to conform with the chosen cloud and to enable compliance with defined service level agreements slas and the included quality of service qos stipulations.
to exploit the cloud s elasticity and the usually employed pay per use model it is necessary to implement and calibrate reconfiguration rules for cost efficient dynamic resource scaling according to observed usage patterns.
all of those design decisions form a multitude of cloud deployment options cdos that need to be explored for well suited candidates.
unfortunately techniques for automatically evaluating all cdos do not exist and a comprehensive manual analysis is most often inapt due to time and budget constraints .furthermore as we also intend to support distributed systems we consider the qos aware composition of software components that run on one node as a single service that is provided to an arbitrary number of components on other nodes.
such deployment optimization problems are intractable as they are known to be np hard .
in our previous work we introduced the simulation tool cdosim that implements a phase of our cloud migration approach cloudmig .
cdosim facilitates the simulation of cdos for determining their respective response times costs and sla violations.
we integrated cdosim into our tool cloudmig xpress that provides support for cloudmig.
with cloudmig xpress cdos can be manually configured and simulated on the basis of a reverse engineered architectural system model with monitored or synthetic workload.
however the design space that spans for all possible cdos is huge the elements of a single cdo exhibit complex non linear interdependencies and cdo simulation runs are very time consuming and can take from a few minutes to several hours.
hence simulating a great number of cdos is most often still not a viable option and it is therefore very likely that a suboptimal solution is chosen.
moreover there usually exists no single cdo that causes the lowest costs along with the lowest average response times and the lowest number of sla violations.
thus a potential cloud user is interested in automatically finding the most adequate trade off solutions among which the cdo candidate can be selected that best suites the user s specific needs.
the set of these most adequate trade off solutions constitutes a pareto optimum.
the included cdos cannot be improved concerning one objective without deteriorating another objective e.g.
considering a trade off between costs and response times.
in this paper we present the genetic algorithm cdoxplorer that explores the cdo search space on the basis of automatically extracted architectural models and approximates the corresponding pareto optimum.
similar problems are addressed by methods of the search based software engineering field where genetic algorithms are widely used .
cdoxplorer is implemented in our tool cloudmig xpress and supports iaas based cloud environments where the most often used building blocks are vms.
in general genetic algorithms group the candidates so called individuals in populations and use a fitness function to assess the candidates.
then the bestsuited individuals are selected.
they reproduce through so c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.512called mutation and crossover operations and after several generations the individuals that inherited superior properties become dominant.
to assess the fitness of cdos cdoxplorer uses simulation runs of cdosim to restrict the search space and to steer the exploration towards promising cdos.
thus cdosim is no longer used only for analyses but for design purposes as well.
by incorporating cdosim cdoxplorer is a member of the simulation based optimization class .
here the evaluation of the used fitness function is in contrast to most genetic algorithms very expensive and requires strict limitations regarding the population size and number of included generations.
cdoxplorer not only optimizes the allocation of software components to vms but also searches for reconfiguration rules that are aligned with the cloud s elasticity and the specific performance and pricing models of the available cloud environments.
a common challenge in the design of genetic algorithms becomes apparent as they do not guarantee to converge to a global optimum especially if a low number of generations is used.
hence we experimentally evaluate the applicability and convergence properties in comparison to other well known search and optimization algorithms.
we report on case studies that employ an open source enterprise resource planning erp system to be deployed on the cloud environments amazon ec2 an eucalyptus cluster as private cloud and microsoft windows azure.
in summary our main contributions are a simulation based genetic algorithm cdoxplorer for finding near optimal cloud deployment architectures and runtime reconfiguration rules for enterprise software an implementation of cdoxplorer within the scope of our open source tool cloudmig xpress that utilizes models which can almost all be extracted automatically extensive experiments that employ well known clouds show that cdoxplorer can find results that surpass those of other state of the art techniques by up to cloudmig xpress and our experiment code and data are available online as open source software such that interested researchers may repeat or extend our experiments.
the paper is organized as follows.
we provide a motivating example in section ii.
the required input models for our genetic algorithm are described in section iii and the output models it produces are explained in section iv.
section v details cdoxplorer.
then the experimental evaluation of cdoxplorer is described in section vi.
section vii discusses related work before our conclusions are drawn in section viii.
ii.
m otivating example we consider the example deployment of a software system that is shown on the left side of figure .
this system should be moved to the cloud environment amazon ec2.
it consists of eight software components that are currently deployed to three interconnected on premise server machines.
those machines are also called status quo nodes as they constitute elements of the deployment architecture that describes the !
!
fig.
mapping on premise servers and deployed components left to atomic services in a basic cdo example right .
status quo assignment of components to physical machines.
as mentioned earlier we regard all of the components that are deployed to a single status quo node as a separate service .
a service is an atomic unit concerning the allocation to a vm.
this design decision was made to prevent a further explosion in the number of combinations and cdos that have to be searched and to render pervasive changes unnecessary that may be required when distributing tightly connected components over different vms.
thus the three status quo nodes and the deployed components shown in the left part of figure result in the three services service toservice in the right part of figure that exhibit a similar assignment of components.
as can be seen in the lower right part of figure a single vm can host multiple services.
in our example it was decided to consolidate service andservice into a joint vm that is started with amazon ec2 s vm instance type m1.large .
such vm instance types describe the hardware resources that are available to vms.
for example at the time of writing amazon ec2 s m1.large vm instance type provides .
gb memory and two virtual cores that together provide approximately the cpu capacity of four .
ghz xeon processors from .
the remaining service in figure is deployed to an own vm that builds upon the m1.medium vm instance type.
the basic cdo of figure is now given by the number of chosen vm instances the assignment of services to these vm instances and the selection of a vm instance type for each vm instance.
furthermore up to this point runtime reconfiguration rules are omitted for the sake of simplicity.
reasoning about the broader array of all potential cdos for e.g.
just the single cloud environment amazon ec2 of its vm instance types and no reconfiguration rules reveals the general complexity of cdo analysis.
when assuming up to three vm images that contain combinations of the three services and that up to two vms can be started from a vm image these restrictive settings already yield cdo candidates.
without using potent heuristics all cdos would have to be simulated for reliably finding competitive solutions.513iii.
i nput models in this section we briefly describe the four input models that have to be provided to cdoxplorer so it can find wellsuited cloud deployment models and reconfiguration rules.
we provide tool support for creating these models.
the architectural model status quo deployment model workload profile andcloud profile are described in the following.
anarchitectural model can be automatically extracted by cloudmig xpress from an existing system s source code.
currently we support java c and python by incorporating among others the reverse engineering tool modisco .
cloudmig xpress generates architectural models that conform to the iso iec standard knowledge discovery metamodel kdm that was developed by the object management group omg .
with kdm several aspects of software systems can be modeled in a language independent way for example the runtime platforms and source code elements.
to describe the current deployment a status quo deployment model is designed with the integrated editor.
here kdm code elements can be assigned to status quo nodes.
to measure and specify the performance capabilities of these computing nodes we introduced a benchmark that measures the mega integer plus instructions per second mipips .
the computing power must be specified to enable cdosim to interpret a workload profile that describes service calls and response times and can be imported from monitoring log files with historical usage data.
currently we support kieker log files but additional monitoring log formats can easily be incorporated via plug ins.
if no real monitoring data is present cloudmig xpress also allows for the definition of synthetic workload profiles.
for specifying cloud environments socalled cloud profiles are used that e.g.
describe a vm instance types performance capabilities.
mipips can also be measured by executing the mentioned benchmark for each vm instance type of a cloud environment.
we plan to develop and integrate a public repository such that cloud profiles can be exchanged.
iv.
o utput models this section explains the result models that are included in a cdo as delivered by cdoxplorer.
the cdos specify a cloud deployment model and a set of reconfiguration rule models.
in iaas based cloud environments resources can be dynamically acquired and released by executing reconfiguration actions to counteract under and over provisioning and to ensure the compliance with specified slas.
two reconfiguration actions together define one of the scaling types vertical scaling or horizontal scaling .
considering vertical scaling the reconfiguration actions scale up andscale down are available.
scaling up adds more resources to a vm e.g.
a further cpu or more memory whereas scaling down removes resources.
horizontal scaling employs vms that use the same vm instance type.
vm instances are added scale out or shut down scale in .
we now describe the basic structure of cdos that is shown in figure .
a cloud deployment option refers to a single cloud environment that is derived from a cloud profile and contains so called node configuration s. anode configuration !
!
.
.
fig.
basic structure of cdos.
describes specifics of a vm instance.
for example an included service composition container refers to the service s that are deployed on this vm.
to link service s with the architectural input model they reference parts of the previously extracted kdm elements.
furthermore an initial start config specifies the vm instance type that should be used for a vm and also the number of vm instances that have to be started initially with this configuration.
moreover a node configuration may contain a grow rule together with a shrink rule .
they represent basic parts of a reconfiguration rule and from a high level view determine how and when computing power is added grow rule or removed shrink rule .
theses rules also specify a minimum number of vms that have to be present and refer to a grow action orshrink action that define the reconfiguration actions that are used for scaling.
a combination of two actions has to comply with the previously explained scaling types.
when applying vertical scaling the mipipsmultiple attribute ofgrow rule s and shrink rule s becomes relevant.
it implicitly specifies the vm instance type of the newly started vm which is given by multiplying the mipips value of the current vm with mipipsmultiple and rounding to the nearest mipips value of any the intended vm instance type.
a condition constitutes a trigger for executing the reconfiguration action with the help of a cpu utilization threshold and a time period.
for example concerning a scale out action an additional vm could be started when the cpu utilization is above for at least minutes.
the scope element would then define if the refers to the specific vm or to the average of all vms that were started from the corresponding node configuration .
v. o ursimulation based genetic algorithm this section details our simulation based genetic algorithm cdoxplorer.
first section v a describes its basic design.
then section v b formalizes the optimization problem that is tackled by cdoxplorer.
sections v c and v d detail the crossover and mutation operator of cdoxplorer respectively.
a. basic design the central purpose of the genetic algorithm cdoxplorer is to efficiently find well suited cdos concerning a set of514 !
!
!
fig.
compound chromosome overview.
gray boxes chromosomes white boxes genes listed in table i .
?
in the boxes upper left corner indicate that the elements occur exactly once at least once and at most once respectively.
arbitrary iaas based cloud environments.
in general genetic algorithms mimic evolutionary processes that describe the advancement of populations over several generations.
evolutionary concepts such as the survival of the fittest and inheritance of properties that turn out to be advantageous are included and utilized as optimization techniques.
genetic algorithms are usually used in the context of multi objective optimization problems.
with cdoxplorer we consider the objectives response times costs and sla violations of a cdo.
as there usually exists no single global optimum genetic algorithms aim to iteratively approximate the pareto optimal set also referred to as pareto optimum .
this pareto optimal set is a subset of all individuals that includes all pareto optimal individuals i.e.
individuals for which the improvement of one objective e.g.
lower costs would inevitably lead to a deterioration of another objective e.g.
higher response times .
as a consequence the individuals contained in a pareto optimum constitute trade off solutions that have to be inspected manually.
in general individuals are compared with so called fitness functions.
after many generations the fittest individuals become dominant.
the reproduction of each generation includes the following four basic steps s1 s4 s1 select parents s2 recombine parents crossover s3 mutate offspring s4 evaluate offspring s fitness the first step s1 selects individuals for reproduction.
for cdoxplorer s1 is based on the selection operation of the nsga ii algorithm for selecting appropriate pairs of parents and ensuring the diversity of solutions.
we apply two tournament rounds for choosing among candidates.
simply put an individual has to be fitter than at least two others.
cdoxplorer produces two children from two parents via executing a custom crossover s2 and mutation operator s3 that are detailed in the sections v c and v d respectively.
as mentioned before cdosim is used for evaluating the individuals in the fourth step s4.
in this step the values of the objectives that have to be optimized are obtained by simulating cdos.
because the simulations are very time consuming we had to limit the population size and configured the basic parameters of cdoxplorer as follows.
our populations contain individuals population size .
individuals are selected from each generation for reproduction number of cdo3cdo1 cdo2 se ce it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se se8 .
.
.
.
se ce it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se se it ni7 .
.
.
it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se ce it ni se se7 .
.
.
.
45fig.
cdo examples encoded as genotypes.
parents and each generation spawns children number of children .
furthermore cdoxplorer produces generations per default.
genetic algorithms also use biological analogies for representing the individuals of a population.
their basic elements are specified by genes .
considering the classes in figure the id of a service represents a single gene for instance.
all genes together constitute the so called genome that contains the complete genetic information of all possible cdos.
genes can be grouped in larger structures that are called chromosomes .
figure illustrates the basic chromosomes and genes that are processed by cdoxplorer.
the chromosomes correspond to the class structure of figure and map to one or more genes that together form a gene sequence.
such a single gene sequence encodes a specific cdo and is called a genotype .
the node configuration chromosome constitutes a container for further chromosomes that correspond to classes shown in figure .
as there can exist one or more node configurations each having zero or one pair of a grow rule andshrink rule chromosome the genotypes exhibit variable lengths.
the crossover point s in figure are detailed in section v c. the abbreviations and range of values that are used for the single genes are listed in table i. these genes correspond to the attributes of classes from figure .
we limited their values to a narrow range and discrete spaces for avoiding a further growth of the search space.
figure presents three examples of cdos that are encoded as genotypes.
cdo1 contains two node configurations from which only the second exhibits assigned grow and shrink rules as can be seen by taking into account the general structure of genotypes in figure .
hence the cloud environment amazon ec2 is encoded by the number in this example gene ce and the first node configuration comprises only the genes .
the deployed service can be identified by the first gene se.
the second node configuration that includes a reconfiguration rule is represented by the genes se s5 .
the further example cdo2 also includes two node configurations and uses amazon ec2 whereas cdo3 shows a genotype using the cloud environment microsoft windows azure and only one node configuration.
we will refer to these genotypes later.
b. problem statement after introducing the basic structure of our genetic algorithm we can describe the multi objective optimization problem that is tackled by cdoxplorer as follows.
let be the set of all feasible cdos feasibility is explained below for a given set of iaas based cloud environments and an architectural model status quo deployment model and workload profile of a software system.
the goal is to find a cdo x2 that minimizes the values of the three objective functions costs x rt x andsla x that determine the costs average response515table i design of the used genes.
gene range description chromosome cen cloud environment id cloud env.
sen service id service comp.
itn vm instance type id initial start c. nin nr.
of vm instances to start initially initial start c. ga grow action scale up scale out grow rule g1n minimum nr.
of vm instances grow rule g2 .
.
mipips multiple in steps of .
grow rule g3 condition scope single vm all vms grow rule g4 .
.
condition median utilization in steps of .
grow rule g5 condition time period in steps of minutes grow rule sa shrink action scale down scale in shrink rule s1n minimum nr.
of vm instances shrink rule s2 .
.
mipips multiple in steps of .
shrink rule s3 condition scope single vm all vms shrink rule s4 .
.
condition median utilization in steps of .
shrink rule s5 condition time period in steps of minutes shrink rule time and number of sla violations of x respectively.
the costs refer to the total amount of monetary units owed to a cloud provider because of utilizing provided services.
the response times refer to the average response times of the methods that are included in a workload profile.
lastly the sla violations indicate the number of method calls with response times that exceed a given threshold.
we denote the set of all node configurations in xasnand the set of all services inxass.xis feasible if it complies to the structure of cdos see figure complies to the value ranges defined in table i and complies to the constraints that are described below.
we will use the following notation where ydenotes a gene or chromosome and zdenotes a chromosome or cdo.
furthermore grnames a grow rule and sra shrink rule.
y z yis contained in z y z number of yinz tc set of vm instance types of cloud environment c xhas to comply with the following constraints .
8s2s x2 s x 8s2s n2n s n 8n2n 9s2s s n 8it x ce x x2 it2tce 8n2n gr n sr n 8gr n sr n n2n gr ga sa sr 8gr n sr n n2n gr g4 s4 sr constraint describes that each service has to be present at least once in some node configuration of an individual.
furthermore we do not allow duplicated services in a single node configuration constraint .
the constraint states that at least one service has to be present in each node configuration.
a specific vm instance type gene it also has to conform with a stated cloud environment gene ce see constraint .
thus vm instance types of amazon ec2 cannot be used in conjunction with microsoft windows azure for instance.
constraint phrases the following limitation if a grow rule exists in a node configuration a shrink rule also has to be present in this node configuration and vice versa.
considering grow rules and shrink rules the grow actions and shrink actions have to match constraint i.e.
a scale out rule has to be accompanied by a scale in rule and a scale up cdo2 se ce it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se se it ni .
.
.
cp2cp2 parents offspring cdoa cdobcdo1cp2 cp2 se ce it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se se it ni .
.
.
it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se ce it ni se se7 .
.
.
.
it ni ga g1 g2 g3 g5 g4 s1 s2 s3 s5 s4 sa se ce it ni se se7 .
.
.
.
4fig.
crossover operator example.
rule has to be associated with a scale down rule.
the cpu utilization thresholds of grow rules and shrink rules indicate trigger points when to start or shutdown a vm instance.
here the cpu utilization threshold of a grow rule has to exceed the cpu utilization threshold of a shrink rule constraint .
c. crossover operator the reproduction procedure involves the application of the crossover operator for producing two children from two parent individuals by mixing their genetic information.
this technique follows the biological analogy for passing properties of the parents to their offspring.
as the simulation of cdos is very expensive we designed the crossover operator to produce only feasible individuals see section v b .
hence we restricted the mixing to dedicated positions in the genotype called crossover points .
we defined the four crossover points cp1 cp4 that are shown in figure .
they are selected by chance are aligned to the chromosomes boundaries and specify corresponding gene sequences that can be swapped.
figure shows an example for applying the crossover operator with the help of the previously introduced cdos of figure .
the example considers cdo1 andcdo2 .
both cdos include two node configurations.
as cp2 was selected both initial start configurations of cdo1 andcdo2 are swapped.
d. mutation operator after two parent individuals have initially produced two children with the help of the crossover operator the mutation operator is applied to each child.
in general genetic algorithms randomly mutate single genes or gene sequences.
this imitates sudden leaps and modifications to the global gene pool that occasionally appear during the evolution process.
considering the influence on the overall optimization procedure the mutation operator fosters retaining the diversity of the individuals and helps to avoid convergence to a local optimum.
just as the crossover operator the mutation operator is aligned to the chromosome boundaries that can be seen in figure .
as a mutation also has to maintain the inner structure of a chromosome we divided the mutation operator in five sub operators that are described in the following.
m ce mutates the gene ce i.e.
a different cloud environment is used.
here the it gene of each node configuration has to be modified as well as the formerly used vm instance types are not available for the new cloud environment.
m nn mutates the number of node configurations and relocates the services.
when a node configuration is added 516a service gene se is moved from another node configuration to the new one.
when a node configuration is removed all services are relocated to other node configurations.
m is mutates the initial start configuration of a single node configuration i.e.
another vm instance type gene it is selected or the number of vms that are initially started for this node configuration gene ni is increased or decreased.
m sc mutates the service composition of a single node configuration.
a service gene se can be added or removed.
m rr mutates a reconfiguration rule i.e.
at least one of the genes ga g1 g5 sa s1 s5 is modified.
when altering a grow rule changes may also be necessary for the shrink rule to satisfy the constraints and vice versa.
vi.
e xperimental evaluation to evaluate our simulation based genetic algorithm cdoxplorer we implemented it as a component of our open source tool cloudmig xpress.
we let cdoxplorer create cdo candidates on the basis of three well known cloud environments and investigated the following research questions rq1 feasibility does cdoxplorer reliably provide wellsuited results?
rq2 competitiveness are cdoxplorer s results at least on a par with those from other state of the art search methods?
rq3 scalability is cdoxplorer applicable for both single and multi cloud environment scenarios?
cdoxplorer utilizes our simulator cdosim.
please note that the following evaluation covers only cdoxplorer.
for an evaluation of cdosim that demonstrates its applicability and precision we refer to our previous work .
we begin with explaining the methodology that we used to tackle the research questions in section vi a. the experimental setting is then described in section vi b. the research questions rq1 rq3 are detailed in sections vi c to vi e respectively before the threats to validity are discussed in section vi f. a. methodology we used the opt4j framework for meta heuristic optimization as a basis for our implementation of cdoxplorer and also applied the nsga ii algorithm for the selection of parent individuals see section v a .
as nsga ii utilizes so called fronts of non dominated individuals a pareto optimum is also called pareto optimal front in this context.
there exist several standard performance metrics that basically measure the level of approximation towards the pareto optimal front.
as all existing performance metrics exhibit different strengths and weaknesses and therefore are often used in combination we decided against using a single metric.
instead we applied the two popular metrics inverted generational distance igd and hypervolume indicator hv that are illustrated in figure .
usually the metrics specify the approximation towards the true pareto optimal front pftrue if this is known.
in our case pftrue can only be obtained by simulating all feasible cdos.
as this is not possible in a reasonable amount of time we instead use the !
!
!
!
!
fig.
the metrics inverted generational distance andhypervolume indicator colored blue are used for evaluation.
best pareto optimal front that is formed by the combination of the overall simulation results as a proxy and term it opfbest.
another pareto optimal front depicted in figure ispfknown .
it is the result of each execution of cdoxplorer whereas each execution includes cdosim simulations.
the cube s axes in figure indicate the three objectives that are optimized by our algorithm costs response times and sla violations.
starting from the individuals in opfbest the nearest individuals in pfknown in terms of the euclidean distance are used for calculating the igd metric.
this metric directly measures the distance from opfbest topfknown .
hence smaller values indicate a better approximation.
in contrast the values produced by the hv metric become bigger as the approximations become better.
hv measures the volume in hyper dimensional space that is covered bypfknown regarding a reference point r2rdin ddimensional space.
as we consider three objectives and configure hv accordingly the mentioned volume corresponds to the volume in three dimensional space that is colored blue in the illustration of figure .
hv therefore implicitly rates the distance from opfbest topfknown as is also done by igd.
additionally both metrics assess the spread of pfknown that constitutes another important quality characteristic.
when covering larger parts of the search space there exist less unexplored areas that could potentially contain better solutions.
to judge the measurement results of these metrics for cdoxplorer we used several state of the art search and optimization techniques for comparison.
however as the objective values cannot be obtained by solving functions analytically some popular classes of approaches such as gradient based optimization methods cannot be used.
though direct search methods are suited for simulation based optimization .
therefore we use the simple yet effective stochastic algorithms simple random sampling si rs andsystematic random sampling sy rs as two out of the three algorithms used for comparison with cdoxplorer.
the algorithm sirs creates cdo individuals by chance and serves as a baseline algorithm.
sy rs also produces individuals by chance but works in a different way.
it can iterate over allffeasible cdo candidates and randomly selects the c th cdo from the floor f interval at the beginning of5171 p op rand m is m nnm ce m sc m rrphase operator op fig.
simulated annealing reuses mutation sub operators.
a cdoxplorer run where floor x roundsx2r down to the next natural number.
the next cdo is then given by the c floor f th candidate and so forth.
the third algorithm used for comparison purposes is just as a genetic algorithm a nature inspired meta heuristic termed simulated annealing si an .
basically it mimics the temperature cooling process of materials.
to emulate such a cooling process in our problem context we reuse the mutation sub operators introduced in section v d as illustrated in figure .
the temperature is adapted according to five phases.
the phases utilize mutation sub operators with specific probabilities to reduce disruptive modifications over time.
cdoxplorer uses generations with populations of individuals.
hence cdoxplorer applies simulations in a single run.
the runs for cdoxplorer si rs sy rs and si an were each repeated times for single as well as for multi cloud scenarios.
thus we conducted optimization runs with simulations in total.
we therefore obtained simulations for the single and multi cloud scenario that were used to approximate two pareto optimal fronts that were set to opfbest for evaluating the respective scenarios.
the first of these pareto optimal fronts is shown in figure .
b. experimental setting for incorporating public clouds we measured the mipips values see section iii for vm instance types of amazon ec2 and five of microsoft windows azure by using locations in europe for both.
five vm instance types of our private eucalyptus cloud were also benchmarked.
for analyzing single and multi cloud scenarios we used the resulting cloud profiles in the two corresponding scenarios scsandscmas follows.
scs amazon ec2 scm amazon ec2 microsoft windows azure eucalyptus we extracted a kdm model from the open source erp system apache ofbiz .
.2then we deployed this system on a machine of our local cluster and described the deployment in a status quo deployment model.
customers that browse the webstore and put articles in their shopping carts were emulated by producing workload according to a typical day night usage pattern.
more customers visited the webstore in the evening instead in the morning hours and the traffic largely reduced at night.
the measured response times and the mipips value of our hardware were then used in a workload profile for generating cdos and driving the cdosim simulations.
the sla violation threshold was set to 2s.
for eucalyptus we defined a synthetic cost model where the prices for vms follow the capabilities of our vm instance types.
cost response times sla violations response times cost sla violations fig.
one of two best known pareto fronts opf best.
c. rq1 feasibility this research question evaluates the feasibility and applicability of cdoxplorer.
as a basic requirement cdoxplorer has to reliably provide well suited results.
the evaluation of this criteria is of particular importance because of the following two reasons.
the simulations used for our simulationbased algorithm are computationally expensive.
hence we strictly limited the number of generations and population size.
this could affect cdoxplorer s capability for producing wellsuited approximations of pareto optimal fronts.
the nondeterminism used in cdoxplorer for example regarding the selection of crossover points could possibly lead to considerable variations among optimization runs.
we approach rq1 by computing two further metrics m1andm2.
m1analyzes the quality of the results produced by cdoxplorer.
we were interested in the degree the hypervolumes of opfbest can be approximated by cdoxplorer for scsand scm.
forscsandscm the hv of opfbest was .
and .
respectively whereas cdoxplorer achieved .
and .
.
thus the actual quality of the found pareto optima were sufficiently well suited for our needs as these results turn into .
and .
approximation of opfbest for the single and multi cloud scenario scsandscm respectively.
the second metric m2calculates the coefficient of variation cv that gives information about the relative dispersion regarding a sample s mean value .
as our performance metrics igd and hv deliver results in artificial and incomparable units we convert the standard deviation forscsandscm in combination with igd and hv to relative and therefore comparable values.
these are denoted as cvsfor our single andcvmfor our multi cloud scenario.
in general cv is computed bycv .
the igd results for scsandscmvary in a band of .
and .
around and of .
and .
around for hv respectively.
hence igd results in the single cloud scenario are up to .
lower or higher than for instance.
thus the results indicate that cdoxplorer can reliably find well suited solutions.
however the value for igd increases for a higher number of cloud profiles.
in our future work we will investigate if this constitutes an actual trend.
d. rq2 competitiveness this research question addresses the competitiveness with other state of the art search approaches by comparing cdoxplorer with si rs sy rs and si an.
table ii lists the results for the metrics igd and hv for the single cloud scenario scs.
table iii shows these results for scm.
the tables list the518table ii search over a single cloud profile scs .
search method metric cdoxplorer si rs sy rs si an i.g.
distancemean .70e .67e .11e .28e sd .10e .13e .61e .85e median .72e .65e .21e .20e min best .16e .34e .40e .76e max worst .03e .07e .83e .95e hypervolumemean .48e .41e .41e .44e sd .08e .96e .89e .09e median .48e .40e .41e .44e min worst .44e .36e .35e .40e max best .54e .46e .46e .48e table iii search over three cloud profiles scm .
search method metric cdoxplorer si rs sy rs si an i.g.
distancemean .08e .18e .03e .37e sd .88e .78e .41e .50e median .12e .17e .90e .38e min best .13e .58e .23e .52e max worst .16e .76e .88e .67e hypervolumemean .65e .20e .18e .63e sd .82e .95e .43e .68e median .65e .20e .17e .63e min worst .61e .16e .13e .61e max best .70e .25e .25e .68e mean standard deviation median min and max values of complete repeated optimization runs for each combination of metric scenario and search method.
bigger values are better for hv but worse for igd.
all best mean and median values are set in bold.
as can be seen cdoxplorer outperforms all other search methods in scsand also inscm.
we use the mann whitney non parametric test to evaluate statistical significance.
the null hypothesis h0states that the results from cdoxplorer cannot be distinguished from those of si rs sy rs and si an.
using the mann whitney test and a bonferroni correction for multiple comparisons h0is rejected with significance level .
for all combinations of metrics with scsandscm.
thus we can quantify the degree cdoxplorer performs better and compare the medians of si rs sy rs and si an to those of cdoxplorer.
figure shows the corresponding fractions with regard to the medians e.g.
for the scmscenario the median for igd is over lower than that of sy rs.
e. rq3 scalability this research question analyzes cdoxplorer s scalability.
that means if cdoxplorer can retain its performance when more cloud profiles are considered for providing cdo candidates or if a potential performance degradation is still acceptable.
this is of particular interest as the number of generations and the population size remain stable but the search space size grows linearly with each new cloud profile.
as described in section vi c the value for the coefficient of variation with igd and the value for the igd metric itself grows when cdoxplorer processes scm.
however the hv metric value and the coefficient of variation even become better when more cloud profiles are used.
furthermore it fig.
cdoxplorer advantage relative to other approaches.
is useful to compare these observations with those from the other search methods.
cdoxplorer provides in all cases the best results.
considering si rs and sy rs their values for the igd metric grow even more and nearly doubled when usingscm.
si an also suffers from a deterioration when transitioning from the scsto thescmscenario.
though the igd values increase less.
the values for hv show a similar development.
cdoxplorer is better than all other search methods and the scalability is better compared with si rs and sy rs but si an exhibits a slightly higher improvement.
in summary we conclude that cdoxplorer scales better than si rs and sy rs but slightly worse than si an.
although cdoxplorer performs better in all cases in terms of the absolute median values we will conduct additional experiments in our future work to further investigate scalability.
f .
threats to validity there are several issues that form a threat to validity.
first we only consider three cloud profiles as their construction is not trivial and the vm instance types of additional cloud providers need to be benchmarked.
this involves potential expenses.
however as indicated by the results of section vi e scalability is a worthwhile area for further analyses.
restrictions were also made concerning the workload profile and the studied enterprise software.
in each case just one sample was used.
this is due to the fact that further optimization runs imply even more time consuming simulations.
therefore we strived after using representative instances.
day night usage patterns with higher and lower demand are frequently found for enterprise systems.
furthermore apache ofbiz is very popular and widespread.
however we plan to address the stated limitations in our future work.
there could also exist other optimization methods that provide better results than si rs sy rs and si an we used for evaluation.
though tailoring optimization methods for our context is time consuming and not straight forward.
quite similarly there could exist better ways to tailor si an instead of reusing the mutation sub operators.
especially in the light that si an partially comes near to cdoxplorer s results.
further threats to validity arise from the synthetic cost model for our private eucalyptus cloud and that slas are519usually defined in terms of percentile ranges when considering response times.
however aligning the vm prices to the capabilities of the vm instance types is omnipresent with respect to public cloud environments.
altering the absolute threshold into percentiles for defining the sla objective can be easily done and will be addressed in the future work.
vii.
r elated work this section discusses related work concerning the optimization of deployment architectures and reconfiguration rules.
here solely approaches that tackle related problems from a user perspective are considered.
cloud users want to deploy software to the cloud under given constraints.
especially a cloud environment s internal structure is transparent to cloud users.
as there exists a large body of work in this regard we limit the description to selected approaches.
deployment optimization in non cloud scenarios.
for improving the deployment architecture of distributed systems regarding arbitrary qos properties malek et al.
propose an extensible framework and visual modeling and analysis environment.
the framework incorporates continuous system monitoring and changing the deployment architecture at runtime by actually executing redeployment operations.
a further mode allows for offline simulation.
arbitrary deployment constraints and qos properties can be formally defined by manually specifying utility functions.
the approach provides four predefined deployment improvement algorithms among those is a genetic algorithm.
the utility functions are used as fitness functions whereas cdoxplorer uses simulation runs to obtain fitness values.
furthermore malek et al.
do not consider the integration of reverse engineered code models and monitored workload as is supported by our approach.
martens et al.
focus on component based systems and at finding optimized software and deployment architectures concerning performance reliability and costs.
similar to our approach a genetic algorithm is used and simulations are partially employed for assessing candidate solutions.
their software peropteryx provides tool support and explores four degrees of freedom e.g.
processor speeds.
no dynamic resource scaling is supported but further degrees of freedom can be added.
in contrast cdoxplorer currently explores fixed degrees of freedom the number of node configurations and genes and optimizes runtime reconfiguration rules.
a hybrid approach that considers the consolidation of multitier applications to virtual machines is presented by jung et al.
.
applications are modeled and optimized offline to generate well suited system configurations.
these are transformed to adaptation policies that can be consumed online by rule engines.
compared with cdoxplorer the approach by jung et al.
only allows to define a single resource type and homogeneous resource instances instead of considering distinct vm instance types that can also be used in parallel.
zhang et al.
propose a qos aware approach for finding the optimal number of machines for deploying services in the context of service oriented architectures soas .
a greedy algorithm is used that maximizes the throughput.
unlike in our approach dynamic resource scaling is not supported.non evolutionary cloud deployment optimization.
as with our approach cloudmig wu et al.
consider resource usage optimization for saas providers that build upon leased vms.
wu et al.
assume that a maximum service utilization is defined per customer in sla agreements.
sla violations and infrastructure costs are minimized by two custom made algorithms that are evaluated with the tool cloudsim.
our simulator cdosim also builds on cloudsim.
in contrast to cdoxplorer wu et al.
do not consider distributed applications runtime reconfiguration and arbitrary workload.
trummer et al.
contribute an algorithm for computing an application s cost optimal deployment architecture for iaasbased clouds.
this single objective optimization is described as a constraint optimization problem and is tackled with an existing constraint solver.
as opposed to this we use multiobjective optimization and support dynamic resource scaling.
nevertheless the application templates used by trummer et al.
serve the same purpose as our status quo deployment models.
san aniceto et al.
also use a custom made singleobjective optimization algorithm for reducing the costs of leased vms.
besides on demand instances that can be started and stopped at any time it also considers reserved instances.
those are frequently offered for a single payment per time period.
in turn a discount is given in the hour rates.
the algorithm aims at finding the best suited combination of ondemand and reserved instances based on historical workload data.
however it does not support dynamic reconfiguration.
dynamic scaling is in contrast supported by the approach of mao et al.
.
here integer programming problems are solved for reducing costs or maximizing the performance of scientific computing jobs.
scaling policies are derived at runtime by learning from previous job executions.
compared with our approach we target enterprise software and use simulations for assessing different cdo candidates before actually deploying an application to a specific cloud environment.
evolutionary cloud deployment optimization.
most related work that employs evolutionary optimization techniques in cloud deployment scenarios takes a cloud provider perspective or requires corresponding knowledge regarding the internal structure of a cloud environment e.g.
.
in contrast wada et al.
follow in common with cloudmig a cloud user perspective and contribute the genetic algorithm e3 r that explores deployment configurations for optimizing services qos attributes.
e3 r can also reduce redundant qos objectives and estimate the performance of configurations using queueing theory and historic mean arrival rates.
however e3 r does not support varying workload and dynamic resource scaling and it regards services as black boxes whereas our approach simulates reverse engineered and transformed architectural models and monitored workload.
a particle swarm optimization based heuristic is introduced by pandey et al.
.
the single objective optimization algorithm maps scientific tasks to cloud resources for minimizing costs.
in comparison we target optimal cdos for enterprise software formulate the search as a multi objective optimization problem and facilitate dynamic resource scaling.520viii.
c onclusion we presented our simulation based genetic algorithm cdoxplorer that optimizes cloud deployment options cdos for supporting the migration of software to the cloud.
a cdo comprises a deployment architecture and runtime reconfiguration rules that can start further vm instances when the overall utilization exceeds a given threshold for instance.
finding near optimal solutions is approached by using techniques of the search based software engineering field.
cdos become optimized in terms of response times costs and number of sla violations.
for example the best suited cloud provider and vm instance types for an existing software system and particular usage patterns have to be found.
cdoxplorer uses our tool cdosim to simulate cdos.
a simulation result represents a fitness value of our genetic algorithm.
the popular public clouds amazon ec2 and microsoft windows azure as well as our private eucalyptus cloud were used for extensive experiments.
we compared cdoxplorer with three state of the art search and optimization methods.
our evaluation showed that cdoxplorer can find cdos that are up to better than those of the other approaches.
our experiment code and data and an implementation of cdoxplorer are available online as open source software.