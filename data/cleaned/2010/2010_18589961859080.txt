solving string constraints lazily pieter hooimeijer and westley weimer university of virginia pieter weimer cs.virginia.edu abstract decision procedures have long been a fixture in program analysis and reasoning about string constraints is a key el ement in many program analyses and testing frameworks.
recent work on string analysis has focused on providing decision procedures that model string operations.
separat ing string analysis from its client applications has import ant and familiar benefits it enables the independent improvement of string analysis tools and it saves client effort.
we present a constraint solving algorithm for equations over string variables.
we focus on scalability with regard t o the size of the input constraints.
our algorithm performs an explicit search for a satisfying assignment the search spa ce is constructed lazily based on an automata representation of the constraints.
we evaluate our approach by comparing its performance with that of existing string decision proce dures.
our prototype is on average several orders of magnitude faster than the fastest existing implementation.
categories and subject descriptors d. .
software program verification validation d. .
software program verification model checking f. .
specifying and verifying and reasoning about programs mechanical verification general terms algorithms languages theory verification keywords regular language decision procedure scalability this research was supported in part by national science foun dation grants ccf ccf cns cns and air force office of scientific research grant fa9550 as well as gifts from microsoft research.
the information pr esented here does not necessarily reflect the position or the policy o f the government and no official endorsement should be inferred.
permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
ase september antwerp belgium.
copyright acm ... .
.
.
introduction reasoning about string variables is a key aspect in many areas of program analysis and automated testing .
program analyses and transformations that deal with string manipulating programs such as test input generation for legacy systems web applicati on bug finding and program repair invariably requir e a model of string manipulating functions.
traditionally both static and dynamic analyses have relie d on their own built in models to reason about constraints on string variables just as early analyses relied on built in conservative reasoning about aliasing.
the current situation is suboptimal for two reasons first it forces researchers to r einvent the wheel for each new tool and second it inhibits the independent improvement of algorithms for reasoning about strings.
external constraint solving tools have long been available for other domains such as satisfiability modulo theories smt and boolean satisfiability sat .
recent work in string analysis has focused on providing similar external decision procedures for string constrain ts .
thus far this work has focused on adding features such as support for symbolic integer constraints support for bounded context free grammars and embedding into an existing smt solver .
we argue that the existing approaches leave significant room for improvement with regard to scalability.
we propose a novel decision procedure that supports the efficient lazy processing of string constraints without re quiring a priori length bounds.
our approach is based on the insight that existing solvers do more work than is strict ly necessary because they eagerly encode the search space of possible solutions before searching it.
for example the ha mpi tool performs an eager bitvector encoding of all positional shifts for each regular expression in the given constraint system.
we observe that much of that encoding work is unnecessary if the goal is to find a single string assignment as quickly as possible.
our approach uses an automaton based representation of string constraint systems.
in contrast with previous autom atonbased approaches we separate the description of the search space from its instantiation.
for ex ample when intersecting two automata using the cross prod uct construction we generate only those parts of the inter section automaton needed to find a single string.
our search space consists of sets of nodes in lazily constructed finite automata corresponding to string variables and constrained b y string operations.
constraint stringexpr regexpr inclusion stringexpr regexpr non inclusion stringexpr var string variable stringexpr var concat regexpr constval string literal regexpr regexpr language union regexpr regexpr language concat regexpr kleene star figure string inclusion constraints for regular sets.
a constraint system is a set of constraints over a shared set of string variables a satisfying assignment maps each string variable to a value so that all constraints are simultaneously satisfied.
constval represents a string literal var represents an element in a finite set of shared string variables.
the primary contributions of this paper are a novel decision procedure that supports the efficient and lazy analysis of string constraints.
we treat string constraint solving as an explicit search problem and separate the description of the search space from the search strategy used to traverse it.
a comprehensive performance comparison between our prototype tool and existing implementations.
we compare against cfg analyzer dprle and hampi .
we use several sets of established benchmarks .
we find that our prototype is several orders of magnitude faster for the majority of benchmark inputs for all other inputs our performance is at worst competitive with existing methods.
the structure of this paper is as follows.
in section we provide a high level overview of our algorithm focusing on the eager construction of a graph based representation o f the search space section .
followed by the lazy trave rsal of the search space section .
.
we provide a worked example of the algorithm in section .
and an informal correctness argument in section .
.
section provides perfor mance results focusing on regular language difference se ction .
regular intersection for large strings section .
and bounded context free intersection section .
.
section briefly discusses related work and we conclude in section .
.
approach in the following subsections we present our decision procedure for string constraints.
our goal is to provide expressiveness similar to that of existing tools such as dprle and hampi while exhibiting significantly improved average case performance.
in section .
we formally define the string constraints of interest.
section .
outline s our high level graph representation of problem instances.
we then provide an algorithm for finding satisfying assignments in section .
and give a brief illustrative example.
.
definitions in this work we focus on a set of string constraints similar to those presented by kie zun et al.
but without required a priori bounds on string variable length.
in earlier work we demonstrate that this type of string constrain t1 follow graph i constraint system letg directed graph empty letm constraint path empty foreach ci constraint ido let v1 .
.
.
vn r ci forj .
.
.
n 1do g add edge g node vj node vj m return g m figure follow graph generation.
given a constraint system i we output follow graph gand mapping m defined in the text .
gand mcapture the high level structure of the search space of assignments.
the node function returns a distinct vertex for each variable.
can model a variety of common programming language constructs.
the set of well formed string constraints is defined by the grammar in figure .
a constraint system sis a set of constraints of the form s c1 .
.
.
cn where each ci sis derivable from constraint in figure .
var denotes a finite set of string variables v1 .
.
.
vm .constval denotes the set of string literals.
for example v abdenotes that variable vmust have the constant value abfor any satisfying assignment.
we describe inclusion and non inclusion constraints symmetrically when possible using to represent either relation i.e.
.
for a given constraint system sover variables v1 .
.
.
vm we write a for the assignment that maps values x1 .
.
.
xmto variables v1 .
.
.
vm respectively.
we define ato be the value of viunder assignment a for a stringexpr e a a a. for a regexpr r denotes the set of strings in the language l r following the usual interpretation of regular expressions.
when convenient we equate a regular expression literal likeab with its language.
we refer to the negation of a language using a bar e.g.
ab w w ab .
an assignment afor a system sover variables v1 .
.
.
vm issatisfying iff for each constraint ci e rin the system s it holds that a .
we call constraint system s satisfiable if there exists at least one satisfying assignment alternatively we will refer to such a system as a yes instance .
a system for which no satisfying assignment exists is unsatisfiable and a no instance .
a decision procedure for string constraints is an algorithm that given a constraint system s returns a satisfying assignment for siff one exists or unsatisfiable iff no satisfying assignment exists.
.
follow graph construction we now turn to the problem of efficiently finding satisfying assignments for string constraint systems.
we break thi s problem into two parts.
first in this subsection we develo p a method for eagerly constructing a high level description of the search space.
then in section .
we describe a lazy algorithm that uses this high level description to search t he space of satisfying assignments.
for a given constraint system i we define a follow graph g as follows for each string variable vi the graph has a single corresponding vertex node vi .
for each occurrence of .
.
.
vi vj.
.
.
in a constraint in i the graph has a directed edge from node vi tonode vj .
this edge encodes the fact that the satisfying assignment for vjmust immediately follow vi s. we also maintain a mapping mfrom individual constraints inito their corresponding path through the follow graph.
for each constraint ch vj r we map chto path .
for each constraint ciof the form vk .
.
.vm r we map ci to path .
figure provides high level pseudocode for constructing the follow graph for a given system.
the follow graph procedure takes a constraint system iand outputs a pair g m where gis the follow graph corresponding to i and mis the associated mapping from constraints in ito paths through g. for each constraint in i line we add edges for each adjacent pair of variables in the constraint lines and u pdate mwith the resulting path line .
for line we assume that singleton constraints of the form v1 rare matched as well this results in zero edges added lines and a singleton path line .
as an example consider the following constraint system and its associated follow graph c1 v1 a c2 v2 ab c3 v1 v2 ab d23 d22 d21 d20 d16 d17 d18 d19c1 d23 d22 d21 d20 d16 d17 d18 d19c2 d47 d46 d45 d44 d40 d41 d42 d43n1 d47 d47 d47 d46 d45 d44 d40 d41 d42 d43n2 d23 d22 d21 d20 d16 d17 d18 d19c3 d64 d65 d66 d67 we represent the graph gwith circular vertices.
the other vertices represent the domain of the mapping m. we assume ni node vi .
the first two constraints result in the mapping from c1to and c2to the third constraint adds the mapping from c3to .
when convenient we will use variables in place of their corresponding follow graph nodes.
.
lazy state space exploration given a follow graph g and a constraint to path mapping m our goal is to determine whether the associated constraint system has a satisfying assignment.
we treat thi s as a search problem the search space consists of possible mappings from variables to paths through finite automata nfas .
we find this variables to nfa paths mapping throug h a backtracking depth first search.
if the search is successf ul then we extract a satisfying assignment from the search result.
if we fail to find a mapping then it is guaranteed not to exist and we return unsatisfiable.
in the remainder of this subsection we will discuss the search algorithm we walk through a run of the algorithm in section .
.
the nfas used throughout the algorithm are generated directly from the regular expressions in the original constraint system our implementation uses an existing algorithm due to ilie et al.
.
for constraints of the form .
.
.
r we construct an nfa that corresponds to l r directly.
for constraints of the form .
.
.
r we eagerly construct an nfa that accepts l r .
we then use a lazy version of the powerset construction to determinize and negate that nfa e.g.
.
we assume without loss of generality tha t each nfa has a single final state.
datatype result unsat ofresult satofassignment result datatype status unknown ofstatus startsat ofnfastate status path ofnfapath status datatype pos constraint int datatype searchstate next variable states variable pos status datatype stepresult next ofsearchstate stepresult back ofstepresult done ofstepresult search followgraph g mapping m letq variable pos status start states m leto searchstate next nil states q lets searchstate stack while sis not empty do letocur searchstate top s letr stepresult visit state ocur g m match rwith next o push o s back pop s done return sat extract ocur end while return unsat visit state searchstate o followgraph g mapping m if v node g all paths o.states then return done ifo.next nilthen o.next pick advance o g m let success paths advance o g m if success then return back leto searchstate copy o o .next nil o .states paths foreach n variable succ o.next g do foreach p c i poss.t.
o .states path x o .states unknown do o .states startsat last x return next o figure lazy backtracking search algorithm for string constraints.
the search procedure performs an explicit search for satisfying assignments.
each occurrence of a variable in the constraint system is initially unconstrain ed unknown or constrained to an nfa start state startsat .
each call to visit state attempts to move one or more occurrences from unknown tostartsat or from startsat topath .
the goal is to reach a searchstate in which each occurrence is constrained to a concrete path through an nfa.
other procedures e.g.
start states extract and advance are described in the text.
.
.
the search algorithm for clarity we will distinguish between restrictions on variables imposed by the algorithm and constraints in the input constraint system.
our search starts by considering all var iables to be unrestricted.
we then iteratively pick one of the variables to restrict this typically imposes furthe r restrictions on other variables as well.
the order in which we apply restrictions to variables does not affect the eventua l outcome of the algorithm i.e.
satisfiable or unsatisfiable but it may affect how quickly we find the answer.
during the search if we find that we have over restricted one of the variables then we backtrack and attempt a different way to satisfy the same restrictions.
at the end of the search there are two possible scenarios at the end of a successful search each occurrence of a variable in the original constraint system will be mapped to an nfa path all paths for a distinct variable will have at least one string in common.
we return satisfiable and provide one string for each variable.
at the end of an unsuccessful search we have searched all possible nfa path assignments for at least one variable finding no internally consistent mapping for at least one of those variables.
there is no need to explore the rest of the state space since adding constraints cannot create new solutions.
we return unsatisfiable.
figure provides high level pseudocode for the search algorithm.
the main entry point is search lines which returns a result line .
an assignment line is a satisfying assignment that maps each variable to a string.
the search procedure performs a depth first traversal of a lazily constructed search tree the stack s line always holds the current path through the tree.
each vertex in the search tree represents a mapping from string variables to restrictions each edge represents the application of one or more additional restrictions relative to the source vertex.
each iteration of the main loop lines consists of a call to visit state .
the visit state procedure takes the current search state attempts to advance the search and returns a stepresult lines signaling success or failure.
ifvisit state returns next then we advance the search by pushing the provided search state onto the stack line .
ifvisit state returns back then we backtrack a single step by popping the current state from the stack line .
if visit state returns done then we extract a satisfying string assignment from the paths in current search state line .
finally if the algorithm is forced to backtrack beyond the initial search state we return unsat line .
.
.
manipulating the search state thesearchstate type lines captures the bookkeeping needed to perform the search.
the next element stores which string variable the algorithm will try to further restrict once set this will remain the same for potential sub sequent visits to the same search state.
the states element holds the restrictions for each variable for each occurrenc e of that variable in the constraint system.
for example in th e constraint system c1 v1 v1 r1 variable v1occurs at positions lines c1 and c1 .
thesearchstate maps each variable at each position to astatus lines which represents the current restrictions on that occurrence as follows .unknown line this status indicates that we do not know where the nfa path for this variable occurrence should start.
in the example the c1 occurrence of v1will initially map to unknown since its start state depends on the final state of the v1occurrence at c1 .
.startsat line this status indicates that we know at which nfa state we should start looking for an nfa path for this variable occurrence.
in the example the c1 occurrence of v1will initially map to startsat nfa c1 .s where nfa c1 .sdenotes the start state of the nfa for regular expression r1.
.path line this status indicates that we have restricted the occurrence to a specific path through the nfa for the associated constraint.
if a variable has multiple occurrences mapped to path status then those paths must agree i.e.
have at least one string in common .
note that these restrictions are increasingly specific.
eac h non backtracking step of the algorithm moves at least one variable occurrence from unknown tostartsat or from startsat topath .
conversely each backtracking step consists of at least one move in the direction path startsat unknown .
the majority of the pseudocode in figure deals with the manipulation of searchstate instances.
the start states call line generates the initial restrictions that start the search it is defined for each variable vfor each valid position c i as follows start states m braceleftbigg unknown ifi startsat nfa c .s ifi thevisit state procedure advances the search by generating new search states children in the search tree based on a given search state the parent .
on lines we check to see if all variable occurrences have a path restriction.
the corresponding nfa paths are required to agree by construction.
in other words the algorithm would never reach a search state with all path restrictions unless the path assignments were internally consistent.
we continue if there exis ts at least one non path restriction.
the call to pick advance determines which variable we will try to restrict in this visit and any subsequent visits to this search state.
this function determines the order in which we restrict the variables in the constraint system.
th e order is irrelevant for correctness as long as pick advance selects each variable frequently enough to guarantee termi nation of the search.
however for non cyclic parts of the follow graph it is generally beneficial to select predecess or nodes variables in the follow graph before their successo rs.
this is the case because visiting the predecessor can potentially change some of the successor s unknown restrictions tostartsat restrictions.
we leave a more detailed analysis of search heuristics for future work.
the remainder of visit state deals with tightening restrictions the call to advance line performs lazy nfa intersection on all of the occurrences of variable o.next 380to convert startsat restrictions to path restrictions or rule out that a valid path restriction exists given the initial restrictions .
if the call to advance succeeds then the search state generation code of lines uses the additional path restrictions if any for o.next to update o.next s successors in the follow graph if any succ v g returns the set of immediate successors of ving .
this step exclusively converts unknown restrictions to startsat restrictions.
the intuition here is that if v2follows v1 in some constraint then the first state for that occurrence of v2must match the last state for v1 last x line returns the last state in nfa path x. note that the first step the call to advance can potentially fail if o.next proves to be over restricted.
when this occurs we backtrack lines and and return to a previous state causing that state to be visited a second time.
these subsequent visits will lead to repeated call to advance on the same parameters.
we assume that advance keeps internal state to ensure that it exhaustively attempts all path restrictions.
.
.
finding nfa paths based on restrictions theadvance function called on line of figure performs all automaton intersection operations during the sea rch.
given some combination of unknown startsat andpath restrictions on the occurrences of a given variable the goal is to convert every startsat restriction to a path restriction while respecting all other restrictions .
this is necessary because the eventual goal is to find a single string assignment for each variable.
how we conduct the traversal for each variable depends on the restriction types for the variable s occurrences anunknown restriction indicates that for the given occurrence we do not know where the nfa path starts.
however we do know that a there should exist a valid agreeing path through this automaton starting at some start state and b if the occurrence is the last position in a constraint then the final state for the associated automaton must be reached.
we use this information only if no other path restrictions are present this is necessary to ensure that we generate strings up to the correct maximum length if we didn t involve all automata in the intersection we could end up generating only strings that are short .
alternatively we can avoid this step by imposing a length bound on variables.
astartsat restriction requires a path through a given nfa starting at the given state the path should agree with all other restrictions.
apath restriction requires that all other paths agree exactly with the current path.
we perform an explicit lazy search of the intersection cross product automaton.
this is equivalent to a simultaneous depth first traversal of the the various automata and paths the traversal terminates if we simultaneously reach all desired final states.
in addition we must guarantee that given the same searchstate repeated calls to advance yield all possible non repeating paths through the intersection automaton.
we accomplish this by storing the search stack fornfa states between calls if the stack is empty we know we have exhausted all possible paths given the current constraints.
informally the postcondition for advance is that anystartsat restriction is replaced with a path restriction and any output path restrictions agree on the concrete nfa path.
if advance signals failure then previous calls have exhausted all possible non repeating paths through the inter section automaton.
.
worked example consider our previous example c1 v1 a c2 v2 ab c3 v1 v2 ab d23 d22 d21 d20 d16 d17 d18 d19c1 d23 d22 d21 d20 d16 d17 d18 d19c2 d47 d46 d45 d44 d40 d41 d42 d43n1 d47 d47 d47 d46 d45 d44 d40 d41 d42 d43n2 d23 d22 d21 d20 d16 d17 d18 d19c3 d64 d65 d66 d67 the initial searchstate generated on lines of figure would look as follows next nil states v1 mapsto c1 mapsto startsat nfa c1 .s c3 mapsto startsat nfa c3 .s v2 mapsto c2 mapsto startsat nfa c2 .s c3 mapsto unknown the main search procedure now visits this searchstate .
the visit state procedure in turn calls pick advance line .
we assume o.next is set to v1 since it is first in a topological ordering of the follow graph.
the advance procedure is called to intersect the language for c1with the prefixes for the language of c3.
suppose the intersection unluckily results in a path matching a. this replaces the two startsat restrictions forv1withpath restrictions.
on line paths now equals c1 mapsto path c3 mapsto path on lines we create the next search state to visit.
because v2 succ v1 g and v2has an unknown restriction on the correct occurrence the final o looks as follows next nil states v1 mapsto c1 mapsto path c3 mapsto path v2 mapsto c2 mapsto startsat nfa c2 .s c3 mapsto startsat nfa c3 .q at this point visit state returns line and o is pushed onto the stack line .
on the next iteration pick advance selects v2 since it is the only variable with work remaining.
when we call advance we notice a problem c2requires that v2begin with a but we have already consumed the ainc3 using v1.
this means no nfa paths are feasible and we return back line .
insearch we pop ocuroff the stack line .
on the next loop iteration we revisit the initial search state.
since w e previously set o.next v1 we proceed immediately to the advance call without calling pick advance .
the advance procedure has only one path left to return the trivial path that matches the empty string .
at the end of visit state o now equals next nil states v1 mapsto c1 mapsto path c3 mapsto path v2 mapsto c2 mapsto startsat nfa c2 .s c3 mapsto startsat nfa c3 .s on the next iteration pick advance again selects v2.
a call toadvance yields agreeing paths from nfa c2 .stonfa c2 .f and from nfa c3 .stonfa c3 .f.
on the final iteration the all paths check on line is satisfied and we extract the satisfying assignment from ocuron line .
this example illustrates several key invariants the algorithm starts exclusively with startsat andunknown restrictions.
each forward step in the search tightens those restri ctions by moving from startsat topath and from unknown tostartsat .
any given search state is guaranteed to have mutually consistent restrictions.
once set the only way to eliminate a restriction is by backtracking.
backtracking o ccurs only if given the current restrictions it is impossib le to find an agreeing set of paths for the selected variable.
.
correctness having described our algorithm we now turn to an informal correctness argument.
decision procedures that return witnesses in general are required to be sound complete and terminate for all valid inputs.
we discuss each of these aspects in turn referring back to the definitions in section .
and the pseudocode of figure when necessary.
definition soundness i search follow graph i sat a e r i a we assume the correctness of the follow graph procedure.
thestart states andvisit state procedures enforce the following invariants for nfa paths the first variable occurrence in each constraint must have its path start with the start state for that constraint s nfa.
all non first variable occurrences in each constraint must have their paths start with the final state of their immediate predecessor in the constraint.
the last variable occurrence in each constraint must have its path end with the final state for that constraint s nfa.
the first bullet is enforced by start states as defined in the text using startsat restrictions these restrictions are preserved when advance moves the startsat restrictions to path restrictions.
the second bullet is enforced directly by visit state in lines when moving unknown restrictions tostartsat restrictions.the third bullet is enforced by advance when generating paths.
taken together these conditions show exactly the righthand side of the implication for each constraint c .
.
.
r if we concatenate the variable assignments we end up with a string wthat must by construction take nfa c .sto nfa c .f showing w r.definition completeness i satisfiable i search follow graph i e atio slash unsat intuitively we want to show that for any satisfiable constraint system there exists a path in a sufficiently high se arch tree that reaches an all paths searchstate .
this argument relies heavily on the completeness of advance since that procedure essentially determines which child nodes we visit.
definition termination search returns in a finite number of steps for all inputs.
a termination proof must show that the main loop on lines of figure always exists in a finite number of steps.
this follows from several facts each vertex in the search tree has a finite number of children because advance generates a finite number of non repeating paths through a cross product nfa.
for a given parent vertex in the search tree we never visit the same child vertex twice.
if we backtrack to the parent node the advance is guaranteed to generate a distinct child node or report failure .
the tree has finite height because each step away from the root modifies at least one restriction in the direction of path .
suppose we assume that all variable occurrences have unknown restrictions except for one startsat restriction the minimum and also that we move only one restriction per step.
in this case the maximum height is 2n where nis the number of variable occurrences.
.
experiments we present several experiments to evaluate the utility of our approach.
we compare a prototype implementation in c with three publicly available tools cfg analyzer dprle and hampi .
we also provide an indirect comparison with work by veanes et al.
.
we evaluate several related tasks set difference.
in section .
we consider a benchmark used by veanes et al.
.
given two regular expressions a b the task is to compute a string in l a l b if one exists.
the benchmark consists of regular expressions taken from real world code .
we compare hampi dprle and our prototype running each on all pairs of regular expressions.
generating long strings.
in section .
we conduct an experiment used to evaluate the scalability of the rex tool .
for each nbetween and inclusive the task is to compute a string in the intersection of a n and b n .
we compare hampi dprle and our prototype.
bounded grammar intersection.
in section .
we compare cfg analyzer hampi and our prototype on a grammar intersection task.
we select pairs of context free grammars from a large data set .
the task for each implementation is to generate strings of length and for each grammar pair.
382regular expression size .
w w w w .
w w s w w w w .
w w .
kb .
?
d ?
d ?
d .
d ?
d .
d ?
.
d ?
b .
d d ?
d ?
b .
?
?
.
b .
w w .
w b .
?
.
?
.
?
?
?
b .
.
.
d .
d ?
kb .
.
w w .
w .
kb .
.
.
kb .
w w w w .
w w s s .
kb figure regular expressions used for experiment .
the not ation follows that of the .net framework we use the emcascript interpretation of the expanded regular express ion in the input format for hampi and our prototype.
the experiments were conducted on a .8ghz intel core duo machine running linux with .2gb addressable ram.
we use unmodified versions of hampi revision dprle revision and cfg analyzer v. built from source using sun javac v1.
.0 16 for hampi and the ocaml native compiler v3.
.
for the others.
we use the prebuil t binaries for stp and minisat included in the hampi distribution.
we use zchaff v. as the unde rlying sat solver for cfg analyzer.
our prototype is written in c and built using the gnu c compiler v4.
.
.
we measure wall clock time unless otherwise specified.
we run hampi in server mode to avoid the repeated cost of virtual machine startup for the other three tools the measure d time includes process startup time for each data point.
we note that at the time of writing only dprle supports solving multivariable constraints and concatenatio n. we are aware of at least one effort to add support for multiple variables to hampi but at the time of writing such an extension is not publicly available.
in addition we are not aware of any publicly available benchmarks that could provide a reasonable performance comparison while exercising features like concatenation.
consequently we focus on established benchmarks that are compatible with the majority of available tools.
we leave the analysis of search heuristi cs and other potential optimizations for future work.
.
experiment regular set difference in this experiment we test the performance of dprle hampi and our prototype on a set difference task.
we reproduce an experiment used to test the symbolic difference construction by veanes et al.
.
this experiment uses ten benchmark regular expressions presented by li et al.
they are taken from real world code.
the task for each pair of regular expressions a b is to compute a string that occurs in l a but not l b .
this yields distinct inputs for each tool yes instances whenever a e atio slash b and no instances when a b .
the subject regular expressions are listed in figure .
neither our prototype nor the other tools under consideration currently support repetition operations like ?
and i j so we expand these operations into the equivalent combination of concatenations and disjunctions e.g.
a?becomes or a in the input language for hampi .
these expressions are presented in the format used for the microsoft .net framework .
the size column in figure shows figure string generation time distributions grouped by yes and no instances left and right of each pair respectively .
the boxes represent the 25th through 75th percentile the whiskers represent the 5th through 95th percentile.
the size of each regular expression after expansion.
we note that there is a substantial range of sizes from 228b number two to 369kb number nine .
we conducted the experiment as follows.
for each pair of expanded regular expressions we applied the appropriate transformations to create a valid constraint systems for ea ch of the three tools.
this required the following considerations in both cases giving any potential benefit to the othe r tools hampi requires a single fixed length bound for each input and does not support searching for the empty string.
for each pair of input regular expressions we run hampi on length bounds through inclusive.
we terminate the search as soon as hampi finds a string.
in practice we found that k allowed hampi to correctly identify all yes instances while lower kdid not.
dprle requires automata descriptions for its input it does not support regular expressions.
since our prototype performs a conversion from regular expressions to automata we use that conversion algorithm to generate the dprle inputs.
we do not count the conversion time towards dprle s running time in practice we found that this made no significant difference.
figure summarizes the running times of the tools grouped 383figure string generation times log scale for the intersection of the regular languages a n and b n for nbetween and inclusive.
by yes instances datapoints per tool and no instances datapoints per tool .
note that the average time for our prototype tool on yes instances is over an order of magnitude faster than dprle or hampi and that our tool exhibits relatively consistent timing behavior compared to the others.
the performance gain arises from our construction of the state space corresponding to l b this potentially large automaton is determinized and complementized lazily.
.
experiment generating long strings we hypothesize that our prototype implementation is particularly well suited for underconstrained systems that r equire long strings.
to test this hypothesis we reproduce an d extend an experiment used to evaluate the scaling behavior of rex .
we compare the performance of hampi dprle and our prototype.
we also provide an indirect comparison with the results presented for rex which is not publicl y available.
the task is as follows.
for some length n given the regular expressions a n and b n find a string that is in both sets.
for example for n we need a string that matches both a and b one correct answer string is abcc .
note that for any n the result string must have length n .
for hampi we specify this length bound explicitly dprle and our prototype do not require a length bound.
for each n we run the three tools measuring the time it takes each tool to generate a single string that matches both regular expressions.
figure shows our results.
our prototype is on average faster than hampi the speedup ranges from .
to .
dprle outperforms hampi up ton but exhibits considerably poorer scaling behavior than both other tools.
by comparison the published rex results for n show that tool taking approximately seconds or approximately longer than hampi and longer than our prototype on similar hardware.
an informal review of the results shows that our prototype generates only a fraction of the nfa states for n dprle generates states while our prototype generates just or just more than the length of the discovered path .
these results suggest that lazy con straint solving can save large amounts of work relative to eager approaches.
12time ms our prototype hampi cfg analyzer figure string generation times log scale for the intersection of context free grammars.
the grammar pairs were randomly selected from a dataset by axelsson et al.
.
length bounds are and .
each column represents data points the bars show percentile through and the whiskers indicate percentile through .
.
experiment length bounded contextfree intersection in this experiment we compare the performance of cfg analyzer cfga hampi and our prototype.
the experiment is similar in spirit to a previously published co mparison between hampi and cfga from a dataset of approximately context free grammars published with cfg a we randomly select pairs of grammars and have each tool search for a string in the intersection for several length bo unds.
cfga and hampi differ substantially in how they solve this problem.
hampi internally generates a potentially la rge regular expression that represents all strings in the given grammar at the given bound.
cfga directly encodes the invariants of the cyk parsing algorithm into conjunctive normal form.
for our prototype we assume a bounding approach similar to that of hampi.
we use an off the shelf conversion tool similar to that used by the hampi implementation to generate regular languages.
we measure the running time of our tool by adding the conversion time and the solving time.
we randomly selected pairs of grammars.
of these pairs had at least one grammar at each length bound that produced at least one string.
we excluded the other pairs since they can be trivially ruled out without enumeration by a length bound check.
we eliminated an additional three testcases because our conversion tool failed to produ ce valid output.
we ran the three implementations on the remaining grammar pairs at length bounds and yielding datapoints for each of the three tools.
the ratio of yes instances to no instances was roughly equal.
in terms of correctness we found the outputs of hampi and our prototype to be in exact agreement.
figure shows the running time distributions for each tool at each length bound.
we note that our performance is in general just under an order of magnitude better than the other tools.
in all cases our running time was dominated by the regular enumeration step.
we believe a better integrat ed implementation of the bounding algorithm would significantly improve the performance for larger length bounds thus potentially increasing our lead over the other tools.
.
related work in this section we discuss closely related work focusing on other string decision procedures and client application s. there is significant theoretically oriented work on word equations.
some of the problems discussed in this work are similar to those in the recent decision procedure literatur e but focuses more on complexity bounds and decidability results.
kunc provides an overview of this area .
the idea of treating a constraint solving problem as an explicit search problem is not new many existing decision procedures are built around backtracking search e.g.
.
the hampi tool is a solver for string constraints over fixed size string variables.
it supports regular languages fixed size context free languages and a number of operations e.g.
union concatenation kleene star .
hampi has been extensively evaluated in static and dynamic analysis tools and for automatic test generation.
our new procedure supports similar operations to hampi but without requiring fixed size bounds and with significant efficiency gains.
in addition our implementation supports multiple variables while the currently available hampi implementation does not.
the cfg analyzer tool is a solver for bounded versions of otherwise undecidable context free language pro blems.
problems such as inclusion intersection universal ity equivalence and ambiguity are handled via a reduction to satisfiability for propositional logic in the bounded case.
the rex tool solves string constraints through a symbol ic encoding of finite state automata into z3 smt solver .
an important benefit of this strategy is that string constraint s can be readily integrated with other theories e.g.
linear arithmetic handled by z3.
a disadvantage is that the encoding is relatively inefficient in section .
and section .
we showed that hampi and our prototype consistently outperformed rex by up to four orders of magnitude.
the dprle tool is a decision procedure for regular language constraints involving concatenation and subset operations.
the tool focuses on generating entire sets of satisfying assignments rather than single strings ofte n constraints over multiple variables can yield multiple dis joint solution sets.
the core algorithm of dprle has been formally proved correct in a constructive logic framework.
our new procedure supports similar operations to those allowed by dprle but efficiently produces single witnesses rather than atomically generating entire solution sets.
ne vertheless our worst case performance corresponds to that of dprle.
for a large class of no instances in which the contradiction occurs close to a right most variable our curre nt algorithm necessarily generates a large subset of the nfa states that dprle generates by default.
a number of program analyses have been concerned with the values that string expressions can take on at run time.
christensen et al.
check the validity of dynamically generated xml.
similarly minamide uses context free grammars and finite state transducers to perform basic xhtml validity and cross site scripting checks.
wassermann and su build on minamide s analysis to detect sql injection vulnerabilities and cross site scripting vulnerabiliti es by combining it with conservative static taint analysis.
finally there has been quite a bit of recent interest in automated test case generation.
one goal of this line of work is to automatically produce an high coverage test suite .
path coverage is achieved by in essence computing the pathpredicates or guards associated with a large number of paths in the program and then treating them as constraints over the input variables.
solving the constraint system yields i nput variables that cause a given path to be taken.
early tools such as dart or cute focused largely on scalar constraints.
more recent work has focused on the integration of string reasoning into such frameworks e.g.
.
.
conclusion recent work on the analysis of string values has focused on providing external decision procedures for theories tha t model common programming idioms involving strings.
thus far this work has focused on features such as support for concatenation operations embedding into smt solvers and bounded context free languages .
in this paper we present a constraint solving algorithm for equations over string variables.
our algorithm has similar features to existing string decision procedures but i s designed to yield faster answers to yes instances for large input constraint systems.
we achieve this by treating the constraint solving problem as an explicit search problem.
a key feature of our algorithm is that we instantiate the searc h space in an on demand fashion.
we evaluated our algorithm by comparing our prototype implementation to publicly available tools like cfga dprle and hampi .
we used several sets of previously published benchmarks the results show that our approach is up to four orders of magnitude faster than the other tools.
we believe that as string constraint solvers continue to become more and more useful to other program transformations and analyses scalability will be of paramount importance and our algorithm is a step in that direction.
.