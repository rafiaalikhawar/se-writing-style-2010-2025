do all task dependencies require coordination?
the role of task properties in identifying critical coordination needs in software projects kelly blincoe computer science department drexel university philadelphia pa usa kelly.blincoe drexel.edu giuseppe valetto computer science department drexel university philadelphia pa usa valetto cs.drexel.edu daniela damian software engineering global interaction lab university of victoria victoria bc canada danielad cs.uvic.ca abstract several methods exist to detect the coordination needs within software teams.
evidence exists that developers awareness about coordination needs improves work performance.
distinguishing with certainty between critical and trivial coordination needs and identifying and prioritizing which specific tasks a pair of developers should coordinate about remains an open problem.
we investigate what work dependencies should be considered when establishing coordination needs within a development team.
we use our conceptualization of work dependencies named proximity and leverage machine learning techniques to analyze what additional task properties are indicative of coordination needs.
in a case study of the mylyn project we were able to identify from all potential coordination requirements a subset of that are most critical.
we define critical coordination requirements as those that can cause the most disruption to task duration when left unmanaged.
these results imply that coordination awareness tools could be enhanced to make developers aware of only the coordination needs that can bring about the highest performance benefit.
categories and subject descriptors d. .
management productivity programming teams general terms management performance human factors.
keywords task dependencies proximity coordination requirements awareness collaborative software development machine learning .
introduction in large software projects developers work on tasks in parallel or on interdependent tasks.
this often results in work dependencies and consequently coordination needs.
when developers remain unaware or do not obtain timely awareness of the coordination that is required to manage work dependencies there is potential for software productivity or quality problems .
existing techniques to support coordination awareness assume all dependencies may require coordination and they simply enumerate the universe of those potential coordination needs in a project.
this can lead to an overwhelming number of recommendations and alert developers of even trivial coordination needs.
this is especially problematic in large projects or when coordination requirement detection occurs at fine granularity for example at the level of individual tasks.
the main premise of our work instead is that not all coordination requirements are created equal.
we explore what properties of development tasks and corresponding software code may indicate a critical coordination need.
we define a critical coordination requirement as one that can cause the most disruption and inefficiency to the development process if not properly and timely managed.
an understanding of the characteristics of the critical coordination needs can lead to better awareness tools and more focused coordination efforts in software development teams.
in this paper we report on an exploratory case study of the mylyn open source project with a large set of potential coordination requirements.
we first evaluated a quantitative conceptualization of work dependencies called proximity and confirmed that existing automated techniques for the identification of coordination needs like proximity find far too many dependencies.
we then examined other task properties that could be used to supplement measures like proximity to identify coordination needs.
finally we used machine learning with both proximity and the identified task properties to evaluate whether such an approach is successful in identifying only the critical coordination needs.
the tasks involved in the reduced set of coordination requirements presented very different performance profiles from the rest of the tasks when examining task durations.
these differences may be attributed to the criticality of the coordination needs among those tasks especially since many seem to be unrecognized and unmanaged.
our results imply that not all coordination requirements are created equal and current techniques for detecting coordination requirements could be supplemented by additional task properties beyond just work dependencies to better predict only the critical coordination requirements.
in the remainder of the paper we first discuss related work section and review the proximity algorithm section .
we then introduce our research questions and describe the setting of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
esec fse august saint petersburg russia.
copyright acm ... .
.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august saint petersburg russia copyright acm ... .
our empirical study section .
next we describe the method and results of our research section .
finally we discuss the significance of our contributions section and offer some concluding remarks section .
.
background and related work several techniques have been proposed to detect the need to coordinate between developers in large software development projects .
cataldo et al.
were the first to introduce a framework for establishing coordination requirements between developers depicted in figure .
they found that when coordination requirements are fulfilled for example by acts of communication productivity is likely to increase .
their framework establishes coordination requirements between developers who are working on dependent tasks.
to ascertain work dependencies they look at the artifacts committed during each task and the dependencies between those artifacts.
logical coupling is used to determine technical dependencies between artifacts if they have been checked in together in the past.
cataldo et al.
found that logical couplings are more likely than syntactic couplings to provide a reliable representation of technical dependencies for their coordination requirement conceptualization.
a limitation of this conceptualization is that it requires mining the source control repository of the project for the commit history of software artifacts.
this type of data is typically available only towards the end of the development work for a task and the coordination awareness garnered from this approach may not be actionable by the developers at the time coordination is needed to reap those performance benefits.
in blincoe et al.
we proposed an alternative conceptualization of work dependencies for detecting coordination needs.
that conceptualization uses the proximity metric which is described in detail in section .
proximity as shown in figure evaluates the intersection of the working sets of a pair of developers and the actions developers take on the artifacts in those working sets to determine and weigh coordination needs.
we found that by looking at both artifact consultation and editing actions it is possible to accurately discover coordination requirements without the need to model and consider technical dependencies between artifacts.
since artifact consultation and edit actions can be captured in real time through existing ide monitoring facilities proximity can provide timely detection of coordination needs.
this timely detection of coordination needs provides awareness to developers while their work is still underway.
developers can then act upon and resolve their coordination needs as they surface.
current coordination requirement detection methods including proximity abstract coordination requirements by detailing only pairs of developers who may need to coordinate.
developers may work on multiple tasks at the same time so coordination requirements at the developer level may encompass the work dependencies of many tasks see figure .
the many existing awareness tools that exist to support developer awareness of coordination needs do not indicate which tasks are involved in coordination requirements.
this puts the burden on the developers to identify what to coordinate about.
if awareness tools were able to provide finer grained coordination needs at the task level that burden would be removed.
in this work we extend the proximity technique to identify coordination requirements between pairs of tasks rather than pairs of developers.
however without the abstraction that occurs when rolling coordination requirements up to the developer level the work dependencies may signal a plethora of coordination requirements including those that are trivial or insignificant.
for this reason we augment the proximity method by also including other task properties to detect only the most critical coordination requirements.
figure .
conceptualization of coordination requirements in cataldo et al.
approach .
figure .
conceptualization of coordination requirements through proximity .
figure .
coordination requirements between developers are typically a result of their work on more than one development task.
.
proximity proximity is a metric for measuring coordination needs in software development teams.
unlike more traditional coordination requirement detection techniques it does not obtain information from the source control repository system nor rely on technical dependencies between artifacts.
these differences make proximity timely and turn coordination requirements into an actionable concept for managing coordination in software projects.
to determine coordination requirements the proximity algorithm examines the similarity of artifact working sets as they are constructed during developers tasks.
to do this it obtains developer actions such as artifact consultation or edits as they occur.
it uses the mylyn framework to obtain this information.
mylyn is a tool that transforms a developer s individual developer environment ide to a task centric view to make context switching between tasks easier.
to fulfill its own purposes mylyn records all developer ide interactions as they occur.
these events are stored as context data for the task in focus.
for convenience proxiscientia the tool which implements the proximity measure is built on top of mylyn so it can easily obtain these developer actions.
the proximity measure looks at artifact consultation and modification activities captured by mylyn and weighs the overlap that exists between the working sets associated to pairs of developers.
it considers all actions recorded for each artifact in each working set in order to apply a numeric weight to that artifact s proximity contribution.
weights are applied based on the type of overlap where the most weight is given when an artifact is edited in both working sets weight and the least amount of weight is given when an artifact is simply consulted in both working sets weight .
.
when an artifact is edited in one working set and consulted in the other working set we consider this a mixed overlap weight .
.
the weights are directly based on the weights mylyn itself uses for its degree of interest model .
figure illustrates an example of the proximity computation process .
the algorithm computes the ratio of actual to potential overlap.
actual overlap considers the intersection of the two working sets while potential overlap considers the union of the two working sets.
potential overlap represents the maximum possible proximity score had there been perfect overlap between the two sets of actions.
proximity scores can then be scaled based on the number of overlapping events to place greater weight on complex tasks that are likely to require coordination.
proximity scores range from zero to infinity.
through empirical analysis we found that higher proximity scores are indicative of a stronger need to coordinate .
.
research approach we build on the proximity method since it is the only existing real time coordination requirement detection method.
conceptually proximity can be easily applied to pairs of tasks simply by aggregating the captured developer actions at the individual task level rather than at the developer level.
however even in moderately sized projects a large number of potential coordination needs could be created when calculating proximity between tasks.
it is currently not possible to know whether all work dependencies that are detected between task pairs require actual coordination.
our working hypothesis is that current coordination requirement detection algorithms cast too wide a net in considering all work dependencies as candidates for coordination.
we explore this hypothesis by comparing the tasks pairs with proximity to the dependencies identified by the team rq1 is there a correspondence between tasks with identified dependencies and development tasks with proximity?
to answer this research question we look for evidence of task dependencies that have been identified by the project team and recorded within a change request.
change request repositories like bugzilla1 are commonly used to define assign and manage project tasks.
in the remainder we refer to the task dependencies established by the project team and recorded in the change request repository as the identified dependencies .
we then compare those identified dependencies to the proximity scores computed between tasks.
we expect to find high levels of recall paired with low levels of precision indicating that while proximity is able to successfully detect many identified dependencies the identified dependencies represent only a small subset of the task pairs with proximity.
if this hypothesis is proven correct research questions rq2 and rq3 will begin to explore solutions for this problem.
rq2 what properties of task pairs other than work dependencies ranked by proximity are also indicative of actual coordination needs?
we examine various properties of task pairs to look for differences between the identified dependencies and all other task pairs.
we inspect the statistical difference in proportion and distribution of these properties using chi squared and mann whitney tests.
rq3 can we supplement proximity with additional task pair properties to identify the most critical coordination needs?
this research question builds on the findings of rq2.
if there are properties beyond work dependencies ranked by proximity that greatly differ between tasks with identified dependencies and all other tasks we can use those properties with machine learning to better infer coordination requirements and to supplement current methods like proximity.
we conceptualize critical coordination requirements as those coordination needs that have suffered the most in terms of performance task duration and use this criterion in analyzing the output of such a machine learning technique on figure .
proximity algorithm example .
215our data set.
therefore to answer rq3 we evaluate the results of the machine learning approach comparing the task performance of the tasks involved in machine learning predicted coordination requirements and all other tasks.
to answer our three research questions we carried out an empirical study on the mylyn open source project itself.
the mylyn project represents an ideal case study because its developers make routine use of the mylyn plugin in their ide allowing us to collect the context data needed for the proximity calculation.
we mined the project repositories and collected all bugzilla change requests and developer activities mylyn context data from two releases of the mylyn project releases .
and .
.
on the mylyn project developers are assigned change requests as their unit of work and encouraged to deliver their work as code patches that correspond to and resolve a single change request.
the bug tracking database is therefore the way the mylyn team defines and assigns developer tasks and we refer to bugzilla change requests as tasks.
mylyn release .
spanned from june to march .
at the time we mined the repository in july we obtained bugzilla tasks with context data for which development work occurred during the development of release .
.
this yielded task pairs for that release.
similarly mylyn release .
spanned from march to june and contained tasks task pairs .
our analysis focused on release .
.
release .
was used as a training data set for the machine learning technique that we apply to address rq3.
.
research method and results .
applying proximity to tasks rq1 is there a correspondence between tasks with identified dependencies and development tasks with proximity?
to answer rq1 we mined the project s change request database bugzilla to obtain evidence of work dependencies between submitted change requests and the tasks associated with those change requests that have been identified by the project team.
a recent study by aranda and venolia found that repositories like bugzilla often provide incomplete information because of omission oversight or simply because of project conventions.
for this reason we sought dependencies beyond those explicitly marked by the project team.
by inspecting the change request reports we found three main types of dependency identification evidence explicitly marked dependencies duplicates and discussion cross