tzuyu learning stateful typestateshao xiao j u ns u n y a n gl i u s h a n g w e il i n and chengnian sun school of computer engineering nanyang technological university singapore university of technology and design temasek laboratories national university of singapore school of computing national university of singaporeabstract behavioral models are useful for various softwareengineering tasks.
they are however often missing in practice.thus specification mining was proposed to tackle this problem.existing work either focuses on learning simple behavioralmodels such as finite state automata or relies on techniques e.g.
symbolic execution to infer finite state machines equippedwith data states referred to asstateful typestates.t h ef o r m e ris often inadequate as finite state automata lack expressivenessin capturing behaviors of data rich programs whereas thelatter is often not scalable.
in this work we propose a fullyautomated approach to learn stateful typestates by extending theclassic active learning process to generate transition guards i.e.
propositions on data states .
the proposed approach has beenimplemented in a tool called tzuyu and evaluated against anumber of java classes.
the evaluation results show that tzuyuis capable of learning correct stateful typestates more efficiently.i.
introductionbehavioral models or specifications are useful for vari ous software engineering tasks.
for instance object types tates are important for program debuggingand verification.
a precise and preferably concise typestateis useful for understanding third party programs.
in practice however such models are often inadequate and incomplete.
toovercome this problem learning based specification mining was proposed to automatically generate behavioral modelsfrom various software artifacts e.g.
source code executiontraces and natural language api documentation .
thisapproach is promising as it requires no extra user efforts.existing approaches on learning typestates also known asinterface specification can be broadly categorized intotwo groups.
one focuses on learning behavioral models inthe forms of finite state automata without data states.
thesemethods are often inadequate in practice as it is known thatfinite state automata lack expressiveness in modeling data richprograms.
consider a simple example of astackclass withtwo operations pushandpop.at y p e s t a t eo ft h estackshouldspecify the following language the number ofpushoperationsin any valid trace of the model must be no less than thenumber ofpopoperations.
it is known that this language isirregular and therefore beyond the expressiveness of finite state automata.
on the other hand the model of thestackcan be easily expressed using a finite state machine with aguard condition on thepopoperation size 1wheresizedenotes the number of items in the stack.
the central issue isthus how to identify the propositionsize 1systematicallyand automatically.the other group learns stateful typestates using relativelyheavy weight techniques like smt sat solving.
for instance aluret al.
propose to synthesize interface specificationsfor java classes based on predicate abstraction which relieson theorem proving.
similarly giannakopoulouet al.
propose to learn typestates through symbolic execution whichrelies on smt solving and refinement.
given that existingtheorem proving and smt sat techniques are still limited inhandling complicated data structures and control flows thesemethods are often limited to small programs.in this paper we propose an alternative approach to learningstateful typestates from java programs.
the key idea is toextend an active learning algorithm with an approach toautomatically learning transition guards i.e.
propositions ondata states .
our approach takes the source code of a classas the only input and generates a stateful typestate throughas e r i e so ft e s t i n g l e a r n i n ga n dr e fi n e m e n t .f i g .1s h o w st h ehigh level architecture of our approach.
there are three maincomponents.
the learner constructs a typestate based on thel algorithm .
it drives the learning process by generatingtwokinds of queries.
one is the membership query i.e.
whetheras e q u e n c eo fe v e n t s i .
e .
at r a c e o ft h ec u r r e n tt y p e s t a t eis valid.
the other is the candidate query i.e.
whether acandidate typestate matches the actual typestate.
the testeracts as a teacher in the classic active learning setting.
it takesqueries from the learner and responds accordingly based ontesting results.
in the original l algorithm the model to belearned is a finite state automaton and a trace can be eithervalid or invalid but never both.
however in our setting itis possible that two executions have the same sequences ofmethod calls on the same object but lead to different outcomes i.e.
error or no error due to different inputs to the methodcalls which in turn result in different data states .
in suchac a s e a l p h a b e tr e fi n e m e n ti sp e r f o r m e d b ys p l i t t i n go n eevent into multiple events each of which has a different guardcondition so that the traces are distinguished.
the refiner isused to automatically identify proper guard conditions.
inthefollowing we use a simple example to illustrate how ourmethod works.we take thejava.util.stackclass in java se .
.
as therunning example.
without loss of generality let us focus onthe following two methods push which takes an object asan input andpop a n do n ed a t afi e l delecount inheritedfrom thejava.util.vectorclass which denotes the number ofelements in the stack.
initially we have an alphabet containing978 c ieee ase palo alto usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.
counterexample counterexample failed tests success tests membership querycandidate query o o divider for o o fig.
.
the high level architecture of tzuyu.
angbracketleft angbracketright angbracketleft angbracketright angbracketleftpush angbracketright angbracketleftpop angbracketright angbracketleftpop push angbracketright angbracketleftpop pop angbracketright a abpushpoppush pop b fig.
.
the first observation table a and candidate typestate b .two events corresponding to the two methods.
given aninstance of the stack class the learner generates a number ofmembership queries i.e.
a sequence of method calls.
givenone membership query the tester generates multiple test caseswhich have the same sequence of method calls with differentarguments and answers the query.
the queries and testingresults are summarized in the observation table refer to detailsin section ii b as shown in fig.
a where a bracketle t a bracketri htis anempty sequence of method calls and a bracketle tpop push a bracketri htdenotes thesequence of callingpushafterpop.t h e0 si nc o l u m n a bracketle t a bracketri htdenotethat all tests generated for the sequence a bracketle tpop a bracketri htand then a bracketle t a bracketri htresultin an exception or assertion failure hereafter failure .
the 1sdenote that none of the tests result in failure.
based on theobservation table the learner generates a candidate typestateas presented in fig.
b .
note that the typestate is a finite state automaton with one accepting state i.e.
statea.next the learner asks a candidate query i.e.
is the typestatein fig.
b the right typestate?
the tester takes the candi date typestate and performs random walking i.e.
randomlygenerates a set of tests which correspond to traces of thetypestate.
notice that a trace of the typestate is either accepting i.e.
ending with an accepting state or otherwise.
throughthe random walking the tester identifies one inconsistencybetween the typestate and the class under analysis.
that is thetypestate predicates that callingpopfrom stateaalways resultsin failure whereas it is not always the case.
for instance calling methodpushfirst which leads to statea a n dt h e npopresults in no failure.the existence of inconsistency suggests that the typestatemust be refined.
we collect data states of the stack at stateabefore calling methodpopand partition them into two sets i.e.
ones which lead to failure after invokingpopand the rest.next the refiner is consulted to generate a proposition suchthat all data objects in the first set satisfy while all therest violate .t h et e c h n i q u eu s e db yt h er e fi n e ri sb a s e do nsupport vector machines svms .
in the above example the generated proposition iselecount .n e x t w er e s t a r tthe learning process with an alphabet which contains threeevents push pop a n d popwhere popdenotes the event of callingpopwhen the conditionelecount 1is satisfied.
after a series angbracketleft angbracketright angbracketleft angbracketright angbracketleftpush angbracketright angbracketleft pop angbracketright angbracketleft pop angbracketright angbracketleft pop push angbracketright angbracketleft pop pop angbracketright angbracketleft pop pop angbracketright a 10push pop poppush pop b fig.
.
the second observation table a and candidate typestate b generatedby tzuyu.of membership queries the learner constructs the observationtable as shown in fig.
a .notice that all tests corresponding to popresult in no failure and therefore it is marked in the table.an e wc a n d i d a t et y p e s t a t ei st h e ng e n e r a t e df r o mt h et a b l e as shown in fig.
b .
the tester performs random walkingagain and finds no inconsistency.
we then present fig.
b as the resultant typestate after some simple bookkeeping onfig.
b by transforming!
elecount toelecount 0using the fact thatelecountis an integer .
the novelty of our approach is on integrating a refinerinto the active learning process so as to learn typestates fordata rich programs.
in particular by adopting techniquesfrommachine learning community we are able to automaticallygenerate propositions for alphabet refinement.
the refiner actsas an abstract mapper between the learner and the classunder analysis.
compared with existing techniques on findingthe right proposition e.g.
our approach improves theperformance of typestates generation as it avoids smt satencoding and solving.
furthermore to learn concise statefultypestates efficiently we investigate the interplay betweenlearning and refinement and develop an algorithm which avoid sr e s t a r t i n gl e a r n i n gw h e na l p h a b e tr e fi n e m e n to c c u r s .t h emethod has been implemented in a tool named tzuyu1andour experiments show that tzuyu is able to learn meaningfuland concise typestates efficiently.the remainder of the paper is organized as follows.
sec tion ii presents preliminary introduction to the concepts andtechniques used in our approach.
section iii presents thedetails of our approach.
section iv presents details on theimplementation of tzuyu and section v evaluates its perfor mance with experiments.
section vi discusses related work.section vii concludes the paper.ii.
preliminariesin this section we formalize the definitions related to statefultypestate and introduce the techniques used in our approach.a.
definitionsthe input to our method is a java class e.g.
the stack class which is constituted by a set of instance variables which could1tzuyu is commonly known as the best student of confucius.433be objects of other classes and methods.
in this work we fixone object of the given class as the main receiver and inspectbehaviors of all instances of the class through this object.anobject state is the status of the object i.e.
the valuationof itsvariables.
for each object there is an initial object state2 i .
e .
the initial valuation of the variables.
a method is a functionwhich takes one object state and returns a new one.
a concreteexecutionexof an object is a finite sequenceex a bracketle to0 m0 p0 o1 m1 p1 ok mk pk ok a bracketri htwhereoiis an object state andmi pi is a method call withconcrete arguments pi.af a i l e de x e c u t i o ni sa ne x e c u t i o nwhich results in an exception or assertion failure.
a successfulexecution is one which does not fail.the output of our method is a stateful typestate which isdefined on top of the deterministic finite state automaton.definition ad e t e r m i n i s t i cfi n i t e s t a t ea u t o m a t o n h e r e after dfa is a tupled s init f such thatsis afinite set of states init sis an initial state is the alphabetwhich is a finite set of events s sis a transitionfunction andf sis a set of accepting states.
at r a c eo fdis a sequencetr a bracketle ts0 e0 s1 sn en sn a bracketri htsuch thats0 initand si ei si for alli.tris acceptingifsn f.o t h e r w i s e i ti sn o n a c c e p t i n g .t h el a n g u a g eo fdis the set of all accepting traces ofd.i na na b u s eo fn o t a t i o n s we writestr s primeto denote that tracetrfrom statesleads tostates primeand writetr s to denotes prime.f o rt w ot r a c e str0andtr1 we writetr0 tr1to denote their concatenation.definition a s t a t e f u l t y p e s t a t eo faj a v ac l a s si satuplet prop meth d such thatpropis a set ofpropositions which are boolean expressions over variablesin the class methis the set of method names in the class d s init f is a dfa such that prop meth.
in the stack example a proposition inpropcan be con stituted byelecount capacity inherited from vector anydata field ofelementdata e.g.
elementdata.length etc.
setmethcontainspushandpop.b yd e fi n i t i o n t y p e s t a t e sa r edeterministic in this work.
notice that an event in is a pair i.e.
a guard conditionginpropand a method nameeinmeth.for brevity a transition is written as s e s prime .at y p e s t a t eabstracts all executions of an object of the class.
in particular at r a c etr a bracketle ts0 e0 s1 e1 s2 sn en sn a bracketri htis anabstraction of the executionexabove if they have the samesequence of methods i.e.
ei mifor alli a n da l lt h eguard conditions are satisfied i.e.
giis satisfied byoiandmethod arguments pifor alli .
we denote the set of concreteexecutions oftrascon tr .g i v e na ne x e c u t i o nexand analphabet w ec a no b t a i nt h ec o r r e s p o n d i n gt r a c e d e n o t e da sabs ex b yt e s t i n gw h i c hp r o p o s i t i o ni npropis satisfied foreach method call inex.at y p e s t a t edis said to be safe or sound if for every ac cepting tracetrofd e v e r ye x e c u t i o ni ncon tr is successful.2for brevity a constructor is treated in the same way as a normal methodexcept that it must be called initially and calling it later leads to failure.it is complete if for every concrete executionexof the class there is an accepting tracetrsuch thatex con tr .b.
the l algorithmthe learner extends the original l algorithm with lazyalphabet refinement which is introduced later in section iii c.in the following we introduce the original l algorithm.the l algorithm assumes that the system to be learneddis in the form of dfa with a fixed alphabet and learnsad f aw i t ht h em i n i m a ln u m b e ro fs t a t e st h a ta c c e p t st h esame language ofd.d u r i n gt h el e a r n i n gp r o c e s s t h el algorithm interacts with aminimal adequate teacher teacherfor short by asking two types of queries membership queriesand candidate queries.
amembership queryasks whether atracetris a trace ofd w h e r e a sacandidate queryasks whetherad f acis equivalent tod i .
e .
canddhave the samelanguage.during the learning process the l algorithm stores themembership query results in anobservation table p e t wherep is a set of prefixes e is a set ofsuffixes andtis a mapping function such thatt tr tr prime 1iftris a trace inpor a trace inpattached with an eventin a n dtr primeis a trace iseandtr tr primeis a trace of thesystem otherwise t tr tr prime .i nt h eo b s e r v a t i o nt a b l e the l algorithm categorizes traces based on myhill nerodecongruence .definition we say two tracestrandtr primeareequivalent denoted bytr tr prime i ftr is a trace ofsifftr prime is a traceofs f o ra l l .u n d e rt h ee q u i v a l e n c er e l a t i o n w ec a nsaytrandtr primeare therepresenting traceof each other withrespect tos d e n o t e db ytr randtr prime r. the l algorithm always tries to make the observationtableclosedandconsistentwith membership queries.
anobservation table isclosedif for alltr pande t h e r ealways existstr prime psuch thattr a bracketle te a bracketri ht tr prime.a no b s e r v a t i o ntable isconsistentif for every two elementstr tr prime psuchthattr tr prime t h e n tr a bracketle te a bracketri ht tr prime a bracketle te a bracketri ht for alle .if the observation table p e t is closed and consistent the l algorithm constructs a corresponding candidate dfac s init f such that scontains one state for each trace inp n o t i c et h a tequivalent traces inpcorrespond to the same state.
initis the state corresponding to the empty trace a bracketle t a bracketri ht for any statesinswhich corresponds to a tracetrande s e s prime w h e r es primeis the state for the trace rinp as t a t esis infiff the corresponding tracetrsatisfiest tr .subsequently l raises a candidate query on whethercisequivalent to the system to be learned.ifcis equivalent to the system cis returned as the learningresult.
otherwise the teacher identifies a counterexample s a ytr w h i c hi st h e na n a l y z e dt ofi n dawitness suffix.aw i t n e s ssuffix is a trace that when appended to the two traces providesenough evidence for the two traces to be classified into twoequivalence classes under the myhill nerode congruence.
let434 angbracketleft angbracketright angbracketleftpop angbracketright angbracketleft angbracketright angbracketleftpush angbracketright angbracketleftpop angbracketright angbracketleftpop push angbracketright angbracketleftpop pop angbracketright angbracketleftpush push angbracketright angbracketleftpush pop angbracketright a 101100pushpoppoppushpush pop b fig.
.
the second observation table a candidate dfa b generated by theclassic l algorithm.trbe the concatenation of two tracestr0andtr1 i .
e .
tr0 tr1 tr.l e tsbe the state reached from stateinitvia tracetr0 i .
e .
inittr0 s.tr1is thewitness suffixoftr d e n o t e db yws tr i fstr1 s primeands prime e atio slash d tr w h e r ed tr denotes the state reachedafter runningtrond.o n c et h ew i t n e s ss u f fi xws ce isobtained l usesws ce to refine the candidate dfacuntilcis equivalent to the system.
we refer readers to the work oflinet al.
for more details of l algorithm withexamples.angluin proved that as long as the unknown languageuis regular the l algorithm will learn an equivalent minimaldfa with at mostn 1candidate queries ando n2 nlogm membership queries wheremis the length of thelongest counterexample returned by the teacher andnis thenumber of states of the minimal dfa.example we again use the stack example to illustratehow l works and also why it doesnotwork when thetarget class cannot be captured by a dfa.
after a series ofmembership queries l constructs the first candidate dfa as shown in fig.
b and performs a candidate query forthe dfa.
the teacher answers no with a positive coun terexample a bracketle tpush pop a bracketri ht w h i c hs h o u l db ei n c l u d e di n t ot h ebehavior of the candidate.
after analyzing the counterexample the witness suffix a bracketle tpop a bracketri htis added into the set of suffixeseof the observation table and the closed observation tableis shown in fig.
a .
based on the observation table l constructs the second candidate dfa as shown in fig.
b and performs a candidate query for the candidate.
the teacheranswers no again with another positive counterexample a bracketle tpush push pop pop a bracketri ht.t h i st i m e t h ew i t n e s ss u f fi x a bracketle tpop pop a bracketri htis added into the set of suffixeseof the observation table andthe closed observation table is shown in fig.
a .
based onthe observation table l constructs the third candidate dfa as shown in fig.
b and performs a candidate query for thethird one.
the reader may find that after theith candidate queryfori n t h e r ei sa l w a y saw i t n e s ss u f fi x a bracketle t pop i a bracketri htshowingthat the candidate dfa is incorrect and one additional statewill be added to the candidate dfa which makes the l learning process non terminating.
iii.
detailedapproachin this section we first introduce the detailed design of thetester and refiner and then introduce the learner which interactswith the tester and learner to learn the typestate.
angbracketleft angbracketright angbracketleftpop angbracketright angbracketleftpop pop angbracketright angbracketleft angbracketright angbracketleftpush angbracketright angbracketleftpop angbracketright angbracketleftpop push angbracketright angbracketleftpop pop angbracketright angbracketleftpush push angbracketright angbracketleftpush pop angbracketright angbracketleftpush push push angbracketright angbracketleftpush push pop angbracketright a 100110111000pushpoppoppushpushpoppush pop b fig.
.
the third observation table a and candidate dfa b generated bythe classic l algorithm.a.
the testerthe tester acts as the teacher for l algorithm.
ideally givenam e m b e r s h i pq u e r yf o rat r a c etr t h et e a c h e rs h o u l da n s w e reither yes or no.
sincetrcan be mapped into a set of concreteexecutionscon tr t h a ti st os a yt h a tt h et e a c h e rs h o u l da n s w e ryes iff all executions incon tr are successful and answerno iff all executions incon tr are failed.
similarly given acandidate query the tester should answer yes iff the candidatetypestate is safe and complete.having a perfect teacher in our setting is infeasible fortwo main reasons.
firstly the setcon tr is infinite withdifferent arguments for method calls in general and hencechecking whether all executions incon tr are successful ornot is highly non trivial.
secondly it could be that someexecutions incon tr are successful whereas some are failed.for instance assume the class given isjava.util.vectorandtris a bracketle taddall a bracketri ht.ac o n c r e t ee x e c u t i o nw i t ham e t h o dc a l laddalland argumentnullresults in exception whereas a non nullargument results in success.
we tackle the former problemby using guided random testing as the teacher as we discussbelow.
the latter problem is solved by alphabet refinement aswe show in section iii b.in the following we show how the tester is used as ateacher for membership queries and candidate queries.
givenam e m b e r s h i pq u e r ytras follows tr a bracketle ts0 m0 s1 m1 s2 sn mn sn a bracketri htthe tester s task is to identify multiple concrete executionsas follows a bracketle to0 m1 p1 o2 m2 p2 ok mk pk ok a bracketri ht.i nother words to automatically generate the arguments for allmethod calls such that all guard conditionsgiare satisfied.
thistask is in general highly non trivial and requires techniqueslike sat smt solving.
in the name of scalability we insteadapply testing techniques for argument generation.
in particular the approach of randoop is adopted.
in the following webriefly introduce the idea and refer readers to details in .giventr w eg e n e r a t ea r g u m e n t sf o re a c hm e t h o dc a l lo n e by one in sequence.
given a typed parameter the idea is torandomly generate a value from a pool of type compatiblevalues.
this pool composes of a set of pre defined value e.g.
435ar a n d o mi n t e g e rf o ra ni n t e g e rt y p e nullor an object with thedefault object state for a user defined class etc.
but alsotype compatible objects that have been generated during the testingprocess.
we remark that in order to re create the same object we associate each object with the execution which producesthe object state.
given one value for each parameter we thenevaluate whethergiis true or not.
ifgiis true we proceedwith next method call.there are four possible outcomes of the random testing.
ifall tests are successful the answer to the query is yes i.e.
trshould be an accepting trace.
if all tests are failed the answeris no i.e.
trshould be a non accepting trace.
if there areboth successful tests and failed tests fortror a prefix oftr the tests are passed to the refiner for alphabet refinementas we show later.
lastly due to the limitation of randomtesting i.e.
the price we pay to avoid theorem proving itis possible that some guard conditiongiis never satisfied bythe generated arguments.
in other words we fail to find anyconcrete execution incon tr .i ns u c hac a s e w eo p t i m i s t i c a l l yanswer yes so that the resultant typestate is more permissive.to answer a candidate query with a typestatec w eu s erandom walk to generate a suite of test cases.note that the approach of randoop is again used.
testcases which are inconsistent with the typestates are collectedinto two sets positive counterexamples and negative counterex amples.
a positive counterexample is a successful test whosecorresponding tracetris non accepting.
a negative exampleis a failed test whose corresponding tracetris accepting.
ifboth sets are empty we answer the query with a yes i.e.
the typestate is the final output.
if either of the two sets isnot empty the typestate is invalid and a counterexamplemust be presented to the learner.
in the original l algorithm presenting any of the counterexamples will do.
it is howevermore complicated in our setting as we show below.for each statesin the typestatec w ei d e n t i f yas e to fexecutions in the test suite which end at the state denoted ases.f o re a c he w ee x t e n de a c he x e c u t i o ni neswith amethod call corresponding toeand obtain a new set denoted asees.i fa l lo ft h ee x e c u t i o n sr e s u l ti nf a i l u r ew h e r e a sat r a n s i tionlabeled withefromsleads to an accepting state inc t h et e s t e rreports thatcis invalid and picks one execution ineesandpresents its corresponding abstract trace as a counterexample.similarly if all of the executions are successful whereasatransition labeled withefromsleads to a non accepting state the tester presents a counterexample.
lastly if some of theexecutions ineesresult in failure and others result in success the refiner is consulted to perform alphabet refinement.b.
the refinerthere are two different scenarios when the refiner is con sulted.
one is with a membership querytrand a set of testsincon tr such that for some of the executions denoted ast performing the last method call with the generatedarguments results in failure whereas for the rest of theexecutions denoted ast performing the last call resultsin success.
in this case alphabet refinement is a must as allthe tests have the same tracetrand therefore they cannot bedistinguished without alphabet refinement.given an execution int ort w ec a no b t a i nad a t as t a t epair o p whereois the object state of the main instanceprior to the last method call and pis the list of arguments ofthe last method call.
leto be the set of all pairs we collectfrom executions int ando be the set of all pairs we collectfrom executions int .i n t u i t i v e l y t h e r em u s tb es o m e t h i n gdifferent betweeno ando such thatt fails andt succeeds.
the refiner s job is to find adivider i nt h ef o r mof a proposition such thato ando can be distinguished.formally a divider foro ando is a proposition suchthat for allo o osatisfies and for allo prime o a n do primedoes not satisfy .f r o ma n o t h e rp o i n to fv i e w t h e r em u s tb esome invariant for all object states ino denoted asinv and some invariant for all object states ino denoted asinv such thatinv implies andinv implies the negation of .the refiner in our work is based on techniques developedby machine learning community in particular support vectormachines svms .
svm is a supervised machine learningalgorithm for classification and regression analysis.
we usei t sbinary classification functionality.
mathematically thebinaryclassification functionality of svms works as follows.
giventwo data states sayo ando each of which can be viewedas a vector of numerical values e.g.
floating point numbers it tries to find a separating hyperplane ni 1ci xi csuchthat for every positive data state p1 p2 pn o such that ni 1ci pi cand for every negative data state m1 m2 mn o such that ni 1ci mi c.a sl o n ga so ando are linear separable svm is guaranteed to findas e p a r a t i n gh y p e r p l a n e e v e ni ft h ei n v a r i a n t sinv andinv may not be linear.
furthermore there is usually more than onehyperplane that can separateo fromo .i nt h i sw o r k w echoose theoptimal margin classifier see the definition in if possible.
this separating hyperplane could be seen as thestrongest witness why the two data states are different.in order to use svm to generate dividers each elementino oro must be casted into a vector of numericaltypes.
in general there are both numerical type e.g.
int a n dcategorical type e.g.
string v a r i a b l e si nj a v ap r o g r a m s .t h u s we need a systematic way of mapping arbitrary object states tonumerical values so as to apply svm techniques.
furthermore the inverse mapping is also important to feed the svm resultsback to the original program.
our approach is to systematicallygenerate anumerical value graphfrom each object type andapply svm techniques to values associated with nodes inthe graph level by level.
we illustrate our approach usinganexample in the following.fig.
shows part of the numerical value graph for typestack where many data fields have been omitted for readability .
arectangle with round corners represents a categorical type whereas a circle associated with the type denotes a numericalvalue which can be extracted from the type.
notice that acategorical type is always associated with a boolean typevalue which is trueiffthe object is null.
an edge reads as contains .
for instance a stack type contains an object of436stackbiarrayiobjectbibisnullelecountincrementdataelementlengthisnullisnullfig.
.
the numerical value graph for stack.type array i.e.
elementdata which in turn contains objectsof type object .
for readability each edge is labeled withanabbreviated variable name and each node is labeled with thetype.
to obtain a vector of numerical values from a type wetraverse through the graph level by level to collect numericalvalues associated with each type.
in general the graph couldbe huge if a type contains many variables.
for the purposeof typestate learning however it is often sufficient to looka tonly the top few levels.in the following we demonstrate how the graph is used.assume the last event of the membership query is popand the two sets of object states areo ando prior tothe method call.
given the receiver object of the methodcall is a stack the refiner first abstractso ando usinglevel numerical values in the graph i.e.
isnull elecountandincrementwhich is the amount by which the capacityof the vector is automatically incremented when its sizebecomes greater than its capacity inherited from the vectorclass.
next the refiner tries to generate a divider whichseparates the abstractedo from that ofo .a s s u m et h a to contains two object states and the abstractedo is aset a bracketle t0 a bracketri ht a bracketle t0 a bracketri ht where a bracketle t0 a bracketri htdenotes a stack objectwhich is not null i.e.
means thatisnullis false withelecountbeing and withincrementbeing .
assume thatthe abstractedo is a bracketle t0 a bracketri ht a bracketle t0 a bracketri ht .s v mfi n d sad i v i d e rreceiver.elecount .n o t i c et h a ti ft h e r ed o e sn o te x i s talinear divider the refiner refines the abstraction ofo ando by using numerical values from next level in the graph i.e.
isnullfordataandlengthofdata a n dt r i e sa g a i nt ofind a divider.
intuitively the reason that we look for a dividerlevel by level is that we believe that the reason why callingt h esame method leads to different results is more likely relatedto the values of variables directly defined in the class and lesslikely nested in its referenced data variables.the other scenario where the refiner is consulted is with acandidate querycand a set of executions which end in thesame state inc.f u r t h e r m o r e e x t e n d i n gt h ee x e c u t i o n sw i t hamethod call corresponding to an eventewould result in failureor success.
similar to the case of a membership query for eachexecution we obtain a pair o p whereois the object stateof the main instance prior to the last method call and pisthe arguments of the last method call.
similarly we collecttwo sets of those pairso from those successful executions algorithm 1l algorithm with lazy alphabet refinement letp e a bracketle t a bracketri ht fore a bracketle t a bracketri ht do3 updatetbyqm e ifeneeds to be splitthen5 split e p e t whiletruedo7 whilethere existstr a bracketle te a bracketri htwheretr pande suchthattr a bracketle te a bracketri ht e atio slash tr primefor alltr prime pdo8 p p tr a bracketle te a bracketri ht for do10 tr prime prime tr a bracketle te a bracketri ht a bracketle t a bracketri ht11 updatetbyqm tr prime prime ifthere is somee prime needs to be splitthen13 split e prime p e t construct candidate typestatecfrom p e t ifqc c 1then16 returnc17 else18 ifthere is somee prime needs to be splitthen19 split e prime p e t v ws ce ceis a counterexample21 e e v fortr pande do23 updatetbyqm tr v andqm tr a bracketle te a bracketri ht v ifthere is somee prime needs to be splitthen25 split e prime p e t ando from those failed executions .
afterwards svm isinvoked to generate a divider for alphabet refinement.c.
the learnerthe learner drives the learning process and interacts withboth the tester and refiner.
it uses an algorithm which extendsthe l algorithm with lazy alphabet refinement.in general a typestate for a program often requires moreexpressiveness than dfa and therefore the l algorithm itselfis not sufficient.
we solve this problem by extending the l algorithm with lazy alphabet refinement i.e.
by introducingpropositions on object states into the alphabet.
the detailso nthe extended l algorithm are presented in the following.
l with lazy alphabet refinement when the refinergenerates a divider a ne v e n te which is the event callingsome method under certain condition is effectively dividedinto two eand e.w i t ham o d i fi e da l p h a b e t p r e v i o u slearning results are invalidated and therefore learning needsbe re started.
however re starting from scratch is costly a swe often need multiple rounds of alphabet refinement.
in thefollowing we show how to extend the l algorithm with lazyalphabet refinement so as to re use previous learning resultsas much as possible.algorithm shows the pseudo code of the l algorithmwith lazy alphabet refinement whereqm tr denotes themembership query with the tracetrandqc c denotes the437algorithm 2split e p e t let be divider given by the refiner to refinee2 e e e ifp porq ehas a substring a bracketle te a bracketri htthen4 splitpintop1andp2such thatp1has the substring eandp2has the substring e5 splitqintoq1andq2such thatq1has the substring eandq2has the substring e6 updatetbyqm pi qi for alli end if angbracketleft angbracketright angbracketleft angbracketright angbracketleftpush angbracketright angbracketleft pop angbracketright angbracketleft pop angbracketright angbracketleft pop push angbracketright angbracketleft pop push angbracketright angbracketleft pop pop angbracketright angbracketleft pop pop angbracketright 0fig.
.
the observation table generated by the lazy l algorithm.candidate query of a typestatec.t h e r ea r et w oc a s e sw h e r ethe alphabet refinement takes place when a membershipquery triggers the generation of a divider lines5 which means that some alphabete needs to be split into eand e i tc a l l sa l g o r i t h m2t or e fi n et h ea l p h a b e ta n dupdate the corresponding results of the membership queries.
a candidate query may also trigger the generation ofad i v i d e r line19 .
if so algorithm is also called torefine the alphabet and update the corresponding results ofthe membership queries in the observation table.we use the stack example to illustrate the new algorithm.initially the alphabet is push pop .a f t e ras e r i e sof memberships algorithm constructs the first candidatetypestate as shown in fig.
b based on the closed andconsistent observation table shown in fig.
a .
a candidatequery for the first typestate is performed and the refinerreturns a propositionelecount 1for the positive coun terexample a bracketle tpop a bracketri ht.t h ee v e n tpopis split into two events popand pop a n dt h el learn ing process is restarted from the scratch.
without lazy alphabetrefinement all the membership queries over the new alphabet prime push pop pop haveto be queried as shown in the observation table in fig.
.however with lazy alphabet refinement only the membershipqueries marked with a symbol have to be queried.
in thissmall example only two membership queries are reduceddue to the small alphabet size.
in real world examples thesize of alphabet is usually big and the number of reducedmembership queries is significant.
the final typestate learnedby algorithm is the same as the one shown in fig.
b .iv .
tzuyuimplementationwe have implemented the approach in a tool named tzuyu which has more than 20k lines of java code.
in this section wediscuss the challenges in implementing the proposed methodand how we have addressed them.we first employ reflection to collect relevant informationlike fields and methods of each class so as to construct a numer ical value graph for each class.
the graph of a type depends onthe referenced types and hence it may reference many types but not all referenced types are useful for generating dividers.therefore we filter classes such asthread exceptionandhigh level interfaces such asserializable.t h ep u b l i cm e t h o d sdefined in the target class identify the initial alphabet forthelearner.
afterwards the learner starts to generate membershipqueries and candidate queries according to algorithm .given a membership query the tester checks whether itsabstract trace is feasible or not by generating a number which is configurable of executions and uses reflection torun them.
during execution the tester saves the runtime statesof the arguments of each method.
for argument generation we develop a just in time approach i.e.
generate the requiredarguments just before executing a method.
some of the chosenarguments may fail the guard condition and then we chooseanother argument which can pass the guard condition.
if thereis no argument satisfying the condition we generate anotherset of arguments until the guard condition evaluates to true or a bound is reached .
we don t present the just in timealgorithm here due to space limitation.
informally an argumentcan be obtained from three sources i.e.
randomly generatedfrom a set of pre defined type compatible values selected fromexisting executions that generate type compatible variables or selected from type compatible out referenced variablesgenerated by the current execution.
the above recursive argu ment generation procedure may not terminate for a recursiveconstructor which has a parameter of the same class in whichthe constructor is defined.
we set a maximum call depth forthe recursive constructor as did by linet al.
.before executing each method call we store the object statesof the receiver and the arguments as an instrumented state.
weremark that using the java standardclonemechanism to saveobject states is infeasible because the class may not implementserializableorcloneableinterface.
we thus implement amockup mechanismsimilar to the standard clone mechanism injava to save the runtime object into a mockup object whosetree like class structure resembles the class structure of theoriginal object.
the mechanism differs from the standard clonemechanism in that only primitive type values of the object aresaved.
for reference type field we construct another mockupobject as its saved value.
these mockup objects can be usedby the refiner.
when the real object is needed for instance togenerate a new test we record the exact sequence of statementswhose execution creates the object that can then be used to clone the arguments later by re executing them.given a candidate query the tester generates a numberof tests from the typestate.
the default number which isconfigurable is twenty multiplied with the maximum length oftraces generated in membership queries before this candidatequery.
each testing trace is generated by depth first randomwalking on the typestate up to a fixed length the length of thetrace is set to two plus the maximum length of traces generatedduring membership queries.
due to randomness in random438table ithe runtime statistics fortzuyur u n n i n gt h et a r g e tc l a s s e s target class loc method ttotal mq cq trace tc svm tsvm alphabet state java.util.stack example.boundedstack java.io.pipedoutputstream example.pipedoutputstream example.signature testing and random walking a test case generated previouslymay not appear again later.
to ensure the learning processis improving always and hopefully converging we store allthe generated test cases so as to provide consistent answers.notice that we do not store the instrumented states of the testcase to reduce memory consumption and we re execute thetest case to create the states when they are needed e.g.
toevaluate the guard conditions .one key step in our approach is to automatically generate adivider for alphabet refinement.
we use the svm techniquesimplemented in libsvm .
the first problem with usingsvm is how to choose a good hyperplane as there are intheory an infinite set of hyperplanes which separate two setsof object states.
the second problem is that the hyperplanediscovered by libsvm often has float coefficients which areoften not as readable as integer values when we use themto build the typestate.
thus we always if possible chooseinteger coefficients which constitute a hyperplane which liesbetween the strongest and weakest hyperplane.
further weimplemented a few heuristics to preprocess the inputs tolibsvm for generating a better divider.
firstly we balancethe positive and negative input data sets by duplicating datarandomly chosen from the smaller set of the two as svmtends to build biased hyperplanes when the input data set isimbalanced.secondly because the arguments of method calls are gen erated randomly libsvm may generate an incorrect divider.for instance given a bounded stack with a size bound ifpush element is invoked withelementfrom whenthe bounded stack is full whereas it is invoked withelementin when the bounded stack is not full.
libsvmmay generate a dividerelement 4suggesting that callingpush element with an input less than will lead to failure.this is obviously incorrect.
the problem is avoided with crossvalidation by checking whether the argument really affectstheexecution results.
this is done by executing the successful failed respectively traces whose arguments are substitutedwith arguments in the failed successful respectively traces.for instance in the above example additional test cases aregenerated so that every invocation ofpush element is testedwith the same set of input values i.e.
.a saresult if the argument is irrelevant to the execution result itwill be ruled out by cross validation.v.
eva l uat i o nin this section we first evaluate tzuyu on a set of javalibrary classes selected from the jdk and then compare tzuyuwith existing tools.
all the experiments were carried out onaubuntu .
pc with .
ghz intel core i7 duo processorsand gb memory.
all the experimental data is available inour web site .the selected jdk classes also used in previous relatedpapers are shown in table i. columnlocis thesize of the class in terms of lines of code.
column methodis the number of methods excluding the constructors of thetarget class which are defined in the target class and usedto generate the initial alphabet.
in this set of experiments we generate two values for each parameter in each method.to get a numerical vector from an object state for svmconsumption we limit the numerical value graphs to its topfive levels which we found to be sufficient.a.
resultstable i also shows the statistics of the experiments.
columnttotalis the total time used in milliseconds.
the subsequentthree columns show details about the l algorithms.
column mqand cqare the number of membership queries andcandidate queries respectively.
column traceis the totalnumber of abstract traces generated from random walking.column tc is the number of positive concrete test casesgenerated by tzuyu.
column svmandtsvmare the totalnumber of svm calls and the time in milliseconds taken bysvm to generate dividers respectively.
the last two columnsshow the size of alphabets and the number of states in thefinal dfa respectively.the following observations are made based on the experi mental results.
firstly tzuyu successfully learned typestatesin all cases in seconds.
furthermore in most cases the timetaken by svm is less than of total time except forjava.io.pipedoutputstreamwhere the cross validation in orderto determine whether a method parameter is relevant in asvm call consumes a few seconds.
secondly all learnedtypestates are sound and complete which we confirm bycomparing the learned one with the manually constructedactual one.
thirdly the number of states in the learnedtypestate is minimum i.e.
two as we are differentiating twostates only failure or non failure.
this implies that for everymethod whether invoking the method leads to failure or notcan be determined by looking at the value of the data variables and further svm is able to identify a suitable propositionevery time.
lastly we did not record the memory consumptiondue to the garbage collection feature of jvm.
however thememory consumption is relatively small since we did not storethe instrumented states with the test cases and the number of439table iiprogram invariants generated bydaikon psyco andtzuyu method daikon psyco tzuyu java.util.stack.pop elementcount java.util.stack.peek elementcount example.boundedstack.push integer size one of size example.boundedstack.pop size one of size java.io.pipedoutputstream.connect snk sink null snk negationslash null snk.connected false java.io.pipedoutputstream.write int sink negationslash null example.pipedoutputstream.connect snk sink null snk negationslash null snk.connected false sink null snk negationslash null snk.connected false sink null snk negationslash null snk.connected false example.pipedoutputstream.write sink negationslash null snk negationslash null sink negationslash null example.signature.verify signature.verify state state example.signature.sign signature.sign state state state example.signature.upate signature.sign state state test cases is relatively small which is linear in the number ofcandidate queries.b.
comparison with related toolswe identified three closely related tools.
psyco isas y m b o l i ce x e c u t i o nb a s e dt y p e s t a t el e a r n i n gt o o l a d abu is a dynamic behavior model mining frameworkand daikon is a dynamic invariant generator.
we comparetzuyu with them in terms of time and the quality of thegenerated models.
table ii shows the results of the invariantsgenerated by the three tools and tzuyu.
notice that psycoisnot available at the time of writing we thus only obtain thelearned typestate documented in their paper .we first compare the learned models as shown in table ii.the invariants generated by adabu are state invariants andthey are omitted from table ii.
methods with the trivialtrueinvariant e.g.
size instack a r ea l s oo m i t t e d .b o t hadabu and daikon need test cases as input to mine modelsand therefore we use the test cases generated by tzuyu astheir input for a fair comparison.
the number of generatedtest cases for each class is shown in the tc column oftable i. neither adabu nor daikon is able to learn modelsfor all of the classes.
for instance neither mined models forthejava.io.pipedoutputstreamclass.
adabu often generatesmultiple e.g.
dozens of models for one class which meansadabu s state abstraction techniques failed to generate agood invariant.
the reason is that adabu employs a setof pre defined templates to generate invariants.
if a minedstate invariant contains irrelevant variables adabu s stateabstraction and model merging technique fails and thereforeno unified model is generated.
daikon failed to mine modelsforjava.util.stackclass.
both adabu and daikon use pre defined invariant templates.
in comparison the typestates which are invariants generated by tzuyu are better becausetzuyu does not rely on templates but rather uses svmtechniques to discover propositions dynamically based onthe object states.
furthermore daikon uses only successfulexecutions whereas tzuyu uses both successful and failedexecutions thus the model learned by tzuyu is more accuratethan the one generated by daikon.01000200030004000500060007000time ms tzuyuadabudaikon fig.
.
time consumed in milliseconds to mine models for target classes.forexample.pipedoutputstreamandexample.signature psyco can learn accurate transition guards due to thefact that it encodes all path conditions in the source codeand uses an smt solver to exactly find out whether failurehappens.
however psycois limited by the capability of thesmt solver.next we compare the execution time of each tool onmining the models briefly.
the time taken by each tool tomine the models is plotted in fig.
.
psycois not availablefor running the target classes we cannot get the time forit.
both adabu and daikon need test cases while tzuyugenerates the test cases so we only include the time consumedby svm for tzuyu.
the figure shows that tzuyu oftenuses less time in generating the models.
an exception isthejava.io.pipedoutputstreamclass for the reason mentionedabove.c.
limitations of tzuyufirstly because our approach is based on testing there isno guarantee that the learned typestate is sound or complete.however this can be fixed to certain extent by using an smtsolver to verify the learned typestate.
for instance the types tate for stack in fig.
b can be verified by showing that eachtransition is sound and complete e.g.
the self looping transi tion at state labeled with popcan be verified440by proving two hoare triples elecount pop noerror executingpopwith a pre conditionelecount 1will notlead to error and elecount pop error .f u r t h e r i ft h esmt solver identifies a counterexample the counterexamplecan be used to refine the typestate.secondly because our approach is based on random testing there is no guarantee that a good divider can be discoveredin general though it should emerge in theory after sufficienttesting.
this can be partially fixed if we can obtain better test cases through different means e.g.
from real executionhistory of the given class or through more sophisticatedtest case generation methods like concolic testing andcombinational testing .thirdly our method will not terminate if the typestate forthe class under analysis is beyond the expressiveness of finite state machines with linear guard conditions.
if the refiner failsto find a divider for a membership query with conflictingresults i.e.
the same sequence of events leads to failure andsuccess a counterexample i.e.
a path which is predicatedto fail by the typestate but succeeds in real testing execution or the other way round is returned so that l may introducean e ws t a t e .i nt h ew o r s tc a s e t z u y uw i l lk e e pg e n e r a t i n gtypestates with ever growing number of states and eventuallytimes out .
this is due to the limitation of svm that could beovercome using advanced learning techniques.vi.
relatedworkour approach is related to specification mining.
we referinterested readers to the book by loet al.
for a compre hensive literature review.
therefore we only review previouswork that is closely related to the three components in tzuyuand the overall approach.the idea of using testing as the teacher for l algorithm isalso found in the amc approach which uses l to handlecounterexamples returned by the model checker.
the l algo rithm is also used for learning assumptions in compositionalverification by formal methods community.tzuyu differs from these work in that it uses l algorithm tolearn the specification from source code.the idea of learning interface specifications from sourcecode was proposed by aluret al.
which learns interfacespecifications from source code automatically by using amodel checker as the teacher.
the psycotool achievesthe same goal by using a symbolic execution engine as theteacher.
the x psyco tool extends psycoby answeringmembership and candidate queries with testing under inputsgenerated from symbolic execution.
in comparison tzuyuemploys testing and thus avoids expensive model checking orsymbolic execution.
similarly aartset al.
proposed a fullyautomated data abstraction technique to learn a restrictedformof mealy machine in which only testing equality of argumentsis allowed.
tzuyu s svm based alphabet refinement can beapplied to more programs.our testing strategy is related to randoop .
we extendrandoop to the context of learning in which the receiver objectmust be the same in order to learn a better model and wealso add a new source for reference arguments which canbe chosen from an out reference variables to improve datacoverage.
tester in tzuyu is also related to tautoko which generates more test cases by mutating existing tracesinthe mined model by using adabu to augment the modellearning process as well as finding bugs.we extend the active learning l algorithm with lazy alpha bet refinement.
there are also other learning algorithms suchas sk strings algorithm .
the sk strings algorithm passivelylearns a dfa from a given set of traces by generalizing themethod call sequences in the trace to form the final dfa.adabu can be classified as a passive learner whichrequires a set of test cases as input it abstracts the concretestates with simple templates to abstract states thus to get theabstract traces and then it merges models from abstract tracesto generate a model.
the combination of an active learningalgorithm with automatic argument generation techniques en ables tzuyu to learn stateful typestates automatically.the refiner in tzuyu is inspired by sharmaet al.
who use svm and smt solver to generate interpolants forcounterexamples produced by model checkers.
the goal of therefiner is in line with that of the dynamic invariant generatordaikon and axiom meister .
daikon uses a set ofpre defined invariant templates over data from the set of givenruntime traces.
daikon may find some irrelevant invariants atap r o g r a mp o i n t .a x i o mm e i s t e ru s e ss y m b o l i ce x e c u t i o nt ocollect all the path conditions which are then abstracted intopreconditions.
tzuyu s refiner is based on svm which enablestzuyu to find relevant linear arithmetic propositions over alarge number of variables.vii.
conclusion andfutureworkdespite the recent progress on learning specifications fromvarious software artifacts the community is still challengedwith difficulties in dealing with data abstraction for commonprograms.
in this paper we propose a fully automated typestatelearning approach from source code.
to fully automate thegeneration of test cases which are the required inputs formany automata learning tools we combine the active learningalgorithm l with a random argument generation technique.we then use a supervised machine learning algorithm i.e.
the svm algorithm to abstract data into propositions.for the future work we want to use symbolic execution toensure that the learned model is sound and try other machinelearning techniques in order to generate better dividers.
wealso want to evaluate the effectiveness of different test casegeneration techniques in learning setting.acknowledgementswe thank the anonymous reviewers fortheir invaluable comments.
this work is partially supportedb yntu nap project formal verification on cloud and trfproject research and development in the formal verificationof system design and implementation .
this work is alsosupported by project idd11100102a idg31100105a fromsingapore university of technology and design.441references f. aarts f. heidarian h. kuppens p. olsen and f. vaandrager.
au tomata learning through counterexample guided abstractionr e fi n e m e n t .infm p a g e s1 .
m. acharya t. xie j. pei and j. xu.
mining api patterns asp a r t i a lorders from source code from usage scenarios to specifications.
inesec fse p a g e s2 .
r. alur p. madhusudan and w. nam.
symbolic compositional verifica tion by learning assumptions.
incomputer aided verification v o l u m e3576 oflecture notes in computer science p a g e s5 .s p r i n g e rberlin heidelberg .
r. alur p. cern p. madhusudan and w. nam.
synthesis of interfacespecifications for java classes.
inpopl p a g e s9 .
g. ammons r. bod k and j. r. larus.
mining specifications.
inpopl pages .
d. angluin.
learning regular sets from queries and counterexamples.inf.
comput.
n o v .
.
h. barringer and d. giannakopoulou.
proof rules for automated com positional verification through learning.
inin proc.
savcbs workshop pages .
c. c. chang and c. j. lin.
libsvm a library for support vectormachines.acm trans.
intell.
syst.
technol.
.
t. chow.
testing software design modeled by finite statemachines.software engineering ieee transactions on s e .
k. claessen and j. hughes.
quickcheck a lightweight tool for randomtesting of haskell programs.
inacm sigplan notices p a g e s2 .
v .
dallmeier n. knopp c. mallon s. hack and a. zeller.g e n e r a t i n gtest cases for specification mining.
inissta p a g e s8 .
v .
dallmeier c. lindig a. wasylkowski and a. zeller.mining objectbehavior with adabu.
inwoda p a g e s1 .
c. damas b. lambeau p. dupont and a. van lamsweerde.
generatingannotated behavior models from end user scenarios.ieee trans.
softw.eng.
d e c .
.
m. d. ernst j. h. perkins p. j. guo s. mccamant c. pacheco m. s.tschantz and c. xiao.
the daikon system for dynamic detection oflikely invariants.
inscience of computer programming .
d. giannakopoulou z. rakamaric and v .
raman.
symbolicl e a r n i n gof component interfaces.
insas p a g e s2 .
a. groce d. peled and m. yannakakis.
amc an adaptive modelchecker.
in e. brinksma and k. g. larsen editors cav v o l u m e2 4oflecture notes in computer science p a g e s5 .s p r i n g e r .
j. e. hopcroft and j. d. ullman.introduction to automata theory languages and computation.a d d i s o n w e s l e y .
f. howar d. giannakopoulou and z. rakamaric.
hybrid learning interface generation through static dynamic and symbolica n a l y s i s .i nissta p a g e s2 .
k. ji y .
liu s. w. lin j. sun j. s. dong and t. k. nguyen.
cell ac o m p o s i t i o n a lv e r i fi c a t i o nf r a m e w o r k .
i natva .
t oa p p e a r .
r. kuhn r. kacker y .
lei and j. hunter.
combinatorialsoftwaretesting.computer .
d. lee and m. yannakakis.
principles and methods of testing finite statemachines a survey.proc.
of the ieee .
s. w. lin .
andr j. s. dong j. sun and y .
liu.
an efficientalgorithm for learning event recording automata.
inatva p a g e s4 .
s. w. lin and p. a. hsiung.
counterexample guided assume guaranteesynthesis through learning.ieee transactions on computers .
s. w. lin y .
liu j. sun j. dong and .
andr .
automaticc o m p o s i tional verification of timed systems.
infm p a g e s2 .
.
y .
lin x. tang y .
chen and j. zhao.
a divergence oriented approachto adaptive random testing of java programs.
inase p a g e s2 .
d. lo k. cheng and j. han.mining software specifications method ologies and applications.c h a p m a n a n d h a l l c r c d a t a m i n i n g a n dknowledge discovery series.
taylor francis group .
m. g. nanda c. grothoff and s. chandra.
deriving objectt y p e s t a t e sin the presence of inter object