maintaining invariant traceability through bidirectional transformations yijun yu1 yu lin2 zhenjiang hu3 soichiro hidaka3 hiroyuki kato3 and lionel montrieux1 1department of computing the open university milton keynes united kingdom 2department of computer science university of illinois at urbana champaign usa 3national institute of informatics tokyo japan abstract following the convention over configuration paradigm model driven development mdd generates code to implement the default behaviour that has been specified by a template separate from the input model reducing the decision effort of developers.
for flexibility users of mdd are allowed to customise the model and the generated code in parallel.
a synchronisation of changed model or code is maintained by reflecting them on the other end of the code generation as long as the traceability is unchanged.
however such invariant traceability between corresponding model and code elements can be violated either when a users of mdd protect custom changes from the generated code or when b developers of mdd change the template for generating the default behaviour.
a mismatch between user and template code is inevitable as they evolve for their own purposes.
in this paper we propose a two layered invariant traceability framework that reduces the number of mismatches through bidirectional transformations.
on top of existing vertical model code synchronisations between a model and the template code a horizontal code code synchronisation between user and template code is supported aligning the changes in both directions.
our blinkit tool is evaluated using the data set available from the cvs repositories of a mdd project eclipse mdt gmf.
i. i ntroduction aiming at productivity convention over configuration is a software design paradigm meant to reduce the decision effort of developers while preserving flexibility.
following this paradigm model driven development mdd of software projects e.g.
eclipse modeling framework emf generates code from models to implement the default behaviour which was specified by a template separate from the input model.
as users of mdd programmers are allowed to customise the generated code and the modellers are allowed to modify the models further.
to support the eventual round trip synchronisation of model and code markers for traceability correspondence e.g.
generated are inserted at the beginning of the generated methods by mdd indicating to the programmers that all changes to the model and the template will be reflected by the annotated method.
in other words any change made by programmers on such methods will get lost after another round of code generation.
in order to protect such changes in the user code from getting lost programmers are allowed to modify the generated marker to generated not instructing the code generators to skip the user specified methods.
this technique is common in mdd practice for another example the acceleo model2text project uses ... annotations to enclose user specified parts for arbitrary textual outputs.
to illustrate its problematic use in development we use emf the eclipse modeling framework emf as an exemplar mdd framework the template code is generated by emf first later refined manually into functioning user code.
once programmers change the model and regenerate the template code its traceability to the user code becomes necessary.
ideally a round trip engineering approach should support the correct propagation of changes in both directions .
current state of the art mdd tools such as emf maintain the synchronisation of model and code by reflecting changes in both directions.
however such invariant traceability links between corresponding model and code elements can be easily violated either when a users of mdd protect custom changes from the generated code by changing generated to generated not or when b developers of mdd change the template for generating the default behaviour for those generated methods losing all users change s .
in either case a better solution would be to preserve the changes made by the users as well as the changes made on the model as long as they are consistent.
in section iii a detailed example will illustrate the problems such a mismatch can cause.
we consider in this paper that the mismatch problem between user modified and template generated hereafter user and template codes is inevitable as they evolve for their own purposes and propose a two layered invariant traceability framework that merges the changes when possible through bidirectional transformations.
the first layer of the framework synchronises the structural changes between the model and the template code at the api level vertically denoted by model code using existing state of the art mdd tools such as emf the second layer synchronises the behavioural changes between the template code and the user code inside the method bodies horizontally denoted by code code if users wish to preserve both types of changes.
aligning these changes in both directions our blinkit tool is evaluated using the data set available from the cvs repositories of the eclipse mdd projects emf and gmf.
to effectively use the invariant traceability framework users only need to insert a traceability annotation generated inv instructing the code generator to au see a compute the differences between the current template and user modified methods and b derive a bidirectional transformation for future code generation to reflect changes of the model or changes of the template back to the users methods.
the tool raises warnings when there are inconsistencies between the template and the user code.
a prototype has been successfully applied to changes recorded in the evolution of the gmf framework from its cvs repository which shows that our new approach of round trip engineering is promising and potentially useful in practice.
fig.
presents an overview of blinkit when it is applied to the case study of emf gmf where emf is the synchronisation framework for vertical traceability andblinkit is the horizontal synchronisation counterpart.
examples indicate that when the complementary changes to templates and user modified code are conflicting or redundant our tool can avoid some dead code redundancies and raise some warnings as compilation errors.
our major technical contributions are listed as follows from a user s perspective a new type of annotations generated inv is supported as explicit markers for automatic maintenance of invariant traceability between template generated and user generated not code whereas generated not marked methods only keep user s change while ignoring changes made to the model.
a novel algorithm is proposed for automatically generating a one pass bidirectional transformation from the meaningful differences between the template code and arbitrarily modified user code such that the round trip relation between the structures of the model and the code can be correctly maintained.
an empirical study is done on a cvs repository of the state of the art mdd project gmf highlighting thebenefits of maintaining invariant traceability links especially when there are changes to the model parts have impact on the bodies of of the revisions of methods marked by generated not .
compared to existing mdd and traceability approaches blinkit derives invariant transformations automatically from meaningful changes in the source code .
unlike our initial work that proposes to apply bidirectional transformations directly on class diagrams and java code this work takes full advantages of the state of art synchronisations of many to many vertical traceability links between the model and the template code such that the horizontal bidirectional transformations are applied only to the method bodies relevant to the user modified behaviours.
since the template and the user method code are at the same level of abstraction blinkit is allowed to derive a forward transformation from the user method to the generated method.
our initial work needs to monitor the execution logs of userspecified atl transformations which is no longer needed.
cvs gmf generated elements emf generated v2 v1 modeling elements emf model v2 v1 user modified elements emf generated inv v2 v1 horizontal bidirec2onal sync.
ver cal sync.
emf figure .
an overview of the horizontal and vertical traceability links in the bidirectional invariant traceability framework blink .
v1 and v2 are two revisions of model template or user codes extracted from the cvs repository of a software development project using emf code generation.
the remainder of this paper is organised as follows section ii gives preliminary knowledge on emf and introduces the bidirectional transformation mechanism.
section iii provides one example to illustrate the synchronisation problem of invariant traceability.
section iv overviews the round trip process for horizontal and vertical invariant traceability and indicates the position of blinkit in the overall process.
section v describes the technical details of blinkit the generation of bidirectional transformations from meaningful changes and the one pass optimisation for efficiency.
section vi presents the observations of the cvs evolution history of the gmf project to show the number of cases where the generated inv markers can be useful.
section vii compares related work section viii concludes.
ii.
b ackground a. emf as a state of the art mdd framework the eclipse modeling framework emf is a mdd framework and a code generation facility for building eclipse tools and other applications around a structured model.
from a meta model specified in xmi or xml schema emf generates default i.e.
template eclipse plugin tools that consist of java classes for manipulating a model along with java adapter classes for viewing and editing a model.
from a rather complex meta model it is impractical to generate all source code because programmers may customise the default behaviour by modifying some parts of the code in order to achieve their own goals.
using emf the template code is generated first and later refined manually into functioning user code.
once programmers change the model and regenerate the template code it brings the necessity of the traceability to and from the user code.
the mdd part of the emf consists of one code generation component i.e.
jmerge to generate source code from a meta model i.e.
.ecore .
the template used by the code generator is specified in the javajet template language similar to that of jsp which will bind the template variables1 2a b 4c 5a a c 6dfigure .
a simple rooted and edge labelled graph with the default values specified in the corresponding .genmodel configuration files.
there is no one to one mapping between a class operation to a java method in this code generation a class in the class model can be implemented in multiple classes in the model impl util edit and editor packages scattered across the generated model edit editor and test plugins.
in addition there will bepackage andfactory classes created and instantiated by the classes in the model.
it is hard to maintain such manyto many relations using traditional traceability techniques.
note that emf is used in this study both as a subject matter as part of the mdt case study as well as a component of our solution.
parts of the emf tool were generated using the emf code generator as well.
it can be seen from the existing emf implementation that developers marked some methods as generated not to preserve the changes that cannot be generated from the ecore models alone.
it can therefore be expected that the code generated from emf will be modified by users.
b. bidirectional transformation we use groundtram to do bidirectional graph transformations.
this well behaved framework guarantees the round trip property in bidirectional model transformations.
a model transformation is described in unql an extension of the sql like graph query language unql with three graph update constructs to achieve efficiency and expressiveness namely replacing deleting and extending.
the model transformation is then desugared to the core algebra uncal which consists of a set of constructors for building graphs and a powerful structural recursion for manipulating graphs.
this graph algebra can have clear bidirectional semantics and be efficiently evaluated in a bidirectional manner .
graphs models in unql are rooted and edge labelled i.e.
all information is stored as labels on edges rather than on nodes and the labels on nodes have no particular meaning and represented in uncal or the standard dot format which can be visualised and edited by the popular graphviz tool .
to illustrate unql consider a simple graph db the root is the node in fig.
.
we can select the subgraph pointed by the edge labelled bfrom the root by select gwherefb ggin db delete the subgraph rooted at node 5reached by b aby delete b a!
in db and insert a subgraph gunder the node reached from the patha aby extend a a!
with gin db iii.
a m otivating example to illustrate the problem concretely we use a constructed example here.
suppose an emf user initially specifies a simple model that consists of one entity class with a single name attribute.
using the code generation feature of emf she will obtain a default implementation which consists of compilation units in java .
figure .
default code generated from the emf meta model fig.
lists parts of the generated code.
the entity java interface has getter and setter methods for the name attribute.
they are commented with generated annotations which indicate that the methods are part of the default implementation.
similarly such generated annotations are added to every generated element in the code e.g.
shown in the skeleton of entityimpl java class.
the annotation generated defines a single trip traceability contract from the model to the annotated code element.
a change in the model or a change in the modelling framework can be propagated to the generated code however a change on the generated code will not cause a change to the reflected model and will thus be discarded upon next code generation.
because the default implementation is not always desired the code generation shall keep user specified changes as long as they are not inside the range of generated traceability the set of methods marked by generated that keeps the changes of generated templates.
this can be achieved by adapting the generated annotation into generated not a non binding traceability that reflects programmers intention that it will not be changed when the implementation code is regenerated.
note that such nonbinding traceability indicated by generated not is still different from those without any annotation at all without such an annotation emf will generate new implementation of a method body following the templates.1package example 2import org .
e c l i p s e .
emf .
e c o r e .
eobject model 4p u b l i c i n t e r f a c e e n t i t y extends eobjectf model p u b l i c s t r i n g getname generated void setname s t r i n g v a l u e 7g 1package example .
impl 2import example .
e n t i t y .
.
.
generated 5p u b l i c c l a s s e n t i t y i m p l extends eobjectimpl implements e n t i t yf .
.
.
generated p r o t e c t e d s t r i n g name name edefault .
.
.
generated p u b l i c s t r i n g getname freturn name g generated p u b l i c void setname s t r i n g newname f. .
.g .
.
.
generated override p u b l i c s t r i n g t o s t r i n g f i f e i s p r o x y return super .
t o s t r i n g s t r i n g b u f f e r r e s u l t new s t r i n g b u f f e r super .
t o s t r i n g r e s u l t .
append name r e s u l t .
append name r e s u l t .
append return r e s u l t .
t o s t r i n g 24g 25g e n t i t y i m p l figure .
parts of the generated code in fig.
this workaround is not ideal.
if a user parametrises the tostring method to append an additional type to the returned result.
to guard the method from being overwritten by future code generations the annotation generated not is used.
she also applies a rename method refactoring changing the getname method into getid .
the modified parts are shown in fig.
.
propagating these changes back to the model the name attribute will be renamed into id automatically following the naming convention that attribute identifiers start with a lower case character.
the regeneration of the code will result in the changes in fig.
the setter methods and the implementations of both getter setter methods are modified according to the default implementation of the new model.
these are expected.
however two unexpected changes are not desirable.
first a compilation error results from the change in the default implementation where the attribute name used in the user controlled code no longer exists.
second the default implementation of the tostring method is generated with the original signature which will of course become dead code since the user has already modified all call sites oftostring to reflect the insertion of the new type.
similarly the user specified tostring method can also become dead code if it is no longer invoked by the new default implementation.
compilation errors are relatively easy to spot by the programmer with the aid of the eclipse ide but the dead1 model 2p u b l i c i n t e r f a c e e n t i t y extends eobjectf model p u b l i c s t r i n g g e t name id generated p u b l i c void setname 5g .
.
.
generated 8p u b l i c c l a s s e n t i t y i m p l extends eobjectimpl implements e n t i t yf generated p u b l i c s t r i n g g e t name id freturn name g .
.
.
generated not override p u b l i c s t r i n g t o s t r i n g string type f i f e i s p r o x y return super .
t o s t r i n g s t r i n g b u f f e r r e s u l t new s t r i n g b u f f e r super .
t o s t r i n g r e s u l t .
append name r e s u l t .
append name r e s u l t .
append result.append type return r e s u l t .
t o s t r i n g 22g 23g e n t i t y i m p l figure .
user modifications to the generated code insertions are underlined and the deletions are stroked out the changes are reflected code problems are more subtle because the ide will not complain.
therefore it will be more difficult for developers to notice the consequences.
ideally the user should be able to specify which parts of her changes to the code need to be kept rather than overwritten by code generation.
for this purpose a new annotation for invariant traceability generated inv will be used in our proposed approach.
as a result fig.
illustrates the changes to be propagated to users code after our approach of bidirectional transformations is adopted.
iv.
o verview of blinkit the prototype blinkitysupports our idea of maintaining the traceability of the user code and template code through bidirectional transformations.
fig.
gives an overview of the dataflow of the components inside blinkit .
dashed arrows represent the external changes made by developers or vertical synchronisations between models and template code whilst the open or close ended solid arrows represent forward and backward transformations respectively.
first developers define an original emf model and synchronise with the template code from the emf engine .
developers may modify the template code into user code to meet their requirements and mark some parts of their code with the generated inv annotation .
developers can change the model if needed and reyblinkit can be downloaded from model 2p u b l i c i n t e r f a c e e n t i t y extends eobjectf model p u b l i c s t r i n g getid generated p u b l i c void s e tname id 5g .
.
.
generated 8p u b l i c c l a s s e n t i t y i m p l extends eobjectimpl implements e n t i t yf generated p u b l i c s t r i n g getid freturn name id g .
.
.
generated public string tostring f if eisproxy return super.tostring stringbuffer result new stringbuffer super.tostring result.append id result.append id result.append return result.tostring g generated not p u b l i c s t r i n g t o s t r i n g s t r i n g t y p e f i f e i s p r o x y return super .
t o s t r i n g s t r i n g b u f f e r r e s u l t new s t r i n g b u f f e r super .
t o s t r i n g r e s u l t .
append name r e s u l t .
append name r e s u l t .
append r e s u l t .
append t y p e return r e s u l t .
t o s t r i n g 30g 31g e n t i t y i m p l figure .
regenerated code from the model insertions are underlined and the deletions are stroked out the compilation error is doubly underlined.
synchronise the code using emf .
note that without blinkit may lose developers modifications.
having the above steps performed by developers blinkit will generate a bidirectional transformation in the unql language by comparing the user code denoted byu0 and the original template code denoted by t .
the forward transformation uses this generated transformation.
we represent the code by specific graphs and compare the graphs to generate unql in section v a. to take the modified user code denoted by u0 as inputs which generates an intermediate code that will be the same as the template codet such that the trace information stored by the forward transformation can be applied to the corresponding backward transformation.
in the backward transformation the intermediate code tand the modified template code denoted by t0 are used as inputs and the output is the merged code1 model 2p u b l i c i n t e r f a c e e n t i t y extends eobjectf model p u b l i c s t r i n g g e t name id generated p u b l i c void setname 5g .
.
.
generated 8p u b l i c c l a s s e n t i t y i m p l extends eobjectimpl implements e n t i t yf generated p u b l i c s t r i n g g e t name id freturn name g .
.
.
generated inv override p u b l i c s t r i n g t o s t r i n g string type f i f e i s p r o x y return super .
t o s t r i n g s t r i n g b u f f e r r e s u l t new s t r i n g b u f f e r super .
t o s t r i n g r e s u l t .
append name r e s u l t .
append name r e s u l t .
append result.append type return r e s u l t .
t o s t r i n g 22g 23g e n t i t y i m p l model 2p u b l i c i n t e r f a c e e n t i t y extends eobjectf model p u b l i c s t r i n g getid generated p u b l i c void s e tname id 5g .
.
.
generated 8p u b l i c c l a s s e n t i t y i m p l extends eobjectimpl implements e n t i t yf generated p u b l i c s t r i n g getid freturn name id g .
.
.
generated inv p u b l i c s t r i n g t o s t r i n g s t r i n g t y p e f i f e i s p r o x y return super .
t o s t r i n g s t r i n g b u f f e r r e s u l t new s t r i n g b u f f e r super .
t o s t r i n g r e s u l t .
append name id r e s u l t .
append name id r e s u l t .
append r e s u l t .
append t y p e return r e s u l t .
t o s t r i n g 21g 22g e n t i t y i m p l figure .
the use of invariant traceability to propagate changes in the backward direction resulting in t0 u0.
denoted by t0 u0 which not only reflects the changes made to the model but also conserves the modifications applied by the developers in .
notice that the intermediate code is the same as the template code in our approach.
we do not substitute it by the template code because it separates the forward and backward transformation and makes the transformation process clearer.
v. i mplementation of blinkit we will illustrate the implementation of blinkit by first explaining the overall process then providing details for the critical steps for correctness and efficiency.original model template code t user modified code u modified model modified template code t unql transforma on merged code t u mct groundtram external changes forward transf.
backward transf.
optional check meaningful diff figure .
the data flows inside blinkit a. the overall process we use groundtramzto perform bidirectional transformations and to keep the traceability of the template and user method bodies.
groundtram adopts input graphs which are represented in uncal ordot format.
thus in order to perform bidirectional transformations on java code generated by emf through groundtram we first translate java code into uncal ordot i.e.
using uncal ordot to represent java source code .
when translating java code into uncal ordot we adopt the emf model as an intermediate representation of java code since emf model is much more navigable than specific abstract syntax trees and can be manipulated more easily.
after we get the uncal or dot graphs we can generate unql automatically and perform bidirectional transformations using groundtram .
to achieve such a round trip process our framework involves four engineering steps on either side of the forward backward directions to support the code code horizontal synchronisation between the evolving template and user code see fig.
.
without loss of generality in the following we denote the template generated and user modified codes as tandu0 the modified template codes as t0 and the merged code as t0 u0 respectively.
given that java codes t t0were generated and synchronised from the model using emf s built in vertical synchronisation with user s java codes u0except for those methods that are marked by generated inv we first parse all the generated inv methods in t t0 u0using the jamopp parser on top of the emftext frameworkx.
the differences between tandu0are obtained using the api of theemfcompare framework after the meaningful differences were preprocessed using mctk.
here the differences are a comprehensive representation of code rather than editing operations zsee xsee see ksee the emf models of t t0 u0are translated into our specific uncal graphs using ecore s reflection api and as a by product an unql transformation is generated from the meaningful differences between t andu0using the algorithm in fig.
the uncal graphs of t t0 u0are transformed into dot graphs by groundtram which preserves the paths from the graph root to any node on the uncal graphs in the equivalent dot graphs using the generated unql transformation and the dot graphs of u0as inputs the groundtram system also performs a forward transformation to output a group of dot graphs that represent t guaranteed by the one pass optimisation described in section v c backwards using the same unql transformation on thedot graphs of the modified template code t0 and the internal graph traceability between tandu0 kept by the forward transformations that performs a backward transformation to output the dot graphs that represent the merged user code denoted by t0 u0 path equivalent uncal graphs corresponding to t0 u0 are re generated from the resulting dot graphs an equivalent emf model of those uncal graphs fort0 u0is obtained using an xtext parser of uncal to process its abstract syntax using emf api finally the merged java code t0 u0is obtained from the emf model using jamopp s pretty print function.
since we have a txl based parser to generate dot graphs our presented technique is not limited to emf based external representations of java.
as long as a code generation framework for vertical synchronisation is available it will be possible to adapt our horizontal synchornisation framework.
however we do not intend to implement the vertical synchonisation baseline because it will be complex to maintain one to many traceability links invariant.
to apply our approach effectively one can initially attach inv to all generated java methods as a trivial identity bi transformation.
once an inconsistency warning is raised the marker can be modified to either generated or generated not incrementally in order to preserve template or user modified changes respectively.
users introducing generated inv are currently responsible for resolving the warnings.
figure .
the multi tier architecture of blinkit see generating correct unql transformations to enable the use of unql on mdd we need to make sure that translating the artifacts between the code theuncal graphs and node traced graphs such as graphviz dot does not lose information.
this can be done in a multitier fashion and one critical step is to guarantee the correctness of the horizontal code code synchronisation that is to generate a correct unql bidirectional transformation from the meaningful differences between the original template code and the modified user code.
function unqlg enerator dotuser dottemplate rootuser the root node of dotuser roottemplate the root node of dottemplate matchingdot rootuser roottemplate end function function matching dot nodeuser nodetemplate edgesetuser outgoing edges of nodeuser edgesettemplate outgoing edges of nodetemplate for all edgeuser2edgesetuser do flag false childnodeuser target node of edgeuser for all edgetemplate2edgesettemplate do ifedgeuser edgetemplate then flag true childnodetemplate the target node of edgetemplate matchingdot childnodeuser childnodetemplate end if end for ifflag false then deleteconstructor childnodeuser end if end for for all edgetemplate2edgesettemplate do flag false childnodetemplate target node of edgetemplate for all edgeuser2edgesetuser do ifedgetemplate edgeuser then flag true end if end for ifflag false then extendconstructor childnodetemplate end if end for end function figure .
procedure of generating unql we can then use the dot graphs as inputs to perform bidirectional transformations groundtram needs to use bidirectional transformations specified in the unql graph transformation language.
as we said in section iv unql is used in forward transformations to convert user code into intermediate code which is the same as template code.
weimplemented an algorithm shown in fig.
to generate the unql transformation automatically in order to mitigate developers burden.
after representing the java code that we want to synchronise using dot graphs we can compute the differences between the dot graphs and such differences can be used to generate unql automatically.
the unql generated by our approach only contains deleting and extending operations.
replacing operations can be replaced by a deleting and an extending operation.
theunqlgenerator algorithm starts node matching from the root in the dot graphs.
for each node pair we compare their outgoing edges labels.
if we find one edge which exists in the user s graph but does not exist in the template s graph that means deletion occurs and we will generate a deleting operation to delete the subgraph beneath the node under comparison lines in fig.
if the two edges have the same labels we will do node matching for their children recursively lines .
similarly for those edges that the template s graph has but the user s graph does not we need an extending operation lines .
for the extending operation we have to record the subgraph that needs to be inserted.
to generate unql transformation path information composed by edge labels is needed in order to denote which part should be deleted or inserted.
since the labels on the outgoing edges of one node are different from each other in our dot graphs such paths which reflect the changes between two dot graphs are unique.
we have to obtain such paths to generate unql transformation and the uniqueness of the paths guarantees the correctness of our unql generated algorithm i.e.
if there are two outgoing edges of a node with the same label this algorithm may not generate the desired unql transformation .
an example is shown to illustrate this algorithm .
we transform the graph shown in fig.
a into the one in fig.
d .
we have to delete the edge e gandsubgraph and insert the edge hand subgraph .
the algorithm first generate deleting operations which could transform fig.
a into fig.
b .
note that the deleting operations contain the deletion of subgraph and edge fthough they should not be deleted.
this is because when the algorithm deletes the edge g it will also delete its pointed subgraphs subgraph and the edges connected to those subgraphs edge f .
then when generating the extending operation the algorithm not only inserts the edge handsubgraph but also inserts the edge fandsubgraph again.
this extra deletion and insertion may reduce the transformation s efficiency and more efficient algorithms should be explored in the future work.
comparison algorithms for trees and graphs based on dynamic programming may be adopted.
c. derivation of a one pass transformation the automatically generated unql transformations are not optimal.
one performance bottleneck is that there are typically multiple pairs of different elements leading to multiple basic editing operations composed sequentially.
ideally s u b g r a p h a b c d e f g s u b g r a p h s u b g r a p h a b c d e f g s u b g r a p h a b c d f h a b c d f h a b c d d e l e t i n g e x t e n d i n g s u b g r a p h s u b g r a p h s u b g r a p h s u b g r a p h s u b g r a p h s u b g r a p h s u b g r a p h s u b g r a p h figure .
an example to illustrate the algortihm in fig.
these operations should be composed in parallel as one single graph transformation such that groundtram could obtain results in one pass of traversing the graph structure.
in theory the composition of general unql transformations has to be sequential.
however the transformations we obtained from the diff results have nice properties that make it possible to compose the basic operations in parallel without introducing any side effect.
the rationale is given below.
lete1 e2 e nbe a sequence of the editing operations obtained above where any two editing operations eiand ej are independent in the sense that neither insertion nor deletion is done on a previously inserted deleted part.
this can be formalised as 8i j ei ej ej eiholds.
we show that any editing sequence can be automatically transformed to a one pass traversal of graphs.
our algorithm consists of two steps we first map the editing sequence to composition of a set of graph transformations where each graph transformation corresponds to an editing operation and then try to fuse the composition into a single one pass graph traversal in terms of a structural recursion in uncal .
mapping from editing sequence to composition of graph transformations first each editing operation corresponds to a simple graph transformation in unql .
let p denote the path from the root to the node n i.e.
a sequence of edge labels from the root to the node n in the graph db.
then the editing operation e db for deleting a subgraph fl ggrooted at the node ncan be translated to e db delete p!fl ggin db and the edition operation e0 db for inserting a subgraph gto the node ntoe0 db extend p!
gwith gin db now a sequence of editing operations e1 e2 e ncorresponds to the composition of graph transformations of e1 db e2 db e n db that is e1 e2 en db fusion of composition of graph transformations groundtram provides a powerful fusion mechanism thatcan automatically fuse a composition of graph transformations into one so that unnecessary exchange of graph structures between the individual graph transformations can be saved.
we could apply this general fusion mechanism but we can do better based on the fact that each graph transformation is independent from each other.
thus we develop a specialised but more efficient fusion algorithm.
our idea is to construct an action tree from the editing sequence and then map the action tree to a one pass transformation.
for an action tree leaves are marked with two action markers d l andi g denoting respectively the deletion of a graph pointed by the edge lwhen possible and the insertion of a graph g. fig.
gives an example figure .
an action tree action tree which describes the intention of that composed transformation given a graph for the node reached by the path of a bdo deletion for the node reached by the path b ado deletion and for the node reached by the path b cdo insertion.
in fact an action tree is a tree automaton that can be mapped to a structural recursion in uncal that traverses graphs only once .
let us show that a sequence of editing operations can be represented by an action tree.
first it is clear that a single editing operation can be represented by a simple action tree which is actually a tree where each node has just a single child .
now given two action trees t1andt2 we can combine them to merge t1 t2 satisfying that any action in t1ort2appears in merge t1 t2 and any action in merge t1 t2 appears in t1ort2and there is no node that has two outgoing edges with the same labels.
the algorithm merge t1 t2 is defined as follows merge t2 t2 merge t1 t1 merge t1 t0 t2 merge t1 merge t0 t2 merge fl t1g fl t0 2g t2 fl merge t1 t0 g t2 merge fl t1g t2 fl t1g t2 with this merge operation we can merge all editing operations into an action tree.
vi.
e valuation in order to evaluate the benefits of the framework we assess two research questions.
first does blinkit work correctly on the examples without human intervention?
second given that the illustrative example is constructed are there realistic cases in an open source mdd software development project where invariant traceability links can be synchronised using blinkit ?
the first question needs tobe answered first since only a working blinkit prototype can bring benefits to the users.
to answer these questions we conducted two sets of experiments.
correctness.
in the 1st experiment we create a model using emf as illustrated earlier and generate the default java source code.
there is only class i.e.
entity and attribute i.e.
name respectively in the emf meta model the code generated by emf has classes i.e.
entity entitypackage and attribute i.e.
name annotated by model .
in terms of the number of generated attributes there are respectively classes attributes and methods generated in packages.
currently blinkit only supports synchronisation between method bodies which users are more likely to change in order to introduce different behaviours.
to evaluate the correctness of blinkit we manually modified those methods annotated by generated into generated inv .
the blinkit tool generated an identity unql transformation for each invariant traceability generated inv .
then we manually modified individual generated inv methods by adding removing and replacing some statements to simulate a possible change by the user.
in parallel we applied the rename class and the rename method refactorings to the elements in the model that were annotated by the model markers to see whether they have an impact on the user modified code.
the simulated changes to the newly generated template code may conflict with the changes introduced by user e.g.
by renaming name to id .
in those cases the changes should be merged by blinkit .
for correctness we checked the merged results manually to see whether they preserve both changes in the model and in the user code.
when the changes of the model did not affect the changes to the generated inv elements by the user all changes introduced by the user were preserved.
intersection of the changes in generated not generated and model .to answer the second question we first extracted all revisions of java code from the cvs repository of the gmf projectyy which spans about years period between and .
according to this repository there have been revisions including all the ones before the deleted files were placed in the attic subfolders.
in order to understand how many times the model parts have changed we rely on the emf convention that all modelling elements in the generated template code have been annotated with the model markers.
therefore we extracted the interface apis that were marked by model using the normalisation and clone detection technique reported in our earlier work .
this way all meaningful differences for the model can be found among the pairs of possible revisions we only compare those revisions on the same files .
there are pairs of meaningful changes ranging from till and no more changes after that.
fig.
shows yysee distribution of the model changes over this period.
figure .
the distribution of model changes in the cvs repository indicates that meta models used in the gmf project is getting stabilised.
next we used a different normalisation on the same dataset this time filtering only those methods that have been annotated by generated not markers amongst java classes.
for these java methods we moved their implementation in the body into the !
begin user doc ... !
end user doc pairs in the javadoc comments and changed their annotations into generated such that the code generator will overwrite the user code with the template code while the user modifications are still available in the comment.
finally we compared the differences between the template and user codes in order to see whether the changed model elements appear in these method bodies.
if they do then we have confirmed that the bidirectional transformation could be useful in practice because the user code was indeed different from the template code and those differences would interact with the modification of the model in the immediate revisions following the timestamps.
throughout the data set we found that revisions amongst the total of revisions i.e.
will be influenced by the changes of the model elements.
there are modified model elements referenced by the generated not methods in the revisions.
therefore on average 61modified modelling elements are referenced by the generated not method bodies in every java revision file.
we list threats to validity and some limitations below construct validity instead of synchronising for the whole classes or packages we focus on synchronising changes to the method bodies.
the reason for this choice is practical as most of the time users would customise the behaviour of the default class rather than rewriting them completely.
a modification to method bodies is also often required because the template code would otherwise raise unsupportedoperationexception .
external validity blinkit is built on existing opensource mdd toolsets emf emftext jamopp and a transformation system txl.
it also integrates two research prototypes groundtram and mct which are freely available to download.
the subject case study is also an open source one whose cvs repository is publicly available.internal validity although studying committed changes on models in the gmf repository may be conservative it is the only available source that we can rely on.
it can be argued that the editing changes outside the repository present more synchronisation opportunities however we have to estimate the benefits of our solution conservatively without empirically monitoring developers over their shoulders.
vii.
r elated work we compare blinkit to the work in traceability coevolution and bidirectional transformations.
precise traceability.
automated software document code traceability recovery has been studied by researchers from many angles since requirements traceability was proposed the review of the best practises in this field suggests that automated techniques such as vector spaces lsi are useful when part of the dataset relies on ambiguous documentation such as requirements manuals and bug reports.
it is expensive to obtain expert judgements for large applications and to obtain highquality inputs .
incremental techniques have been proposed to analyse evolving traceability links for better efficiency however precision cannot be greatly improved.
auxiliary information from programs such as call graphs or traces or xml based xlinkit rules could help improve the precision to some extent but it is still largely expensive to gain better results through feedback .
on the other hand the abstraction gap between models and code is much narrower that that between requirements document and code thus precise tracing has been considered through maintaining semi automated refactorings .
however such refactorings are also expensive to construct thus affordable only for medium sized security software applications.
here we address the problem for general software projects that scales while mdd has been applied.
invariant traceability for model code co evolution.
when projects evolve mdd methods face additional challenges not only do artifacts such as models or code change over time their changes also need to be propagated in order to maintain consistency even when artifacts are at different levels of abstraction.
co evolution needs to be studied between models and code between behavioural and structural models or even between code and programming languages .
modifications to a model must be reflected on the corresponding code in order to keep the model and the code synchronised .
code generators exist to automatically generate code from uml models .
in practice however code is often updated manually after it has been generated and it is therefore necessary to reflect those changes back to the corresponding model.
round trip engineering rte is one way to synchronise uml diagrams and code .
however combining code generation and reverse engineering approaches is still not sufficient changing independently models and code needto be merged first secondly since models are generally at a higher level of abstraction than code not all changes made to the code can be reflected back to models.
giese and wagner use triple graph grammars for rte but their approach is limited to elements that have a correspondence in the model.
other approaches like van paesschen et al.
s assume that both artifacts can be represented in a common representation.
fujaba is yet another rte approach that can generate java code from uml class diagrams and regenerated class diagrams from modified java code as long as developers follow fujaba s naming conventions and implementation concepts.
state of the art rte tools such as emf gmf make use of annotations to separate the portions of generated and user modified code yet it is largely manual to maintain the correspondence of generated not elements.
the co evolution of gmf project has been studied for synchronising the emf meta models model model used by the project.
although we also use the same case study to evaluate the benefits our focus is on automating the code code synchronisations.
bidirectional transformation has been recently widely studied by researchers from different communities of programming language software engineering and database.
it has many potential applications in software development including model synchronisation round trip engineering software evolution and multiple view software development .
our work shows that we can move from potential to practical we achieve scalability by proposing a two layer bidirectional transformation framework hiding difficulties in writing bidirectional transformation by automatic deriving it from a sequence of editing operations and widening its application scope by treating general graphs.
viii.
c onclusions and future work in this paper we presented a model driven development mdd method supported by the blinkit prototype to maintain the invariant traceability between model and code through bidirectional transformations.
using this method if code is annotated by generated inv a bidirectional transformation will be generated to correctly propagate changes in both directions.
we tested our framework by the example shown in section iii and observed empirically how often blinkit can be used to maintain the invariant traceability based on the data set in the cvs repository of gmf a widely used mdd project.
it is also observed that applying the method earlier delivers more benefits since its meta models change more frequently.
in this case study we also found that more changes were derived from the evolving model than from the evolving template.
current work considers a basic form of invariant traceability where all meaningful changes are synchronised regardless of whether they were derived from the template or from the model.
our future work will extend the syntaxand semantics of generated inv to differentiate model changes from template changes.
acknowledgement.
the work is supported in part by eu securechange microsoft seif computingresearch.open.ac.uk seif and nii big projects.