camouflage automated anonymization of field data james clause department of computer and information sciences university of delaware clause udel.edualessandro orso college of computing georgia institute of technology orso cc.gatech.edu abstract privacy and security concerns have adversely affected the usefulness of many types of techniques that leverage information gathered from deployed applications.
to address this issue we present an approach for automatically anonymizing failure inducing inputs that builds on a previously developed technique.
given an input ithat causes a failure f our approach generates an anonymized input i primethat is different fromibut still causes f.i primecan thus be sent to developers to enable them to debug fwithout having to know i. we implemented our approach in a prototype tool camouflage and performed an extensive empirical evaluation where we applied camouflage to a large set of failure inducing inputs for several real applications.
the results of the evaluation are promising as they show that camouflage is both practical and effective at generating anonymized inputs for the inputs that we considered iandi primeshared no sensitive information.
the results also show that our approach can outperform the general technique it extends.
categories and subject descriptors d. .
software engineering testing and debugging k. .
public policy issues privacy general terms experimentation security keywords input anonymization symbolic execution .
introduction investigating techniques that capture data from deployed applications to support in house software engineering tasks is an increasingly active and successful area of research e.g.
.
however privacy and security concerns have prevented widespread adoption of many of these techniques and because they rely on user participation have ultimately limited their usefulness.
many of the earlier proposed techniques attempt to sidestep these concerns by collecting only limited amounts of information e.g.
stack traces and register dumps or sampled branch profiles this work was supported in part by nsf awards ccf0725202 and ccf to georgia tech.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.
and providing a privacy policy that specifies how the information will be used e.g.
.
because the types of information collected by these techniques are unlikely to be sensitive users are more likely to allow the techniques to be used.
moreover because only a small amount of information is collected it is feasible for users to manually inspect and anonymize such information before it is sent to developers.
unfortunately recent research has shown that the effectiveness of these techniques increases when they can leverage large amounts of detailed information e.g.
complete execution recordings or path profiles .
since more detailed information is bound to contain sensitive data users will most likely be unwilling to let developers collect such information.
in addition collecting large amounts of information would make it infeasible for users to anonymize the collected information by hand.
to address this problem some of these techniques suggest using an input minimization approach e.g.
to reduce the number of failure inducing inputs and hopefully eliminate some sensitive information.
input minimization techniques however were not designed to specifically reduce sensitive inputs so they can only eliminate sensitive data by chance.
in order for techniques that leverage captured field information to become widely adopted and achieve their full potential new approaches for addressing privacy and security concerns must be developed.
one promising technique for addressing privacy concerns is the one proposed by castro and colleagues which works in conjunction with an execution record replay technique e.g.
.
given an execution recording that contains a captured failure inducing input i angbracketlefti1 i2 ...in angbracketrightand terminates with a failure f the technique replays the execution recording and leverages dynamic symbolic execution to automatically produce i prime an anonymized version of ithat still causesf.
in this paper we extend the work presented in in several ways.
from a conceptual standpoint we present an improved approach that incorporates two novel techniques that we developed path condition relaxation andbreakable input conditions .
intuitively these techniques increase the strength of the general approach by decreasing the amount of information that is revealed about the original inputs.
by so they make it more difficult to reconstruct all or even part of the original input which helps to ensure users privacy.
from a practical standpoint we present a more thorough evaluation of the approach that considers a larger number of faults and considerably more failure inducing inputs than the empirical study in .
1permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
to perform our evaluation we implemented our approach in a prototype tool camouflage that we used to anonymize inputs that cause failures in several real applications.
in this evaluation we investigated a set of research questions that are concerned with the feasibility strength and effectiveness of the approach.
the results of the evaluation show that the approach is feasible in that for each input that we considered camouflage generated in a matter of minutes an anonymized version of the input that reproduced the original failure the percentage of information revealed by the anonymized inputs ranged from in the worst case to in the best case even in the worst case the anonymized inputs were unlikely to reveal sensitive information and could have been safely sent to developers and our two techniques path condition relaxation and breakable input conditions are effective for the cases considered they reduced the amount of information revealed by the approach by more than on average without significantly increasing the amount of time needed to generate anonymized inputs.
although still preliminary these results are promising and show that the approach can be both efficient and effective at anonymizing inputs that cause failures in real applications and can improve on the state of the art.
the contributions of this paper are an automated approach for input anonymization that extends the state of the art through two novel techniques path condition relaxation and breakable input conditions.
a prototype tool that implements our approach for java applications.
an extensive empirical study that demonstrates the feasibility and effectiveness of our approach and the benefits provided by path condition relaxation and breakable input conditions.
the remainder of this paper is organized as follows section presents a motivating example for our work.
section provides background information on dynamic symbolic execution.
section describes the details of our technique.
section presents our prototype implementation and our empirical evaluation.
finally sections and discuss related work and present our conclusions and future work.
.
motivating example in this section we provide an example that will be used in the remainder of the paper to illustrate our technique.
figure shows the code for the example which is an excerpt from a credit card processing utility that accepts visa american express and discover credit cards.
the program reads from the command line the credit card number to be processed and passes it to isvalidcardnumber which checks whether the provided number is valid using the luhn formula a simple checksumming algorithm .
if the credit card number is valid the program invokes processcard which determines the type of the credit card number i.e.
visa american express or discover by checking the number s prefix and processes the card accordingly.
function processcard contains a fault that can cause the credit card processing utility to incorrectly handle certain credit card numbers.
on october discover s prefix was changed from to .
because line of processcard was not updated to reflect this change validdiscover card numbers that start with such as are not correctly processed and would cause an unknowncardtype exception to be thrown.
although this program and fault are relatively simple to understand failures caused by this fault are good examples of the type of scenario that the technique targets for two reasons.
first such failures directly involve sensitive information credit card numbers in this case which means that users would likely be unwilling to provide developers with the specific input that triggered the fault.
second it would be difficult for commonly used approaches to provide an anonymized version of the input that still triggers the fault.
in particular input minimization techniques would be likely to fail.
minimization techniques that attempt to find a subset of the inputs that causes the same failure such as ddmin will be unsuccessful because a valid credit card number must have digits so no minimization would be possible.
minimization techniques that perform alphabet normalization by substituting some portions of the input with a don t care value e.g.
tmin would also likely fail as most inputs generated in this manner will not satisfy the luhn formula.
even constructing anonymized inputs by hand would be quite challenging due to the difficulty of generating inputs that pass the luhn check.
.
dynamic symbolic execution in this section we briefly provide necessary background information on dynamic symbolic execution.
at a high level dynamic symbolic execution techniques e.g.
execute a program using symbolic inputs so that at each point in the computation the state is expressed as a function of the input and the conditions on the input for reaching the current location lare expressed as a conjunction of constraints called a path condition .
symbolic execution techniques generate path conditions by first associating a symbolic variable vkwith every element of an input.
for the example in figure for instance each character of the command line argument would be associated with a unique symbolic variable the first character would be associated with v0 the second character would be associated withv1 and so on.
then as the program executes program statements are interpreted and their effect determines the symbolic state of the program expressed in terms of the symbolic variables and the current path condition.
as an example of a symbolic state consider two subsequent instructions s1 x i j and s2 y x whereiis associated with a symbolic expression eandjis associated with symbolic variable v1 the value of yin the symbolic state afters2 s execution would be the symbolic expression e v1 .
path conditions are constructed incrementally by appending a new constraint to the current path condition every time a predicate that depends on the symbolic state is executed i.e.
every time a predicate involves one or more values that have an associated symbolic expression .
the constraint encodes the condition on the symbolic variables under which the predicate evaluates in the same way as the concrete execution.
to illustrate consider the code in figure and assume that the code is run with command line argument .
when line 24is first executed cis associated with symbolic variable v15 has the concrete value prime5 prime and is compared with character prime0 prime.
in this case the predicate evaluates to true because prime5 prime prime0 prime so the con222 boolean isvalidcardnumber string ccn .
if ccn.length !
return false .
int sum .
boolean alternate false .
int i ccn.length .
for i i .
int n mapchar ccn.charat i .
if alternate .
n .
if n n n .
.
sum n .
alternate !alternate .
.
return sum void processcard string ccn .
if ccn.startswith .
process visa17.
else if ccn.charat ccn.charat .
ccn.chatat .
process american express20.
else if ccn.startswith .
process discover22.
else23.
throw new unknowncardtype ccn int mapchar char c .
return c c ?
c c a void main string args .
if isvalidcardnumber args .
processcard args figure code excerpt for our motivating example.
straint v15 prime0 prime is appended to the path condition.
had the predicate evaluated to false the constraint v15 prime0 prime would have been appended instead.
figure shows the complete path condition generated for this example program and input including constraints due to library code .
.
automated anonymization before discussing the details of our approach we use figure to illustrate intuitively the approach s goal and the context in which it operates.
given a program pwith input domainid a failuref and an input i idthat causes f there is typically a subset of the input domain if id such that every input in ifcausesf.
in general identifying ifis not possible due to computability issues.
however under the assumptions that we discuss in section .
it is possible to identify a subset of if such that every input in this subset follows the same path as i and causes f. the approach proposed by castro and colleagues basic approach hereafter computes this subset using dynamic symbolic execution.
given a specific input i dynamic symbolic execution is used to identify a subdomain of idwhose elements are inputs that cause the program to follow the same path as i. more precisely dynamic symbolic execution is performed along the specific path of execution pcaused byi when failure foccurs at location l the computed path condition identifies this target subdomain the set of all inputs including i that cause pto be executed and f to occur at l. we call this set i .
note that in general the fact that an input satisfies does not necessarily imply that such input will follow the same path as ior if it does causef.
however this tends to be the case in most practical situations as we discuss in detail in section .
.
after computing an anonymized input i primeis generated by leveraging boolean isvalidcardnumber string ccn .
if ccn.length !
return false .
int sum .
boolean alternate false .
int i ccn.length .
for i i .
int n mapchar ccn.charat i .
if alternate .
n .
if n n n .
.
sum n .
alternate !alternate .
.
return sum void processcard string ccn .
if ccn.startswith .
process visa17.
else if ccn.startswith .
ccn.startswith .
process american express20.
else if ccn.startswith .
process discover22.
else23.
throw new unknowncardtype ccn int mapchar char c .
return c c ?
c c a void main string args .
if isvalidcardnumber args .
processcard args constraints from mapcharv0 v0 ... v15 v15 constraints from processcardv0 v0 v0 v1 v2 constraints from isvalidcardnumber v0 v2 v4 v6 v8 v10 v12 v14 v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 0path condition breakable input constraintsv0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 original input 7524basic approach 9754our improved approach v0 v0 v1 v1 v0 v1 v2 anonymized input constraints from processcard relaxed v0 v0 v1 v1 v0 v1 v2 constraints from mapchar and isvalidcardnumbersame as figure 2path condition original input 3585anonymized input 9754figure path condition for the code in figure and input .
anonymized input figure anonymized input generated by the basic approach for the path condition in figure .
a constraint solver to identify a satisfying assignment for .
for our motivating example a possible assignment generated by this approach is shown in figure .
the strength of this approach i.e.
how well it prevents information about ifrom being revealed depends on several related aspects.
first the solution identified by the solver i prime should be independent from i i.e.
it should not be possible to algorithmically recover ifromi prime .second i must be large enough to make an enumeration of the domain impractical in a reasonable amount of time.
because can be derived from i prime just as it is derived from i a sufficiently small domain allows for easily recovering i which defeats the purpose of the technique.
and third the inputs in i primeshould be as different as possible from their corresponding inputs ini.
although there are cases where only a single value can satisfy some constraints in e.g.
in our example v0must be equal to prime6 prime in general trying to prevent i primefrom duplicating ireduces the likelihood that sensitive information can be identified simply by examining i prime.
we expect the first aspect not to be a problem most constraint solvers utilize some randomness in their search heuristics so the selection of i primecan be safely considered pseudo random.
to address the second and third aspects and thus improve the strength of the approach we extend the basic approach by means of two novel techniques path condition relaxation and breakable input conditions.
path condition relaxation addresses the second aspect the size ofi .
it consists of a set of optimizations that specialize the constraint generation part of dynamic symbolic execution to increase the size of i .
intuitively the technique relaxes overly restrictive constraints thus strengthening the overall approach by allowing for a larger number of solutions.
breakable input conditions address the third aspect by forcing the constraint solver to chose whenever possible values for i prime that are different from the corresponding values in i. in the rest of this section we discuss in detail path condition relaxation breakable input conditions and the assumptions that underlie the overall approach.
id input domain inputs that cause f inputs that satisfy the path condition derived from ii sanitizedinputi sensitive inputi iffigure intuitive view of a program domain.
.
path condition relaxation as we mentioned in the previous section path condition relaxation consists of several optimizations that modify the way path conditions are generated so as to increase the number of solutions for the computed conditions.
in the following we describe the four cases that our technique optimizes.
note that because these optimization are designed for our specific goal of finding inputs that cause a known path to be executed we believe that they are unlikely to benefit other dynamic symbolic execution techniques e.g.
in any significant way.
array inequality.
typically a comparison between two arrays is performed by iterating over the arrays and performing a pairwise comparison between corresponding elements.
in traditional symbolic execution the result of each comparison would be recorded as a constraint in the path condition.
therefore only inputs that cause every comparison to evaluate the same way as the observed execution would satisfy the path condition.
for example assume that a b a s elements are associated with symbolic expressionse1 e2 ande3 andb s elements are associated with symbolic expressions e4 e5 ande6.
checking the equality of these arrays would add the constraints e1 e4 e2 e5 and e3 negationslash e6 to the path condition.
the key intuition behind our optimization of array comparisons is that such comparisons are essentially atomic operations.
therefore when arrays are not equal path condition relaxation can replace the constraints that encode the individual comparisons with a constraint that simply requires that at least one comparison evaluates to false i.e.
at least one element is different .
for the previous example the constraint e1 negationslash e4 e2 negationslash e5 e3 negationslash e6 would be added.
all variable assignments that satisfy the original constraints also satisfy the relaxed one but the latter is also satisfied by many other assignments e.g.
a b .
multi clause conditionals.
in many languages commonly used boolean operators such as and and or are evaluated with short circuit or minimal evaluation semantics only the minimal amount of evaluation is done to determine the value of the expression.
for example consider the conditional if a1 bardbla2 wherea1anda2are associated with symbolic expressions e1ande2 respectively.
if a1 s value is then a2 will not be evaluated as the outcome of the condition is known after the evaluation of a1 .
because the rest of the conditional is not evaluated the path condition will only include the constraint e1 .
like for array inequalities such path conditions exclude a large number of assignments that would cause the conditional to evaluate to the same value e.g.
a b .to generate relaxed path conditions for multi clause conditionals our technique generates constraints that encode all clauses in the conditional not just those evaluated at runtime.
for example if the aforementioned conditional if a1 bardbla2 were to evaluate to true the constraint e1 e2 would be generated.
conjunctive clauses and conditionals comprised of more than two clauses are handled in a similar manner.
switch statements.
switch statements are similar to multiclause conditionals in that multiple values can cause the switch to jump to the same target i.e.
for case statements that immediately fall through to their successor .
in these cases a traditional technique would build a constraint of the form e negationslash c1 negationslash cm e cm whereeis the symbolic expression associated with the value compared by the switch statement cmis the value in the first case statement that matches e andc1 ... cm 1are the values of the cases that precede cmin the switch statement.
conversely the technique would generate the constraint e negationslash c1 e negationslash cm e cm e cn where cm ... cnare the values of the cases that branch to the same target as cm.
in this way the technique allows more possible values of eto be considered.
array reads.
when symbolically executing array accesses concretization1is often performed.
for example assume that a and thatxhas the value and is associated with symbolic expression ewhen statement if a is executed.
in the common case of a solver that cannot handle symbolic array indices ewould be concretized to .
in these cases concretizing may be unnecessarily restrictive as multiple values in an array could satisfy the same condition.
in our example for instance the values at index and at index would both cause the conditional to evaluate totrue which means that ecan be equal to either or .
to generate these extended path conditions our technique uses an approach similar in nature to the one proposed by elkarablieh and colleagues .
essentially a snapshot of the contents of the array is encoded in the path condition as a sequence of ternary expressions.
considering again our example the technique would generate the constraints e ?
e ?
e e .
these constraints ensure that the value of eis within the bounds ofa yet allow it to be any value that satisfies the conditional.
to illustrate figure shows how the above optimizations would relax the constraints generated for our motivating example.
although in this case the narrow constraints on the first two digits of the input nullify the effects of relaxation in general such relaxation can result in the expansion of the set of possible solutions as shown empirically in section .
.
.
breakable input conditions the use of a constraint solver to compute i primeby solving the path condition for a failing execution guarantees that i prime can reproduce the failure considered.
however because the solver s only goal is to find a satisfying assignment it may 1concretization is a technique used in dynamic symbolic execution to handle constraints that the decision procedure in the constraint solver does not support.
it works by replacing symbolic expression in the problematic constraints with their corresponding concrete values so that the constraints become decidable.
424breakable input conditionsv0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 constraints from processcard relaxed v0 v0 v1 v1 v0 v1 v2 constraints from mapchar and isvalidcardnumbersame as figure 2path condition original input 3585anonymized input 9852figure path condition and anonymized input generated by our approach for the example in figure and input .
coincidentally choose values that are in i even when other choices are possible thus unnecessarily revealing information about the original input.
this is especially true when the domain of some of parts of the input is small.
in our example for instance there are only ten possible values for each digit and the domain is further reduced by the constraints on the inputs.
it is not surprising that in a similar situation an anonymized credit card number could share many digits with the original number.
the anonymized input shown in figure where the unchanged values are underlined illustrates an instance of this problem which we have also observed in practice in our empirical evaluation see section .
.
to address this issue we add to the path condition breakable input conditions constraints that explicitly prevent the constraint solver from choosing values from i. more precisely for each symbolic variable our technique adds a new constraint that specifies that the symbolic variable should not be equal to the original value of its corresponding input.
for our running example the breakable input conditions for the given input are shown in figure .
when the conjunction of a path condition and the corresponding breakable input conditions is satisfiable and the solver is able to find a solution for the resulting set of constraints i primeis guaranteed to be different from i. in situations where an element must have a specific value in order to cause the failure however the breakable input conditions make the path condition unsatisfiable.
this is the case for our example where the first two digits of the input must be and the other digits must pass the luhn checksumming algorithm.
for this reason our technique encodes each breakable input condition as a discardable constraint that is a constraint that the solver can ignore in order to find a solution for an otherwise unsatisfiable set of constraints.
because the solver would still try to ignore as few discardable constraints as possible encoding breakable input conditions as discardable constraints forces the solver to choose i primesuch that it is as different as possible from i. figure shows an example of an anonymized input computed using breakable input conditions where only three values are shared with the original input.
.
assumptions our technique is based on two main assumptions on failure f fis observable and can be encoded in the form of an assertion and any input that satisfies path condition not only follows the same path as the original failure inducing inputi but also results in the same failure f. the first assumption is common to all debugging related techniques and holds in most if not all cases.
the second assumption requires that the necessary conditions for fare encoded in .
the only cases in which this assumption does not hold are non determinism and implicit checks.
if the program being considered is non deterministic the technique may not be able to generate anonymized inputs that reproduce the failure because it cannot guarantee that events such as thread switches always occur in the same order.
this problem is also common to all debugging related techniques and can be addressed by leveraging record replay infrastructure that supports deterministic replay e.g.
.
implicit checks are checks that are performed by an entity that is external to the application and thus are not observable by the symbolic execution.
a typical example of implicit checks is the set of checks performed by the underlying runtime system such as checks that may result in a division by zero or out of memory error.
because these checks are not performed by the application they would not be included as constraints in the path condition and an input that satisfies may fail to reproducef.
although this issue exists we believe it is of limited relevance in most cases for two reasons.
first although some types of implicit checks occur frequently the majority of them are likely to be irrelevant because as confirmed by our evaluation they constrain variables that are not directly or indirectly related to the failure.
therefore in the worst case the technique could simply ignore cases for which the anonymized input cannot reproduce fand focus on the remaining failures.
second we can automatically account for implicit checks that occur within the runtime system by making them explicit.
to account for division by zero errors for instance the technique could easily preprocess the code and add an explicit check of the denominator s value every time a division is encountered.
.
evaluation to evaluate our technique we implemented it in a prototype tool called camouflage and investigated the following research questions rq1 feasibility can the approach generate in a reasonable amount of time anonymized inputs that reproduce the original failure?
rq2 strength how much information about the original failure inducing inputs is revealed by the approach?
rq3 effectiveness are the anonymized inputs generated by our approach safe to send to developers?
rq4 improvement does the use of path condition relaxation and breakable input conditions provide any benefits over the basic approach?
note that rq2 provides an objective assessment of the technique it does not make any assumptions about whether the revealed information is actually sensitive.
conversely rq3 does take into account whether the information that is revealed is indeed sensitive.
the remainder of this section discusses camouflage our subjects and our experimental protocol and results.
.
prototype tool ourcamouflage tool is a prototype implementation of the technique for applications written in the java language.
it consists of two separate components the constraint generator and the input anonymizer.
the record replay is assumed to be an external component.
the current implementation of the constraint generator is an extension to java pathfinder jpf an explicit state software model checker for java software .
to assign symbolic variables to an application s inputs we use jpf s method interception capabilities to wrap all native methods in the java.io package.
because ultimately all file and network inputs are read by these methods camouflage can easily associate a symbolic variable with every input read from these sources.
to handle other sources of input we also wrap the main method to handle command line arguments and the appropriate methods for reading environment variables and system properties.
by default camouflage assumes that all inputs are sensitive.
however it also allows users to specify that inputs read from specific sources should not be associated with a symbolic variable.
this feature is useful for example in cases where it is known that inputs read from certain files or network streams are not sensitive and do not need to be anonymized.
to implement our specialized path condition generation see section .
we use jpf s bytecode overloading facilities to replace each java bytecode with a modified version that replicates the instruction s original semantics while also performing the necessary steps for generating path conditions.
finally to identify when failures occur we use jpf s vmlistener interface to intercept uncaught exceptions and failed assertions.
when the execution reaches the point of failure and the failure occurs the constraint generator writes the recorded path condition and the breakable input conditions to disk.
the input anonymizer is implemented as a set of ruby scripts and works as follows.
first it transforms the constraints produced by the constraint generator into a format understood by the constraint solver.
then it invokes the constraint solver to find a solution for the constraints.
finally it transforms the solution provided by the constraint solver into a concrete input that can be sent to developers.
as our constraint solver we choose yices because among the constraint solvers that we know it is the only one that supports both discardable constraints see section .
and bit vector operations.
using bit vectors for symbolic variables allows our implementation to handle bit shifts and masks which are commonly used in the java libraries.
however using bit vectors does have one drawback currently no constraint solver including yices supports floating point arithmetic on bit vectors.
this means that currently camouflage does not support symbolic floats or doubles.
.
subjects the goal of the technique is to generate anonymized inputs that cause the same failures as the original input while revealing as little information as possible.
to suitably evaluate the technique with respect to this goal we selected applications with known faults that process information that can be considered private or sensitive nanoxml faults which is available from sir software artifact infrastructure repository a java version ofprinttokens faults whose original c implementa tion is also available from sir the address book component of the columba email client version .
fault http and version .
of htmlparser fault .
for each fault we selected multiple failure inducing inputs.
for nanoxml and printtokens we used the inputs provided with the two applications.
forcolumba andhtmlparser we constructed representative inputs by hand.
in total we used failure inducing inputs that range in size from several hundred bytes to over five megabytes.
.
rq1 feasibility the primary goal of our first research question is to assess whether the amount of time needed to generate anonymized inputs is reasonable and whether the anonymized inputs reproduce the original failure.
to generate the data necessary for investigating these questions we proceeded as follows for each failure inducing input we used camouflage to run the application and generate an anonymized version of such input.
in addition we recorded two measurements the amount of time needed by camouflage to generate the path condition and the amount of time needed by the constraint solver to solve the generated path condition.
the top half of figure presents a bar chart that shows for each fault the average amount of time camouflage needed to generate path conditions.
the bottom half of the figure shows the average amount of time needed by the constraint solver to solve the generated path conditions.
as the figure shows the amount of time needed to generate path conditions ranges from an average of seconds for printtokens to an average of seconds for htmlparser .
the amount of time needed to solve the path conditions ranges from an average of .
seconds for printtokens to an average of .
seconds for columba .
overall for all of the failure inducing inputs that we considered camouflage was able to generate an anonymized version in less than minutes.
because camouflage is designed to run off line during idle periods when free cycles are available e.g.
overnight the approach is clearly practical.
users will only experience the overhead caused by the record replay technique used which have been shown to be in the single digits for modern approaches .
to determine whether the anonymized inputs reproduce the original failures we executed our subject applications with such inputs and manually inspected the outcomes.
we found that all anonymized inputs produced by camouflage successfully reproduced the original failure.
.
rq2 strength to assess the strength of camouflage s anonymization we used two metrics bits of information revealed and residue.
the first metric bits of information revealed is a standard entropy measure that has been used in related work .
intuitively it measures how much information is revealed by the technique by calculating how many inputs satisfy the path condition i.e.
the number of inputs in i .
in general an anonymized input reveals summationtext i i prime log2 xi bits of information about i wherexiis the number of solutions to the constraints involving idivided by the size of i s input domain.
for example assume that i prime 0is an bit character i.e.
its input domain contains values and that of the possible values satisfy the constraints on i prime .
in this case i prime 0reveals approximately .76of the 8total bits 626columbaprinttokens1printtokens2nanoxmlv01s01nanoxmlv01s03nanoxmlv01s05nanoxmlv01s06nanoxmlv02s02nanoxmlv02s03nanoxmlv02s04nanoxmlv02s05nanoxmlv02s06nanoxmlv02s07nanoxmlv03s04nanoxmlv03s09nanoxmlv03s10nanoxmlv05s03nanoxmlv05s05nanoxmlv0509htmlparserexecutiontime s fault runtime solvetimev01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s05v01s06v01s06v01s06v01s06v01s06v01s06v01s06v01s06v01s06v01s06v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s03v02s03v02s04v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s07v02s07v02s07v02s07v02s07v03s04v03s09v03s10v03s10v03s10v03s10v03s10v03s10v03s10v03s10v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s05v05s093.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.438fault runtimeconstraintruntimeaddressbookhtmlparsertokens1tokens2v01s01v01s03v01s05v01s06v02s02v02s03v02s04v02s05v02s06v02s07v03s04v03s09v03s10v05s03v05s05v05s095.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.70constraint solver time s fault runtime solvetimev01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s01v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s03v01s05v01s06v01s06v01s06v01s06v01s06v01s06v01s06v01s06v01s06v01s06v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s02v02s03v02s03v02s04v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s05v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s06v02s07v02s07v02s07v02s07v02s07v03s04v03s09v03s10v03s10v03s10v03s10v03s10v03s10v03s10v03s10v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s03v05s05v05s093.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.438fault runtimeconstraintruntimeaddressbookhtmlparsertokens1tokens2v01s01v01s03v01s05v01s06v02s02v02s03v02s04v02s05v02s06v02s07v03s04v03s09v03s10v05s03v05s05v05s095.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.70figure bar charts showing for each fault the average amount of time needed to execute the subject and generate the corresponding path condition top and find a solution using the constraint solver bottom .
columbaprinttokens1printtokens2nanoxmlv01s01 nanoxmlv03s10nanoxmlv05s03nanoxmlv05s05nanoxmlv0509htmlparser residue bitsrevealed nanoxmlv01s03nanoxmlv01s05nanoxmlv01s06nanoxmlv02s02nanoxmlv02s03nanoxmlv02s04nanoxmlv02s05nanoxmlv02s06nanoxmlv02s07nanoxmlv03s04nanoxmlv03s09addressbookhtmlparserprinttokens1printtokens2v01s01v01s03v01s05v01s06v02s02v02s03v02s04v02s05v02s06v02s07v03s04v03s09v03s10v05s03v05s05v05s09020406080100addressbookhtmlparserprinttokens1printtokens2v01s01v01s03v01s05v01s06v02s02v02s03v02s04v02s05v02s06v02s07v03s04v03s09v03s10v05s03v05s05v05s09020406080100 figure box plots showing for each fault the bits of information revealed as a percentage of the total number of bits in the input top and the percentage of residue bottom that remains after anonymization.
of information about i0.
because computing xiexactly is difficult and expensive when constraints involve multiple input elements we chose to use an algorithm by martin that quickly provides an accurate over approximation for xi .
the bits of information revealed metric provides a good starting point for assessing the strength of the anonymization.
however its results can be misleading.
for example it is possible to decrease the amount of bits revealed while large portions of the input remain unchanged.
to illustrate this situation consider a program that reads characters as input.
assume that the constraints on each of the last characters have possible solutions while the first characters must remain the same.
if the number of possible solutions for the second characters is increased from to the amount of information revealed decreases from .
bits to .
bits.
this decrease correctly indicates that it is now more difficult to recover the original input but it fails to indicate that half of the input is unchanged a fact that may be important especially if the first half of the input is more sensitive than the second half.
our second metric residue addresses this shortcoming.
residue is essentially the percentage of bits that remain unchanged after anonymization.
for the example mentioned in the previous paragraph the percentage of residue would not change if the number of possible solutions for the second characters increased from to thus indicating that anonymization may not have been as effective as the bits of information revealed metric would suggest.
by usingboth metrics we can assess the strength of the anonymization performed by camouflage from multiple perspectives and better judge how much information about the failureinducing inputs is revealed by their anonymized versions.
figure presents two box and whisker plots that show for each fault and failure inducing input the bits of information revealed by the anonymized input as a percentage of the total number of bits in the failure inducing input top and the percentage of residue in the anonymized input bottom .
for the subjects we considered the average percentage of bits of information revealed ranges from .
to76.
with an average of .
and the average percentage of residue ranges from .
to with an average of .
although these results show that under some circumstances camouflage cannot generate fully anonymized inputs they are also encouraging the majority of anonymized inputs produced by camouflage reveal only a limited amount of information.
moreover as the results discussed in the next section show the information revealed is unlikely to be sensitive.
these results also suggest that the strength of the anonymization performed by camouflage depends not only on the subject application but also on the specific input considered and can vary widely even among different inputs that trigger the same fault.
.
rq3 effectiveness the results of rq2 s investigation provide an objective measure of the anonymization performed by camouflage .
!doctype foo !element foo ns bar !attlist foo xmlns cdata fixed a cdata required !element ns bar blah !attlist ns bar xmlns ns cdata fixed !element blah empty !attlist blah x cdata required ns x cdata required !
comment foo a test b test1 c test2 vaz ns bar blah x ns x ns bar foo a failure inducing input for nanoxml .
...wayne bartley bartley wayne wbartly acp.com ronald kahle kahle ron ron.kahle kahle.com wilma lavelle lavelle wilma lavelle678 aol.com jesse hammonds hammonds jesse hamj34 comcast.com amy uhl uhl amy uhla corp1 com uhla gmail.com hazel miracle miracle hazel hazel.miracle corp2.com roxanne nealy nealy roxie roxie.nearly gmail.com heather kane kane heather kaneh corp2.com rosa stovall stovall rosa sstoval aol.com peter hyden hyden pete peteh1989 velocity.net jeffrey wesson wesson jeff jwesson corp4.com virginia mendoza mendoza ginny gmendoza corp4.com richard robledo robledo ralph ralphrobledo corp1.com edward blanding blanding ed eblanding gmail.com sean pulliam pulliam sean spulliam corp2.com steven kocher kocher steve kocher kocher.com tony whitlock whitlock tony tw14567 aol.com frank earl earl frankie shelly riojas riojas shelly srojas corp6.com ... b failure inducing input for columba .
?xml version .
encoding utf ?
!doctype html public w3c dtd xhtml .
en xmlns xml lang en head title james clause gatech home title style type text css media screen title !
!
style head body ... body c failure inducing input for htmlparser .
figure example failure inducing inputs.
however without considering whether the revealed information is actually sensitive it is difficult to accurately assess if anonymized inputs can safely be sent to developers.
performing such an assessment is the goal of the study addressing rq3.
in this study we conducted an in depth qualitative assessment of all the anonymized inputs generated by camouflage that takes into account whether the revealed information is sensitive.
to make this determination we manually inspected each failure inducing input and its anonymized version.
as the discussion of the specific anonymization cases in the rest of this section will show for the subjects we considered the distinction between sensitive and not sensitive inputs was fairly clear cut.
for all anonymized inputs we found that they did not reveal any information that we believe to be sensitive.
in the rest of this section we provide a detailed description of our analysis for three anonymized inputs one for nanoxml one for the address book component of columba and one for htmlparser .
we chose to present these inputs because among the failure inducing inputs for each application they have the highest percentage of bits of information revealed and residue.
consequently they are the most likely to actually reveal sensitive information.
figures 8a 8b and 8c show representations of the portions of the original inputs that can and cannot be changed i.e.
residue for the inputs we are presenting.
we shortened the inputs to make them fit.
in these figures portions of the inputs that cannot be changed are underlined.
nanoxml.
the input for nanoxml shown in figure 8a is an xml file available from the sir repository.
the fault triggered by this input causes nanoxml to incorrectly handle closing tags.
as the figure shows the portions of this file that cannot be changed do not contain any sensitive information.
the literals doctype attlist and fixed are keywords of the language used to specify document type definitions and nanoxml specifically checks for their presence.
similarly the angle brackets exclamation points hyphens double quotation marks backslashes equals signs and white spaces represented by that cannot be changed are necessary because they define the structure of the xml document.
conversely portions of the input that are likely to contain sensitive information such as xml tag names attribute values and tag bodies can all be changed without preventing the modified input from reproducing the failure.
therefore although a relatively large percentage ofthe file cannot be changed we can consider the input to be anonymized because it contains to the best of our knowledge no real sensitive information.
columba.
the input for columba shown in figure 8b is a pipe separated value file of contact information.
the entries in each row are a contact s first name last name sort key nickname email address work phone and home phone albeit none of the entries shown actually has a phone number .
this file triggers a fault in a section of columba that handles the email portion of each row.
columba assumes that each contact has an email address.
if this assumption is violated as it is by the second to last row in the part of the input shown in figure 8b an exception is thrown.
the results of anonymizing this input are similar to the results of anonymizing the input for nanoxml the structural elements of the file i.e.
the commas that separate the individual fields cannot be changed but the non structural elements i.e.
each contact s first name last name and so on can all be changed.
consequently also in this case we can conclude that the input produced by camouflage is anonymized i.e.
contains no sensitive information and can be safely sent to developers.
htmlparser.
the input for htmlparser shown in figure 8c is an html file taken from the website of one of the authors.
the fault that this input triggers is in the tag processing portion of htmlparser which scans for pairs of angle brackets and backslashes.
this version of htmlparser incorrectly handles several angle brackets around the cdata portion of the file which causes a mismatch between opening and closing brackets and leads ultimately to an exception being thrown.
for this input the only parts that cannot be changed are the angle brackets and backslashes which are explicitly matched by the tag parser.
again the portions of the input that are most likely to be sensitive the contents of the web page and the style sheet have all been changed.
overall conclusions.
for the three failure inducing inputs that we presented above and the additional inputs that we considered in our evaluation camouflage was always able to anonymize the inputs by removing all of the portions of the inputs that we considered to be sensitive.
these results are encouraging because they provide initial yet strong evidence that camouflage can generate anonymized failure inducing inputs that could be safely sent to developers.
828columbaprinttokens1printtokens2nanoxmlv01s01nanoxmlv01s03nanoxmlv01s05nanoxmlv01s06nanoxmlv02s02nanoxmlv02s03nanoxmlv02s04nanoxmlv02s05nanoxmlv02s06nanoxmlv02s07nanoxmlv03s04nanoxmlv03s09nanoxmlv03s10nanoxmlv05s03nanoxmlv05s05nanoxmlv0509htmlparserbits basebits path bits of informationresidue baseresidue pathresidueaddressbookhtmlparserprinttokens1printtokens2v01s01v01s03v01s05v01s06v02s02v02s03v02s04v02s05v02s06v02s07v03s04v03s09v03s10v05s03v05s05v05s090.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
bits of informationresidueimprovementfigure improvement provided by our approach in terms of bits of information revealed and residue.
.
rq4 improvement rq4 investigates the benefits provided by path condition relaxation and breakable input conditions.
ideally we would have liked to answer rq4 by comparing camouflage against castro and colleagues implementation.
unfortunately their implementation targets x86 binaries and is not publicly available.
we therefore performed a proxy study in which we compared camouflage with a java implementation of castro and colleagues technique that we developed using jpf s symbolic execution engine.
specifically we compared for the two tools the time needed to generate anonymized inputs the percentage of bits of information revealed by such anonymized inputs and the percentage of residue between the original and the anonymized inputs.
these measures are the same ones that we used in sections .
and .
.
figure shows the average improvement achieved by camouflage over our implementation of castro and colleagues technique in terms of percentage of bits of information revealed and percentage of residue.
as the figure shows for all of the faults considered camouflage provides better results.
on average the anonymized inputs generated usingcamouflage revealed less bits of information and contained less residue.
moreover the use of path condition relaxation and breakable input constraints increased only marginally the time needed to generate anonymized inputs.
with the caveat of a potential implementation bias these results provide evidence that the use of path condition relaxation and breakable input constraints can substantially improve the basic technique and the overall inputanonymization process.
.
threats to validity because we used a limited number of subjects and faults and the majority of the considered faults are within one subject our results may not generalize.
however both the subjects and the faults we considered are real and it is reasonable to assume that inputs to these applications may contain sensitive data.
therefore we believe that these results albeit preliminary are promising and motivate further research.
an additional threat is that we determined whether the information remaining after anonymization is sensitive which may introduce bias.
although a human study could have eliminated this threat we do not think that the effort involved in such a study is justified at this stage of the research.
moreover as we mentioned earlier and showed in section .
for the cases considered the distinction between sensitive and non sensitive data was fairly clear cut.
.
related work the technique most closely related to our approach is that by castro and colleagues which we extended through thenovel concepts of path condition relaxation and breakable input conditions.
in addition we perform a more extensive and thorough evaluation on a wider range of inputs and different application types.
finally our evaluation shows that for the cases considered our extensions can considerably improve the effectiveness of input anonymization.
broadwell and colleagues scrash tool uses a form of secure information flow or dynamic tainting to identify where sensitive information is stored inside a crash dump .
during an execution an initial set of data is marked as sensitive.
as the execution progresses any data that is derived from this initial set is also marked as sensitive.
if a crash occurs any data that is marked as sensitive is excluded from the crash dump that is sent to developers.
the main practical limitation of this approach is the difficulty in identifying the initial set of sensitive data it is unreasonable to expect users to perform this step and relying on the application s developers is equivalent to trusting them with access to the sensitive data.
furthermore unlike our technique scrash does not attempt to anonymize sensitive data but simply avoids sending it to the developers which can result in a loss of potentially useful information.
in addition their technique is performed on line and unlike our technique may subject users to high runtime overheads.
wang and colleagues propose an approach panalyst that aims to reconstruct failure inducing inputs on developers machines by using a combination of dynamic taint analysis symbolic execution and collection of answers to questions sent to a client running on the user s machine.
answers provided by the client determine which direction the symbolic execution takes when encountering branches that depend on sensitive information and what values are read or written by memory accesses through sensitive pointers.
the client will answer all questions that do not involve sensitive information but will only disclose up to a predetermined amount of sensitive information.
besides involving a considerable amount of infrastructure the main practical limitation of this technique is like for scrash the difficulty in identifying which information is sensitive.
in addition to these closely related techniques there is also a large body of work concerned with anonymizing data sets before they are released to the public e.g.
.
these approaches aim to maintain statistical properties of the data e.g.
the age distribution across a population while preventing users of the data from uniquely identifying a specific record e.g.
the age of a specific individual .
typically this is accomplished by merging data e.g.
grouping ages or by adding random noise to the data.
because the conditions for reproducing a failure are typically very specific these approaches are not suitable for our scenario.
white box dynamic test generation and fuzzing techniques e.g.
are also tangentially related to our ap929proach.
instead of solving path conditions to obtain a new set of inputs to reach a known failure they iteratively generate and solve new path constraints to explore as many execution paths as possible.
.
conclusions and future work in this paper we presented an approach for automatically anonymizing failure inducing inputs.
our approach extends a previously presented technique through the novel concepts of path condition relaxation and breakable input conditions.
we also presented camouflage a prototype implementation of the approach for java programs and an empirical evaluation of camouflage on failure inducing inputs for several real applications.
the results of the evaluation show that the approach is feasible effective and improves on the state of the art.
for each failure inducing input that we considered camouflage was able to generate an anonymized version that reproduced the original failure in less than minutes.
moreover manual investigation of the anonymized inputs showed that they did not reveal any potentially sensitive information contained in the original inputs and could therefore be safely sent to developers.
in future work we will investigate additional metrics for quantifying the strength of the anonymization.
bits of information revealed and residue constitute a useful starting point but they fail to account for all aspects of privacy loss.
most importantly they do not consider the relative sensitivity of different parts of the inputs.
we also believe that typical users would find these metrics difficult to use as they provide no indication of what is an acceptable percentage of bits of information revealed or residue.
as our evaluation shows even when an anonymized input reveals a relatively large amount of information it may still be safe to collect.
we will also investigate how input minimization techniques can be used together with our technique to improve the anonymization process.
.