building call graphs for embedded client side code in dynamic web applications hung viet nguyen ecpe department iowa state university usachristian k stner school of computer science carnegie mellon university usatien n. nguyen ecpe department iowa state university usa abstract when developing and maintaining a software system programmers often rely on ides to provide editor services such as syntax highlighting auto completion and jump to declaration .
in dynamic web applications such tool support is currently limited to either the server side code or to hand written or generated client side code.
our goal is to build a call graph for providing editor services on client side code while it is still embedded as string literals within server side code.
first we symbolically execute the server side code to identify all possible client side code variations.
subsequently we parse the generated client side code with all its variations into a vardom that compactly represents all dom variations for further analysis.
based on the vardom we build conditional call graphs for embedded html css and js.
our empirical evaluation on real world web applications show that our analysis achieves precision in identifying call graph edges.
of the edges cross php strings and of them cross files in both situations navigation without tool support is tedious and error prone.
categories and subject descriptors f. .
program analysis keywords web code analysis embedded code call graphs .
introduction with the pervasiveness of dynamic web applications supporting developers in implementing and maintaining them becomes increasingly important.
modern integrated development environments ides should provide editor services such as code navigation code completion refactorings and other code analysis tools.
while existing sophisticated ides exist to provide support for programming languages such as java and c support for dynamically typed languages such as php and javascript js is challenging.
supporting dynamic web application raises even additional challenges.
one important characteristic of dynamic web applications is that they work in two stages the first server side stage typically written permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november hong kong china copyright acm ... .
.in php asp jsp etc.
dynamically generates a program that is subsequently executed in the second client side stage typically consisting of html js and css .
in a sense web applications can be seen as program generators or multi stage programs .
the server side code generates the client side code often assembling string literals e.g.
html templates js includes with custom computations that is code elements occurring in the second stage are often represented as string values in the first stage.
contemporary ides support developers in writing and maintaining code either in server side code or in hand written or generated client side code e.g.
providing an editor service jump to declaration for php or javascript .
in fact research on analyses of dynamic programming languages has advanced the ability of ide support for languages such as php and javascript significantly e.g.
.
however contemporary ides do not provide editor support across stages.
that is within the server side code fragments of client side code are merely string constants and an ide would not support navigating in them e.g.
finding a closing html tag navigating to a js declaration .
the staged nature of dynamic web applications prevents a general solution since client side code can be generated from arbitrary sources.
however in practice templates for most client side code are available in server side code as string literals within which meaningful tool support is possible.
our goal is to provide a call graph for client side code while it is still embedded in server side php code in the first stage .
such a call graph can be used in ides to provide various editor services.
specifically we want to support jump to declaration for javascript code embedded in php code jump to closing tag for html tags embedded in php code and find css attributes for css and html embedded in php code even before the client side code is generated as illustrated in figure .
in practice navigating within embedded client side code is often nontrivial.
for example an html element opened in one string literal may be closed in another possibly generated from a different file and processed in a sequence of transformation and concatenation steps.
the target of a jump may even differ among different executions of the php code.
to build the call graph we build a tool chain combining symbolic execution variability aware parsing and call graph analyses.
first we symbolically execute the server side code to identify how the client side code will be generated.
symbolic execution approximates all possible executions of the server side generator such that the generated client side programs may contain symbolic values and conditional parts i.e.
they are generated depending on certain path conditions .
next we parse the generated output into a conditional dom called vardom that compactly represents all variations of the generated server side code.
a vardom is similar to the document object model dom for html but has condition nodes to indicate that certain subtrees of the html document are notgenerated in all executions.
based on the vardom we provide three analyses to build conditional call graphs for html css and js describing call graph edges for navigation among code elements traced back to string literals in the original server side code.
we build our infrastructure on top of our symbolic execution engine phpsync and our variability aware parser framework typechef .
for building call graphs for js we reencode the problem to reuse the wala framework .
we demonstrate that building call graphs for embedded clientside code is efficient and accurate.
in an empirical evaluation on several real word php web applications our analysis achieves precision in identifying possible jumps within seconds.
although the general problem is undecidable our results show that in practical cases we can resolve most client side relationship within server side code.
in addition of the jumps cross php string fragments and of them cross files which suggests that tool support in those cases is valuable.
our key contributions in this paper include the vardom representation which compactly represents dom variations generated from the server side code a tool infrastructure combining symbolic execution and variability aware parsing to build the vardom call graph analyses on the vardom for html css and js tracing nodes to the original string literals in php code and an empirical evaluation to show the analyses accuracy and efficiency.
.
challenges to illustrate the desired call graphs and involved challenges we use the running example in figure adapted from the addressbook6.
.
php application see section .
the example shows a typical scenario in which client side html css and js code is generated from string literals in server side php code.
note that the directive ?php...?
separates php code snippets from inline html code string literals that are printed verbatim when the php program is executed.
depending on the server side execution i.e.
depending on the values of php variables get ajax and rtl different client side programs are generated.
editor services in ides such as syntax highlighting syntax validation auto completion jump to declarations and many others are standard for most languages including php but missing for embedded client side code.
in particular we want to build a call graph for nodes embedded in php string constants that would allow us to navigate from opening to closing html tags from css rules to affected html elements and from js function calls to their declarations.
we illustrate the corresponding call graph edges for our running example in figure .
in building call graphs for embedded client side code we face three key challenges .
embedded client code.
the client side code is dynamically generated from the server side code and is often embedded in php strings and inline html.
for instance the html form tag in our running example is concatenated from a string literal the value of a php variable and another string literal.
html fragments from string literals can be printed directly with echo statements but can just as well be assigned to php variables first processed and printed later as done with input in our example.
call graph edges of embedded code often cross string literals and even php files.
.
conditional client code.
due to the staged nature of generating client side code from server side code a call graph of client side code within server side code can only be approximated and the target of a call may differ among different executions of the server side code.
that is a client side call may have alternative possible targets depending on how the server side code is executed we say that a index.php ?php 2include header.php 4echo form method .
get .
name searchform 6if ajax input input ... onkeyup update 8else input input ... onkeyup update .
input type submit 10echo input 11echo form ?
script type text javascript ?php if ajax ?
function update ... script ?php else ?
function update ... script ?php ?
?php include footer.php ?
b header.php html ... ?php if rtl echo dir rtl ?
... style type text css ?php if rtl ?
footer float left ?php ?
... style ... body ... c footer.php div id footer ... div body html embedded string literal ... call graph edge figure example php program including call graph edges within embedded client side code in string literals generated client side code and edges in a call graph are conditional .
in figure the js call update refers to two different declarations depending on whether the ajax option was selected in the serverside code.
similarly the html script element is closed in two alternative locations and the footer div has different css styles depending on the server side execution.
our goal is to identify all possible call graph edges and document their server side conditions.
.
unresolved values.
when we consider multiple execution paths in php code certain values are not resolved until the php code is executed and may be non deterministic in general.
values may be computed or retrieved from databases files or the user input e.g.
the php variable get obtains its value from the user s query string .
the analysis cannot statically derive their values but must be able to work with uncertainty caused by unresolved values.
.
approach overview our approach builds on the observation that most of the generated client side code that does not come from databases according to our prior study is contained in server side code in the form of php string literals including the inline ?php...?
notation and can be largely traced through the generation process.
variability aware analysis ... ... ... ... ...... ... ......php program vardom js call graph css jumps html jumpsvariability aware html parsersymbolic execution sequence of conditional charsupdate function update update function update div id footer footer ajax !
!
ajax rtl js call graph css jumps html jumps script ... ajax script script l7 fig.
1a l9 fig.
1al16 fig.
1a l20 fig.
1a l1 fig.
1c l4 fig.
1b l14 fig.
1a l18 fig.
1a .. l22 fig.
1a a b output with symbolic values !
!
ajax ..transformfigure a approach overview and b produced call graphs html ifa rtl 3dir rtl endif style type text css ifa rtl footer float left endif style body form method f name searchform ifb ajax input ... onkeyup update else input ... onkeyup update input type submit endif form script type text javascript ... figure an excerpt of the conditional output of the php program represented with conditional compilation directives.
greek letters represent symbolic values in symbolic execution.
to build call graphs we process the server side code in three steps symbolic execution variability aware parsing and analysis as outlined in figure 2a.
.
symbolic execution.
to identify how the client side code will be generated in all possible executions of the server side generator wesymbolically execute the server side code.
during symbolic execution we follow all function calls follow the handling assigning reassigning concatenation printing of string literals and variables explore all conditional branches ifstatements and explore one iteration of each loop in php code.
we use symbolic values to represent non determinism and interactions with the environment e.g.
reading from a database or web service getting the current time etc.
.
the result of symbolic execution is the generated client side code called d model which may contain symbolic values and in which parts of the output are printed only depending on a symbolic path condition.
during symbolic execution we track the origin locations of all string values.
for illustration we represent the output of symbolically executing our running example as a client side program with ifconditional compilation directives in figure .
.
parsing into a vardom.
next we parse this output which contains the approximated client side code of all possible executions with symbolic values.
we ignore symbolic values typically originating from user input or a database since it cannot be the source of a jump to editor command there is nothing in the server side code that a user could jump from and it is unlikely to contain a target see evaluation .
however we preserve the alternatives originating from exploring alternative execution paths in the php program.
that is if the output of a client side code sequence depends on a symbolic decision in the php code we preserve the notion that this sequence is conditional depending on the path constraint .
for parsing we transform the symbolic output into a stream of conditional characters in which each character has a formula representing the path condition under which it was produced.
the token stream contains special sym tokens to represent symbolic values.
to build parse trees from conditional token sequences we use variability aware tooling originally developed for software product lines e.g.
parsing and analyzing all configurations of c code with ifdef directives .
we parse the generated client side code into a conditional dom called vardom that compactly represents all its variations.
a vardom the core of our analysis framework is similar to the document object model dom for html with the addition of condition nodes to indicate that certain subtrees of the html document may vary depending on some condition.
in figure we illustrate the vardom for our running example with condition nodes highlighted.
note how the two js function calls update and their respective declarations are represented in the same vardom with different conditions.
through all parsing steps we track origin locations to vardom nodes.
though beyond our focus the parser can report identified syntax errors in generated client side code and the vardom can be used for syntax validation syntax highlighting and auto completion within php string literals in ides.
.
analysis to build call graphs.
finally we analyze the vardom to build call graphs.
while traditional analyses for static client code work on a single dom our variability aware analyses work on a vardom with conditional parts.
our analyses consider these conditions and build a conditional call graph.
call graph nodes refer to code elements with corresponding origin locations in string literals of the server side code.
call graph edges represent possible jumps between nodes and may have conditions.
specifically we create callgraph edges between opening and corresponding closing html tags between css rules and affected html nodes1 and between js function calls and corresponding function declarations.
for html and css we implement our own analyses for js we reencode the problem to reuse the existing call graph analysis in wala section .
in figure 2b we illustrate the analysis results for the embedded code of our example.
notice how the opening html tag script is related to two alternative closing tags with correspond1these are not traditional calls however similar in ide purposes.
html style body form input input input script !
!
function update !
function update footer float left dir rtl id footer div onkeyup update onkeyup update type submit l7 fig.
1a l9 fig.
1al16 fig.
1a l20 fig.
1al4 fig.
1bl1 fig.
1c element html element html text condhtml attribute name value condition node attribute of an elementdom structuretextdocument document html document script l14 l18 fig.
1al14 l22 fig.
1a rtl ajaxfigure the vardom for the php program in figure ing conditions and how the footer element may or may not have css annotations in different executions.
the conditional call graph is subsequently used for various forms of ide tool support e.g.
jump to declaration jump to closing html tag or find css rules .
.
the v ardom representation our core representation is the vardom a compact structural representation the possible client side programs.
in the following we first describe vardom and subsequently explain how we derive it from php code with symbolic execution and variability aware parsing.
.
vardom representation just as the dom represents the hierarchical syntactic structure of a web page with nested nodes of four types html elements attributes text and comments a vardom represents the tree structure of a web page with variations.
the key difference is that in a vardom all elements can be conditional that is they are part of the web page only given a specific condition called presence condition .
we model conditional elements with condition nodes in the tree where the condition node holds the presence condition for its subtree as illustrated in figure .
note how this representation can compactly represent variations within similar pages in our running example possible client side pages differ with regard to input fields depending on whether ajax is enabled but all pages share the same html and body elements.
conceptually it is possible to move condition nodes up the vardom hierarchy by replicating code fragments yielding a less compact representation see the choice calculus for a formal treatment .
presence conditions in condition nodes refer to decisions during the execution of the server side code.
they originate from path conditions during symbolic execution see below .
during analysis we will attempt to exclude infeasible call graph edges by checking whether a presence condition is satisfiable.
different formalisms are possible with different accuracy and expense tradeoffs.
conceptually any formalism supporting conjunction negation and a mechanism to detect some unsatisfiable formulas is possible we use propositional logic and sat solvers as we will explain.
.
symbolic execution to build the vardom for embedded client side code we need to extract the client side code from the server side php code.
there are several possible strategies from collecting all string literals as they occur in the server side code to tracing the execution of test cases .
we approximate the output of all possibleexecutions of the server side code by executing it symbolically reusing our symbolic execution engine phpsync developed in prior work .
symbolic execution assumes all unknown values user input i o nondeterminism and so forth as symbolic.
when reaching control flow decisions symbolic condition explores all possible paths keeping track of a path condition and ignoring executions with infeasible path constraint.
during symbolic execution we track all output of the executed php code.
output fragments can be concrete produced from string literals inside the php code possibly after several reassignments concatenation and other string processing steps or symbolic.
for each output fragment we record the path constraint under which it was produced.
additionally we track the origin location of each string literals such that we can map all output back to the original php literals.
the output of symbolic execution represents the usually infinite number of possible client side implementations generated from the php code as a stream of characters and symbolic values in which each entry has a path constraint and each character has origin information.
to support developers understanding we store not only the symbolic path condition but also a textual representation of the corresponding conditions php code as comment as shown in figure .
our symbolic execution engine phpsync is unsound but efficient and effective at approximating all possible outputs of the php program.
it performs only coarse tracking of symbolic values e.g.
a 1is tracked as a new symbolic value binstead of tracking expressions exactly we only track string operations such as concatenation exactly it explores exactly one iteration of each loop and aborts on recursion it does not support class and object features in php yet and it uses only conservative approximations to detect some infeasible paths which is undecidable in general .
since our goal is not detecting bugs in the php execution but to extract call graph edges within embedded string literals for tool support these simplifications are acceptable when analyzing embedded client side code from string literals we do not care how often these are printed within a loop exploring infeasible paths will at most identify additional call graph edges with infeasible conditions see next section which a user can often identify quickly.
.
parsing for further analysis we need to transform the character stream into a vardom that represents the structures of the client side implementation.
since the output of symbolic execution contains conditional characters only printed under given path constraints and symbolic characters parsing is challenging.
fortunately the prob variability aware parser if a endif if b else endif 1code with variability ast with variabilitytypechef variability aware parser frameworklanguage grammar 3true seq.
of conditional tokens charactersvariability aware lexer a b !b atrue b true b !b true figure example of variability aware parsing with typechef lem resembles closely the challenge of parsing unpreprocessed c code that still contains ifdirectives which we solved recently .
to illustrate the similarities we already listed the output of symbolic execution as code with ifdirectives in figure .
next we describe our variability aware parser framework typechef originally developed for c code and subsequently explain how we use it to parse the vardom with a lexer a sax parser and a dom parser.
.
the variability aware parser framework.
the parser framework typechef provides a library of variability aware parser combinators that can be used to develop parsers for different languages.
all parsers expect a sequence of conditional elements with a presence condition each as input and produce a single parse tree with condition nodes again with presence conditions as a result.
the parser combinators handle variability during the parsing process by forking subparsers when encountering conditional tokens and join subparsers subsequently.
since it exploits sharing among configurations variability aware parsing is much faster than a brute force approach of parsing all variants separately.
details of the typechef parser framework are described elsewhere and equivalent strategies based on lr parsers have been developed subsequently here we use typechef as is to develop new variability aware parsers.
parsers written with the typechef combinators do not make any assumptions about how presence conditions are used in the input i.e.
ifdirectives do not need to align with the underlying code structure.
variability aware parsing is sound and complete with regard to a brute force approach that would parse every possible configuration separately with a traditional parser it reports conditional parser errors if some configurations cannot be parsed and returns an parse tree for the remaining configuration.
in case presence conditions do not align with the underlying structure of the host language the parser parses local sequences multiple times and locally replicates code until alternative conditional parsing structures can be recognized as visible from the s expression example with two alternative closing parentheses for the inner s expression.
as an illustration figure shows variability aware parsing of s expressions using typechef.
a list of conditional tokens created from a code fragment with if is parsed into an s expression structure with three conditional children precisely and compactly representing the possible s expressions in all configurations without replicating shared structures such as the literal .
.
from symbolic execution output to conditional character streams lexing .
from symbolic execution s output the lexer produces a sequence of conditional characters.
the condition of each character is derived from the path constraint under which the output was produced during symbolic execution represented with if directives in figure .
we preserve the same formalism for formulas and satisfiability checking used during symbolic execution propositional formulas and sat solvers in our implementation .
the lexerproduces a special sym token for symbolic values in the output and propagates origin locations from the php code for every individual character.
we exemplify the step for our example in figure .
.
sax parser.
to deal with the complexity of html we proceed in two steps common in html parsers.
the first step recognizes nodes and their attributes in a flat structure sax style parsing whereas the second step builds a tree from those nodes dom parser .
the sax parser takes the stream of conditional characters and produces a list of conditional nodes.
nodes can be opening tags with a name and possibly conditional attributes e.g.
div id i closing tags with a name e.g.
div or text fragments containing possibly conditional characters.
the parser accepts symbolic tokens in text as tag names as attribute names as attribute values or as whitespace.
as seen in figure this parsing step produces a very shallow parse tree of a document with a list of conditional tags texts and comments of which start tags can contain conditional attributes and texts comments can contain conditional characters.
the parser framework propagates origin locations and presence conditions.
.
dom parser.
in the second parsing step we use the document s list of conditional nodes from the previous step as conditional token sequence for the subsequent dom parser.
the dom parser itself is simple since it recognizes only a tree structure based on matching starting and closing tags.
however the context sensitive nature of checking well formedness in html requires matching names in opening and closing tags for which we wrote a simple combinator.
again the parser framework propagates origin locations and presence conditions.
in the vardom of our running example exemplified in figure the first input field is guarded by condition nodeb ajax and the other input fields are guarded by condition nodes b !
ajax .
note we simply propagate attributes inside nodes and variations inside text nodes from the sax parser.
.
reporting parsing errors.
during parsing the two parsers reject ill formed html code the first parser rejects invalid syntax of tags and attributes and the second parser rejects invalid nesting and missing closing tags .
in each case the parsers report a conditional error message for invalid configurations with location information tracked from the initial php code and a parse tree for the remaining configurations.
for example the html dom parser would report a missing closing tag for div in line in the example below in the configurations with cevaluating to true.
although relaxed or errorrecovering parsing is conceptually possible rejecting ill formed code has the additional benefit of being able to report client side errors during development while embedded in server side code.
in addition we could easily check validity and other invariants on top of the vardom representation reporting conditional error messages when structural assumptions are violated.
php code output of symb.
exec.
1if c div div 3else div 5echo form .
div.
form form ifa c div endif form .
assumptions and limitations.
the output of symbolic execution may contain symbolic values representing a potentially infinite number of possible client side programs.
the symbolic execution engine however explores only a finite number of paths in the serverside code due to our simplifications with regard to loops and recursion section .
which allows us to parse the output into a structure with a finite number of variations expressed through condition nodes assuming that symbolic values do not affect the output s structure.
specifically we assume that symbolic values produce tag names attribute names or attribute values when used in that location and form method name searchform if ajax input ... onkeyup update input else input ... onkeyup update input input type submit input endif form output with variability variability aware html sax parsersequence of conditional characters sequence of conditional tokensopentag form variability aware lexer truef trueo truer truem true i n p !
i !
n !
m true .. .. .. .. opentag input closetag input opentag input !
closetag form .. form input input input !
!
onkeyup update onkeyup update type submit document method sym method sym name searchform name searchform vardom excerpt variability aware html dom parser truer trueu t .. o truel4 fig.
1a l4 fig.
1adocumentl4 fig.
1al4 fig.
1a sym true ..figure parsing output with variability to build a vardom produce well formed html fragments otherwise in which case we can parse it as text or white space .
for example we fundamentally could not parse the output div y if we had to assume that ymight provide the closing tag.
although it is easy to construct artificial examples that we cannot parse we have not seen a code fragment in practice in which a symbolic value e.g.
from user input or another source of nondeterminism affected the structural well formedness of produced client side code.
.
building call graphs the vardom is the basis for all subsequent analyses to build conditional call graphs that can be used for tool support.
even though not executable we interpret relationships among html and css elements as call graph edges as well since they equally provide a foundation for corresponding editor services.
in general a conditional call graph consists of nodes reflecting positions in the server side code2and edges representing relationships among those nodes calls corresponding tags affected css rules and so forth .
edges in a conditional call graph can have a presence condition meaning that the node is related to another node only in certain executions of the server side program.
for example an opening html tag can be closed by two different closing tags resulting in two conditional call graph edges as illustrated with the script tag in our running example see figures and 2b .
as usual call graph edges can be navigated in both directions for different editor services e.g.
jump to declaration versus find usage .
if the server side code has multiple entry points e.g.
multiple .php files a user can call we build vardoms and analyze them separately for each entry point and subsequently merge all call graphs in which the nodes point to the same php code locations.
we illustrate three analyses to extract conditional call graphs for ide support in html jump to opening closing tag css jump to affected nodes and find applicable css rules and javascript jump to declaration each while embedded in server side code.
2technically a node can refer to multiple positions in the source code if it was concatenated from multiple string literals.
.
supporting html jumps for an html jump we define a source as an html opening tagand a target as its corresponding closing tag either the entire tag or the name of the tag .
this type of jumps is useful in helping developers understand the structures of html tags that would be produced by their php program and find closing elements especially if they are generated from different php files such as the body tag in our running example.
building call graph edges for html jumps is straightforward.
we simply traverse the vardom and look up the origin locations of the opening and closing tags of each element as explained in section .
tokens representing opening and closing tags produced by the sax parser are used in the dom parser .
we create a call graph edge between those locations with a presence condition reflecting the element s presence condition in the vardom i.e.
a conjunction of all condition nodes between the element and the vardom s root .
when an element has alternative opening or closing tags it occurs repeatedly in the vardom under alternative presence conditions e.g.
the two script elements in figures 2b and .
.
supporting css jumps css code consists of css rules to define styles for html elements.
we create call graph edges between css rules and all html elements selected by them to support navigation among those elements within server side code similar to the debugging facilities that many browsers provide for generated client side code.
unlike our html jump analysis in which opening and closing tags are directly available in the vardom we need to extract css rules from text fragments in the vardom typically from style tags and from included potentially generated files.
notice that each css fragment is a sequence of conditional characters in which we preserved the presence condition of the originating html element and which may contain symbolic values.
to analyze the css code with its variations we wrote another variability aware parser with typechef to recognize css as a list of conditional rules ignoring symbolic values as white space illustrated in figure .
the parser framework propagates origin locations and presence conditions.vardomextract css code css code with variability sequence of conditional characters style footer float left .news color blue variability aware css parserstylesheet css ast with variabilityrule selector .news declaration color blue f o o t .
n e w s true... ...... rule selector footer declaration float left ...figure parsing css code with variability after parsing we only need to match the selector of each css rule against the vardom nodes.
we create a call graph edge for every match in the vardom each with a presence condition that conjuncts the presence condition of the css rule with the presence condition of the matched html element.
edges with infeasible presence conditions can be filtered as far as the used formalism supports it.
we reimplemented the matching algorithm for the most common selectors class selectors id selectors element selectors and nested selectors implementing remaining selectors is technically straightforward following the specifications of css .
we list the css related call graph edge for our running example in figure 2b.
.
conditional js call graph to build a conditional call graph for js in general we can develop a variability aware analysis from scratch in line with our solution for css.
however due to the complexity of building call graphs already for non embedded js code without conditional parts we want to reuse existing infrastructures for building js call graph.
our key idea is to reencode js code with generation time variability as js code with runtime variability in which the presence conditions of js code are encoded as the conditions of regular js ifstatements enclosing those code elements.
after transforming the code into regular js code still tracking origin locations we reuse wala an existing state of the art tool for building a js call graph .
through consistent origin tracking we can translate the identified call graph nodes and edges back to their location in the vardom and hence also back to the original string literals in php code.
we derive presence conditions for call graph edges from the presence conditions of the involved vardom nodes again filtering infeasible edges.
our goal is to provide editor support such as jump to declaration for js code embedded in server side code for every call graph edge that wala can identify on the generated js code.
.
parsing js code.
as for css we first extract all js code fragments from text elements the vardom.
specifically we collect the content of html script tags linked js files and all event handlers such as onload andonclick .
again we build a variabilityaware js parser on top of the typechef framework that accepts a sequence of conditional characters and produces a js parse tree with conditional nodes ignoring symbolic values .
we follow the js grammar specification but ignore the context sensitive semicoloninserting feature in our prototype.
to simplify subsequent steps we push up conditional nodes to the level of statements that is variations inside statements are expanded to two alternative statements.
.
reencoding variability.
after parsing we reencode generationtime variations condition nodes with presence conditions in theast as runtime variations with ifstatements.
this strategy named configuration lifting orvariability encoding has been used in model checking and deductive verification of product lines to reuse analysis techniques that are oblivious to generation time variations but can handle runtime variations .
we reencode variability with the following two key transformation rules r1 condition cond statement stmt !
ifstatement string cond statement stmt r2 condition cond functiondeclaration name params body !
ifstatement string cond expressionstatement assignmentexpression identifier name functionexpression params body rule r1reencodes a statement stmt under presence condition cond ifcond6 true as a js ifstatement with a condition representingcond andstmt in the then branch e.g.
lines of figure .
rule r2for a function declaration similarly reencodes function declaration as an equivalent assignment of a function expression inside an ifstatement e.g.
lines and of figure .
conceptually it is possible to prove that a reencoding maintains the execution semantics of all configurations e.g.
by showing that the execution semantics of executing the program is not affected by the reencoding in any configuration where a configuration would either remove unnecessary code at generation time or initialize the configuration parameters equivalently to be interpreted at runtime .
for our purpose a strict notion of correctness is not necessary since we perform an unsound call graph analysis subsequently.
it is sufficient to encode the program in a way that the analysis tool can identify the correct call graph edges hence we checked correctness of our encoding through testing only.
.
reencoding html code.
js code can interact with the html dom during execution check existence of an element access its properties and so forth which the used analysis framework wala takes into account to some degree.
wala takes as input an html document and turns it into pure js code which generates the document using js instruction document.createelement .
wala s call graph building algorithm for js is then applied on this transformed js code.
therefore we reencode the entire html code by removing all condition nodes from the vardom.
the resulting html document contains all possible alternative nodes in which all js code is properly reencoded.
this reencoding of html is a crude approximation but sufficient for wala s analysis in our experience.
for instance we reencode our running example as in figure and analyze it with wala.
.
call graph generation with wala.
to create the actual call graph we run wala for js on the reencoded html js code.
we take wala s result as is and track nodes back to their origin in the vardom and in the php code.
we create presence conditions for call graph edges from the conjunction of the presence condition of the two involved vardom nodes.
in our running example wala in fact ignores the conditions of the created ifstatements and creates a total of four call graph edges from each update call to each function declaration.
however since both update calls and declarations depend on the same symbolic path condition in our example i.e.
we know that expression ajax has the same value bin both server side ifstatements two call graph edges receive infeasible presence condition b band can be discarded.
we show the js call graph for our running example in figure 2b.
.
empirical ev aluation our approach to build call graphs has a number of sources of potential inaccuracies.
while variability aware parsing and callgraph building for html and css are conceptually sound symbolic1 html dir rtl style type text css footer float left style body form method f name searchform input ... onkeyup if b update input ... onkeyup if !b update input type submit form script type text javascript if b update function ... script script if !b update function ... script div id footer ... div body html figure reencoding variability execution may not produce output for all string literals parsing has limitations regarding symbolic values and js analysis uses potentially inaccurate reencodings as we explained.
in an evaluation with real world php applications we investigate the practicality and accuracy of our approach.
in addition ide support for navigation is especially useful if callgraph edges are nontrivial e.g.
developers need to search across files .
thus we investigate the complexity of the created call graphs to characterize the usefulness of ide support based on our tooling.
experiment setup.
we collected five php web applications from sourceforge.net with various sizes and without heavy use of object oriented constructs also used in related work .
for each system we selected a main file which might also recursively include other files and ran our analysis on that file.
when encountering html syntax errors during parsing most often due to missing closing tags we manually fixed them in the php code and report results after applying all fixes.
all subject systems have multiple entry points php files that can be called by a user the call graphs of which can be merged but due to the manual effort of fixing syntax errors we considered only a single main file per system.
the main entry file the number of symbolically executed php statements the size of the generated symbolic output the size of js code and the number of fixed errors are listed in table .
.
practicality and accuracy all call graph computations completed within a few seconds seconds on average 12seconds in the worst case .
since this performance is acceptable for executing analyses in the background of an ide we did not perform additional rigorous performance measurements.
currently we need to fix all html syntax errors before we can build call graphs which is a positive side effect but also a laborious endeavor.
an error recovering parser or automated repair tools could help with this step.
overall our tool is easy to set up for a new project by pointing it to the main file s .
precision.
in table we list the number of call graph edges detected in all subject systems.
we manually checked the created call graphs for correctness.
in small call graphs 100edges we inspected all call graph edges in large call graphs we randomly sampled edges each.
we consider a call graph edge as correctwhen it connects two nodes tracked to php string literals and the nodes are actually in a call relationship.
all checked edges were correct yielding a precision of100 .
recall.
in the absence of ground truth recall is more challenging to measure.
we approach recall with three proxy metrics coverage symbolic discipline and reencoding losses addressing the three sources of inaccuracies in our approach.
.
first we can cover only literals that are output as part of an execution of the php code string literals in dead code are never printed and we cannot build call graphs for them .
in addition due to limitations of our symbolic execution engine see section .
we may not cover every possible execution path or may not be able to track some string literals to their output.
to characterize the potential loss of call graph nodes we measure coverage as the ratio between the number of output characters that are covered by symbolic execution and the total number of all output characters in the project.
as a heuristic to ignore string literals that are not output such as array index method in get we only consider literals that contain the representative html tag opening character .
when executing the single main file we cover to of all characters.
when symbolically executing all entry points of the php code we cover on average of all characters see the last column in table .
this shows that symbolic execution can achieve high coverage in our subject systems.
.
second we manually inspected all occurrences of symbolic values in the output of symbolic execution.
we did not find a single case where a symbolic value was relevant for the structure of the vardom.
that is a symbolic value may add substructure but in no case was it required to provide the closing tag for a concrete opening tag or similar structural parts.
this confirms our assumptions in section .
and makes inaccuracies due to symbolic values unlikely in our subject systems.
.
third while html and css analyses are sound with regard to a brute force approach our reencoding for js analysis may lead to documents in which the used js call graph tool wala cannot find all call graph edges.
note that we do not want to check the quality of wala s call graphs but only to what degree our reencoding prevents discovering call graph edges that wala could discover without reencoding.
thus we generated random configurations from the symbolic output i.e.
different selections for the ifdecisions and executed wala on the generated code without variability and without reencoding comparing the resulting call graph edges with the ones identified when analyzing the entire configuration space with reencoding.
we did not find a single case where reencoding lost call graph edges compared to analyzing individual configurations.
overall the results and performance are practical and promising.
in our subject systems our tool yields a perfect precision.
investigating the sources of inaccuracies that lead to reduced recall shows that symbolic execution can cover of string literals and that symbolic values during parsing and reencoding of js are unproblematic.
more details are in table .
.
complexity besides accuracy we investigated the potential benefit of such support.
using the created call graphs we measure several characteristics to show the complexity of the underlying problem suggesting the effort required when developers do not have ide support.
first we investigated the locality of call graph edges.
call graph edges are often nonlocal.
of all html call graph edges on average and up to of js call graph edges connect nodes in different string literals .
that is the connected elements are written in different parts of the server side code with some php code between them.
while many call graph edges for htmltable subject systems and coverage subject system version files loc main entry exec.
output size re encoded js html coverage stmts chars conds stmts re enc errors main entry all entries addressbook ab .
.
index.php schoolmate sm .
.
index.php timeclock tc .
timeclock.php upb .
.
admin forums.php webchess wc .
.
index.php table complexity of call graphs sys.
html jumps css jumps js jumps strings total xstr xfiles total xfiles total xstr on echo ab .
.
sm .
tc .
upb .
wc tot avg .
xstr xfiles number of call graph edges that cross strings files.
avg geometric mean for non zero relative numbers percentages .
.
.
.
.
.
.
distance in lines call graph edges relative html all projects ab js tc js sm js upb js wc js figure cumulative distribution of distance of html and js jumps within the same file depicting the percentage of jumps shorter than a given distance.
are relatively local with source and target in the same line or only few lines apart about .
are more than lines apart and .
are even in different php files.
js call graph edges often span a larger distance an average of lines but were mostly within the same php file.
for css even all call graph edges connect nodes in different files since all css rules are written in separate files in our subject systems.
tool support is especially valuable for long jumps and jumps across files.
details are listed in table and figure .
to characterize how difficult it is to track string literals through php code when they are re assigned concatenated or part of other computations we also tracked how many string literals are printed immediately or appear as inline html code in a php file.
again we track only string literals containing the character .
we found that on average of all such string literals are assigned to variables before they are eventually printed at a different location .
our analysis can follow these string literals and create correct call graphs while navigation without ide support might not be straightforward.
second conditional jumping where one html tag is closed by alternative closing tags depending on the server side execution is achallenge for tools and humans.
our solution with variability aware parsing can correctly handle those cases and create corresponding conditional call graph edges.
we found two cases where the source of an html jump has multiple targets in addressbook andtimeclock each both similar to the script tag in our running example.
here a developer may accidentally finish manual search before finding all relevant closing tags.
in addition we found cases in schoolmate in which call graph edges among nodes with the same name are disambiguated by their respective presence conditions similar to the js update call in our running example.
our results show that the produced client side structure mostly aligns with the server side execution so that these cases are relatively rare in practice.
they also demonstrate that our more powerful infrastructure can provide accurate results in common as well as difficult cases.
finally a common approach for navigation in embedded clientside code is to use a global text search especially for nonlocal jumps.
a naive global text search for closing html tags such as table a andform yields hundreds of results in dozens of files even in the smaller php projects.
a global text search is only more promising for rare tags such as html andbody and uncommon js variables and function names.
for css global text search is almost useless.
a developer would not perform a global search in most cases and in many cases the corresponding jump target is only few lines away see figure but nesting of html tags common jumps across string literals and occasional jumps over many lines of code and even across files see figure and table show that a local search is also not a universal strategy.
the relatively rare but possible case that a jump has alternative targets depending on the server side execution as the script tag in our running example emphasizes that an incomplete local search may actually miss important targets potentially leading to inconsistencies.
overall we conclude that text search can be an effective alternative in many common local cases but that a call graph can support navigation in many nontrivial cases quantified throughout our evaluation.
.
threats to validity regarding external validity we selected only a small sample of medium sized subject systems and investigated only a single main file per project due to the main bottle neck of manually fixing html syntax errors.
while we cannot generalize over arbitrary php systems all systems are real world open source applications developed by others and the results are consistent over all systems.
regarding internal and construct validity we used various proxy metrics to carefully characterize possible recall and usefulness measures.
since we do not have ground truth about what call graphs to expect we decided to break down the evaluation into the three sources of inaccuracies.
implementation defects may also reduce precision and recall but our tests and manual investigations did not reveal any issues.
instead of performing a user study in which the navigation benefit may be buried in noise or over exaggerated with artificial tasks or material we decided to characterize usefulness byquantifying nontrivial call graph edges in which developers could likely benefit from a tool.
we expect a strong correlation with actual improvements in practice but a usability study is still required.
.
related work state of the art ides do not provide call graph based editor support such as jumps to declaration for embedded client code within server side web application.
however there exist analysis approaches for embedded client code to support other software engineering tasks.
analyzing generated client side html code.
the eclipse plugins phpquickfix and phprepair detect and fix errors in server side php applications leading to ill formed generated html.
phpquickfix examines constant prints i.e.
the php statements that print directly string literals and repairs html ill formed errors.
whereas we symbolically execute php code to track how string literals are processed it analyzes each string literal separately and can only identify local issues.
in contrast phprepair follows a dynamic approach in which a given test suite is used to generate client side code with different server side executions while tracing the origin of output strings.
in contrast to their dynamic strategy we symbolically execute php code to approximate all possible executions and subsequently use a variability aware parser to analyze them all.
we additionally detect well formedness issues.
in wang et al.
a user generates the client code by executing the instrumented server side code with a specific input.
changes in that generated code can then be mapped to their origins in the php code using the recorded run time mappings and static impact analysis.
we similarly track origin locations but we symbolically execute the php code.
we previously used our symbolic execution engine phpsync for similar purposes .
first we used our static origin tracking to propagate changes in the client code output of symbolic execution back to the php code .
subsequently we designed drc to analyze both php code and generated client side code to detect cross language and cross stage dangling