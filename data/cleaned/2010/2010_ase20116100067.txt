differential precondition checking a lightweight reusable analysis for refactoring tools jeffrey l. overbey and ralph e. johnson department of computer science university of illinois at urbana champaign overbey2 johnson cs.illinois.edu abstract one of the most difficult parts of building automated refactorings is ensuring that they preserve behavior.
this paper proposes a new technique to check for behavior preservation we call this technique differential precondition checking.
it is simple yet expressive enough to implement the most common refactorings and the core algorithm runs in linear time.
however the main advantage is that a differential precondition checker can be placed in a library and reused in refactoring tools for many different languages the core algorithm can be implemented in a way that is completely language independent.
we have implemented a differential precondition checker and used it in refactoring tools for fortran photran php and bc.
keywords program representation refactoring i. introduction what makes writing a new refactoring tool hard?
what are the parts of such a tool?
one part is the user interface refactoring is interactive and requires a good ui.
but ides like eclipse provide a good framework for building a ui for a refactoring tool and most of the ui for a new refactoring too l can be reused from other tools.
another part is the parser and the general language infrastructure.
people have tried to r euse the infrastructure from compilers and other tools with mixe d results but our previous work shows that it is possible t o generate an infrastructure that is perfectly suited for ref actoring so this is a solved research problem too.
the remaining parts are the refactorings themselves.
automated refactor ings have two parts the transformation the change made to the user s source code and a set of preconditions which ensure that the transformation will produce a program that compile s and executes with the same behavior as the original program.
authors of refactoring tools agree that precondition check ing is much harder than writing the program transformations.
this paper shows how to construct a reusable generic precondition checker which can be placed in a library and reused in refactoring tools for many different languages.
t his makes it easier to implement a refactoring tool for a new language.
we call our technique for checking preconditions differential precondition checking.
a differential precondition checker builds a semantic model of the program prior to transformation simulates the transformation performs semantic che cks on the modified program computes a semantic model of themodified program and then looks for differences between the two semantic models.
the refactoring indicates what differ ences are expected if the actual differences in the semanti c models are all expected then the transformation is conside red to be behavior preserving.
the changes are applied to the user s code only after the differential precondition check er has determined that the transformation is behavior preserving .
this technique is simple practical and minimalistic.
it does not guarantee soundness and it is nota general method for testing program equivalence.
rather it is designed to b e straightforward fast scalable and just expressive enou gh to implement preconditions for the most common refactorings.
most importantly the core algorithm can be implemented in a way that is completely language independent so it can be optimized placed in a library and reused in refactoring to ols for many different languages.
this paper makes five contributions.
relevant section numbers are noted parenthetically.
it characterizes preconditions as guaranteeing input validity compilability andpreservation iii .
it introduces the concept of differential precondition checking iii and shows how it can simplify precondition checking by eliminating compilability and preservation preconditions v .
it observes that semantic relationships between the modified and unmodified parts of the program tend to be the most important and based on this observation proposes a very concise method for refactorings to specify their preservation requirements v .
it describes how the main component of a differential precondition checker called a preservation analysis can be implemented in a way that is both fast and language independent vii .
it provides an evaluation of the technique viii considering its successful application to refactorings and its implementation in refactoring tools for fortran photran php and bc.
ii.
p recondition checking in most tools each refactoring has its own set of preconditions.
these are tested first and the transformation procee ds978 .
c ieee ase lawrence ks usa303 only if they pass.
unfortunately designing a sufficient set of preconditions for a new refactoring is extremely difficul t. the author of the refactoring must exhaustively consider ev ery feature in the target language and somehow guarantee that th e transformation is incapable of producing an error.
conside r java even a simple refactoring like rename must consider naming conflicts namespaces qualifiers shadowing reser ved words inheritance overriding overloading constructo rs visibility inner classes reflection externally visible na mes and special names such as main .
one promising alternative to traditional precondition che cking is to analyze the program after it has been transformed comparing it to the original program to determine whether or not the transformation preserved behavior.
this has been us ed for some dependence based compiler transformations e.g.
afusion preventing dependence is most easily detected after transformation but researchers have appl ied it to refactoring tools only recently.
although this techni que is not yet used in any commercial tools research indicates that it tends to make automated refactorings simpler and mor e robust .
so how can a refactoring tool analyze a program after transformation?
refactorings preserve certain relations hips in the source program.
the rename refactoring preserves a name binding relationship it ensures that every identifier refe rs to the same declaration before and after transformation.
ex tract method and extract local variable preserve control flow and def use chains at the extraction site.
as we will see later in this paper pull up method preserves a name binding relationship as well as a relationship between classes and methods they override.
in our experience the most common refactorings preserve invariant relationships related to name bindings inheritance overriding control flow and def u se chains.
analyzing a program after transformation means ensuring that these invariant relationships are preserved ac ross the transformation.
sch afer et al.
have suggested one way to refactor using invariants like these.
to implement a rename refactoring for java they stored the original name bindings changed names then checked the resulting bindings adding qualifie rs as necessary to guarantee that the name bindings would resol ve identically after the transformation was complete .
the y used a similar approach to implement extract method they stored the original control flow performed the transformat ion then added control flow constructs as necessary to restore the original flow .
they have applied this approach to many other refactorings as well .
in short their appro ach maintains invariants by construction i.e.
while performing the transformation the refactoring checks the invariant a nd if possible adjusts its behavior to preserve it.
the approach taken in this paper is based on some of the same ideas as that of sch afer et al.
but there is a substantial difference in how we perform the preservation check.
the main difference is that our technique when implemented appropriately is language independent the mechanism for specifying preservation requirements and the algorithm fo rperforming the preservation analysis are the same regardl ess of what refactoring is being checked and regardless of what language is being refactored.
this means that unlike the approach of sch afer et al.
our preservation analysis can be implemented in a library and reused verbatim in refactoring tools for many different languages.
iii.
d ifferential precondition checking preconditions determine the conditions under which the program transformation will preserve behavior.
logically this means that they guarantee three properties input validity.
all input from the user is legal it is possible to apply the transformation to the given program with the given inputs.
compilability.
if the transformation is performed the resulting program will compile it will meet all the syntactic and semantic requirements of the target language.
preservation.
if the transformation is performed and the resulting program is compiled and executed it will exhibit the same runtime behavior as the untransformed program.
clearly input validation needs to be performed before the program is transformed since it may not even be possible to perform a transformation if the user provides invalid input .
but compilability is actually easier to determine after transformation essentially it means running the program throu gh a compiler front end.
it turns out that preservation can ofte n be checked a posteriori as well.
when differential precondition checking is employed refactorings proceed as follows analyze source code and produce a program representation.
construct a semantic model called the initial model.
validate user input.
simulate modifying source code and construct a new program representation.
detect compilability errors and if appropriate abandon the refactoring.
construct a semantic model from this new program representation.
this is the derivative model.
perform a preservation analysis by comparing the derivative model with the initial model.
if the preservation analysis succeeds modify the user s source code.
otherwise abandon the refactoring.
what distinguishes differential precondition checking is how it ensures compilability and preservation.
these topic s will be discussed in detail in sections iv and v respectivel y. it ensures compilability by performing essentially the sam e checks that a compiler front end would perform.
it ensures behavior preservation by building semantic models of the program before and after it is transformed.
the refactoring informs the differential precondition checker of what kind s of semantic differences are expected the checker ensures t hat the actual differences in the semantic models are all expect ed304differences hence the name differential precondition checking.
note that a differential precondition checker contrasts th e program s semantic model after transformation with its semantic model before transformation.
this is different from program metamorphosis systems which provide an expected semantic model and then determine whether the transformed program s semantic model is equivalent to the expected mode l. as we will see in v d v f the mechanism for specifying expected differences in a differential precondition check er is fairly coarse grained it does not uniquely characteriz e the semantics of a particular transformed program but rathe r identifies in general how a refactoring is expected to affe ct programs semantics.
iv.
c hecking compilability checking for compilability means ensuring that the refactored program does not contain any syntactic or semantic errors i.e.
that it is a legal program in the target languag e. these errors would usually be detected by the compiler s front end.
typically these check constraints like no two l ocal variables in the same scope shall have the same name and a class shall not inherit from itself.
when differential precondition checking is employed these checks are performed in step above and they are used in lieu of traditional precondition checks.
for example a refactoring renaming a local variable atobwould not explicitly test for a conflicting local variable named b instead it would simply change the declaration of atob and if this resulted in a conflict it would be detected by the compilabil ity check.
in fact most refactoring tools already contain most of the infrastructure needed to check for compilability.
it is virtually impossible to perform any complicated refactori ngs without a parser abstract syntax tree ast and name bindi ng information symbol tables .
a type checker is usually need ed to resolve name bindings for members of record types as well as for refactorings like extract local variable.
so refact oring tools generally contain most of a compiler front end.
step s and above involve running source code through this front end.
so checking for compilability in step is natural.
the literature contains fairly compelling evidence for including a compilability check in a refactoring tool.
compil ability checking subsumes some highly nontrivial precondition s preconditions that developers have missed in traditiona l refactoring implementations.
verbaere et al.
identify a bug in several tools extract method refactorings in which the extracted method may return the value of a variable which has not been assigned a problem which will be identified by a compilability check.
sch afer et al.
describe a bug in eclipse jdt s rename refactoring which amounts to a failure to preserve name bindings.
daniel et al.
reporte d 1why differential precondition checking?
a refactoring ta kes user input iand uses it to determine a program transformation t i .
however a precondition for the application oft i to the user s source code is that it satisfies the properties of compilability and preservatio n.bugs on eclipse jdt and on netbeans.
of the eclipse bugs would have been caught by a compilability check.
seven of these identified missing preconditions 2the others were actually errors in the transformation that manifested as compilation errors.
compilability checking also serves as a sanity check.
in the presence of a buggy or incomplete transformation it analyz es what the transformation actually did not what it was supposed to do.
if the code will not compile after refactoring the transformation almost certainly did something wrong and t he user should be notified.
v. c hecking preservation compilability checking is important but simple.
checking for preservation is more challenging.
it involves choosing an appropriate semantic model and finding a preservation analy sis algorithm that balances speed correctness and generalit y. in this section we will use a program graph as the semantic model.
in section vii we will use a slightly different seman tic model based on the same ideas.
in the remainder of this section we will discuss what program graphs are v a and how they can be used as an analysis representation for a refactoring tool v b .
then we will discuss what preservation means in the context of a program graph v c and how it can be used instead of traditional precondition checks using safe delete and pul l up method as examples v d v f .
the discussion here is conceptual in nature a more detailed formal treatment wil l appear in the first author s dissertation .
a. program graphs one program representation which has enjoyed success in the refactoring literature is called a program graph .
a program graph may be viewed in broad lines as an abstract syntax tree augmented by extra edges .
these extra edges which we will call semantic edges represent semantic information such as name bindings control flow inheritance relationships and so forth.
alternatively o ne might think of a program graph as an ast with the graph structures of a control flow graph du chains etc.
superimposed the nodes of the ast serve as nodes of the various graph structures.
an example of a java program and a plausible program graph representation are shown in figure .
the underlying abstract syntax tree is shown in outline form the dotted lin es are the extra edges that make the ast a program graph.
we have shown three types of edges.
name binding edges link the use of an identifier to its corresponding declaration.
wi thin the method body control flow edges form the intraprocedural control flow graph the method declaration node is used as the entry block and null as the exit block.
similarly there are t wo du chains given by def use edges.
program graphs are appealing because they summarize the interesting aspects of both the syntax and semantics of 2bugs and 006305class name test2 body field type int name field initialvalue intconstant value method returntype void name fun arguments none body i localvariable type int name i initialvalue intconstant value ii postincrement variable i iii postincrement variable field iv methodinvocation name system.out.println arguments variableaccess variable i binding binding binding control flow control flow control flow control flow def use def use class test2 int field void fun int i i field system.out.println i fig.
.
example java program and corresponding program graph a program in a single representation obviating the need to maintain a mapping between several distinct representatio ns.
moreover they are defined abstractly the definition of a program graph does not state what types of semantic edges are included.
a person designing a program graph is free to include or exclude virtually any type of edge imaginable depending on the language being refactored and needs of the refactorings that will be implemented.
for the refactori ngs we considered see viii we found five types of edges to be useful name binding control flow def use override edges which link an overriding method to the overridden implementation in a superclass and inheritance edges which link a class to the concrete methods it inherits from a superclass .
b. program graphs and ast manipulation in the end refactoring tools manipulate source code.
however when building a refactoring it is helpful to think of manipulating the ast instead.
adding a node means inserting source code.
replacing a node means replacing part of the source code.
and so on.
this does not change when a program graph is used in a refactoring tool.
a program graph is always derived from an ast.
the content of the ast determines what semantic edges will be superimposed.
semantic edges cannot be manipulated directly they can only change as a side effect of modifying the ast.
in fact that observation will serve as the basis of our preservation analysis.
when we modify an ast we will indicate which semantic edges we expect to be preserved and which ones we expect to change.
then after the source code has been modified we will determine what semanticedges were actually preserved and compare this with our expectations.
c. preservation in program graphs this raises a question what does it mean for a semantic edge to be preserved when an ast is modified?
we would like to say if both the modified and unmodified asts contain an edge with the same type and the same endpoints that edge has been preserved.
unfortunately it is not clear what the same endpoints are since the ast has been modified and the endpoints are ast nodes.
consider a refactoring which replaces the expression x x with the constant .
when applied to the expression x x this corresponds to the following tree transformation.
xx when a subtree is changed i.e.
added moved removed or replaced in an ast we will call that the affected subtree.
a gray triangle surrounds the affected subtrees in the figure above.
using that figure as an example consider how ast nodes in the unmodified ast correspond with nodes in the modified ast there is an obvious correspondence between ast nodes outside the affected subtrees since those parts of the ast were unaffected by the transformation.
as a whole the affected subtree before the transformation corresponds to the affected subtree after the transformation.
in general there is no correspondence between nodes inside the affected subtrees.
recall that our goal is to determine if a semantic edge has the same endpoints before and after an ast transformation .
this is easy if an endpoint is outside the affected subtree or if that endpoint is the affected subtree itself.
but if the endpoint is inside the affected subtree we cannot determine exactly which node it should correspond to.
.
.
except that i f it corresponds to anything that node would be in the other affected subtree.
since we cannot determine a correspondence between ast nodes inside the affected subtree we will collapse the affected subtrees into single nodes.
this makes the ast before transformation isomorphic to the ast after transformation.
collapsed collapsed now suppose we have superimposed semantic edges to form a program graph.
when we collapse the affected subtree to a single node we will also need to adjust the endpoints of the semantic edges accordingly when an affected subtree is collapsed to a single node if any semantic edges have an endpoint inside the affected subtree that endpoint will instead point to the collapsed node.
note in particular that if an edge has both endpoints inside the affected subtree it will become a self loop on the collapse d node.
also note that a program graph is not a multigraph if several edges have the same types and endpoints in the collapsed graph they will be merged into a single edge.
collapsing the affected subtree in a program graph actually has a fairly intuitive interpretation if we replace one sub tree with a different subtree that supposedly does the same thing then the new subtree should interface with its surroundings in mostly the same way that the old subtree did.
that is all of the edges that extended into the old subtree should also exte nd into the new subtree and all of the edges that emanated from the old subtree should also emanate from the new subtree.
there may be some differences within the affected subtree but the interface with the rest of the ast stays the same.
in some cases we will find it helpful to replace one subtree with several subtrees or conversely to replace several subtrees with one .
for example encapsulate variable removes a public variable replacing it with a private variable an accessor method and a mutator method.
in other words we are modifying several subtrees at the same time.
in these cases we have an affected forest rather than a single affected subtree.
however the preservation rule is essentially the same all of subtrees in the affected forest are collapsed into a singl e unit.
so if an edge extended into some part of the affected forest before transformation it should also extend into so me part of the affected forest after transformation.
in the cas e of encapsulate variable this correctly models the idea that e very name binding that pointed to the original public variable should instead point to either the new private variable the accessor method or the mutator method.
we will see an example of an affected forest when we discuss pull up method in v f. d. specifying preservation requirements now that we have established how to determine whether a semantic edge has been preserved across a transformation we turn to a different question how can we express which semantic edges we expect to be preserved and which ones we expect to change?
edge classifications from the above description we can see that whether we want to preserve an edge depends on its type as well as its relationship to the affected subtre e. therefore it is helpful to classify every semantic edge as e ither internal both endpoints of the semantic edge occur within the affected subtree external neither endpoint occurs within the affected subtree incoming the head of the semantic edge is outside the affected subtree but the tail is inside it or outgoing the head is inside the affected subtree and the tail is outside it .
notation now we can establish some notation.
to indicate what edges we do not expect to preserve we must indicate three things the type s of edges to preserve.
we will use the letters n c d o andito denote name binding control flow def use override and inheritance edges respectively.
note however that program graphs may contain other types of edges as well depending on the language being refactored and the requirements of the refactorings being implemented.
the classification s of edges to preserve.
we will use anticlockwise and to indicate incoming outgoing internal and external edges respectively.
we will use as a shorthand for describing both incoming and outgoing edges.
whether we expect the transformation to introduce additional edges or remove existing edges.
if additional edges may be introduced we denote this using the symbol i.e.
the transformed program will contain a superset of the original edges .
if existing edges may be eliminated we denote this by .
if edges may be both added and removed then we cannot effectively test for preservation so those edges will be ignored we indicate this using the symbol ?.
otherwise we expect a correspondence between edges i.e.
edges should be preserved exactly.
we indicate this by .
e. example safe delete fortran to make these ideas more concrete let us first consider a safe delete refactoring for fortran which deletes an unrefe renced internal subprogram.
the traditional version of this refactoring has only one precondition there must be no