observable modified condition decision coverage michael whalen gregory gay dongjiang you mats p.e.
heimdahl department of computer science and engineering university of minnesota usamatt staats division of web sciences technology korea advanced institute of science technology south korea abstract in many critical systems domains test suite adequacy is currently measured using structural coverage metrics over the source code.
of particular interest is the modified condition decision coverage mc dc criterion required for e.g.
critical avionics systems.
in previous investigations we have found that the efficacy of such test suites is highly dependent on the structure of the program under test and the choice of variables monitored by the oracle.
mc dc adequate tests would frequently exercise faulty code but the effects of the faults would not propagate to the monitored oracle variables.
in this report we combine the mc dc coverage metric with a notion of observability that helps ensure that the result of a fault encountered when covering a structural obligation propagates to a monitored variable we term this new coverage criterion observable mc dc omc dc .
we hypothesize this path requirement will make structural coverage metrics .
more effective at revealing faults .
more robust to changes in program structure and .
more robust to the choice of variables monitored.
we assess the efficacy and sensitivity to program structure of omc dc as compared to masking mc dc using four subsystems from the civil avionics domain and the control logic of a microwave.
we have found that test suites satisfying omc dc are significantly more effective than test suites satisfying mc dc revealing up to more faults and are less sensitive to program structure and the choice of monitored variables.
i. i ntroduction test adequacy metrics defined over the structure of a program such as branch coverage and modified condition decision coverage mc dc have been used for decades to assess the adequacy of test suites.
such criteria can be useful tools when evaluating a testing effort.
nevertheless these criteria are quite sensitive to the structure of the program under test e.g.
the complexity of boolean expressions .
in our work we have been particularly interested in the coverage criterion modified condition decision coverage mc dc since it is used as an exit criterion when testing software for critical software in the avionics domain.
for certification of such software a vendor must demonstrate that the test suite provides mc dc coverage of the source code .
in previous investigations we have found that the effectiveness of mc dc is highly dependent on the syntactic structure of the code under test.
a simple syntactic transformation such as inlining variables eliminating intermediate boolean values to create more complex decisions can dramatically improve the effectiveness of the mc dc criterion with increases in fault detection of up to .when examining the discrepancy in fault finding between test suites for non inlined and inlined programs we often found that the test case encountered a fault in the code e.g.
an erroneous boolean operator leading to a corrupted internal state but this state was masked out in a subsequent condition and did not propagate to an output.
this effect was far more prevalent in programs with many small boolean expressions whose results were stored in intermediate values a non inlined implementation .
furthermore in both non inlined and inlined programs it was common that a test case encountered a fault leading to a corrupted internal state but the test case was too short to allow the corrupted state to propagate to an output the test case terminated before the corrupted state became visible in a variable monitored by the test oracle.
the underlying issue is that structural coverage criteria such as mc dc require only that each syntactic element in the case of mc dc a particular truth assignment of a decision is covered.
nevertheless covering an element does not ensure faults found will be observed by a test oracle.
in the case of mc dc the effects of masking and test length can be overcome if the test oracle monitors all variables in the program under test i.e.
all internal state variables as well as all outputs but this is often prohibitively expensive.
instead we would prefer to use a coverage criterion requiring that the result of the covered syntactic structure e.g.
a condition be likely to propagate to the test oracle variables.
to address this issue we have defined observable modified condition decision coverage omc dc .
omc dc combines the coverage of decisions required by mc dc with a path condition that increases the likelihood that a fault encountered when executing the decision will propagate to a monitored variable.
unlike previous extensions to mc dc this path condition does not increase the number of test obligations over mc dc instead it makes the existing obligations more difficult to satisfy since the possibility of propagating a fault revealed by the mc dc obligation must also be demonstrated.
we hypothesize that this additional observability obligation will improve the effectiveness of the mc dc criterion particularly when used as a test generation target for automated tools paired with output based test oracles.
the idea of observability has been explored in hardware testing but our ideas extend this work in several ways.
first we provide a straightforward semantic definition of observability to ground the discussion of the metric.
second the hardware work is pessimistically inaccurate it states that978 c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.102certain observable obligations using our semantic definition are not observable making it unsuitable as a coverage target for critical software.
finally we describe the close connection between the notion of observability and mc dc.
in this paper we present experiments conducted on four subsystems from the civil avionics domain and one example of the logic control of a microwave.
our results indicate that test suites generated to satisfy achievable omc dc over non inlined systems achieve between and better fault finding than test suites providing achievable mc dc when using an oracle observing the output variables only.
when using an oracle observing all state variables the advantage of omc dc diminishes but it is still significant to better fault finding than mc dc with a median improvement of .
.
we also observed that omc dc is dramatically less sensitive to the structure of the program under test than mc dc a highly desirable trait of a structural test adequacy metric.
based on these results omc dc is for the systems studied a far more effective test adequacy coverage criterion both in terms of fault finding and robustness to changes in program structure and variables monitored by the test oracle.
ii.
b ackground and problem statement modified condition decision coverage mc dc is a white box structural coverage metric developed as a compromise between the benefits of multiple condition coverage and the lower number of test cases required by condition decision coverage .
a test suite provides mc dc over the structure of a program or model if every condition within a decision has taken on all possible outcomes at least once and every condition has been shown to independently affect the decision s outcome the condition of interest cannot be masked out by the other conditions in the decision .
note that when discussing mc dc a decision is defined to be any boolean expression and a condition is an atomic boolean expression with no connectives such as and oror.
while mc dc ensures that a condition will not be masked out in a decision it is still possible that the condition will ultimately be masked out within some sequence of statements in a program.
as an example consider the trivial program fragment in table i. based on the definition of mc dc testset1 in table i provides mc dc over the program fragment the test cases with in 3 false bold faced contribute towards mc dc of in 1 or in 2 in stmt1.
nevertheless if our oracle monitors the output variable out 1 the effect of in 1 andin 2 cannot be observed in the output since it will be masked out by in 3 false .
thus testset1 gives us mc dc coverage of the program fragment but a fault on the first line will never propagate to the output.
on the other hand testset2 will also give mc dc coverage of the program but since in 3 true in the first two test cases faults in the first statement can propagate to an output.
this masking problem can be addressed by monitoring all internal state variables but the use of such a strong test oracle is often cost prohibitive or outright infeasible .
an alternativetable i sample program susceptible to masking expr 1 in 1 or in 2 stmt1 out 1 expr 1 and in 3 stmt2 sample test sets for in in in testset1 f tff ftf fft ttt g testset2 f tft ftt fft tff g approach is to strengthen the coverage criterion to include a notion of observability of expressions in the variables monitored by the test oracle.
to this effect in this paper we propose a new test adequacy coverage criterion observable mc dc omc dc .
informally omc dc establishes observability of decisions by requiring that the variable whose assignment contains a particular boolean decision remains unmasked through a path to a variable monitored by the test oracle commonly an output variable .
observability is a measure of how well internal states of a system can be inferred usually through the values of its external outputs .
we state that an expression in a program isobservable in a test case if we can modify its value leaving the rest of the program intact and observe changes in the output of the system.
if we cannot find such a value then the expression is not observable for that test case.
more formally we can view a deterministic program p containing expression eas a transformer from inputs to outputs p i!o.
we writep for program pwhere the computed value for the nthinstance of expression eis replaced by value v. note that this is not substitution but akin to mutation we are replacing a single instance of expression erather than all instances.
we say eis observable in test t if9v p t p t .
this idea can be straightforwardly lifted from test cases to test suites.
this formulation is a generalization of the semantic idea behind masking mc dc lifted from decisions to programs.
for masking mc dc the main obligation1is that given decisiond for each condition cind we want a pair of test cases tiandtjthat ensurecis observable for both trueandfalse values d ti d ti d tj d tj .
given this definition one can directly lift mc dc obligations to observable mc dc obligations by moving the observability obligation from the decision to the program output.
given test suitet the omc dc obligations are 8cn2cond p 9t2t p t p t 9t2t p t p t wherecond p is the set of all conditions in program p. iii.
t agged semantics unfortunately the semantic definition for observability is unwieldy both for test generation and especially for test 1the other obligations being that each decision evaluates to both true and false and that each entry and exit point has been invoked these can be added to the observable mcdc criteria with no difficulty.103measurement.
first the analysis requires that two versions of the program run in parallel to check that the results match.
second for test measurement the test suite must be run separately for each pair of modified programs.
in order to define an observability constraint that more efficiently supports monitoring and test generation we approximate semantic observability using a tagging semantics similar to .
we assign each condition a tag and then track the observability of these tags through the execution of a program.
if a tag reaches the output we consider the obligation satisfied.
more accurately we track pairs the first is the condition tag uniquely assigned for each condition instance in the program syntax and the second is the boolean outcome of the condition.
the level of coverage for a test suite can be assessed by examining how many of all possible pairs within the program have reached an output in some test.
to demonstrate the generality of the approach we define semantics both for an imperative command language and a simple dataflow language sharing a common set of expressions shown in table ii.
for presentation we use a reduction semantics with evaluation contexts rsec which we machine checked for consistency using the k tool suite .
the rules operate over configurations that contain the syntax being evaluated k and a set of labeled configuration parameters.
to simplify presentation elements of the configuration are not shown in rules if not used or modified.
the rules operate by applying rewrites at positions in the syntax that are allowed by the evaluation context thecontext definition .
a context is a program or fragment of a program with a hole where the hole represented by defines a placeholder where a rewrite can occur.
we assume appropriate definitions for maps including lookup x and update operations the empty map and lists with concatenation x yand cons elem x operators.
during rewriting additional syntax may be introduced we distinguish this syntax from user level syntax by formatting it against a gray background.
expressions yield val ts pairs where tsis a set of tags and are evaluated in a context containing environment eof typeenv id!
val ts .
the expressions are standard except the tag t e expression which adds a tag to the set of tags associated with the expression e. for omc dc it is assumed that each condition is wrapped in atag expression.
the boolean operators and ordefine masking given aandb the value of aonly matters if bis true soa s tags only propagate if bis true and vice versa or is similar and not shown in table ii due to space constraints.
the imperative language semantics describe how tags propagate through commands.
the main issue involves conditional statements tags in conditions should propagate through all variables assigned in either branch as a condition may affect the value of the variable by notassigning it.
we extend the expression configuration to include c tsto store the set of condition tags.
conditional statements add tags to cthat must be removed once the statement has completed.
to do so anend statement is appended to reset cand propagate the conditional tags to all variables assigned in the conditionaltable ii syntax and tagging semantics for an imperative and dataflow language expression syntax context and semantics e valjidjeopejnotej e?e ejtag e t j val ts jaddtags e ts context jcontext opejeopcontextjnotcontextj context ?e ejaddtags context ts j hk context e env i litn n varhe i he i ifx2dom op n0 l0 n1 l1 n0 n1 l0 l1 and1 tt l0 and tt l1 tt l0 l1 and2 tt l0 and ff l1 ff l1 and3 ff l0 and ff l0 ite1 tt l0 ?et ee addtags et l0 ite2 ff l0 ?et ee addtags ee l0 tag tag t v l v l f t v g addt addtags v l0 l1 v l0 l1 imperative command syntax context and semantics s skipjs sjifethenselsesj id ejwhileedosjend list id ts context jid contextjifcontext thenselsesj context sjhk context e env c tsi asgnhe i he i seq skip s2 s2 cond 1hc ci hc c wherev assigneds1 assigneds2 cond 2hc ci hc c wherev assigneds1 assigneds2 while while e s if e then s while e s else skip endcond 1hc c0i hc ci endcond 2he c c0i he c c0i where x n l and progs hk s e c i dataflow program syntax context and semantics eq id ejid pre e prog i env listeq context jcontext listeqjcontext listeqj eq contextjid contextjid pre context j hk context i listenv o listenv e env s env i combhe ieqs0 x n l eqs1 he ieqs0 eqs statehs ieqs0 x pre n l eqs1 hs ieqs0 eqs writeho e cinil eqs ho e cieqs cyclehi i e s lieqs hi e i l s ieqs eqs prog i s eqs hi i o nil s s e k eqsi104body using assigneds a helper function that returns the list of variables assigned by a statement s .
given a context containing input variable values these rules determine the set of tags that propagate to outputs.
dataflow languages such as simulink and scade are popular for model based development and assign values to a set of equations in response to periodic inputs.
to store system state state variables zblocks in simulink are used.
our dataflow language consists of assignments to combinatorial and state variables and the semantics are defined over lists traces of input variable values.
the expression configuration is extended to contain an input trace i output trace o and state environments s. evaluation proceeds by cycles at the beginning of a cycle the cycle rule constructs the initial evaluation environment.
during a cycle variable values are recorded using the comb andstate rules.
note that the context does not force an ordering on evaluation of equations instead an equation can evaluate as soon as all variables it uses have been stored in the environment.
when all equations have been computed the write rule appends the environment to the output list.
the prog rule given an input list an initial state environment and a list of equations initializes the configuration for the cycle rule.
coverage can be determined by examining the tags stored in the output environment list.
note that both the tagging semantics are optimistically inaccurate with respect to observability that is they may report that certain conditions are observable when they are not.
this is easily demonstrated by a small code fragment if c then out else out the semantic model of observability will correctly report that cis not observable it cannot affect the outcome of this code fragment.
however the tagging model propagates the tags of cto the assignments in the then andelse branches.
iv.
t estgeneration for dataflow programs in the previous section we presented an extended semantics that accounts for tags in imperative and dataflow programs.
in order to generate tests we would like to instead annotate the program and describe trap properties to track the tags.
we will generate test obligations such that each obligation is suitable for tracking a single tag and determining whether it propagates to an output.
this is accomplished by conjoining an mc dc coverage obligation over a single variable as described in with a path condition representing the variable s observability at one of the monitored variables.
we describe this annotation for the dataflow language lustre in order to measure test coverage of industrial simulink models in section v. a. immediate non masking paths a variablexis observable if it is not masked along some computation path as described in the tagged semantics to a monitored variable.
if the path is entirely within one computational step i.e.
it does not go through any delays we call it an immediate non masking path and the variable is immediately observable .
this can be defined inductively by examiningthe variables that use xin their definition if one of these variablesyis immediately observable and xis not masked in the definition of y thenxis immediately observable.
we track these notions by defining additional variables to track this information ximm used byywhich is true if xis not masked in the definition of y and ximm observed if xhas an immediate non masking path.
suppose we had the following equations where out1 is an observed variable out1 v1 and v2 v1 true v2 if input1 then v3 else v1 v3 true in this case we could generate additional definitions to track the observability of the variables as follows v1 imm used by out1 v2 v2 imm used by out1 v1 input1 imm used by v2 true v3 imm used by v2 input1 v1 imm used by v2 not input1 out1 imm observed true v1 imm observed v1 imm used by out1 and out1 imm observed or v1 imm used by v2 and v2 imm observed v2 imm observed v2 imm used by out1 and out1 imm observed input1 imm observed input1 imm used by v2 and v2 imm observed v3 imm observed v3 imm used by v2 and v2 imm observed v1is used in two equations and therefore has two immediate paths to observability one through v2and another directly throughout1 while the other variables are each used once so have one immediate path.
b. delayed non masking paths although many variables can be immediately observed often the effect of a variable on an output can only be observed after several steps.
in each of these intermediate steps its tag is stored in a delay until it eventually propagates to an output.
we call this a delayed non masking path and the variable is delay observable .
this situation can be broken into immediate observations the first from a variable to a latch the next from the latch to another latch etc.
until an output is reached.
suppose we had the following lustre program2 delay1 pre v1 v1 v2 and delay2 v2 in1 delay2 pre in1 in the same way that we modeled immediate observability we could talk about immediate use by delay equations 2in lustre latches are represented slightly differently than in the language in section ii the lustre equation var init pre expr contains both the initial value of the latch init and the latch expression pre expr whereas our semantics imports the initial value of latches through an initial latch environment s.105v2 imm used by v1 delay2 delay2 imm used by v1 v2 v1 del used by delay1 true v2 del used by delay1 v2 imm used by v1 and v1 del used by delay1 delay2 del used by delay1 delay2 imm used by v1 and v1 del used by delay1 we now have a mechanism that defines immediate paths to latches.
what is necessary is some means to knit these paths together to define a sequential path through possibly several delays to an output.
we accomplish this using a token variable that describes the current delay location.
once the token is initialized to a delay variable x it can nondeterministically move to any other delay location as long as xisdel used by that location or to a special complete state ifxis immediately observed .
if the token cannot move because it is not observable at another delay or the output the token moves to an error state and stays there.
c. test obligations an omc dc coverage obligation can be represented as an mc dc obligation over a single variable conjoined with a path condition describing the observability of that variable at one of the monitored variables.
for delayed paths we have to describe the instant in which the expression was immediately observable at a delay called capture .
we then want to latch this fact for the rest of the execution hoping that the token will propagate to an output.
so the test consists of the original mc dc obligation v2 at v1 true below and a path condition which can be satisfied by either be an immediate or delayed path as described in the following lustre code v2 at v1 true in1 and delay2 v2 at v1 true capture v2 at v1 true and v1 del used by delay1 and token delay1 v2 at v1 true captured v2 at v1 true capture v2 at v1 true capture or pre v2 at v1 true captured v2 true ob v2 at v1 true and v1 imm observed or v2 at v1 true captured and token tok complete v. e valuation e xperiment we wish assess the quality in terms of fault finding of the test suites generated to satisfy omc dc as compared to masking mc dc .
we also want to evaluate the effect of program structure on the effectiveness of test suites generated to provide omc dc.
thus we address the following questions are test suites generated to provide omc dc more effective at revealing faults than test suites generated to satisfy masking mc dc?
how robust is the omc dc criterion to the structure of the program under test?
will the effectiveness of omc dc change as program structure changes?
additionally we are interested in the nature of the tests generated to satisfy the omc dc and mc dc coverage criteria how do the length of the individual tests the size of test suites and the percentage of achievable coverage compare between omc dc and mc dc for the systems included in our experiment?a.
experimental setup overview in this research we have used four industrial systems developed by rockwell collins engineers.
two of these systems dwm1 and dwm2 represent distinct portions of a display window manager dwm for a cockpit display system.
the other two systems vertmax andlatctl describe the vertical and lateral mode logic for a flight guidance system.
in addition we have used a microwave system control software for a generic microwave oven developed as a non proprietary teaching aid at rockwell collins.
each of the systems under test represent sizable realistic industrial systems.
the size of each system and number of variables are listed in table iii.
table iii case example information subsysts.
blocks outputs internal vars.
dwm1 dwm2 vertmax latctl microwave for each case example we generated inlined and noninlined versions of each system detailed in section v b below .
then for each implementation of each system we generated test input suites each for omc dc and mc dc section v c .
generated mutants of each system section v d .
ran test suites on mutants with output only and maximum test oracles section v e .
assessed fault finding of each test suite and oracle combination.
section v e .
b. inlined and non inlined implementations our subject systems are modeled using the simulink notation from mathworks inc. and were automatically translated into the lustre synchronous programming language in order to take advantage of existing automation.
this is analogous to the automated code generation from simulink offered by mathworks real time workshop.
lustre can be automatically translated to c code.
when translating these systems from simulink to lustre a number of options exist on how to structure the generated code.
for example one can factor complex boolean expressions through the introduction of additional variables or one can inline expressions to reduce the number of variables while increasing the complexity of the boolean expressions.
as we know the structure of the program under test influences the effectiveness of the mc dc criterion we have generated both inlined complex boolean conditions and non inlined systems intermediate variables used to factor expressions .
c. test suite generation we use a counterexample based test generation approach to generate tests satisfying masking mc dc and omc dc .
this approach is guaranteed to generate a106test suite that achieves the maximum possible coverage of the system under test.
we have used the kind model checker in our experiments.
the obligations generated to satisfy omc dc will differ depending on the set of monitored variables.
in this study we generate omc dc with respect to the output variables of each system as an output only oracle is most likely to be used in practice.
note when using the maximum oracle all variables are observable and so the omc dc obligations are equivalent to mc dc obligations.
counterexample based test generation results in a separate test for each generated coverage obligation.
this results in a large amount of redundancy in the generated tests as each test case likely covers several coverage obligations.
such an unnecessarily large test suite is unlikely to be used in practice.
we therefore have reduced each generated test suite while maintaining a consistent level of coverage.
to generate these reduced test suites we make use of a simple randomized greedy algorithm.
we begin by determining the coverage obligations satisfied by each test generated and initialize an empty test set reduced .
we then select a test input at random from the full set of tests if this test satisfies any obligations not satisfied by the existing test inputs in reduced we add it to the set.
this process continues until all tests have been removed from the full set.
in these experiments we have produced different test suites for each case example and program structure to eliminate the possibility that we by accident create a very good or very poor test suite in the test suite reduction step.
d. mutant generation mutation testing is the practice of automatically generating faulty implementations of a system for the purpose of empirically examining the fault finding potential of a test suite .
during mutation testing clones of the system under test are created by introducing a single fault into the program.
this method is designed such that all mutants produced are both syntactically and semantically valid.
that is the mutants will compile and no mutant will crash the system under test.
the mutation operators used in this experiment are similar to those used by other researchers for example arithmetic relational and boolean operator replacement boolean variable negation constant replacement and delay introduction that is use the stored value of the variable from the previous computational cycle rather than the newly computed value .
a detailed description is available in .
for each case example we created mutants.
we then remove functionally equivalent mutants from each evaluation set using the kind model checker.
this is possible due to the nature of the systems examined in this research.
each system is finite therefore determining equivalence is decidable and in practice fast .
3equivalence checking is common in the hardware domain van eijk provides a nice introduction .e.
test oracles and data collection for the inlined and non inlined implementations of each case example we ran the reduced test suites against each mutant and the original version of the system.
for each test suite we recorded the value of every internal variable and output at every step of the execution of every test case using an in house lustre interpreter.
to determine the fault finding effectiveness of the generated test suites we paired each suite with two different expected value test oracles .
when using an expected value oracle for each test input concrete values are specified that the system is expected to produce for one or more variables monitored by the oracle internal states and or outputs .
we have found that this form of test oracle is commonly used by our industrial partners in the testing of critical software systems.
in this study we have chosen two expected value test oracles output only an oracle that compares expected and actual values for each of the system s output variables and maximum an oracle that compares values for all internal and output variables.
we compute the fault finding of an oracle test suite pairing as the percentage of mutants killed.
we perform this analysis for each oracle and test suite for every case example.
vi.
r esults d iscussion in this section we address our research questions and discuss the implications of our results.
we begin by presenting the median percent of seeded faults revealed by each combination of test suite and oracle type in table iv plotted in figure .
a. rq1 fault finding effectiveness we would first like to determine whether omc dc performs better than mc dc with respect to fault finding.
to address this question we formulated the following hypothesis h1 for a given oracle and program structure the test suite satisfying omc dc reveals more faults than the test suite satisfying mc dc.
this is paired with the appropriate null hypothesis h0 for a given oracle and program structure the fault finding results for the test suite satisfying omc dc are drawn from the same distribution as the fault finding results for the test suite satisfying mc dc.
our observations are drawn from an unknown distribution.
therefore we use a two sided mann whitney wilcoxon ranksum test a non parametric hypothesis test for determining if one set of observations is drawn from a different distribution than another set of observations.
as we cannot generalize across non randomly selected case examples we apply the statistical test for each pairing of case example program structure and oracle type with .
our results indicate that the null hypotheses can be rejected for all combinations of case examples program structures and oracle types with p .
furthermore we can see in table iv that test suites satisfying omc dc outperform those satisfying mc dc in all cases with improvements in fault107table iv percent of mutants killed for each case example median over 10reduced test suites dwm1 dwm2 latctl vertmax microwave non inlinedomc dc output only mc dc output only omc dc maximum mc dc maximum inlinedomc dc output only mc dc output only omc dc maximum mc dc maximum test suite size020406080100fault finding maximum mcdc ni oo mcdc ni mx mcdc i oo mcdc i mx omcdc ni oo omcdc ni mx omcdc i oo omcdc i mx a dwm1 test suite size707580859095100fault finding maximum mcdc ni oo mcdc ni mx mcdc i oo mcdc i mx omcdc ni oo omcdc ni mx omcdc i oo omcdc i mx b dwm2 test suite size5060708090100fault finding maximum mcdc ni oo mcdc ni mx mcdc i oo mcdc i mx omcdc ni oo omcdc ni mx omcdc i oo omcdc i mx c latctl test suite size405060708090100fault finding maximum mcdc ni oo mcdc ni mx mcdc i oo mcdc i mx omcdc ni oo omcdc ni mx omcdc i oo omcdc i mx d vertmax test suite size5060708090100fault finding maximum mcdc ni oo mcdc ni mx mcdc i oo mcdc i mx omcdc ni oo omcdc ni mx omcdc i oo omcdc i mx e microwave fig.
.
percent of mutants killed plotted against reduced test suite size for each implementation and oracle pairing for each system.
finding of for non inlined systems using an outputonly oracle when using a maximum oracle and for inlined systems when using an output only oracle when using a maximum oracle .
we therefore accepth1 for all combinations of system program structure and oracle type and conclude that test suites satisfying omc dc provide a statistically significant and practical improvement over those satisfying mc dc.
b. rq2 sensitivity to program structure previous research indicates that mc dc is sensitive to program structure inlining a program generally makes it more difficult to achieve mc dc over a program but yields a large improvement in fault finding for test suites satisfying mc dc with one study demonstrating increases of .
as seen in table iv and summarized in table v we see similar increases of for output only oracles.this sensitivity is undesirable for any criterion as the value of satisfying the criterion depends heavily on how the program is written indeed the sensitivity of mc dc to program structure and its negative impact on automated test generation is one of the motivations for the creation of omc dc.
the cause of mc dc s sensitivity relates to errors not propagating to observed variables due to masking coupled with inlining imposing additional constraints when computing mc dc obligations over complex expressions which limits opportunities for masking.
in the studied examples omc dc is far less sensitive to changes in program structure.
when paired with an outputonly oracle we see a median improvement of from inlining and in two cases actually see a to decrease in fault finding .
when using a maximum oracle the effect is negligible.
thus while inlining has been proposed as a solution to the masking and propagation related deficiencies108of mc dc the addition of the path condition required by omc dc which explicitly addresses issues with masking is also an effective and in our opinion cleaner and more straightforward solution.
table v median improvement from inlining case example oracle omc dc mc dc dwm1output only maximum dwm2output only maximum latctloutput only maximum vertmaxoutput only maximum microwaveoutput only maximum on a related note the use of a maximum oracle has also been proposed as a method of addressing issues with propagation.
as we can see in table iv generally test suites satisfying omc dc with an output only oracle perform the same or better than suites satisfying mc dc with a maximum oracle though gains are low to negligible .
only in one case dwm1 when inlined do suites satisfying mc dc achieve significantly higher median fault finding versus .
c. rq3 test suites and coverage obligations our final question is concerned with the cost and challenge of satisfying omc dc.
in particular does satisfying omc dc require more test inputs must the test inputs be longer and what percentage of obligations are uncoverable i.e.
cannot be achieved by any test input?
note that as omc dc requires the same obligations as mc dc with an additional path condition the total number of obligations required to cover a system will be the same for both criteria.
from the information in table vi we can see that there is no definitive pattern for test suite size sometimes reduced suites for omc dc are larger than those for mc dc and viceversa and omc dc obligations are more likely to be uncoverable with as low as .
of obligations coverable.
with respect to size we can see that for non inlined systems omc dc generally requires more sometimes many more test inputs than mc dc.
this reflects the strength of omc dc the observability requirements ensure test cases are more diverse with respect to which paths they must take thus it is less likely that several test cases will cover the same obligation.
naturally more test cases are needed to satisfy achievable omc dc.
also we observed that omc dc test case lengths not shown for space reasons are slightly longer than that of mc dc as test cases must take additional steps through delays to propagate certain variables to outputs.
nevertheless while we naturally do not wish to increase the cost of testing we believe ensuring propagation during testing is necessary otherwise why bother to exercise a condition at all?
furthermore we believe the substantial improvements in testing effectiveness justify the cost particularly in the domain of critical systems.the increase in uncoverable obligations is more concerning.
for mc dc a coverage obligation is uncoverable if it is impossible to demonstrate that a condition can independently affect the outcome of a decision.
this situation can occur through interrelationships between conditions in a decision making certain truth assignments impossible.
for omc dc this can also cause uncoverable obligations as can the inability to propagate values to monitored variables.
the path constraints accounts for the increase in uncoverable obligations.
uncovered obligations for structural coverage criteria may reflect problems with the code conditions that are not properly influencing decisions or simply eccentricities in the code e.g.
dead code or interrelationships between conditions in a decision .
in our case since we are using a verification tool for test generation the tool will simply produce maximum achievable coverage with a proof that the uncovered obligations are truly uncoverable.
however if omc dc was adopted as a coverage criterion in conjunction with other test generation techniques e.g.
manual or based on heuristic search it may become necessary as it currently is with mc dc in the context of critical avionics systems to demonstrate that all necessary test have been found i.e.
to demonstrate that all uncovered obligations are indeed uncoverable.
this is already a challenging task for mc dc and would be made more challenging with the addition of path constraints how to address this problem is a topic for future research.
vii.
r elated work lustre and function block diagram fbd are data flow languages that describe how inputs are transformed into outputs instead of describing the control flow of the program.
researchers studying coverage metrics for lustre and fbd implicitly investigated observability by examining variable propagation from the inputs to the outputs.
structural coverage metrics for lustre are based on activation conditions that are defined as the condition upon which a data flow is transferred from the input to the output of a path.
when the activation condition of a path is true any change in input causes modification of the output within a finite number of steps .
coverage metrics for fbd are based on a d path condition that is similar to activation conditions in lustre .
coverage metrics in lustre and fbd are different from omc dc in several respects.
first these metrics check if specific inputs affect the outputs and measure the coverage of variable propagation on all possible paths.
omc dc on the other hand checks if each atomic condition in a boolean expressions affects the monitored variables and determines if a path exists which propagates the effect of the condition.
second omc dc as well as mc dc is stronger in terms of how a decision must be exercised.
observability has been studied in testing of hardware logic circuits.
observability based code coverage metric occom is a technique where tags are attached to internal states in a circuit and the propagation of tags is used to predict the actual propagation of errors corrupted state .
a variable is tagged when there is a possible change in the value of the109table vi number of achievable test obligations and median reduced test suite size case example structure total omc dc mc dc omc dc mc dc obligations achievable achievable reduced size reduced size dwm1non inlined .
inlined .
.
dwm2non inlined .
.
inlined .
.
latctlnon inlined .
inlined .
.
vertmaxnon inlined .
inlined .
.
microwavenon inlined .
.
inlined .
.
variable due to an fault.
the observability coverage can be used to determine whether erroneous effects that are activated by the inputs can be observed at the outputs.
the key differences between omc dc and occom are twofold omc dc investigates variable value propagation while occom investigates fault propagation and occom has pessimistic inaccuracy because of tag cancelation.
when both positive and negative tags exist in the same assignment e.g.
different tags in an adder or the same tags in a comparator cancel each other out no tag is assigned or an unknown tag ?
is used.
variables without tags or with unknown tags are not considered to carry an observable error.
in omc dc since we do not make a distinction between positive and negative tags we do not have tag cancelation or the corresponding pessimistic inaccuracy.
extended work in may fix pessimistic inaccuracy by producing test vectors with specific values but is highly infeasible.
dynamic taint analysis or dynamic information flow analysis marks and tracks data in a program at runtime similar to our tagging semantics.
this technique has been used in security as well as software testing and debugging .
taint propagation occurs in both explicit information flow i.e.
data dependencies and implicit information flow control dependencies .
although the way in which markings are combined varies based on the application the default behavior is to union them .
thus dynamic taint analysis is conservative and does not consider masking.
more accurate techniques for information flow modeling such as define path conditions quite similar to those used in this paper to prove non interference that is the non observability of a variable or expression on a particular output.
dynamic program slicing computes a set of statements that influence the variables used at a program point for a particular execution.
this can identify all variables that contribute to a specific program point including output.
however similarly to dynamic taint analysis it does not consider masking.
checked coverage uses dynamic slicing to assess oracle quality where oracles are program assertions .
given a test suite it yields a percentage of all statements that contribute to the value of any assertion i.e.
are observable at that assertion vs. the total number of statements covered by the test suite.
this work is designed to assess the oracle not the test suite.viii.
t hreats to validity external validity we have chosen to focus on five synchronous reactive critical systems.
we believe these systems are representative of the avionics domain and our results are therefore generalizable to other systems in this domain.
we have used lustre as an implementation language rather than a more common language such as c or c .
as noted in section v b in this domain systems written in lustre are similar in structure to systems written in c or c .
thus we believe our results are applicable to programs written in more traditional imperative languages.
we have generated approximately mutants for each program structure of each case example.
this number was chosen to yield a reasonable cost for the study.
it is possible the number of mutants is too low.
based on past experience however we have found results using fewer than mutants to be representative .
additional studies have yielded evidence that results plateau when using over mutants.
internal validity we have used a model checker kind to generate test cases.
this generation approach provides the shortest test cases that provide the desired coverage.
it is possible that test cases derived by hand or through some other automated means e.g.
through heuristic search may provide different results.
construct validity we measure the fault finding over seeded faults rather than real faults encountered during development it is possible that using real faults would lead to different results.
however andrews et al.
have shown that the use of seeded faults like ours leads to conclusions similar to those obtained using real faults in similar experiments .
ix.
c onclusions f uture work structural coverage metrics such as mc dc are commonly used to measure the adequacy of test suites.
such criteria require only that certain code structures such as a particular boolean assignment of a decision be exercised without requiring the resulting value to affect an observable point in the program.
as a result test suites satisfying these criteria can produce corrupted internal state without revealing a fault resulting in wasted testing effort.
to address this we have proposed observable mc dc a combination of traditional mc dc testing with a notion110of observability an additional path constraint which helps ensure that faults will be observed through a non masking path from the point the obligation is satisfied to a variable monitored by the test oracle.
our results indicate that test suites generated to satisfy achievable omc dc locate a median of .
and up to more faults than test suites providing mc dc coverage when paired with an oracle observing only the output variables.
furthermore we have also observed that omc dc is less sensitive to the structure of the program under test than mc dc and also provides the benefits of using a very strong test oracle with mc dc coverage.
while our results are encouraging there are a number of areas open to explore in future research including oracle data selection omc dc test obligations are defined in terms of both the system structure and a test oracle.
in this work we have paired the case examples with an output only oracle but an intelligently selected set of internal and output variables such as could potentially yield more cost effective test suites.
comparison to other coverage metrics we have directly compared the performance of omc dc to mc dc.
however there exist many other test adequacy metrics.
in particular we would like to compare the effectiveness and cost of generation of omc dc to black box requirements metrics which have been previously shown to be adept at propagating faults to the output level .
applying observability to other metrics the current notion of observability is general and could be adapted to orthogonal metrics such as boundary value coverage.
acknowledgment this work has been partially supported by nasa ames research center cooperative agreement nna06cb21a nsf grants ccf cns and cns an nsf graduate fellowship and the world class university program under the national research foundation of korea project no r31 .
we also thank the advanced technology center at rockwell collins inc. for granting access to industrial case examples.