synthesis of live behaviour models for fallible domains nicol s d ippolito victor braberman nir piterman sebasti n uchitel imperial college london london united kingdom su2 imperial.ac.uk universidad de buenos aires buenos aires argentina ndippolito vbraber dc.uba.ar university of leicester leicester united kingdom np183 le.ac.uk abstract we revisit synthesis of live controllers for event based op erational models.
we remove one aspect of an idealised problem domain by allowing to integrate failures of controller actions in the environment model.
classical treatment of failures through strong fairness leads to a very high computational complexity and may be insufficient for many interesting cases.
we identify a realistic stronger fairne ss condition on the behaviour of failures.
we show how to construct controllers satisfying liveness specifications under these fairness conditions.
the resulting controllers exhi bit the only possible behaviour in face of the given topology of failures they keep retrying and never give up.
we then identify some well structure conditions on the environmen t. these conditions ensure that the resulting controller will be eager to satisfy its goals.
furthermore for environments that satisfy these conditions and have an underlying probabilistic behaviour the measure of traces that satisfy our fairness condition is giving a characterisation of the ki nd of domains in which the approach is applicable.
categories and subject descriptors d. general terms design algorithms keywords controller synthesis behavioural modelling .
introduction we are interested in the automated construction of operational event based models from specification of intende d this work was partially supported by grants erc pbmfimbse conicet pip955 ubacyt x021 and pict pae .
permission to make digital or hard copies of all or part of thi s work for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage an d that copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
icse may waikiki honolulu hi usa copyright acm ... .
.system behaviour.
this topic has been the subject of extensive study in the software engineering community.
consider for example the research on synthesis from scenario based e.g.
and declarative e.g.
specifications.
t he aim is to provide an operational model that will support requirements elicitation and analysis.
analysis techniqu es may include model checking simulation animation and inspection aided by automated slicing and abstraction .
behaviour model synthesis is also used to automatically construct plans that are then enacted by a software component.
for instance synthesis of glue code and component adaptors has been studied.
the main aim of these studies has been to achieve safe composition at the architecture level and in particular in service oriented architect ures e.g.
.
also there has been an increasing interest in a pplications toself adaptivesystems .
allthesesys tems rely heavily on controller synthesis techniques .
such techniques guarantee the satisfaction of safety and even li veness requirements.
the proposed solutions work within theconstraintsenforcedbytheproblemdomain thecapabil ities offered by the self adaptive system and under fairnes s and progress assumptions on the controller s environment.
recently we suggested an approach for synthesis in the context of discrete event systems.
our work emphasises the importance of explicit distinction in controller synthes is between controlled and monitored actions and between descriptive and prescriptive behaviour .
we also provided appropriate methodological guidelines.
one of the limitations of existing synthesis techniques is that they are designed to work in the context of idealised problem domains.
situations in which the outcome of controller actions are notguaranteedare dealtwith byassumin g thatcontroller actionsneverfail e.g.
bynot consi dering liveness goals e.g.
or by building controllers t hat aim to be live but are not guaranteed to be so .
in this paper we propose a technique for synthesising live behaviour models in the context of problem domains in which controlled actions can fail.
the technique adapts and extends our previous work on synthesis of controllers for di screte event systems .
a key insight is the identification of a realistic fairness condition strong independent fairness which allows for a polynomial treatment of failures.
in contrast the complexity of the general problem is exponential .
specifically we consider models in the form of labelled transition systems lts .
we distinguish controllable fro m uncontrollable actions.
in addition some controllable ac tions have associated actions that constitute a success or a failure.
the synthesis problem calls for the construction o f amodel that when composed with its environment satisfies a given specification in fltl .
the fltl formulas we consider have the form gi logicalandtextn i 1gfai logicalandtextm j 1gfgj wheregiis a safety system goal gfairepresents a liveness assumption on the behaviour of the controller s environment and gfgjmodels a liveness goal for the system.
the expressions aiandgjare non temporal fluent expressions .
the system safety goal i is expressed as a fluent linear temporal logic formula.
we assume strong independent fairness of the successes and failures with respect to certain assumptions on the environment.
intuitively th e strong independent fairness condition states that every fa ilure and every assumption must occur fairly infinitely often ifenabled infinitelyoften butalso independentlyofall ot her failures and assumptions and of the state of the environment and the controller.
in other words failures and assumptions cannot be coordinated.
they must be controlled by different agents which must be oblivious to each other.
technical contributions of this paper include i a discussion of the fairness conditions required for problem domain s with failures.
in particular the observation that strong fa irness of successful controlled actions may be insufficient to guarantee that reasonable controllers are synthesised ii novel fairness conditions i.e.
t strong fairness and stro ng independent fairness that are stronger than strong fairnes s and are good fits for realistic controller synthesis setting s iii the definition of a polynomial time lts control problem named rsgr that supports safety and gr like liveness properties iv the restrictions that an environment model requires in order to guarantee correctness of the synthesis procedure and to avoid controllers that fulfill their specification by trivialising it i.e.
anomalous controlle rs and v a proof that if the environment can be thought of as a grounding of a probabilistic environment with nonzero probabilities on transitions then the traces that are not strong independent fair have probabilistic measure zer o thus providing a characterisation of the domains in which our approach can be applied.
the paper is organised as follows.
in section we motivate and present an overview of the approach.
section includes the necessary background.
in section we present the technique for synthesising lts controllers in the presence of failures in subsection .
we discuss the notion of fairness required for the proposed controller synthesis te chnique in subsection .
we formalise the control synthesis problem that handles domains with failures and discuss how it can be solved efficiently in subsection .
we discuss the problem of anomalous controllers and how to avoid them and in subsection .
we present a probabilistic argument to show that behaviour that is not strong independent fair is irrelevant in the context of our synthesis approach.
finall y we report on case studies discussion related work and conclusions.
proofs can be found in .
.
motiv ation in this section we discuss motivation for our approach.
technical details are provided in the next sections.
considerthefollowing simplifiedscenario atravelagency wants to sell vacation packages on line by orchestrating ex isting web services for flight purchase car hire and hotel booking.
we want an automated or semiautomated technique for building the agency s orchestration based on the known usage protocols for individual services and on the2 6car.query car.reserve car.paycar.resetcar.query.failedcar.query.succ car.reserve.succcar.reserve.failed car.pay.failedcar.pay.succ figure car booking service.
agency s own requirements for the provision of packages.
an example of what the protocol for a car rental webservice is the one depicted in figure .
the service requires a query with information on dates car type and other preferences car.query .
the service can either respond with a list of items satisfying the specified criteria car.query.succ or with not found car.query.failed .
subsequently if a list is retrieved a particular item can be reserved car.reserve or the process can be aborted car.reset .
reservation can fail car.reserve.failed or succeed car.reserve.succ .
in the latter case payment is enabled car.payment and can succeed car.payment.succ or fail car.payment.failed .
the web service protocols for hotel and flight bookings will typically be similar to that of car rentals a sequence of actions is required to progress towards a purchase and a number of problems may arise which lead to the failure of these actions no flights communication errors insufficien t funds etc.
.
without loss of generality the protocol for hotel and flight bookings is analogous to that for cars with actions such as flight.query andhotel.reserve.succ .
the problem for the travel agency orchestration is to coordinate the individual services in order to provide a cohesive comprehensive vacation package web service.
for instance it must attempt to avoid booking hotel and car for a customer when no flights are available for the desired dates.
such a requirement can be formalised for instance in temporal logic as i1 g srv services trytobuy srv allreserved .
another requirement if the agency is charged for reservations might be not to reserve before all queries have returned viable items i2 g srv services trytoreserve srv allfound .
the agency should coordinate the services to achieve its own requirements.
it should do that while following the protocols of the services and deal with the various failures tha t may occur.
for instance if a failure occurs when reserving a flight then the flight service must be re queried but if the result of the new query returns notfound then reservations for car and hotel must be cancelled and the user may consider a different holiday .
finally thetravelagencyorchestration mustbelive.
that is it must actually succeed in providing package holidays.
of course this depends on actually having requests pending to be processed.
such a requirement should be formalised distinguishing the assumptions on the environment a1 gfpendingpackagerequests and prescriptions on the orchestration g1 gfpackage.deliver .
we require that if the environment satisfies a1then the orchestration will satisfy g1.
we distinguish between the travel agency s controlled and monitored actions double and single lines in figures respe ctively .
actionssuchas car.query car.reset flight.reserve andhotel.payment are controlled by the orchestrator for the travel agency while the rest are monitored.
with such distinction we apply controller synthesis.
we attempt to pro duce a controller such that when interacting with the car flight andhotelservices will achievesafety e.g.
i1 i2 and liveness e.g.
g1 under relevant assumptions e.g.
a1 .
unfortunately our previous approach cannot produce controllers that guarantee such goals.
this is quite reason able as for achieving such a goal the controller must rely on a number of domain assumptions.
for instance it cannot be the case that queries reservations and payments always fai l. under such assumptions it would seem feasible to construct a controller for the travel agency the controller would hav e to retry actions in the case of failures knowing that after some number of reattempts it will succeed1.
the assumption mentioned if the controller tries often enough it wil l eventually succeed is a typical fairness condition someti mes referred to as strong fairness .
strong fairness is not su pportedbypolynomial timealgorithms suchas .
itrequire s exponential algorithms such as .
it could be argued that many exponential worst case algorithms are well behaved in practice.
unfortunately this is not the case here.
the best case complexity of all known algorithms that deal with strong fairness is exponential .
more precisely the si ze of the controller is always n k!
wherenis the size of the environment model and kis the number of strong fairness conditions.
the best time complexity of all known algorithms isnk k!.
again the k!
factor is never reduced.
in other words unlike symbolic model checking in which many practical settings are not worst case here space and time blow up in every reasonable sized example.
interestingly strong fairness assumptions on success of queries reservations andpaymentsare insufficienttoachie ve thegoals.
the strongfair behaviourinwhichfailures ta ke turns would prevent achieving the goal.
consider the scenario in which the controller first queries a car successfull y and then fails querying for a hotel.
the controller must reset the car service and re query for cars and hotels.
but now the hotel query succeeds and the car query fails forcing the controller to reset the hotel service and so on.
thus a synthesis algorithm relying on strong fairness would decla re that no controller realising this goal exists.
in conclusion it would seem possible to build a reasonable orchestration of theservices towards achievingthego als of the travel agency.
however non trivial assumptions on the environment behaviour are required to guarantee such goals are achieved by a reasonable controller.
this lays out two research questions.
firstly how can an orchestration for the travel agency be constructed automatically and secondly what are the required assumptions which will enable to guarantee the goals.
in section we present a technique for automatically synthesising controllers for settings such as the travel agenc y. we handle cases where the environment can exhibit failures to controller actions and show what are the environment assumptions required for such controllers to succeed.
.
background in this section we present background for controller synthesis in the context of event based operational models.
we assume the problem domain for which a controller is to be built is described as a labelled transition system.
1notethateveninthissimpleexampleretryingisnottrivial .
for example if a payment fails it is necessary to re query and re reserve before re attempting to pay.definition .
.
labelled transition systems alabelled transition system lts isp s l s0 wheres is a finite set of states l actis itscommunicating alphabet s l s is a transition relation and s0 sis the initial state.
we denote s s s a s .
we say an lts is deterministic if s l s and s l s are in impliess s .
an execution of pis a words0 a0 s1 ... where si ai si .
a word is trace ofpif there is an execution ofpsuch that l .
we define tr p to define the set of traces of p. we describe specifications e.g.
the prescriptions for controller using fluent linear temporal logic fltl .
linear temporal logics ltl are widely used to describe behaviour requirements .
fltl is a linear time temporal logic for reasoning about fluents.
a fluentfl is defined by a set of initiating actions ifl a set of terminating actions tfl and an initial value initially fl.
that is fl a bracketle tifl tfl a bracketri htinitiallyfl whereifl tfl actandifl tfl .when we omit initially fl we assume the fluent is initiallyfalse.
we use las short for the fluent defined as fl a bracketle tl act l a bracketri ht.
given the set of fluents an fltl formula is defined inductively using the standard boolean connectives and temporal operators x next and u strong until as follows fl x u wherefl .
we introduce f eventually and g always as usual.
let be the set of infinite traces over act.
for we write ifor the suffix of starting at ai.
the suffix i satisfies a fluent fl denoted i fl if and only if one of the following conditions holds initiallyfl j j i aj tfl j j i aj if k n j k i ak tfl the problem of controller synthesis can be expressed as follows given an lts model eof the environment a set of controllable actions lc assumptions asiand goalsgiexpressed in fltl build an lts msuch that when composed in parallel with e i.e.e bardblm the controller does not block all non controlled actions in the environment and for every trace ofe bardblmif the trace satisfies the assumption ai then the trace also satisfies the goal gi.
we use a standard definition of parallel composition .
the parallel composition is the lts that models the asynchronous execution of composed models.
it interleaves nonshared actions and forces synchronisation on shared action s. the notion of a controller that does not block the actions of the environment that it does not control is built on that oflegal environment for interface automata .
intuitively it says that mis a legal environment for eif in every state m e ofm bardblewheremandeare states of manderespectively if an action anot controlled by mis enabled in ethen it is also enabled in m e .
definition .
.
lts control given a specification for a problem domain in the form of an environment lts e a set of controllable actions lc and a sethof pairs asi gi whereasiandgiare fltl formulas specifying assumptions and goals respectively the solution for the lts control problem l a bracketle te h l c a bracketri htis to find an lts mwith controlled actionslcand uncontrolled lcsuch thatmis a legal environment for e e mis deadlock free and for every pair asi gi hand for every trace inm ethe following holds if asithen gi.the problem with using fltl as the specification language for assumptions and goals is that the synthesis problem is 2exptime complete .
nevertheless restrictions on the form of the goal and assumptions specification have been studied and found to be solvable in polynomial time.
for example goal specifications consisting uniquelyofsaf ety requirements can be solved in polynomial time and so can particular styles of liveness properties such as gr .
we have presented an adaptation of gr in the context of lts in .
it is defined as follows definition .
.
sgr lts control an lts control problem l a bracketle te h l c a bracketri htis sgr if eis deterministic and h i as g wherei g as logicalandtextn i 1gf i g logicalandtextm j 1gf j and iand jare boolean combinations of fluents.
.
synthesis for fallible domains we now present a technique for synthesising controllers even when their environment exhibits failures.
in subsection .
we discuss the notion of fairness required for the proposed controller synthesis technique.
in subsection .
we formalise the control synthesis problem and discuss how it can be solved efficiently.
we then discuss in subsection .
the problem of anomalous controllers and how to avoid them and finally in subsection .
we present a probabilistic argument to show that non fair environment behaviour is irrelevant in many realistic settings.
note that the examples in this section are simplistic and with obvious solutions to allow conveying the main issues involved in controller synthesis in domains with failures.
.
fair environments we consider controller synthesis in the context of environments that exhibit failures.
we call this setting synthesis with failures .
we present examples showing that fairness of failures and successes is both necessary and subtle.
a malicious environment typically cannot be controlled to achiev e the goals.
however we propose realistic fairness assumpti ons that allow for controllers that behave as expected i.e.
do not give up and keep retrying.
considere the simple environment model in figure where a ceramics cooking process is described.
the aim of the controller is to produce cooked ceramics by taking raw pieces from the in tray placing them in the oven and moving them once cooked to a conveyor belt.
a natural solution for such a problem is to attempt to build a controller using sgr with a liveness goal g gf movetobelt and an assumption a gf cooking.
note that the assumption ais required to ensure that the controller s environment progresses when cooking ceramics without the assumption no controller can guarantee production of ceramics.
indeed a controller for this trivial problem is the one that chooses tocookrather than be idle and is constructed automatically by solving the sgr problem sg1 a bracketle te h l c a bracketri ht whereh a g andlc idle cook movetobelt .
the solution to sg1is a controller mthat composed with e produces infinitely many cooked pieces if the oven finishes cooking infinitely often i.e.
e bardblm gfaimplies e bardblm gfg .
a slight twist to the ceramics cooking problem is the scenario in which some pieces may break during cooking.
the reasons for why the pieces may break e.g.
impurities in the12 3idlecook movetobeltfinishedcooking cooking figure ceramic cooking process.
cookidle movetobeltcookmovetobelt fix cook finishedcooking cookingbroken not.broken figure failing ceramic cooking process e2 .
ceramics heat stability in oven etc are abstracted in the model figure .
such abstraction of the causes for failure is a common approach to behaviour modelling of problem domains.
the assumption is not that the controller s environment chooses whether the piece breaks rather that the choice is made by a number of factors that are beyond the scope of the model.
we distinguish failures from other actions as follows.
for each control problem we define a set of try response triples.
such a triple captures the relation between controlled actions and their success or fail reactions.
note that we require the try action to be controlled all actions in a try response triple to be unique with respect to other tripl es in the set re tries cannot occur before a response responses can only occur as a result of a try maximum of one response occurs for everytry and thedecision of whether to fail or succeed cannot be enforced by other actions hence failure is enabled if and only if success is enabled.
definition .
.
try response given anlts m sm lm m sm0 wherelc lm we say that a set t tryi suci faili is atry response set formif the following hold for all i .tryi lc suci faili l lcandsuci e atio slash faili .for allj e atio slash i tryi suci faili tryj sucj failj .
faili suci w tryi .g tryi x tryiw faili suci .g faili suci x faili suci w tryi and .
for alls sm failiis enabled from siffsuciis enabled from s. we returntothe ceramics cooking problem andadd afailure to it.
consider the model of figure with the try response sett cook not.broken broken .
the controller for this problem is required to accomplish two things.
first to produce cooked pieces and place them on the conveyor belt.
second to ensure that only unbroken pieces are placed on the belt while broken pieces are fixed and re cooked.
a naive attempt to build a controller for the modified problem simply adds a safety goal s g movetobelt broken tosg1 wherebroken is a fluent defined as a bracketle tbroken cook a bracketri ht.
in other words attempting to solve sg2 a bracketle te2 h lc a bracketri ht whereh s a g .
unfortunately sg2does not have a solution.
furthermore in general there is no controller that will work if the environment is malicious.
a controller cannot succeed if its environment breaks all ceramics.
in other words for a controller to produce cooked unbroken ceramics we must assume that if enough pieces are cooked one will eventually not break.
thatis thattheresponse totrying cookisnotalways the failure broken.
this could be a reasonable assumption for the problem domain.
another attempt at automatically building a controller could be to strengthen the assumption ainsg2to bea gf cooking gf not.broken .
this leads tosg3 a bracketle te2 h lc a bracketri ht whereh s a g .
the problem with sg3is that it admits as a solution a controllermwhich only does idle.
this is because by never performing cook the assumption a and more specifically gf not.broken does not hold.
hence the controller has no obligation to achieve g. formally e2 bardblm gfaimpliese2 bardblm gfgholds ife2 bardblm e atio slash gfa.
clearly a is not a reasonable assumption for the controller s environment.
the environment depends on the controller to achievea .
or in van lamsweerde s terms the assumption is not realisable by the controller s environment.
as we show in unrealisable assumptions in addition to not following best practices in requirements engineering can lead to controllers that satisfy their goals vacuously.
jus t like the controller that always idles in our example satisfie s its specification vacuously see also subsection .
.
in order to introduce an assumption that is realisable by the controller s environment we must state that if pieces a re cooked infinitely often not.broken is taken infinitely often i.e.gf cook gf not.broken .
however this condition amounts to requiring strong fairness of not.broken actions which cannot be encoded in sgr .
althoughmore general controller synthesis techniques can deal with stro ng fairness these take the algorithmic complexity of synthesis from polynomial the sgr case to exponential.
moreover sometimes strongfairnessisnotsufficientlystro ng for synthesising controllers in simple yet common proble m domains.
this is shown in the next example.
consider another variation of the ceramic cooking probleminwhichpiecesmustbecookedtwicebeforebeingmoved to the conveyor belt.
a controller for such a problem will need to remember how many successful consecutive cook s have occurred.
requiring strong fairness on try response triples oft cook not.broken broken is insufficient to allow the construction of a controller that achieves its goals.
there is no controller that can deal with the case in which pieces break at least once every two consecutive attempts to cook them.
for instance consider ma potential controller for the problem figure .
it is possible to construct a strongly fair trace by always succeeding in the first cook taking the not.broken transition from state but always failing after the second cook taking the broken transition in state .
if an infinite number of cookare tried thengf cook gf not.broken holds yet the controller never succeeds in placing a twice cooked unbroken piece on the conveyor belt.
the above example shows that a stronger notion of strong fairness is required.
informally it should state that ever y individual attempt to cook should be treated fairly.
that is 6cookidle fixcook cook movetobeltfinishedcookingcooking brokennot.broken finishedcookingcooking not.brokenbroken figure ceramics cook twice controller.
attempting first cook of a piece transition from to in figure infinitely often should yield an infinite number of non broken once cooked pieces transition to and attempting a second cook of a piece transition to infinitely often should yield an infinite number of non broken twice cooked pieces transition to .
this stronger notion of fairness is in fact tightly coupled with the structure of the environment and controller behaviourmodels.
whatisneededisthatforeveryglobal state a state ofe2 bardblm if a cook on that state is attempted infinitely often then the cooking process will not fail infinite ly often.
an alternative intuition is that the decision whether to fail the cooking process should be fair and be taken independently of state of the environment model or the controller.
in the two cooks a piece example the decision to fail the second cook of a piece process should be fair and independent of the first cookon the same piece.
the following definition captures this stronger notion of fairness.
it requires that for every transition labelled wi th a try if it is taken infinitely often then infinitely often success occurs before another try.
definition .
.
t strongfairness given an lts mand a try response tform.
a trace tr m ist strong fair with respect to mandtif for all tryi suci faili tand for all transitions t s tryi s the following holds gftry i gf tryiusuci where lm try i s.tryi.s s.try i.try i.s and is an execution of msuch that lm .
note thatw ais the projection of word wover the alphabeta andw is the result of replacing in word wall occurrences of word vwithv .
one issue remains regarding the fairness conditions that are relevant to enable automated synthesis with failures.
consider the synthetic example in figure .
in this exampletryis the only controlled action try succ fail the only try response triple lis an arbitrary event and gand arepresent goals and assumptions respectively.
the trace try success l try fail a try success l ... is an example of a trace that satisfies strong fairness and t strong fairne ss the assumptions hold infinitely often and yet the goal is never achieved.
note that no controller could prevent this trace astryis the only controlled action.
the trace shows some peculiar behaviour the environment never chooses to take the assumptions on state and it can do so because it relies on the fact that it fails sometimes and through failin g achieves its assumptions.
although contrived the example shows that the assumptions and failures can be systematically combined to make a controller unsuccessful the environment can avoid assump tions when actions succeed state in figure and achieve assumptions when actions fail state .
however a natural expectation is that the assumptions on the environ 5trysucc faill aa g figure t strong fairness is not enough.
ment should be independent of failures particularly because the choice of failure or success is understood as nondeterministic given that it abstracts the actual cause for failure and success.
if required to construct a controller for figure what should the controller do?
naturally the controller should keep taking tryhoping that eventually assumptions are not coordinated with failures.
a synthesis algorithm that only assumes strong fairness or even t strong fairness would say that this is impossible and fail to produce a controller.
our goal is then to come up with a setting in which such a controller would be automatically generated by the synthesis algorithm.
in order to do so we formalise the notion that assumptions and failures must be independent.
we formalise that assumptions and failures must be independent of each other in the following way.
we restrict traces of interest tothose thatsatisfy that assumptions mu st be attainable infinitely often without seeing failures.
or more precisely if the controller tries often enough then n ot only will it succeed but also it will succeed and all assumptions are fulfilled.
that is if assumptions and failures are truly independent trying often enough guarantees that at some pointafter atry nofailures will occur untilall assum ptions are satisfied.
definition .
.
strongindependentfairness given an ltsm a try response tformandaa set of fltl formulas.
a trace tr m isstrong independent fair with respect toaif for all tryi suci faili tand for all transitiont s tryi s the following holds gftry i gf tryiusuci logicalandtextn i logicalortextn j 1failj wai where lm try i s.tryi.s s.try i.try i.s and is an execution of msuch that lm .
in the next subsection we formalise the control problem with the fairness discussed above.
we show that this problem can be solved efficiently by encoding it into the sgr control problem.
the encoding relies on strong independent fairness.
finally as further motivation we reason about domains that are considered as probabilistic with non zer o probabilities on all transitions .
we show that in such domains if the environment is well structured then the probabilistic measure of traces that do not satisfy this fairnes s conditions andconsequentlythetraces for whichcontroll ers have no obligations is zero.
.
recurrent success control problem we now formalise the recurrent success control problem .
for traces that are strong independent fair it guarantees general safety and liveness properties which are gr li ke.
we extend the sgr control problem we defined in by introducing failures and expectations on the fairness of th e environment.
definition .
.
recurrent success given an sgr lts control problem l a bracketle te h l c a bracketri htand a try response tforl the solution for the recurrent success control problemr a bracketle tl t a bracketri htis to find an lts msuch thatmwith controlled actions lcand uncontrolled actions lcis a legal environment for e e mis deadlock free and for every pair asi gi h for every tryi suci faili and for strong independent fair trace inm ethe following holds if asithen gi.
notice the requirementof independencebetween decisions onwhentofail andwhentoachieveassumptions.
thisis key to the tractable treatment of rsgr problems rsgr can be reduced to a sgr problem leading to more efficient algorithms than those needed to solve strong fairness in general.
theorem .
.givenr a bracketle tl t a bracketri htan rsgr control problem it holds that there exists an sgr control proble m ssuch that ris realisable iff sis realisable.
furthermore the controller extracted from scan be used to control r. the reduction can be explained in two steps rsgr can be solved by constructing a controller for an alternativ e control problem named finitely many failures fmf .
solutions for fmf control problems construct controllers tha t guarantee gfgon a trace if on the same trace gfasi holds and also a finite number of failures occur i.e.
fg logicalortext jfailj .
an fmf problem can be coded as an sgr problem where the goal is gf g logicalortext jfailj .
the key to the coding of rsgr into fmf is the strong independent fairness requirement and in particular what i t adds on top of t strong fairness if a try transition is taken infinitely often then not only will it succeed infinitely oft en but also that infinitely often no failures will be observed f or thattryor any other action that can potentially fail until all assumptions have occurred.
we sketch the proof that every solution to fmf is a solution to rsgr .
suppose by way of contradiction that mis an fmf controller that is not an rsgr controller.
thentheremustbeastrongindependentfair trace ine bardblc that satisfies the assumptions infinitely but not the goals.
i n there must be an infinite number of failures otherwise it would be a counter example to mbeing an fmf controller and hence there must be at least one try transition taken infinitely often.
as is strong independent fair the trytransition must be successful and infinitely often no failur es occur before assumptions occur.
hence there is cycle covered by in which no failures occur all assumptions do occur and goals are not achieved.
this cycle can be used to construct a trace in e bardblmwhich has finitely many faults and in which goals are not achieved even though assumptions hold.
this contradicts that mwas assumed to be an fmf controller.
we give an alternative intuition of why rsgr can be reduced to fmf.
in fmf the controller knows that at some point there will be no more failures but does not know at which point this will happen.
it follows that its strategy is toreattempt knowingthat eventuallyall its attempts will b e successful.
the same strategy works for rsgr .
indeed because of strong independent fairness it may be the case that failures are infrequent enough and non systematicall y occurring.
in such cases eventually all the successes neede d to achieve the goals will occur consecutively i.e.
with n o failures occurring before reaching the goal .
the mtsa tool set implements rsgr .
try1 try2suc1 fail1g asuc2 fail2a g l figure environment e. .
anomalous controllers anomalous controllers as we defined in are an important issue to consider in the context of automatic controlle r synthesis.
intuitively an anomalous controller tries to d ischarge its obligation of achieving goals by preventing the environment from fulfilling its own obligations.
werevisit theissue ofanomalous controllers for rsgr .
in rsgr the controller may discharge its obligation to achieve goals by either preventing assumptions from occurring or by forcing non strong independent fair traces.
the following definition of best effort controller extends that of for domains with failures.
it states that a controller for an rsgr problem is best effort if it prevents infinitely many occurrences of assumptions and strong independent fair traces as least as possible .
that is every other controller prevents these cases as much as the best effort one or more.
informally the definition states that for every point at which it is no longer possible to satisfy the assumptions infinitelyoften or itis notastrongfair indepe ndent trace the same would occur for every other controller.
definition .
.
best effort controller letrsbe an rsgr lts control problem with assumptions as.
we say that a solution mforrsis abest effort controller for rsif for all finite traces traces e bardblm such that for all where .
traces e bardblm we have .
logicalandtextn i g fai or .
is not strong independent fair then for all other solutions m torssuch that traces e bardblm every such that .
traces e bardblm either .
logicalandtextn i 1gfai or .
is strong independent fair.
consider the rsgr lts control problem r a bracketle tl t a bracketri ht wherel a bracketle te h l c a bracketri ht whereeis the lts in figure lc try1 try2 g h as gs as gf aand gs gf g. the controller enabling only try1 is a valid controller for rbut it forces the environment to fulfil its assumptions by failing while the controller enabling only try2is also a valid controller for rbut it doesn t force the environment to a place in which the only possibility to fulfil its assumptions is by failing.
such a controller is more desirable and is what we expect from a best effort controller in the context of recurrent success control problems.
notethat rsatisfies thebesteffortconditiondefinedin for sgr but not the one above for rsgr .
in a sufficient condition for ensuring best effort is defined.
it essentially dictates that it must be possible for the environment to fulfill its assumptions regardless of how a controller behaves.
in the context of domains with failures and rsgr this condition is not sufficient.
for rsgr we must require that the environment be able to achieve its assumptions independently of how the controller behaves and how decisions on failures occur.
the assumptions compatibility definition that follows is iden tical to that of except that the set of controlled actions is extended with failure actions.
the definition states that th e assumptions are compatible if there is no controller that ca nprevent assumptions from happening even when controlling failures.
definition .
.
assumptions compatibility given an rsgr lts control problem r a bracketle tl t a bracketri ht wherel a bracketle te h lc a bracketri htandh i as g we say that the asis compatible with eaccording to t if for every state sin ethere is no solution for the sgr lts control problem a bracketle tes h lc f a bracketri ht whereh i as false andesis the result of changing the initial state of etosandfis the set of allfailiint.
it is straightforward to see that the environment ein figure is not assumptions compatible with a. a controller m which never takes try2norfail1forcese bardblmto not satisfy gfa whichmeans that thecontroller has noobligation of satisfyingfalse.
hence there is a solution for the problem a bracketle te h l c f a bracketri ht whereh true a false .
similarly to the assumptions compatibility conditio n is related to the definition of best effort controller.
intuitively if the domain is such that the environment can produceall itsassumptions withoutrequiringtheuseof failur es then every controller is best effort.
theorem .
.given an rsgr lts control problem r a bracketle tl t a bracketri htwith environment model eand assumptions as ifasis assumptions compatible with eaccording to tthen all solutions to rare best effort controllers.
proof.
refer to .
the theorem above is applicable for ein figure since eis not assumptions compatible with a in effect there are non best effort controllers for e. however the orchestration problem discussed in section is assumptions compatible thetheoremappliesandallsolutions tothersgr orchestration problem are best effort.
the environment for the orchestration problem is assumptions compatible because the assumption a1requires there be package requests pending to be processed infinitely often.
a controller controlling failures too as in definition .
cannot impede the environ ment from achieving the assumptions because failures will simply delay package processing and while a package is being processed that package is pending.
on the other hand once the controller has processed the package it is blocked until a new package arrives.
hence the environment is free to deliver a new package request which becomes pending and which fulfils a1.
.
unsupported traces in the previous subsection we discussed assumptions compatibility.
underthisconditionacontrollercannotdisch arge obligations by either forcing assumptions not to occur or by forcing strong independent fairness not to hold.
however even in the case of satisfying the assumptions compatibili ty condition the environment may still choose not to satisfy strongindependentfairness.
clearly for suchtraces thec ontroller is not obligated to satisfy the goals.
consequently applicability of our techniqueseverely depends on howmany or how relevant are the traces in which goals are not necessarily achieved?
more concretely consider the example in figure .
assumptionais compatible with theenvironment.
thus solutions tothe control problem are guaranteed to be best effort.
consequently a controller that repeatedly attempts tryis a good controller it does not trytoachieveits goals vacuous lyand succeeds in achieving its goals for all strong independent fair traces.
however the trace try success l try fail a try success l ... is not strong independent fair.
hence the controller is not obliged to and in fact does not satisf y its goals.
how good is this controller?
how relevant is it that the controller does not achieve its goals for this trace ?
are there other traces for which the controller s obligatio ns are discharged and how relevant are they?
we consider this question in contexts where the environment can be thought of as a probabilistic model in which all transitions or at least non failing ones have non zer o probability.
we show that if we restrict our attention to assumptions compatible environments then the measure of the set of paths in which the environment progresses but the controller has no obligations is zero.
that is when working with assumptions compatible models the traces for which the controller does not achieve the goals are negligible.
consider an environment efor an rsgr problem r that can be seen as an abstraction of a markov decision process mdp ep.
it is possible to show that if eis assumptions compatible with respect to the assumptions of rthenthemeasure ofpathsthatarenotstrongindependent inepis zero.
more formally theorem .
.given an rsgr problem rwith an assumptions compatible environment e and an mdp ep such that the underlying lts ep is simulation equivalent toethen for every controller m for every fair scheduler sofepconsistent with m the following holds the measure of the setb is a trace of epunder scheduler sand matches a trace of ethat satisfies assumptions infinitely often but is not strong independent fair in m e is zero.
proof.
refer to .
for instance the mdp epin figure is a model of the ceramic cooking problem.
it is straightforward to see that the grounding of ep i.e.ep is simulation equivalent to the ltse2of figure .
in addition e2is assumptions compatible with a cooking as the only way of not achieving theassumption isbyperforming cooking whichis controlled by the environment.
so by theorem .
controllers to the rsgr problemwith environment e2 assumption a goal movetobelt try response triple cook broken not.broken and safety movetobelt cooked twice broken are besteffortandachievethegoals withprobabilityone.
trace s that are not strong independentfair e.g.
if a piece is broke n at least once in every two cooks are negligible.
consider now the orchestration problem of section .
its environment is compatible with the assumptions on pending package request.
the question to ask now is if the problem domain can be thought of as an mdp for the theorem above to be applicable.
this amounts to validating if the environment s choices can be thought of as probabilistic choice s over some memoryless probabilistic distribution.
all choi ces of the environment are related to failures queries on avail ability of cars hotels and plains can fail reservations on these can fail and so can payments.
modelling each query failure success as an independentprobabilistic choice en tails the following.
either resources are transiently unavailab le e.g.
cars of a certain model eventually become available or users will vary their criteria reasonably e.g.
making it less restrictive in order to succeed in queries.
hence the orem .
is not free.
requiring an mdp model of the domain means that the denotation of for instance failures must be4 5cookidle cookingfinishedcooking env envbroken not.brokenmovetobeltcookmovetobelt fixcook pp 11p1 p figure mdp for ceramic cooking problem.
compatible with probabilistic choice.
in many setting such a denotation is possible and realistic as with the orchestr ation problem but this is not necessarily the case.
if for instance payment failure denotation includes failures du e to incorrect program logic in one of the services then assuming probabilistic behaviour of these failures may not be valid.
for example the logic may be such that it consistently fails once every npayments of the same client where nis the number of services that a package includes.
summarising theorem .
shows that the restriction to strong independent fair paths is not severe if the problem domain can be modelled probabilistically.
.
case studies in this section we report on a number of case studies.
we evaluate the applicability of our approach and the benefits i t provides with respect to existing synthesis techniques.
th e case studies are taken from existing literature on behaviou r model synthesis.
applicability is evaluated based on the fo llowing criteria i is rsgr applicable to the case study as described in the literature ii is rsgr applicable to richer versions which introduce domain relevant failures .
benefits with respect to existing techniques is evaluated ba sed oni the ability to generate controllers automatically ii the guarantees provided by the resulting controller and iii the degree of idealisation of the problem domain.
for the controller synthesis tool and all case studies includi ng the orchestration problem of section see .
production cell.
in we presented a control problem based on the production cell a robotic arm coordinates the application of various tools to construct a product fulfi lling some safety and liveness requirements.
the liveness requirement is that infinitely many products are constructed.
the assumption is that if the controller is waiting for piece s to construct a new product it eventually receives them.
both the original problem formulation and that of take an idealised view of the problem.
they assume that all controllable arm actions succeed.
for instance it is possible to order an arm to lift a piece from the conveyor belt and it is assumed that this always succeeds.
we refined the problem in order to account for failed arm movement actions.
we define a set of try success triples of the form put.tool i tooli.succ tooli.fail modelling the action of placing a piece to be processed by tool iand the possible success or failure of the action.
the resulting model is a compatible environment see definition .
for the following assumption if the controller is waiting for pieces the environment provides then.
hence the rsgr problem is guaranteed to produce a best effort controller see theorem .
.
it could be argued that we model failures to our advantage in order to obtain a compatible environment.
however we find it very natural that failures and assumptions in this case are independent.
notice that failures can occuronly when the controller is busy working on existing pieces.
hence it would be impossible to not satisfy assumptions when failures occur.
another possible criticism could be that strong independent fair traces are not sufficient in this domain.
however for instance suppose that failures are abstracting imprec ision of arm movements.
in such a case arms miss the target location for loading or unloading due to traction problems.
it is reasonable to assume that the imprecision measured in millimetres is amemory less randomvariable.
hence failu re would be related to the imprecision being above a certain threshold.
consequently the probability of a failure is in dependent of the global state of the environment that of the controller and of the history of previous failures.
consider a denotation of failures such as the one above.
by proposition .
the traces for which the controller provides no guarantees have probabilistic measure zero.
obviously if the failure denotes also the possibility of the arm breaking or getting permanently stuck then the measure of such traces is not zero.
in fact under such scenarios no controller could achieve its production goals unless anot her action repair or get unstuck is added .
pay ship.
pistore et al.
synthesise a plan for composing distributed web services and monitoring them .
more specifically a web service coordinates purchase requests by buying on a furniture sales service and booking a shipping service.
the case study includes these failures both the furniture sales and shipping services may respond positiv ely or negatively to a request by the controller to be.
the controller synthesised in gives no guarantees that the goal of satisfying purchase requests is achieved.
in fac t achieving the goals stated in requires assuming progre ss on the environment and fairness conditions on the success of operations on the furniture sales and shipping services .
we modelled this case study as an rsgr problem.
in our setting it is possible to check that the model is a compatible environment with respect to the following assumptions.
first that the purchase requests occur infinitely of ten.
second that customers confirm infinitely many products and delivery options.
thus the resulting controller i s guaranteed to be best effort.
furthermore the environment assumptions under which it achieves its goals are explicit.
finally the probabilistic argument of section .
is appli cable if failures are assumed for instance to be a result of lack of periodically renewed resources no stock of selecte d furniture or no delivery trucks available at the moment of request .
if on the other hand failures denote the applica tion of a commercial policy related to the characteristics o f the purchase then a probabilistic argument may not apply.
clearly users of our technique have to analyze its adequacy for their specific problem.
they have to understand the implications of assuming strong fair independece on traces and the implications of deploying a service which does not provide guarantees in these cases.
autonomous vehicles.
weconsider therobotics case study originally presented in .
it presents a disaster recove ry scenario in which a robot must travel within a collapsed house taking supplies to people trapped in one of the rooms.
inadditionanumberofobstacles mayintermittentlyimpede movement of the robot.
the synthesis algorithm presented in considers two types of failures as a result of movements of the robot i the robot does not get to expected position after moving for instance due to roughness of theterrain and ii the package is dropped as a result for instance of sharp movements of the robot.
the goal of the controller is toget tothetarget location with supplies.
ho wever there is no guarantee that the controller achieves thi s goal.
the environment model as presented in assumes the following.
first the robot is loaded with supplies infinite ly often.
second intermittent obstacles disappear infinitel y often.
we find that the environment is compatible with these assumptions.
thus posing this case study as rsgr produces a controller that is guaranteed to achieve its goals fo r strong independent fair traces.
furthermore if failures d ue tomovementattempts areconsidered tobeindependent i.e.
that the rubble may compromise an attempt at moving but that the robot does not encounter an unsurmountable unmodelled obstacle such as a wall and if the loss of supplie s has a probability lower than one then strong independent fair traces have a probabilistic measure of one.
note that in an adaptation of the case study is presented.
due to the limitations of the technique in dealing with failures either failures must be restricted or remove d altogether or if fully specified the technique reports tha t no controller can be built.
bookstore.
we consider the web service composition scenario in which structurally resembles pay ship.
similarly to pay ship two services are to be coordinated to provide a more complex service.
the difference is that no explicit liveness properties are stated.
furthermore an i dealised version of the services is provided in which no failur es can occur.
the introduction of failures to this problem results in a problem that is in essence the same as pay ship and which our approach can deal with.
.
discussion and related work our work builds on that of the controller synthesis community and particularly on the generalised reactivity synthesis algorithm gr .
in we revisit gr and adapt it to a message passing communication model rather than for a shared memory model.
the message passing model matches the paradigm in behaviour modelling and analysis in software engineering e.g.
requirements engin eering and architectural design .
specifically in a contro ller synthesis algorithm sgr is studied for lts and csplike parallel composition .
in particular we provided a sound methodological approach to the definition of assumptions in order to avoid anomalous controllers.
the techniqu e presented herein extends both the controller synthesis alg orithms and methodological definitions of to account for domains with failures.
although numerous behaviour model synthesis techniques have been studied e.g.
these are restricted to userdefined safety requirements.
the exceptions that we are aware of relate to the self adaptive systems and planning.
sykes et al.
build plans for reachability a limited form of liveness goals .
in their setting the execution of t he plan is restarted every time the environment behaves unexpectedly.
hence there is an implicit assumption that the environment behaves well enough for the system to eventually reach the goal state.
as well enough is not defined it is not clear what guarantees are provided by the resulting plans.
more generally planning as model checking supports ctl goals for kripke structures.
thus the problemof environment controller composition distinction betw een controllable and monitored actions and realizability are n ot considered.
in addition as with when failures are sup ported there are noguarantees as to when goals are actually achieved by plans.
in the problem of constructing an adaptation strategy is studied.
however it is limited to enforcing safety properties and uses a backward error propagation technique to construct controllers.
the lack of explicit live conditi ons makes failures and fairness conditions irrelevant.
finally our work is heavily influenced by the work on requirements engineering by jackson van lamsweerde and parnas .
they have argued the importance of distinguishing between descriptive and prescriptive asserti ons between software requirements system goals and environment assumptions and the key role that the latter play in the validation process.
.
conclusions we have presented a controller synthesis technique for event based operational models.
our technique supports a restricted yet expressive form of liveness.
it conforms to foundational requirements engineering best practices i it makes explicit the assumptions on the environment behaviour and ii distinguishes between controlled and monitored actions.
our technique integrates failures allowi ng less idealised environment models.
in order to handle failures we introduce explicit fairness conditions that are required to guarantee controller goals.
we provide methodological guidelines for providing well constructed assump tions which are in line with standard realisability notions.
we show that these guidelines guarantee controllers that are eager to satisfy goals and avoid discharging obligation s by invalidating environment assumptions.
furthermore fo r environments that satisfy these guidelines and have an underlying probabilistic behaviour the measure of traces th at satisfy our fairness condition is .
this gives further evidence to the usefulness of these guidelines.
a key aspect of our technique is that unlike general controller synthesis techniques it remains within polynomia l complexity.
werestrictuserstowritespecificationingr which has beenused in complex problem settings such as autonomous vehicles .
the fairness condition required in our technique is crucial to reducing the problem to sgr andthengr .
thetradeoff betweenalgorithmic complexity and expressiveness is captured by strong independent fairness.
informally strong independent fairness requir es environments not to orchestrate failure occurrences and sa tisfaction of assumptions.
as shown in discussions and case studies there are relevant problem domains in which environments have such characteristics.
in particular there a re problem domains where environment choices can be characterised by memoryless probabilistic choices which make ou r technique even more appealing.
.