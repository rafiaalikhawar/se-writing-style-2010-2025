permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to red istribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india .
copyright acm ... .
.
trading robustness for maintainability an empirical study of evolving c programs n lio cacho thiago c sar thomas filipe eliezio soares arthur cassio rafael souza israel garcia department of informatics and applied mathematics federal university of rio grande do norte natal brazil neliocacho dimap.ufrn.br lord.sena thomasfdsdiniz arthurecassio rafael israelbarbosa lcc.dimap.ufrn.com eiji adachi barbosa alessandro garcia informatics department pontifical catholic university of rio de janeiro puc rio rio de janeiro brazil ebarbosa afgarcia inf.puc rio.br abstract mainstream programming languages provide built in exce ption handling mechanisms to support r obust and maintainable impl ementation of exception handling in software systems.
most of these modern languages such as c ruby python and many others are often claimed to have more appropriated exception handling mechanisms .
t hey reduce programming constraints on exception handling to favor agile changes in the source code.
these languages provide what we call maintenance driven exce ption handling mechanisms.
it is expected that the adoption of these mechanisms imp rove software maintainability without hindering software robustness.
however there is still little empi rical knowledge about the impact that adopting these mechanisms have on software robustness.
this paper addressed this gap by conducting an empirical st udy aimed at understanding the rel ationship between changes in c programs and their robustness.
in particular we evaluated how changes in the normal and exce ptional code were related to exception handling faults.
we applied a change impact analysis and a control flow analysis in ve rsions of c programs.
the results showed that i most of the problems hindering software robustness in those programs are caused by changes in the normal code ii many potential faults were introduced even when impro ving exception handling in c code and i ii faults are often facilitated by the maintenance driven flexibility of the exception handling mechanism.
more over we present a series of change scenarios that decrease the program robustness .
categories and sub ject descriptors d. .
software engineering maintenance and enhancement corrections r estructuring reverse engineering reengineering .
general terms measurement reliability experimentation.
keywords exception handling robustness maintainability .
introduction robust software systems must provide their intended fun ctions and operations in the presence of erroneous or unexpected conditions.
thus a compulsory part of a robust software system is its exception handling .
exceptions are abnormal events that occur at runtime to indicate that the system internal state is inconsistent and therefore recovery actions should be taken before the system continue s its normal flow.
an exception ha ndling mechanism ehm for short is a model that allows software developers to detect and signal the occurrence of exceptions and also to structure recovery actions.
experienced software developers explicitly recognize the impo rtance of robust exception handling in evolvable software sy stems .
however given the incremental nature of software deve lopment projects exception handling is often explicitly treated and incorporated a posterior .
there is a wide range of forces governing incremental treatment of exception handling in a sof tware project .
in some cases exceptions and appr o priate recovery actions for existing functionalities can only be revealed after the core functionalities are fully known and impl e mented in a program .
in other cases new require ments emerge afte rwards then the related exceptions and handlers have to be ident ified structured and realized on demand.
e ach software project may also impose particular constraints on when and how exce ption handling structure should evolve over time.
as a cons equence the solution for exception handling implementation should enable modular and agile realization of software changes.
otherwise software developers may be discouraged on maintai ning exception handling in a program .
nowadays most mai nstream programming languages provide built in ehms to support implementation of exception handling in software systems.
moreover some programming languages pr ovide built in ehms with extra facilities to avoid the introduction of faults in the exception h andling code which would decrease the program robustness .
in p articular these mechanisms force developers to explicitly specify at methods signatures an exce ptional interface i.e.
a list of exceptions that a method might raise during its execution.
in this manner these mechanisms can pe rform automatic reliability checks to verify if consumer methods implement appropriate handlers for the exceptions declared in the exceptional interface of provider methods.
we call these mecha nisms as reliability driven ehms.
t ypical examples of languages that provide reliability driven ehm s are java eiffel and guide .
even though the facilities provided by reliability driven ehms are aimed at aiding developers to properly impl e permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may june hyderabad india copyright acm ... .
ment the ex ception handling of their programs these facilities have well known adverse side effects to software maintainability .
reliability driven ehms therefore favor software reliability in detriment to software maintainability.
in this manner designers of programming languages such as c and c have increasingly argued for less rigid ehms.
we call these more flexible mechanisms as maintenance driven ehms.
these mechanisms in particular do not enforce declar ations of excep tional interfaces in methods signatures in order to make it easier to change exception handling structure according to project s evolving requirements.
despite the absence of exce ptional interfaces reliability checks are still supported at runtime.
theref ore their designers claim that these mechanisms allow developers to achieve a better trade off between robustness and maintainability .
however there is little empirical knowledge on how programs using such maintenance driven facilities for exception handling evolve over time.
their impact and side effects on the reliability and maintainability in a software project is actually unknown.
fault prone programming scenarios on changing both normal and exceptional codes need to be better understoo d when mainte nance driven exception handling is employed.
existing empirical studies focus on the investigation of patterns to handle exceptions in progra m ming languages without built in ehms or reli ability driven facilities for exception handling s upported for i nstance in java and its dialects .
this paper fills this gap by presenting an empirical study that assesse d the relationship between program changes and c pr ograms robustness.
we analyzed changes to both normal and exceptional code in version s extracted from software projects covering several domains.
to conduct this study change impact analysis and control flow analysis were performed on those versions of the analyzed projects.
these data analyses a llowed us to investigate how often certain recurring change scen arios decrease d the software robustness of the evolving programs analyzed .
the following particular findings were also derived we confirmed that the use of maintenance driven facilities in c allows accommodating different evolution patterns for e xception handling across the projects.
we quantified which and to what extent specific change scenarios decrease software r obustness .
indicators revealed that the effort i.e.
amount of code wri tten to inc lude new exception handling code is consistently low across all c projects.
however there were many types of change unexpectedly decreas ing software robustness.
this was the case for instance when i adding handlers intended to remap and re throw exc eptions and ii changing the ha ndlers to catch more specific exception types.
these changes focused on improving exception handling but surprisingly and recurrently led to exception occurrences being uncaught.
in particular remapping of exceptions fo r instance is co mmonly referred as a good programming practice but it was a common source of potential faults in c programs.
there was a high incidence of changes initially targeted at modifying normal code causing unexpected changes to exce ption handli ng.
in other words there is still a strong coupling between normal and exception code when using c exception handling mechanism.
the couplings are hard to detect by pr ogrammers as they cannot be observed syntactically e.g.
access to local variables .
th anks to this coupling and the lack of static reliability checks programmers may often introduce faults in the exception handling code.
these findings seem to indicate that exception handling support still needs to be improved.
even though changes can be e asily realized with c programming mechanisms the rate of possible exception handling faults was too high.
and it was not just a matter of exception handling being ignored.
the remainder of this paper is organized as follows.
section describes basic con cepts and the characteristics of exception handling mechanisms.
section presents the experimental procedures adopted in this study.
se ctions present results and their analyses.
section presents the threats to validity.
section discusses related wor k. section provides some concluding remarks.
.
exception handling exception handling mechanisms are the most co mmon models to cope with errors in the development of software systems.
their basic concepts and a classification are presented in the next subsections.
.
basic concepts although ehm s implementations vary from language to la nguage they are typically grounded on the try catch constructs as depicted by the following general structure try s catch e x h catch e x h the t ry block delimits a set s which is a set of statements that are protected from the occurrence of exceptions.
the try block defines the normal code and it is associated with a list of catch blocks.
each catch block defines a set h n which is a set of statements that implement the handling actions responsible for coping with an exception.
the set h n consists of the exceptional code and it is commonly called the exception handler .
each catch block has an argument e n which is an exce ption type.
these arguments are filters that define what types of exceptions each catch block can handle.
when a catch block defines as argument an exception type e it can handle exceptions of the e type and also exceptions that inhe rit from e .
when a catch block handles an exception that is a subtype of its argument it is said that this exceptions was handled by subsumption .
handler search.
if an exception is thrown in the context of the set of protected statements s the ehm performs at runtime the search for a proper handler.
the search takes into account the list of catch blocks statically attached to the enclosed try block.
the type of the exception thrown is compared with the exception types declared as arguments in each catch block.
for the firs t matching pattern the exception handler of that catch block is executed.
if no matching pattern is found the exception propagates up the call stack until a matching handler is found.
if no handler is found in the whole call stack the exception handler mechanism either propagates a general exception or the program is terminated.
when no handler is found it is said that the exception was u ncaught .
reliability and maint enance driven ehm.
amongst the diffe rent implementations of built in ehm we classify them in two main categories reliability driven and maintenance driven .
r eliability driven ehm s promote software reliability by means of the explicit specification of exception handling constraints.
these me chanisms enforce software developers to specify in each m ethod interface a list of exceptions that might be raised during its execution and therefore should be handled by client methods.
the list of exceptions that might be raised by a method is called i ts exceptional interface .
in this manner it is possible to perform 585automatic reliability checks to verify if software modules adhere to the specified constraints.
in java for instance if a consumer method does not handle the exceptions specified in the exceptio nal interface of a provider method nor specify them in its own exceptional interface compilation errors occur.
it is expected that such reliability checks prevent software developers from introdu cing faults in the exception handling code.
side e ffects of reliability driven ehm s .
however there are some adverse side effects of using exceptional interfaces.
the main problem of supporting exceptional interfaces is related to its impact on software maintenance .
if a new exception is added to the exceptional interface of a method at the bottom of the method call chain the exceptional interfaces of all methods through which the new exception will be propagated also have to be updated.
for programs with long method call chains this is a time c onsuming and error prone task causing severe problems on the system architecture evolution.
furthermore enforcing the declaration of exceptional interfaces in order to propagate exceptions leads to an artificial increase of the coupling betwe en exception classes and intermediary methods that only propagate exceptions .
in some cases this high coupling causes the inability to reuse normal behavior without changes to the normal and exceptional code .
the omnipresence of maintenance driv en ehm s .
mainte nance driven ehm s on the other hand promote software mainta inability by not forcing developers to specify exception handling constraints.
in this manner developers are free of the burden of specifying exceptional interfaces.
most mainstre am programming languages adopt maintenance driven ehm s .
in fact amongst the top most used programming languages eight languages c c objective c php visual basic python javascript and ruby provide maintenance driven ehm s whereas one lang uage c does not provide built in ehm and one language java pr ovides reliability driven ehm.
despite the large adoption of la nguages that provide built in maintenance driven ehm s there is still a gap in the literature in terms of the impact that mainte nance driven ehm s have on software robustness.
in this paper we focus on the ehm provided by the c programming language to investigate such an impact of the maintenance driven approach.
the built in ehm provided by c is a representative of the mai ntenance driven category for two main reasons.
first c supports automatic propagation of exceptions .
the automatic propag ation of exceptions does not require inserting handlers to explicitly catch and rethrow exceptions along the call chain in order to ensure that these exceptions will make its way to the top of the call stack.
second c does not support the specification of e xceptional interfaces in methods signatures hence methods can throw any exception without making this explicit in their sig n ature.
in this manner developers can add new exceptions to exis ting methods without having to cope with the ripple effect of i mplementing the propagation of these exceptions along the whole call chain.
this also avoids unnecessary tangling between normal and exceptional code and facilitates the modification and reuse of the normal behavior of a system .
.
experimental procedures as described in the previous section the maintenance driven ehm focus on achieving superior maintainability of the norma l and exceptional behavior of a system.
however there is limited empirical knowledge about the impact that the use of mainte nance driven ehm has on program robustness.
therefore the goal of this empirical study is to investigate if and to what extent the benefits introduced by maintenance driven ehm are counterb alanced by adverse side effects that decrease software robustness during software evolution.
the experimental procedures of this study comprised four stages i in the first stage we defined the study hypotheses section .
ii in the second stage we selected the sample of subject pr ograms section .
iii then we defined the variables of the study and the suite of metrics to be computed from the source code and binaries of the subject pr ograms section .
and iv finally we used the gathered metrics to perform statistical anal ysis using the statistical package spss section .
.
hypotheses this study relies on the analysis of the following hypotheses which are set up as null hypothes es hypothesis there is no significant relationship between the number of changes in the code responsible for implementing the normal behavior and the number of changes in the exce ptional code code within catch blocks .
hypothesis there is no significant relationship between the number of changes in the code responsible for implementing the normal behavior and the level of robustness of a system.
hypothesis there is no significant relationship between the number of changes in t he exceptional code code within catch blocks and the level of robustness of a system.
the first hypothesis aims at investigating whether the number of changes in the exceptional code increases with the number of changes in the normal code.
the second hyp othesis investigates whether changes in the normal behavior of a program ha ve side effects on the level of robustness of a system.
the third hypothesis investigates whether changes in the exceptional behavior of a program ha ve side effects on the level of robustness of a system.
.
sample we selected our sample of subject programs based on the sample of c programs used on a previous study performed by cabral and marques .
we opted to select our subject programs from their study because their sample covers a wide spectrum of how maintenance drive n exception handling is typically used in real software development environments.
we divided our subject programs in the same categories used by cabral and marques i libraries software libraries providing a specific appl i cation domain api ii applications running on server server apps software applications running on server pr o grams iii servers server programs and iv stand alone a p plications desktop programs.
in our sample we tried to include t he maximum number of c programs used in the study of cabral and marques.
however since in their study they only analyzed one version of each subject program whereas in our study we were interested in analyzing programs during their evolution we had to discard those programs that did not have more than one version available to download nor had public version control systems available .
for such cases we replaced the discarded program with another program from the same category.
our final sample comprise d a set of open source c programs.
even though we had to perform some r eplacements in the original sample of cabral and marques study our sample was also particularly diverse in the way exception handling is employed.
for instance we could find almos t all the categories of exception handlers in terms of their structure including nested exception handlers masking handlers context 586dependent handlers and context affecting handlers.
we could also observe that the behavior of exception handlers sign ificantly varied in terms of their purpose ranging from error logging to application specific recovery actions e.g.
rollback .
table presents our final sample of subject programs.
table subject programs name pairs average loc libraries direct show lib .
dot net zip zip .
report net .
smartirc4net .
subtotal .
server apps blog engine admin .
mvc music store .
photoroom .
sharp webmail .
subtotal .
servers neat upload .
rnwood smtp server .
super socket server socketengine .
super web socket .
subtotal .
stand alone asc generator .
circuitdiagram ecomponents .
nunit nunitcore.core .
sharp developer main.core .
subtotal .
total .
table reports for each subject program its name the number of consecutive version pairs analyzed and the average number of lines of code.
for the smartirc4net library for instance we analy z ed pairs of versions .
.
.
.
.
.
.
.
and .
.
.
.
.
for each category table also shows the total number of pairs and the total number of loc analyzed .
in the la st row it is shown the total number of pairs and the total number of loc analyzed in this study.
.
v ariables and metrics the selected variables are the metrics quantifying some charact eristics of both normal and exceptional code.
we chose different metrics to capture changes in the normal and the exceptional code during software evolution and also metrics that quantify the robustness of a program.
therefore the variables of interest of this study encompass a suite of metrics classified in three categ ories size metrics robustness metrics and change metrics.
the following subsections describe each suite of metrics and how they were computed.
.
.
size metrics size metrics capture the basi c structure of the normal and the exception handling code of a software system.
the size metrics used in this study are i nmod counts the number of modules classes and interfaces of each version of a system ii nmethod counts the number of methods of each version of a system iii ntry counts the number of try blocks of each ve rsion of a system and iv ncatch counts the number of catch blocks of each version of a system.
we computed the size metrics using two different tools.
ntry and ncatch were computed using the eflowmining tool whereas nmod and nmethod were computed using the sourcemonitor tool.
.
.
robustness metrics robustness is the ability of a program to properly cope with errors during its execution .
if a handler is not d efined or correctly bound to an exception program robustness is decreased.
in order to measure software robustness we followed the typical approach adopted in the community in which exception flow information is used as an indicative of robustness .
exception flow is a path in a program call graph that links the method where the exception was raised to the method where the exception was handled.
if there is no handler for a specific exception the exce ption flow starts in the method where the exception was raised and finishes at the program entrance point.
in the context of our anal ysis we used three metrics to support our analysis of software robustness as they are often used as an indicative of software robustness specia lized flow counts the number of exception flows in which the raised exception is caught by a handler with the same exception type.
higher the number of specialized flows higher the level of robustness is likely to be.
subsumption flow counts the number of exception flows in which the raised exception is caught by subsumption section .
.
a high rate of handling by subsumption help s to dete rmine the level of robustness as for instance exceptions are bound to general handlers and improper actions are being e xecuted.
uncaught flow counts the number of exception flows that leave the bounds of the system without being handled.
u ncaught exceptions terminate the execution of a program hence the higher the number of uncaught exception flows is the lo wer the system s robustness is.
we employed the eflowmining tool to collect the robustness metrics.
eflowmining uses the common compiler infrastructure framework to analyze the binaries of a program and follows the approach proposed by to perform an inter procedural and intra procedural dataflow analysis.
the tool generates the exce ption flows for all exceptions explicitly thrown by the application or implicitly thrown e.g.
thrown by library method s .
in this study we are assuming th at only one exception is thrown at a time the same assumption considered in .
as well as we have ignored i.e.
not considered exception flows created by exce ptions that are not normally related to the program logic exe.
system.missingmethodexc eption .
the full list of exce ptions not considered in our analysis is detailed in .
.
.
change metrics in order to quantify the changes in both normal and exceptional code we collected a suite of typical change impact metrics .
change impact metrics count at the program level the number of elements added changed or removed between two versions of a given system.
the elements considered in this study range from more coarse grained elements such as classes and methods to more fine grained elements such as try and catch blocks .
in our study we considered exceptional code only the catch block which handles an exception.
figure collecting change impact measures an example the change metrics are computed based on the di fference between the source code of a baseline version and the source code of a subsequent version.
the definition of each change metric used in this study is presented next.
along with the definitions there is also an example for each change metric.
the examples are based on the code snippet presented in figure .
this figure shows two versions of a class named c1 where the version n on the left is the baseline version of c1 and the version n on the right is the subsequent version of c1 .
ehlocadded ehlocchanged and ehlocremoved they count respectively the number of lines of exceptional code added changed and removed between a pair of versions.
in the example presented in figure three lines of exceptional code are added two lines a re changed and no line is removed.
hence the value of the ehlocadded metric is the value of ehlocchanged metric is and the value of ehlocremoved is .
tryblockadded and tryblockchanged they count respe ctively the number of try blocks added and cha nged between a pair of versions.
in the example presented in figure one try block is added and another is changed.
notice that when lines of code are added to or removed from a try block we cons idered as it has changed.
hence the value of tryblockadde d is and the value of tryblockchange is .
catchblockadded and catchblockchanged they count respectively the number of catch blocks added and changed between a pair of versions.
in the example presented in figure one catch block is added and another is changed.
hence the value of catchblockadded is and the value of catchbloc kchange is .
classchurned it counts the number of classes that have a catch block added or changed between a pair of versions.
in the example presented in figure catch blo cks were added and changed in the same class so the value of classchurned is .
methodchurned it counts the number of methods that have a catch block added or changed between a pair of versions.
in the example presented in figure catch blocks were ad ded and changed in two different methods so the value of m ethodchurned is .
normalchurnedloc it counts the sum of the added and changed lines of normal code for a pair of versions.
in the e xample presented in figure one line of normal code is change d within the first try block and six lines are added.
hence the value of the normalchurnedloc is .
we e mployed the microsoft line of code counter tool loccou nter to count nomalchurnedloc.
loccounter provides the churnedloc metric which counts t he sum of the added and changed lines without distinguishing whether the code is normal or exceptional.
for that reason we subtract the abs olute value of the churnedloc metric provided by the tool from the sum of ehlocadded and ehlocchanged i.e.
no rmalc hurnedloc churnedloc ehlocadded eh lo cchanged .
our main goal during the change impact analysis was to gather deeper knowledge about the recurrent change scenarios observed and their impact on software robustness.
therefore we had to not only comput e the change metrics but also describe each change scenario observed and assess its impact on software robustness.
since some of these information are inherently qualitative we could not rely on any existing static analysis tool to automatically extract them from the source code nor implement a tool of our own.
in this manner we had to perform a manual inspection in the source code in order to textually describe the change scenarios and assess the impact of the observed changes in the software robustne ss.
these tasks were performed by a group of six master students a phd student and two senior researchers.
each master student performed a manual inspection on the source code of the versions of a given subject program and simultaneously i co mputed the change metrics ii textually described the observed change scenarios and iii assessed the impact of the changes on software robustness by means of an exception flow analysis .
the data produced by the master students were reviewed by the phd s tudent and the main researchers.
further clarifications modific ation or improvements were performed by the master students when divergences were identified by the reviewers.
whenever necessary the students performed an open discussion with the reviewers to resolve any conflict and reach a consensus on the data produced.
if on one hand this manual inspection process did not allow us to scale our study to a larger sample on the other hand it provided us with more accurate data and a better unde rstanding of the change scenarios observed.
moreover it also allowed us to identify and categorize change scenarios that i mproved or deteriorated the robustness of the subject programs.
next each task is described in more details.
change metrics computation a nd textual description .
the change impact metrics were manually computed with the aid of the diffmerge tool.
the diffmerge tool performs a visual side by side comparison of two folders showing which files are present in only one folder as well as fil e pairs two files with the same name but in different folders that are identical or different.
for file pairs with differences the tool also graphically shows the 588changes between the two files.
the diffmerge tool was used to compare the project folder o f two subsequent versions of a given subject program.
for each file pair with differences the master students manually computed the change impact metrics by i nspecting the differences pinpointed by the tool.
for each change scenario analyzed the students also textually described the o bserved changes occurred within try blocks and catch blocks.
for instance in one of the change scenarios analyzed one of the students described it as follows it was observed a new if stat ement added to the try block and a new method invocation added to the catch block .
on a further step the main researcher applied a coding technique to the textual descriptions of each change scen ario in order to extract categories of change scenarios divided in categories of changes in the normal code and categories of changes in the exceptional code.
the result of this categorization is presented on table .
table chang e scenarios and corresponding descriptions.
scenarios description changes in exceptional code generic handler added a catch block which catches a generic exception is added empty generic handler added an empty catch blocks is added to handle a generic exception generic handler added to rethrow exception a catch block which catches a generic exception is added to construct a new exception which is thrown generic handler removed a catch block which catches a generic exception is removed specialized handler added a catch block which catches a specific exception is added empty specialized handler added an empty catch blocks is added to handle a specific exception specialized handler added to rethrow exception a specific handler is added to construct a new exception which is thrown specialized handler removed a specialized handler is removed changing the exception handling policy changes how an specific exception type is handled changing the catch block to use normal code the catch block needs to change its code in order to use some