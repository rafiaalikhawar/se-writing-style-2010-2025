developers ask reachability questions thomas d. latoza institute for software research school of computer science carnegie mellon university tlatoza cs.cmu.edu brad a. myers human computer interaction institute school of computer science carnegie mellon university bam cs.cmu.edu abstract a reachability question is a search across feasible paths through a program for target statements matching search criteria.
in three separate studies we found that reachability questions are common and often time consuming to answer.
in the first study we ob served developers in the lab and found that half of the bugs developers inserted were associated with reachability questions.
in the second study professional software developers reported asking questions that may be answered using r e a c h a b i l i t y q u es tions more than times a day and rated one or more as at least somewhat hard to answer.
in the third study we observed developers in the field and found that of the longest activities were associated with reachability questions.
these findings sug gest that answering reachability questions is an important source of difficulty understanding large complex codebases.
categories and subject descriptors d. .
programming environments d. .
distribution maintenance and en hancement.
general terms human factors.
keywords program comprehension empirical study software maintenance code navigation developer questions .
introduction a central goal of software engineering is to improve developers productivity and the quality of their software.
this requires an efficient and effective way to explore code since most developers will encounter code with which they are not familiar.
understand ing code in modern codebases is challenging because of the size and complexity o f t h e c o d e b a s e and the use of indirection.
for example many modern codebases use callbacks and events to connect modules or communicate with external frameworks.
while use of indirection enables reuse it also makes understand ing relationships between behaviors more challenging.
for exam ple an analysis of code in adobe s desktop applications found that one third of the codebase is devoted to event handling logic which in turn caused half of the reported bugs .
successfully coordinating dependencies among effects in loosely connected modules can be very challenging .
to better understand how developers understand large complex codebases we conducted three studies of developers q u e s t i o n s during coding tasks.
surprisingly we discovered that a significant portion of developer s w o r k i n v o l v e s a n s w e r i n g what we call reachability questions.
a reachability question is a search across all feasible paths through a program for statements matching search criteria.
reachability questions capture much of how we observed developers reasoning a b o u t c a u s a l i t y among behaviors in a program.
consider an example from our first study after proposing a change a developer sought to determine if it would work before committing to implementing it.
to do so he wanted to determine all of the events that cause this guy to get updated .
while he was aware that a call graph exploration tool could traverse chains of method calls this did not directly help.
upstream from the update method was a bus onto which dozens of methods posted events but only a few of these events triggered the update.
exist ing call graph tools are unable to identify only those upstream methods sending the events triggering the update of interest.
un able to answer the question in any practical way he instead opti mistically hoped his guess would work spent time determining how to reuse functionality to implement the change edited the code and tested his changes before learning the change would never work and all his effort had been wasted.
we found that many of the problems that developers experience understanding code arise from difficulties answering reachability questions.
in a lab study of modifications to complex unfamiliar code developers often inserted defects because they either could not successfully answer reachability questions or made false as sumptions about reachability relationships.
a survey of develop ers t h a t a s k e d a b o u t r e a r c h a b i l i t y q u e s t i o n s r e v e a l e d t h a t on average .
of these were thought to be at least somewhat hard to answer.
and these questions were not limited to inexperienced developers or those new to a codebase neither professional de velopment experience nor experience with their c o d e b a s e m a d e these questions l e s s f r e q u e n t o r e a s i e r t o answer.
reachability questions can be time consuming to answer.
in a field study developers often spent tens of minutes answering a single reach ability question.
this paper presents data about reachability questions gathered from over developers and over hours of direct observations of coding tasks.
we first review related work and formally define reachability questions.
next we present the method and results of each of three studies in turn and discuss their findings.
finally we permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may cape town south africa copyright acm ... .
discuss the implications of these findings for helping developers more effectively understand code.
.
related work it has long been known that control and data flow are central to how developers mentally represent programs .
studies of pro gram comprehension have found that developers begin under standing small programs by constructing a mental model of con trol flow .
a number of st udi es have appl i ed t he i dea of in formation foraging t o d e s c r i b e how developers navigate code .
beginning at an origin method developers use cues such as method names to pick which of many calls t o traverse towards targets and remember information they collect .
simulations of code navigation have focused on understanding exactly how developers decide which calls to traverse.
for example one study found that words contained in a bug report were usually sufficient to explain which calls developers decide to traverse .
devel opers must also remember what they find.
difficulties here have been found to lead t o i n f o r m a t i o n l o s s p o o r r e p r e s e n t a t i o n choices and problems returning to points where information was previously found .
these studies illustrate the central impor tance of navigating and exploring code to coding tasks.
several recent studies have observed developers at work in coding tasks to identify information needs or q u e s t i o n s a s s o ciated with development activities.
one study identified questions devel opers ask about interactions in code artifacts and teammates .
we believe that one third of these questions are questions which developers might answer by asking reachability questions.
some of the other questions were related to communication with team mates maintaining awareness of changes and reasoning about design.
another study identified questions s p e c i f i c a l l y a b o u t code .
they reported that developers refine their questions from higher level q u e s t i o ns such as the implications of their changes into lower level questions that can be more directly an swered using the d e v e l o p m e n t e n v i r o n m e n t .
many of the chal lenges developers experienced stemmed from problems separating task relevant results from the many task irrelevant results that the tools in the d e v e l o p m e n t e n v i r onment produced.
several of the questions they identified were specifically about control or data flow.
interestingly of the questions identified as not well sup ported by existing tools were questions we believe develop ers might answer by asking reachability questions.
several studies have observed developers using existing tools for understanding control flow to produce recommendations for fu ture tools that would more effectively support developers needs.
one study observed developers using a uml tool while editing code .
in addition to identifying several usability problems a key recommendation was to better support selecting task relevant items in the reverse engineered view to prevent wasted time un derstanding task irrelevant items.
they also saw the need for much more automated support for reverse engineering sequence diagrams.
another study failed to find much use of detailed large scale maps of code hung on walls near d e v e l o p e r s o f f i c e s .
designed to be useful for all possible tasks these diagrams h a d both too much and too little information developers r e q u i r e d many details but only those that were task relevant.
the authors conclude that diagrams providing concise and targeted answers to situation relevant questions were more likely to be useful t h a n general purpose diagrams.
another study observed several stu dents using a uml sequence diagram tool in the lab .
participants specifically requested the ability to rapidly configure the diagram to filter or search for items and to easily hide items that were determined to be uninteresting.
overall these studies suggest that developers could benefit greatly from diagrams that are more focused on task relevant items but the studies provide little guidance on what developers find task relevant.
only a few studies have attempted to measure the time developers spend on development activities.
in one study developers were observed for an hour each.
they m o s t frequently executed unix commands followed by reading the source loading or running software and reading or editing notes.
in a later study developers at microsoft when s u r v e y e d a b o u t t h e i r u s e o f t i me reported spending nearly equal amounts of time communicating understanding writing new code editing old code and on non code related activities .
developers reported spending some what less time designing testing and on other activities.
a de tailed study of students at work on a lab task found o f time spent reading code editing code navigating de pendencies searching and testing .
thus developers are spending significant time trying to understand code.
.
definitions from preliminary analysis of related work and results from our studies it seemed clear that developers ask a class of questions that had not previously been explicitly characterized reachabil ity questions.
but exactly which questions do these include?
while we had many examples often in developers own words a formalism would unambiguously show how each was a reachabil ity question and highlight relationships between similar questions.
so we used our examples to design a formalism for reachability questions which we describe here.
although we developed it chronologically after the studies we present it first in this paper to use it to describe the questions we observed see tables and .
.
reachability questions intuitively a reachability question is a search across feasible paths through a program for target statements matching search criteria.
thus a reachability question consists of two parts the paths to search and the search criteria specifying the statements to find.
reachability questions represent feasible paths as a set of concrete traces tr.
a concrete trace tr is a list of s env tuples where s is a statement and env m a p s e v e r y v a r i a b l e i n s t o a v a l u e .
traces p o d c is the set of all concrete traces in a program p from an origin statement o in the set o to a destination statement d in the set d which satisfy all the filtering constraints c in c. o d and c can be left unspecified by using a ?
although at least one of o or a d must be specified .
questions without an origin are called upstream reachability questions while questions with an origin and optionally a destination are downstream reachability questions.
c is a set of filtering constraints c where c is a tuple s x const specifying a value for a variable x in s. x and const can be left unspecified ?
to find only the traces containing s. there are two types of reachability questions find and compare.
find sc in tr finds the portion of each tr in the set of traces tr that match s e a r c h c r i t e r i a sc.
a s e a r c h c r i t e r i a f u n c t i o n g i v e n attributes describing a set of statements generates a set of state ments sc.
table lists search criteria functions we observed in our studies.
a reachability question then matches sc against each s env tuple in a trace tr to generate new traces containing only the formalism was designed with the assistance of jonathan aldrich.
tuples where s is in sc.
compare tra trb trcommon tr1 tr2 compares sets of traces.
compare first by an unspecified method attempts to match each tra in tra to a corresponding trace trb in trb.
when such a match is found compare then attempts to match tuples sa enva in tra to corresponding tuples sb envb in trb.
this generates three new lists trcommon which contains an ordered list of tuples that matched and tr1 and tr2 which contain an ordered list of tuples in tra and trb that did not match.
tr1 and tr2 also contain traces in tra and trb for which no match could be found.
.
comparison to slicing many tools h a v e b e e n d e s i g n e d t o h e l p d e v e l o p e r s e x p l o r e p ro grams by finding sets of statements.
one technique used by many tools is slicing .
slicers find statements connected by either data dependencies or control dependencies.
data de pendency ddepend s1 x finds the set of statements s where each s2 i n s may have last defined a variable x used in s1.
a control dependency exists from s1 to s2 if s2 controls if s1 does or does not execute.
cdepend s1 finds all such control dependencies of s1.
a backward static slice is simply the transitive closure of the union of these two relations ddepend s1 x cdepend s1 .
in a highly influential study weiser found that developers de bugging better remembered a static slice related to the bug than either a n u n r e l a t e d s l i c e o r a n a r b i t r a r y p o r t i o n of the program.
this suggested that developers follow slices when using the strat egy of debugging backwards from an error to a bug.
building on this work many variations on slicing have been pro posed .
a forward s l i c e f i n d s c o n t r o l a n d d a t a dependencies forwards rather than backwards fddepend s1 x fcdepend s .
a dynamic slice finds control and data dependen cies in a particular execution.
like reachability questions with a filtering constraint conditioned static slices f i n d d e p e n d e n c i e s across paths w h i c h s a t i s f y a c o n s t r a i n t .
a thin slice f i n d s d a t a dependencies ddepend s1 x while excluding data dependencies at pointer dereferences .
a chop intersects statements in a forwards slice on x at s1 with a backwards slice on y at s2 fdde pend s1 x fcdepend s1 ddepend s2 y cdepend s2 .
the central idea of all slicing techniques applied to code explora tion is to use control and data dependencies t o f i n d s t a t e m e n t s answering a developer s question.
reachability questions differ from slicing in many ways.
first by searching over the set of all concrete traces reachability questions exclude infeasible paths.
static slicing techniques are typically defined as a may a n a l y s i s w h e r e s t a t e m e n t s m a y b e dependent only through infeasible paths that never execute.
however much of the work done on improved slicing has focused on eliminating infeasible paths by for example introducing context sensitivity .
t h u s t h e d i f f e r e n c e i s o n l y t h a t a r e a c h a b i l i t y q u e s t i o n specifies a fully precise answer whereas slices specify answers of any precision.
a second difference is that r e a c h a b i l i t y q u e s t i o n s find portions of traces where statements can occur multiple times while static slicers often find a subset of the program where statements occur exactly once.
dynamic slicers search over traces but only a single trace rather than the set of all traces.
an important difference between reachability questions and slic ing is that a reachability question is a search across control flow paths rather than dependencies.
by design the set of statements in a s l i c e w i l l a l w a y s b e a s u b s e t o f t h e s t a tements across control flow paths statements that are not dependent are n o t included.
slices correspond to questions about influence why did this execute?
control dependency or where did this value come from?
data dependency .
in contrast control flow captures ques tions about what happens before what are the situations in which?
or after what does this do?
.
when developers ask a question a b o u t c o n t r o l f l o w t h e s l i c e ma y n o t i n c l u d e t h e s t a te ments answering their question.
and while our reachability ques tion formalism includes searches for data dependencies we ob served only example of such a question out of the important reachability questions we found tables and .
the most important difference between slicing and reachability questions i s t h a t a reachability question is a search for a set of statements described by any of a wide variety of search criteria.
consider an example from study a developer wondered why calling a method m is necessary.
the reachability question find ends in traces jedit mstart mend ?
identifies a few statements at a call depth of or less from mstart w h i l e a s t a t i c s l i c e f r o m mstart finds all of the statements in hundreds of methods.
because the first line of m conditionally throws an exception depending on the input to m everything afterwards is control dependent on the input to m. if this were not the case the static slice still would not help locate ends a n d m i g h t n o t e v e n i n c l u d e t h e s e s t a t e m e n t s i f they do not happen to be control or data dependent.
even the searches supported by chopping are different in chopping both the origin and target statement are supplied by the user.
thus the user must already know the statements in ends when they ask a chop question.
.
study lab observations in a previous study we observed developers at work on two .
hour long changes to an unfamiliar codebase.
we reported that experienced developers used their more extensive knowledge to diagnose the problem and formulate a fix addressing the under lying cause of the design problem rather than simply its symptoms .
here we reanalyzed this study s data and report several new findings.
despite spending almost the entire task asking questions and investigating code developers frequently incorrectly under function finds the set of statements that grep str include text matching the string str reads f writes f read write a field f in the set of fields f. fields is the set of all fields in the program.
stmts t are in a type t in the set of types t stmts m are in a method m in the set of methods m callers m are callsites of a method m in the set of meth ods m callees m are method declaration statements of methods invoked by a method m in the set of methods m ends are method calls to framework methods with out source or method declaration statements with no callers which may be callbacks ddepend s x x i n s has a data dependency on.
ddepend s x finds the transitive closure including tran sitive data dependencies.
table .
search criteria functions describing statements for which developers searched see tables and .
stood facts about the code.
acting on these false facts developers implemented buggy changes which in some cases they later real ized were mistaken and abandoned.
when developers inserted defects we analyzed questions developers asked and actions they took to look for specific information they incorrectly understood.
in other cases developers spent tens of minutes employing tedi ous strategies.
we report several of these strategies and questions they attempted to answer.
.
method we review the most important aspects of the method here.
addi tional details can be found in .
participants were provided with the eclipse .
.
ide and were allowed to use any eclipse feature and take notes with windows notepad or on paper.
par ticipants worked on two code change tasks for .
hours per task.
both tasks were changes to jedit an open source text editor that is non comment non blank lines of java.
b o t h t a s k s w e r e designed to be challenging and require understanding the design of the code rather than just locating features or reusing an api.
to achieve these goals we designed both tasks to require fixing de sign problems.
we searched the current version of the application for hack c o m m e n t s a n d selected two problems.
both tasks involved editing code that controlled when updates happened and involved reasoning about related functionality scattered across the codebase.
participants found the tasks to be highly challenging one participant described them as typical of a bad day .
we conducted two new analyses of this data.
first we identified edits to the code and clustered these into changes.
we labeled each change as to if it had been implemented if it was later aban doned and if it contained a bug.
for changes containing a bug we then looked to see if the developer had either asked a question or had otherwise made an assumption.
we then attempted to deter mine if the question or assumption could be addressed by a reach ability question.
in a second analysis we looked for examples of time consuming questions that developers spent ten or more min utes answering.
.
results developers implemented an average of .
changes per task.
de velopers abandoned changes when they learned their changes could never work found a bug they could not fix or decided they did not have sufficient time to finish the change.
developers abandoned an average of .
changes per task two thirds of which contained bugs.
developers abandoned changes that did not con tain a bug either because they no longer thought the change was a good design or did not think they had time to finish it.
overall developers spent over two thirds of their time investigating code e i t h e r t e s t i n g o r d o i n g d y n a m i c i n v e stigation using the debugger or reading statically following call relationships or using other source browsing tools .
they spent the re mainder of their time editing consulting or creating other artifacts task description notes in notepad diagrams o r reasoning without interacting with any artifacts .
.
.
causes of defective changes half of all changes developers implemented contained a bug.
in half of these defective changes changes we were able to relate the bug to a reachability question either in a false assumption that developers made or a question they explicitly asked .
table lists the false assumptions or questions that were related to reachability questions and the corresponding reachability ques tion.
developers often made incorrect assumptions about up stream or downstream behaviors as they reasoned about the impli false assumption or question related to a bug correct answer related reachability question dist notes method m is fast enough that it does not matter that it is called more frequently.
this method sends an event which triggers a hidden call to an extremely expensive library function.
find ends in traces jedit mstart mend ?
finds calls to downstream library functions in m why is calling m necessary?
m determines if the screen needs to be repainted and triggers it if necessary.
find ends in traces jedit mstart mend ?
finds calls to library functions including one that triggers screen repainting from what callers can the guards protecting statement d in method m be true?
more than one caller can reach d. find callers m in traces jedit ?
d ?
finds callers reaching d method m need not invoke method n as it is only called in a situation in which n is already called.
bugs method m is called in sev eral additional situations.
find callers m in traces jedit ?
m ?
finds callers reaching m the scroll handler a does not need to notify b because b is unrelated to scrolling.
method b updates the screen to reflect updated scroll data signaled by a. find grep scroll in traces jedit astart aend ?
finds statements in b that reads scroll data updated when a occurs removing this call in m does not influence behavior down stream.
m no longer clears a flag disabling functionality downstream compare traces jeditold mstart ?
?
traces jeditnew mstart ?
?
finds differences in behavior resulting from the change in cluding downstream functional ity that is no longer invoked.
what situations currently trigger this screen update in m?
a variety of user input events eventually cause m to be invoked find ends in traces jedit ?
m ?
finds upstream methods with no callers including user input event handlers called only by the framework.
table .
questions developers failed to answer or false assumptions developers made in study that are associated with an implemented change containing a defect and are associated with a reachability question.
for each reachability question dist is the shortest call graph distance between the origin statement developers investigated and any statement found by the reachability question.
cations of removing calls currently present in the code.
these assumptions took different forms depending on the change they considered.
upstream often occurred when developers asked or assumed that behavior was redundant and unnecessary because it would always be called somewhere else.
in these cases the call graph distance from the origin statement they were investigating to target behavior was often small mean .
.
these questions were challenging to reason about because it was difficult to de termine which calls were feasible.
in contrast downstream often occurred when developers made false assumptions about how a method mutated data or invoked library calls.
here the relevant effect was further away mean .
calls and developers had no reason to believe that traversing the path to the target would chal lenge their assumption.
.
.
tedious and time consuming strategies in addition to the bugs that arose from assumptions developers made when they should have a s k e d reachability questions there were many cases where the developers did ask reachability ques tions and formulated a strategy to answer them.
developers spent much of the task investigating code by traversing calls in an at tempt to understand what methods did and the situations in which they were invoked.
most participants rapidly switched between a call graph view static and the debugger call stack dynamic .
static investigation allowed developers to navigate to any caller or callee at will.
but as developers traversed longer paths of calls developers were likely to hit infeasible paths.
several guessed incorrectly about which paths were feasible.
dynamic investiga tion was more time consuming to begin developers set break points invoked application behavior and stepped through break point hits until the correct one was reached.
at task start most investigation was relatively unfocused developers attempted to make sense of what the methods did and the situations in which they were called.
as the tasks progressed and developers began to propose changes the questions grew increasingly focused a n d developers sought to navigate to specific points in code.
developers differed greatly in the effectiveness and sophistication of the strategies they employed.
particularly challenging for many participants was upstream navigation.
two participants did not realize they could search the call stack to find an upstream method and instead spent much time mins mins locating the method by using string searches and browsing files.
three partici pants spent ten or more minutes and mins using a particularly tedious strategy to navigate upstream from a method m across only feasible paths adding a breakpoint to each of m s callers running t h e a p p l i c a t i o n executing functionality noting which callers executed and recursing on these callers.
many par ticipants used eclipse s call graph exploration tool to traverse calls but both traversed infeasible paths and experienced prob lems determining which calls led to their search targets figure .
the three most experienced participants instead invoked function ality and copied the entire call stack into a text editor.
but even these experienced participants experienced problems reasoning about reachability relationships.
three of the defects inserted associated with reachability questions were inserted by these par ticipants.
.
discussion despite spending much of the task investigating code developers were often unsuccessful in correctly understanding what it did.
developers made many false assumptions about relationships between behaviors that in some cases led to defects.
developers tools were ill suited for answering reachability questions often forcing them to use tedious and time consuming strategies to an swer specific well defined questions.
and had developers been able to more easily check their erroneous assumptions that led to defects their changes might have been more accurate.
while these results suggest that reasoning about reachability rela tionships is important for developers understanding unfamiliar poorly designed c o d e t h e s e r e s u l t s m i g h t n o t b e g e n e r a l i z a b l e .
while we expect developers do work with such code in the field it is unclear how typical such a task is.
while the carefully con trolled setting of a lab study allowed us to evaluate the success and accuracy to a degree impossible in the field lab studies are never able to perfectly replicate conditions in the field.
under standing real code in more typical tasks might involve fewer and less challenging reachability questions.
developers working in the same codebase over a period of time might be able to use their knowledge to directly answer reachability questions as studies suggest developers learn facts including callers and callees of methods with increasing experience .
developers had limited time in which to work which likely led them to rush changes with less investigation than they might otherwise have done.
and sev eral developers did not seem to have had much experience under standing large complex codebases.
are reachability questions frequent and challenging for developers at work in the field?
.
study survey in order to understand the frequency and difficulty of reachability questions in the field we conducted a survey of developers in which they rated questions for difficulty and frequency.
.
method we randomly sampled participants from among all employ ees at microsoft s redmond campus listed as a developer in the address book.
each was sent an email inviting them to participate figure .
developers using eclipse s call graph exploration tool to traverse callers found it difficult both to identify feasi ble paths and those leading to their target.
these methods are shaded but the actual target is several levels further away behind several methods with high branching factors.
in our survey.
we received responses from developers and excluded additional responses from non developer positions.
respondents included architects lead developers and developers.
most worked in a single or shared office while a small number worked in an open shared space.
respondents ranged in professional software development experience from the very inexperienced years to the very experienced years with a median of years experience.
respondents f r e q u e n t l y changed codebases ranging in time spent in their current code base from to .
years but with a median of only year.
nev ertheless agreed that they were very familiar with their current codebase.
developers teams were involved in a wide range of activities bug fixing implementation planning and other.
developers reported that they typically spent of their work t i m e e d i t i n g u n d e r s t a n d i n g o r d e b ug ging code with a range from to .
in the main portion of the survey developers were asked to rate the frequency and difficulty of questions.
these questions were selected from a previous study of questions that developers ask about code and questions identified in our first study.
some of these were closely related to reachability questions in what situations is this method called?
while others were more indi rectly related what are the implications of this change?
.
how ever we observed many of the indirectly related questions being refined into reachability question in our lab study.
so we hypothesized that developers often answer these questions by asking reachability questions.
we piloted the survey with graduate students and developer to ensure that the meaning of the questions was clear and we iter ated the wording based on the feedback.
for each question re spondents were asked to rate how often in the past days of pro gramming they had asked the question and to rate its difficulty on a point scale from very hard to very easy.
participants did not answer all questions.
when a participant did not answer the ques tions necessary for a particular comparison that participant was dropped from that c o m p a r i s o n .
t o analyze t h e d a t a w e l o o k e d both at simple descriptive statistics and correlations between rat ings and demographic variables.
w e r e p ort these results using r the p e a r s o n p r o d u c t moment c o r r e l a t i o n coefficient and p a statistical significance measure smaller is more significant .
.
results on average developers reported asking more than of these questions every day.
these questions were often hard to answer.
of the questions that the developers rated developers rated an average of .
questions at least somewhat hard to answer and .
as hard or very hard to answer.
few developers thought all these questions were easy to answer of respondents rated at least question at least somewhat hard to answer and rated at least question as very hard to answer.
surprisingly developers do not ask these questions significantly less frequently and they are not significantly easier to answer as they become more experienced r .
p .
r .
p .
or after spending more time in a codebase r .
p .
r .
p .
.
nor does the quality of the codebase significantly affect the frequency of these ques tions r .
p .
.
while it is harder to answer these ques tions on lower quality code r .
p .
it is not possible to say if this is unique to these questions or simply that all ques tions become harder to answer in poorly maintained code.
figure plots the questions frequency against difficulty.
interest ingly difficulty was positively related to frequency r .
p .
.
both the most frequent and hardest to answer question was what are the implications of this change?
generally the most frequent and difficult questions were the most high level.
for example half of respondents reported asking what are the impli cations of this change?
at least twice a day and of respon dents rated it at least somewhat difficult to answer.
of course some questions are much more frequent and difficult than others.
over of developers thought answering what are the impli cations of this change?
was usually at least somewhat hard to answer while this was true of only of respondents for how are instances of these classes or data structures created and as sembled?
.
discussion our results revealed that developers frequently ask questions that they might refine into reachability questions that these questions are often difficult to answer and that experience does not remove figure .
frequency vs. difficulty for reachability related questions sorted by decreasing difficulty.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
.
.
.
.
.
what are the implications of this change?
e.g.
what might break .
how does application behavior vary in these different situations that might occur?
.
could this method call potentially be slow in some situation i need to consider?
.
to move this functionality e.g.
lines of code methods files to here what else needs to be moved?
.
is this method call now redundant or unnecessary in this situation?
.
across this path of calls or set of classes where should functionality for this case be inserted?
.
when investigating some application feature or functionality howis it implemented?
.
in what situations is this method called?
.
what is the correct way to use or access this data structure?
.
how is control getting from that method to this method?
.
what parts of this data structure are accessed in this code?
.
how are instances of these classes or data structurescreated and assembled?frequency developers difficulty developers who rated question at least somewhat hard to answer the need to ask these questions.
these results suggest that answer ing these q u e s t i o n s i s a n i m p o r t a n t p a r t o f h o w a l l d e v e l o p e r s understand code whether they are new to a codebase or know it well and whether the codebase is poorly d e s i g n e d o r w e l l de signed.
these findings are still limited in that all survey respon dents were taken from a single company.
but respondents differed greatly by the products on which they worked by experience with the codebase by overall professional experience and by software project phase.
these results demonstrate that techniques that help developers more effectively answer these questions are important.
however the results do not establish that developers answer these questions by asking reachability questions.
do developers fre quently ask reachability questions and are they time consuming to answer?
what do examples of reachability questions in the field look like?
.
study field observations in order to better understand the situations in which developers ask reachability questions and the strategies they use to answer them we observed developers at work on their everyday cod ing tasks.
.
method we recruited developers at microsoft from respondents to study to participate in observation sessions.
all sessions were conducted with a single observer and a s i n g l e d e v e l o p e r i n t h e developer s office.
developers used a variety of programming languages c c javascript editors and debuggers.
after briefly introducing the observer and reviewing the purpose of our study participants were asked to work on a coding task in their codebase for the remainder of the approximately minute ses sions.
three participants finished their first task and chose a sec ond task.
when selecting tasks participants were encouraged to choose a task involving unfamiliar code minimally defined as code they had not written themselves.
while only of the tasks that developers chose were tasks they planned to do at the time of our session all but one of the tasks they chose were on their lists of tasks to do.
the remaining task was a bug previ ously assigned to another team member.
the work we observed was not biased towards the beginning or the end of tasks of the tasks were tasks the developer had previously begun and de velopers completed of their tasks.
all but one developer stopped working after they had completed testing their fix and before having their teammates code review the change.
we asked participants to think aloud as they worked.
when deeply engrossed in the tasks participants occasionally forgot to talk and we prompted them to resume by asking what they were trying to do or having them confirm or reject a statement about what they appeared to be to record the sessions we re corded audio and took notes.
two of the recordings were lost due to equipment failure leaving participants.
from the recordings and observer notes we produced time stamped annotated tran scripts of the sessions spanning pages.
to analyze the data we first reviewed the transcripts and qualita tively summarized what developers were next we itera tively designed a coding scheme for describing developers activi ties.
we coded of the sessions one session did not include any implementation task.
each session was coded for activity at one minute time granularity.
participants occasionally retrospec tively described particularly memorable past tasks or talked about how they approached tasks in general which we did not include in the activity list but mention in the discussion section.
developers were interrupted by replying to task unrelated emails by team mates dropping by or discussions with the interviewer.
all task irrelevant activity was coded as an interruption and excluded from the analysis of time use.
due to equipment failure w e l o s t minutes of the recordings out of a total of minutes of task related activity.
in most cases developers stopped working on their tasks once they had completed its implementation.
but one developer reached the end of his task and conducted a code re view.
so we do not include code reviews in our activity times.
.
results developers spent a majority of their time understanding code by debugging or p r o p o s i n g c h a n g e s a n d investigating their implications .
of the longest debugging and implication investigations were associated with a reachability question.
.
.
activities figure d e p i c t s the sequence of activities we observed a n d t h e time developers spent on each.
when working on a bug they did not already understand developers first sought to reproduce t h e problem by following steps in the bug to confirm that the bug had not already been fixed ensure that a fix could be tested and pro vide a w a y t o b e g i n u s i n g t h e d e b u g g e r .
d e v e l o p e r s f a c e d w i t h incorrect application behavior either from the original bug or introduced by their fix debugged to assign blame to specific pro gram points exhibiting incorrect behavior.
after determining the cause of a bug or when beginning a feature implementation task developers began to propose fixes to solve the problem and inves tigated t h e implications o f t h e p r o p o s a l s o n p r o g r a m b e h a v i o r .
developers then edited the code to implement the change.
when editing developers sometimes reused e x i s t i n g f u n c t i o n a l i t y a n d sought to learn its name and how to correctly reuse it.
developers compiled and built the application sometimes producing compile errors they debugged.
finally developers tested t h e i r c h a n g e s often revealing defects they debugged.
.
.
time consuming activities while debugging and investigating code developers frequently asked reachability questions.
in order to examine the relationship of these activities to reachability questions we looked for reach ability questions in the longest debugging and longest investi gation activities.
e a c h o f t h e s e a c t i v i t i e s h a d a c e n t r a l primary question developers tried to answer throughout the activity.
sur prisingly the primary question in out of of these activities figure .
developers activities circles with of activity time and transitions between activities lines with of transitions from activitiy .
transitions from an activity are in the activ ity s color and left to right transitions are above right to left.
reproducedebuginvestigatetest6 editreusecompile50 was a reachability question.
at the beginning of these activities developers rapidly formulated a specific question expressing search criteria describing statements they wished to located.
for example to debug a deadl ock a developer began at a st at ement and began traversing callees in search of statements acquiring resources.
minutes later this finally revealed the sequence of behaviors causing the deadlock.
when answering r e a c h a b i l i t y q u e s t i o n s developers explored the code either dynamically using the debugger and logging tools or statically using source browsing tools.
interestingly developers did not primarily use t h e d e b u g g e r t o d e b u g a n d c o d e b r o w s i n g tools to investigate implications.
instead like the lab study par ticipants developers often made use of both tools as they sought to answer multiple l o w e r level questions or tried alternative strategies for answering their primary question.
developers con stantly dealt with uncertainty during their tasks both from generat ing and testing hypotheses and wondering about the correctness of results produced by their tools.
an example from the longest debugging activity helps illustrate several of these points.
observing an error message in a running application one developer spent minutes locating the cause of the error message in the code.
using knowledge of the codebase he rapidly located t h e c o d e implementing the command h e had invoked in the application.
but it was not obvious where it trig gered the error.
hoping to get lucky he did a string search for the error message but found no matches.
unsure why he did not find any matches he next began statically traversing calls from the command method in search of the error.
but he rapidly deter mined he was unsure which path would be followed when the command was invoked.
switching to the debugger he stepped through the code until learning his project was misconfigured and creating spurious results both in his debugger and code searches.
after resetting his project configuration he again did a string search f o r t h e e r r o r s t r i n g a n d f o u n d a m a t c h .
h o w e v e r m a n y callers called the method any one of which might be causing his error.
so he returned to stepping in the debugger.
finally locating code that seemed relevant he quickly browsed through the code statically.
finally he returned to the debugger to inspect the val ues of some variables.
.
discussion in the third study developers spent over half of their time debug ging or reasoning about the implications of their changes.
in of the most time consuming activities the developer s primary question was a reachability question.
developers were at a point in code and had specific search criteria describing the statements they wished to find.
but finding these statements was hard and time consuming as developers searched through large amounts of task irrelevant code.
in contrast to results from study the ques tions in study were all questions developers explicitly asked.
like all studies these findings may have been influenced by the practices and tools that developers used that might differ in other organizations.
in organizations with more extensive documenta tion or commenting processes developers might rely on these more than the code itself.
developers did not have access to so phisticated uml reverse engineering tools.
none of our develop ers had unit tests extensive enough to rely on to test the correct ness of their changes.
extensive unit tests might lead to more implementation of speculative changes followed by testing rather than extensive investigation prior to changes.
.
general discussion we found that reachability questions are frequent often hard to answer associated with false assumptions that lead to bugs and asked by developers in many of the most time consuming debug developer s primary question debugging activities time min reachability question notes where is method m generating an error?
find grep errortext in traces p mstart mend ?
finds the statement downstream from m outputting error text what resources are being acquired to cause this deadlock?
find acquire methods in traces p o d ?
finds calls to methods acquiring resources including those leading to the deadlock.
when they have this attribute they must use it somewhere to generate the content so where is it?
find reads attribute in traces p o d ?
finds downstream uses of attribute includ ing those generating the content.
what the test which is different from what my app is compare traces ptest o d ?
traces papp o d ?
finds differences in behavior between the test program and app program how are these thread pools interacting?
find methods t in traces p o d ?
finds any calls into methods in thread pool types t. developer s primary question investigation activities time min reachability question notes how is data structure struct being mutated in this code between o and d ?
find writes struct in traces p o d ?
finds all downstream statements mutating struct where the code assuming that the tables are already there?
compare traces p o d tablesloaded traces p o d tablesnotloaded finds different behaviors the code exhibits when tables are not loaded how application state change when m is called denoting startup completion?
find writes fields in traces p mstart mend ?
finds state changes caused by m is another reason why status could be non zero?
find ddepend status in traces p ?
d ?
finds upstream statements through which values flow into status including those creat ing its values table 3a top and 3b bottom .
the of the longest debugging activities and the of the longest investigation activities associ ated with a reachability question.
for each activity the developer s primary question during the activity the length of the activity and the related reachability question.
ging and investigation tasks.
several developers in the lab study became so overwhelmed investigating code that they gave up.
developers at work on actual tasks in the field often spent tens of minutes answering single reachability questions when debugging or investigating the implications of their changes.
in all of these cases developers asked questions and explored the code to search for statements answering their q u e s t i o n s .
linking many of the diverse problems developers commonly experience understanding large complex codebases to reachability questions helps better explain the strategies developers use to understand code and the factors influencing their success or failure.
.
strategies for answering reachability questions developers may choose from among several classes of strategies for answering questions reasoning using facts they already know communicating with teammates or dynamically or statically ex ploring code.
for code that developers know well developers may already know the answer .
but this level of understanding is difficult to achieve due both to the number of reachability rela tionships present in a codebase and because they often change as developers edit the code.
one field study participant spent several minutes investigating code he had written himself a little over a year earlier because he was not certain of several important details unique to his task and he was concerned others might have edited the code.
conversely even developers new to a codebase are able to generate hypotheses about reachability relationships by inter preting identifiers and using their knowledge about how they ex pect an application to work.
study participants assumed that an editbus was connected to edit events.
but when developers wished to test these hypotheses they used other strategies.
developers communicate with their teammates both directly through face to face communication instant message or email and indirectly through documentation and comments.
where they exist documentation diagrams such as uml sequence diagrams could help answer some reachability questions provided they an ticipate t h e c o r r e c t q u e s t i o n. but nearly all of the questions we observed were highly specific to the developers task m a k i n g i t unlikely for that such a diagram would exist.
developers occa sionally made use of direct communication often instant messag ing teammates they thought might know all or part of an answer.
but teammates often were not available to immediately respond.
moreover for longer face to face interruptions developers are sometimes expected to have already done due di l i gence t o get a general understanding before asking a lengthy question of a busy and more knowledgeable teammate .
of course teammates also eventually leave the team may be otherwise unavailable might have forgotten the answer or might never have known the answer at all.
thus developers often answered reachability questions by explor ing the code.
in dynamic exploration developers run the program and observe its output either directly or through tools such as a breakpoint debugger logging statements or logging tools.
in some cases generating the trace to be dynamically investigated was difficult or impossible because special hardware was re quired it took a long time for the application to run and generate the trace or it was unclear what application input was necessary to generate the trace.
a developer in study working with a web application added logging statements before waiting a day for it to execute a l e n g t hy b a t c h j o b. moreover some reachability ques tions forced consideration of all possible traces.
developers some times randomly invoked application behavior in an attempt to generate desired traces.
when possible there were several advan tages of dynamic exploration.
developers could inspect state and even mutate state to select the trace being followed.
breakpoints allowed developers to search for paths to a statement.
but setting breakpoints was impractical when searching for many statements e.g.
any method in a type or when developers did not know the statements for which they were searching e.g.
all statements related to scrolling .
some of the problems we observed in the lab study could be at tributed to a lack of knowledge of effective dynamic investigation strategies.
developers exploring upstream by iteratively setting breakpoints c o u l d h a v e i n s t e a d m u c h m o r e e f f e c t i v e l y i n s p e c t e d call stacks.
however developers devising and choosing strategies must simultaneously hypothesize answers to their questions keep track of the question they are answering and information they have found and deal with frequent interruptions from teammates .
in these situations developers may not have time to reflect at length on their strategies.
however better educating developers about the types of questions they ask and the strategies they could use to answer them might help them devise more effective code exploration strategies.
.
challenges statically exploring code in static exploration developers navigate the code by using source browsing tools such as a call graph exploration tool or textual searches f o r n a m e s. in contrast to dynamic exploration static exploration does not require running the program.
call graph tools such as the eclipse call hierarchy allow developers to fol low chains of calls through the source.
however we observed many cases where these chains contained infeasible paths that could never execute.
infeasible paths are caused by correlated conditionals where the branch taken at a consumer conditional is correlated to one of several producers controlled by the path by which the consumer was reached.
through our direct observations and retospective accounts from our participants w e d i s c o v e r e d several idioms t h a t c r e a t e d c o r r e l a t e d c o n d i t i o n a l s w i t h w i d e l y separated producers and consumers that were particularly difficult to statically explore.
in an event b u s a r c h i t e c t u r e m e s s a g e s a r e created by a producer sent over a bus and subscribed to by con sumers.
in com a pointer is initialized to a particular implemen tation of an interface producer and passed to call sites invoking methods on the interface consumer .
in frameworks clients often register t h e i r i m p l e m e n t a t i o n s o f f r a m e w o r k i n t e r f a c e s w i t h t h e framework producer which then uses dynamic dispatch con sumer to transfer control back.
in a property system values refer ring to properties are created producer and used to access prop erty getters or setters which look up the property consumer .
several but not all of these idioms often produce high branching factors in the control flow graph.
a common interface e.g.
irun nable in java may have many implementations creating a large branching factor at dynamic dispatch.
in an event bus many methods call the bus send method and many bus receive methods are called by the bus creating two high branching factors.
for the developer the effect of correlated conditionals is to create many possible edges to traverse forcing the developer to guess which are feasible or attempt to manually simulate control flow by propagating data over control flow paths.
we observed that per forming path simulation manually was nearly impossible for statements with high branching factors as there were simply too many paths to consider.
.
recommendations for tools we found that developers often had specific search c r i t e r i a describing statements they wished to find.
however most existing tools force developers to guess where these statements might be located when they traverse calls statically or dynamically.
re cently a few tools have begun to support searching.
in dora a developer specifies an origin method and a string search criteria and dora scores methods connected by a call graph path by their relevancy to the search string.
however dora does not eliminate infeasible paths and supports only searches described by string grep str i n o u r f o r m a l i s m not attributes of target statements.
the oasis sequence explorer depicts a trace in a uml se quence diagram and allows developers to use a regular expression to search for method names.
our findings suggest improved tools could greatly improve developer productivity by supporting searches across feasible paths for statements matching a wider variety of search criteria.
.
conclusions modern development environments provide developers with a debugger and source browsing tools for exploring code.
but we found that these tools only indirectly answer many of the ques tions developers ask or should have asked.
better educating de velopers about reachability questions might help developers learn share and choose more effective strategies for answering reach ability questions.
but our results also s u g g e s t t h a t d e v e l o p e r s could perform coding tasks more quickly and accurately with tools that more directly support answering reachability questions.
.