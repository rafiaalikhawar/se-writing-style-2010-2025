see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation variability points and design pattern usage in architectu ral tactics conf erence paper no vember .
.
citations 21reads author s mehdi mir akhorli association f or computing machiner y publica tions citations see profile patrick m der technische univ ersit t ilmenau publica tions citations see profile jane cleland huang dep aul univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y patrick m der on no vember .
the user has r equest ed enhanc ement of the do wnlo aded file.variability points and design pattern usage in architectural tactics mehdi mirakhorli depaul university chicago il usa m.mirakhorli acm.orgpatrick m der johannes kepler university linz austria patrick.maeder jku.atjane cleland huang depaul university chicago il usa jhuang cs.depaul.edu abstract architectural tactics are important building blocks of software architecture.
tactics come in many shapes and sizes describe solutions for addressing specific quality concerns andareprevalentacrosshigh performancefault tolerantsystems.
once a decision is made to utilize a tactic the developer must generate a concrete plan for realizing the tactic in the design and code.
unfortunately the variability points found in individual tactics can make this a challenging task.
to address this knowledge gap we conducted a study to investigate how design patterns were used to implement various tactics.
data mining techniques were used to identify potential pattern instances within tactic implementations.
our manual analysis of the retrieved data identified a distinct set of variability points for each tactic as well as corresponding design patterns used to address them.
from these observations we construct tactic level decision trees depicting variability points of a tactic and generate a reference model which provides implementation guidance.
categories and subjectdescriptors d. .
object oriented design methods d. .
patterns keywords architecture design patterns tactics .
introduction the architecture of a complex software intensive system is carefullydesignedanddevelopedtosatisfydiverseandsometimes competing concerns related to dependability safety security performance usability and other important qualities .
to satisfy such concerns architects often utilize architectural patterns sometimes referred to as styles and architectural tactics to design an overall solution .
an architectural tactic serves as a building block of software architecture and is used to satisfy a specific quality permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bearthisnoticeandthefullcitation onthefirstpage.
tocopyotherwise to republish topostonserversortoredistributetolists requirespriorspecific permission and or afee.
sigsoft fse november11 cary nc usa copyright2012acm .
..attribute .
architectural tactics come in many different shapes and sizes and describe solutions for a wide range of quality concerns .
they are particularly prevalent across high performance and or fault tolerant software systems.
for example reliability tactics such as redundancy with voting heartbeat and check pointing provide solutions for fault mitigation detection and recovery while performance tactics such as resource pooling andscheduling help optimize response time and latency .
the importance of implementing architectural tactics rigorously and robustly was highlighted by a small study we conducted as a precursor to this work.
we investigated tactic implementations in hadoop and ofbiz and evaluated their degree of stability during the maintenance process.
for each of these projects we retrieved a list of bug fixes from the change logs nov. nov. for hadoop and jan. nov. for ofbiz .
our analysis showed that tactic related classes incurred .
times as many bugs in hadoop and .
times as many bugs in ofbiz as non tactic related classes suggesting that tactic implementations if not developed correctly are likely to contribute towards the well documented problem of architectural degradation .
the work described in this paper focuses on implementing proven solutions for such tactics.
less experienced developers sometimes find this challenging primarily because of the variability points that exist in a tactic and the numerous design decisions that need to be made in order to implement a tactic in a robust and effective way.
figure illustrates this point with two concrete examples of developers posting requests for help to online forums because they did not understand how to implement specific tactics.
we found many examples of such requests.
unlikedesignpatternswhicharedescribedintermsofspecific classes and associations tactics are defined at a higher conceptual level of roles and responsibilities .
developers must understand the nuances of the tactic take into consideration a wide range of project specific factors that serve as forces upon the tactic consider various implementation options and ultimately derive a suitable design solution.
for example the heartbeat tactic is a relatively simple tactic used to monitor the availability of a critical component.
however in a previous study of over open source systems we observed numerous variations in how the tactic could be implemented.
these included i direct communication between the emitter and receiver roles ii use of the observer pattern in which the receiver registered as a listener to the emitter iii the decorator pattern in which 1h ttp stackoverflow.com questions pattern to im plement heartbeat between server and the client figure developers seek help in online forums to imple ment architectural tactics.
the heartbeat functionality was added as a wrapper to a core service and finally iv in numerous proprietary formats that did not follow any specific design pattern.
while a good developer can certainly come up with a functioning implementation it is difficult for any but the most experienced developers to have a complete understandingof all the issues and trade offs that might go into making an informed implementation decision.
this paper reports the results from an extensive study of 36opensourcesystems inwhichweinvestigatedthewaydevelopers used design patterns within the implementation of architectural tactics from now on referred to as tactic pattern overlaps .
our findings show that design patterns are often used to address variability points of a tactic in order to make the tactic more maintainable scalable or reliable or to otherwise increase its quality and robustness.
based on our observations we identify variability points for each tactic highlight the issues that a developer should consider during the tactic implementation process and document the solutionspreviousdevelopershavemade.
eachofthemodels we present was derived from observing and analyzing several uses of design patterns for implementing each of the studied tactics and then selecting a prevalent design option which we judged to best follow the fundamental principles of good design .
based on the identified variability points and proposed designs we offer prescriptive guidelines for helping developers implement architectural patterns.
in the case of thescheduler tactic we also present a combined design which integrates relevant design patterns into a single reference model.the preparatory phase of our work in which we identify examples of design pattern use within tactic implementations utilizes tools we previously developed for tactic detection and design pattern detection .
the new contributionofthispaperisthein depthanalysisofdesignpattern usage in architectural tactics the extrapolation of variability points in each tactic and the resulting decision trees and reference models.
the remainder of this paper is laid out as follows.
section describes the process and techniques that were used to mine open source projects for instances of tactic pattern overlaps.
section describes the analysis and assessment of pattern usage in tactics.
sections to describe our results for three different tactics namely the scheduler resource pooling and heartbeat tactics .
for each of these tactics we identify variability points and implementation solutions in the form of design patterns.
section then describes our approach for merging individual design patterns into a combined tactic specific reference model while section provides an illustrative example showing how the model might be used to help the developer make tactic implementation decisions.
section discusses threats to validity for our study.
section describes related work and finally section summarizes our contributions and outlines our plans for ongoing work.
.
mining tactic implementations findingarepresentativesampleoftactic patterninstances is far from trivial.
we therefore developed a semi automated process for retrieving candidate instances of tactic related classes implemented using the gang of four gof design patterns .
the process involves several steps depicted in figure including building a software repository extracting instances of architectural tactics extracting instances of design patterns computing the overlap between tactics and design patterns to identify tactic pattern instances and finally manually inspecting the results to remove false positives and to clearly delimit the boundaries of each tactic and each identified pattern.
the output from this process provides the raw data needed in the remainder of our study.
.
building a software repository we downloaded open source projects using sourcerer which is an automated crawling application designed to extract projects from publicly available open source repositories such as apache java.net google code and sourceforge.
.
extracting architectural tactics to identify architectural tactics we utilized a previously developed tactic detection algorithm and tool .
the tool had previously been trained to identify five different architectural tactics namely heartbeat scheduler resource pooling authentication and audit trail and in a series of previously reported experiments was able to correctly reject approximately of unrelated code classes depending on tactic type to recall of the tactic related classes in most cases but only in the case of the authentication tactic and to achieve precision at these recall levels of and in the cases of the scheduler and authentication and from to for other tactics.
while this approach does not return entirely precise results it does significantly manual evaluation and assessment tactic extraction project selection open source pr ojects de sign pa ttern detection candidate classes mapped onto tactics pattern detection c andidate pa tterns c andidate ta ctics t actic det ector t actic ri ch projects n ualo verlap analysis id entify variability points and design pattern solutions.
d ecision tr ees tactic reference models x y z figure an overview of our semi automated proce ss for mining open source repositories to retrieve samples of tactic pattern code identifying tacticspecific variability points and generating reference models reduce the search space and assist with the task of retrieving candidate tactic pattern overlap classes.
this imprecision is tolerable because our process includes an evaluation phase in which false positive results are manually eliminated.
for purposes of this paper we trained the classifier to identify the additional tactics of active redundancy check pointing kerbrose loadbalancing pbac pingecho rbac and secure session for a total of tactics.
these tactics were selected because they represent common tactics for fault tolerance performance and security.
the tactic classifier includes the three phases of preparation training and classifying.
due to space constraints we provide only an informal description of each of these phases however a more complete description of the approach including its related formulas is provided in other publications .
during the preparation phase all of the data that is to be used for training and classification purposes is preprocessed according to standard information retrieval methods.
preprocessing steps include splitting source code variable names into primitive parts removing stop words i.e.
unimportant words and stemming words to their root forms.
the resulting terms are then stored for future processing.
thetraining phase takes a set of textual descriptions ofthe tactic as input and produces a set of weighted indicator terms that are considered representative of each tactic type.
for example a term such as priority is found more commonly in code related to the scheduling tactic than in other kinds of code and therefore receives a higher weighting with respect to that tactic.
for training purposes we used ten textbook journal or whitepaper descriptions of each tactic as input to the classifier.
finally during the classification phase the indicator terms learned in the training phase are used to compute the likelihood that a given class is associated with a given tactic.
each class is assigned a score for each tactic and classes scoring over a pre defined threshold in this case .
based on results from our earlier work are labeled as being associated with the relevant tactic.
in this way it is possible for a class to be simultaneously associated with more than one tactic.
given the fact that the study described in later parts of this paper involved manually inspecting each tactic and pattern instance in order to understand how and why the pattern was used in the tactic it was important to reduce the original dataset to a smaller tactic rich set of projects.
the tactic detector was therefore run against all previously downloaded projects.
projects were then ranked according to the number of detected tactics and the top scoring projects were carried forward into the next stage of the analysis.
the final projects are listed in table .
for each project we report its name the number of classes in the system the number of tactic types covered maximum number of candidate design patterns detected maximum and the final count of pattern tactic overlaps as predicted by our automated tools.
as depicted in this table most of the included projects provided coverage of or more tactic types however in order to ensure coverage of all the studied tactics we included a couple of additional projects simply because they included the targeted tactic type even though their overall tactic coverage was low.
.
detecting design patternsin the code pattern detection was performed on the selected projects using an algorithm and tool developed previously by one of the authors .
the approach incorporates a catalog of user customizable pattern definitions supports pattern variationsandalternatives andappliesmultiplesearchtechnologies during the matching process.
the underlying algorithm is based on the concept of a feature type defined as an elementary property of a design pattern likely to recur across different pattern types e.g.
an aggregation relation between two classes or a method return and the instance of the class that contains it .
pattern definitions can be created through composing feature types.
a set of feature types was defined and enabled the detection of all socalled gang of four gof patterns as well as several of their variants.
each of these feature types is assigned to a search technology that allows for its precise but efficient detection.
by combining these feature types into the definition of a pattern search technologies are also combined and contribute to the matching process.
the approach currently uses three different search technologies sql queries to retrieve information from a class model of the analyzed source code regular expressions matching constructs in the class model or the 3table studied projects size identified tactics de tected design patterns and observed overlaps of tactic pattern overar ea name classes types types laps enterprise er p crmapache ofbiz apache tobago compiere erp enterprise jpos neogia nomadpim open subsystem paperdog quickfix frameworks mi ddlewareapache cocoon apache ds jboss luntbuild nomadpim open3ds oracle cac posit vt middleware communic ations etc.arsenal charliebot icemud projectvianet operating sys temsmvctrl tinyos internetarchive crawler sino content man agementapache lenya mdfiction distributed comp utingapache hadoop apache triplesec mobicents parlay ra mx4j openjmx pfc spumoni source code and parser modules performing sophisticated sta tic code analyses for matching a single feature type.
we originally applied this approach in two stages to a set of five benchmark applications with partly known and agreed design pattern detection results.
in stage one pattern definitions were iteratively optimized to the best possible extent and we were able to achieve high recall and precision rates of for the first three systems.
in stage two we used the pattern catalog optimized in stage one without further customization and found that the quality of results decreased.
we reached precision and recall for one system for the last system we had several false and missing recognitions but could not compute recall and precisions due to an insufficient baseline.
to detect patterns in the open source projects we used our existing catalog of pattern definitions .
however the size complexity and scope of the datasets used in this study was far more extensive that that of our previous study and so we discovered design pattern mechanisms not covered by the existing catalog.
as a result we tweaked the performance in order to handle the larger systems updated feature types and pattern definitions in order to make them more efficient and updated the parsers so that they could handle the latest java versions correctly.
we made the decision to report results from the state and the strategy pattern together because their structural representation is hard to differentiate.
we also completely omitted results for the abstract factory and the facade pattern as we felt that additional rules and evaluation were needed to detect thesecorrectly.
as a result our pattern detection algorithm was run for gof design patterns.
results from the projects are reported in table .
column labeled pattern types reports the number of distinct design patterns found in each of the projects.
numbers range from zero meaning that no patterns were detected to meaning that of the possible pattern types were discovered.
.
computingoverlap thetacticclassifieranddesignpatterndetectoralgorithms wererunindependentlyacrosseachoftheselected36projects.
the classes detected by the tactic classifier were compared against those detected by the design pattern detector in order to identify tactic pattern overlaps.
if a pattern and tactic shared at least one class then a candidate overlap was declared.
for example in one case a decorator design pattern added heartbeat functionality to an http service and was identified as a decorator heartbeat instance despite the fact that only a single class overlapped.
thisoverlapanalysisproducedtheresultsreportedinfigure .
these results show the un vetted occurrences of each pattern within each of the tactics following the automated overlap analysis.
the numbers in each cell represent the percentage of times a tactic of the given type overlapped with the specified class.
for example the top left hand cell shows that in of the occurrences of the redundancy tactic there was overlap with a class from the adapter pattern.
similarly the bridgepattern overlapped with the redundancy tactic in of its occurrences.
it is important to remember that these are raw values computed automatically by our tools and therefore not guaranteed to be accurate until they are evaluated in the next phase.
the color scheme of figure shows stronger overlaps in red or orange and lesser ones in paler colors.
it highlights several interesting trends.
certain design patterns are clearly used more prevalently in tactics than others.
for example adapter flyweight memento andstrategy are the four most commonly occurring patterns.
this is not really surprising as these patterns contribute to scalability flexibility and state restoration all of which are important in high performance systems.
unsurprisingly there are no individual tactics that implement a high percentage of patterns.
column in table shows the number of overlapping tactic pattern pairs per project.
these numbers range from zero inprojectsinwhichnodesignpatternsoverlappedwith the identified tactics to in the opensubsystem project.
given the hugesearchspaceof classesin theseopen source systems our automated approach significantly reduces the amount of human effort needed to find tactic pattern overlaps.
nevertheless it is still necessary to manually inspect the results in order to eliminate the incorrectly identified instances.
this process is described in section .
.
assessmentprocess as previously discussed the potential benefits of utilizing architectural tactics are often only fully realized when the tactics are fine tuned to meet project specific needs.
in the following sections of this paper we report on three different tactic types and the design patterns that were used to implement them.
these tactics are scheduling resource pooling and heartbeat.
we do not claim to have identified all possible patterns that could be used to implement these 4adaptor bridge builder chain of resp.
command composite decorator factory method flyweight interpreter iterator mediator memento observer prototype proxy singleton state strategy template visitor ac tive redundancy0.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
audit .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
authenticate .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
checkpointing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
heartbeat .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
kerbrose .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
load balancing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pbac .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
pingecho .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
resource pooling .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
rbac .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
scheduler .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
session .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure overlaps produced automatically and reported prior to human evaluation tactics after all it is likely that a creative developer could figure out a way to incorporate almost any design pattern in any tactic.
however what we do claim is that we have identified many common uses of design patterns in the studied tactics.
we adopted a multi phase process that was designed to identify correct instances of patterns for deeper analysis.
our process involved initially skimming the pattern instance and eliminating obviously incorrect classifications i.e.
the pattern detector claimed a group of classes to be the heartbeat pattern where clearly they were not .
analysis continued until we found three correct uses of the pattern in the tactic ran out of cases to evaluate or searched through tactic pattern instances without finding a correct use of the pattern.
instances that were not initially ruled out were thencheckedmorecarefullytoconfirmthattheyrepresented the claimed pattern and tactic.
as part of this process we evaluated approximately instances and attempted to disperse our efforts equally across the different tactic pattern pairs.
the following steps were then followed .
for each correct tactic pattern instance we evaluated the pattern to answer the question what purpose does this pattern play in the tactic?
.
in cases where the same pattern was implemented for different purposes we studied additional pattern instances until we gained understanding of the multiple contributions the pattern played in the tactic.
.
for each pattern purpose pair in a tactic we constructed a generalized class diagram capturing the classes and their associations needed to implement the design pattern in the context of the tactic.
.
finally we documented specific factors which might trigger a decision to utilize a specific pattern in the tactic.
on average we found that approximately one tactic pattern pair was correct for every five evaluated.
this is expected given the precision of the two underlying tools plusthe additional step of combining results .
the tactic pattern overlaps for which we identified correct uses of both the pattern and tactic are depicted in figure with a bold border.
.
tactic scheduling the first tactic studied was the scheduler .
this tactic is commonly adopted to improve system performance in the face of resource contention.
it is defined in terms of elements to be scheduled the scheduler responsible for scheduling them and a scheduling policy such as fifo first in first out fixed priority or dynamic priority scheduling .
bachman et al.
identify five independent parameters that must be considered when designing and implementing a scheduler.
these include the execution times of units of concurrency arrival distribution number of units of concurrency number of processors and number of processors.
these parameters are used to fine tune the performance of the scheduler in order to satisfy a response measure such as worst case latency however they say nothing about how the scheduler must actually be implemented.
as with all design solutions there are numerous trade offs to consider.
in the case of the scheduler these center around latency scalability and code maintainability.
weidentifiedseveraldesignpatternswhichwereusedquite prevalently to implement the scheduler tactic.
these includedadaptor bridge composite flyweight memento observer proxy andstrategy.
to more fully understand the purpose of these patterns in the tactic we analyzed their implementations following the steps outlined in section .
as a result six primary reasons were identified for adoptingdesignpatternsinschedulerimplementations.
wetermed thesevariability points because in most cases they could be added as additional features to augment the basic behavior of the tactic.
each variability point is described below.
.
many tasks if the scheduler is responsible for scheduling a large number of tasks incurred memory costs may be high and it may be necessary to minimize memory us5c oncretetask initialsettings taskoperation s cheduler schedule t ask taskoperation t askfactory createtask t asks a many tasks flyweightc oncretetask taskoperation interface t ask taskoperation s cheduler schedule t askproxy taskoperation b high resource demand proxy t askfactory state createtaskstate settaskstate t askstate state getstate setstate s cheduler t askstate c stateful tasks mementot askprogressmonitor update t ask notify register c oncretetask notify register p rogressmonitor update d task monitoring observer t askprogressmonitor addmonitor done removemonitor setcancled started p rogressdistributor addmonitor done removemonitor setcancled started p rogressmonitor addmonitor done removemonitor setcancled started e hierarchy of monitors composites cheduler gettaskid schedule interface t ask gettaskid taskoperation c oncretetask gettaskid taskoperation c oncretetask2 gettaskid taskoperation t ask f many task types bridge figure design patterns used to address variability points in the scheduler tactic age.
tasks share intrinsic state such as task priority or task type whilealsoexhibitingindividualpropertiessuchasstart time resources required and so on.
the flyweight pattern reduces the memory resource requirements and also reduces time needed to start a task.
this concept is generalized in figure a .
.
high resource demand when individual tasks have high resource demands e.g.
high memory it is more efficient to create them immediately prior to use and destroy them immediately afterwards.
the proxypattern can be used so that a proxy object serves as a stand in for the task while it waits in the queue.
the scheduler is unaware that the proxy exists.
however the proxy creates invokes and destroys the task as soon as it is scheduled for execution.
this is depicted in figure b .
.
stateful tasks when the state of the task needs to be preserved between scheduled runs the memento pattern is used to preserve state at the end of a run and restoreprevious state at the beginning of the next run.
this is depicted in figure c .
.
task monitoring tasks often need to be monitored to ensure that they are active and progressing.
the observer pattern allows a task progress monitor which could be the scheduler itself to register as an observer of the task and receive status update notifications.
in more complex systems it may be necessary to have hierarchies of monitors.
in this case the composite pattern can be used to compose monitors into hierarchies.
these uses of patterns are depicted in figures d and e respectively.
.
remote tasks theproxypattern can be used to provide a local object as a stand in for a task that is running remotely.
this is not shown in the figure.
.
multiple task types when a scheduler is responsible for managing multiple types of tasks i.e.
maptask reducetask dfstask etc and new types of tasks may be added in the futureand orbehaviorof thosetasksmay changeover 6m any tasks h igh resource demand s tateful tasks t ask mo nitoring s imple mo nitoring c omplex mo nitoring r emote task m ultiple task types s cheduling f lyweight p roxy m emento o bserver c omposite p roxy b ridge a dapter m ulti stepped sc heduling figure decision tree for the scheduler tactic la zy load s ingle point of access c omplex steps r eset before use r esource po oling p rototype s ingleton s trategy f actory method c hain of responsibility m emento n ew resource ty pes likely m ultiple kinds of resources t emplate p rototype o r figure decision tree for resource pooling time then the bridgepattern can be used to create a flexible environment in which both the tasks and their behavior can change independently.
this is depicted in figure f .
when there are multiple types of tasks to be scheduled and different types of tasks involve different steps i.e.
retrieving data checking priorities etc then the adapter pattern can be used to adapt each task with the required steps.
in this case a generic schedule method is invoked for all tasks and this method is then adapted according to task type.
the identified patterns used in the scheduler are modeled as the decision tree shown in figure .
a developer needing to implement the scheduler tactic could use the decision tree to examine the variability points of the tactic with respect to the specific project.
.
tactic resource pooling the second tactic evaluated was resource pooling.
this tactic allows limited resources to be shared between clients if neither exclusive nor continual access is needed to the resource.
pooling is typically used to share threads database connections sockets and other such resources .
based on our analysis of resource pooling implementations we identified several design patterns which were used quite prevalently to implement the tactic.
these included prototype singleton template method strategy factory method chain of responsibility andmemento .
the following variability points were identified.
.
lazy load shared resources are typically created either at start up time or upon demand.
when the cost of creating a resource in the standard way is high the proto w rap around p iggy backing d ifferent monitor types m ass creation h eartbeat d ecorator t emplate c omposite b ridge f lyweight m any mo nitored components h eartbeat mo nitor o bserver s tate m any tasks figure decision tree for heartbeat typ epattern can be used to efficiently create a clone of a prototypical object.
.
single point of access access to a resource pool is managed by a poolerrole.
if many different components need to access the pool there can be significant overhead for establishing and managing a sharing scheme.
the problem can be addressed through using singleton to ensure that there is only one instance of the pooler at runtime.
.
multiple kinds of resources when there are multiple types of resources i.e.
thread pooling connection pooling session pooling and if the types are stable i.e.
it is unlikely that new types will be introduced the template method can be used to customize resource management according to resource type.
when new types are expected to be introduced the factory pattern can be used to create the pools and their associated resources sometimes referred to as ponds while the strategy pattern can be used to select the appropriate factory method according to type.
.
complex steps when the task of creating managing and using a resource pool is complex the chain of responsibility pattern can be used to decouple the sender of a request from its receiver.
for example a series of requests for checking the existence of the pool checking the number of objects or checking the maximum allowed number of objects can be passed as a command along a chain of objects until the request is handled.
.
reset before use a resource pool recycles resources.
before a recycled resource can be reused it needs to be reset to its original state.
use either memento to reset the resource to its original state or prototype to create a new clone before each use.
these variability points and their associated design solutions are modeled in the decision tree shown in figure .
however due to space constraints we do not provide class diagrams for each design pattern.
.
tactic heartbeat the third tactic studied was the heartbeat tactic.
this is used to monitor the availability of a critical component.
the monitored component emits a periodic heartbeat message while another component listens for the message.
the originalcomponentisassumedtohavefailediftheheartbeat fails .
our study identified six different patterns used to implement the heartbeat.
these included decorator template method observer composite bridge flyweight and state.
from these we derived the following variability points.
statefultasks t askstate state getstate setstate highresourced... t askproxy taskoperation t askprogressmonitor complexmonitoring addmonitor done removemonitor setcanceled started taskmonitoring update c oncretetask initialsettings taskoperation multipletasktypes gettaskid taskmonitoring notify register multipletasktypes c oncretetask2 initialsettings taskoperation multipletasktypes gettaskid taskmonitoring notify register s cheduler createtask schedule monitortask p rogressmonitor complexmonitoring addmonitor done removemonitor setcanceled started taskmonitoring update p rogressdistributor complexmonitoring addmonitor done removemonitor setcanceled started t askfactory statefultasks state manytasks statefultasks createtask statefultasks createtaskstate settaskstate taskstate t ask taskoperation multipletasktypes gettaskid taskmonitoring notify register t askstatet asks figure a reference model for the scheduler tactic.
variabilit y points are marked as stereotypes.
these stereotypes are used to reduce the model to deliver only the functionality specified by the user.
.
wrap around the heartbeat tactic often needs to be added onto other services or functions which have availability concerns.
the decorator pattern can be used to wrap those services with heartbeat functionality without the need to modify the services themselves.
.
piggybacking sending periodic messages such as a heartbeat can add significant communication overhead and impact system performance.
the heartbeat can therefore be piggybacked on other messages such as logging messages used for check pointing.
the template pattern can be used to construct a message which carries different kinds of information.
.
heartbeat monitor when multiple components emit heartbeats that need monitoring the observer pattern can be used to register one or more monitors with the heartbeat emitter.
in more complex systems where hundreds or thousands of components are being monitored the composite pattern can be used to establish a hierarchy of monitors.
in this case a low level monitor checks the health of a group of threads while its own health is checked by a higher level of monitor.
.
different monitor types when different types of componentarebeingmonitored thefaultmonitormustsupport different monitoring techniques https http ftp etc .
in this case the bridge pattern can be used to monitor different types of heartbeat messages and also check the health of different heartbeat senders in ways that are appropriate for their type.
.
mass creation when the heartbeat connection service requires mass creation of the same service specification for many clients the flyweight pattern can be used to create multiple objects in an efficient way.
for example this approach is appropriate if a http connection is heartbeat enabled in a given project there are many requests for such connections and connections and heartbeat services exhibit common properties across all the client requests then fly weight pattern can be used to create and share multiple heartbeathttp objects.
.
many tasks the heartbeat receiver s responsibilities vary based on the status of heartbeat sender.
for example the receiver could be in i steady state i.e.
receiving regular messages at predefined intervals from the sender ii compromised state when one or more senders is failing to transmit or in iii recovery state when steps are taken to remediate the problem of the unavailable sender.
the state pattern can be used to manage these various states.
.
reference models in sections we presented individual patterns implemented in scheduling resource pooling and heartbeat patterns respectively.
we also presented a decision tree for each of the tactics depicting the factors driving the adoption of each design pattern.
these factors and their associated implementation solutions can be seen as variability points of the tactic.
as in a product line features can be mandatory optional or variants.
mandatory features represent the essence of the product.
in the case of architectural tactics the core roles responsibilities and interactions that define the tactic can be seen as its mandatory features .
for example in the scheduling tactic there must be a scheduler and one or more schedulees while in the heartbeat tactic there must minimally be an emitterand areceiver.
optional features are those features which can be added to the product to bring additional value.
finally a variant feature is an abstraction of a group of mandatory or optional features which provides alternate methods of delivering the functionality.
in the case of architectural tactics the identified variability points of the tactic represent a mixture of optional and variant features.
figure shows the reference model we developed for the 8da ta noden ame node t ask trackersec ondary nam e node job trackersch eduler t ask tracker t ask tracker t ask tracker t ask trackerda ta node da ta node da ta node da ta nodedf s layer para llelization layer figure the high level architecture of the parallel computing infrastructure used in our case study m any tasks h igh resource demand s tateful tasks t ask mo nitoring s imple mo nitoring c omplex mo nitoring r emote task m ultiple task types s cheduling f lyweight p roxy m emento o bserver c omposite p roxy b ridge a dapter m ulti stepped sc heduling figure in this case study the developer selects de sired variability points for the pci system scheduler tactic.
all of the design patterns discussed in section are integrated into this model.
however we do not claim that this is the only possible way of combining the design patterns into a holistic solution nor do we claim that it is the best way.
we merely present this solution as one possible design given the variability points of the tactic and their related design patterns.
this reference model can help developers to implement the tactic.
although our longer term goal is to automate the generation of a customized reference model from a decision tree we currently provide only the static reference model where each variability point is labeled with a unique stereotype.
this is depicted in figure which shows stereotypes attached to classes attributes and to methods.
stereotypes on attributes and methods are shown above the element and refer to all elements underneath.
a stereotype on a class means that the whole class with all its attributes and methods contributes to a single variability point and could simply be removed if this variation is not part of the desired configuration.
for classes that contribute to multiple variations mult istepschedul remot etask taskproxy taskoperation t askprogressmonitor taskmonitoring update c oncretetask initialsettings taskoperation multipletasktypes gettaskid taskmonitoring notify register s cheduler createtask schedule monitortask p rogressmonitor taskmonitoring update t askfactory manytasks createtask t ask taskoperation multipletasktypes gettaskid taskmonitoring notify register t asks figure in this case study the reference model is mo dified to retain only desired variability points the elements inside the class are stereotyped and will be removed if not needed in the desired configuration.
if these reductions result in elements without attributes and methods then the class itself must be removed and its associations replaced with associations that connect source and target directly.
all core elements e.g.
task concretetask taskoperation initialsettings are not stereotyped and will accordingly form the mandatory elements of all configurations even if all variations are removed.
.
an illustrativeexample in this section we present an illustrative example of a system which we will refer to as parallel computing infrastructure pci .
pci is a development environment in which developers can write and or run parallelized computing tasks.
a high level architectural view is depicted in figure .
this example is loosely built upon the architecture and implementation of the hadoop system and the microsoft compute cluster pack .
pci has two main layers the distributed file system dfs layer and the parallelization layer.
in the dfs layer datanodes components are responsible for managing and storing data chunks while namenode is a central control point responsible for managing the file system namespace and controlling access by external clients.
it keeps track of datachunks managed by datanode and also is responsible for distributing replicated data.
the parallelization layer is designed to execute tasks through a map reduce paradigm.
operations are submitted by a client andthenstartedby jobtracker .jobtracker isalsoresponsible for creating a set of tasktrackers to track and report on task status.
job scheduling is a critical function of process parallelization so that the system can achieve high throughput and low response times.
the system is expected to handle thousands of concurrent requests.
to explore the possible design space of the scheduler the architect and or developers use the scheduler decision tree from section and mark the variability points of interest.
their choices are summarized in figure .
the first key characteristicofthepcisystemisitneedstoscheduleavery large number of tasks.
we therefore check off many tasks to 9increase parallelization and decrease the performance time.
t hepciarchitectureiscloud basedinwhichphysicalredundancy and parallelization are achieved through distributing tasks on different machines.
the scheduler therefore needs to manage remote tasks running in different address spaces.
wethereforecheckoff remote task.
schedulinguserdefined tasks requires customized initialization across the map reduce schema therefore we check multiple task types and multi stepped scheduling.
finally we opt for simple monitoringof tasks and check simple monitoring.
armed with these decisions the developer utilizes the stereotypes provided in the reference model to remove unwanted parts of the design and customize the reference model for the pci project.
the end result is shown in figure .
.
threats to validity there are several primary threats to the validity of this work.
the tactic pattern overlap datasets were created using two data mining techniques neither of which is precise.
ommissionerrorswerereducedbysettingthethresholds in both mining tools quite low in order to favor high recall over high precision.
however this also increased the manual evaluation effort which could have resulted in failure to identify instances of correct tactic pattern implementations.
as a result we clearly cannot claim that we have identified all common cases of design pattern usage in architectural tactics.
instead we claim to have identified many of the common uses.
commission errors were reduced significantly by manually inspecting the resulting overlaps.
this task was performed by one author of this paper and validated by the other two.
nevertheless this is a non trivial task which sometimes involves deep understanding of the source code.
while we are confident that the use of patterns was correctly identified it is possible that we misinterpreted the intent of using the pattern in a particular context.
this danger was somewhat mitigated by examining multiple instances of each pattern use.
second our work studies the actual use of design patterns for implementing architectural tactics in open source systems.
however just finding a pattern use does not necessarily mean it was used correctly.
developers may choose less than effective design solutions.
to mitigate this problem we only included a pattern in our framework if we found it used in a similar way across three or more systems or else found its use particularly convincing.
given the nature of open source development a pattern that is used in several systemssuggestscommunityconsensusthatit isa solididea.
finally an additional threat to validity arises in the construction of the reference models.
these models represent a synthesis of designs found across multiple projects as well as standard knowledge of design patterns available in text books and other material .
we have presented our approach as applicable to a broad range of patterns however due to the time consuming nature of our study we have only developed such models for the three tactics discussed in detail in this paper.
based on our study of the other tactics described in this paper we see no reason to believe this approach is not generalizable.
.
related work the concepts of architectural styles also referred to as architectural patterns tactics and designpatterns have a long and respected history.
bass describes tactics as architectural building blocks from which architectural patterns such as layers pipe and filter blackboard and model view controller are constructed .
numerous authors have shown the usefulness of architectural tactics for addressing performance reliability maintainability and other such quality concerns .
some researchers have explored the interactions between architectural tactics and architectural patterns.
for example harrisonandavgeriousconductedastudyentitled how do architecture patterns and tactics interact?
.
however their study focused on the contribution and interaction of architectural tactics to higher level patterns i.e.
styles and did not investigate the use of design patterns for implementing architectural tactics.
champagne and gagne describe an approach that utilizes a design assistant to automate architectural tactics while de bruin et.
al.
describe a top down decompositional approach for deriving an architecture from tactics .
neither of these approaches explores the specific use of design patterns to implement architectural tactics.
numerous architectural assessment techniques such as the attribute driven design and quality driven architecture development for designing architectural solutions however such approaches focus more upon high level architectural design drive by quality attributes.
other authors have presented techniques for improving designs through adopting design patterns .
gueheneuc et al.
proposed a recommender system which recommends which design patterns might be useful to support specific problems contexts .
finally although we did find some practice oriented websites which addressed the implementation of various tactics to the best of our knowledge this paper is the first attempt to systematically document developers actual uses of design patterns in tactics.
.
conclusions this paper has presented the results of an extensive study we conducted into the industrial use of design patterns for implementing architectural tactics.
our study revealed interesting usage trends from which we were able to identify variability points associate specific design pattern solutions with each variability point and construct a tactic specific reference model.
in its current form a developer can manually transform the reference model into a customized class diagramshowingonlythedesiredfeaturesofthetactic.
this provides guidance to developers as they implement architectural tactics.
in future work we plan to adopt concepts from the feature modeling domain so that each tactic and its variability points will be specified as a feature model from which we can automatically generate a class diagram.
we will also extend our work on reference models by adding dynamic views.
the work in this paper examined a broadly representative set of tactics and patterns.
however due to the time and effort needed to manually evaluate pattern tactic overlaps we identified variability points for the scheduler resource pooling and heartbeat tactics only.
in our ongoing work we thereforeintendtodevelopreferencemodelsforafarbroader range of tactics.
.