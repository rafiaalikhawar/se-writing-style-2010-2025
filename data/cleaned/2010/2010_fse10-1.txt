locating need to translate constant strings in web applications xiaoyin wang1 lu zhang1 tao xie3 hong mei1 jiasu sun1 1institute of software school of electronics engineering and computer science 2key laboratory of high confidence software technologies ministry of education peking university beijing china wangxy06 zhanglu meih sjs sei.pku.edu.cn 3department of computer science north carolina state university raleigh nc usa xie csc.ncsu.edu abstract software internationalization aims to make software accessible and usable by users all over the world.
for a java application that does not consider internationalization at the beginning of its development stage our previous work proposed an approach to locating need to translate constant strings in the java code.
however when being applied on web applications it can identify only constant strings that may go to the generated html texts but cannot further distinguish constant strings visible at the browser side needto translate from other constant strings not need to translate .
in this paper to address significant challenges in internationalizing web applications we propose a novel approach to locating need totranslate constant strings in web applications.
among those constant strings that may go to the generated html texts our approach further distinguishes strings visible at the browser side from non visible strings via a novel technique called flag propagation.
we evaluated our approach on three real world open source phpbased web applications in total near kloc squirrel mail lime survey and mrbs.
the empirical results demonstrate that our approach accurately distinguishes visible strings from non visible strings among all the constant strings that may go to the generated html texts and is effective for locating need to translate constant strings in web applications.
categories and subject descriptors d. .
distribution maintenance and enhancement general terms management standardization keywords software internationalization flag propagation web application .
introduction software applications usually require different local versions for users from different regions of the world.
researchers and practitioners usually refer to techniques for acquiring and managing corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa copyright acm ... .
.local versions of software as software internationalization and localization.
a typical way to perform software internationalization and localization is to put language specific elements such as uservisible constant strings and number date formats etc.
to property files i.e.
internationalization and translate the property files without changing the code i.e.
localization .
for various reasons developers may not internationalize a software application at the very beginning of the development process but have to perform internationalization on an existing version of the software application .
therefore the developers need to locate all the hardcoded language specific elements and externalize them to property files.
when locating these language specific elements the most time consuming task is to locate need to translate constant strings due to their large number and scattered distribution in the code.
in our previous work we proposed an approach to locating need to translate constant strings in java applications.
our previous approach includes three major steps.
first we locate all of the library method invocations that may output a string type argument to the graphical user interface gui .
then for each string type argument that is output to the gui we use string analysis to obtain a context free grammar cfg which is built from the static single assignment ssa form of the code.
the start nonterminal of the cfg is the string type argument and the language of the cfg is all the possible values of the string type argument.
finally we add a unique annotation to each terminal constant string in the cfg to indicate its exact location in the code and propagate the annotations in the cfg based on string taint analysis to get the locations of all the constant strings whose values may be passed to the string type argument.
therefore our previous approach is able to locate all the constant strings whose values may go to the gui.
in recent years web applications are increasingly becoming popular due to the convenience of internet access.
challenges in the development of web applications are attracting more and more attention from various researchers .
web applications especially require internationalization partly because users from all over the world can access them after they are put online.
when applying our previous approach on web applications we face significant challenges.
for a web application each dynamically generated web page is actually a text in the html format displayed at the browser side.
thus our previous approach is able to locate the constant strings that may go to the browser side for display.
however not all parts of the html text sent to the browser side are visible to users.
in fact strings output to the gui in traditional applications such as java gui applications are usually plain texts and are directly displayed on the gui but strings output to the browser side in a web application may contain html tags.
according to the syntax of html only some parts of an html text are displayed on thescreen.
the remaining parts of the html text are tags used for format description and element identification etc.
so an approach for web applications needs to further distinguish those user visible constant strings from other constant strings in each web page.
typically there are two types of user visible strings in an html text strings displayed as texts visible on web pages and strings displayed as labels or default values of input fields on web pages.
for static web pages it is easy to identify the user visible constant strings with an html parser.
however it is challenging to identify the user visible constant strings for dynamic web pages.
for a dynamic web page user visible strings appear as constant strings in the code for generating the dynamic page.
therefore it is infeasible to identify them in the code with an html parser.
furthermore in a typical web application the set of possible html texts generated by the application can be infinite.
thus it is also infeasible to enumerate all the possible html texts generated by the application and check them with an html parser.
in this paper to address the significant challenges in internationalizing web applications we propose a new approach to locating need to translate strings in web applications.
our new approach currently works for only php applications but the idea is general and it is relatively easy to adapt our approach for other types of web applications.
our new approach significantly extends and improves our previous approach .
given a dynamic web page we use our previous approach to locate constant strings that may go to the browser side for display.
among these constant strings we propose two novel techniques to identify the preceding two types of user visible constant strings.
the basic idea of the two techniques is as follows.
we add location information such as whether the string is inside a tag to each terminal constant string and each non terminal.
the location information of some constant strings can be determined based on their values.
we further propagate the location information to all the other terminals and non terminals and use the propagated location information to identify the preceding two types of user visible constant strings.
in this paper we refer to the added location information as flags and propagation of location information as flag propagation.
this paper makes the following main contributions a demonstration of significant challenges in automatically locating need to translate constant strings in web applications novel algorithms for flag propagation to automatically determine whether a constant string in the code can appear in user visible parts of the generated html texts an empirical evaluation of applying our approach on three real world open source web applications in total near kloc to evaluate the effectiveness of our approach.
we organize the rest of this paper as follows.
section presents our motivation using some sample php code.
section introduces some background knowledge.
section presents our approach in detail.
section presents the implementation of our approach.
section reports an empirical evaluation of our approach.
section discusses related issues.
section discusses related work.
section concludes the paper with future work.
.
motivation in this section we present four code portions in three real world web applications to motivate our approach.
the first code portion is from question.php of lime survey version .
.
... echo and pressed refresh on your browser.
in this case your responses have br nn already been saved.
echo font center br br ... in the preceding code portion we can see that to determine that the constant string already been saved.
can be displayed on the screen at the browser side we need to consider its context.
in fact we can decide that this string is user visible at the browser side because the strings before it br and after it font indicate that it is not inside an html tag.
that is to say our approach needs to check the strings which may be either constants or variables before and after each constant string to determine its context.
the second code portion is from day.php3 of mrbs version .
.
as described below it demonstrates some constant strings that can be determined as not user visible only through their context.
... if t timetohighlight c red else c white ... echo td bgcolor c ... in the preceding code portion we can see that the constant strings red and white appearing in the code portion are not uservisible at the browser side because they are inside a tag corresponding to a table column quoted by td and and they indicate the background color of the table column.
furthermore some constant strings that are output to the tag part of the generated html texts are still user visible at the browser side.
such constant strings are the value attributes of some input tags.
the following code portion is from compose.php of squirrel mail version .
.
.
... if substr strtolower reply subj !
re reply subj re reply subj echo input type text name passed subject size value reply subj ... in the preceding code portion we can see that the italicized constant string i.e.
re becomes the value attribute of an input tag.
according to the html syntax this constant string is displayed as the default value of an input text field and is thus uservisible.
however not all the value attributes in all the input tags are user visible at the browser side.
according to the html syntax there are types of input tags.
only when the type of an input tag is text button submit or reset the value attribute of the input tag is user visible at the browser side.
for example the italicized text y in the following code portion from qanda.php of lime survey version .
is not user visible at the browser side because the type of the input tag is checkbox .
... answer .
ntntntntntntntntnt input class checkbox type checkbox name myfname value y if session y answer .
checked answer .
onclick checkconditions this.value this.name this.type ansrow nn ... the preceding four code portions demonstrate that the challenges for accurately determining whether each constant string in the code is user visible at the browser side lie in the need to know which part of the generated html texts each constant string eventually appears in.
to address these challenges we need to search in the code to obtain the context of each constant string and use the context to determine whether the constant string is user visible.
.php3 is the old extension for php.
background .
string analysis and string taint analysis for the ease of understanding our approach presented in section we next introduce string analysis and string taint analysis.
the general idea of string analysis is as follows.
first the program under analysis is transformed to the static single assignment ssa form.
second string assignments and operations that the string variable under analysis depends on are abstracted as an extended context free grammar cfg with string operations i.e.
library string methods such as string.substring int int in java on the right hand side of productions.
then these string operations are simulated with finite state transducers fsts .
finally the language of the generated cfg represents all the possible values of the string variable under analysis.
string taint analysis is a technique proposed by wessermann and su for tracing possible malicious user inputs to check crosssite scripting or sql injection.
string taint analysis is based on the cfg generated by string analysis.
initially the terminals corresponding to possible malicious user inputs are annotated with a taint.
then for each production in the cfg if there is a terminal or a non terminal with a taint on its right hand side the non terminal on the left hand side is also annotated with the taint.
finally vulnerabilities are checked on certain non terminals with taints.
our previous work adapts string taint analysis by adding exact locations in the code as annotations to the constant strings terminals that are involved in string analysis and propagating these annotations in the generated cfg.
during the propagation the annotation of the non terminal at the left hand side of each production becomes the union of the annotations of all the terminals and nonterminals at the right hand side and its current annotation.
finally the annotation of the start non terminal indicates the exact locations of all the constant strings whose values may be passed to the string variable under analysis i.e.
the start non terminal in the cfg .
.
user visible parts in html texts we next briefly summarize which parts of a standard html text are displayed to users at the browser side.
there are two types of user visible strings in an html text.
strings of the first type are those that are outside any html tags.
these strings are displayed as ordinary texts in web pages.
the first code portion in section is an example of strings of this type.
strings of the second type are those that serve as the value attributes of certain types of input tags4.
these strings are displayed as labels or default values of input fields corresponding to input tags in the generated html texts.
such types of input tags include button text submit and reset .
however the value attributes of the other types of input tags e.g.
radio and checkbox are not user visible.
for a checkbox its value attribute actually indicates whether it is checked in the web page i.e.
y for checked and n for unchecked .
.
approach in this section we first formalize the target problem in section .
and then we present two new techniques to identify the two types of user visible constant strings in sections .
and .
respectively.
.
problem according to string analysis we can represent a dynamic web page as a cfg denoted as a tuple g n t s p where nis the set of non terminals tis the set of terminals sis the start 4attributes of other tags e.g.
the alt attribute of the image tag can also be user visible.
the situation is similar to the value attribute of the input tag so that they can be addressed by the same approach.non terminal and pis the set of productions .
non terminals can be traced to string variables in the code and terminals can be traced to constant strings in the code.
based on g l g f!js !g where s !denotes that scan deduce !
is the set of all possible html texts generated in the dynamic web page.
the nature of deduction in cfgs ensures that any !2l g corresponds to at least a deduction tree.
the leaf nodes of the deduction tree are terminals and !is the concatenation of the leaf nodes.
in this paper we say that scan deduce !witht denoted as st !
where t2t ifs !andtappears as a leaf node in at least one deduction tree of !.
thus given a dynamic web page the problem of determining constant strings that may go to the html texts generated in the dynamic web page can be represented as the calculation of the following set s1 ftjt2t !2l g st !
g. our previous approach uses an adapted string taint analysis to calculate this set.
however calculating s1is not sufficient for locating need totranslate constant strings in a dynamic web page.
given !2l g andt2t an html parser can determine whether tappears in a user visible part of !.
in this paper we denote that tappears in a user visible part of !asv is !
t .
thus the problem of locating need to translate constant strings in a dynamic web page can be represented as the calculation of the following set s2 ftjt2t !2l g st !
v is !
t g.s2 is a subset of s1.
as it is infeasible to enumerate each !2l g to check whether v is !
t holds we need to analyze the productions in gto identify user visible constant strings in t. in our approach we represent v is !
t as location characteristics of t and check which terminals satisfy these location characteristics on the basis of the productions.
.
locating outside tag constant strings if a constant string contains or we can use or to determine which parts of the constant string are outside tags.
for example we know that in abc def abc appears inside a tag and def appears outside tags.
however if a constant string does not contain either or we need to resort to constant strings that may be concatenated to the constant string in the generated html texts.
for example if we know that abc may be concatenated to def to form a string like abc def in the generated html texts we can determine that def is outside tags using the in abc .
in fact when two strings are concatenated together the right most point of the first string and the left most point of the second string become the same point.
thus if one such point is outside tags the other point is also outside tags.
as a result if we already know some constant strings are outside or inside tags we can also know whether other constant strings are outside or inside tags by iteratively checking neighboring strings.
following this idea this sub section presents a technique for locating user visible constant strings appearing outside tags consisting of four phases adding flags to variables5 initializing flags of variables propagating flags and identifying outside tag constant strings.
.
.
adding flags to variables for each variable in the cfg we add two flags the left flag and the right flag.
the left flag represents whether the left most point of the variable is inside an html tag and the right flag represents whether the right most point of the variable is inside an html tag.
5here we use variables to denote either terminals or non terminals for the ease of presentation.
note that a variable in a cfg is different from a variable in its corresponding code.
.
.
initializing flags of variables we define four different values for flags of variables in the cfg unknown denoting that it is not known whether the left most point or the right most point is inside an html tag inside denoting that the left most point or the right most point is inside an html tag outside denoting that the left most point or the right most point is outside any html tag conflict denoting that the left most point or the right most point may be either inside or outside html tags.
we initialize the flags of each variable in the cfg as follows.
if the variable is a non terminal set both its left flag and right flag as unknown .
if the variable is a terminal and it contains neither nor set both its left flag and right flag as unknown .
otherwise if the left most or is actually a set the left flag as outside otherwise set the left flag as inside and if the right most or is actually a set the right flag as inside otherwise set the right flag as outside .
.
.
propagating flags after initialization we propagate the flag values between flags on the basis of productions.
here the propagation is bidirectional and the propagation between flag aand flag bwill result in setting both aandbwith the same flag value which we denote as bipropagate a b .
we repeatedly do the preceding propagation until the propagation cannot change the value of any flag.
the rules for calculating bipropagate a b are as follows.
bipropagate a b unknown if values of both aandb areunknown .
bipropagate a b inside if values of both aandbare inside or one value is inside and the other is unknown .
bipropagate a b outside if values of both aandb areoutside or one value is outside and the other is unknown .
bipropagate a b conflict if either the value of aor the value of bisconflict or one value is inside and the other isoutside .
given a production we propagate the flags of variables in the production with the following rules.
.if two variables are neighboring at the right hand side of a production we perform a propagation between the right flag of the first variable and the left flag of the second variable.
.if a terminal contains neither nor we perform a propagation between the left flag and right flag of the terminal.
.we perform a propagation between the right flag of the production s left hand side variable and the right flag of the last variable in the production s right hand side.
.we perform a propagation between the left flag of the production s left hand side variable and the left flag of the first variable in the production s right hand side.
.
.
identifying outside tag constant strings after we acquire the final values of the left flags and right flags of all the variables we consider each terminal constant string that contains at least a or a and that has at least one of its two flags as outside orconflict to be a possible need to translate constant string.
note that as such a constant string may contain tags we need to further check which parts of the string need translation.
a terminal can have its flag value as conflict due to one of the following three factors.
first the code has some bugs and may generate incomplete tags e.g.
input id br .
second table flag initialization variable left flag right flag input outside inside student id unknown unknown name unknown unknown student unknown unknown inside outside all non terminals unknown unknown there exists some imprecision in string analysis.
the reason lies in that string analysis tries to use a cfg to express the possible strings generated by the code but the set of possible strings generated by the php code may go beyond the expressiveness power of cfgs e.g.
php code can generate 0n1n2n which cannot be expressed exactly by any cfg .
thus string analysis actually approximates the possible strings generated by php code using a cfg that expresses the superset of the possible strings generated by the php code e.g.
using to approximate 0n1n2n and may contain some strings that actually cannot be generated by the php code.
third the constant string corresponding to the terminal may appear both inside tags and outside tags.
the following code portion is an example of such a situation.
abc dog echo div id abc abc div from the above code portion as constant string dog may appear outside any tag it should be a need to translate constant string.
however the constant string also appears inside an html tag.
for such a case the developer can refactor the php code by splitting the variable abc into two variables otherwise translation of dog may impact the structure of the generated html.
as our approach cannot differentiate which reason causes the conflict value currently we consider all terminals constant strings with the conflictflag value as need to translate to reduce false negatives.
.
.
illustration to further illustrate the flag propagation process we use the following example cfg.
s a input bcd a student id b name c student d in the example productions non terminals are represented by capital alphabets and terminals are surrounded by quotation marks.
the php code corresponding to the cfg tries to generate a string of student id followed by an input tag.
the initialization of the two flags of each variable is shown in table .
assume that we divide flag propagation into a series of iterations and in each iteration from the first production to the last production we propagate flags for the production by applying the four rules described in section .
.
one by one.
the first iteration propagation goes as follows.
first we take the first production and perform a propagation with the first rule between the right flag of aand the left flag of input .
since the left flag of input isoutside the right flag of abecomes outside.
similarly the left flag of bbecomes inside .
as there are no terminals without containing either or there is no propagation with the second rule for the first production in this iteration.
the third rule changes nothing because both the right flag of d and the right flag of sareunknown .
the fourth rule also changes nothing because both the left flag of aand the left flag of sare unknown .
second we then turn to the second production.
as the right flag of aisoutside now the right flag of student id becomes outside using the third rule.
as we consider the second rule before the third rule we cannot change the left flag of student id tooutside in the first iteration.
third the left flag of name becomes inside using the fourth rule since the left flag of bis inside.
as we consider the second rule before the fourth rule wecannot change the right flag of name toinside in the first iteration.
fourth we change nothing with the fourth production in the first iteration.
finally the left flag of dbecomes inside and the right flag of dbecomes outside .
after the first iteration the cfg with flag values is as below.
for simplicity we use o to denote outside i to denote inside u to denote unknown and c to denote conflict .
u s u u a o o input i i b u u c u i d o u a o u student id o i b u i name u u c u u student u i d o i o then we perform propagation for the second iteration and the cfg with flag values is as follow.
the flags in the bold font indicate the changes from the first iteration.
u s o o a o o input i i b i u c i i d o o a o o student id o i b i i name i u c i u student i i d o i o then after several iterations the final cfg with flag values becomes as follow.
the flags in the bold font indicate the changes from the second iteration.
o s o o a o o input i i b i i c i i d o o a o o student id o i b i i name i i c i i student i i d o i o finally from the cfg with flag values we can distinguish that the constant string student id in the second production appears outside tags since both its left and right flags are outside .
.
locating need to translate constant strings inside input tags to check whether a constant string is a need to translate constant string inside an input tag we need to check whether and where the constant string may appear in an input tag.
to achieve this purpose we extend flag propagation described in section .
.
in particular the technique for locating need to translate constant strings inside input tags consists of four phases.
the first phase is to locate all the occurrences of input in the cfg that correspond to an input tag.
the second phase is to identify the scope of each input tag.
the third phase is to identify the value and the type attributes in the input tag scope.
the fourth phase is to determine whether a constant string as a value attribute is need to translate according to the content of its corresponding type attribute.
to simplify the situation we make an assumption that all the html keywords e.g.
input type value and possible type values like button and text in the generated html text appears in the code as a whole.
in other words the keywords are not split into more than one constant string in the php code but there can be constant strings in which one or more keywords appear as substrings.
our algorithm described below works only under this assumption.
so the algorithm cannot deal with the code below.
echo inp echo ut id id1 we expect that this assumption holds in most cases in real php code because there is no need to use string variables to generate keywords and few programmers would write such php code which is quite difficult to understand and exists with no good reasons.
.
.
locating input tags in this phase we first collect a list of candidate input tags by collecting all the terminals that both have input as a substring and are decided as inside tag in identification of outside tag constant strings.
some of the collected terminals containing input may not correspond to an input tag in the generated html text because input in an inside tag terminal may serve as an attribute of an html tag e.g.
input in div name input .
accordingto the html syntax only an input that appears at the beginning of a tag corresponds to an input tag.
in other words each such input has its nearest previous non space character as .
so we then check whether the non space character appearing nearest before input is a .
in particular we determine input tags as follows.
if the terminal containing an input has a non space character immediately before the input and the non space character is a then we know that the input corresponds to an input tag.
if the terminal containing an input has a non space character immediately before the input but the non space character is not a then we know that the input does not correspond to an input tag.
if the terminal containing such an input has no non space character immediately before the input we put the terminal into an undecided list and use the following flag propagation to further check terminals in this list.
similar to the technique described in section .
we also give each variable in the cfg two flags the left flag and the right flag.
this time a flag has only two values unknown andbefore input .
the value before input represents that the corresponding point of the flag is before a string with input value but after any non space character.
then for each terminal in the undecided list we set the value of its left flag as before input and the value of its right flag as unknown .
for each other terminal we set the values of both flags as unknown .
after that we propagate the flag values in the cfg in a way similar to the flag propagation for locating outside tag constant strings in section .
.
using the following propagation rules.
.if two variables are neighboring at the right hand side of a production we perform a propagation from the left flag of the second variable to the right flag of the first variable.
.if a terminal contains only spaces we perform a propagation from the right flag of the terminal to the left flag of the terminal.
.we perform a propagation from the right flag of the production s left hand side variable to the right flag of the last variable in the production s right hand side.
.we perform a propagation from the left flag of the first variable in the production s right hand side to the flag of the production s left hand side variable.
here the propagation is unidirectional and the direction is backward in possible html texts.
therefore we denote the propagation from flag ato flag bas assigning backpropagate a b to bwithout changing the value of a. we define backpropagate a b as follows.
backpropagate a b unknown if values of both aand bareunknown .
backpropagate a b before input if either the value ofaor the value of bisbefore input .
the preceding definition of backpropagate a b ensures that a flag of value unknown cannot be propagated to a flag of value before input .
furthermore as we are looking for the previous instead of the following character of a given terminal the preceding definition of backpropagate a b ensures that we search in the correct direction.
like the bidirectional flag propagation for locating outside tag constant strings the backward propagation ends when no flag value changes.
then we check whether there is a terminal whose right flag has the value of before input and whose left flag has the value ofunknown .
for such a terminal denoted as t if the last nonspace character in tis we know that it is possible that a appears as the nearest non space character before an input in the undecided list.
thus we determine the input as an input tag.
otherwise we filter out the input .
note that the preceding backwardflag propagation is for checking only one input in the undecided list and we use the same way to check every other input in the undecided list one by one.
furthermore it is possible that an input has more than one possible nearest previous non space character and not all of them are .
in such situations the input has other usages than being a tag mark6.
in these situations our approach may produce some false positives.
the empirical study in section shows that such false positives are of only a small number in practice.
.
.
identifying scopes of input tags in the second phase we find out all the terminals that may appear inside the scope of each input tag.
we start from the input tags located in the first phase.
for each terminal corresponding to an input tag if the terminal contains a following the input the scope of the input tag can be easily determined.
otherwise if the terminal does not contain such a following we perform flag propagation to identify all the terminals that are possibly in the scope of the input tag.
here the flag propagation is also unidirectional and the direction direction is forward.
we give each variable a left flag and a right flag.
the value of a flag is unknown orafter input .
the value after input represents that the corresponding point of the flag is after a tag mark input but before a character which indicates the end of the input tag.
we initialize the right flag of the terminal asafter input and all the other flags as unknown .
like bidirectional and backward propagation the forward propagation also has four rules.
.if two variables are neighboring at the right hand side of a production we perform a propagation from the right flag of the first variable to the left flag of the second variable.
.if a terminal contains neither nor we perform a propagation from the left flag of the terminal to the right flag of the terminal.
.we perform a propagation from the left flag of the production s left hand side variable to the left flag of the first variable in the production s right hand side.
.we perform a propagation from the right flag of the last variable in the production s right hand side to the right flag of the production s left hand side variable.
if we denote the forward propagation from flag ato flag bas assigning forpropagate a b tobwithout changing the value of a the definition of forpropagate a b is as follows.
forpropagate a b unknown if values of both aand bareunknown .
forpropagate a b after input if either the value of aor the value of bisafter input .
the forward propagation ends when no flag value changes.
then there are three types of terminals that may contain substrings in the scope of the input tag the terminal corresponding to the input tag terminals whose left flag and right flag both have the value ofafter input and terminals whose left flag has the value of after input and whose right flag has the value of unknown .
for the terminal corresponding to the input tag the characters after the tag mark input are in the scope of the input tag.
for each terminal whose left flag and right flag both have the value of after input all the characters are in the scope of the input tag.
for each terminal whose left flag has the value of after input and whose right flag has the value of unknown the characters before the first is in the scope of the input tag.
for the ease of presentation we also use the scope of an input tag to denote the characters determined to be in the scope of the input tag.
6we use tag mark to denote a constant string corresponding to an html tag such as the input in input type text name .
.
.
identifying value and type attributes of input tags after determining the scope of a given input tag the third phase further determines the parts that indicate the value attribute and type attribute of the input tag in its scope.
here we need to handle only each input tag whose scope is not contained as a whole in a terminal.
otherwise the type and the value attributes can be easily acquired.
the key technique in this phase is the forward flag propagation described in section .
.
.
as identifying the type attribute of an input tag is very similar to identifying the value attribute of an input tag we present only the identification of the value attribute of an input tag.
let us consider the html syntax about the value attribute of an input tag.
for an input tag there are two ways to indicate its value attribute.
the first way is to use a pair of single or double quotations.
for example an input tag with value abc can be defined as input value abc or input value abc .
the second way is not to use quotations.
for example an input tag with value abc can also be defined as input value abc .
the identification of the value attribute of an input tag consists of four steps.
first we locate all the keyword value in the scope of the given input tag.
second for each keyword value we find all the possible nearest following non space characters of value .
third for each character found in the second step if the character is the value before indicates that the value attribute is after .
in this case we find all the possible nearest following nonspace characters of .
then the acquired characters should be the first character in the value attribute.
fourth for each character acquired in the third step if the character is a or we find all the terminals that may appear in the scope after this character and before another or otherwise we find all the terminals after this character and before a space or .
in the identification of the value attribute of an input tag we adapt the second propagation rule in forward flag propagation.
the essence of the adaptation is as follows.
if we are looking for a character denoted as c we perform a propagation from the left flag of a terminal to the right flag of the terminal only when the terminal does not contain c. for example in the second and third steps when we are looking for the nearest non space character following value or cbecomes any non space character space and the second propagation rule allows propagation through terminals containing only spaces.
.
.
identifying need to translate constant strings inside input tags after we acquire the terminals in the type and the value attributes of an input tag we determine whether the terminals in the value attribute is need to translate as follows.
we check all the terminals that possibly serve as the type attribute of the input tag.
if there is any keyword e.g.
text and button indicating that the value attribute of the input tag is user visible we conservatively consider all those terminals possibly serving as the value attribute as needto translate.
additionally if an input tag has no type attribute but only a value attribute the value attribute of the input tag is need totranslate because according to the html syntax the default type attribute for an input tag is text .
.
implementation as our previous approach works for only java code our new approach for php applications cannot reuse the implementation of our previous approach.
therefore we adapted an existing 7in a generated html text only one value attribute is active however the string forming the value attribute can have multiple origins.
so an input tag may have multiple terminals as its possible value attributes.
the type attribute has the same characteristic.php string analyzer called phpsa .
phpsa builds a cfg from the php code and the start non terminal of the built cfg represents all possible html texts generated by the php code.
we re implemented the adapted string taint analysis on top of phpsa.
thus each time we run the adapted phpsa we obtain a cfg with all terminals and non terminals annotated with locations in the code.
since the start non terminal represents all possible html texts generated by the php code its annotations location information indicate all constant strings in the code that may appear in the generated html texts and these constant strings form a list of candidate constant strings.
to identify the need to translate constant strings from candidates we implemented the techniques introduced in section .
our implementation reads the cfg with annotations generated by the adapted phpsa performs the flag propagation algorithms in which our implementation adds and propagates flags for only candidate constant strings and acquires a list of user visible terminals that may appear in the user visible parts of the generated html texts.
.
evaluation .
research questions our evaluation aims to answer the following research questions rq1 how effective is our approach for locating need totranslate constant strings in web applications?
rq2 how effective are our two new techniques for locating the two types of need to translate constant strings in web applications compared with a related previous approach ?
the first research question is concerned with evaluating our approach as a whole.
the second research question is concerned with evaluating our two new techniques proposed in this paper.
.
approaches under comparison to answer the two preceding research questions we compared the following three approaches in our evaluation.
first we considered our approach proposed in section .
second since our approach extends our previous approach we also considered our previous approach without extension as a baseline in the evaluation.
third as the extension over our previous approach consists of two techniques we also considered an approach with only one technique i.e.
the technique for locating outside tag constant strings .
for the ease of presentation we use bs to denote our previous approach which serves as the baseline bs o to denote the approach with only the technique for locating outside tag constant strings indicating that this approach is the baseline approach plus the technique for locating outside tag constant strings all to denote our new approach proposed in section indicating that our approach is the baseline approach plus the two techniques.
.
subject programs we used three real world open source web applications as subjects lime survey squirrel mail and mrbs.
all three applications which are accessible from sourceforge8 are written in php.
the primary reason for choosing these three applications as subjects is that they belong to different web application domains and they have different web page structures.
lime survey started in march is a popular web application to do surveys on the internet.
squirrel mail is a well known web based email client started since november .
mrbs is a web based meeting room reservation system started since early may .
the information of the subjects is presented in table .
for each subject columns to show the name and the version number of the application the starting month the application the number of developers involved in the development of the application the number of lines of code loc of the application the number of files of the application and the number of constant strings of the application respectively.
the developers of all the three subjects did not consider internationalization at the beginning and they used many hard coded constant strings in english in early versions of theses subjects.
in june the developers of lime survey internationalized lime survey and updated the application from version .
to version .
.
the primary aim of the internationalization was to create a version for spanish users.
in january the developers of squirrel mail internationalized squirrel mail and updated the application from version .
.
to version .3prel.
in may the developers of mrbs began to internationalize mrbs and updated the application from version .
to .
.
for all the three subjects we applied the three approaches on versions before internationalization.
.
metrics to evaluate the three approaches we obtained the exact needto translate constant strings in the three subjects using a procedure similar to the evaluation in our previous work .
first we deemed constant strings in the version before internationalization as need to translate constant strings if the developers externalized them in the subsequent internationalized version.
second as the approaches under comparison did find a number of need totranslate constant strings that were not externalized in the subsequent internationalized version for each subject we also deemed as need to translate the constant strings that at least one approach located and we manually verified to be need to translate.
in particular when one approach located a constant string not externalized in the subsequent internationalized version we further checked the versions later than the subsequent internationalized version.
we deemed the constant string as need to translate if it was externalized in a later version.
if not we manually generated some input data to execute the subsequent internationalized version.
if we could see the string on some web page and found it not understandable to a user not familiar with english we deemed it as need to translate otherwise we deemed it as not requiring translation.
the numbers of the need to translate constant strings in the subjects are shown in the last column in table .
all the numbers in our statistics and evaluation are the numbers of constant string locations in the code rather than constant string values.
for example constant strings of the same value but appearing in two different locations in the code are counted as two.
furthermore the numbers are for the versions before internationalization.
for example if three constant strings in the previous versions are externalized as one string in the internationalized version the constant strings are counted as three.
based on the obtained need to translate constant strings for each approach and each subject we calculated the number of constant strings that need translation but are not located by the approach denoted as false negatives and the number of constant strings that are located by the approach but actually do not need translation denoted as false positives .
in the brackets after the numbers shown in the last two columns of table the percentages of false negatives and false positives are presented.
.
results and analysis .
.
rq1 overall effectiveness the rows where subject names are marked with all in table show the results of using our approach on the three subjects.
in the table we use fn to denote false negatives and fp to denote false positives.
we use lime and squirrel as abbreviations of lime survey and squirrel mail respectively.
the need to table basic information of the subjects application starting developers loc files constant need to translate not externalized version month strings in the subsequent version lime survey .
march .3k squirrel mail .
.
nov. .0k mrbs .
may .4k table results of the three experimented approaches subject need to located fn fp approach translate lime all lime bs o lime bs squirrel all squirrel bs o squirrel bs mrbs all mrbs bs o mrbs bs translate and located columns show the number of exact needto translate constant strings and the number of need to translate constant strings located by each approach respectively.
from the results we have three main observations.
first our approach to locating need to translate constant strings in web applications using both new techniques is able to locate most of the need to translate strings.
in lime survey our approach locates of exact need to translate constant strings.
in squirrel mail our approach locates all the need to translate constant strings.
in mrbs our approach locates of .
all the false negatives in lime survey are due to the analysis inaccuracy of the php string analyzer used in our implementation.
in particular in lime survey there are constant strings that are compared with the default values of input tags in the generated web pages that are fetched by post .
since the default values of the input tags are need to translate when the input tags are of certain types the constant strings that are compared to the default values are also need to translate.
the php string analyzer used in our implementation cannot catch the assignment relation between the default value of an input tag and the variable post .
since the cfg itself does not contain this relation our approach currently cannot handle this situation.
we believe that our approach should be able to locate these false negatives if the underlying string analyzer is implemented in a more advanced way.
the false negatives in mrbs are due to that mrbs used some static html texts together with php code and our approach cannot locate need to translate constant strings in static html texts.
however such need to translate constant strings can be easily found using an html parser.
second for each subject our approach produces a few false positives.
in lime survey squirrel mail and mrbs the numbers of constant strings that are located by our approach but do not need translation are and respectively.
compared to the numbers of need to translate strings in the three subjects the numbers of false positives are quite small.
one reason for false positives is our conservative policy on conflict flags.
this reason accounts for false positives in lime survey and false positives in squirrel mail.
the second reason of false positives is the user visible constant strings that cannot be translated.
this reason accounts for false positive in squirrel mail which is the trademark squirrel mail itself and false positives in lime survey which are user visible sql queries.
the third reason is some small php chips inside static html texts such as div name ?php echo div .
i?
.
since our approach considers only the content inside the php code we cannot decide whether div is inside a tagor not.
we conservatively consider such constant strings as needto translate and result in false positives in mrbs.
in fact such false positives can be resolved by parsing the static html to add the context for each portion of php code.
third for each subject our approach is able to locate some constant strings that the developers did not externalize in the subsequent internationalized version but we verified as need to translate.
the developers may have either missed them or did not externalize them at that time due to time or workload limit.
in both cases locating such strings should be helpful for the developers to obtain a version with better quality of internationalization earlier.
in total our approach locates such strings in the three subjects in lime survey in squirrel mail and in mrbs shown in the brackets of the last column of table .
among the strings in lime survey in squirrel mail and in mrbs were externalized and translated in a later version and still remained hard coded in all the later versions or were removed due to modifications other than internationalization.
one example of not externalized constant strings is presented in the following code portion in smtp.php of squirrel mail .
... switch err num ... case message command not implemented status break ... ... echo nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp nbsp b reason b message br ... this code portion outputs an error message command not implemented to the generated web page and then the error message is shown on the browser.
however the developer of squirrel mail did not externalize this string until three years later jan .
.
.
rq2 effectiveness of the two new techniques in table the rows where subject names are marked with bs show the results of using the baseline approach i.e.
our previous approach on the three subjects and the rows where subject names are marked with bs o show the results of using the baseline approach together with only the first technique i.e.
locating outside tag constant strings .
after a close examination of table we have the following four main observations concerning the effectiveness of the two new techniques.
first when used for locating need to translate constant strings in web applications our previous approach produces large numbers of false positives.
typically the numbers of false positives are much larger than the numbers of need to translate constant strings.
for squirrel mail the number of false positives is almost three times as large as the number of need to translate constant strings.
this observation indicates that without further distinguishing user visible constant strings from non visible constant strings our previous approach is not suitable for web applications.
second our first technique i.e.
locating outside tag constant strings is able to dramatically reduce the false positives.
after comparing the rows where subject names are marked with bs o and bs for each subject we find that our first technique reduces of false positives in lime survey of false positives in squirrel mail and of false positives in mrbs respectively.
this observation confirms that our first technique is highlyeffective in locating need to translate constant strings in web applications.
however our first technique cannot reduce all the false positives.
we have analyzed the reasons of those false positives in section .
.
.
third our second technique i.e.
locating need to translate constant strings inside input tags is able to locate some need to translate strings without inducing extra false positives.
in particular after comparing the rows where subject names are marked with all and bs o we obtain the numbers of new need to translate constant strings located by our second technique i.e.
for lime survey for squirrel mail and for mrbs .
this observation indicates that our second technique is also effective.
fourth the combination of our two new techniques accurately tackles the challenges that we have faced when adapting our previous approach for web applications.
after comparing the rows where subject names are marked with all and bs we find that none of the false negatives produced by our approach is due to our two new techniques.
that is to say if we consider the evaluation of only the two new techniques the combination of the two techniques is able to find all the need to translate constant strings among the candidate constant strings located by our previous approach with less than false positives.
.
threats to validity in our evaluation the threats to internal validity mainly lie in the way we verified constant strings not externalized in the subsequent internationalized version to be need to translate strings.
since the later versions involve various modifications for other purposes it is error prone to verify constant strings as need to translate in versions later than the version immediately after internationalization.
furthermore the manual verification of constant strings not externalized in any version as need to translate may be prone to accidental mistakes or personal perspectives to the notion of being needto translate .
to reduce these threats for each subject we examined all these strings in the later versions carefully executed the internationalized subject to see whether they appear on the browser and decided whether they are not understandable to a user who is not familiar with english.
the main threats to external validity lie in that the three subjects used in our empirical study are all open source web applications in php and all of them are of moderate sizes i.e.
several thousand lines of code .
furthermore to make use of the manually externalized constant strings as golden results we use old versions of applications generated years ago.
therefore it is possible that the findings of our empirical evaluation are specific to old versions of moderate size open source web applications and may not be generalized to other subjects.
to reduce these threats we plan to apply our approach to more web applications especially those that are commercial with larger code bases or using new web technologies.
.
discussion as discussed in our previous paper the conservative nature of string analysis may induce imprecision and this imprecision may impact the empirical results of locating need to translate constant strings in web applications.
however according to our empirical results reported in this paper we have not found false positives due to the preceding weakness of string analysis for locating need totranslate constant strings in web applications.
one important situation that our approach currently cannot handle is the case where a web application dynamically generates javascript code and the generated javascript code when executed by the browser outputs some need to translate strings to the generated web page directly or outputs some need to translated strings by calling apis of javascript libraries.
for example our approachcurrently cannot handle ajax web applications.
it is not easy to locate such need to translate strings because we need to analyze the syntax of the generated javascript part without obtaining all the possible contents of the javascript part.
since the javascript syntax is much more complex than html we may need to propose more complex adaptations to our flag propagation as well as developing some new techniques to handle dynamically generated javascript code.
.
related work to our knowledge our work is the first reported effort directly focusing on automatically locating need to translate constant strings in web applications.
our previous work which locates needto translate strings in java code is the most related work.
however when used for web applications our previous work cannot differentiate between constant strings that form html tags and constant strings that are displayed on the screen.
furthermore there have been a couple of published books on how to internationalize a software application .
these books provide guidelines on finding out need to translate constant strings and externalizing them but they do not propose any approach to perform the task automatically.
on top of that some researchers analyzed the process of internationalization and presented issues to be considered during the process including the problem of locating need to translate strings .
however none of them provided any automatic approach to locating need to translate strings.
there are also tools e.g.
gnu gettext9 java internationalization api10 to help developers externalize need to translate constant strings after the developers locate them.
other tools like kbabel11help developers edit and manage resource files called po files containing externalized constant strings.
these tools cannot locate need to translate constant strings but can be used together with our approach to improve the efficiency of internationalization.
string analysis and string taint analysis are recent improvements of traditional static data flow analysis .
christensen et al.
first proposed string analysis which is an approach for obtaining possible values of a string variable.
then string analysis is widely used in checking dynamically generated sql queries.
gould et al.
used a string analysis based approach to check the correctness of dynamically generated query strings.
halfond and orso used string analysis to detect and neutralize sql injection attacks.
minamide first used string analysis on web applications.
he proposed to simulate string operations in the extended cfg with fsts and implemented a string analyzer for php code to predict dynamically generated web pages.
based on minamide s work xie and aiken proposed a technique on detecting sql injection vulnerabilities in scripting languages.
recently wassermann and su developed string taint analysis based on minamide s work and applied this analysis on detecting cross site scripting vulnerabilities .
recently wassermann and su developed an approach to generating test cases for security vulnerabilities and kieyzun et.al.
further improved their approach.
compared to these approaches we apply string taint analysis on locating needto translate string candidates and developed flag propagation algorithms to find need to translate strings among the candidates.
like string taint anlysis our flag propagation algorithms also propagate information on the cfg generated by string analysis.
however our flag propagation differs from taint propagation in three main aspects.
first the purpose of flag propagation is different from that of taint propagation.
taint propagation aims to find all non terminals that may contain a taint i.e.
non terminals that may deduce to a terminal with taint while flag propagation aims to find the preceding or following terminals of a given terminal with some conditions e.g.
the nearest non space before or after certain character values like .
second taint propagation requires only one taint similar to the flags in flag propagation which may be of two or more taint values while our algorithms require at least two flags which represent the left most point and the right most point of a variable.
third taint propagation has only one propagation rule to propagate all the taints at the right hand side of a production to the left hand side of the production while our algorithms have four propagation rules to make sure that flags can be propagated through neighboring variables variable deductions and terminals.
another area related to our approach is machine translation .
machine translation has been used in translating web pages in some products e.g.
google translation12 babel13 .
if the technique of machine translation is advanced enough to accurately translate the generated web pages in real time the internationalization and localization of web applications may become unnecessary.
however it may take a long way to achieve this goal and almost all web applications are using internationalization and localization now.
additionally the technique of machine translation can also be integrated in our approach to help developers translate the need to translate strings after our approach identifies them.
.
conclusion and future work in this paper we identify significant challenges in automatically locating need to translate constant strings in web applications.
to address the challenges we propose two techniques to distinguish two types of user visible constant strings among all the constant strings that may go to the generated html texts.
we evaluated our approach on three real world open source web applications lime survey squirrel mail and mrbs.
the empirical results demonstrate that as our approach is able to accurately distinguish visible strings from non visible strings our approach is effective for locating need to translate constant strings in web applications.
we plan to extend our approach in three ways.
first to reduce the previously mentioned threats to the validity of our empirical evaluation we plan to conduct experiments on larger and newer commercial web applications.
second we plan to capture the string relations missed by the current php analyzer and reduce the false negatives in future work.
as stated in section .
integrating an html parser in our approach enables our approach to handle small pieces of php code inside static html texts.
therefore we plan to integrate such a parser in our approach in near future.
we also plan to integrate dynamic analysis in our approach to reduce false positives.
third our approach currently works only for php web applications.
we plan to extend it for web applications written in other languages e.g.
jsp .
since jsp web applications contain java code we need to integrate our approach with our previous approach for locating need to translate constant strings in java code.
acknowledgment the authors from peking university are sponsored by the national basic research program of china no.
2009cb320703 the high tech research and development program of china no.
2007aa010301 and no.
2006aa01z156 the science fund for creative research groups of china no.
and the national science foundation of china no.
.
tao xie s work is supported in part by nsf grants cns ccf and army research office grant w911nf .