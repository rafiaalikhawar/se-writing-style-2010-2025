singapor e management univ ersity singapor e management univ ersity institutional k nowledge at singapor e management univ ersity institutional k nowledge at singapor e management univ ersity resear ch collection school of computing and information systems school of computing and information systems activ e refinement of clone anomaly r epor ts activ e refinement of clone anomaly r epor ts lucia singapor e management univ ersity lucia.
smu.edu.sg david l o singapor e management univ ersity davidlo smu.edu.sg lingxiao ji ang singapor e management univ ersity lxjiang smu.edu.sg adity a budi singapor e management univ ersity adity abudi smu.edu.sg follow this and additional works at https ink.libr ary.smu.edu.sg sis r esear ch part of the softwar e engineering commons citation citation lucia lo david ji ang lingxiao and budi adity a. activ e refinement of clone anomaly r epor ts.
.
icse 34th international conf erence on softwar e engineering pr oceedings june z urich switz erland .
.
available at available at https ink.libr ary.smu.edu.sg sis r esear ch this conf erence pr oceeding ar ticle is br ought t o you for fr ee and open access b y the school of computing and information systems at institutional k nowledge at singapor e management univ ersity .
it has been accepted for inclusion in resear ch collection school of computing and information systems b y an authoriz ed administr ator of institutional k nowledge at singapor e management univ ersity .
for mor e information please email cher ylds smu.edu.sg .
active refinement of clone anomaly reports lucia david lo lingxiao jiang and aditya budi school of information systems singapore management university lucia.
davidlo lxjiang adityabudi smu.edu.sg abstract software clones have been widely studied in the recent literature and shown useful for finding bugs because inconsistent changes among clones in a clone group may indicate potential bugs.
however many inconsistent clone groups are not real bugs true positives .
the excessive num ber of false positives could easily impede broad adoption of clo nebased bug detection approaches.
in this work we aim to improve the usability of clone based bug detection tools by increasing the rate of true positives found when a developer analyzes anomaly reports.
our idea is to control the number of anomaly reports a user can see at a time and actively incorporate incremental user feedbac k to continually refine the anomaly reports.
our system first presents top few anomaly reports from the list of reports generated by a tool in its default ordering.
users then eithe r accept or reject each of the reports.
based on the feedback our system automatically and iteratively refines a classific ation model for anomalies and re sorts the rest of the reports.
our goal is to present the true positives to the users earlier tha n the default ordering.
the rationale of the idea is based on our observation that false positives among the inconsisten t clone groups could share common features in terms of code structure programming patterns etc.
and these feature s can be learned from the incremental user feedback.
we evaluate our refinement process on three sets of clonebased anomaly reports from three large real programs the linux kernel c eclipse and argouml java extracted by a clone based anomaly detection tool.
the results show that compared to the original ordering of bug reports we can improve the rate of true positives found i.e.
true positiv es are found faster by and for linux kernel eclipse and argouml respectively.
i. i ntroduction code clones or pieces of similar code commonly occur in large software systems due to various reasons whic h range from improper code reuse via the prevalent copy andpaste practice to the introduction of redundant code to improve runtime efficiency and or reliability of systems.
the y have attracted many research interest and various studies o n detecting code clones tracking and managing code clones and examining the harmfulness or usefulnes s of code clones .
one important use of code clones is their applicability in detecting bugs .
these clone based anomaly detection tools look for inconsistencies among code clones in every clone group i.e.
a group of code fragments similar to each other and report them as anomalies i.e.
potential bugs .
for example li et al.
look for different identifiernames among clones and check whether all names are changed consistently jiang et al.
look at syntactical structures of the code surrounding every clone in addition to the identifier names in clones and report differences as anomalies.
tens of true positives of diverse characteristi cs from large systems such as the linux kernel and eclipse have been found by these tools.
figure shows a true positive from the linux kernel there is a missing null chec k on thetmp variable in the code fragment .
such a detection is possible because most parts of the two code fragments after theifcondition are detected as clones and the code surrounding the clones which are the variable declaration and theifcondition shows some structural differences no ifin code fragment .
however the set of reported anomalies can be huge containing hundreds or even thousands of reports.
among these anomalies only a small proportion are true positives othe rs arebenign variations among clones in a clone group which are intended changes rather than mistakes.
the process of verifying whether these anomalies are true or not can be painstaking and time consuming.
developers tend to give up if many of the first set of anomaly reports that they check are false positives.
for example jiang et al.
reported that among more than reports generated by their tool for the linux kernel only are true bugs or bad programming styles.
gabel et al.
applied more advanced filtering techniques based on textual similarity a nd sequence alignment on inconsistent clones detected from a large commercial code base.
they reported that among manually checked anomaly reports out of in total may be true bugs and may be code smells while the rest is unsure.
hence reducing the manual effort in locatin g true positives in clone based anomaly reports remains an important task for wide adoption of such tools.
in this paper we propose an active learning and userfeedback directed approach to help alleviate the problem of false positives.
the task is challenging as there are only a few true positives embedded in a mass of false positives.
our idea is to actively iteratively incorporat e user feedbacks to refine anomaly reports.
users are presented anomaly reports one by one as a user labels the report as a false positive or true positive our system actively updates the remaining set of anomaly reports.
in so we aim to make true positives appear earlier in the list978 .
c ieee icse zurich switzerland 397icse 34th international conference on software engineering proceedings june zurich switzerland pages .
fragment code fragment file linux .
.
fs sysfs inode.c struct dentry dentry sd s dentry if dentry the following parts are detected as clones spin lock dcache lock spin lock dentry d lock if !
d unhashed dentry dentry d inode dget locked dentry d drop dentry spin unlock dentry d lock spin unlock dcache lock ...... file linux .
.
drivers infiniband hw ipath ipat h fs.c struct dentry tmp tmp lookup one len name parent strlen name spin lock dcache lock spin lock tmp d lock if !
d unhashed tmp tmp d inode dget locked tmp d drop tmp spin unlock tmp d lock spin unlock dcache lock ...... code fragment code fragment file linux .
.
fs sysfs inode.c struct dentry dentry sd s dentry if dentry the following parts are detected as clones spin lock dcache lock spin lock dentry d lock if !
d unhashed dentry dentry d inode dget locked dentry d drop dentry spin unlock dentry d lock spin unlock dcache lock ...... file linux .
.
drivers infiniband hw ipath ipat h fs.c struct dentry tmp tmp lookup one len name parent strlen name spin lock dcache lock spin lock tmp d lock if !
d unhashed tmp tmp d inode dget locked tmp d drop tmp spin unlock tmp d lock spin unlock dcache lock ...... figure .
a sample bug missing null check revealed by cont extual inconsistency among clones in a clone group from the l inux kernel compare lines in code fragment with lines in code fr agment .
g code clone code clone file linux .
.
fs nfsd nfs3xdr.c if !
p decode fh p args fh !
p decode filename p args name arg s len !
p decode sattr3 p args attrs return file linux .
.
fs nfsd nfsxdr.c if !
p decode fh p args ffh !
p decode fh p args tfh !
p decode filename p args tname ar gs tlen return file linux .
.
drivers hwmon lm87.c if err device create file new client dev dev attr in6 input err device create file new client dev dev attr in6 min err device create file new client dev dev attr in6 max goto exit remove file linux .
.
drivers hwmon gl520sm.c if err device create file new client dev dev attr in4 input err device create file new client dev dev attr in4 min err device create file new client dev dev attr in4 max goto exit remove files g code clone code clone file linux .
.
fs nfsd nfs3xdr.c if !
p decode fh p args fh !
p decode filename p args name arg s len !
p decode sattr3 p args attrs return file linux .
.
fs nfsd nfsxdr.c if !
p decode fh p args ffh !
p decode fh p args tfh !
p decode filename p args tname ar gs tlen return file linux .
.
drivers hwmon lm87.c if err device create file new client dev dev attr in6 input err device create file new client dev dev attr in6 min err device create file new client dev dev attr in6 max goto exit remove file linux .
.
drivers hwmon gl520sm.c if err device create file new client dev dev attr in4 input err device create file new client dev dev attr in4 min err device create file new client dev dev attr in4 max goto exit remove files figure .
false positive clone groups in linux kernel.
each r ow is a pair of inconsistent clones which do not correspond to bugs.
each pair of clones involve the same numbers of ifstatements operators function calls and assignments.
table i informal illustration refinement process case without refinement jack is presented with bug reports.
he investigates the fi rst and can find five true positives.
if the bugs are mission critical it s wo rth the effort.
case with refinement jack is presented with bug reports.
as he navigates throu gh the bug reports and labels each of them as true bugs or false positives the sy stem automatically reorders the remaining unlabeled bug reports.
he can now find ten true positives after investigating reports.
jack s productivity in fin ding bugs is doubled.
of all anomaly reports.
thus we provide a feedback loop between bug detection tools and developers and help to improve the quality of anomaly reports and reduce the effort of manual investigation.
as an informal illustration consi der two scenarios in table i. now we describe how this active refinement of anomaly reports could be performed.
conceptually we divide the space of possible clone groups into four quadrants as shown in figure .
the columns separate clone groups that have inconsistencies from those that do not the rows separate clone groups that allow variations i.e.
flexible from those that do not i.e.
rigid .
a rigid clone group is a set of clones where variations among clones are harmful a flexible clone group is a set of clones where variations are benign1.
current clone based anomaly detection tools would separat e clone groups in the two quadrants on the left from those in the two quadrants on the right.
however clone groups in the bottom left quadrant would be all false positives since the inconsistent changes in those clones are allowed or intentional and should not be reported as anomalies.
the 1both notions allow gapped clones and are orthogonal to the c oncept of gapped clones.rigid flexible inconsistent consistent true positive figure .
clone group s four quadrants goal of our approach is to learn a discriminative model to provide the likelihood of a clone group belonging to the top left quadrant i.e.
rigid but inconsistent versus belonging to the bottom left quadrant i.e.
flexible and inconsistent .
then this model can be used to re sort the list of anomaly reports and make true positives appear earlier in the list.
we observe that false positives could be similar to one another in certain ways.
for example consider the code snippets in figure containing two clone groups with two clones each.
all of code snippets involve the same number ofifstatements operators function calls and assignments but they are quite different from the true positive shown in figure .
thus the intuition of our approach is that false positives may have similar characteristics amon g themselves but they have different characteristics from t rue positives and differences between false and true positive s could be leveraged to build a discriminative model.
in order to characterize the similarities and differences among clones we convert each clone group into a set of features.
these features are built from the various syntact ical patterns in the clones of each group.
a discriminative model is a composition of features that collectively capture the d ifferences between false and true positives.
often such model s are built from a fixed static training dataset e.g.
.
however in our bug refinement process the training398dataset is incrementally updated as a new anomaly report is inspected and marked by a developer as either a false or true positive and we would like to build our discriminative model based on such a dynamic training dataset.
we propose a framework consisting of a refinement engine that leverages user feedbacks and is iteratively invoked.
people need to take action on anomaly reports to either get bugs fixed or discard them.
our feedbacks are from such actions and no extra effort is needed.
the refinement engine is composed of a feature extractor a pre processor and a classifier arranged in a pipeline.
it takes in the feedbacks given so far to build and refine discriminative models.
the resultant discriminative model in each iteration is used to refine the remaining uninvestigated anomaly reports.
we evaluate our framework on three sets of clone anomaly reports for three large programs the linux kernel c eclipse and argouml java extracted by a clonebased anomaly detection tool.
our evaluation shows that compared to the original ordering of bug reports we can improve the average percentage of true positives found an evaluation metric adopted from the test case prioritizatio n community by and for the linux kernel eclipse and argouml respectively.
the main contributions of this work are as follows .
we present the topic of refining clone anomaly reports.
.
we propose an active learning approach to incrementally refine anomaly reports with user feedbacks.
.
we present an engine that learns discriminative models that can assign the likelihood of each anomaly report being a false positive.
.
we evaluate our proposed approach on three large systems the linux kernel eclipse and argouml with promising results.
this paper is organized as follows.
we describe related work in section ii.
in section iii we review the concept of clone based anomaly detection.
in section iv we describe our overall active refinement framework which iteratively invokes a refinement engine.
we elaborate this engine in section v. our evaluation metric is described in section vi.
in section vii we describe our evaluation results on three large software systems.
we conclude and mention potential future work in section viii.
ii.
r elated work there are many studies in software engineering that are related to our work.
we summarize them in the following.
code clone analysis and clone based bug detection code clones have been widely studied in the literature.
some studies focus on detection of code clones based on similarities among strings tokens syntax trees depende ncy graphs and even functionalities .
clones are traditionally thought as harmful and technique s have been proposed to reduce clones .
on the other hand some studies show that clones can be usefuland necessary .
then instead of reducing clones some studies investigate techniques to track and manage code clones .
one important use of code clones is to detect bugs.
a number of studies detect bugs by detecting inconsistencies among clones .
such inconsistencebased detection of clone related bugs often produces many false positives and uses various filtering rules to reduce false positives.
however even with the most recent filterin g techniques such as ones based on textual similarity and sequence alignment false positive rates remain high.
compared with these studies that use filtering based approaches to remove reports which may cause false negatives our approach actively and incrementally refines and reranks anomaly reports based on user feedbacks without removing any report.
the code features used in our reranking are also different from those papers.
our work is not an alternative but rather a complement of others.
filterin gbased approaches which still leave many false positives behind may be applied first then our work refines the filtered reports as users take actions e.g.
to fix an anomaly if it is a true positive.
bug prediction and triage many studies aim to predict whether certain code changes or files may contain faults.
kim et al.
use bug history to predict faults.
ruthruff et al.
use logistic regression models from historical data to predict whether a warning generated by findbugs is actionable.
zimmermann et al.
have studied the accuracies of bug prediction models that may be used across various projects in various domains.
other studies aim to reduce similar bug reports or prioritize bug reports.
podgurski et al.
group software failures with similar symptoms together.
kremenek and engler propose z ranking to order bug reports produced by a static program checking analysis tool.
heckman and william propose faultbench a benchmark for evaluating alert prioritization and classification techniques.
these ranki ng models only perform reordering of bug reports once.
our approach is different from the above studies in several aspects.
we focus on anomaly reports generated by a clonebased anomaly detection tool instead of reports from users .
wereorder anomaly reports while most other studies filter reports.
filtering anomaly reports carries a risk of removi ng true positives.
filtering and reordering are complementar y as we could first filter and then re order anomaly reports.
some studies leverage historical data to prioritize anomaly reports while we leverage immediate user feedbacks to iteratively prioritize clone based anomaly reports.
iii.
c lone based anomaly detection clone based bug detection techniques are based on code clone detection and the concept of contextual consistency .
the intuition behind the technique is that code399clones should be inherently similar to each other and incon sistent changes to the clones themselves or their surroundi ng code which are called contexts may indicate unintentional changes bad programming styles and bugs.
the technique in is summarized as follows it uses a code clone detection tool d eckard to detect code clones in programs.
the output of this step is a set of clone groups where each clone group is a set of code pieces that are syntactically similar to each other a.k.a.
clones then it locates the locations of every clone in the source code and generates parse sub trees for them next it detects inconsistencies among the parse trees of the clones and their contexts e.g.
whether the clones contain different numbers of unique identifiers and how the language constructs of the contexts are different.
the inconsistencies are then ranked heuristically based on their potential relationship with bugs.
inconsistent clones unlike to be buggy are also filtered out.
finally it outputs a list of anomaly reports each of which indicates the location of a potential bug in the source code for developers to inspect.
it has been reported that this technique has high false positive rates even though it can find true bugs of diverse characteristics that are difficult to detect by other techni ques.
for example among more than reported bugs for the linux kernel only 41are true bugs and another 17are bad programming styles among more than reported bugs for the eclipse only 21are true bugs and 17are issues with bad programming styles .
iv.
o verall refinement framework a typical clone based anomaly detection system performs a single batch analysis where a static set of anomaly or bug reports ordered or unordered are produced.
it requires no or little user intervention e.g.
setting some parameters but may produce many false positives.
to alleviate this problem we propose an active learning approach that can dynamically and continually refine anomaly reports based on incremental user feedbacks each feedback is immediately incorporated by our approach into the ordering of anomaly reports to move possible true positive reports up in the list while moving likely false positives towards the end of the list.
our proposed active refinement process supporting user feedbacks is shown in figure .
it is composed of five parts corresponding to the boxes in the figure.2let us refer to them as block to counter clockwise from left to right .
block represents a typical batch mode clonebased anomaly detection system.
given a program the system identifies parts of the program that are different from the norm where the norm corresponds to the common 2a square a trapeze and a parallelogram represent a process a manual operation and data respectively.anomaly detection system refinement engine refinement loop user feedback 4sorted bug reports first few bug reports figure .
active refinement process characteristics in a clone group.
then the set of anomalies or bugs i.e.
block is presented for manual user inspection.
we extend such typical clone based anomaly detection systems by incorporating incremental user feedbacks through the feedback and refinement loop starting at block followed by blocks and and back to block .
at blocks and a user is presented with a few bug reports and is asked to provide feedbacks on whether the reports he or she sees are false or true positives.
these feedbacks are then fed into our refinement engine i.e.
block to update the original or intermediate lists of bug reports.
with user feedbacks the refinement engine analyzes the characteristics of both false positives and true positives labeled by users so far and hypothesizes about other false positives and true positives in the list based on various cla ssification and machine learning techniques.
this hypothesi s is then used to rearrange the remaining bug reports.
it is possible that a true positive that is originally ranked low is moved up the list a false positive that is originally ranke d high is downgraded or pushed down the list.
the active refinement process repeats and users are asked for more feedbacks.
with more iterations more feedbacks are received and a better hypothesis can be made for the remaining unlabeled reports.
the ultimate goal of our refinement process is to produce abetter ordering of bug reports so that true positive reports are listed first ahead of false positives which we refer to as the bug report ordering problem .
with better ordering true positives can be identified earlier without the need to investigate the entire report list.
with less false positiv es earlier in the list a debugger can be encouraged to continue investigating the rest of the reports and find more bugs in a fixed period of time.
if all or most of the true positives can appear early a debugger may stop analyzing the anomaly reports once he or she finds many false positives.
v. r efinement engine this section elaborates our refinement engine further.
our refinement engine takes in a list of anomaly reports and refines it by reordering the reports.
each anomaly report is a set of code clones i.e.
a clone group which contain inconsistencies among the clones.
given a list of anomaly reports ordered either arbitrarily or with some ad hoc cri teria and user provided labels i.e.
true positives or false400input bug report list feature extraction from source code classification pre processing feature selection balancing reordered input discriminative model figure .
refinement engine positives for some of the reports our refinement process reorders unlabeled anomaly reports based on the predicted likelihood of each of them being true positives.
figure shows our refinement engine that is composed of mainly three blocks feature extraction pre processing includ ing feature selection and data balancing and classification.
the feature extraction is meant to transform each clone group into a set of features where each feature is simply a quantitative value that represents a certain property of t he code.
the set of features is also referred to as a data point .
in our case we apply feature extraction to each inconsisten t clone group reported by the clone anomaly detection tool and collect a set of data points a.k.a.
a dataset for all clone groups in the reported list.
this feature set is then fed to the preprocessor which analyzes the data points and may remove some features or data points from the dataset.
its goal is to smooth over data noise as much as possible before classification.
the classifier then takes a preprocessed dataset to mine a classification model that can discriminate features belong ing to one class from the other.
in our setting the two classes are false positive class and true positive class.
we use class labels false andtrue to indicate whether a clone group is a false or true positive.
this mined model in turn is used to predict the class labels of the reported clone groups that ha ve received no user feedback.
we also make our classification engine to provide the degree of likelihood for a clone group to be in each of the two classes which is used as a key to rank and sort unlabeled clone groups.
a. feature extraction our feature extraction block analyzes parse trees which are commonly used to represent programs written in various languages.
as a benefit it is easier to adopt our refinement engine to code written in different programming languages.
a parse tree node is labeled with different information to represent various program constructs e.g.
for switch et c. each clone is reported as a sub tree rooted in a particular node in a parse tree.
the feature extraction would constructparse trees for every reported inconsistent clone group and traverse the trees to collect features.
more specifically i t performs the following two steps tree construction for each clone in the anomaly reports we invoke a parser on the source file containing the clone to construct a parse tree for the file each node in the tree contains a label indicating its type e.g.
for if assignment etc.
.
then we locate the root node of the subtree that corresponds to the clone.
we refer to this subtree as a clone tree .
we also locate the first ancestor node of this subtree that corresponds to the containing scope of the clone in the source file and refer to the subtree rooted at this ancestor node as a clone ancestor tree .
clone ancestor trees correspond to more code than clone trees.
they may contain more information that could help decide whether an anomaly report is false or true positive.
thus we extract features from clone ancestor trees.
representing clone ancestor trees as features we define five sets of features that could be extracted from a clone ancestor tree namely basic pair proportionalbasic proportional pair and rich.
consider a clone group cg containing a set of clones corresponding to a set of clone ancestor trees the five sets of features are defined in definitions .
.
.
.
and .
.
rich features belong to the most comprehensive feature set that is a superset of the other four feature sets.
our engine would convert the clone ancestor trees into rich features.
definition .
basic features the basic feature set basic of a clone group cg is the set of type count pairs in which each pair contains a node type and the number of parse trees in cg having that particular type.
for example considering the trees in figure the basic feature set contains the following pairs an bracketle tcall an bracketri ht an bracketle tname an bracketri ht an bracketle texpr list an bracketri ht and an bracketle texpr an bracketri ht.
mathematically basic cg vextendsingle vextendsingle vextendsingle vextendsingle t cs where cs c cg c has a node of type t cs vextendsingle vextendsingle vextendsingle vextendsingle definition .
pair features the pair feature set pair of a clone group cg is the set of type count pairs in which each pair contains a pair of node types and the number of parse trees in cg having that particular pair.
for example considering the trees in figure the pair feature set conta ins the following pairs an bracketle tcall name an bracketri ht an bracketle tcall expr list an bracketri ht and an bracketle texpr list expr an bracketri ht.
mathematically pair cg vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle t1 t2 cs where cs c cg n1 n2 c.n1 n2are connected n1is of type t n2is of type t cs vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle definition .
proportional features basic the proportional basic feature set prop basic of a clone group cg is the set of type count pairs in which each pair contains a node type and the proportion of parse trees in cg having that particular type.
for example considering the trees in figure the prop basic feature set401code clone ... decode sattr3 p args attrs ... code clone ... decode filename p args tname args tlen ... type count call name expr list expr 2basic type count call name call exprlist expr list expr 2pair type proportion call name call expr list expr list expr prop pair type proportion call name expr list expr prop basic type value num avg .
other call name exprlist expr expr call name exprlist expr expr expr rich clone group figure .
feature extraction contains the following pairs an bracketle tcall an bracketri ht an bracketle tname an bracketri ht an bracketle texpr list an bracketri ht and an bracketle texpr an bracketri ht.
mathematically prbasic cg vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle t cs cg where cs c cg c has a node of type t cs vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle definition .
proportional features pair the proportional pair feature set prop pair of a clone group cg is the set of type count pairs in which each pair contains a pair of node types and the proportion of parse trees of cg having that particular pair.
for example considering the trees in figure the prop pair feature set contains the following pairs an bracketle tcall name an bracketri ht an bracketle tcall expr list an bracketri ht and an bracketle texpr list expr an bracketri ht.
mathematically prpair cg vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle t1 t2 cs cg where cs c cg n1 n2 c.n1 n2are connected n1is of type t n2is of type t cs vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle vextendsingle definition .
rich features the rich feature set rich of a clone group cg is the union of the basic pair prop basic prop pair feature sets plus two additio nal features the number of clones in cg num and the average size of the clones in cg avg .
for example considering the trees in figure the rich feature set is the union of other features sets plus two additional features an bracketle tnum an bracketri ht and an bracketle tavg .
an bracketri ht.
mathematically rich cg basic cg pair cg prbasic cg prpair cg num cg avg c cg.
c cg b. preprocessing we consider two pre processing options feature selection and dataset re balancing.
feature selection is to reducethe number of features by removing unimportant ones.
unimportant features are noise and are good to be removed.
also as our data contains much more false positives than true positives we need to re balance the dataset otherwis e the discriminative model would be biased to always label unknown reports as false positives.
feature selection various approaches have been proposed to select important features.
information gain has be en widely used to evaluate the usefulness of a feature e.g.
.
if we use cto denote the class labels true positive ve class vs. false positive and use fto represent a feature then information gain of fis defined as in eq.
.
ig c f h c h c f where h c summationtext ci ve p ci logp ci is the entropy andh c f summationtextp f summationtext ci ve p ci f logp ci f is the conditional entropy given the feature f. we select important features based information gain and the weka toolkit with its default configuration.
dataset re balancing to re balance the dataset we reduce the number of data points in the larger class.
we retain all data points in the smaller class.
for each data poi nt in the smaller class we find the most similar data points in the other class and retain it cosine similarity betwee n two feature sets corresponding to the two data points is used as the similarity measure.
other data points in the larger class are dropped.
this is motivated by the nearest neighbor approach by renieris and reiss that localizes bugs by comparing the nearest faulty and correct executions .
in their setting they also have the issue of imbalanced dataset correct executions are many more than faulty ones.
c. classification the classification block takes preprocessed datasets and learns a discriminative model that discriminates true posi 402tives from false ones.
we refer to the true and false positive s as class labels.
the purpose of a discriminative model is to take an unlabeled datapoint i.e.
a datapoint or an anomaly report that is not known to be a true positive or a false positive and assign a class label to it.
to produce a discriminative model the classifier learns from a given labeled training data points.
in our case the training data points are the clone reports that have been investigated by developers to be true positives or false positives.
in this paper we use a variant of nearest neighbor classification scheme namely nearest neighbor with non nested generalization nnge .
nearest neighbor classificati on has been proved successful for various tasks e.g.
.
al so this technique matches our intuition an instance similar t o known false positives is likely to be a false positive.
our initial study showed that nnge performs no worse than other common classification approaches.
we describe the technique in the following.
nearest neighbor with non nested generalization as its name suggests in nearest neighbor classification unknown data would be assigned with the same label as its nearest neighbor.
the time needed to build a model would be little as it only involves index building and distance calculation .
the nearest neighbor approach can not generalize or group several data points together which potentially reduces it s classification accuracy.
thus it has been extended with generalization .
rather than loading all data points in to the memory the training phase constructs multi dimension al rectangles i.e.
hyper rectangles that generalize a few data points in a multi dimensional space.
this approach has poor performance on some settings due to nested generalization i.e.
hyper rectangles are contained inside other hyper rectangles or overlap with one another .
martin addresses this issue by proposing nearest neighbor with non nested generalization nnge which we use in this work.
in particular we use the implementation available in weka with its default distance function.
in this work we extend nnge to output the likelihood for a data point dpto belong to each of the two classes i.e.
true positives t and false positives f .
let s refer to the set of exemplars the set of exemplars with label t and the set of exemplars with label f as d dt and df respectively.
also considering an exemplar d let sim dp d dist dp d where dist dp d is the distance between dpto the exemplar dwhich ranges from to .
our likelihood measure to re sort the bug reports is given by the following formula lh dp .
rs dp rs dp summationtext dt dtsim dp d t dt summationtext df dfsim dp d f df the lh measure corresponds to the normalized relative similarity of a datapoint dpto the datapoints in dtas compared to those in df.
bug reports with higher lh are more likely to be true positives and would be listed first.
d. concrete refinement process algorithm is the pseudo code of our refinement process.
it takes in several parameters the list of bug reports br from a bug detection tool the initial number of bug reports to be labeled k and the feedback pool size p .
the process would be bootstrapped by manually labeling the firstkbug reports which are used to train an initial model lines .
the classification model is then used to resort the unlabeled bug reports line .
the next top p reports are presented for user feedback lines .
we only repeat the refinement process after pnew feedback are obtained.
then the feedback are incorporated by learning a new discriminative model and applying it to the remaining unlabeled bug reports in the refinement loop lines .
when the false positive rate goes too high a user can choose to stop the refinement process lines .
with accumulated user feedback lines and the refinement process can incrementally improve the classification and ranking accuracy of the discriminative models so that true positives can be ranked higher.
algorithm clone report refinement process input br bug reports k initial set of bug reports to be labeled p feedback pool size output re ordered bug reports let bk select the first kbug reports label all bug reports in bk manual let fk features extracted from bk perform pre processing on fk let m classification model created from fk refine br using m let bp select the new top punlabeled bug reports ask for user feedback on bug reports in bp let fprate compute false positive rate if fprate is too high based on user feedback stop else set bk bk bp goto vi.
e valuation criteria in this section we define a suitable metric to measure the quality of the re sorted bug reports to evaluate the effectiveness of our active refinement process.
our refinement process is effective if it could re sort the reports such that all reports corresponding to true positiv es are listed first.
as an illustration consider a scenario whe re our refinement process starts with a set of klabeled bug reports and there are mtrue positive reports among the remaining unlabeled reports.
the ideal situation happens when all mother true positives are listed in the k thto k m thpositions after the refinement process.
the worst403case happens when the true positives are listed as the last mreports after refinement.
to measure the quality of the refinement process we adapt a measure proposed in test case prioritization area average percentage faults detected apfd .
there are a number of similarities between test case prioritization a nd our problem.
in test case prioritization test cases need to be sorted i.e.
prioritized in the order of their likelihood to reveal program failures.
also there is a need to measure and compare the quality of different test case orderings.
in a graph capturing the cumulative proportion of faults captured as more test cases are run is plotted.
apfd defined as the area under this curve measures the rate of fault detection .
in our work we use the same concept and plot a graph capturing the cumulative proportion of true positive s found as more anomaly reports are inspected by users.
we refer to this graph as the cumulative true positives curve .
in the cumulative true positives curve a larger area under the curve indicates that more true positives are found by developers early which means that the refinement process effectively re sorts the anomaly reports.
consider the sam ple graphs in figure and assume that there are five true positives among reports.
each of the five increments in each of the two cumulative curves corresponds to when each of the five true positives is found.
the left curve shows that true positives are found at positions and .
the right curve shows that true positives are found at positions and .
using the original list of reports left the developer could only find three true positives by investigating the first six reports.
using the refined list produced by the refinement process right five true positives are found in the first six reports.
hence by performing the same number of inspections which may correspond to the time budget a developer has in real world situations the developer could find more true positives using the refined report list as compared to the original one.
in this case the refined report list has a better true positiv e detection rate.
in the graphs this improvement is indicate d by a larger area under the curve for the refined report list.
the idea of using apfd as the evaluation criteria for bug finding is also used by kremenek and engler .
following the same idea we define average percentage true positives found appf as the area under the cumulative true positives curve .
our goal is to improve the appf score which measures the rate of true positives found.
we illustra te appf improvement computation in figure .
vii.
e mpirical evaluation in this section we describe our experimental settings our evaluation results and the threats to validity.
a. settings and results settings we evaluate our approach on clone based anomaly reports for three real programs written in differen t020 cumulative true positives curve true positives found bug reports investigated appf 100cumulative true positives curve true positives found bug reports investigated appf original appf improvement .
refined figure .
computing and comparing appf programming languages the linux kernel c eclipse and argouml java .
we analyze the reports generated by jiang et al.
.
we choose these reports as they contain a large number of false positives.
there are more than 800anomaly reports i.e.
clone groups for the linux kernel and only 57of them are true positives or programming style issues.
there are more than anomaly reports for eclipse and only 38of them are true positive.
there are more than anomaly reports for argouml and only 15of them are true positive.
finding a few true positives on the large number of false positives is a challenging task that would stress te st the usability of our approach.
the authors from have manually labeled all the reported inconsistent clone group s from the linux kernel and eclipse as either true positives or false positives.
we manually label the reported inconsiste nt clone groups from argouml.
we use these clone groups and their labels to simulate initial and incremental user feedbacks as inputs to our refinement engine.
the tool in returns the list of anomalies in a particular order.
we take the ordering returned by the tool and refine it.
following the steps in section v we initially take the first k labeled clone groups.
we set kto be since there is only one true positive among the first 50bug reports for eclipse.
we also use k for the linux kernel.
since there are only inconsistent clone groups reported for argouml we set kto be for argouml.
we set the feedback pool size i.e.
p to be .
we thus iteratively refine the bug reports as each feedback is received.
in this paper we repeat the refinement process until all anomaly reports are inspected.
evaluation results we improve appf by and for the linux kernel eclipse and argouml bug reports respectively.
these measures mean that within a limit period of time a developer investigating the anomaly reports may find more true positives in the linux kernel eclipse and argouml.
the improvement for the linux kernel is not as much as eclipse and argouml.
the bugs in the linux kernel often involves identifier changes e.g.
variations in variable names function names type names etc.
which are not captured well by our feature sets which are mostly based on syntactical node types while the bugs404table ii top r e orderings .x mapsto ymeans that a report of a true positive at position xis reordered to position y. system top re orderings linux mapsto mapsto mapsto mapsto mapsto eclipse mapsto mapsto mapsto mapsto mapsto argouml mapsto mapsto mapsto mapsto mapsto table iii top3 features based on their information gain linux kernel .
the symbol is the separator between two features for a pair feature set .
thepsuperscript denotes a proportional feature .
top feature info.
gain extdefp0.
extdef 1p0.
program extdefsp0.
in eclipse and argouml often involve conditionals which may be better captured by our features.
in future we plan to add more features to construct better discriminative model s for linux and more programs.
the top successful re orderings for the linux kernel eclipse and argouml are shown in table ii.
we highlight sample bugs that are successfully reordered.
figure shows a buggy clone group in linux that is reordered from position to .
the bug is related to an early unlock of a variable.
figure shows a bug from eclipse that is successfully reordered from position to .
the bug is similar to the bug in figure it misses a null check in code fragment and was reported to developers and fixed.
for argouml a bug shown in figure is reordered from position to .
this bug is related to a missing validation before a variable is used in the next statement.
to further investigate which program elements i.e.
features as described in section v a may be better bug indicators than others we compute the information gain of each feature in linux and eclipse bug reports.
information gain is frequently used to find important features that differentiate two contrasting datasets i.e.
in our case true positives and false positives e.g.
.
the top features for linux kernel eclipse and argouml are shown in table iii iv and v. we notice that the individual features have low information gain.
thus individually they are not able to distinguish true positive s from false positives.
however composing them into a discriminative model is more effective in improving the rate of true positives found.
from the list one could intuitively i nfer that if a clone from eclipse involves inconsistent changes related to conditionals it is more likely to be buggy.
for argouml the inconsistent changes that involve variable declaration and initialization are more likely to be buggy e.g.
a declared variable being used without further valida tion or checking null checking a variable needs to be converte d to an appropriate type etc.
as discriminative features usinginformation gain could mean that the features are eithertable iv top3 features based on their information gain eclipse .
the bsuperscript denotes a basic feature whilepsuperscript denotes a proportional feature top feature info.
gain bool or tkp0.
conditional orexpression .
conditional orexpressionp bool or tkb0.
table v top3 features based on their information gain argouml top feature info.
gain local variable declaration statementb0.
variable initializerb0.
block statement .
local variable declaration statementb highly related to buggy clone or highly related to nonbuggy clone in linux kernel if a clone involves inconsiste nt changes related to global definitions e.g.
extdef it is more likely not a bug.
overall our approach helps to better separate false positives from true bugs making first listed anomaly reports closer towards the top left cell of the ideal four quadrants of figure .
b. threats to validity threat to construct validity corresponds to the suitablene ss of our evaluation metric.
in this study we adapt a measure commonly used in test case prioritization which also needs to re sorts i.e.
prioritize test cases.
their goal is to find an optimal ordering of test cases that would identify the failures early.
they measure the quality of an ordering usin g average percentage faults detected apfd .
we propose a similar measure referred to as average percentage of true positives found appf .
similar like apfd that measures the rate of fault detection appf measures the rate of true positives found.
we believe this measure is relevant in measuring the performance of a refinement framework.
a higher appf score indicates that within the same period of time a developer can find more true positives.
threat of internal validity corresponds to the ability of ou r experiments to link the independent and dependent variable s. the threat could be manifested due to experimental or human errors.
the labels of the bug reports are decided manually by the authors of .
the labeling might be prone to errors.
still the authors of and us have taken some precautions to prevent these to happen at least two people are assigned to label each of the inconsistent clone group for any discrepancy a third person would break the tie.
threat of external validity corresponds to the generalizability of our result.
we have performed a study on three large real systems that are written in two most popular programming languages c and java.
although these help there is still a threat to external validity.
in the future we plan to investigate more systems written in various programming languages.405code fragment code fragment file linux .
.
drivers net wireless bcm43xx bcm 43xx sysfs.c struct bcm43xx private bcm dev to bcm dev ... mutex lock bcm mutex switch bcm43xx current phy bcm type case bcm43xx phytype a ... default assert mutex unlock bcm mutex file linux .
.
drivers net wireless bcm43xx bcm 43xx wx.c struct bcm43xx private bcm bcm43xx priv net d ev ... mutex lock bcm mutex mode bcm43xx current radio bcm interfmode mutex unlock bcm mutex switch mode case bcm43xx radio interfmode none ... default assert .. figure .
report of a true positive in linux that is reordered from position to code fragment code fragment file eclipse cvs20070108 org.eclipse.debug.core co re org eclipse debug internal core launchconfiguration.jav a if file !
null validate edit if file.isreadonly istatus status resourcesplugin.
getworkspace .validateedit new ifile file nul l if !status.isok throw new coreexception status ...... file eclipse cvs20070108 org.eclipse.debug.core co re org eclipse debug internal core launchconfigurationwork ingcopy.java ...... validate edit if file.isreadonly istatus status resourcesplugin.
getworkspace .validateedit new ifile file nul l if !status.isok throw new coreexception status ...... code fragment code fragment file eclipse cvs20070108 org.eclipse.debug.core co re org eclipse debug internal core launchconfiguration.jav a if file !
null validate edit if file.isreadonly istatus status resourcesplugin.
getworkspace .validateedit new ifile file nul l if !status.isok throw new coreexception status ...... file eclipse cvs20070108 org.eclipse.debug.core co re org eclipse debug internal core launchconfigurationwork ingcopy.java ...... validate edit if file.isreadonly istatus status resourcesplugin.
getworkspace .validateedit new ifile file nul l if !status.isok throw new coreexception status ...... figure .
report of a true positive in eclipse that is reorder ed from position to code fragment code fragment2 file argouml src argoumlapp src org argouml uml diagram umlmutablegraphsupp ort.java if edge instanceof commentedge ... else if model.getfacade .isarelationship edge model.getfacade .isatransition edge model.getfacade .isaassociationen d edge return model.getumlhelper .getdestination edge else if model.getfacade .isalink edge .. file argouml src argoumlapp src org argouml uml diagram umlmutablegraphsupp ort.java if edge instanceof commentedge ... else if model.getfacade .isaassociation edge list conns new arraylist model.getfacade .getconnections edge return conns.get else if model.getfacade .isarelationship edge model.getfacade .isatransition edge model.getfacade .isaassociationen d edge return model.getumlhelper .getdestination edge else if model.getfacade .isalink edge .. figure .
report of a true positive in argouml that is reorde red from position to viii.
c onclusion and future work code clones have been widely studied in the literature.
various techniques have been proposed to recover clones from a code base.
one important usage of clones is to find bugs by detecting inconsistencies among members of the same clone group.
these correspond to bugs that might arise due to inconsistent updates among parallel code fragments or violation of a common programming practice.
past techniques e.g.
have demonstrated the ability of clonebased bug detection tools to detect true positives in large systems.
however often the number of false positives are too many.
this could affect the usability of such a system as a developer could spend a lot of time in performing a debugging activity which at the end might be futile as the reported anomaly is a false alarm.
our work tries to address this issue by proposing an approach to automatically refine bug reports by the incorporation of user feedback.
rather than having a static sorted list of bug reports our bug reports are dynamic .
as a user investigates the top few bug reports and feedback to the system the system automatically re sorts the remaining uninvesti gated bug reports and thus refines it.
this refinement processis performed multiple times as more feedback is available.
for each refinement we perform feature extraction preprocessing feature selection and dataset re balancing and discriminative model learning.
to evaluate the quality of a list of ordered bug reports we use average percentage of true positives found appf which measure the rate true positives are found.
we evaluate our refinement process on three sets of clone based anomaly reports from three large real programs the linux kernel c eclipse and argouml java extracted by a clone based anomaly detection tool.
the results show that compared to the original ordering of bug reports we can improve appf by and for linux kernel eclipse and argouml respectively.
as future work we plan to extend our approach to refine not only clone based anomaly reports but also other types of anomaly reports.
we also plan to investigate the applicabil ity of models learned from one or more software systems to refine bug reports of other software systems.