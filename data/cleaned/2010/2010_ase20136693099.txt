dynamically transforming data structures erik osterlund software technology group linnaeus university v axj o sweden erik.osterlund lnu.sewelf l owe software technology group linnaeus university v axj o sweden erik.osterlund lnu.se abstract fine tuning which data structure implementation to use for a given problem is sometimes tedious work since the optimum solution depends on the context i.e.
on the operation sequences actual parameters as well as on the hardware available at run time.
sometimes a data structure with higher asymptotic time complexity performs better in certain contexts because of lower constants.
the optimal solution may not even be possible to determine at compile time.
we introduce transformation data structures that dynamically change their internal representation variant based on a possibly changing context.
the most suitable variant is selected at run time rather than at compile time.
we demonstrate the effect on performance with a transformation arraylist data structure using an array variant and a linked hash bag variant as alternative internal representations.
using our transformation arraylist the standard dacapo benchmark suite shows a performance gain of .
in average.
i. i ntroduction picking the right data structure implementation for a given task can be tedious and time consuming.
programmers tend to optimize for the worst case.
however the data structure performing best in the worst case may however perform worse in the actual execution contexts because of higher constants.
also programmers tend to use the data structure implementations that scales better for large problem sizes.
analyzing the break even points where one implementation outperforms another is difficult and depends on the target hardware that is usually unknown at program design time.
and even with such a break even point at hand it is difficult to program dynamic switching between implementations.
since the state of a data structure needs to be copied from one implementation to another dynamic switching takes time itself which makes an analysis of break even points even harder.
hence programmers would benefit from a library of data structures finding these break even points and switching between the expectedly best implementation automatically.
the semantics of certain high level languages don t allow programmers to be precise in their choice of data structure .
javascript for instance has an associative array used both as an array with indices and associative collection with key value pairs.
these more abstract data structures implemented as part of programming languages also benefit from dynamic selection of the internal implementation depending on how it is being used.
finally in a multithreaded environment the choice of data structure implementation may depend on contention from dif ferent threads.
if contention is very high it may be beneficial to use a lock free or wait free data structure implementation rather than an implementation using semaphores.
likewise if contention is low or synchronization is not needed another implementation could be more beneficial.
since contention is a property that can change throughout program executions so is the optimal data structure implementation.
context aware composition approaches these optimization problems dynamically at run time by profiling the variant s performance in different usage contexts learning a dynamic dispatcher and selecting the expectedly best implementation for an actual context at runtime.
context attributes include e.g.
the number of cores available size and type of input contention memory usage etc.
one and the same abstract operation could be implemented with different algorithms depending on the current data structure implementation.
hence the current data structure implementation is just another context attribute for selecting the appropriate algorithm implementing an operation.
alternatively the data structure implementation can adapt to the operation to be executed.
so in general both the abstract operation to be invoked and the current data structure implementation are context attributes for the selection of the appropriate algorithm and appropriate data structure implementations.
in short the choice of an algorithm can be delayed to run time as well as the choice of the data structure implementation while preserving the same operation and data structure semantics to the outside world.
these capabilities of context aware composition were demonstrated before varying the data structure operations and their implementation algorithms as well as data structure state representations context attributes and online offline learning scenarios.
this study adds three aspects we introduce transformation data structures that encapsulate variants of its operation implementations algorithms and state representations behind a well defined interface.
based on context aware composition they switch between different algorithms and representations without changing its functional behavior.
transformation data structures consider operation sequences rather than individual operations for selecting the expectedly best fit data representation variants.
these sequences are abstracted with states of finite state machines making the maintenance of the actual usage978 .
c ieee ase palo alto usa410 context affordable compared to the gain of selecting the appropriate variant for each such context.
we implement a transformation data structure derived from a standard api data structure and evaluate its performance using a standard performance benchmark suite.
this goes beyond previous evaluations in experiments designed for showing the potential benefits of context aware composition.
here we do neither control the application usage context nor the importance of the data structure for the overall performance of the benchmark applications.
more specifically an arraylist for java that transforms between an array based variant and a linked hash bag variant is used as an example showing more than on average performance gain in an evaluation against the dacapo benchmark.
the remainder of this paper is organized as follows.
section ii explains the design ideas behind efficient transformation data structures and discusses implementation details necessary for high performance.
section iii discusses a case study using these ideas.
section iv shows how our implementation performs in practice in a standard benchmark suite.
finally section v discusses related work and section vi concludes the paper and motivates directions of future work.
ii.
t ransformation of data structure design and implementation a. general design let a data structure consist of an abstract data representationrand a set of abstract operations ooperating on this data.
the abstract data representation captures the state of the data structure.
therefore rdefines data access operations r w for state construction and for reading and updating the state.
the abstract data representation rallows for different data representation variants .
data representation variants are specializations of the abstract data representation i.e.
access operations r w may have stronger pre conditions in the implementation or not even implement all access operations.
the abstract operations oof a data structure may come in variants too.
we refer to these variants to as algorithm variants .
one and the same abstract operation ocan be implemented with different algorithms.
again the algorithm can be a specialization of the operation.
for correctness of the data structure we must require though that for each abstract operation its preconditions imply the disjunction of all implementing algorithms preconditions.
then for each legal call to an abstract operation there exists an algorithm variant that handles the call.
this can usually be achieved with a possibly inefficient default algorithm for each operation.
the benefit of special data representation variants and algorithm variants is that they can be faster in special contexts under special pre conditions than a general implementation.
in order to exploit this potential benefit in practice we must solve three problems first we need a design for changing the data representation variants and algorithm variants respectively at runtime.
second we must be able to find the operation abstract execute ... operation algorithm execute ... operation algorithm m execute ... operation algorithm representation constructthis representation representation this data structure transformation data structure changeto newrepr set operation algorithm operation ... ... set operation n algorithm operation n ... representation newrepr constructthis representation implementation constructthis representation implementation k constructthis representation operation algorithm execute ... fig.
.
transformation data structure.
uml diagram of the design pattern.
the actual implementation design could be different e.g.
for improving access performance an algorithm could know a data representation variant directly.
expectedly best variants for each usage context.
third we need to efficiently switch between the variants and efficiently transfer state between them.
the first problem is solved by a general design pattern as proposed in and depicted in figure .
it uses a combination of the well known bridge andstrategy design patterns .
the data structure holds a reference to a current representation that is an instance of an abstract representation class.
different data representation variants inherit from the abstract one.
besides the data access operations readers writers iterators constructors etc.
a data representation variant implements aconstructthis operation which constructs an instance of this variant from the general one and hence from any other variant.
therefore some core data access functions e.g.
a read iterator must be available in any data representation variant.
the data representation variant can be changed by achangeto operation which creates a new empty instance of the desired data representation variant and reconstructs the state using its constructthis operation.
also the data structure holds