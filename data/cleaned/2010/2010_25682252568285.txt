case studies and tools for contract specifications todd w. schiller kellen donohue forrest coward michael d. ernst university of washington seattle wa usa tws kellend fmc3 mernst cs.washington.edu abstract contracts are a popular tool for specifying the functional behavior of software.
this paper characterizes the contracts that developers write the contracts that developers could write and how a developer reacts when shown the difference.
this paper makes three research contributions based on an investigation of open source projects use of code contracts.
first we characterize code contract usage in practice.
for example approximately three fourths of the code contracts are basic checks for the presence of data.
we discuss similarities and differences in usage across the projects and we identify annotation burden tool support and training as possible explanations based on developer interviews.
second based on contracts automatically inferred for four of the projects we find that developers underutilize contracts for expressing state updates object state indicators and conditional properties.
third we performed user studies to learn how developers decide which contracts to enforce.
the developers used contract suggestions to support their existing use cases with more expressive contracts.
however the suggestions did not lead them to experiment with other use cases for which contracts are better suited.
in support of the research contributions the paper presents two engineering contributions celeriac a tool for generating traces of .net programs compatible with the daikon invariant detection tool and contract inserter a visual studio add in for discovering and inserting likely invariants as code contracts.
categories and subject descriptors d. .
requirements specifications general terms software engineering keywords specifications design by contract invariant detection .
introduction contracts are a popular tool for formally specifying the functional behavior of software .
a method s contracts describe what must be true when the method is called the method s precondition and given that the method is called correctly what must be true when the method returns the method s postcondition .
additionally for object oriented languages contracts can describe object invariants properties that must hold for an object whenever it is visible.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
icse may june hyderabad india copyright acm ... .
.contract based specifications share many similarities with and are complementary to other development practices such as modeling and testing.
in particular the rising popularity of parameterized testing and mocking frameworks has pushed testing toward specification conversely contracts provide a powerful semantic basis for test creation .
contracts can additionally augment or even automate refactoring debugging program repair and verification .
to maximize benefit to developers contract frameworks should enable developers to express semantically interesting properties with minimal annotation burden.
tools should be able to make use of the additional semantic information yet still produce meaningful results without a full functional specification.
a key observation in meeting these goals is that contract semantics are only partially determined bysyntax tooling design and assumptions e.g.
defaults also contribute to contract semantics.
the aim of this paper is to guide the design of contract languages and tools by providing information about how developers use contract style specifications.
while this paper focuses on microsoft code contracts hereafter just code contracts the ideas are also applicable to other contract languages and tools.
contributions.
this paper makes three research contributions based on an analysis of open source projects using code contracts and an in depth investigation of four of the projects use of code contracts we identify that developers use simple contracts but underutilize expressive contracts for state update constraints checking object state and conditional properties implications .
for example of the projects code contracts are basic checks for the presence of data e.g.
non null checks and another of contracts of all postconditions repeat field assignments and return expressions from the code.
we present evidence that annotation burden tooling and training are primary factors affecting the extent to which developers use contracts as specifications as opposed to argument validation assertions.
we performed two case studies of how developers react when shown what contracts they could write.
the developers used the contract suggestions to capture more expressive contracts to support existing use cases.
however the suggestions did not lead the developers to explore new use cases for which contracts are well suited.
for example one developer who had not previously written object invariants did not accept any of the suggested object invariants.
based on the results we recommend that contract language and tool designers take three complementary actions introduce tooling to reduce annotation burden make suggestions an in permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
copyright is held by the author owner s .
publication rights licensed to acm.
icse may june hyderabad india acm table subject program summary.
the static checking column indicates whether the project developers actively use cccheck the static checker for code contracts.
the dynamic checking column indicates whether the developers use code contracts for run time checking in either debug or release builds.
the other tools column lists the other specification testing and code quality tools the developers use for the project.
projectsize sloc downloadsteam sizecode contracts introducedcode contract usestatic checkingdynamic checkingother tools labs framework 11k spring static checking stylecop1 mishra reader 19k 27k fall debugging concurrent code jetbrains r sando 24k winter early runtime error detection nunit3 quick graph 32k 75k documentation testing pex mstest tegral part of tooling and curate best practices by establishing design specification patterns.
reducing annotation burden is especially important to provide value to developers in the near term tools for static checking refactoring and testing with contracts are still relatively immature.
in support of the research contributions this paper presents two engineering contributions celeriac an open source tool for producing daikon compatible traces of .net binary executions and an open source visual studio add in for inserting dynamically inferred contracts into c software as code contracts.
inferring code contracts for .net programs required the development of features not included in previous daikon trace generators as well as modifications to daikon itself.
these include a static analysis for determining expression comparability support for multiple links between expressions for hoisting inferred preconditions and postconditions to object invariants and interface contracts and more fine grained immutability tracking.
this paper proceeds as follows.
section introduces four subject projects that will be referred to throughout the paper and describes each project s use of microsoft code contracts as reported by their developers.
section analyzes the developer written code contracts in programs with a focus on the four subject programs.
section characterizes the contracts that celeriac and daikon can infer for the subject programs contrasting these to the developerwritten contracts.
section reports on two case studies in which the project developers added additional code contracts to their own software using a visual studio add in that infers likely contracts from program traces.
section discusses implications with respect to the design of contract languages and tools.
section presents related work.
finally section concludes.
.
subject programs we selected code contracts as a subject framework because it has a sizable user base the extension has been downloaded over 49k times4.
code contracts also has a low barrier to entry due to its integration with the popular c language.
we automatically analyzed the open source c projects listed on ohloh5that use code contracts.
these projects contain .5m source lines of code sloc .
for context ohloh indexes 12m sloc of eiffel code across projects it indexes 568m sloc of c code across projects.
we performed a more detailed analysis of four of the projects.
we selected these projects because they were all actively developed used and employing contracts in a meaningful way.
additionally they are diverse in both application domain and their reason for code contracts.
table overviews each project s use of code contracts.
the following paragraphs describe each project s adoption of code contracts as reported by the project s developers via questionnaire and the additional skype interviews performed for mishra reader and sando as part of developer studies in section .
each paragraph additionally describes the project s use of other specification testing and code quality tools as they relate to the project s use of code contracts.
of particular significance is cccheck the static contract checker packaged with the microsoft code contracts framework.
the checker uses a modular abstract interpretation based analysis to report unsatisfied contracts and to suggest additional contracts.
to fully benefit from using cccheck developers must add contracts to all the code being checked as well as add contract stubs for method calls to external assemblies.
labs framework.
the labs framework6is a framework for managing experiments demonstrating the behavior of an api or library.
the static code contracts checker cccheck is enabled by default in the project.
the project does not include any formal unit tests instead relying on sample applications built with the framework.
mishra reader.
mishra reader7is a google reader client.
the lead developer introduced code contracts to the core library to help reduce bugs in multithreaded code.
the developers add code contracts after the methods are implemented to aid in debugging as opposed to design by contract .
at one point the developer considered abandoning code contracts due to a lack of support for debugging with contracts in async andawait constructs the bytecode rewriter did not properly modify the debugging information microsoft has since added debugging support for these constructs.
the team does not use cccheck citing that it is slow and issues too many false positive warnings.
sando.
sando8is a lucene based code search engine that includes a visual studio interface.
code contracts were introduced to the project because one of main contributors had seen a webinar on code contracts and wanted to try them.
the team primarily uses contracts in the core functionality.
in particular contracts are used in the index component because placing bad data into the index can result in later errors.
contracts are typically written after a change is made but before running the unit test suite prior to check in.
the developer we interviewed was not aware of the static checker for code contracts.
the project does not use any other static analysis tools in part because the team has limited build engineering resources.
code contracts is seen as offering additional quality assurance without requiring additional build engineering and likely makes the team less likely to try other quality assurance tools.
the developer we interviewed feels that code contracts has sped the discovery of bugs and regressions as well as increasing confidence in the quality of code containing contracts.
graph.
quick graph9is a data structure and algorithm library.
code contracts were introduced to the project to serve as documentation and for use in conjunction with the microsoft s pex white box testing tool which the quick graph developer also develops .
while the project has a single developer a member of the code contracts team contributed to the project by fixing contracts that were malformed but were erroneously considered valid by older versions of the toolset we included quick graph as an example of a well annotated project.
while as anticipated code contracts have led to the discovery of some bugs the developer has also found that using contracts has forced a cleaner api and has exposed bugs in the code contracts and pex tools themselves.
the project does not use cccheck since it was not ready for use when the developer was adding contracts.
.
developer written contracts this section characterizes the types of specifications that the developers of the subject projects captured using code contracts.
we aim to answer the following two questions research question .
.
what properties do developers use code contracts to enforce semantics ?
research question .
.
are developers able to efficiently express these properties using code contracts syntax ?
the developers predominately use contracts to perform argument validation consistent with polikarpova et al.
s observations .
approximately three fourths of the contracts just check for the presence of data an additional of contracts of all postconditions repeat field assignment and return statements from the code.
.
methodology we divided contracts into three general categories common case repetitive and application specific.
common case contracts enforce expected common program properties that data is present strings aren t blank collections aren t empty indices are in bounds and methods don t modify unrelated variables.
common case contracts often check for exceptional program behavior that produced a degenerate value e.g.
returning null instead of throwing an exception .
repetitive contracts repeat exact statements from the code that a method returns a field assigns a variable to a field or returns a specific value i.e.
the contract repeats the return expression .
application specific contracts enforce richer semantic properties valid argument values how state is modified the relation between expressions indicators of object state and conditions under which properties hold i.e.
implications .
common case and repetitive contracts are good candidates for language tool optimizations such as defaults and inference.
developer time is better spent writing expressive application specific properties.
similarly for developers concerned about code bloat common case and repetitive contracts can crowd out the semantically richer application specific contracts.
we wrote a roslyn10program to categorize each contract into the finer categories of table .
we ran the program on c projects .5m source lines of code that use code contracts.
the program available on the paper website categorizes each expression or toplevel conjunct in a requires ensures and invariant statement.
we manually refined the categorization rules by spot checking the results.
program looks only at the contract expressions themselves and errs on the side of categorizing a contract as application specific.
for example the program categorizes the contract idx as a lower upper bound contract rather than a bounds check even if the variable idxis used as an index in the body of the method.
this has the effect of making our assessment of the application specific nature of developer written contracts overly generous.
.
results table shows code contract content.
the projects had top level contract clauses across .5m source lines of code.
of those clauses were preconditions were postconditions and were object invariants.
out of all contract clauses just check for the presence of data cf.
rows nullness null blank and non empty .
for postconditions of the clauses are getter setter or return value specifications which are repetitive with the code cf.
the ens columns .
the following paragraphs describe other characteristics of the contracts including the use of special postcondition methods e.g.
oldvalue and object oriented features object invariant methods and contract classes .
these methods and features gain their semantics from the bytecode rewriting process.
object invariants and contract classes are particularly interesting because they allow developers to capture application properties that are true at multiple points in the program without significantly increasing annotation burden the contracts are automatically propagated by the bytecode rewriter.
labs framework.
the labs framework uses indicator properties more than the other projects.
indicator properties describe type state and or which methods and properties can be called.
contracts using indicator properties cf.
the indicator row in table refine the interface guarantee offered by the type system.
for example the labs framework uses checks for isenabled to specify methods that can only be called when a lab is active.
contracts over indicator properties convey rich semantic information with minimal annotation burden syntax .
additionally indicator properties provide a client method with a concise way to determine if when it can call the object s methods.
some contracts are lexically enclosed within ifpreprocessor conditionals impairing readability.
unlike other projects the contracts for the project differ based on the target platform checks for isnullorwhitespace are used when targeting the windows phone andisnullorempty are used for other targets.
recent support in the code contracts framework for contract abbreviator methods would enable the developer to refactor this pattern as a method call.
the project additionally makes use of special postcondition methods and the object oriented features of code contracts.
of particular note is the use of oldvalue to write frame conditions contracts stating that a method does not modify a certain field or argument.
these contracts are necessitated by the use of cccheck the checker depends on frame conditions to reason modularly about method calls.
mishra reader.
the mishra reader project primarily contains argument validation contracts cf.
the req column .
the developers chose to include the exception type to throw e.g.
argumentnullexception with precondition contracts making the contracts more informative.
no contracts are written for private methods since external input has already been validated the developer feels that these contracts do not add enough value to justify code bloat and run time overhead.
interface contracts i.e.
contract classes are provided for interfaces which primarily connect to external services google reader facebook and twitter .
however the special quantification and598table developer written code contracts.
the columns req uires ens ures and inv ariants correspond to preconditions postconditions and object invariants respectively.
the contracts counted for each category row are mutually exclusive.
the vast majority of preconditions written with code contracts simply check the presence of information the majority of postconditions ensure that information is produced or specify which information is produced.
section characterizes the contracts that the developers could have written as determined by contract inference.
subject program contract usage contract property example labs framework mishra reader sando quick graph projects req ens inv req ens inv req ens inv req ens inv med.
mean common case nullness arg !
null null blank !string.isnullorempty arg non empty list.count bounds check idx list.count frame condition this.fld oldvalue this.fld repetitive with code getter setter this.fld arg return value result t this.fld application specific constant this.fld lower upper bound count state update this.fld oldvalue this.fld expr.
comparison !arg1.equals arg2 membership list.contains elt indicator this.isenabled implication arg null arg.count other func arg1 func arg2 postcondition methods provided by code contracts are not used as highlighted by the fact that no contracts make use of quantification e.g.
contract.forall .
the lack of specifications for collection elements is consistent with the lack of contracts on private methods validation of all the elements inserted into the collection partially implies the collection specification without incurring run time overhead.
however as with private methods neither runtime checks nor the static checker can enforce that all elements are indeed validated before insertion.
additionally later modifications to the elements may violate the intended contracts for the collection.
sando.
the sando developers use contracts as though they were standard argument validation and assertions i.e.
debug.assert .
the project makes no use of contract classes or invariant methods.
as with mishra reader the project s contracts contain no use of code contracts s quantification expressions.
however in one location the c findall method is used to check that a property does not hold for any of the elements as opposed to contract.forall or contract.exists .
the lack of object oriented and code contractprovided methods indicates a lack of familiarity with the contract framework s features as was confirmed by the developer case study in section .
.
quick graph.
compared to the other projects quick graph includes a higher proportion of application specific contracts.
many of these enforce algorithmic properties such as the color of a node during edge coloring.
to express complex properties contracts include helper method calls and lambda expressions cf.
the other row .
in conjunction with logic connectives and the heavy weight syntax for special postcondition methods these make many contracts inscrutable to the untrained eye e.g.
contract.ensures !contract.result bool contract.valueatreturn ienumerable tedge out rslt !
null typeof tedge .isvaluetype enumerable.all contract.valueatreturn ienumerable tedge out rslt e e !
null the developer could extract the logic into a separate method to eliminate the need for multiple special postcondition method calls.as a data structure and algorithm library the project relies heavily on interfaces for graphs algorithms and collections.
of these interfaces are annotated with contracts.
however the project contains relatively few object invariants just objects include invariant methods.
these invariants are for collections classes heaps and the core graph abstractions.
they predominately express basic facts about nullness and that countable properties e.g.
edges are nonnegative.
more precise invariants are provided for the binaryheap andbidirectionalgraph classes however these are excluded via preprocessor macro by default since they are expensive deep invariants .
these excluded invariants are not included in table .
.
discussion there are material differences in contract usage across the projects.
these relate to the different use cases that contracts were supporting detecting one s own bugs vs. checking for ill behaved clients simple assertions vs. rich behavioral specifications etc.
one explanation for the differences in contract usage is that the developers using contracts for more than debugging e.g.
with cccheck or pex have greater incentive or are forced to write richer contracts.
an alternative explanation is that the developers inclined to use the other tools are also inclined to use contracts more extensively.
in either case a developer who underutilizes the special postcondition methods and object oriented features is missing out on exactly the features that make code contracts more powerful and more concise than standard argument validation asserts.
conciseness and annotation burden in addition to expressivity is important because it affects whether or not developers use tools that require relatively complete specifications such as cccheck .
the large number of nullness contracts relative to the other contract types suggests that nullness contracts may be crowding out application specific contracts that is the developers limited resources time lines of code etc.
are being consumed by writing nullness contracts.
nullness contracts do provide value since they guarantee that types are inhabited and therefore support the interface guarantees provided by the type system.
however since non null is the common case the annotation burden is difficult to justify.
.
contract inference this section reports on what code contracts could have been written in the subject programs.
we determined the potential contracts by running daikon on a trace of the program s execution this methodology mimics the practice of a developer inferring the contract for a program by generalizing how they see the program behave.
we use the results to explore two research questions.
research question .
.
to what extent are the contracts that developers could have written application independent semantics ?
the results indicate that in addition to writing numerous commoncase and repetitive contracts the developers of the subject programs could have written a higher proportion of application specific contracts particularly constraints on state updates indicator expressions and implications.
research question .
.
what are the differences qualitative and quantitative between developer written code contracts and the contracts that the developers could have written syntax and semantics ?
from the data in section and our own experience we hypothesized that developers disproportionately write basic contracts.
additionally polikarpova et al.
note that developers are typically worse at writing postconditions than preconditions .
the results support these expectations.
.
methodology as a proxy for determining which contracts could be written for the subject programs we used the daikon invariant detector to infer invariants.
daikon takes as input one or more execution traces and employs statistical methods e.g.
minimum support and confidence heuristics to infer likely method preconditions method postconditions and object invariants.
the contracts that daikon infers are sound with respect to the observed executions i.e.
it does not infer any properties that are falsified by any traces.
for each program we instrumented an assembly using the celeriac trace generator section .
and then ran the programs using tests or example inputs.
for the labs framework and quick graph we used the main assemblies.
for mishra reader and sando we used the assemblies that are the subjects of the developer case studies in section .
we generated a trace for the labs framework by running the labs for the rxx project11 mishra reader by using the application normally sando by running its integration test suite and quick graph by running a subset of the unit test suite excluding long running tests .
celeriac s sampling feature was used for the labs framework sando and quick graph to reduce run time.
section .
.
addresses the shortcomings of daikon and celeriac as they relate to this study.
.
celeriac .net trace generator to infer likely invariants for .net programs with daikon we built celeriac a tool that dynamically instruments .net binaries to produce daikon compatible program traces.
celeriac uses the cci metadata il rewriting library12to insert callbacks into managed c code the callback walks over data structures i.e.
fields and performs pure method calls.
since celeriac operates directly on a .net binary it can be used to generate traces without build integration.
the following subsections describe three features to support the unique challenges encountered when tracing .net programs and the improvements we made to daikon to support these features.
interface inference and behavioral subtyping code contracts enable a developer to strengthen the postconditions on a method implementing an interface or overriding another method.
this is compatible with behavioral subtyping.
it is a limitation of code contracts that they do not allow the developer to modify the precondition even though that would also be compatible with behavioral subtyping.
prior work has observed that daikon produces invariants that violate behavioral subtyping by not incorporating inheritance information .
to address this problem celeriac links arguments and fields to the corresponding arguments and members of any supertype interface.
the link information causes daikon to lift contracts that hold across all the implementations to the interface supertype.
we modified daikon to support multiple links per argument and field daikon previously used single links for encoding object invariant relationships.
we added a post processing step to daikon that discards the non lifted preconditions the implementation specific preconditions from the implementation methods.
.
.
comparability analysis by default daikon compares all values of the same primitive type and all