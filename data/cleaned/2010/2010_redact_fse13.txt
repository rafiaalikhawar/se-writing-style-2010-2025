preventing database deadlocks in applications mark grechanik b. m. mainul hossain ugo buy university of illinois at chicago chicago il drmark bhossa2 buy uic.eduhaisheng wang university of illinois at chicago and oracle corp. redwood city ca haisheng.wang oracle.com abstract many organizations deploy applications that use databases by sendingstructured query language sql statements to them and obtaining data that result from the execution of these statements.
since applications often share the same databases concurrently database deadlocks routinely occur in these databases resulting in major performance degradation in these applications.
database engines do not prevent database deadlocks for the same reason that the schedulers of operating system kernels do not preempt processes in a way to avoid race conditions and deadlocks it is not feasible to find an optimal context switching schedule quickly for multiple processes and sql statements and the overhead of it is prohibitive.
we created a novel approach that combines run time monitoring which automatically prevents database deadlocks with static analysis which detects hold and wait cycles that specify how resources e.g.
database tables are held in contention during executions of sql statements.
we rigorously evaluated our approach.
for a realistic case of over sql statements our algorithm detects all hold and wait cycles in less than two seconds.
we built a toolset and experimented with three applications.
our tool prevented all existing database deadlocks in these applications and increased their throughputs by up to three orders of magnitude.
categories and subject descriptors d. .
testing and debugging error handling and recovery h. .
systems concurrency general terms algorithms performance experimentation keywords database deadlock petri net hold and wait cycle dr.wang completed the work on this project when he was a postdoc in dr.grechanik s research group at the department of computer science university of illinois at chicago.
permission to make digital or hard copies of all or part of this w ork for personal or classroom use is granted without fee provided th at copies are not made or distributed for profit or commercial advantage and th at copies bear this notice and the full citation on the first page.
to cop y otherwise to republish to post on servers or to redistribute to lists re quires prior specific permission and or a fee.
esec fse august saint petersburg russia copyright acm ... .
.
.
introduction many organizations and companies deploy database centric applications dcas which use databases by sending transactions to them atomic units of work that contain structured query language sql statements and obtaining data that result from the execution of these sql statements.
when dcas use the same database at the same time concurrency errors are observed frequently that are known as database deadlocks which is one of the main reasons for major performance degradation in these applications .
the responsibility of relational database engines is to provide layers of abstractions to guarantee atomicity consistency isolation and durability acid properties however these guarantees do not include freedom from database deadlocks.
in general deadlocks occur when two or more threads of execution lock some resources and wait on other resources in a circular chain i.e.
in a hold and wait cycle .
even though database deadlocks occur within database engines and not within dcas that use these databases these deadlocks affect the performance of the combined software system i.e.
the dcas that interact with their databases.
a condition for observing database deadlock is that a database should simultaneously service two or more transactions that come from one or more dcas and these transactions contain sql statements that share the same resources e.g.
tables or rows .
in enterprise systems database deadlocks may appear when a new transaction is issued by a dca to a database that is already used by some other legacy dca thus making the process of software evolution error prone expensive and difficult.
there are two main reasons why preventing database deadlocks is a hard and open problem.
first databases are general tools that process arriving transactions on demand making it infeasible to find all hold and wait cycles statically.
second database engines are designed to execute transactions efficiently and imposing runtime analysis for finding all hold and wait cycles adds significant overhead.
in short database engines do not prevent database dea dlocks for the same reason that the schedulers of operating system kernels do not preempt processes in a way to avoid race conditions and deadlocks it is not feasible to find an optimal context switching schedule quickly for multiple processes and transactions and the overhead would be prohibitive.
currently database deadlocks are typically detected within database engines at runtime using special algorithms that analyze whether transactions hold resources in cyclic dependencies and these database engines resolve database deadlocks by forcibly break ing the hold and wait cycle .
that is once a deadlock occurs the database rolls back one of the transactions that is involved in the circular wait.
so effectively resolves the database deadlock this is why the database research community has considered this problem solved for a long time.
however thisresolution degrades the performance from the software engineering position since dcas should repeat the rolled back transactions to ensure functional correctness.
unfortunately this solution is only partially effective even though it is widely used as part of the defensive programming practice whereby programmers write special database deadlock exceptionhandling code that typicahandwgraphly repeats aborted transactions.
searching for database deadlock exception on the web yields close to web pages many of which instruct programmers how to handle database deadlock exceptions for different databases.
by the time that a database deadlock is resolved the damage to the performance of the dca is done since rolling back transactions issuing exceptions inside the dca and executing defensive code within exception handlers to retry aborted transactions incur a significant performance penalty.
our experiments show in section that database deadlocks result in up to three orders of magnitude of worsening performance of client server dcas when scaling the load up to only clients!
to make things worse when transactions are discarded the results of valuable and long running computations are lost as it is especially evident in case of multi level and long lived transactions .
our interviews with different fortune companies confirmed that database deadlocks occur on average every two to three weeks for large scale enterprise dcas some of which have been around for over years with an estimated annual cost of dca support close to 500k per company.
for instance database deadlocks still occur every ten days on average in a commercial large scale dca that handles over of cargo flight reservations in the usa.
major database vendors acknowledge this problem and they publish different advice to software engineers on how to avoid database deadlocks and how to handle exceptions that are thrown as result of aborted transactions.
these vendors also release tools that help these engineers debug and understand the causes of database deadlocks.
different database deadlock avoidance programming patterns help database designers and programmers structure their code transactions and data so that they can avoid database deadlocks .
for example microsoft oracle2and db2 published guidelines for minimizing database deadlocks in sql server oracle and db2 databases respectively showing that this problem has not been solved in major databases.
these guidelines include among others accessing database objects in some order that prevents forming cyclic dependencies with a drawback of losing parallelism and keeping transactions short and in one batch.
since these solutions are manual and error prone it is important to prevent database deadlocks automatically.
interestingly even if the cause of a database deadlock is understood it is often not possible to fix it since it would involve drastic redesign by changing the logic of the dca to avoid certain interleavings of sql statements among different transactions .
in addition fixing database deadlocks may introduce new concurrency problems and frequently these fixes reduce the occurrences of database deadlocks instead of eliminating them .
developers need approaches for preventing database deadlocks in order to achieve better performance of software but unfortunately there ar e no tools that prevent database deadlocks.
we created a novel approach that detects all hold and wait cycles among resources in sql statements and prevents database dead1 ms191242 v sql.
.aspx devguide cdevconcepts53677.htmlstep transaction t1 transaction t2 update authors set citations where paperid update titles set copyright where titleid select title titles where titleid select authorname from authors where paperid table example of a database deadlock that may occur when two transactions t1andt2are issued by dca s .
locks automatically using the information about these cycles.
this paper makes the following contributions.
we introduce our abstraction and a performance model that hide the complexity of database engines instead concentrating on abstract operations i.e.
read and write on resources e.g.
database tables and on how these operations lock and release these resources.
using our abstraction we developed a petri net model for representing transactions and we designed an algorithm to detect all hold and wait cycles in this model.
the algorithm returns exact execution scenarios that lead to database deadlocks thus enabling programmers to understand and analyze these scenarios.
we implemented our algorithm and evaluated it with a random sql generator and we showed that for an extreme case of transactions each containing sql statements i.e.
a total of sql statements it takes a little over .
hours for our algorithm to detect all hold andwait cycles.
for a realistic case of a large scale dca that contains transactions each of which includes a dozen of sql statements all cycles are found in less than two seconds.
using this information about hold and wait cycles we designed and built a supervisory control program that prevents database deadlocks by intercepting transactions sent by dcas to databases detecting a potential deadlock and delaying a conflicting transaction thereby breaking a deadlock cycle.
we implemented our approach in a tool and experimented using three client server dcas.
our tool prevented all existing database deadlocks in these dcas and increased their throughputs by approximately up to three orders of magnitude for clients.
our tool is publically available at .
.
the problem in this section we show how dcas use databases give an illustrative example of a database deadlock and formulate the problem statement.
.
an illustrative example consider the example of database deadlock shown in table .
transactions t1andt2are independently sent by dcas to the same database at the same time.
when the first dca executes gid2 gid15 gid1 gid3 gid13 gid10 gid5 gid7 gid8 gid9 gid1 gid11 gid10 gid6 gid4 gid9 gid1 gid2 gid16 gid1 figure a lock graph for the transactions shown in table .
the lock graph shows the hold and wait cycle t1 authors t2 titles t1.
theupdate statement in step the database locks rows of tableauthors in which the value of attribute paperid is .
next the second dca executes the update statement in step and the database locks rows of table titles in which attribute titleid is .
when the select statement in step is executed as part of transaction t1 the database attempts to obtain a read lock on the rows of table titles which are exclusively locked by transaction t2of the second dca.
since these locks cannot be imposed simultaneously on the same resource i.e.
these locks are not compatible t1is put on hold.
finally theselect statement in step is executed as part of transaction t2 the database attempts to obtain a read lock on the rows of tableauthors which are exclusively locked by transaction t1of the first dca.
at this point both t1andt2are put on hold resulting in a database deadlock.
once an algorithm within the database engine detects this hold and wait cycle the database engine resolves this database deadlock by aborting either the transaction t1or the transaction t2.
figure shows the lock graph for the transactions appearing in table .
transactions are depicted as rectangles and resources i.e.
tables are shown as ovals.
arrows directed towards resource s designate locks held by transactions on those resources arrows in the opposite direction designate transactions that are waiting to obtain resource locks.
the lock graph shows the hold and wait cycle t1 authors t2 titles t1.
the same reasoning applies if the granularity of locks is coarser for example at the table level when interleaving steps occur as shown in table a database deadlock is highly likely.
.
how dcas use databases many enterprise level dcas are written in general purpose programming languages e.g.
java they communicate with relational databases by using standardized application programming interfaces apis such as java database connectivity jdbc .
using jdbc programs pass sql statements as string parameters in api calls that send these sql statements to databases for execution.
for example the api call executequery of the class statement takes a string containing an sql statement that is sent to a database for execution.
once executed values of database attributes that are specified in sql statements are returned to dcas using jdbc s resultset interface.
these sql statements are executed as part of a transaction that is delimited by statements begin transaction by setting the connection s autocommit mode to false and end transaction with the subsequent api call commit .
in case a transaction is not explicitly delimited in the source code each sql statement is taken to be a separate transaction which may be committed automatically.
.
the performance model a performance model for analyzing the impact of database deadlocks is shown in figure .
this model uses a standard template for discrete time analysis in the performance evaluations of different systems .
using this model we pursue two goals to understand in which situation database deadlocks present a big performancetransactions arrivals results departures queue database gid4 gid2 gid1 gid4 gid3 gid1transactions exception handler figure performance model for database deadlocks.
problem rather than small inconvenience and to determine when our proposed solution will be most beneficial.
transactions arrive from dcas at the arrival rate a arrivals can be modeled as a normal distribution with some mean arrival time rate.
these transactions are put into the queue that models a mechanism for analyzing arriving transactions for cycles in sql statements.
once this analysis is performed a batch of transactions is sent to the database that executes these transactions and outputs results at some departure rate d. if database deadlocks occur some transactions are aborted and an exception handling mechanism delivers exceptions back to the dca which retries these aborted transactions.
this process is represented using the feedback loop that delivers some transactions back into the queue at a rate that is proportional to the arrival rate a. that is we assume that the frequency of database deadlocks is proportional to the transaction arrival rate which we observed in different projects.
we exploited this observation in our recent work where we developed an effective method to reproduce database deadlocks .
a relation between two independent variables aand dis important to determine the impact of database deadlocks.
consider two cases when d a and d a .
the underlying physical event for the departure rate dis the time it takes by the database to process transactions and to produce results.
thus the first case d a where the average time per transaction is measured in milliseconds or seconds rather then minutes or hours means that transactions are processed by the database much faster than they arrive this is typical for smaller applications where transactions manipulate small amounts of data without applying complex operations like joins and aggregations.
however existing database deadlock detection algorithms take time often many seconds to detect cyclic dependencies among executing transactions leading to a significant overhead.
we summarily add this overhead to the exception handler processing element in the feedback loop.
our simulation with the performance model showed nonlinear decrease in the throughput measured as the number of successfully processed transaction in some time interval for short running transactions with the high rate of arrival meaning that the system loses its scalability when deadlock detection time is equal to or greater than the mean transaction completion time.
when a database deadlock occurs recovering from it is easy and little overhead is involved.
clearly this is a case for non mission critical applications where the impact of database deadlocks is small.
the other case d a where the average time per transaction is measured in hours or days involves long running and complex transactions for mission critical and scientific applications.
examples include batch financial and retail applications various biological sequence analyses complex process simulations and online transaction processing tasks that involve data mining big data sets whose sizes are measured in terabytes.
in this case transactions arrive at about the same rate with which they are processed.
any database deadlock resulting in aborting a long running transaction that is put back into the queue will have a devastating effect on the performance of the system.
our simulation with the performancemodel showed a nonlinear decrease in the throughput time meaning that the system loses its scalability under realistic conditions.
.
the problem statement our main goal is to prevent database deadlocks.
our solution is conservative i.e.
it should statically detect all hold and wait cycles that can occur in sql statements that belong to different transactions.
these hold and wait cycles may potentially result in database deadlocks.
however depending on interleavings in different execution scenarios not all of these cycles will lead to database deadlocks meaning that false positives fps are possible.
for example when tables contain little or no data locks may be released by the database engine almost instantaneously or not imposed at all.
alternatively a deadlock will not occur if conflicting transactions attempt to lock disjoint sets of rows in at least one of the tables involved.
evidently the rows being locked depend on the outcome ofwhere clauses appearing in queries.
thus database deadlocks may or may not happen depending on the data stored in database tables even if hold and wait cycles are present leading to fps.
on the one hand a problem with fp hold and wait cycles is that they are not known to be fps until transactions are executed by the database engine.
using our mechanism to prevent a database deadlock by delaying a conflicting transaction imposes an overhead in addition to some reduction in the level of parallelism.
on the other hand given a high cost of database deadlocks it is an experimental question to determine how fps affect our solution and we address this question with our experiments in section .
in addition our approach should not depend on a specific database engine or require modifications of the kernels of database engines.
similar to operating systems database engines are very complex fragile and closed software systems a solution that requires their modifications is unlikely to be practical.
moreover our approach should not depend on specific architectures of dcas.
finally it is important to give exact scenarios that lead to database deadlocks.
lock graphs an example of which is shown in figure demonstrate the resulting hold and wait cycle but not execution paths that lead to it.
to help programmers understand how database deadlocks occur we provide exact scenarios that show specific orders of execution of sql statements and sequences of lock acquisitions that lead to database deadlocks.
.
our approach in this section we describe our key ideas and the abstraction on which they are based and give an overview of our approach for preventing database deadlocks from application based transactions redact .
.
our abstraction redact is based on our abstraction that represents relational databases as sets of resources e.g.
database tables and transac tions that dcas issue to databases as sets of abstract operations i.e.
reading from and writing into resources and these abstract operations also issue synchronization requests.
using this abstraction unifies dcas that use the same databases in a novel way their independently issued transactions become abstract operations with resource sharing requests.
with this abstraction we hide the complex machinery of database engines and concentrate on abstract operations performed by sql statements and the engines locking properties that we associate with these abstract operations.
.
key ideas redact rests on two key ideas to detect statically all holdand wait cycles among abstract operations that belong to differ gid4 gid3 gid2 gid23 gid1 gid4 gid3 gid2 gid24 gid1 gid2 gid3 gid7 gid3 gid4 gid3 gid6 gid5 gid1 gid13 gid27 gid14 gid24 gid28 gid14 gid16 gid30 gid25 gid24 gid28 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid40 gid39 gid39 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid1 gid13 gid27 gid14 gid24 gid28 gid14 gid16 gid30 gid25 gid24 gid28 gid1 gid12 gid11 gid7 gid1 gid28 gid29 gid14 gid29 gid18 gid23 gid18 gid24 gid29 gid28 gid1 gid12 gid11 gid7 gid1 gid28 gid29 gid14 gid29 gid18 gid23 gid18 gid24 gid29 gid28 gid1 gid4 gid14 gid29 gid14 gid15 gid14 gid28 gid18 gid1 gid12 gid18 gid32 gid24 gid19 gid28 gid1 gid8 gid25 gid17 gid18 gid22 gid18 gid27 gid1 gid10 gid18 gid29 gid27 gid21 gid1 gid9 gid18 gid29 gid1 gid8 gid25 gid17 gid18 gid22 gid1 gid10 gid14 gid27 gid28 gid18 gid27 gid1 gid5 gid25 gid22 gid17 gid41 gid14 gid24 gid17 gid41 gid36 gid14 gid21 gid29 gid1 gid16 gid37 gid16 gid22 gid18 gid1 gid17 gid18 gid29 gid18 gid16 gid30 gid25 gid24 gid1 gid14 gid22 gid19 gid25 gid27 gid21 gid29 gid20 gid23 gid1 gid11 gid1 gid14 gid1 gid15 gid1 gid16 gid1 gid17 gid1 gid18 gid1 gid19 gid1 gid12 gid34 gid26 gid18 gid27 gid35 gid21 gid28 gid25 gid27 gid37 gid1 gid3 gid25 gid24 gid29 gid27 gid25 gid22 gid1 gid42 gid12 gid3 gid43 gid1 gid11 gid12 gid1 gid11 gid1 gid11 gid11 gid1 gid11 gid11 gid1 gid11 gid10 gid1 gid13 gid1 gid13 gid1 gid6 gid24 gid29 gid1 gid6 gid24 gid29 gid1 gid12 gid1 gid12 gid1 gid4 gid18 gid29 gid18 gid16 gid29 gid18 gid17 gid1 gid20 gid25 gid22 gid17 gid41 gid14 gid24 gid17 gid41 gid36 gid14 gid21 gid29 gid1 gid16 gid37 gid16 gid22 gid18 gid28 gid1 gid12 gid3 gid1 gid12 gid18 gid32 gid24 gid19 gid28 gid1 figure the workflow of redact.
ent transactions with specific execution scenarios that lead to these hold and wait cycles and to use the information about all detected hold and wait cycles at runtime to prevent database deadlocks by holding back one operation i.e.
sql statement that participates in the hold and wait cycle hence breaking it.
an important element of these ideas is that we separate detection of holdand wait cycles and prevention of database deadlocks the former is done statically and the latter is done dynamically during executions of dcas that use shared databases.
this separation enables us to avoid expensive computations at runtime making database deadlock prevention very fast and efficient since a simple lookup function is involved.
in redact we make conservative approximations about how database engines process transactions.
in general processing tran sactions includes compiling sql statements building and optimizing execution plans and detecting shared accesses by analyzing execution plans with respect to the data that is stored in the database.
different database engines implement this process differently.
our idea is to utilize information that all database engine vendors release on how these database engines impose and release locks on different resources for different types of sql statements it is called a database locking strategy .
using a locking strategy we can approximate the complex sequences of steps of transaction processing by modeling conservatively sql statements using our abstract operations that issue synchronization requests according to a given locking strategy.
.
overview of redact the workflow of redact is shown in figure and this workflow shows two dcas i.e.
dca mand dca n that use the shared database as shown with dashed arrows labeled with .
in this setting database deadlocks occur at some rate.
here we use the terms transaction and sql statement interchangeably.
the first step in the workflow involves extracting transactions that contain sql statements from these dcas as shown with dashed arrows labeled with .
this is a one time manual effort that may be required as it was done for three subject dcas in this paper .
once transactions are extracted the static analysis phase starts.
first sql statements that are contained in these transactions are parsed and the resulting parse trees are inputted into the modeler that automatically transforms sql statements into the ab stract operations and synchronization requests.
specific details of modeling are described in section .
.
in redact we extracted the sql parser from apache derby database.
the modeler uses database settings that include a locking strategy to produce a petri net model which we describe along with the hold and wait cycle detection algorithm in section .
this model is created using thepetri net xml modeling language pnml and it serves as the input to the algorithm that detects all hold and wait cycles that are in turn used as inputs to the supervisory control sc .
this step concludes the static phase of redact.
at this point we describe the dynamic phase during which dcas are run and database deadlocks are prevented automatically.
our goal is to divert sql statements from dcas to the sc at runtime so that the sc determines whether executing these sql statements may result in hold and wait cycles and consequently a database deadlock.
diverting sql statements is accomplished in redact by using the interceptor pattern that is implemented using a framework with call backs associated with particular events .
the first step is to add interceptors to dcas.
we show these interceptors as partial rectangles with the label int that are superimposed on the rectangles that designate dcas in figure .
the goal is to intercept jdbc api calls that take sql statements as string parameters.
instead of sending these statements to the database the interceptors divert the statements to the supervisory controller whose goal is to quickly look up if hold and wait cycles are present in the sql statements that are currently in the execution queue.
in so the sc utilizes the information that is obtained from the static analysis phase as well as its settings that enable stakeholders to fine tune the sc for specific environments.
for example it is possible to specify a delay time for a conflicting transaction which we use in our experiments in section .
smaller delay time increases the probability of database deadlocks while larger delay time enables redact to prevent database deadlocks at the cost of introducing higher overhead in case of fps.
it is an experimental question to determine this trade off.
to make the sc efficient each sql statement is given a unique hash key and the information about hold and wait cycles in sql statements is coded using hash keys to avoid significant overhead when looking up sql statement in the execution queue.
if no holdand wait cycles are present the sc forwards these sql statements to the database for execution otherwise it holds back one sql statement or a transaction to which this sql statement belongs while allowing others to proceed and once these sql statements are executed and results are sent to the dcas the held back sql statement is sent to the database thus effectively preventing the database deadlock.
this concludes the description of the workflow for redact.
.
the model and the algorithm in this section we give the background on petri nets specify our modeling approach and discuss the algorithm for detecting holdand wait cycles and we argue for its correctness.
.
background on petri nets ordinary petri nets are directed graphs with two kinds of nodes called places andtransitions .
figure shows an example of a petri net modeling the transactions appearing in table .
net transitions are represented as bars places are represented as circles.
places may contain tokens represented as solid dots each place may be assigned zero or more tokens.
for example place p1 init in figure is assigned one token.
arcs connect transitions to places and vice versa.
a directed arc from a place to a transition represents preconditions that are required for an event gid15 gid28 gid25 gid11 gid13 gid11 gid18 gid1 gid18 gid28 gid25 gid16 gid8 gid5 gid7 gid23 gid1 gid15 gid29 gid1 gid18 gid29 gid25 gid22 gid16 gid11 gid18 gid8 gid1 gid15 gid30 gid1 gid18 gid30 gid25 gid16 gid8 gid5 gid7 gid1 gid15 gid31 gid1 gid18 gid31 gid25 gid16 gid8 gid12 gid17 gid8 gid1 gid15 gid33 gid1 gid15 gid34 gid1 gid15 gid35 gid1 gid15 gid32 gid25 gid11 gid13 gid11 gid18 gid1 gid18 gid32 gid25 gid16 gid8 gid5 gid7 gid23 gid1 gid18 gid33 gid25 gid22 gid16 gid11 gid18 gid8 gid1 gid18 gid34 gid25 gid16 gid8 gid5 gid7 gid1 gid18 gid35 gid25 gid16 gid8 gid12 gid17 gid8 gid1 gid2 gid28 gid25 gid5 gid21 gid18 gid10 gid14 gid16 gid17 gid1 gid2 gid29 gid25 gid19 gid18 gid12 gid8 gid17 gid1 gid3 gid21 gid6 gid13 gid8 gid18 gid1 gid9 gid14 gid16 gid1 gid4 gid28 gid1 gid3 gid21 gid6 gid13 gid8 gid18 gid1 gid9 gid14 gid16 gid1 gid4 gid29 gid1 figure petri net model for the illustrative example that is shown in table .
associated with that transition to occur.
conversely arcs from transitions to places represent the outcome of the event associated with the transition.
a transition is enabled if all its input places contain at least one token each.
an enabled transition may fire a token is consumed from each of the transition s input places and a token is added to all of the transition s output places.
for example when transitiont1 ready fires the token in place p1 init is removed and a token is added to place p2 enabling transition t2 write since both its input places p2andr1 authors now hold tokens.
definition .an ordinary petri netn p t a m0 is a directed bipartite graph with node sets p p1 ... pn the places and t t1 ... tm the transitions .
a p t t p is the arc set and for each p p m p defines the initial assignment of tokens to place p. the set of input transitions of a place p is denoted by p t t p a .
similarly the set of output transitions of place p is denoted as p t p t a .
the sets of input and output places for a transition t are similarly defined as t and t .
.
modeling transactions we model database transactions using a subclass of petri nets called s4rnets which consist of a set of disjoint process subnets each modeling a sequential process in a concurrent system.
subnets are connected to each other by a place subset called the resource places which model resources shared by the process subnets.
typically operations in different process subnets may require one or more resources shared with other process subnets.
in addition each process subnet consists of one main loop which starts at an initial place for that subnet however no additional cycles are contained in each subnet.
we use process subnets to model database transactions and resource places to model database locks such as locks on database tables or rows.
the special structure of s4rnets has allowed us to build an efficient algorithm for detecting potential deadlocks in dcas.
thes4rnet is shown in figure whose two subnets model the transactions that appear in table .
resource places r1 authors andr2 titles model the locks on the two tables appearing in the example.
our models contain four types of transitions ready read write andrelease .
these transitions are associatedwith operations that we introduced as part of our abstraction in section .
.
sql statements insert andupdate are modeled using the operation write select statements are modeled using the operationread .
the operation release designated in figure asrelse specifies that all acquired locks are ready to be released.
states and resources are modeled as places.
resource places always have tokens at the initial state to indicate their availability for transactions.
if a transition models an sql statement that accesses and manipulates some resources then arcs connect places that designate these resources with that transition.
so addresses two issues at the same time executing the abstract operation that a transition specifies and obtaining a lock on a resource by moving the token from the resource into the transition s output places.
for example when the transition t1 ready fires in the model that is shown in figure a token is placed into place p2.
since the token is still in the resource place r1 authors transition t2 write is enabled which corresponds to the execution of the sql statementupdate fort1in table .
since the token is taken from placer1 authors transition t7 read is no longer enabled.
the hold and wait cycle can be reached by the following transition firing sequence t1 ready t5 ready t6 write t2 write .
unlike lock graphs these sequences enable stakeholders to understand analyze and debug database deadlocks which is one of the goals of this paper.
.
the redact algorithm a brute force approach for finding hold and wait cycles does not work for ntransactions each combination should be explored i.e.
the powerset of these transactions 2n n .
assuming that it takes less than .
sec to explore each combination it will take one year to explore all combinations for transactions.
of course they can be explored in parallel running analysis in virtual machines reduces the analysis time to less than hours.
however better results are possible.
our insight is to use a depth first search dfs based cycle search algorithm which we extend for s4rnets.
the algorithm iterates through transactions i.e.
subnets and analyzes if any transition within a subnet is connected to a resource.
if no resource is shared then the analysis complexity is effectively the order of o s t where sis the number of subnets and tis the number of transitions i.e.
no cycles are possible.
in the worst case all subsets of subnets have cycles and the complexity is exponential.
however our main insight is that this situation rarely occurs if ever there are very few cycles and this is what makes detection and prevention of database deadlocks difficult.
in fact the main problem is to detect these very few cycles that materialize as database deadlocks.
in case there are few and far cycles between transactions and the analysis time will be quite small even for a large number of resources as we show in our experiments in section .
the algorithm redact is shown in algorithm .
this algorithm takes as its input the s4rnetnwhose process subnets model sql statements in different transactions.
hold and wait cycles are computed and returned in line 21of the algorithm.
the algorithm recursively calls the procedure computeallcycles see line that performs a depth first search on the subnets of n. lines and in algorithm initialize three variables a stack of transitions to be searched a variable cycles holding all detected hold and wait cycles and a variable cycle holding transition sequences potentially leading to a cycle.
line extracts the process subnets from input net n. lines iterate the following actions on each subnet.
first all transitions in the subnet are pushed on the stack line .
next a transition tis popped from thealgorithm the redact algorithm.
redact petri netn cycles initialize global variable.
stack cycle initialize local variables.
getsubnets n mapsto s a subnet of a petri net models some transaction.
for all s s do stack.push gettransitions s while stack ne ationslash 0do stack.pop mapsto t t if p p resource p true a a a p t then cycle mapsto t for all w t p w a do computeallcycles w cycle getsubnet w end for end if end while n n s end for return cycles computeallcycles transition t cycle c subnet s localstack v init local stack and list of visited transitions.
if p p resource p true p t a then cycle mapsto cycle t if t getinitialplaces s 0then localstack.push transitionspreceding t ins end if while localstack ne ationslash 0do localstack.pop mapsto u t ifu gettransitions s then getfirsttransition c mapsto v ifv u v transitionspreceding u insthen cycles mapsto cycles cycle end if else if u vthen v mapsto v u cycle mapsto cycle u if q uholdstoken q true then for all q u resource q q e a e ne ationslash udo computeallcycles e cycle s end for end if if u getinitialplaces s then localstack.push transitionspreceding u ins end if end if end while end if stack and checked for a structural conflict with transitions in other subnets.
a structural conflict between net transitions occurs when the transitions share an input place with each other.
in this case tcould be in conflict with another transition w iftandwshare a resource place as an input.
this means that tandwmodel computations requiring the same database lock.
if there is an arc between tand some resource tis added to the potential cycle being explored and procedure computeallcycles is called to further explore the cycle.
finally the process subnet that is considered in eachwhile loop iteration is removed from further consideration in line .
lines in algorithm specify the body of the procedure computeallcycles .
the procedure takes as input a transition t the cycle c under exploration and the process subnet s to which tbelongs.
line initializes a local stack of transitions and a list of transitions v that have been visited.
line checks whether trequires any locks.
if this is not the case the procedure just returns otherwise the procedure explores t. in this case tis added to the cycle under construction and t s predecessor transitions in the process subnet of tare pushed on the local stack for further exploration lines .
lines iteratively pop a transition ufrom the local stack and check whether the first transition in the cycle under exploration is either uor a predecessor of uinu s subnet.
in this case a cycleapp loc db size t stdb ttrans rows him 248mb ucom 29mb dan 371mb table subject dcas and their databases.
the columns show lines of code loc in dcas the size of db in megabytes the number of transactions tin the dca and how many sql statements sat most are contained in each transaction the number of tables in the database tdb the number of tables used in transactions ttrans and the total number of rows.
is detected and the cycle under consideration is added to the list of discovered hold and wait cycles.
otherwise in lines u is added to the list v of visited transitions and to the cycle currently being explored.
if uis enabled line a new search is started from uby invoking computeallcycles recursively on all transitions that may share resources with u lines .
if u is not enabled lines push upredecessor transitions in u s process subnet on the local stack and the loop beginning at line is repeated.
the list of cycles is returned in line .
.
experimental ev aluation in this section we describe the results of experimental evaluation of redact on three small java dcas.
we seek to answer the following research questions.
rq1 how efficiently does the redact algorithm detect holdand wait cycles in large scale transactions?
rq2 how effectively does the redact approach prevent database deadlocks?
the rationale for rq1 is to determine if our redact algorithm is practical for detecting hold and wait cycles in transactions.
we observe that many enterprise large scale dcas contain less than transactions each of which includes a dozen sql statements.
however we want to experiment in the extreme to show if our redact algorithm can handle very large inputs.
the rationale for rq2 is determine how much performance can be gained by preventing database deadlocks when compared with the standard defensive programming practice that we described in section .
to address rq2 is to experiment with dcas to determine redact s overhead and compare it with other solutions.
.
methodology to evaluate rq1 we should experiment with different number of transactions that contain different numbers of sql statements that use different database resources e.g.
tables .
this methodology requires a large number of different complex sql statements that contain hold and wait cycles.
one way to address the problem is to select transactions from commercial dcas as benchmarks however so negatively affects reproducibility of results which is a cornerstone of the scientific method since commercial benchmarks cannot be easily shared among companies for legal reasons and trade secret protection.
unfortunately in many cases existing tpc benchmarks fall short of evaluating complex database features and they do not lead to database deadlocks .
relational database engines are routinely tested using complex sql statements that are generated using random sql statement generators .
suppose that a claim is made that a relational database engine performs better at certain aspects of sql optimization than some other engine.
the best way to evaluate thisclaim is to create complex sql statements as benchmarks for this evaluation in a way that these statements stress properties that are specific to these aspects of sql optimization.
since the meaning of sql statements does not matter for our evaluation this generator creates semantically meaningless but syntactically correct sql statements thereby enabling users to automatically create low cost benchmarks with reduced bias.
we use this approach to generate random transactions and seed them with hold and wait cycles and we use these generated transactions to evaluate our redact algorithm to address rq1.
to address rq2 our goal is to determine how using redact with supervisory control sc affects the performance of dcas.
recall that even if a hold and wait cycle is detected it does not necessarily always lead to a database deadlock.
unfortunately it is not feasible to know in advance if a hold and wait cycle would materialize in a deadlock due to a large combinatorial space of possible interleavings.
thus the sc will conservatively delay an sql statement i.e.
a transaction to which this sql statement belongs to break a hold and wait cycle.
to evaluate the impact of redact and its sc we should experiment under different conditions.
we aligned our methodology with the guidelines for statistical tests to assess randomized approaches in software engineering .
since database deadlocks are not easy to reproduce different run s of the dca may reveal different number of deadlocks and different impacts of redact.
our goal is to collect highly representative samples of runs when applying different approaches perform statistical tests on these samples and draw conclusions from these tests.
since our experiments involve the probability of encountering database deadlocks it is important to conduct the experiments multiple times to pick the average to avoid skewed results.
.
subject dcas we evaluate redact with three java dcas whose characteristics are shown in table .
him is a program for maintaining health information records.
dan is a demographic analysis program.
finally ucom is a program for obtaining statistics on how users interact with unix systems using their commands.
these dcas are based on simplified specifications from real world applications that came from different projects at accenture.
subjects dcas as well as their databases are available from sourceforge3.
each dca consists of the server component that spawns multiple threads that use its backend database and a client component that submits client requests and obtains data from the server.
.
experiments with subject dcas in our experiments we used jmeter org to run subject dcas with different numbers of clients.
in the baseline experiment type b database deadlock exception handling is disabled in the subject dcas that is once a database rolls back a transaction its data is lost.
it is the fastest but also incorrect execution that gives us a baseline for performance the maximum throughput of the dcas that is measured in the number of executed transactions in a predefined time interval.
in the experiment where database deadlock exceptions are handled gracefully type g using the defensive programming practice as we described in section rolled back transactions are retried until successfully executed.
finally type r experiment uses the redact approach that incurs the sc overhead but it decreases the cost of deadlock resolution.
for each dca we carried out experiments with one and clients for mins per experiment and we measured the throughput as the total number of executed transactions.
since exhibiting database deadlocks requires specific interleavings of trans3 x sqlstmts perx x incycles places transitions arcs resources cycles det time inseconds .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table results of experiments on cycle detection algorithm for var ious number of transactions x and sql statements per transactions.
column xincycles represents the percentage of transactions that are randomly c hosen to be involved in cycles.the constructed petri net model is reported as the columns places t ransitions arcs and resources.
total number of cycles deteted is reported in cycles detcolumn.the execution time of the algorithm is reported in the time colu mn.
all times are in seconds and rounded to two decimal points.
actions we repeated each experiment times.
thus the total number of experiments is equal to three dcas three types b g r four client settings x times experiments.
we report statistical results average median min max variance for runs for the number of observed deadlocks and the throughputs.
.
threats to validity a threat to the validity of this experimental evaluation is that our subject programs are relatively small it is difficult to find large open source dcas that use nontrivial databases.
large dcas may have millions of lines of code and use databases whose sizes are measured in thousands of tables and attributes.
those dcas and databases may have different characteristics compared to our smaller subject programs.
on the one hand increasing the size of applications to millions of lines of code is unlikely to affect the time and space demands of our analyses because redact only considers transactions.
thus the source code of dcas is ignored in the cycle analysis which is focused on the transactions that these dcas issue to their databases.
on the other hand increasing the size and the number of transactions may have a significant impact on the cost of cycle analysis.
the algorithm that we propose in this paper has the exponential complexity and even though it is unlikely to encounter dcas that have hundreds of distinct transactions that contain hundreds of sql statements each most of which share resources in cyclic dependencies it is really a pathological case since one should question the design of such a system!
.
however it is a limitation of redact and a potential threat to validity when dealing with ultra large scaletransactions.
in addition it may be more challenging to use the sc for executions of large and complex applications to prevent database deadlocks when there are too many fp hold and wait cycles.
evaluating this impact is a subject of future work.
additional threats to validity of this study is that we used graduate students as programmers who created dcas and this task should be tackled by professional programmers.
however most of these students have at least one year of professional programming experience thereby reducing this threat to validity.
finally there are over two dozen of different kinds of database deadlocks.
in this paper we experimented only with circular database deadlocks most frequently occurring based on our observations that are realized from hold and wait cyclic locks on resources by transactions.
it is unclear how well redact will perform on other kinds of database deadlocks so this is a threat to external validity of our results.
.
results the results of experiments with the redact algorithm are shown in table .
for the number of transactions and sql statements per transaction smaller than the hold and wait cycle detection time is negligent and measured in seconds.
for an extreme case of transactions each of which containing sql statements i.e.
a total of sql statements it takes a little over .
hours for our algorithm to detect all hold and wait cycles.
for a realistic case of a large scale dcas contains transactions each of which includes sql statements and in which of statements are chosen to be involved in cycles our algorithm finds all cycles indca deadlocks throughput all transactions for 15mins name type clients avg med min max var avg med min max var himb1 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
g1 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
r1 .
.
.
.
.
.
.
.
.
.
ucomb1 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
g1 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
r1 .
.
.
.
.
.
.
danb1 .
.
.
.
.
.
.
.
.
.
.
.
.
.
g1 .
.
.
.
.
.
.
.
.
.
.
.
.
r1 .
.
.
.
.
.
.
table each subject dca i.e.
him ucom and dan is evaluated u sing b aseline g raceful exception handling and r edact methodologies.
each dca was run with one and clients for mins per experiment and we measured the throughput as the number of all executed transactions for 15min s of the experiment.
for the columns deadlock and throughput we report statistical results average median min max variance for runs for each dca client setting.
less than two seconds.
these results provide an answer to rq1 that our redact algorithm efficiently detects hold and wait cycles in large scale transactions.
the results of experiments with the subject dcas are shown in table and table .
when one client is used database deadlocks do not occur and the overhead of supervisory control is rather significant it reduces the throughput by approx for him.
however as the number of clients increases so does the frequency of deadlocks.
we can see that the average number of database deadlocks increases by two orders of magnitude for the dca dan when the number of clients increases from to .
at the same time the thoughput drops by four orders of magnitude since the overhead of database deadlock resolution algorithm within the database engine takes its toll even if discarded transactions are not retried.
recall that the database engine takes some time it is a configurable parameter usually set between seconds by default is set to seconds4 to locate cycles and resolve database dead4 in general the timeout is set by database administrators who base their decision on the average time it takes to execute a transaction.
this resolution time significantly worsens the performance of dcas severely impacting their scalability!
we experimented with different conflicting transaction delay times for the sc that we show in table .
we decreased the time from seconds the value that we used in experiments that we show in table to seconds and .
seconds.
reducing the delay time force sc to perform unnecessary computation while scheduling process for newly arrived transactions needs to be put on hold.
exceptions are for and clients of ucom when decreasing the delay time decreased the throughput.
the reason is in non scalability of the design of the dca since lots of transactions were aborted for connection exceptions due to so many clients.
however as we observe from the experimental results in table throughput increases by more than two orders of magnitude in some cases with no database deadlocks observed.
and this is when redact is effective it prevents databaseapplication clients time seconds t hroughput avg him10.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ucom10.
.
.
.
.
.
.
.
.
.
.
.
.
.
dan10.
.
.
.
.
.
.
.
.
.
.
.
.
.
table results of experiments with redact for three subject applications i.e.
him ucom and dan four different client loads and three different waiting times in the sc.
we report the average numbers of throughput values i.e.
executed transactions of runs for each distinct combination of the experimental settings.
each experiment lasted for minutes no database deadlocks were observed.
deadlocks thereby removing the need for this costly deadlock resolution within the database engine.
for clients for him the average throughput is transactions for the type g experiment while redact s throughput is .
transactions.
for ucom the numbers are .
versus .
for redact and for dan the numbers are .
versus .
for redact on average.
and for dan the throughput is improved by approximately three orders of magnitude.
these results allow us to answer rq2 that the redact approach is very effective in preventing database deadlocks .
.
related work some approaches use static program analysis to obtain information about deadlocks.
racerx is a static tool that uses flowsensitive interprocedural analysis to detect both race conditions and deadlocks .
williams et al.
defined a deadlock detection algorithm for java libraries.
in contrast with our method theseapproaches derive lock graphs directly from java and c source code and they suffer from false negatives.
these approaches ar e not currently applicable to detect database deadlocks since analyzing source code of dca will not detect cycles in transactions.
dynamic approaches use runtime data to infer where deadlocks may occur or determine how to predict and resolve them in future program runs.
an approach called dimmunix immunizes programs against deadlocks by collecting deadlock patterns which are subsets of control flow traces that lead to deadlocks .
like redact it uses detected hold and wait cycles to prevent database deadlocks.a fundamental difference between redact and dimmunix is that the hold and wait cycles designate necessary conditions for deadlocks to occur while deadlock patterns in dimmunix are loose approximations that result in many fps especially since control flow of dca is not applicable to detect database deadlocks.
rx is a dynamic approach that rolls back an application once a deadlock occurs to a checkpoint and retries it again with the hope that the deadlock will be avoided in subsequent executions .
this solution cannot be used in the context of redact since rolling back a dca significantly worsens its performance retrying these transactions incurs a significant performance penalty.
recent work on magicfuzzer described a dynamic deadlock detection technique for c programs where magicfuzzer uses runtime information to prune the number of choices that may lead to deadlocks .
a dynamic approach sammati provides automatic deadlock detection and recovery for posix threaded applications .
unlike magicfuzzer and sanmati redact performs its analysis at compile time to prevent deadlocks at runtime.
like redact snapshot isolation partially addresses the problem of database deadlocks by avoiding conflicting concurrent updates that may lead to inconsistent snapshots .
in contrast to redact exceptions are thrown when snapshot isolation is violated leading to the same performance problem that redact address with database deadlocks.
h store addresses the database deadlock problem by running transactions single threaded and avoiding conflicts by preventing multiple transactions from competing with one another .
it is a new concept and our goal of future work is to experiment to compare redact and h store.
approaches for preventing deadlocks using transactional memory are gaining increasing popularity but unfortunately database deadlocks often occur in the distributed setting.
.
conclusion since applications often share the same databases concurrently database deadlocks routinely occur resulting in major performance degradation in these applications.
to address this problem we created a novel approach for preventing database deadlocks automatically and we rigorously evaluated it.
for a realistic case of over sql statements our algorithm detects all hold and wait cycles in less than two seconds.
we build a tool that implements our approach and we experimented with three dcas.
our tool prevented all database deadlocks in these dcas and increased their throughputs by approximately up to three orders of magnitude.