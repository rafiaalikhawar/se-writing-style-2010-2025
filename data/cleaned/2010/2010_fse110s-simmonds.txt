guided recovery for web service applications jocelyn simmonds shoham ben david marsha chechik department of computer science university of toronto toronto on m5s 3g4 canada jsimmond shoham chechik cs.toronto.edu abstract web service applications are dynamic highly distributed and loosely coupled orchestrations of services which are notoriously di cult to debug.
in this paper we describe a user guided recovery framework for web services.
when behavioural correctness properties safety and bounded liveness of an application are violated at runtime we automatically propose and rank recovery plans which users can then select for execution.
for safety violations such plans essentially involve going back compensating the occurred actions until an alternative behavior of the application is possible.
for bounded liveness violations such plans include both going back and re planning guiding the application towards a desired behavior.
we report on the implementation and our experience with the recovery system.
categories and subject descriptors d. .
testing and debugging error handling and recovery general terms design veri cation .
introduction recent years have seen the increased reliance on being able to conduct business over the internet.
the serviceoriented architecture soa framework is a popular guideline for building web based applications.
a soa based application is an orchestration of services o ered by possibly third party components written in a traditional compiled language such as java or in an xml centric language such as bpel1.
web services are distributed systems where partners are dynamically discovered and are going on and o line as the wsbpel v2.
os.html permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
fse november santa fe new mexico usa.
copyright acm ... .
.application runs.
their failures can be caused by bugs in the service orchestration e.g.
due to faulty logic and bad data manipulation or by problems with hardware network or system software or by incorrect invocations of services.
with runtime failures of web services inevitable infrastructures for running them typically include the ability to dene faults and compensatory actions for dealing with exceptional situations.
speci cally the compensation mechanism is the application speci c way of reversing completed activities.
for example the compensation for booking a car would be to cancel the booking.
existing infrastructures for web services e.g.
the bpel engine include mechanisms for fault de nition for speci cation of compensation actions and for dealing with termination.
when an error is detected at runtime they typically try to compensate all completed activities for which compensations are de ned with the default compensation being the reversal of the most recently completed action.
this approach presents several major problems the application is often allowed to continue running until the fault is discovered thus executing and then compensating for a lot of unnecessary and potentially expensive activities.
it is hard to determine a priori the state of the application after executing compensation mechanisms.
there might be multiple compensations available based on global information i.e.
avoid canceling the ight since it has a dollar cost associated with it and try to cancel the hotel instead but the automatic application of compensations does not allow the user of such a system to choose between them.
this paper describes a user guided recovery framework for web services instantiating it on bpel programs.
we concentrate on behavioural correctness and speci cally on the correct interaction between service partners.
the overview of the approach is given in fig.
1a.
our approach consists of three phases preprocessing monitoring and recovery.
it admits the following user guidance i application developers de ne a set of behavioral correctness properties that need to be maintained at runtime as well as compensation costs and idempotent service calls see sec.
.
ii optional application users provide criteria for choosing between possible recovery plans i.e.
based on the plan length compensation cost etc.
iii application users manually choose the desired recovery plan among those automatically computed and ranked by our system.
we consider behavioral correctness properties to be scenarios that the system should exhibit and scenarios that the system should not exhibit.
for example consider a simple web based trip advisor system tas .
in a typical scenario a b figure a overview of our approach b a schematic view on plan generation.
a customer either chooses to arrive at her destination via a rental car and thus books it or via an air ground transportation combination combining the ight with either a rental car from the airport or a limo.
the requirement of the system is to make sure the customer has the transportation needed to get to her destination this is a desired behaviour while keeping the costs down i.e.
she is not allowed by her company to reserve an expensive ight and a limo this is a forbidden behavior .
such desired and forbidden behaviours can come from use cases global invariants simulation or a variety of other sources.
they can be expressed in temporal logic or in visual notations such as uml s sequence diagrams .
the problem of collecting and expressing properties has been addressed by many researchers and we consider it to be orthogonal to this paper.
we also refer to the speci cation of negative behaviour as safety properties and positive behaviour as bounded liveness properties .
in the interest of space we further assume that properties are represented by nite state monitors.
a description of the desired orchestration and the set of monitors describing safety and liveness properties are then passed to the runtime monitoring framework which runs the monitors in parallel with the application stopping when one of the monitors enters its error state.
we build on an earlier work of de ning and implementing an unintrusive online framework for runtime monitoring of conversations between partners .
using high level properties allows us to detect the violation and our event interception mechanism allows us to stop the application right before the violation occurs and enable recovery.
our main contribution is the development of recovery plans from runtime errors.
given an application path which led to a failure and a monitor which detected it our goal is to compute a set of suggestions i.e.
plans for recovering from these failures.
for violations of safety properties such plans use compensation actions to allow the application to go back to an earlier state at which an alternative path that potentially avoids the fault is available.
we call such states change states these include user choices and certain partner calls.
for example if the tas system produces an itinerary that is too expensive a potential recovery plan might be to undo the limo reservation so that the car can now be booked or to undo the ight reservation and see if a cheaper one can be found.
yet just merely going back is insu cient to ensure that the system can produce a desired behaviour.
thus in order to satisfy bounded liveness properties we aim to compute plans that redirect the application towards executing new activities those that lead to goal satisfaction.
for example if the ight reservation partner fails and thus the air ground combination is not available the recovery plans would be to provide transportation to the user s destination her goal state either by calling the ight reservation again or by un the reserved ground transportation from the airport if any and try to reserve the rental car from home instead.
the overall recovery planning problem is then stated as follows from the current error state in the system nd a plan to achieve the goal that goes through a change state.
this process is shown schematically in fig.
1b.
when there are multiple recovery plans available we automatically rank them based on user preferences e.g.
the shortest the cheapest the one that involves the minimal compensation etc.
and enable the application user to choose among them.
this paper makes the following contributions we propose a user guided framework for recovery from run time violations of behavioural properties representing desired and prohibited conversations between partners in web service applications.
we show the di erence between recovery from a violation of safety and bounded liveness properties and propose automated strategies for such recoveries.
we pose recovery problem as a plan generation problem and in turn reduce it to a sat instance which allows us to control the size of the resulting plans and compute multiple plans.
the rest of this paper is organized as follows.
we describe inputs to our system bpel models and monitors representing properties in sec.
.
we de ne the representation of bpel models as labeled transition systems lts and show how to use these representations for static identication of change states and goal transitions in sec.
.
we brie y discuss runtime monitoring in sec.
and describe our main contribution recovery for violations of safety and bounded liveness properties in secs.
and respectively.
we report on our implementation sec.
and use it to compute recovery plans for two web service examples sec.
.
after comparing our work with related approaches in sec.
we conclude in sec.
with a summary of the paper and suggestions for future work.
.
input inputs to our system are a bpel program enriched with compensation actions and a set of behavioral correctness properties described by monitors.
we describe these below.
.
bpel programs bpel is a standard for implementing orchestrations of web services provided by partners by specifying an executable work ow using prede ned activities.
the basic bpel activities for interacting with partner web services are receive invoke and reply which are used to receive messages execute web services and return values respectively.
the control ow of the application is de ned using structural activities such as while if sequence ow and pick .
fig.
2a shows the bpel expressed work ow of the trip advisor system tas introduced in sec.
.
we use the a b figure a work ow of tas b compensation for booking a ight bf .
netbeans soa notation2.tasinteracts with four external services book a rental car bc book a limo bl book a ight bf and check price of the ight cf .
the result of cfis then passed to local services to determine whether it is expensive expf or cheap cheapf .
service interactions are preceded by a symbol.
the work ow begins with receive ing input ri followed by pick ing indicated by labeled either the car rental onmessage onlycar or the air ground transportation combination onmessage carandflight .
the latter choice is modeled using a ow labeled since air getflight and ground transportation getcar can be arranged independently so they are executed in isolation.
the air branch sequentially books a ight checks if it is expensive and updates the state of the system accordingly.
the ground branch pick s between booking a rental car and a limo.
the end of the work ow is marked by a reply activity reporting that the destination has been reached rd .
compensation.
bpel s compensation mechanism allows the de nition of the application speci c reversal of completed activities.
for example the compensation for booking a ight bf is to cancel the booking cancelf this is described in bpel as shown in fig.
2b.
compensation handlers ch are attached to scope and invoke activities a scope activity is used to logically group activities and are executed by fault termination and compensation via the compensate and compensatescope activities.
the default compensation respects the forward order of execution of the scopes being compensated ifaandbare two activities where acompleted execution before b then compensate a b is compensate b compensate a .
any attempt to compensate a scope for which the ch either has not been installed or has been installed and executed is treated as executing an empty activity .
further extended bpel to allow users to associate compensations with di erent costs e.g.
to indicate that canceling a ight might be signi cantly more expensive than canceling a car.
we do this by adding an extra attribute cost to the de nition of compensationhandler .
for example the ight booking compensation de ned in fig.
2b has been assigned a cost of out of indicating that this is an expensive compensation and should be avoided if possible.
.
properties and monitors the second input to our system is a set of correctness properties.
as mentioned in sec.
we view the question of harvesting properties as well as the exact language for specifying them as orthogonal to our work and we assume that properties are expressed as monitors see def.
below .
we di erentiate between monitors representing safety properties negative behaviors that should not appear in the application and monitors representing liveness properties positive behaviors that the system must posses.
in general liveness properties are violated only by in nite behaviors and thus are not monitorable .
however bpel applications are run to completion programs which are expected to terminate.
by the explicit addition of the terminate ter event liveness properties become bounded and thus are readily monitorable.
for example the two requirements of the tassystem are to make sure that the customer has the transportation needed to get to her destination desired behavior while keeping the costs down forbidden behavior .
more formally they become p1 liveness if requested ri taswill guarantee that the transportation booked reaches the customer s destination rd regardless of the type of transportation chosen andp2 safety the user cannot book both a limousine bl and an expensive ight expf .
property p1is represented by the monitor a1in fig.
3a the property is satis ed once the booked transportations reaches the destination rd and the automaton is in state colored green and shaded vertically .
if the application terminates before rd the monitor moves to the error state colored red and shaded horizontally .
is the alphabet of the monitor i.e.
every event occurring in the application de ned formally in sec.
.
.
states and are unshaded and colored yellow to indicate that p1is neither satis ed nor violated.
the monitor a2for property p2 see fig.
3b goes to the error state when travel includes booking an expensive ight and a limo in any order.
all other states are yellow since the negative behavior can be detected but its absence cannot be established.
we formalize colored monitors below.
definition monitor .
amonitor is a tuple a s i f wheresis a set of states is an alphabet s sis a transition relation and i sandf s are sets of initial and nal states respectively.
a statesof a monitor ais called a sink state if all outgoing transitions from sare self loops.
for example states and in fig.
3a and state in fig.
3b are sinks.
we say thataaccepts a worda0a1a2 an i there exists an execution s0a0s1a1s2 an 1snofasuch thats02iand sn2f.
in our case the accepted words correspond to bad computations and the set fof accepting states represents error red states.
a green state is a desired monitor state when it is reached the corresponding property cannot be violated in the current computation.
a b figure monitors a a1 and b a2.
red states are shaded horizontally green states are shaded vertically and yellow states are solid.
definition colored monitor .
leta s i f be a monitor and let k sbe the set of all sinkstates ofa.
then 8s2f color s red 8s2knf color s green all non accepting sink states and8s2sn f k color s yellow.
definition .ais a liveness monitor if it includes at least one green state otherwise it is a safety monitor .
we assume that we are given a set sm fas as mgofm safety monitors and lm fa a ngofnliveness monitors.
as with any other property based speci cation it is possible that the property list is incomplete i.e.
some behavioural requirements are not captured or even inconsistent i.e.
satisfying the entire set of requirements is not possible .
.
preprocessing inputs to the preprocessing stage are the bpel program b the set of safety monitors smand a set of liveness monitors lm.
we begin with converting binto a formal representation l b which is a labeled transition system lts .
we then enrich it with transitions on compensation actions to get lc b sec.
.
.
we formalize change states andgoal transitions and provide an algorithm for computing these statically on lc b sec.
.
.
.
bpel to lts in order to reason about bpel applications we need to represent them formally so as to make precise the meaning of taking a transition reading in an event etc.
several formalisms for representing bpel models have been suggested .
in this work we build on foster s approach of using an lts as the underlying formalism.
definition labeled transition systems .
alabeled transition system lts is a quadruple s i where sis a set of states is a set of labels s sis a transition relation and i sis a set of initial states.
e ectively ltss are state machine models where transitions are labeled whereas states are not.
we often use the notationsa !s0to stand for s a s0 .
specify mapping of all bpel .
activities into lts.
for example fig.
shows the translation of the invoke activity bfwhich returns a con rmation number.
the activity is a sequence of two transitions the actual service invocation invoke bf and its return receive bf .
conditional activities like while if and pick are represented as states with two outgoing transitions one for each valuation of the condition.
sequence and ow activities 3foster s translation uses names to include traceability information to the bpel s scopes.
we omit these in this paper for simplicity.
figure lts translation of the invoke activity bfand its compensation bold .
a b c figure a lts lc tas showing traces t1 dotted andt2 dashed b a fragment of l tas a1 c a recovery plan in xml.
result in the sequential and the parallel composition of the enclosed activities.
the set of labels of the resulting translation l b is derived from the possible events in the application b service invocations and returns onmessage events scope entries and condition valuations.
it also includes the new system event ter modeling termination.
the set of states sinl b consists of the states produced by the translation as well as a new state t. this state is reached from any state ofsvia a ter event 8s2snftg s ter t .
in order to capture bpel s compensation mechanism we introduce additional backwards transitions.
for example the compensation for bf speci ed in fig.
2b is captured by adding the transition 3invoke cancelf !
as shown in fig.
.
taking this transition e ectively leaves the application in a state where bfhas not been executed.
we denote by an empty action allowing un of an action without requiring an explicit compensation action.
note that we have made a major assumption that compensation returns the application to one of the states that has been previously seen.
thus given a bpel program b and its translation to lts l b s i we translate b with compensation into an lts lc b s c c i where cis the set of compensation actions including and cis the set of compensation transitions.
fig.
5a shows lc tas .
to increase legibility we do not show the termination state tand transitions to it.
also we only show one transition for each service invocation abstracting the return transition and state.
in this notation the lts in fig.
has two transitions 1bf !
and 3cancelf !
.
this allows us to visually combine an action and its compensation into one transition labeled in the form a a where ais the application activity and ais its compensation.
in other words each transition sa a !tin fig.
5a represents two transitions s a t and t a s c. the pick activity labeled in fig.
2a corresponds to state of fig.
5a.
the choice between onlycar andcarand flight is represented by two outgoing transitions from this state onlycar and carandflight .
since these actions do not a ect the state of the application they are compensated by .
the ow activity labeled in fig.
2a results in two branches depending on the order in which the air and ground transportation are executed.
the compensation for these events is also .
.
identifying goal transitions and change states the second part of the preprocessing phase statically identi es strategic behaviors of the application l b aimed to help nd an e cient recovery plan when a violation is encountered see sec.
and sec.
.
.
.
goal transitions in order to nd a good recovery plan we rst need to compute a set of goal transitions that is transitions taken by the application which immediately result in satisfaction of some properties.
we compute these on a per property basis.
further recall that only liveness properties can be satis ed which is indicated by the monitor reaching a green state safety properties can only be violated.
thus for each liveness monitor a i2lm si i ii fi we are looking for transitions in l b s i corresponding to a ientering its green state s .
to nd those we compute the crossproduct l b a i. s a s0 is agoal transition i 9q q02 si s q a !
s0 q0 color q green color q0 green.
that is sa !s0corresponds to taking a transition on ainto a green state of a i. the resulting set of goal transitions is denoted by g b a i .
for example consider a fragment of l tas a1shown in fig.
5b.
the green state of a1is state with transition on rd leading to it.
the only transition in l tas a1satisfying the above de nition is rd !
and thus g tas a1 f rd g depicted by tiny dashed transitions in fig.
5a .
when computing recovery plans we need to direct the application towards taking its goal transitions.
.
.
change states given an erroneous run how far back do we need to compensate before resuming forward computation?
if we want to avoid repeating the same error again we need the application to take an alternative path.
states of l b that have actions executing which can potentially produce a branch in control ow of the application are called change states .
flow changing actions are user choices states modeling the ow activity since each pass through this state may produce a di erent interleaving of actions and those service calls whose outcomes are not completely determined by their input parameters but instead depend on the implicit state of the world .
this characteristics of services is sometimesreferred to as idempotence since multiple invocations of the same service yield the same results.
thus non idempotent service calls also identify change states.
for example cheapf is a call to determine whether a given ight is cheap and unless the speci cation of what cheap means changes returns the same answer for a given ight.
on the other hand bf books an available ight and each successive call to this service can produce di erent results.
non idempotent service calls are identi ed by the bpel developer as xml attributes in the bpel program.
we denote by c b the set of all change states in the lts of the application b. for example in the lts in fig.
5a state corresponds to the ow activity and represents the di erent serialization order of the branches.
states and model user choices.
non idempotent partner calls arebf bc bl and thus c tas f1 24g identi ed in fig.
5a by shading.
a recovery plan should pass through at least one change state to allow a change in the execution.
of course it is possible that the computed recovery plan passes through a change state which does not a ect its outcome i.e.
is irrelevant to the encountered error and its x. we address computation of relevant change states in .
.
runtime monitoring the runtime monitoring phase uses the set of safety sm and liveness lm monitors to analyze the bpel program bas it runs on a bpel speci c application server.
in we have reported on an implementation of a runtime monitoring framework within the ibm websphere business integration products4.
the interception mechanism captures events in as they pass between the application server and the program.
we use them to update the state of the monitors and store them as part of the execution trace t. this process continues until the current event is about to cause the application termination or entering the error state of one of the monitors.
at this point we stop the computation and begin the recovery process.
formally for the lts l b s i we build the trace t s0a0 !s1a1 !
an !sn wheres02iand8i ai2 andsi2s.tis a successful trace i 8ai2sm lm a0a1 an 1is rejected by ai.
thensn t the termination state of the application.
tis afailure or an error trace i 9ai2sm lms.t.a0a1 an 1is accepted by ai.
then state snis called an error state and is denoted by e. note that e can be tas well this occurs when aiis a liveness monitor since absence of a desired sequence is determined when the application terminates.
for example consider the execution of tasin which the customer chooses the air ground option but due to communication problems with the ight system partner the invocation of cftimes out and triggers termination of the application leaving monitor a1in its error state .
this scenario corresponds to the trace t1depicted by dotted transitions in fig.
5a.
in another scenario corresponding to the trace t2 depicted by dashed transitions in fig.
5a the customer attempts to arrive at her destination via an expensive ight index.jsp?tab products businessint expf and a limo bl .
executing this trace leaves monitor a2in its error state .
since the application properties are speci ed separately from the bpel program no code instrumentation is required in this step enabling non intrusive and scalable online monitoring.
.
recovery plans from safety property violations once an error has been detected during runtime monitoring the goal of the recovery phase is to suggest a number ofrecovery plans that would lead the application away from the error.
definition plan .
aplan is a sequence of actions.
abpel recovery plan is a sequence of actions consisting of user interactions compensations empty or not and calls to service partners.
recovery plans di er depending on the type of property that failed.
we treat safety properties below and recovery from liveness properties is described in sec.
.
computing plans.
the recovery procedure for a safety property violation receives lc b the lts of the running application bwith compensations see sec.
.
t the executed trace ending in an error state e see sec.
and c b the set of change states see sec.
.
.
.
in order to recover we need to undo a part of the execution trace executing available compensation actions as speci ed by c. we do this until we either reach a state in c b or the initial state of lc b .
multiple change states can be encountered along the way thus leading to the computation of multiple plans.
for example consider the error trace t2described in sec.
and shown in fig 5a.
f1 18gare the change states seen along t2.
this leads to the recovery plans shown in fig 6a.
we add state names between transitions for clarity and refer to plans as to mean recovery to state s .
a given plan can also become a pre x for the follow on one.
this is indicated by using the former s name as part of the de nition of the latter.
for example recovery to state starts with recovery to state and then includes two more backward transitions the last one with a non empty compensation.
planr18can avoid the error if after its application the user chooses a cheap ight instead of an expensive one.
executing planr15gives the user the option of changing the limousine to a rental car and plan r2 the option of changing from an air ground combination to just renting a car.
both of these behaviours do not cause the violation of a2.
computed plans are then converted to bpel for presentation to the user.
for example plan r18is shown in fig 5c.
the chosen plan can then be applied see sec.
allowing the program to continue its execution from the resulting change state.
the exact number of plans is determined by the number of change states encountered along the trace.
since each new plan includes the previous one the maximum number of plans computed by our tool is set by user preferences either directly compute no more than plans or indirectly compute plans of up to length or compute plans while the overall sum of compensation actions is less than .
discussion.
note that plan r16which cancels the limo would lead to rebooking it right away which may still leavethe possibility of booking an expensive ight and violating the property p2.
the reason why this plan might not be as useful as others is that computation of change states in sec.
.
.
treats all non idempotent service calls as the same whereas not all might be relevant to the satisfaction of properties of interest.
see for a description of computation and evaluation of e ectiveness of relevant change states.
.
recovery plans from liveness property violations failure of a liveness monitor during execution means that some required actions have not been seen before the application tried to terminate and the recovery plan should attempt to perform these actions.
the recovery procedure receives a the monitor that identi ed the violation lc b the lts of the application g b a the set of goal transitions corresponding to a t the executed trace ending in an error state e and c b the set of change states.
a recovery plan e ectively undoes actions along t starting with eand ending in a change state otherwise the plan would not be executable!
and then re plans the behavior to reach the goal see fig.
1b for a schematic view of the overall process .
our solution adapts techniques from the eld of planning described below.
.
recovery as a planning problem aplanning problem is a triplep d i g wheredis the domain iis the initial state and gis a set of goal states.
in addition to p a planner often gets as input k the length of the longest plan to search for and applies various search algorithms to nd a plan of actions of length k starting from iand ending in one of the states in g. typically the plan is found using heuristics and is not guaranteed to be the shortest available.
if no plan is found the bound kcan be increased in order to look for longer plans.
to convert a recovery problem into a planning problem we use lc b as the domain and eas the initial state.
the third component needed is a set of goal states.
recall that g b a is a set of goal transitions .
we de ne gs b a fsj9a s0 s a s0 2g b a g. that is gs b a is a set ofsources of transitions in g b a .
we can now de ne the planning problem p b a t lc b e gs b a note that when a plan pto a goal state sis computed we need to extend it with an additional transition pa !s0to account for s a s0 2g b a .
for example consider the tracet1of fig.
5a described in sec.
in which monitor a1fails.
we de ne the planning problem p tas a1 t1 lc tas f4g where is the initial state see fig.
5a andgs tas a1 f4g see sec.
.
.
.
the resulting plan p should be expanded to prd !
.
unfortunately not every trace returned by solving p b a t is acceptable the recovery plans for liveness violations should also go through change states.
thus we cannot simply use a planner as a black box .
instead we look at how planners encode the planning graph and then manipulate the produced encoding directly to add additional constraints.
consider the lts in fig.
7a which is the planning domain with sas both the initial and the goal state.
the planning graph expanded up to length a r18 !
!
!19cancelf !
r6 r15 !
r16 r18 !17cancell !
r2 r6 !
r15 r16 !
r1 r2 !
b p0 !8cancelf !
!
!2onlycar !
3bc !
p1 !8cancelf !
7bf !8cf !9exptrue !
10expf !11getcar !
12car !13bc !
p2 !8cancelf !
7bf !8cf !9expfalse !
14cheapf !
11getcar !
12car !13bc !
p3 !8cancelf !
7bf !8cf !9expfalse !
14cheapf !
11getcar !
12limo !24bl !
figure recovery plans for tas a plans for the safety violation of trace t2 b plans of length 10for recovery from the liveness violation of trace t1.
a b figure a a simple lts and b its encoding as the planning graph of size .
is shown in fig.
7b and is read as follows at time we begin in states1.
if actionaoccurs modeled as a2 then at time we move to state t modeled as proposition t2becoming true otherwise we remain in state s i.e.
proposition s2 is true .
if action boccurs while we are in state t modeled asb3 then at time we move to state s. two plans of length are extracted from this graph a2 b3 corresponding to executing a rst followed by b and do nothing a planner speci c treatment of a sequence of no ops.
several existing planners such as blackbox translate the planning graph into a cnf formula and then use a sat solver such as sat4j5 to nd a satisfying assignment for it.
such an assignment if found represents a plan.
for example the cnf encoding of the planning graph in fig.
7b is as follows flts no op s2 s1 a2 s1 no op s3 s2 b3 t2 s2 no op s2 t2 a2 no op s3 s3 b3 s3 s1 s3 note that it explicitly models pre and post conditions of the execution of actions.
such a formula is passed to a sat solver which produces a satisfying assignment s if one exists.
the desired plan is extracted from sby taking propositions that correspond to actions and that are assigned positive values in s. for the above example these are a2 b3and do nothing .
in what follows we rst discuss how to produce a single recovery plan using a sat based approach sec.
.
and then show how to extend it to produce multiple plans sec.
.
.
.
producing a single recovery plan letfpbe the encoding of the planning problem p b a t produced by an existing planner.
we augment fpto follow our undo until a change state and then redo approach by adding conjuncts to fpwith the purpose of restricting its solutions.
for e ciency some additional ltering is done after all plans have been computed see sec.
.
.
.
we want to make sure a recovery plan visits at least one of the change states encountered on the execution trace t. lets t be the set of states on t. we de ne c t s t c b to be the change states that appear on tand denote by c1 cnthe propositions that correspond to states in c t .
ifkis the maximum length of the plan which is being searched for propositions cj cj ... cj kcorrespond to expansions of times ... k. for example consider fig.
again.
if tis a change state and k then propositions t1 t2 t3in fltscorrespond to expansions of tto times .
we de ne c c1 1 c1 k cn cn k or in the case of our example c t1 t2 t3 .
this formula is true when at least one of the change states in c t is part of the plan.
.
in order to further lead the planner towards the undo and then redo plans we want to make sure that the only compensations used in the plan correspond to actions in the original trace t. more formally let tcbe the set of compensation actions corresponding to the actions in t and let cntcbe all other compensation actions.
let abe a formula which excludes timed versions of actions in cntc i.e.
neither of these compensation actions is true at any step in the plan.
for example for trace t1over the lts lc tas see fig.
5a formula awould exclude all compensations except cancelf and .
we now build a new propositional formula based on fp r0 fp fp c a r0 fp describes the original planning problem for p b a t and in addition requires that at least one of the change states is visited and no compensation actions for events that did not occur in tappear in the plan.
.
producing multiple recovery plans let 0be the plan produced for r0 fp see sec.
.
leading to a goal state g2gs b a .
to give the user options for recovery we want to produce other plans di erent from .
the simplest way to do this is to remove gfrom g b a and repeat the process described in sec.
.
.
the new plan will necessarily lead to a di erent goal transition and thus will be di erent from .
however this method cannot produce multiple plans to the same destination.
instead we constrain r0 fp to explicitly rule out .
for example to rule out the plan a bfor the lts in fig.
7a we user0 flts computed in sec.
.
and modify it as r1 flts r0 flts a2 b3 this guarantees that the plan if found is di erent from the previously found one in at least one action.
we continue this way restricting ri fp with the set of previously computed plans to get ri fp until the number of desired plans is reached or until no new plan can be found that is rj fp is not satis able for some j. we now apply this method to the tasproblem and the error tracet1shown in fig.
5a and ending in state .
looking for plans up to length we get plans p0 p1andp2shown in fig.
6b.
and as mentioned earlier each plan is extended with the last goal transition 4rd !
.
planp0is the shortest if unable to obtain a price for the ight cancel the ight and reserve the car instead.
plans p1andp2also cancel the ight since is not a change state whereas is and then proceed to re book it and book the car regardless of the ight s cost.
increasing the plan length we also get the option of taking the getcar transition out of state book the car and then the ight.
the produced plans are than ranked based on the length of the plan and the cost of compensation actions in it.
for example plan p0is the shortest and the additional compensation for action carandflight is of zero cost.
thus it is ranked the highest.
of course this plan does not take into account the time the user will spend driving rather than ying so she may choose one of the alternative plans instead.
chosen plans are then converted to bpel for execution.
the compensation part of the plan is similar to the one shown in fig.
5c and the re planning part consists of a sequence of bpel invoke operations.
.
discussion precision.
our treatment of goal transitions e ectively means that we model satisfaction of the required sequence of actions of a liveness property by executing the last event in the sequence.
thus our approach may include some plans that do not result in the satisfaction of the desired property we did not encounter this problem in the examples reported in sec.
.
one way to approach this problem that we intend to investigate in the future is to de ne goal traces based on the computation tree of l b .
while this will lead to the extra precision in plan generation we expect to pay a potentially steep price in performance.
in addition we can aim to limit the number of recovery plans computed by taking two issues into consideration a making sure that the plan goes through only relevant change states i.e.
those that a ect the computation of the violating trace and b removing those plans that result in the violation of one of the safety properties see .
controlling unnecessary compensations.
plansp1 p2 andp3seem to be an unnecessary compensation why cancel a ight and then re book it if the check ight service call failed?
the reason is that the application developer identi ed service call cfas idempotent.
that is she determined that executing this service again cannot change the ow of control of the application and thus further compensations are necessary.
of course every service call can fail and thus none are truly idempotent.
yet having too many change states would undermine the e ectiveness of our framework.
we believe that the tradeo we have made in this paper is reasonable but intend to revisit this issue as we gain more experience with the approach.
furthermore as plan lengths get large the planner can generate plans with compensation loops which involve an action and then immediately un it.
for example in recovering from a violation in trace t1in lts lc tas shown in fig.
5a the plan may include booking a ight and then canceling it several times i.e.
going between states and of lc tas .
clearly such situations should be avoided.
we could have encoded a corresponding formula as the sat problem conjoining it to r0 fp at any point in the plan when a non compensatory action appears all follow on actions should not include compensation .
however we feel that this modi cation should make sat computation signi cantly less e cient.
instead we lter com puted plans so that the ones with compensation loops are not presented to the user.
can generated plans still fail?
there are a number of reasons our plans can fail.
the rst one addressed earlier in this subsection are due to the inherent imprecision of our handling of required event sequences.
the second reason is that any service in the recovery plan can fail thus the application will be unable to reach its goal prompting further planning and recovery.
finally for recovery of safety properties it is possible that all paths from a change state may still lead the application to an error state.
this problem can probably be addressed using additional static analysis.
.
tool support we have implemented the process described in this paper using a series of publicly available tools and several short lines new python or java scripts.
for more information please refer to .
the preprocessing phase see sec.
receives as input a bpel program bin bpel4ws xml format.
we use the ws engineer extension for ltsa to translate binto an lts l b and then export it in the aldebaran format with an extension aut.
since ws engineer does not support full handling of bpel compensations we built our own aut to autpython script add comp py which uses band l b to produce lc b as described in sec.
.
.
traceability between the bpel and the resulting lts is established by the ws engineer s encoding of bpel scopes into names of lts actions.
this traceability allows us to convert computed plans to bpel.
the safety and liveness monitors are speci ed in aldebaran as well and we built a script compute cp pyto compute cross products and identify change states and goal links for them as described in sec.
.
.
the monitoring phase is implemented on top of the ibm websphere process server.
it allows us to intercept events that pass between the application server and the program.
in this phase we also build the trace registering the encountered change states.
when recovering for safety properties we use these states to compute and rank plans.
in the liveness recovery phase we rst use our own script gen plan prob py to translate lc b into a planning problem which starts in the error state eand ends in the source of one of the goal transitions see sec.
.
.
the planning problem is expressed in strips an input language to the planner blackbox which we use to convert it into a cnf formula fp see sec.
.
another new script genplans java modi es fpto produce alternative plans calls the satis ability solver sat4j extracts plans from the satisfying assignments produced by sat4j ranks them and converts them to bpel4ws xml format for displaying and execution.
sat4j is an incremental sat solver i.e.
it saves results from one search and uses them for the next.
for our method of generating multiple plans see sec.
.
where each sat instance is more restricted than the previous one this is particularly useful leading to e cient analysis.
dynamic work ows implemented in ibm websphere integration developer .
allow us to execute the generated plans at runtime.
.
case studies in this section we report on our experience applying ourour approach app.
kvars clauses plans time s length plans fv .
.
.
.
fc .
.
.
.
.
tas .
.
.
table plan generation data.
approach to recover from two known vulnerabilities in the flickr system.
modeled each of the aspects of the system as a nite state machine and showed how to use redundancies in the system in order to work around these vulnerabilities.
a much bigger example of the use of our framework on the travel booking system is reported in .
.
examples flicker visibility.
flickr is a web based photo management application.
photos are initially uploaded as either public family orprivate and a photo s visibility should be changeable anytime using the setperm function.
the identi ed vulnerability is when a photo is initially loaded as private its visibility cannot be changed to family at a later date .
we created the flicker visibility system fv by reverseengineering the model given in and expressing it in bpel.
we then expressed its properties if a user tries to set a photo s visibility to x flickr will guarantee that the photo will have the visibility x where x is each of the possible visibilities as separate liveness automata.
an instance with x family will catch the identi ed vulnerability in the case where a photo is initially loaded as private .
the bpel model fv described fully in consists of activities with explicit compensations .
two of these upload andchange are non idempotent.
converted to lts the resulting model has states and transitions.
flicker comments.
flickr lets users comment on uploaded photos.
while any user can add a comment to a public photo only authorized users can comment on private and family photos.
the identi ed vulnerability is after uploading a photo as public no comments could be added .
using the same process as for fv we created the bpel model fc see consisting of activities with compensations .
the resulting lts model has states and transitions.
we expressed fc s property if a user adds a comment to apublic photo that has comments enabled the comment should be successfully added to the photo s comments as a liveness monitor.
.
experience the number of recovery plans generated for failed traces of fv and fc is shown in table .
for example for the plan length up to we have generated plans for fv.
the longest plan was of length .
we now look at the e ectiveness of the plan generation process.
for fv one of the plans we generate for k is compensate changes in visibility until the photo becomes private again set the photo visibility to public and change visibility to family which corresponds to the workaround plan chosen by .
for fc the plan corresponding to the chosen workaround is delete the problematic comment tog gle the comments permission and then try to add the comment again generated when k .
to compare the precision of our approach i.e.
the number of plans generated we look at the list of workaround sequences computed by see table .
the work in modeled the flickr behavior directly and the model did not include bpel induced actions such as entering scopes.
further the workaround sequences did not include the going back part they were plans on how to execute a task starting from the initial state.
thus the plans we generate are somewhat longer.
for example the workaround sequences of length correspond to our plans of length k .
with this adjustment table shows that we generate signi cantly fewer plans of the corresponding length.
we also generate every plan marked by as desired.
our experience with the flickr examples suggests that combining simple properties with the compensation mechanism is e ective for producing recovery plans.
.
scalability to check whether sat solving done as part of the planning is the bottleneck of our approach we measured sizes of sat problems for fv fc and our running example tas listing them in table .
for all three systems the number of variables and the number of clauses grows linearly with the length of the plan as expected and the running time of the sat solver remains in seconds.
while the web applications we have analyzed have been small e.g.
tas has activities and its lts encoding states and transitions our experience suggests that sat instances used in plan generation remain small and simple and scale well as length of the plan grows.
given that modern sat solvers can often handle millions of clauses and given that individual web services are intended to be relatively compact with tens rather than thousands of partner calls we have a good reason to believe that our approach to plan generation is scalable to realistic systems.
.
related work the main contribution of our work is a recovery framework for web applications via planning.
bertoli et al.
used planning for the synthesis of web service orchestrations .
in contrast we assume the orchestration is given and use planning to help recover when an error is detected.
several works have suggested self healing mechanisms for web service applications.
the dynamo framework uses annotation rules in bpel in order to allow recovery once a fault has been detected.
such rules need to be installed by the developers before the system can function.
in contrast our work uses an existing compensation mechanism and requires no extra e ort from developers.
propose a framework for self healing web services where all possible faults and their repair actions are prede ned in a special registry.
this approach relies on being able to identify and create recovery from all available faults.
our approach uses compensations for individual actions and can dynamically recover from errors as they are detected.
uses fault tolerance patterns to transform the original bpel process into a fault tolerant one at compile time.
it is done by adding redundant behavior to the application which may result in a signi cantly bigger and slower program.
our work is non intrusive and does not slow down the application if no errors are found.the work of carzaniga et al.
is the closest to ours in spirit.
it exploits redundancy in web applications to nd workarounds when errors occur assuming that the application is given as a nite state machine with an identi ed error state as well as the fallback state to which the application should return.
the approach generates all possible recovery plans without prioritizing them.
in contrast our framework not only detects runtime errors but also calculates goal and change states and in addition automatically lters out unusable recovery plans those that do not include change states and ranks the remaining ones.
see sec.
for a detailed comparison.
.
conclusion and future work in this paper we have used bpel s compensation mechanism to de ne and implement an online system for suggesting ranking and executing recovery plans.
our experience has shown that this approach computes a small number of highly relevant plans so quickly and e ectively.
we have evaluated our approach on relatively small and simple examples.
while we expect web service applications to be small it is still important to conduct further case studies to assess scalability and more importantly usability of our approach.
furthermore throughout the paper we have identi ed several precision issues related to the identi cation of goals and change states.
we intend to apply static analysis techniques to help improve it and conduct further experiments to better understand the tradeo s between the more expensive analyses and the e ective computation of recovery plans.
some preliminary work towards this end is reported in .
another limitation of our approach is that we model compensations as going back to states visited earlier in the run.
while this model is simple clean and enables e ective analysis the compensation mechanism in languages like bpel allows the user to execute an arbitrary operation and thus end up in a principally di erent state.
in fact our approach will encounter this situation as soon as we start modeling data in addition to control.
for example if we model the amount of money the user has as part of the state then booking and then canceling a ight brings her to a di erent state the one where she has less money and no ight.
thus extending our framework to situations where compensation a ects data remains a challenge.
in fact reasoning about properties which involve the actual data exchanged by conversation participants may be challenging from the perspective of expressing the properties and converting them into monitoring automata as well as from the scalability perspective e.g.
computing the goal links expressing the formal model of bpel with data as a state machine etc.
.