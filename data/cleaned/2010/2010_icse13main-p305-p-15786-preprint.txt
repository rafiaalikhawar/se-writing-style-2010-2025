coupling software architecture and human architecture for collaboration aware system adaptation christoph dorn distributed systems group vienna university of technology austria dorn infosys.tuwien.ac.atrichard n. taylor institute for software research university of california irvine usa cdorn taylor uci.edu abstract the emergence of socio technical systems characterized by significant user collaboration poses a new challenge for system adaptation.
people are no longer just the users of a system but an integral part.
traditional self adaptation mechanisms however consider only the software system and remain unaware of the ramifications arising from collaboration interdependencies.
by neglecting collective user behavior an adaptationmechanismisunfittoappropriatelyadapttoevolution of user activities consider side e ffects on collaborations during the adaptation process or anticipate negative consequence up on reconfiguration completion.
inspired by existing architecture centric system adaptation approaches weproposelinkingtheruntimesoftwarearchitectur e to the human collaboration topology.
we introduce a mapping mechanism and corresponding framework that enables a system adaptation manager to reason upon the e ffect of software level changes on human interactions and vice versa.
we outline the integration of the human architecture in the adaptation process and demonstrate the benefit of our approach in a case study.
index terms collaboration topology software architecture runtime mapping architecture reconfiguration dynamic adaptation i. introduction in northrop et al.
identified ultra large scale uls systems as the major future software engineering chal lenge.
among the defining characteristics of uls systems are decentralized control conflicting and changing requireme nts continuous evolution heterogeneous and dynamic system el ements ubiquitous failures and erosion of the people system boundary.
this paper focuses primarily on the implication o f that last aspect on system self adaptation.
people are no longer just the users of a system but an integral part p1 .
consequently human interactions are highly relevant to the design and adaptation of uls systems p31 ff .
we believe that this is true not only for uls systems but also for traditional medium and large scale systems.
any system heavily relying upon significant user collaboration needs to explic itly addresshumaninteractionimplicationsduringdesign tim eand runtime.
among the many adaptation approaches architecture drive n techniques appear to be the most applicable to systems exhibiting uls characteristics.
kramer and magee arguethat an architecture based approach provides i concepts and principles applicable across domains ii su fficient abstraction from the algorithmic and network level while still capturin g dynamic change and iii scalability through hierarchica l composition thereby facilitating the specification of sys tems of systems.
in addition architecture driven adaptation t echniques are among the earliest and continuously relevant approaches as demonstrated by successful application t o mobile environments robotics systems and adaptiv e service compositions .
current architecture driven adaptation mechanisms however consider only the software system and remain unaware o f the ramifications arising from collaboration interdepende ncies.
a system neglecting the collective user behavior might su ffer from some of the following example weaknesses the system is unable to support the e fficient operation and evolution of user behavior.
for example failing to provide appropriate coordination mechanisms when groups of users change their behavior from sequential resource access to simultaneous resource access.
conversely the system cannot anticipate the consequences of particular software adaptations.
disregarding for example user proximity user role or user capacity might result in reconfigurations that jeopardize a team s performance due to increasing the likelihood of information overload information delay information scarcity o r resource access conflicts.
likewise thesystemisunabletoreasonaboutside e ffects during the software reconfiguration process.
a database schema update for example might have the implicit assumption that humans are in a state of quiescence upon commencing an update potentially interrupting all ongoing interactions.
the system remains unaware of users becoming bottlenecks.
unavailable or overloaded users slow down critical processes when they are responsible for manually triggering key tasks.
we propose linking the system s software architecture to humaninteractions.specificallywedescribethesystem su sers978 c ieee icse san francisco ca usa accepted for publication by ieee.
c ieee.
personal use of this material is permitted.
permission from ieee must be obtained for all other uses in any current or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for resale or redistribution to servers or lists or reuse of any copyrighted component of this work in other works.53in terms of human components and collaboration connectors along with their means of communication and coordination.
to this end we apply the human architecture description language hadl introduced in our previous work for specifying a system s underlying collaboration topology and the extensible architecture description language xadl for specifying the software architecture.
explicit non tr ivial design time mappings between hadl and xadl elements allow during runtime the matching of software component and connector instances to users and their interactions.
adaptation rules can subsequently utilize the hadl model for example for prioritizing the replication of component s associated with key collaborators.
the main contributions of this paper are a model for mapping from software architecture to human collaboration patterns and vice versa a framework for detecting runtime software architecture changes andreflectingthosechanges inthehumancollaboration topology according to the predefined mappings.
a discussion on integrating human architecture and software architecture for system adaptation.
a case study demonstrating the benefit of turning software architecture centric self adaptation strategies to be collaboration aware.
the remainder of this paper is structured as follows.
sectioniiandiiiprovideamotivationscenarioandadiscussio nof related work respectively.
section iv summarizes backgro und information an overview of our approach and the architect ure mapping rationale.
section v details the design time mappi ng specification and the runtime mapping process.
we discuss th e application of our framework for collaboration aware syst em self adaptation in section vi.
a case study in section vii demonstrates actual adaptation benefits.
finally section viii gives an outlook on future work and concludes this paper.
ii.
motivating scenario monitoring and safety systems range in scope from a small security team handling an o ffice building to thousands of personnel in back o ffices and on site at geographically distributed locations to secure critical infrastructure.
these systems tightly interweave people and software components and hence need co adaptation of collaboration structures a nd software architectures.
in the building monitoring case b ack office operators utilize high definition video streams floor plans building sensor feeds occupancy logs and communic ation channels with on site security sta ff.
reassigning observation tasks among team members reacting to non responding team members or adding new team members are examples of collaboration driven adaptations that result in changes t o the underlying software structure.
the adaptation mechanism needs to react to software level events such as failing components congested data links an d emergence of new information sources.
at the same time it requires maintenance of various qos metrics such as acceptable video delay video stream availability and bandwidth costthrough continuous adaptation of video relay replication a nd video stream rerouting.
in the presence of scarce resources the adaptation mechanism has to prioritize the adaptation of particular relays and video streams.
to this end it requires awareness of the collaboration topology and user roles.
consider the softwa re architecture in figure consisting of components for strea mingservers videosources guis for each role and connecto rs for coordinating video publishing subscribing and deliv ering activities.
this architecture may serve as the underlyi ng communication infrastructure for two quite distinct coll aboration topologies fig.
and fig.
.
the publish subscribe human architecture in figure specifies the following human components fieldagents provide video streams pubstreams whereasbackoffice agents assistants andteam leaders subscribe to video streams substreams .videopubsub collaboration connectors typically but not necessarily implement ed as software entities manage video stream publication and subscription.
video feeds may be replicated across multipl e videopubsub connectors in accordance with the software architecture.
all users have access to a wallscreen a collaboration object of type shared artifact for displaying rele vant video streams.
the collaboration topology in figure lacks such a flat organizational hierarchy and instead features a pipes filters style collaboration structure.
individual agents receivetheirvideofeedsasdeemedrelevantbytheirpredeces sor.
a backoffice agent for example routes a pipestream to an assistant.
ultimately only the team leader has access to the wallscreen.
suppose an adaptation mechanism reconfigures the software architecture to maintain system reliability by avoidi ng individual streamingservers from becoming overloaded.
si multaneously it should ensure that the team leader has the most reliable streams.
without a mapping between software and collaboration structure it would be unable to make an informed decision between adaptation action replicate team leader video streams suitable for the human architecture in fig.
or action equal component replication along the video relay chain suitable for the human architecture in fig.
.
we will be using these configurations throughout the paper fo r explaining the mapping process at runtime and design time the adaptation process and the final evaluation.
iii.
relatedwork our work builds on the insights of architecture based adaptation research.
as early as orzeiy et al.
outlined the process for reflecting runtime changes in an architectural model as the basis for dynamic adaptation.
subsequent work focused predominately on architecture based adaptat ion techniques such as the rainbow framework the kcomponent architecture meta model model based development or object oriented design adaptation .
in line with such previous work our framework also features an architecture runtime manager and the adaptation mechanism follows the feedback loop described by the autonomic54fig.
.
software architecture surveillance video monitor ing.
fig.
.
collaboration architecture publish subscribe style surveillance team.
information flows from le ft to right along collaboration links.
each link connects two collaboration actions letter abbreviated send forward receive display .
fig.
.
collaboration architecture pipes filters style surveillance team.
information flows from left to right along collaboration links.
each link connects two collaboration actions letter abbreviated send forward receive display .
computing mape k model monitoring analysis planning execution and knowledge.
as we pointed out in the introduction these techniques focus exclusively on adapting the software architecture.
u ser preferencesandusercontextdriveadaptationinmobilesce narios e.g.
the madam architecture model but the applied techniques still remain unaware of collaboration dependen cies.
the novel aspect of our research is mapping the human architecture hadl to the software architecture xadl at designtimeandruntime.aswewilldemonstrateinsectionvi having two distinct but constantly synchronized views on t he system gives rise to unique adaptation opportunities.
note that linking of the xadl and hadl architecture models should not be mistaken for the three layer architect uremodel typically applied for self adaptation in the ro botics domain .
the three layer model describes a strict hierar chical separation of goal management change management and change execution.
in contrast we propose to apply software architecture and human architecture simultaneously acros s all steps of the mape k model.
enhancing software architecture models with domain specific properties enables analysis beyond structural consis tency.
edwards and medvidovic apply multi model composition in their xteam framework to simulate reliability power consumption and performance.
di ruscio et al.
utilize model mapping and transformation techniques for integrating multiple architecture concerns e.g.
fault tolerance and activity flow .
the sassy framework provides service55activity schemas and service sequence scenarios to specify qos requirements in service oriented architectures.
fina lly bhave et al.
augment software architectures with physical properties and behavioral annotations thus enabling an integrated specification of cyber physical systems such as quadrotors.
the main di fference compared to our approach is the extremely tight coupling of the various architectura l views such that no separate mapping and tracing is foreseen or required during runtime.
the business process modeling domain traditionally included some aspects of human involvement.
business process model and notation bpmn consists of constructs for describing activities in business processes their depend encies artifacts and involved events.
bpmn processes typically m ap to bpel the business process execution language for execution.
the bpel4people extension utilizes human tasks for integrating users into otherwise web service bas ed workflows.
human tasks support assignment to generic roles ownership delegation and coordination mechanisms such as four eyes nomination orescalation .
both languages primarily target service oriented architectures with limite d or no support for other common architectural styles such as peer to peer components and connectors c2 or publishsubscribe.
likewise support for collaboration is limited to isolated execution of individual task items from a work list .
dynamic patterns for joint work on shared artifacts publis hsubscribe information distribution organizational cont rol or request routing in social networks and thus also the pattern s adaptation implications remain outside the scope of bpmn and bpel.
the human provided service framework hps offers more flexible user collaboration but lacks support for structural patterns at the human level and the software level.
as a final note for clarification and caution we cannot rely on insights from conway s law or socio technical congruence when describing the mapping between collaboration structure and software architecture.
we model t he structure of the users organization rather than the develo pers organization.
iv.
approach a. background we first proposed linking software architecture and human collaboration models in our icse new ideas and emerging results track paper .
it describes the general idea and approach to achieve co adaptation and introduces basic concepts.
in this paper we focus in detail on the models and mechanism for reflecting runtime software architecture changes in collaboration topologies and how to apply these synchronized views for sophisticated system adaptation.
the co adaptation of software architecture and human collaboration requires models for specifying the involved run time elements and their relations.
components and connectors are the primary building blocks of a software architecture.
components are the loci of computation and data management whereas connectors facilitate and control the interac tionsbetween components.
based upon malone and crowston s observation that human collaboration and software systems share similar coordination requirements we argue for a similar distinction among humans according to workfocused and coordination focused roles.
along these lines we recently introduced the human architecture description language hadl for describing collaboration topologies in terms of human components and collaboration connectors see fig.
and fig.
for examples .
software architecture a nd human architecture models are thus the core artifacts of our approach.
mape steps adaptation knowledge runtime mapping runtime systemsoftware architecturemapping templatescollaboration topologyhuman architecture domain specific probes sensorsref ref software artifactsrefref monitoringanalysisplanningexecutiondesign time runtime runtime sw architecture fig.
.
reflecting software architecture changes in the human architecture for collaboration aware system adaptation.
b. mapping and adaptation overview given the software architecture and human architecture description a software architect specifies at design time how software elements map to collaboration elements and viceversa.
software architecture centric events are the prima ry source for creating a runtime view of the overall system.
our approach aims to leverage these events as much as possible fo r inferring the collaboration topology fig.
middle .
the m apping specification identifies configurations where software centric events are insu fficient.
an event for example may describe a new link between an agentgui component and a streamingserver component hosting multiple video streams .
while such an event provides su fficient information at the software architecture level additional information is re quired to unambiguously connect the respective human agent to a particular substream.
we thus embed not only software archi tecture but also human architecture and mapping specificati on in the software artifacts fig.
left .
system adaptation typically requires additional domainspecific events besides architecture centric changes.
whil e independent from the software architecture and collaborat ion topology suchinformationdescribesruntimesoftwareand collaboration elements in further detail.
eventually an adap tation56manager utilizes the runtime software architecture runti me mapping and collaboration topology in each adaptation ste p monitoring analysis planning and execution to detect and react to critical situations fig.
right .
c. the case for an explicit architecture mapping multiple generic extensible and domain specific architecture description languages already exist e.g.
acme xadl and one could argue that collaboration structures should be embedded at the software architecture level.
there are multiple reasons however why a separate human architecture model and thus an explicit non trivia l mapping is a better choice collaboration patterns are su fficiently independent from their implementing software architecture style and even more so from the detailed software topology.
for example a collaboration system for a rescue task force can be realized as a peer to peer system for environments without a communication infrastructure.
alternatively the client server style is suitable when a reliable communication infrastruc ture is available.
a collaboration pattern based on supervisors assigning tasks to workers and subsequently collecting the ir feedback however remains in both cases the same.
similarl y the same software architecture style supports di fferent collaboration patterns as demonstrated in the motivating scenario in section ii.
software architectures are typically more fine grained tha n collaboration structures.
spreading collaboration struc ture descriptions as annotations across software elements make s it hard to obtain a clear picture of the overall human architecture.
structural changes at the collaboration level rarely correspond to structurally equivalent changes at the softw are level and vice versa.
hence collaboration changes would remain unnoticed in the software structure while software topology changes would require additional analysis whethe r the human architecture remained the same.
adaptation relevant properties potentially fit more natura lly with hadl elements and thus allow for devising more understandable and manageable adaptation triggers analy sis logic and adaptation strategies.
an explicit human architecture keeps the focus on the user and team perspective and thus gives stake holders an additional model for communicating requirements during th e design process.
this also enforces a structured approach to explicitly defining adaptation and evolution capabilities at the collaboration level.
v. thearchitecture mappingprocess a. design time mapping specification synchronizing software architecture and collaboration topology at runtime requires the software architect to spec ify how software elements map to collaboration elements and vice versa.
our framework utilizes the extensible architec ture description language xadl for describing softwarecomponent types connector types interface types and con tainment hierarchies.
on the collaboration level we apply the human architecture description language hadl for specifying human component types collaboration connecto r types collaboration object types collaboration action t ypes and substructure patterns.
large scale systems are typically too dynamic and complex for completely specifying all involved elements and their precise wiring at design time.
thus we can neither a prior i fully describe the runtime software structure in xadl nor the collaboration topology in hadl.
consequently we first define templates that specify for xadl and hadl separately how the various model elements are correctly assembled and connected at runtime.
for example figure displays on the left a software architecture blueprint for connecting vide o sources connectors streaming server and video sinks.
th e dotted frames and lines represent individual templates.
th e corresponding collaboration topology and templates for th e publish subscribe human collaboration pattern are given on the right.
we subsequently need additional mapping informa tion to identify which xadl template corresponds to what hadl template dash dotted lines in figure .
in other words a set of xadl respectively hadl templates behaves similar to a set of jigsaw pieces we arrange all pieces according to their shape i.e.
signatures actions and obtain a valid overall picture i.e.
architecture .
to know which two xadl and hadl pieces go together and where they are supposed to interlock within their respective puzz le we also need to define matching tabs blanks i.e.
an interlock point pair .
see for example the two jigsaw pieces for the mapping specification in fig.
left.
given a software architecture blueprint and collaboration pattern as input a complete software to collaboration ma pping specification thus consists of four main parts a set ofxadl elements e.g.
a streamingserver component publishvideo connector subscribevideo connector and li nks from both connectors to the component .
the specification refers to the architecture blueprint elements and not the ac tual element type definition.
a type potentially occurs multiple times in a template such as the receivevideoagent connector and receivevideowallscreen connector which are both derived from the receivevideo connector type.
a set ofhadl elements e.g.
videopubsub collaboration connector substream collaboration object and the link be tween .
a set ofinterlock point pairs defines the intersection of two mappings in the software architecture and where to locate t he corresponding interlink at the human architecture level.
a single interlock point pair identifies exactly one xadl interface and exactly one hadl collaboration action.
the xadl interface establishes joint points of two xadl puzzle pieces the hadl action specifies the joint points between tw o hadl puzzle pieces.
consider the mapping template x1h1 in fig.
the videosource s sendpubstream interface pairs up with the pubstream s forwardaction.
themappingtype determines how many instances of the57fig.
.
example mappings between video streaming architecture blueprint xadl and publish subscribe collaboration pattern hadl .
mapping for example consists of xadl element set x1 and hadl element set h1.
mappings for assistant and teamleader and corresponding xad l elements are omitted for sake of clarity.
xadl elements may map to how many instances of the hadl elements.
in many cases a simple one to one mapping will be insufficient.
a xadl template instance e.g.
a streamingserver incl.
connectors may represent multiple hadl elements e.g.
videopubsub collaboration connectors inc l. substreams .
hence the following mapping types exist exa ct to 1such as the videosource to fieldagent pubstream e.g.
x1h2 infig.
aggregating to m e.g.
x3h3 infig.
replicating n to 1for providing the same video stream on many servers or a combination thereof n to m .
note that the mapping specification includes only elements that are needed to maintain an unambiguous mapping to collaboration elements.
thus a software architect typically omits software elements irrelevant to the collaboration topolog y and vice versa e.g.
the link between the agentgui component and the subscribevideo connector .
for the example in figure a total of mapping definitions link the software architecture and the collaboration structure including t he six mappings for assistant and teamleader not shown .
our framework leverages software architecture centric events as much as possible.
however we determine the need for additional disambiguation events already at design time when we derive from the mapping specification that softwarelevel events won t allow for conclusive mapping execution at runtime.
at runtime the link between a videosource component and a publishvideo connector for example maps to mto the pubstream to videopubsub link mapping x5h5 in fig.
.
here we need a disambiguation event to define which videopubsub among the many hosted by the streamingserver the hadl link should connect to.
applying the jigsaw analogy non to 1mappings result in stacked puzzle pieces for example mapping instances 1a and 1b in figure .
a new mapping instance 4needs to decide whether linking its hadl piece to mapping 1aor1b.
a disambiguation event merely needs to identify any one xadl element involved in the completed hadl piece 4xand any one hadl element from the targeted existing hadl piece 1a.identifying at design time where disambiguation events ar e required is straightforward every interlock pointpair in volved in a1 to morn to mmapping highlights the need for a corresponding disambiguation event.
the developer can the n select from the hadl and xadl sets which information will be provide in the disambiguation event.
before system deployment type information from xadl and hadl models and disambiguation event requirements become embedded in the software artifacts.
the exact means e.g.
through sour ce code annotations middleware configuration or sensor configuration remains outside the scope of this paper see for example .
mapping specification x x x4 x4 h3 h21comp obj conn comph x2 h h ?hadl part1a1b new mapping instance xadl part interlock pointpair a interlock pointpair b fig.
.
utilizing interlock point pair definitions to insert hadl and xadl mappings correctly.
b. runtime template matching and execution atruntime the softwarearchitecturemanager receivessystem events describing the type and identity of newly deploye d software elements their wiring respectively their termi nation and translates them into software architecture change even ts i.e.
new deleted component connector link fig.
.
for removal of existing elements the mapping template matcher takes these architecture change events and merely retrieves the respective mapping instance fig.
2a .
for n ew elements however it determines a set of candidate mapping s fig.
2b .
each xadl element type is potentially part of58fig.
.
artifacts and steps involved in the mapping template m atching process.
multiple mapping definitions e.g.
the link between stream ingserver and receivevideo connectors is of the same type fo r agentgui assistantgui teamleadergui and wallscreen but ultimately only part of a single mapping instance.
the mapping template matcher keeps adding architecture change events to mapping candidates until at least one candidate contains all required xadl elements fig.
3a .
all remaining candidates are discarded.
matching of interlock po int pairs with existing neighboring mappings selects the corre ct mapping in case of multiple simultaneously fulfilled mappin g candidates fig.
3b .
for each completed mapping specification and su fficient disambiguation data the mapping template matcher dispatches collaboration change events for each mapped hadl element fig.
4a .
when adding new elements a runtime mapping instance stores